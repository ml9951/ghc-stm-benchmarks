
==================== Cmm produced by new codegen ====================
2015-11-09 18:21:44.49318 UTC

[section "data" { __stginit_main@main:SkipList:
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:44.493602 UTC

[section "data" { __stginit_main@main:SkipList:
 }]


==================== Output Cmm ====================
2015-11-09 18:21:44.493855 UTC

[section "data" { __stginit_main@main:SkipList:
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:44.506906 UTC

[section "data" {
     SkipList.newSL6_closure:
         const SkipList.newSL6_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     caKK_str:
         I8[] [110,101,119]
 },
 SkipList.newSL6_entry() //  [R1]
         { info_tbl: [(caKL,
                       label: SkipList.newSL6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caKL:
           _rd::P64 = R1;
           goto caKF;
       caKF:
           if ((old + 0) - <highSp> < SpLim) goto caKM; else goto caKN;
       caKN:
           if (HpLim == 0) goto caKM; else goto caKO;
       caKM:
           R1 = _rd::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caKO:
           (_caKH::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rd::P64);
           if (_caKH::I64 == 0) goto caKJ; else goto caKI;
       caKJ:
           call (I64[_rd::P64])() args: 8, res: 0, upd: 8;
       caKI:
           I64[(old + 24)] = stg_bh_upd_frame_info;
           I64[(old + 16)] = _caKH::I64;
           R2 = caKK_str;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:44.509416 UTC

{offset
  caKL:
      _rd::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto caKM; else goto caKN;
  caKN:
      if (HpLim == 0) goto caKM; else goto caKO;
  caKM:
      R1 = _rd::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caKO:
      (_caKH::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rd::P64);
      if (_caKH::I64 == 0) goto caKJ; else goto caKI;
  caKJ:
      call (I64[_rd::P64])() args: 8, res: 0, upd: 8;
  caKI:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _caKH::I64;
      R2 = caKK_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:44.510535 UTC

{offset
  caKL:
      _rd::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto caKM; else goto caKN;
  caKN:
      if (HpLim == 0) goto caKM; else goto caKO;
  caKM:
      R1 = _rd::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caKO:
      (_caKH::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rd::P64);
      if (_caKH::I64 == 0) goto caKJ; else goto caKI;
  caKJ:
      call (I64[_rd::P64])() args: 8, res: 0, upd: 8;
  caKI:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _caKH::I64;
      R2 = caKK_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:44.511655 UTC

{offset
  caKL:
      _rd::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto caKM; else goto caKN;
  caKN:
      if (HpLim == 0) goto caKM; else goto caKO;
  caKM:
      R1 = _rd::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caKO:
      (_caKH::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rd::P64);
      if (_caKH::I64 == 0) goto caKJ; else goto caKI;
  caKJ:
      call (I64[_rd::P64])() args: 8, res: 0, upd: 8;
  caKI:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _caKH::I64;
      R2 = caKK_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:44.512892 UTC

{offset
  caKL:
      _rd::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto caKM; else goto caKN;
  caKN:
      if (HpLim == 0) goto caKM; else goto caKO;
  caKM:
      R1 = _rd::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caKO:
      (_caKH::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rd::P64);
      if (_caKH::I64 == 0) goto caKJ; else goto caKI;
  caKJ:
      call (I64[_rd::P64])() args: 8, res: 0, upd: 8;
  caKI:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _caKH::I64;
      R2 = caKK_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:44.514021 UTC

{offset
  caKL:
      _rd::P64 = R1;
      if ((Sp + -16) < SpLim) goto caKM; else goto caKN;
  caKN:
      if (HpLim == 0) goto caKM; else goto caKO;
  caKM:
      R1 = _rd::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caKO:
      (_caKH::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rd::P64);
      if (_caKH::I64 == 0) goto caKJ; else goto caKI;
  caKJ:
      call (I64[_rd::P64])() args: 8, res: 0, upd: 8;
  caKI:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _caKH::I64;
      R2 = caKK_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:44.51532 UTC

[(caKI, {}), (caKJ, {}), (caKL, {}), (caKM, {}), (caKN, {}),
 (caKO, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:44.515709 UTC

SkipList.newSL6_entry() //  [R1]
        { info_tbl: [(caKL,
                      label: SkipList.newSL6_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caKL:
          _rd::P64 = R1;
          if ((Sp + -16) < SpLim) goto caKM; else goto caKN;
      caKN:
          if (HpLim == 0) goto caKM; else goto caKO;
      caKM:
          R1 = _rd::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      caKO:
          (_caKH::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rd::P64);
          if (_caKH::I64 == 0) goto caKJ; else goto caKI;
      caKJ:
          call (I64[_rd::P64])() args: 8, res: 0, upd: 8;
      caKI:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _caKH::I64;
          R2 = caKK_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:44.517114 UTC

SkipList.newSL6_entry() //  [R1]
        { info_tbl: [(caKL,
                      label: SkipList.newSL6_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caKL:
          _rd::P64 = R1;
          if ((Sp + -16) < SpLim) goto caKM; else goto caKN;
      caKN:
          if (HpLim == 0) goto caKM; else goto caKO;
      caKM:
          R1 = _rd::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      caKO:
          (_caKH::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rd::P64);
          if (_caKH::I64 == 0) goto caKJ; else goto caKI;
      caKJ:
          call (I64[_rd::P64])() args: 8, res: 0, upd: 8;
      caKI:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _caKH::I64;
          R2 = caKK_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:44.518506 UTC

[section "data" {
     SkipList.newSL6_closure:
         const SkipList.newSL6_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     caKK_str:
         I8[] [110,101,119]
 },
 SkipList.newSL6_entry() //  [R1]
         { info_tbl: [(caKL,
                       label: SkipList.newSL6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caKL:
           _rd::P64 = R1;
           if ((Sp + -16) < SpLim) goto caKM; else goto caKN;
       caKN:
           if (HpLim == 0) goto caKM; else goto caKO;
       caKM:
           R1 = _rd::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caKO:
           (_caKH::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rd::P64);
           if (_caKH::I64 == 0) goto caKJ; else goto caKI;
       caKJ:
           call (I64[_rd::P64])() args: 8, res: 0, upd: 8;
       caKI:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caKH::I64;
           R2 = caKK_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:44.520216 UTC

[section "data" {
     SkipList.newSL6_closure:
         const SkipList.newSL6_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     caKK_str:
         I8[] [110,101,119]
 },
 SkipList.newSL6_entry() //  [R1]
         { info_tbl: [(caKL,
                       label: SkipList.newSL6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caKL:
           _rd::P64 = R1;
           if ((Sp + -16) < SpLim) goto caKM; else goto caKN;
       caKN:
           if (HpLim == 0) goto caKM; else goto caKO;
       caKM:
           R1 = _rd::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caKO:
           (_caKH::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rd::P64);
           if (_caKH::I64 == 0) goto caKJ; else goto caKI;
       caKJ:
           call (I64[_rd::P64])() args: 8, res: 0, upd: 8;
       caKI:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caKH::I64;
           R2 = caKK_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:44.525149 UTC

[section "data" {
     SkipList.newSL7_closure:
         const GHC.Types.I#_static_info;
         const 495;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:44.525535 UTC

[section "data" {
     SkipList.newSL7_closure:
         const GHC.Types.I#_static_info;
         const 495;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:44.525848 UTC

[section "data" {
     SkipList.newSL7_closure:
         const GHC.Types.I#_static_info;
         const 495;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:44.526463 UTC

[section "data" {
     SkipList.newSL8_closure:
         const SkipList.newSL8_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     caL3_str:
         I8[] [46,47,68,97,116,97,47,86,101,99,116,111,114,47,71,101,110,101,114,105,99,47,77,117,116,97,98,108,101,46,104,115]
 },
 SkipList.newSL8_entry() //  [R1]
         { info_tbl: [(caL4,
                       label: SkipList.newSL8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caL4:
           _rq::P64 = R1;
           goto caKY;
       caKY:
           if ((old + 0) - <highSp> < SpLim) goto caL5; else goto caL6;
       caL6:
           if (HpLim == 0) goto caL5; else goto caL7;
       caL5:
           R1 = _rq::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caL7:
           (_caL0::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rq::P64);
           if (_caL0::I64 == 0) goto caL2; else goto caL1;
       caL2:
           call (I64[_rq::P64])() args: 8, res: 0, upd: 8;
       caL1:
           I64[(old + 24)] = stg_bh_upd_frame_info;
           I64[(old + 16)] = _caL0::I64;
           R2 = caL3_str;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:44.528655 UTC

{offset
  caL4:
      _rq::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto caL5; else goto caL6;
  caL6:
      if (HpLim == 0) goto caL5; else goto caL7;
  caL5:
      R1 = _rq::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caL7:
      (_caL0::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rq::P64);
      if (_caL0::I64 == 0) goto caL2; else goto caL1;
  caL2:
      call (I64[_rq::P64])() args: 8, res: 0, upd: 8;
  caL1:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _caL0::I64;
      R2 = caL3_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:44.529764 UTC

{offset
  caL4:
      _rq::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto caL5; else goto caL6;
  caL6:
      if (HpLim == 0) goto caL5; else goto caL7;
  caL5:
      R1 = _rq::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caL7:
      (_caL0::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rq::P64);
      if (_caL0::I64 == 0) goto caL2; else goto caL1;
  caL2:
      call (I64[_rq::P64])() args: 8, res: 0, upd: 8;
  caL1:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _caL0::I64;
      R2 = caL3_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:44.533995 UTC

{offset
  caL4:
      _rq::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto caL5; else goto caL6;
  caL6:
      if (HpLim == 0) goto caL5; else goto caL7;
  caL5:
      R1 = _rq::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caL7:
      (_caL0::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rq::P64);
      if (_caL0::I64 == 0) goto caL2; else goto caL1;
  caL2:
      call (I64[_rq::P64])() args: 8, res: 0, upd: 8;
  caL1:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _caL0::I64;
      R2 = caL3_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:44.535277 UTC

{offset
  caL4:
      _rq::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto caL5; else goto caL6;
  caL6:
      if (HpLim == 0) goto caL5; else goto caL7;
  caL5:
      R1 = _rq::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caL7:
      (_caL0::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rq::P64);
      if (_caL0::I64 == 0) goto caL2; else goto caL1;
  caL2:
      call (I64[_rq::P64])() args: 8, res: 0, upd: 8;
  caL1:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _caL0::I64;
      R2 = caL3_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:44.536397 UTC

{offset
  caL4:
      _rq::P64 = R1;
      if ((Sp + -16) < SpLim) goto caL5; else goto caL6;
  caL6:
      if (HpLim == 0) goto caL5; else goto caL7;
  caL5:
      R1 = _rq::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caL7:
      (_caL0::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rq::P64);
      if (_caL0::I64 == 0) goto caL2; else goto caL1;
  caL2:
      call (I64[_rq::P64])() args: 8, res: 0, upd: 8;
  caL1:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _caL0::I64;
      R2 = caL3_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:44.537662 UTC

[(caL1, {}), (caL2, {}), (caL4, {}), (caL5, {}), (caL6, {}),
 (caL7, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:44.53804 UTC

SkipList.newSL8_entry() //  [R1]
        { info_tbl: [(caL4,
                      label: SkipList.newSL8_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caL4:
          _rq::P64 = R1;
          if ((Sp + -16) < SpLim) goto caL5; else goto caL6;
      caL6:
          if (HpLim == 0) goto caL5; else goto caL7;
      caL5:
          R1 = _rq::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      caL7:
          (_caL0::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rq::P64);
          if (_caL0::I64 == 0) goto caL2; else goto caL1;
      caL2:
          call (I64[_rq::P64])() args: 8, res: 0, upd: 8;
      caL1:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _caL0::I64;
          R2 = caL3_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:44.539372 UTC

SkipList.newSL8_entry() //  [R1]
        { info_tbl: [(caL4,
                      label: SkipList.newSL8_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caL4:
          _rq::P64 = R1;
          if ((Sp + -16) < SpLim) goto caL5; else goto caL6;
      caL6:
          if (HpLim == 0) goto caL5; else goto caL7;
      caL5:
          R1 = _rq::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      caL7:
          (_caL0::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rq::P64);
          if (_caL0::I64 == 0) goto caL2; else goto caL1;
      caL2:
          call (I64[_rq::P64])() args: 8, res: 0, upd: 8;
      caL1:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _caL0::I64;
          R2 = caL3_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:44.540726 UTC

[section "data" {
     SkipList.newSL8_closure:
         const SkipList.newSL8_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     caL3_str:
         I8[] [46,47,68,97,116,97,47,86,101,99,116,111,114,47,71,101,110,101,114,105,99,47,77,117,116,97,98,108,101,46,104,115]
 },
 SkipList.newSL8_entry() //  [R1]
         { info_tbl: [(caL4,
                       label: SkipList.newSL8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caL4:
           _rq::P64 = R1;
           if ((Sp + -16) < SpLim) goto caL5; else goto caL6;
       caL6:
           if (HpLim == 0) goto caL5; else goto caL7;
       caL5:
           R1 = _rq::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caL7:
           (_caL0::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rq::P64);
           if (_caL0::I64 == 0) goto caL2; else goto caL1;
       caL2:
           call (I64[_rq::P64])() args: 8, res: 0, upd: 8;
       caL1:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caL0::I64;
           R2 = caL3_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:44.542441 UTC

[section "data" {
     SkipList.newSL8_closure:
         const SkipList.newSL8_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     caL3_str:
         I8[] [46,47,68,97,116,97,47,86,101,99,116,111,114,47,71,101,110,101,114,105,99,47,77,117,116,97,98,108,101,46,104,115]
 },
 SkipList.newSL8_entry() //  [R1]
         { info_tbl: [(caL4,
                       label: SkipList.newSL8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caL4:
           _rq::P64 = R1;
           if ((Sp + -16) < SpLim) goto caL5; else goto caL6;
       caL6:
           if (HpLim == 0) goto caL5; else goto caL7;
       caL5:
           R1 = _rq::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caL7:
           (_caL0::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rq::P64);
           if (_caL0::I64 == 0) goto caL2; else goto caL1;
       caL2:
           call (I64[_rq::P64])() args: 8, res: 0, upd: 8;
       caL1:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caL0::I64;
           R2 = caL3_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:44.547344 UTC

[section "data" {
     lvl_ravL_closure:
         const lvl_ravL_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     caLk_str:
         I8[] [114,101,97,100]
 },
 lvl_ravL_entry() //  [R1]
         { info_tbl: [(caLl,
                       label: lvl_ravL_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caLl:
           _ravL::P64 = R1;
           goto caLf;
       caLf:
           if ((old + 0) - <highSp> < SpLim) goto caLm; else goto caLn;
       caLn:
           if (HpLim == 0) goto caLm; else goto caLo;
       caLm:
           R1 = _ravL::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caLo:
           (_caLh::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _ravL::P64);
           if (_caLh::I64 == 0) goto caLj; else goto caLi;
       caLj:
           call (I64[_ravL::P64])() args: 8, res: 0, upd: 8;
       caLi:
           I64[(old + 24)] = stg_bh_upd_frame_info;
           I64[(old + 16)] = _caLh::I64;
           R2 = caLk_str;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:44.549462 UTC

{offset
  caLl:
      _ravL::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto caLm; else goto caLn;
  caLn:
      if (HpLim == 0) goto caLm; else goto caLo;
  caLm:
      R1 = _ravL::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caLo:
      (_caLh::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _ravL::P64);
      if (_caLh::I64 == 0) goto caLj; else goto caLi;
  caLj:
      call (I64[_ravL::P64])() args: 8, res: 0, upd: 8;
  caLi:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _caLh::I64;
      R2 = caLk_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:44.550558 UTC

{offset
  caLl:
      _ravL::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto caLm; else goto caLn;
  caLn:
      if (HpLim == 0) goto caLm; else goto caLo;
  caLm:
      R1 = _ravL::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caLo:
      (_caLh::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _ravL::P64);
      if (_caLh::I64 == 0) goto caLj; else goto caLi;
  caLj:
      call (I64[_ravL::P64])() args: 8, res: 0, upd: 8;
  caLi:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _caLh::I64;
      R2 = caLk_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:44.551672 UTC

{offset
  caLl:
      _ravL::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto caLm; else goto caLn;
  caLn:
      if (HpLim == 0) goto caLm; else goto caLo;
  caLm:
      R1 = _ravL::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caLo:
      (_caLh::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _ravL::P64);
      if (_caLh::I64 == 0) goto caLj; else goto caLi;
  caLj:
      call (I64[_ravL::P64])() args: 8, res: 0, upd: 8;
  caLi:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _caLh::I64;
      R2 = caLk_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:44.552839 UTC

{offset
  caLl:
      _ravL::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto caLm; else goto caLn;
  caLn:
      if (HpLim == 0) goto caLm; else goto caLo;
  caLm:
      R1 = _ravL::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caLo:
      (_caLh::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _ravL::P64);
      if (_caLh::I64 == 0) goto caLj; else goto caLi;
  caLj:
      call (I64[_ravL::P64])() args: 8, res: 0, upd: 8;
  caLi:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _caLh::I64;
      R2 = caLk_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:44.553958 UTC

{offset
  caLl:
      _ravL::P64 = R1;
      if ((Sp + -16) < SpLim) goto caLm; else goto caLn;
  caLn:
      if (HpLim == 0) goto caLm; else goto caLo;
  caLm:
      R1 = _ravL::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caLo:
      (_caLh::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _ravL::P64);
      if (_caLh::I64 == 0) goto caLj; else goto caLi;
  caLj:
      call (I64[_ravL::P64])() args: 8, res: 0, upd: 8;
  caLi:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _caLh::I64;
      R2 = caLk_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:44.55523 UTC

[(caLi, {}), (caLj, {}), (caLl, {}), (caLm, {}), (caLn, {}),
 (caLo, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:44.555615 UTC

lvl_ravL_entry() //  [R1]
        { info_tbl: [(caLl,
                      label: lvl_ravL_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caLl:
          _ravL::P64 = R1;
          if ((Sp + -16) < SpLim) goto caLm; else goto caLn;
      caLn:
          if (HpLim == 0) goto caLm; else goto caLo;
      caLm:
          R1 = _ravL::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      caLo:
          (_caLh::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _ravL::P64);
          if (_caLh::I64 == 0) goto caLj; else goto caLi;
      caLj:
          call (I64[_ravL::P64])() args: 8, res: 0, upd: 8;
      caLi:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _caLh::I64;
          R2 = caLk_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:44.557008 UTC

lvl_ravL_entry() //  [R1]
        { info_tbl: [(caLl,
                      label: lvl_ravL_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caLl:
          _ravL::P64 = R1;
          if ((Sp + -16) < SpLim) goto caLm; else goto caLn;
      caLn:
          if (HpLim == 0) goto caLm; else goto caLo;
      caLm:
          R1 = _ravL::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      caLo:
          (_caLh::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _ravL::P64);
          if (_caLh::I64 == 0) goto caLj; else goto caLi;
      caLj:
          call (I64[_ravL::P64])() args: 8, res: 0, upd: 8;
      caLi:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _caLh::I64;
          R2 = caLk_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:44.558396 UTC

[section "data" {
     lvl_ravL_closure:
         const lvl_ravL_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     caLk_str:
         I8[] [114,101,97,100]
 },
 lvl_ravL_entry() //  [R1]
         { info_tbl: [(caLl,
                       label: lvl_ravL_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caLl:
           _ravL::P64 = R1;
           if ((Sp + -16) < SpLim) goto caLm; else goto caLn;
       caLn:
           if (HpLim == 0) goto caLm; else goto caLo;
       caLm:
           R1 = _ravL::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caLo:
           (_caLh::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _ravL::P64);
           if (_caLh::I64 == 0) goto caLj; else goto caLi;
       caLj:
           call (I64[_ravL::P64])() args: 8, res: 0, upd: 8;
       caLi:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caLh::I64;
           R2 = caLk_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:44.560131 UTC

[section "data" {
     lvl_ravL_closure:
         const lvl_ravL_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     caLk_str:
         I8[] [114,101,97,100]
 },
 lvl_ravL_entry() //  [R1]
         { info_tbl: [(caLl,
                       label: lvl_ravL_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caLl:
           _ravL::P64 = R1;
           if ((Sp + -16) < SpLim) goto caLm; else goto caLn;
       caLn:
           if (HpLim == 0) goto caLm; else goto caLo;
       caLm:
           R1 = _ravL::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caLo:
           (_caLh::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _ravL::P64);
           if (_caLh::I64 == 0) goto caLj; else goto caLi;
       caLj:
           call (I64[_ravL::P64])() args: 8, res: 0, upd: 8;
       caLi:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caLh::I64;
           R2 = caLk_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:44.564656 UTC

[section "data" {
     lvl1_ravM_closure:
         const GHC.Types.I#_static_info;
         const 591;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:44.565029 UTC

[section "data" {
     lvl1_ravM_closure:
         const GHC.Types.I#_static_info;
         const 591;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:44.56679 UTC

[section "data" {
     lvl1_ravM_closure:
         const GHC.Types.I#_static_info;
         const 591;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:44.567378 UTC

[section "data" {
     lvl2_ravN_closure:
         const lvl2_ravN_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     caLD_str:
         I8[] [119,114,105,116,101]
 },
 lvl2_ravN_entry() //  [R1]
         { info_tbl: [(caLE,
                       label: lvl2_ravN_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caLE:
           _ravN::P64 = R1;
           goto caLy;
       caLy:
           if ((old + 0) - <highSp> < SpLim) goto caLF; else goto caLG;
       caLG:
           if (HpLim == 0) goto caLF; else goto caLH;
       caLF:
           R1 = _ravN::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caLH:
           (_caLA::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _ravN::P64);
           if (_caLA::I64 == 0) goto caLC; else goto caLB;
       caLC:
           call (I64[_ravN::P64])() args: 8, res: 0, upd: 8;
       caLB:
           I64[(old + 24)] = stg_bh_upd_frame_info;
           I64[(old + 16)] = _caLA::I64;
           R2 = caLD_str;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:44.569451 UTC

{offset
  caLE:
      _ravN::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto caLF; else goto caLG;
  caLG:
      if (HpLim == 0) goto caLF; else goto caLH;
  caLF:
      R1 = _ravN::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caLH:
      (_caLA::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _ravN::P64);
      if (_caLA::I64 == 0) goto caLC; else goto caLB;
  caLC:
      call (I64[_ravN::P64])() args: 8, res: 0, upd: 8;
  caLB:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _caLA::I64;
      R2 = caLD_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:44.570557 UTC

{offset
  caLE:
      _ravN::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto caLF; else goto caLG;
  caLG:
      if (HpLim == 0) goto caLF; else goto caLH;
  caLF:
      R1 = _ravN::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caLH:
      (_caLA::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _ravN::P64);
      if (_caLA::I64 == 0) goto caLC; else goto caLB;
  caLC:
      call (I64[_ravN::P64])() args: 8, res: 0, upd: 8;
  caLB:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _caLA::I64;
      R2 = caLD_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:44.571697 UTC

{offset
  caLE:
      _ravN::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto caLF; else goto caLG;
  caLG:
      if (HpLim == 0) goto caLF; else goto caLH;
  caLF:
      R1 = _ravN::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caLH:
      (_caLA::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _ravN::P64);
      if (_caLA::I64 == 0) goto caLC; else goto caLB;
  caLC:
      call (I64[_ravN::P64])() args: 8, res: 0, upd: 8;
  caLB:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _caLA::I64;
      R2 = caLD_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:44.572963 UTC

{offset
  caLE:
      _ravN::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto caLF; else goto caLG;
  caLG:
      if (HpLim == 0) goto caLF; else goto caLH;
  caLF:
      R1 = _ravN::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caLH:
      (_caLA::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _ravN::P64);
      if (_caLA::I64 == 0) goto caLC; else goto caLB;
  caLC:
      call (I64[_ravN::P64])() args: 8, res: 0, upd: 8;
  caLB:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _caLA::I64;
      R2 = caLD_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:44.574083 UTC

{offset
  caLE:
      _ravN::P64 = R1;
      if ((Sp + -16) < SpLim) goto caLF; else goto caLG;
  caLG:
      if (HpLim == 0) goto caLF; else goto caLH;
  caLF:
      R1 = _ravN::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caLH:
      (_caLA::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _ravN::P64);
      if (_caLA::I64 == 0) goto caLC; else goto caLB;
  caLC:
      call (I64[_ravN::P64])() args: 8, res: 0, upd: 8;
  caLB:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _caLA::I64;
      R2 = caLD_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:44.575348 UTC

[(caLB, {}), (caLC, {}), (caLE, {}), (caLF, {}), (caLG, {}),
 (caLH, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:44.575722 UTC

lvl2_ravN_entry() //  [R1]
        { info_tbl: [(caLE,
                      label: lvl2_ravN_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caLE:
          _ravN::P64 = R1;
          if ((Sp + -16) < SpLim) goto caLF; else goto caLG;
      caLG:
          if (HpLim == 0) goto caLF; else goto caLH;
      caLF:
          R1 = _ravN::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      caLH:
          (_caLA::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _ravN::P64);
          if (_caLA::I64 == 0) goto caLC; else goto caLB;
      caLC:
          call (I64[_ravN::P64])() args: 8, res: 0, upd: 8;
      caLB:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _caLA::I64;
          R2 = caLD_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:44.577098 UTC

lvl2_ravN_entry() //  [R1]
        { info_tbl: [(caLE,
                      label: lvl2_ravN_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caLE:
          _ravN::P64 = R1;
          if ((Sp + -16) < SpLim) goto caLF; else goto caLG;
      caLG:
          if (HpLim == 0) goto caLF; else goto caLH;
      caLF:
          R1 = _ravN::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      caLH:
          (_caLA::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _ravN::P64);
          if (_caLA::I64 == 0) goto caLC; else goto caLB;
      caLC:
          call (I64[_ravN::P64])() args: 8, res: 0, upd: 8;
      caLB:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _caLA::I64;
          R2 = caLD_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:44.578461 UTC

[section "data" {
     lvl2_ravN_closure:
         const lvl2_ravN_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     caLD_str:
         I8[] [119,114,105,116,101]
 },
 lvl2_ravN_entry() //  [R1]
         { info_tbl: [(caLE,
                       label: lvl2_ravN_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caLE:
           _ravN::P64 = R1;
           if ((Sp + -16) < SpLim) goto caLF; else goto caLG;
       caLG:
           if (HpLim == 0) goto caLF; else goto caLH;
       caLF:
           R1 = _ravN::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caLH:
           (_caLA::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _ravN::P64);
           if (_caLA::I64 == 0) goto caLC; else goto caLB;
       caLC:
           call (I64[_ravN::P64])() args: 8, res: 0, upd: 8;
       caLB:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caLA::I64;
           R2 = caLD_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:44.580152 UTC

[section "data" {
     lvl2_ravN_closure:
         const lvl2_ravN_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     caLD_str:
         I8[] [119,114,105,116,101]
 },
 lvl2_ravN_entry() //  [R1]
         { info_tbl: [(caLE,
                       label: lvl2_ravN_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caLE:
           _ravN::P64 = R1;
           if ((Sp + -16) < SpLim) goto caLF; else goto caLG;
       caLG:
           if (HpLim == 0) goto caLF; else goto caLH;
       caLF:
           R1 = _ravN::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caLH:
           (_caLA::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _ravN::P64);
           if (_caLA::I64 == 0) goto caLC; else goto caLB;
       caLC:
           call (I64[_ravN::P64])() args: 8, res: 0, upd: 8;
       caLB:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caLA::I64;
           R2 = caLD_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:44.584709 UTC

[section "data" {
     lvl3_ravO_closure:
         const GHC.Types.I#_static_info;
         const 597;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:44.5851 UTC

[section "data" {
     lvl3_ravO_closure:
         const GHC.Types.I#_static_info;
         const 597;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:44.585418 UTC

[section "data" {
     lvl3_ravO_closure:
         const GHC.Types.I#_static_info;
         const 597;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:44.586107 UTC

[section "data" {
     lvl5_ravU_closure:
         const lvl5_ravU_info;
         const 0;
 },
 lvl5_ravU_entry() //  [R3, R2]
         { info_tbl: [(caLZ,
                       label: lvl5_ravU_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caLZ:
           _sawF::I64 = R3;
           _sawE::I64 = R2;
           goto caLV;
       caLV:
           if ((old + 0) - <highSp> < SpLim) goto caM0; else goto caM1;
       caM1:
           goto caLU;
       caLU:
           if (HpLim == 0) goto caM0; else goto caM2;
       caM0:
           R3 = _sawF::I64;
           R2 = _sawE::I64;
           R1 = lvl5_ravU_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caM2:
           I64[(young<caLX> + 8)] = caLX;
           R3 = _sawE::I64;
           R2 = _sawF::I64;
           call Data.Vector.Internal.Check.checkIndex_msg#_info(R3,
                                                                R2) returns to caLX, args: 8, res: 8, upd: 8;
       caLX:
           _sawG::P64 = R1;
           R6 = _sawG::P64;
           R5 = lvl_ravL_closure;
           R4 = Data.Vector.Internal.Check.Bounds_closure+1;
           R3 = lvl1_ravM_closure+1;
           R2 = SkipList.newSL8_closure;
           call Data.Vector.Internal.Check.checkError_info(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:44.588718 UTC

{offset
  caLZ:
      _sawF::I64 = R3;
      _sawE::I64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto caM0; else goto caM1;
  caM1:
      if (HpLim == 0) goto caM0; else goto caM2;
  caM0:
      R3 = _sawF::I64;
      R2 = _sawE::I64;
      R1 = lvl5_ravU_closure;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  caM2:
      I64[(young<caLX> + 8)] = caLX;
      R3 = _sawE::I64;
      R2 = _sawF::I64;
      call Data.Vector.Internal.Check.checkIndex_msg#_info(R3,
                                                           R2) returns to caLX, args: 8, res: 8, upd: 8;
  caLX:
      _sawG::P64 = R1;
      R6 = _sawG::P64;
      R5 = lvl_ravL_closure;
      R4 = Data.Vector.Internal.Check.Bounds_closure+1;
      R3 = lvl1_ravM_closure+1;
      R2 = SkipList.newSL8_closure;
      call Data.Vector.Internal.Check.checkError_info(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:44.590044 UTC

{offset
  caLZ:
      _sawF::I64 = R3;
      _sawE::I64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto caM0; else goto caM1;
  caM1:
      if (HpLim == 0) goto caM0; else goto caM2;
  caM0:
      R3 = _sawF::I64;
      R2 = _sawE::I64;
      R1 = lvl5_ravU_closure;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  caM2:
      I64[(young<caLX> + 8)] = caLX;
      R3 = _sawE::I64;
      R2 = _sawF::I64;
      call Data.Vector.Internal.Check.checkIndex_msg#_info(R3,
                                                           R2) returns to caLX, args: 8, res: 8, upd: 8;
  caLX:
      _sawG::P64 = R1;
      R6 = _sawG::P64;
      R5 = lvl_ravL_closure;
      R4 = Data.Vector.Internal.Check.Bounds_closure+1;
      R3 = lvl1_ravM_closure+1;
      R2 = SkipList.newSL8_closure;
      call Data.Vector.Internal.Check.checkError_info(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:44.59139 UTC

{offset
  caLZ:
      _sawF::I64 = R3;
      _sawE::I64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto caM0; else goto caM1;
  caM1:
      if (HpLim == 0) goto caM0; else goto caM2;
  caM0:
      R3 = _sawF::I64;
      R2 = _sawE::I64;
      R1 = lvl5_ravU_closure;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  caM2:
      I64[(young<caLX> + 8)] = caLX;
      R3 = _sawE::I64;
      R2 = _sawF::I64;
      call Data.Vector.Internal.Check.checkIndex_msg#_info(R3,
                                                           R2) returns to caLX, args: 8, res: 8, upd: 8;
  caLX:
      _sawG::P64 = R1;
      R6 = _sawG::P64;
      R5 = lvl_ravL_closure;
      R4 = Data.Vector.Internal.Check.Bounds_closure+1;
      R3 = lvl1_ravM_closure+1;
      R2 = SkipList.newSL8_closure;
      call Data.Vector.Internal.Check.checkError_info(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:44.592913 UTC

{offset
  caLZ:
      _sawF::I64 = R3;
      _sawE::I64 = R2;
      if ((Sp + 8) - 16 < SpLim) goto caM0; else goto caM1;
  caM1:
      if (HpLim == 0) goto caM0; else goto caM2;
  caM0:
      R3 = _sawF::I64;
      R2 = _sawE::I64;
      R1 = lvl5_ravU_closure;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  caM2:
      I64[Sp - 8] = caLX;
      R3 = _sawE::I64;
      R2 = _sawF::I64;
      Sp = Sp - 8;
      call Data.Vector.Internal.Check.checkIndex_msg#_info(R3,
                                                           R2) returns to caLX, args: 8, res: 8, upd: 8;
  caLX:
      _sawG::P64 = R1;
      R6 = _sawG::P64;
      R5 = lvl_ravL_closure;
      R4 = Data.Vector.Internal.Check.Bounds_closure+1;
      R3 = lvl1_ravM_closure+1;
      R2 = SkipList.newSL8_closure;
      Sp = Sp + 8;
      call Data.Vector.Internal.Check.checkError_info(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:44.594301 UTC

{offset
  caLZ:
      _sawF::I64 = R3;
      _sawE::I64 = R2;
      if ((Sp + -8) < SpLim) goto caM0; else goto caM1;
  caM1:
      if (HpLim == 0) goto caM0; else goto caM2;
  caM0:
      R3 = _sawF::I64;
      R2 = _sawE::I64;
      R1 = lvl5_ravU_closure;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  caM2:
      I64[Sp - 8] = caLX;
      R3 = _sawE::I64;
      R2 = _sawF::I64;
      Sp = Sp - 8;
      call Data.Vector.Internal.Check.checkIndex_msg#_info(R3,
                                                           R2) returns to caLX, args: 8, res: 8, upd: 8;
  caLX:
      R6 = R1;
      R5 = lvl_ravL_closure;
      R4 = Data.Vector.Internal.Check.Bounds_closure+1;
      R3 = lvl1_ravM_closure+1;
      R2 = SkipList.newSL8_closure;
      Sp = Sp + 8;
      call Data.Vector.Internal.Check.checkError_info(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:44.595791 UTC

[(caLX,
  {Data.Vector.Internal.Check.checkError_closure,
   SkipList.newSL8_closure, lvl_ravL_closure}),
 (caLZ,
  {Data.Vector.Internal.Check.checkError_closure,
   SkipList.newSL8_closure,
   Data.Vector.Internal.Check.checkIndex_msg#_closure,
   lvl_ravL_closure, lvl5_ravU_closure}),
 (caM0, {lvl5_ravU_closure}),
 (caM1,
  {Data.Vector.Internal.Check.checkError_closure,
   SkipList.newSL8_closure,
   Data.Vector.Internal.Check.checkIndex_msg#_closure,
   lvl_ravL_closure, lvl5_ravU_closure}),
 (caM2,
  {Data.Vector.Internal.Check.checkError_closure,
   SkipList.newSL8_closure,
   Data.Vector.Internal.Check.checkIndex_msg#_closure,
   lvl_ravL_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:44.597381 UTC

lvl5_ravU_entry() //  [R3, R2]
        { info_tbl: [(caLX,
                      label: block_caLX_info
                      rep:StackRep []),
                     (caLZ,
                      label: lvl5_ravU_info
                      rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caLZ:
          _sawF::I64 = R3;
          _sawE::I64 = R2;
          if ((Sp + -8) < SpLim) goto caM0; else goto caM1;
      caM1:
          if (HpLim == 0) goto caM0; else goto caM2;
      caM0:
          R3 = _sawF::I64;
          R2 = _sawE::I64;
          R1 = lvl5_ravU_closure;
          call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
      caM2:
          I64[Sp - 8] = caLX;
          R3 = _sawE::I64;
          R2 = _sawF::I64;
          Sp = Sp - 8;
          call Data.Vector.Internal.Check.checkIndex_msg#_info(R3,
                                                               R2) returns to caLX, args: 8, res: 8, upd: 8;
      caLX:
          R6 = R1;
          R5 = lvl_ravL_closure;
          R4 = Data.Vector.Internal.Check.Bounds_closure+1;
          R3 = lvl1_ravM_closure+1;
          R2 = SkipList.newSL8_closure;
          Sp = Sp + 8;
          call Data.Vector.Internal.Check.checkError_info(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:44.599135 UTC

lvl5_ravU_entry() //  [R3, R2]
        { info_tbl: [(caLX,
                      label: block_caLX_info
                      rep:StackRep []),
                     (caLZ,
                      label: lvl5_ravU_info
                      rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caLZ:
          _sawF::I64 = R3;
          _sawE::I64 = R2;
          if ((Sp + -8) < SpLim) goto caM0; else goto caM1;
      caM1:
          if (HpLim == 0) goto caM0; else goto caM2;
      caM0:
          R3 = _sawF::I64;
          R2 = _sawE::I64;
          R1 = lvl5_ravU_closure;
          call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
      caM2:
          I64[Sp - 8] = caLX;
          R3 = _sawE::I64;
          R2 = _sawF::I64;
          Sp = Sp - 8;
          call Data.Vector.Internal.Check.checkIndex_msg#_info(R3,
                                                               R2) returns to caLX, args: 8, res: 8, upd: 8;
      caLX:
          R6 = R1;
          R5 = lvl_ravL_closure;
          R4 = Data.Vector.Internal.Check.Bounds_closure+1;
          R3 = lvl1_ravM_closure+1;
          R2 = SkipList.newSL8_closure;
          Sp = Sp + 8;
          call Data.Vector.Internal.Check.checkError_info(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:44.600867 UTC

[section "data" {
     lvl5_ravU_closure:
         const lvl5_ravU_info;
         const 0;
 },
 lvl5_ravU_entry() //  [R3, R2]
         { info_tbl: [(caLX,
                       label: block_caLX_info
                       rep:StackRep []),
                      (caLZ,
                       label: lvl5_ravU_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caLZ:
           _sawF::I64 = R3;
           _sawE::I64 = R2;
           if ((Sp + -8) < SpLim) goto caM0; else goto caM1;
       caM1:
           if (HpLim == 0) goto caM0; else goto caM2;
       caM0:
           R3 = _sawF::I64;
           R2 = _sawE::I64;
           R1 = lvl5_ravU_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caM2:
           I64[Sp - 8] = caLX;
           R3 = _sawE::I64;
           R2 = _sawF::I64;
           Sp = Sp - 8;
           call Data.Vector.Internal.Check.checkIndex_msg#_info(R3,
                                                                R2) returns to caLX, args: 8, res: 8, upd: 8;
       caLX:
           R6 = R1;
           R5 = lvl_ravL_closure;
           R4 = Data.Vector.Internal.Check.Bounds_closure+1;
           R3 = lvl1_ravM_closure+1;
           R2 = SkipList.newSL8_closure;
           Sp = Sp + 8;
           call Data.Vector.Internal.Check.checkError_info(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:44.602956 UTC

[section "data" {
     lvl5_ravU_closure:
         const lvl5_ravU_info;
         const 0;
 },
 lvl5_ravU_entry() //  [R3, R2]
         { info_tbl: [(caLX,
                       label: block_caLX_info
                       rep:StackRep []),
                      (caLZ,
                       label: lvl5_ravU_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caLZ:
           _sawF::I64 = R3;
           _sawE::I64 = R2;
           if ((Sp + -8) < SpLim) goto caM0; else goto caM1;
       caM1:
           if (HpLim == 0) goto caM0; else goto caM2;
       caM0:
           R3 = _sawF::I64;
           R2 = _sawE::I64;
           R1 = lvl5_ravU_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caM2:
           I64[Sp - 8] = caLX;
           R3 = _sawE::I64;
           R2 = _sawF::I64;
           Sp = Sp - 8;
           call Data.Vector.Internal.Check.checkIndex_msg#_info(R3,
                                                                R2) returns to caLX, args: 8, res: 8, upd: 8;
       caLX:
           R6 = R1;
           R5 = lvl_ravL_closure;
           R4 = Data.Vector.Internal.Check.Bounds_closure+1;
           R3 = lvl1_ravM_closure+1;
           R2 = SkipList.newSL8_closure;
           Sp = Sp + 8;
           call Data.Vector.Internal.Check.checkError_info(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:44.607921 UTC

[section "data" {
     SkipList._getNodes1_closure:
         const SkipList._getNodes1_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     caMi_str:
         I8[] [95,103,101,116,78,111,100,101,115]
 },
 SkipList._getNodes1_entry() //  [R1]
         { info_tbl: [(caMj,
                       label: SkipList._getNodes1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caMj:
           _rE::P64 = R1;
           goto caMd;
       caMd:
           if ((old + 0) - <highSp> < SpLim) goto caMk; else goto caMl;
       caMl:
           if (HpLim == 0) goto caMk; else goto caMm;
       caMk:
           R1 = _rE::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caMm:
           (_caMf::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rE::P64);
           if (_caMf::I64 == 0) goto caMh; else goto caMg;
       caMh:
           call (I64[_rE::P64])() args: 8, res: 0, upd: 8;
       caMg:
           I64[(old + 24)] = stg_bh_upd_frame_info;
           I64[(old + 16)] = _caMf::I64;
           R2 = caMi_str;
           call Control.Exception.Base.recSelError_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:44.610094 UTC

{offset
  caMj:
      _rE::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto caMk; else goto caMl;
  caMl:
      if (HpLim == 0) goto caMk; else goto caMm;
  caMk:
      R1 = _rE::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caMm:
      (_caMf::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rE::P64);
      if (_caMf::I64 == 0) goto caMh; else goto caMg;
  caMh:
      call (I64[_rE::P64])() args: 8, res: 0, upd: 8;
  caMg:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _caMf::I64;
      R2 = caMi_str;
      call Control.Exception.Base.recSelError_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:44.611184 UTC

{offset
  caMj:
      _rE::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto caMk; else goto caMl;
  caMl:
      if (HpLim == 0) goto caMk; else goto caMm;
  caMk:
      R1 = _rE::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caMm:
      (_caMf::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rE::P64);
      if (_caMf::I64 == 0) goto caMh; else goto caMg;
  caMh:
      call (I64[_rE::P64])() args: 8, res: 0, upd: 8;
  caMg:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _caMf::I64;
      R2 = caMi_str;
      call Control.Exception.Base.recSelError_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:44.612305 UTC

{offset
  caMj:
      _rE::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto caMk; else goto caMl;
  caMl:
      if (HpLim == 0) goto caMk; else goto caMm;
  caMk:
      R1 = _rE::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caMm:
      (_caMf::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rE::P64);
      if (_caMf::I64 == 0) goto caMh; else goto caMg;
  caMh:
      call (I64[_rE::P64])() args: 8, res: 0, upd: 8;
  caMg:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _caMf::I64;
      R2 = caMi_str;
      call Control.Exception.Base.recSelError_info(R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:44.613577 UTC

{offset
  caMj:
      _rE::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto caMk; else goto caMl;
  caMl:
      if (HpLim == 0) goto caMk; else goto caMm;
  caMk:
      R1 = _rE::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caMm:
      (_caMf::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rE::P64);
      if (_caMf::I64 == 0) goto caMh; else goto caMg;
  caMh:
      call (I64[_rE::P64])() args: 8, res: 0, upd: 8;
  caMg:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _caMf::I64;
      R2 = caMi_str;
      Sp = Sp - 16;
      call Control.Exception.Base.recSelError_info(R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:44.614698 UTC

{offset
  caMj:
      _rE::P64 = R1;
      if ((Sp + -16) < SpLim) goto caMk; else goto caMl;
  caMl:
      if (HpLim == 0) goto caMk; else goto caMm;
  caMk:
      R1 = _rE::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caMm:
      (_caMf::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rE::P64);
      if (_caMf::I64 == 0) goto caMh; else goto caMg;
  caMh:
      call (I64[_rE::P64])() args: 8, res: 0, upd: 8;
  caMg:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _caMf::I64;
      R2 = caMi_str;
      Sp = Sp - 16;
      call Control.Exception.Base.recSelError_info(R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:44.615954 UTC

[(caMg, {Control.Exception.Base.recSelError_closure}), (caMh, {}),
 (caMj, {Control.Exception.Base.recSelError_closure}), (caMk, {}),
 (caMl, {Control.Exception.Base.recSelError_closure}),
 (caMm, {Control.Exception.Base.recSelError_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:44.616457 UTC

SkipList._getNodes1_entry() //  [R1]
        { info_tbl: [(caMj,
                      label: SkipList._getNodes1_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caMj:
          _rE::P64 = R1;
          if ((Sp + -16) < SpLim) goto caMk; else goto caMl;
      caMl:
          if (HpLim == 0) goto caMk; else goto caMm;
      caMk:
          R1 = _rE::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      caMm:
          (_caMf::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rE::P64);
          if (_caMf::I64 == 0) goto caMh; else goto caMg;
      caMh:
          call (I64[_rE::P64])() args: 8, res: 0, upd: 8;
      caMg:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _caMf::I64;
          R2 = caMi_str;
          Sp = Sp - 16;
          call Control.Exception.Base.recSelError_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:44.617834 UTC

SkipList._getNodes1_entry() //  [R1]
        { info_tbl: [(caMj,
                      label: SkipList._getNodes1_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caMj:
          _rE::P64 = R1;
          if ((Sp + -16) < SpLim) goto caMk; else goto caMl;
      caMl:
          if (HpLim == 0) goto caMk; else goto caMm;
      caMk:
          R1 = _rE::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      caMm:
          (_caMf::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rE::P64);
          if (_caMf::I64 == 0) goto caMh; else goto caMg;
      caMh:
          call (I64[_rE::P64])() args: 8, res: 0, upd: 8;
      caMg:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _caMf::I64;
          R2 = caMi_str;
          Sp = Sp - 16;
          call Control.Exception.Base.recSelError_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:44.619217 UTC

[section "data" {
     SkipList._getNodes1_closure:
         const SkipList._getNodes1_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     caMi_str:
         I8[] [95,103,101,116,78,111,100,101,115]
 },
 SkipList._getNodes1_entry() //  [R1]
         { info_tbl: [(caMj,
                       label: SkipList._getNodes1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caMj:
           _rE::P64 = R1;
           if ((Sp + -16) < SpLim) goto caMk; else goto caMl;
       caMl:
           if (HpLim == 0) goto caMk; else goto caMm;
       caMk:
           R1 = _rE::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caMm:
           (_caMf::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rE::P64);
           if (_caMf::I64 == 0) goto caMh; else goto caMg;
       caMh:
           call (I64[_rE::P64])() args: 8, res: 0, upd: 8;
       caMg:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caMf::I64;
           R2 = caMi_str;
           Sp = Sp - 16;
           call Control.Exception.Base.recSelError_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:44.620979 UTC

[section "data" {
     SkipList._getNodes1_closure:
         const SkipList._getNodes1_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     caMi_str:
         I8[] [95,103,101,116,78,111,100,101,115]
 },
 SkipList._getNodes1_entry() //  [R1]
         { info_tbl: [(caMj,
                       label: SkipList._getNodes1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caMj:
           _rE::P64 = R1;
           if ((Sp + -16) < SpLim) goto caMk; else goto caMl;
       caMl:
           if (HpLim == 0) goto caMk; else goto caMm;
       caMk:
           R1 = _rE::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caMm:
           (_caMf::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rE::P64);
           if (_caMf::I64 == 0) goto caMh; else goto caMg;
       caMh:
           call (I64[_rE::P64])() args: 8, res: 0, upd: 8;
       caMg:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caMf::I64;
           R2 = caMi_str;
           Sp = Sp - 16;
           call Control.Exception.Base.recSelError_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:44.625835 UTC

[section "data" {
     SkipList._getNodes_closure:
         const SkipList._getNodes_info;
         const 0;
 },
 SkipList._getNodes_entry() //  [R2]
         { info_tbl: [(caMI,
                       label: SkipList._getNodes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caMI:
           _sawH::P64 = R2;
           goto caMz;
       caMz:
           if ((old + 0) - <highSp> < SpLim) goto caMJ; else goto caMK;
       caMK:
           goto caMy;
       caMy:
           if (HpLim == 0) goto caMJ; else goto caML;
       caMJ:
           R2 = _sawH::P64;
           R1 = SkipList._getNodes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caML:
           I64[(young<caMB> + 8)] = caMB;
           R1 = _sawH::P64;
           if (R1 & 7 != 0) goto caMB; else goto caMC;
       caMC:
           call (I64[R1])(R1) returns to caMB, args: 8, res: 8, upd: 8;
       caMB:
           _sawI::P64 = R1;
           _caMH::P64 = _sawI::P64 & 7;
           switch [1 .. 2] _caMH::P64 {
               case 1 : goto caMF;
               case 2 : goto caMG;
           }
       caMG:
           _sawJ::P64 = P64[_sawI::P64 + 6];
           _sawK::P64 = P64[_sawI::P64 + 14];
           _sawL::P64 = P64[_sawI::P64 + 22];
           R1 = _sawL::P64 & (-8);
           call (I64[R1])(R1) args: 8, res: 0, upd: 8;
       caMF:
           R1 = SkipList._getNodes1_closure;
           call (I64[R1])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:44.628896 UTC

{offset
  caMI:
      _sawH::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto caMJ; else goto caMK;
  caMK:
      if (HpLim == 0) goto caMJ; else goto caML;
  caMJ:
      R2 = _sawH::P64;
      R1 = SkipList._getNodes_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  caML:
      I64[(young<caMB> + 8)] = caMB;
      R1 = _sawH::P64;
      if (R1 & 7 != 0) goto caMB; else goto caMC;
  caMC:
      call (I64[R1])(R1) returns to caMB, args: 8, res: 8, upd: 8;
  caMB:
      _sawI::P64 = R1;
      _caMH::P64 = _sawI::P64 & 7;
      switch [1 .. 2] _caMH::P64 {
          case 1 : goto caMF;
          case 2 : goto caMG;
      }
  caMG:
      _sawJ::P64 = P64[_sawI::P64 + 6];
      _sawK::P64 = P64[_sawI::P64 + 14];
      _sawL::P64 = P64[_sawI::P64 + 22];
      R1 = _sawL::P64 & (-8);
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
  caMF:
      R1 = SkipList._getNodes1_closure;
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:44.630496 UTC

{offset
  caMI:
      _sawH::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto caMJ; else goto caMK;
  caMK:
      if (HpLim == 0) goto caMJ; else goto caML;
  caMJ:
      R2 = _sawH::P64;
      R1 = SkipList._getNodes_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  caML:
      I64[(young<caMB> + 8)] = caMB;
      R1 = _sawH::P64;
      if (R1 & 7 != 0) goto caMB; else goto caMC;
  caMC:
      call (I64[R1])(R1) returns to caMB, args: 8, res: 8, upd: 8;
  caMB:
      _sawI::P64 = R1;
      _caMH::P64 = _sawI::P64 & 7;
      switch [1 .. 2] _caMH::P64 {
          case 1 : goto caMF;
          case 2 : goto caMG;
      }
  caMG:
      _sawJ::P64 = P64[_sawI::P64 + 6];
      _sawK::P64 = P64[_sawI::P64 + 14];
      _sawL::P64 = P64[_sawI::P64 + 22];
      R1 = _sawL::P64 & (-8);
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
  caMF:
      R1 = SkipList._getNodes1_closure;
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:44.63211 UTC

{offset
  caMI:
      _sawH::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto caMJ; else goto caMK;
  caMK:
      if (HpLim == 0) goto caMJ; else goto caML;
  caMJ:
      R2 = _sawH::P64;
      R1 = SkipList._getNodes_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  caML:
      I64[(young<caMB> + 8)] = caMB;
      R1 = _sawH::P64;
      if (R1 & 7 != 0) goto caMB; else goto caMC;
  caMC:
      call (I64[R1])(R1) returns to caMB, args: 8, res: 8, upd: 8;
  caMB:
      _sawI::P64 = R1;
      _caMH::P64 = _sawI::P64 & 7;
      if (_caMH::P64 != 1) goto caMG; else goto caMF;
  caMG:
      _sawJ::P64 = P64[_sawI::P64 + 6];
      _sawK::P64 = P64[_sawI::P64 + 14];
      _sawL::P64 = P64[_sawI::P64 + 22];
      R1 = _sawL::P64 & (-8);
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
  caMF:
      R1 = SkipList._getNodes1_closure;
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:44.633892 UTC

{offset
  caMI:
      _sawH::P64 = R2;
      if ((Sp + 8) - 16 < SpLim) goto caMJ; else goto caMK;
  caMK:
      if (HpLim == 0) goto caMJ; else goto caML;
  caMJ:
      R2 = _sawH::P64;
      R1 = SkipList._getNodes_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  caML:
      I64[Sp - 8] = caMB;
      R1 = _sawH::P64;
      Sp = Sp - 8;
      if (R1 & 7 != 0) goto caMB; else goto caMC;
  caMC:
      call (I64[R1])(R1) returns to caMB, args: 8, res: 8, upd: 8;
  caMB:
      _sawI::P64 = R1;
      _caMH::P64 = _sawI::P64 & 7;
      if (_caMH::P64 != 1) goto caMG; else goto caMF;
  caMG:
      _sawJ::P64 = P64[_sawI::P64 + 6];
      _sawK::P64 = P64[_sawI::P64 + 14];
      _sawL::P64 = P64[_sawI::P64 + 22];
      R1 = _sawL::P64 & (-8);
      Sp = Sp + 8;
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
  caMF:
      R1 = SkipList._getNodes1_closure;
      Sp = Sp + 8;
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:44.635533 UTC

{offset
  caMI:
      _sawH::P64 = R2;
      if ((Sp + -8) < SpLim) goto caMJ; else goto caMK;
  caMK:
      if (HpLim == 0) goto caMJ; else goto caML;
  caMJ:
      R2 = _sawH::P64;
      R1 = SkipList._getNodes_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  caML:
      I64[Sp - 8] = caMB;
      R1 = _sawH::P64;
      Sp = Sp - 8;
      if (R1 & 7 != 0) goto caMB; else goto caMC;
  caMC:
      call (I64[R1])(R1) returns to caMB, args: 8, res: 8, upd: 8;
  caMB:
      if (R1 & 7 != 1) goto caMG; else goto caMF;
  caMG:
      R1 = P64[R1 + 22] & (-8);
      Sp = Sp + 8;
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
  caMF:
      R1 = SkipList._getNodes1_closure;
      Sp = Sp + 8;
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:44.637708 UTC

[(caMB, {SkipList._getNodes1_closure}),
 (caMC, {SkipList._getNodes1_closure}),
 (caMF, {SkipList._getNodes1_closure}), (caMG, {}),
 (caMI, {SkipList._getNodes1_closure, SkipList._getNodes_closure}),
 (caMJ, {SkipList._getNodes_closure}),
 (caMK, {SkipList._getNodes1_closure, SkipList._getNodes_closure}),
 (caML, {SkipList._getNodes1_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:44.638435 UTC

SkipList._getNodes_entry() //  [R2]
        { info_tbl: [(caMB,
                      label: block_caMB_info
                      rep:StackRep []),
                     (caMI,
                      label: SkipList._getNodes_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caMI:
          _sawH::P64 = R2;
          if ((Sp + -8) < SpLim) goto caMJ; else goto caMK;
      caMK:
          if (HpLim == 0) goto caMJ; else goto caML;
      caMJ:
          R2 = _sawH::P64;
          R1 = SkipList._getNodes_closure;
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
      caML:
          I64[Sp - 8] = caMB;
          R1 = _sawH::P64;
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto caMB; else goto caMC;
      caMC:
          call (I64[R1])(R1) returns to caMB, args: 8, res: 8, upd: 8;
      caMB:
          if (R1 & 7 != 1) goto caMG; else goto caMF;
      caMG:
          R1 = P64[R1 + 22] & (-8);
          Sp = Sp + 8;
          call (I64[R1])(R1) args: 8, res: 0, upd: 8;
      caMF:
          R1 = SkipList._getNodes1_closure;
          Sp = Sp + 8;
          call (I64[R1])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:44.640167 UTC

SkipList._getNodes_entry() //  [R2]
        { info_tbl: [(caMB,
                      label: block_caMB_info
                      rep:StackRep []),
                     (caMI,
                      label: SkipList._getNodes_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caMI:
          _sawH::P64 = R2;
          if ((Sp + -8) < SpLim) goto caMJ; else goto caMK;
      caMK:
          if (HpLim == 0) goto caMJ; else goto caML;
      caMJ:
          R2 = _sawH::P64;
          R1 = SkipList._getNodes_closure;
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
      caML:
          I64[Sp - 8] = caMB;
          R1 = _sawH::P64;
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto caMB; else goto caMC;
      caMC:
          call (I64[R1])(R1) returns to caMB, args: 8, res: 8, upd: 8;
      caMB:
          if (R1 & 7 != 1) goto caMG; else goto caMF;
      caMG:
          R1 = P64[R1 + 22] & (-8);
          Sp = Sp + 8;
          call (I64[R1])(R1) args: 8, res: 0, upd: 8;
      caMF:
          R1 = SkipList._getNodes1_closure;
          Sp = Sp + 8;
          call (I64[R1])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:44.641886 UTC

[section "data" {
     SkipList._getNodes_closure:
         const SkipList._getNodes_info;
         const 0;
 },
 SkipList._getNodes_entry() //  [R2]
         { info_tbl: [(caMB,
                       label: block_caMB_info
                       rep:StackRep []),
                      (caMI,
                       label: SkipList._getNodes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caMI:
           _sawH::P64 = R2;
           if ((Sp + -8) < SpLim) goto caMJ; else goto caMK;
       caMK:
           if (HpLim == 0) goto caMJ; else goto caML;
       caMJ:
           R2 = _sawH::P64;
           R1 = SkipList._getNodes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caML:
           I64[Sp - 8] = caMB;
           R1 = _sawH::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto caMB; else goto caMC;
       caMC:
           call (I64[R1])(R1) returns to caMB, args: 8, res: 8, upd: 8;
       caMB:
           if (R1 & 7 != 1) goto caMG; else goto caMF;
       caMG:
           R1 = P64[R1 + 22] & (-8);
           Sp = Sp + 8;
           call (I64[R1])(R1) args: 8, res: 0, upd: 8;
       caMF:
           R1 = SkipList._getNodes1_closure;
           Sp = Sp + 8;
           call (I64[R1])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:44.643888 UTC

[section "data" {
     SkipList._getNodes_closure:
         const SkipList._getNodes_info;
         const 0;
 },
 SkipList._getNodes_entry() //  [R2]
         { info_tbl: [(caMB,
                       label: block_caMB_info
                       rep:StackRep []),
                      (caMI,
                       label: SkipList._getNodes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caMI:
           _sawH::P64 = R2;
           if ((Sp + -8) < SpLim) goto caMJ; else goto caMK;
       caMK:
           if (HpLim == 0) goto caMJ; else goto caML;
       caMJ:
           R2 = _sawH::P64;
           R1 = SkipList._getNodes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caML:
           I64[Sp - 8] = caMB;
           R1 = _sawH::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto caMB; else goto caMC;
       caMC:
           call (I64[R1])(R1) returns to caMB, args: 8, res: 8, upd: 8;
       caMB:
           if (R1 & 7 != 1) goto caMG; else goto caMF;
       caMG:
           R1 = P64[R1 + 22] & (-8);
           Sp = Sp + 8;
           call (I64[R1])(R1) args: 8, res: 0, upd: 8;
       caMF:
           R1 = SkipList._getNodes1_closure;
           Sp = Sp + 8;
           call (I64[R1])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:44.649111 UTC

[section "data" {
     SkipList._getVal1_closure:
         const SkipList._getVal1_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     caN6_str:
         I8[] [95,103,101,116,86,97,108]
 },
 SkipList._getVal1_entry() //  [R1]
         { info_tbl: [(caN7,
                       label: SkipList._getVal1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caN7:
           _rD::P64 = R1;
           goto caN1;
       caN1:
           if ((old + 0) - <highSp> < SpLim) goto caN8; else goto caN9;
       caN9:
           if (HpLim == 0) goto caN8; else goto caNa;
       caN8:
           R1 = _rD::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caNa:
           (_caN3::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rD::P64);
           if (_caN3::I64 == 0) goto caN5; else goto caN4;
       caN5:
           call (I64[_rD::P64])() args: 8, res: 0, upd: 8;
       caN4:
           I64[(old + 24)] = stg_bh_upd_frame_info;
           I64[(old + 16)] = _caN3::I64;
           R2 = caN6_str;
           call Control.Exception.Base.recSelError_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:44.651218 UTC

{offset
  caN7:
      _rD::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto caN8; else goto caN9;
  caN9:
      if (HpLim == 0) goto caN8; else goto caNa;
  caN8:
      R1 = _rD::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caNa:
      (_caN3::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rD::P64);
      if (_caN3::I64 == 0) goto caN5; else goto caN4;
  caN5:
      call (I64[_rD::P64])() args: 8, res: 0, upd: 8;
  caN4:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _caN3::I64;
      R2 = caN6_str;
      call Control.Exception.Base.recSelError_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:44.652316 UTC

{offset
  caN7:
      _rD::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto caN8; else goto caN9;
  caN9:
      if (HpLim == 0) goto caN8; else goto caNa;
  caN8:
      R1 = _rD::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caNa:
      (_caN3::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rD::P64);
      if (_caN3::I64 == 0) goto caN5; else goto caN4;
  caN5:
      call (I64[_rD::P64])() args: 8, res: 0, upd: 8;
  caN4:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _caN3::I64;
      R2 = caN6_str;
      call Control.Exception.Base.recSelError_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:44.653533 UTC

{offset
  caN7:
      _rD::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto caN8; else goto caN9;
  caN9:
      if (HpLim == 0) goto caN8; else goto caNa;
  caN8:
      R1 = _rD::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caNa:
      (_caN3::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rD::P64);
      if (_caN3::I64 == 0) goto caN5; else goto caN4;
  caN5:
      call (I64[_rD::P64])() args: 8, res: 0, upd: 8;
  caN4:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _caN3::I64;
      R2 = caN6_str;
      call Control.Exception.Base.recSelError_info(R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:44.654672 UTC

{offset
  caN7:
      _rD::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto caN8; else goto caN9;
  caN9:
      if (HpLim == 0) goto caN8; else goto caNa;
  caN8:
      R1 = _rD::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caNa:
      (_caN3::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rD::P64);
      if (_caN3::I64 == 0) goto caN5; else goto caN4;
  caN5:
      call (I64[_rD::P64])() args: 8, res: 0, upd: 8;
  caN4:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _caN3::I64;
      R2 = caN6_str;
      Sp = Sp - 16;
      call Control.Exception.Base.recSelError_info(R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:44.655798 UTC

{offset
  caN7:
      _rD::P64 = R1;
      if ((Sp + -16) < SpLim) goto caN8; else goto caN9;
  caN9:
      if (HpLim == 0) goto caN8; else goto caNa;
  caN8:
      R1 = _rD::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caNa:
      (_caN3::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rD::P64);
      if (_caN3::I64 == 0) goto caN5; else goto caN4;
  caN5:
      call (I64[_rD::P64])() args: 8, res: 0, upd: 8;
  caN4:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _caN3::I64;
      R2 = caN6_str;
      Sp = Sp - 16;
      call Control.Exception.Base.recSelError_info(R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:44.657081 UTC

[(caN4, {Control.Exception.Base.recSelError_closure}), (caN5, {}),
 (caN7, {Control.Exception.Base.recSelError_closure}), (caN8, {}),
 (caN9, {Control.Exception.Base.recSelError_closure}),
 (caNa, {Control.Exception.Base.recSelError_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:44.657582 UTC

SkipList._getVal1_entry() //  [R1]
        { info_tbl: [(caN7,
                      label: SkipList._getVal1_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caN7:
          _rD::P64 = R1;
          if ((Sp + -16) < SpLim) goto caN8; else goto caN9;
      caN9:
          if (HpLim == 0) goto caN8; else goto caNa;
      caN8:
          R1 = _rD::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      caNa:
          (_caN3::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rD::P64);
          if (_caN3::I64 == 0) goto caN5; else goto caN4;
      caN5:
          call (I64[_rD::P64])() args: 8, res: 0, upd: 8;
      caN4:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _caN3::I64;
          R2 = caN6_str;
          Sp = Sp - 16;
          call Control.Exception.Base.recSelError_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:44.658917 UTC

SkipList._getVal1_entry() //  [R1]
        { info_tbl: [(caN7,
                      label: SkipList._getVal1_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caN7:
          _rD::P64 = R1;
          if ((Sp + -16) < SpLim) goto caN8; else goto caN9;
      caN9:
          if (HpLim == 0) goto caN8; else goto caNa;
      caN8:
          R1 = _rD::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      caNa:
          (_caN3::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rD::P64);
          if (_caN3::I64 == 0) goto caN5; else goto caN4;
      caN5:
          call (I64[_rD::P64])() args: 8, res: 0, upd: 8;
      caN4:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _caN3::I64;
          R2 = caN6_str;
          Sp = Sp - 16;
          call Control.Exception.Base.recSelError_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:44.660282 UTC

[section "data" {
     SkipList._getVal1_closure:
         const SkipList._getVal1_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     caN6_str:
         I8[] [95,103,101,116,86,97,108]
 },
 SkipList._getVal1_entry() //  [R1]
         { info_tbl: [(caN7,
                       label: SkipList._getVal1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caN7:
           _rD::P64 = R1;
           if ((Sp + -16) < SpLim) goto caN8; else goto caN9;
       caN9:
           if (HpLim == 0) goto caN8; else goto caNa;
       caN8:
           R1 = _rD::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caNa:
           (_caN3::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rD::P64);
           if (_caN3::I64 == 0) goto caN5; else goto caN4;
       caN5:
           call (I64[_rD::P64])() args: 8, res: 0, upd: 8;
       caN4:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caN3::I64;
           R2 = caN6_str;
           Sp = Sp - 16;
           call Control.Exception.Base.recSelError_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:44.662032 UTC

[section "data" {
     SkipList._getVal1_closure:
         const SkipList._getVal1_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     caN6_str:
         I8[] [95,103,101,116,86,97,108]
 },
 SkipList._getVal1_entry() //  [R1]
         { info_tbl: [(caN7,
                       label: SkipList._getVal1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caN7:
           _rD::P64 = R1;
           if ((Sp + -16) < SpLim) goto caN8; else goto caN9;
       caN9:
           if (HpLim == 0) goto caN8; else goto caNa;
       caN8:
           R1 = _rD::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caNa:
           (_caN3::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rD::P64);
           if (_caN3::I64 == 0) goto caN5; else goto caN4;
       caN5:
           call (I64[_rD::P64])() args: 8, res: 0, upd: 8;
       caN4:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caN3::I64;
           R2 = caN6_str;
           Sp = Sp - 16;
           call Control.Exception.Base.recSelError_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:44.666794 UTC

[section "data" {
     SkipList._getVal_closure:
         const SkipList._getVal_info;
         const 0;
 },
 SkipList._getVal_entry() //  [R2]
         { info_tbl: [(caNw,
                       label: SkipList._getVal_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caNw:
           _sawM::P64 = R2;
           goto caNn;
       caNn:
           if ((old + 0) - <highSp> < SpLim) goto caNx; else goto caNy;
       caNy:
           goto caNm;
       caNm:
           if (HpLim == 0) goto caNx; else goto caNz;
       caNx:
           R2 = _sawM::P64;
           R1 = SkipList._getVal_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caNz:
           I64[(young<caNp> + 8)] = caNp;
           R1 = _sawM::P64;
           if (R1 & 7 != 0) goto caNp; else goto caNq;
       caNq:
           call (I64[R1])(R1) returns to caNp, args: 8, res: 8, upd: 8;
       caNp:
           _sawN::P64 = R1;
           _caNv::P64 = _sawN::P64 & 7;
           switch [1 .. 2] _caNv::P64 {
               case 1 : goto caNt;
               case 2 : goto caNu;
           }
       caNu:
           _sawO::P64 = P64[_sawN::P64 + 6];
           _sawP::P64 = P64[_sawN::P64 + 14];
           _sawQ::P64 = P64[_sawN::P64 + 22];
           R1 = _sawP::P64 & (-8);
           call (I64[R1])(R1) args: 8, res: 0, upd: 8;
       caNt:
           R1 = SkipList._getVal1_closure;
           call (I64[R1])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:44.669738 UTC

{offset
  caNw:
      _sawM::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto caNx; else goto caNy;
  caNy:
      if (HpLim == 0) goto caNx; else goto caNz;
  caNx:
      R2 = _sawM::P64;
      R1 = SkipList._getVal_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  caNz:
      I64[(young<caNp> + 8)] = caNp;
      R1 = _sawM::P64;
      if (R1 & 7 != 0) goto caNp; else goto caNq;
  caNq:
      call (I64[R1])(R1) returns to caNp, args: 8, res: 8, upd: 8;
  caNp:
      _sawN::P64 = R1;
      _caNv::P64 = _sawN::P64 & 7;
      switch [1 .. 2] _caNv::P64 {
          case 1 : goto caNt;
          case 2 : goto caNu;
      }
  caNu:
      _sawO::P64 = P64[_sawN::P64 + 6];
      _sawP::P64 = P64[_sawN::P64 + 14];
      _sawQ::P64 = P64[_sawN::P64 + 22];
      R1 = _sawP::P64 & (-8);
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
  caNt:
      R1 = SkipList._getVal1_closure;
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:44.671363 UTC

{offset
  caNw:
      _sawM::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto caNx; else goto caNy;
  caNy:
      if (HpLim == 0) goto caNx; else goto caNz;
  caNx:
      R2 = _sawM::P64;
      R1 = SkipList._getVal_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  caNz:
      I64[(young<caNp> + 8)] = caNp;
      R1 = _sawM::P64;
      if (R1 & 7 != 0) goto caNp; else goto caNq;
  caNq:
      call (I64[R1])(R1) returns to caNp, args: 8, res: 8, upd: 8;
  caNp:
      _sawN::P64 = R1;
      _caNv::P64 = _sawN::P64 & 7;
      switch [1 .. 2] _caNv::P64 {
          case 1 : goto caNt;
          case 2 : goto caNu;
      }
  caNu:
      _sawO::P64 = P64[_sawN::P64 + 6];
      _sawP::P64 = P64[_sawN::P64 + 14];
      _sawQ::P64 = P64[_sawN::P64 + 22];
      R1 = _sawP::P64 & (-8);
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
  caNt:
      R1 = SkipList._getVal1_closure;
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:44.673006 UTC

{offset
  caNw:
      _sawM::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto caNx; else goto caNy;
  caNy:
      if (HpLim == 0) goto caNx; else goto caNz;
  caNx:
      R2 = _sawM::P64;
      R1 = SkipList._getVal_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  caNz:
      I64[(young<caNp> + 8)] = caNp;
      R1 = _sawM::P64;
      if (R1 & 7 != 0) goto caNp; else goto caNq;
  caNq:
      call (I64[R1])(R1) returns to caNp, args: 8, res: 8, upd: 8;
  caNp:
      _sawN::P64 = R1;
      _caNv::P64 = _sawN::P64 & 7;
      if (_caNv::P64 != 1) goto caNu; else goto caNt;
  caNu:
      _sawO::P64 = P64[_sawN::P64 + 6];
      _sawP::P64 = P64[_sawN::P64 + 14];
      _sawQ::P64 = P64[_sawN::P64 + 22];
      R1 = _sawP::P64 & (-8);
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
  caNt:
      R1 = SkipList._getVal1_closure;
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:44.674742 UTC

{offset
  caNw:
      _sawM::P64 = R2;
      if ((Sp + 8) - 16 < SpLim) goto caNx; else goto caNy;
  caNy:
      if (HpLim == 0) goto caNx; else goto caNz;
  caNx:
      R2 = _sawM::P64;
      R1 = SkipList._getVal_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  caNz:
      I64[Sp - 8] = caNp;
      R1 = _sawM::P64;
      Sp = Sp - 8;
      if (R1 & 7 != 0) goto caNp; else goto caNq;
  caNq:
      call (I64[R1])(R1) returns to caNp, args: 8, res: 8, upd: 8;
  caNp:
      _sawN::P64 = R1;
      _caNv::P64 = _sawN::P64 & 7;
      if (_caNv::P64 != 1) goto caNu; else goto caNt;
  caNu:
      _sawO::P64 = P64[_sawN::P64 + 6];
      _sawP::P64 = P64[_sawN::P64 + 14];
      _sawQ::P64 = P64[_sawN::P64 + 22];
      R1 = _sawP::P64 & (-8);
      Sp = Sp + 8;
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
  caNt:
      R1 = SkipList._getVal1_closure;
      Sp = Sp + 8;
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:44.676367 UTC

{offset
  caNw:
      _sawM::P64 = R2;
      if ((Sp + -8) < SpLim) goto caNx; else goto caNy;
  caNy:
      if (HpLim == 0) goto caNx; else goto caNz;
  caNx:
      R2 = _sawM::P64;
      R1 = SkipList._getVal_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  caNz:
      I64[Sp - 8] = caNp;
      R1 = _sawM::P64;
      Sp = Sp - 8;
      if (R1 & 7 != 0) goto caNp; else goto caNq;
  caNq:
      call (I64[R1])(R1) returns to caNp, args: 8, res: 8, upd: 8;
  caNp:
      if (R1 & 7 != 1) goto caNu; else goto caNt;
  caNu:
      R1 = P64[R1 + 14] & (-8);
      Sp = Sp + 8;
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
  caNt:
      R1 = SkipList._getVal1_closure;
      Sp = Sp + 8;
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:44.678486 UTC

[(caNp, {SkipList._getVal1_closure}),
 (caNq, {SkipList._getVal1_closure}),
 (caNt, {SkipList._getVal1_closure}), (caNu, {}),
 (caNw, {SkipList._getVal1_closure, SkipList._getVal_closure}),
 (caNx, {SkipList._getVal_closure}),
 (caNy, {SkipList._getVal1_closure, SkipList._getVal_closure}),
 (caNz, {SkipList._getVal1_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:44.679206 UTC

SkipList._getVal_entry() //  [R2]
        { info_tbl: [(caNp,
                      label: block_caNp_info
                      rep:StackRep []),
                     (caNw,
                      label: SkipList._getVal_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caNw:
          _sawM::P64 = R2;
          if ((Sp + -8) < SpLim) goto caNx; else goto caNy;
      caNy:
          if (HpLim == 0) goto caNx; else goto caNz;
      caNx:
          R2 = _sawM::P64;
          R1 = SkipList._getVal_closure;
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
      caNz:
          I64[Sp - 8] = caNp;
          R1 = _sawM::P64;
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto caNp; else goto caNq;
      caNq:
          call (I64[R1])(R1) returns to caNp, args: 8, res: 8, upd: 8;
      caNp:
          if (R1 & 7 != 1) goto caNu; else goto caNt;
      caNu:
          R1 = P64[R1 + 14] & (-8);
          Sp = Sp + 8;
          call (I64[R1])(R1) args: 8, res: 0, upd: 8;
      caNt:
          R1 = SkipList._getVal1_closure;
          Sp = Sp + 8;
          call (I64[R1])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:44.68093 UTC

SkipList._getVal_entry() //  [R2]
        { info_tbl: [(caNp,
                      label: block_caNp_info
                      rep:StackRep []),
                     (caNw,
                      label: SkipList._getVal_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caNw:
          _sawM::P64 = R2;
          if ((Sp + -8) < SpLim) goto caNx; else goto caNy;
      caNy:
          if (HpLim == 0) goto caNx; else goto caNz;
      caNx:
          R2 = _sawM::P64;
          R1 = SkipList._getVal_closure;
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
      caNz:
          I64[Sp - 8] = caNp;
          R1 = _sawM::P64;
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto caNp; else goto caNq;
      caNq:
          call (I64[R1])(R1) returns to caNp, args: 8, res: 8, upd: 8;
      caNp:
          if (R1 & 7 != 1) goto caNu; else goto caNt;
      caNu:
          R1 = P64[R1 + 14] & (-8);
          Sp = Sp + 8;
          call (I64[R1])(R1) args: 8, res: 0, upd: 8;
      caNt:
          R1 = SkipList._getVal1_closure;
          Sp = Sp + 8;
          call (I64[R1])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:44.682675 UTC

[section "data" {
     SkipList._getVal_closure:
         const SkipList._getVal_info;
         const 0;
 },
 SkipList._getVal_entry() //  [R2]
         { info_tbl: [(caNp,
                       label: block_caNp_info
                       rep:StackRep []),
                      (caNw,
                       label: SkipList._getVal_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caNw:
           _sawM::P64 = R2;
           if ((Sp + -8) < SpLim) goto caNx; else goto caNy;
       caNy:
           if (HpLim == 0) goto caNx; else goto caNz;
       caNx:
           R2 = _sawM::P64;
           R1 = SkipList._getVal_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caNz:
           I64[Sp - 8] = caNp;
           R1 = _sawM::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto caNp; else goto caNq;
       caNq:
           call (I64[R1])(R1) returns to caNp, args: 8, res: 8, upd: 8;
       caNp:
           if (R1 & 7 != 1) goto caNu; else goto caNt;
       caNu:
           R1 = P64[R1 + 14] & (-8);
           Sp = Sp + 8;
           call (I64[R1])(R1) args: 8, res: 0, upd: 8;
       caNt:
           R1 = SkipList._getVal1_closure;
           Sp = Sp + 8;
           call (I64[R1])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:44.684655 UTC

[section "data" {
     SkipList._getVal_closure:
         const SkipList._getVal_info;
         const 0;
 },
 SkipList._getVal_entry() //  [R2]
         { info_tbl: [(caNp,
                       label: block_caNp_info
                       rep:StackRep []),
                      (caNw,
                       label: SkipList._getVal_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caNw:
           _sawM::P64 = R2;
           if ((Sp + -8) < SpLim) goto caNx; else goto caNy;
       caNy:
           if (HpLim == 0) goto caNx; else goto caNz;
       caNx:
           R2 = _sawM::P64;
           R1 = SkipList._getVal_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caNz:
           I64[Sp - 8] = caNp;
           R1 = _sawM::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto caNp; else goto caNq;
       caNq:
           call (I64[R1])(R1) returns to caNp, args: 8, res: 8, upd: 8;
       caNp:
           if (R1 & 7 != 1) goto caNu; else goto caNt;
       caNu:
           R1 = P64[R1 + 14] & (-8);
           Sp = Sp + 8;
           call (I64[R1])(R1) args: 8, res: 0, upd: 8;
       caNt:
           R1 = SkipList._getVal1_closure;
           Sp = Sp + 8;
           call (I64[R1])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:44.689925 UTC

[section "data" {
     SkipList._getKey1_closure:
         const SkipList._getKey1_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     caNU_str:
         I8[] [95,103,101,116,75,101,121]
 },
 SkipList._getKey1_entry() //  [R1]
         { info_tbl: [(caNV,
                       label: SkipList._getKey1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caNV:
           _rG::P64 = R1;
           goto caNP;
       caNP:
           if ((old + 0) - <highSp> < SpLim) goto caNW; else goto caNX;
       caNX:
           if (HpLim == 0) goto caNW; else goto caNY;
       caNW:
           R1 = _rG::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caNY:
           (_caNR::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rG::P64);
           if (_caNR::I64 == 0) goto caNT; else goto caNS;
       caNT:
           call (I64[_rG::P64])() args: 8, res: 0, upd: 8;
       caNS:
           I64[(old + 24)] = stg_bh_upd_frame_info;
           I64[(old + 16)] = _caNR::I64;
           R2 = caNU_str;
           call Control.Exception.Base.recSelError_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:44.692026 UTC

{offset
  caNV:
      _rG::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto caNW; else goto caNX;
  caNX:
      if (HpLim == 0) goto caNW; else goto caNY;
  caNW:
      R1 = _rG::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caNY:
      (_caNR::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rG::P64);
      if (_caNR::I64 == 0) goto caNT; else goto caNS;
  caNT:
      call (I64[_rG::P64])() args: 8, res: 0, upd: 8;
  caNS:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _caNR::I64;
      R2 = caNU_str;
      call Control.Exception.Base.recSelError_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:44.693236 UTC

{offset
  caNV:
      _rG::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto caNW; else goto caNX;
  caNX:
      if (HpLim == 0) goto caNW; else goto caNY;
  caNW:
      R1 = _rG::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caNY:
      (_caNR::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rG::P64);
      if (_caNR::I64 == 0) goto caNT; else goto caNS;
  caNT:
      call (I64[_rG::P64])() args: 8, res: 0, upd: 8;
  caNS:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _caNR::I64;
      R2 = caNU_str;
      call Control.Exception.Base.recSelError_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:44.694331 UTC

{offset
  caNV:
      _rG::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto caNW; else goto caNX;
  caNX:
      if (HpLim == 0) goto caNW; else goto caNY;
  caNW:
      R1 = _rG::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caNY:
      (_caNR::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rG::P64);
      if (_caNR::I64 == 0) goto caNT; else goto caNS;
  caNT:
      call (I64[_rG::P64])() args: 8, res: 0, upd: 8;
  caNS:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _caNR::I64;
      R2 = caNU_str;
      call Control.Exception.Base.recSelError_info(R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:44.695469 UTC

{offset
  caNV:
      _rG::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto caNW; else goto caNX;
  caNX:
      if (HpLim == 0) goto caNW; else goto caNY;
  caNW:
      R1 = _rG::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caNY:
      (_caNR::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rG::P64);
      if (_caNR::I64 == 0) goto caNT; else goto caNS;
  caNT:
      call (I64[_rG::P64])() args: 8, res: 0, upd: 8;
  caNS:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _caNR::I64;
      R2 = caNU_str;
      Sp = Sp - 16;
      call Control.Exception.Base.recSelError_info(R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:44.696591 UTC

{offset
  caNV:
      _rG::P64 = R1;
      if ((Sp + -16) < SpLim) goto caNW; else goto caNX;
  caNX:
      if (HpLim == 0) goto caNW; else goto caNY;
  caNW:
      R1 = _rG::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caNY:
      (_caNR::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rG::P64);
      if (_caNR::I64 == 0) goto caNT; else goto caNS;
  caNT:
      call (I64[_rG::P64])() args: 8, res: 0, upd: 8;
  caNS:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _caNR::I64;
      R2 = caNU_str;
      Sp = Sp - 16;
      call Control.Exception.Base.recSelError_info(R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:44.697871 UTC

[(caNS, {Control.Exception.Base.recSelError_closure}), (caNT, {}),
 (caNV, {Control.Exception.Base.recSelError_closure}), (caNW, {}),
 (caNX, {Control.Exception.Base.recSelError_closure}),
 (caNY, {Control.Exception.Base.recSelError_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:44.698379 UTC

SkipList._getKey1_entry() //  [R1]
        { info_tbl: [(caNV,
                      label: SkipList._getKey1_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caNV:
          _rG::P64 = R1;
          if ((Sp + -16) < SpLim) goto caNW; else goto caNX;
      caNX:
          if (HpLim == 0) goto caNW; else goto caNY;
      caNW:
          R1 = _rG::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      caNY:
          (_caNR::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rG::P64);
          if (_caNR::I64 == 0) goto caNT; else goto caNS;
      caNT:
          call (I64[_rG::P64])() args: 8, res: 0, upd: 8;
      caNS:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _caNR::I64;
          R2 = caNU_str;
          Sp = Sp - 16;
          call Control.Exception.Base.recSelError_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:44.699721 UTC

SkipList._getKey1_entry() //  [R1]
        { info_tbl: [(caNV,
                      label: SkipList._getKey1_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caNV:
          _rG::P64 = R1;
          if ((Sp + -16) < SpLim) goto caNW; else goto caNX;
      caNX:
          if (HpLim == 0) goto caNW; else goto caNY;
      caNW:
          R1 = _rG::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      caNY:
          (_caNR::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rG::P64);
          if (_caNR::I64 == 0) goto caNT; else goto caNS;
      caNT:
          call (I64[_rG::P64])() args: 8, res: 0, upd: 8;
      caNS:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _caNR::I64;
          R2 = caNU_str;
          Sp = Sp - 16;
          call Control.Exception.Base.recSelError_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:44.701096 UTC

[section "data" {
     SkipList._getKey1_closure:
         const SkipList._getKey1_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     caNU_str:
         I8[] [95,103,101,116,75,101,121]
 },
 SkipList._getKey1_entry() //  [R1]
         { info_tbl: [(caNV,
                       label: SkipList._getKey1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caNV:
           _rG::P64 = R1;
           if ((Sp + -16) < SpLim) goto caNW; else goto caNX;
       caNX:
           if (HpLim == 0) goto caNW; else goto caNY;
       caNW:
           R1 = _rG::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caNY:
           (_caNR::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rG::P64);
           if (_caNR::I64 == 0) goto caNT; else goto caNS;
       caNT:
           call (I64[_rG::P64])() args: 8, res: 0, upd: 8;
       caNS:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caNR::I64;
           R2 = caNU_str;
           Sp = Sp - 16;
           call Control.Exception.Base.recSelError_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:44.702855 UTC

[section "data" {
     SkipList._getKey1_closure:
         const SkipList._getKey1_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     caNU_str:
         I8[] [95,103,101,116,75,101,121]
 },
 SkipList._getKey1_entry() //  [R1]
         { info_tbl: [(caNV,
                       label: SkipList._getKey1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caNV:
           _rG::P64 = R1;
           if ((Sp + -16) < SpLim) goto caNW; else goto caNX;
       caNX:
           if (HpLim == 0) goto caNW; else goto caNY;
       caNW:
           R1 = _rG::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caNY:
           (_caNR::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rG::P64);
           if (_caNR::I64 == 0) goto caNT; else goto caNS;
       caNT:
           call (I64[_rG::P64])() args: 8, res: 0, upd: 8;
       caNS:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caNR::I64;
           R2 = caNU_str;
           Sp = Sp - 16;
           call Control.Exception.Base.recSelError_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:44.707636 UTC

[section "data" {
     SkipList._getKey_closure:
         const SkipList._getKey_info;
         const 0;
 },
 SkipList._getKey_entry() //  [R2]
         { info_tbl: [(caOk,
                       label: SkipList._getKey_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caOk:
           _sawR::P64 = R2;
           goto caOb;
       caOb:
           if ((old + 0) - <highSp> < SpLim) goto caOl; else goto caOm;
       caOm:
           goto caOa;
       caOa:
           if (HpLim == 0) goto caOl; else goto caOn;
       caOl:
           R2 = _sawR::P64;
           R1 = SkipList._getKey_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caOn:
           I64[(young<caOd> + 8)] = caOd;
           R1 = _sawR::P64;
           if (R1 & 7 != 0) goto caOd; else goto caOe;
       caOe:
           call (I64[R1])(R1) returns to caOd, args: 8, res: 8, upd: 8;
       caOd:
           _sawS::P64 = R1;
           _caOj::P64 = _sawS::P64 & 7;
           switch [1 .. 2] _caOj::P64 {
               case 1 : goto caOh;
               case 2 : goto caOi;
           }
       caOi:
           _sawT::P64 = P64[_sawS::P64 + 6];
           _sawU::P64 = P64[_sawS::P64 + 14];
           _sawV::P64 = P64[_sawS::P64 + 22];
           R1 = _sawT::P64;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       caOh:
           R1 = SkipList._getKey1_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:44.710565 UTC

{offset
  caOk:
      _sawR::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto caOl; else goto caOm;
  caOm:
      if (HpLim == 0) goto caOl; else goto caOn;
  caOl:
      R2 = _sawR::P64;
      R1 = SkipList._getKey_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  caOn:
      I64[(young<caOd> + 8)] = caOd;
      R1 = _sawR::P64;
      if (R1 & 7 != 0) goto caOd; else goto caOe;
  caOe:
      call (I64[R1])(R1) returns to caOd, args: 8, res: 8, upd: 8;
  caOd:
      _sawS::P64 = R1;
      _caOj::P64 = _sawS::P64 & 7;
      switch [1 .. 2] _caOj::P64 {
          case 1 : goto caOh;
          case 2 : goto caOi;
      }
  caOi:
      _sawT::P64 = P64[_sawS::P64 + 6];
      _sawU::P64 = P64[_sawS::P64 + 14];
      _sawV::P64 = P64[_sawS::P64 + 22];
      R1 = _sawT::P64;
      call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
  caOh:
      R1 = SkipList._getKey1_closure;
      call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:44.712128 UTC

{offset
  caOk:
      _sawR::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto caOl; else goto caOm;
  caOm:
      if (HpLim == 0) goto caOl; else goto caOn;
  caOl:
      R2 = _sawR::P64;
      R1 = SkipList._getKey_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  caOn:
      I64[(young<caOd> + 8)] = caOd;
      R1 = _sawR::P64;
      if (R1 & 7 != 0) goto caOd; else goto caOe;
  caOe:
      call (I64[R1])(R1) returns to caOd, args: 8, res: 8, upd: 8;
  caOd:
      _sawS::P64 = R1;
      _caOj::P64 = _sawS::P64 & 7;
      switch [1 .. 2] _caOj::P64 {
          case 1 : goto caOh;
          case 2 : goto caOi;
      }
  caOi:
      _sawT::P64 = P64[_sawS::P64 + 6];
      _sawU::P64 = P64[_sawS::P64 + 14];
      _sawV::P64 = P64[_sawS::P64 + 22];
      R1 = _sawT::P64;
      call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
  caOh:
      R1 = SkipList._getKey1_closure;
      call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:44.713744 UTC

{offset
  caOk:
      _sawR::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto caOl; else goto caOm;
  caOm:
      if (HpLim == 0) goto caOl; else goto caOn;
  caOl:
      R2 = _sawR::P64;
      R1 = SkipList._getKey_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  caOn:
      I64[(young<caOd> + 8)] = caOd;
      R1 = _sawR::P64;
      if (R1 & 7 != 0) goto caOd; else goto caOe;
  caOe:
      call (I64[R1])(R1) returns to caOd, args: 8, res: 8, upd: 8;
  caOd:
      _sawS::P64 = R1;
      _caOj::P64 = _sawS::P64 & 7;
      if (_caOj::P64 != 1) goto caOi; else goto caOh;
  caOi:
      _sawT::P64 = P64[_sawS::P64 + 6];
      _sawU::P64 = P64[_sawS::P64 + 14];
      _sawV::P64 = P64[_sawS::P64 + 22];
      R1 = _sawT::P64;
      call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
  caOh:
      R1 = SkipList._getKey1_closure;
      call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:44.715446 UTC

{offset
  caOk:
      _sawR::P64 = R2;
      if ((Sp + 8) - 16 < SpLim) goto caOl; else goto caOm;
  caOm:
      if (HpLim == 0) goto caOl; else goto caOn;
  caOl:
      R2 = _sawR::P64;
      R1 = SkipList._getKey_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  caOn:
      I64[Sp - 8] = caOd;
      R1 = _sawR::P64;
      Sp = Sp - 8;
      if (R1 & 7 != 0) goto caOd; else goto caOe;
  caOe:
      call (I64[R1])(R1) returns to caOd, args: 8, res: 8, upd: 8;
  caOd:
      _sawS::P64 = R1;
      _caOj::P64 = _sawS::P64 & 7;
      if (_caOj::P64 != 1) goto caOi; else goto caOh;
  caOi:
      _sawT::P64 = P64[_sawS::P64 + 6];
      _sawU::P64 = P64[_sawS::P64 + 14];
      _sawV::P64 = P64[_sawS::P64 + 22];
      R1 = _sawT::P64;
      Sp = Sp + 8;
      call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
  caOh:
      R1 = SkipList._getKey1_closure;
      Sp = Sp + 8;
      call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:44.717593 UTC

{offset
  caOk:
      _sawR::P64 = R2;
      if ((Sp + -8) < SpLim) goto caOl; else goto caOm;
  caOm:
      if (HpLim == 0) goto caOl; else goto caOn;
  caOl:
      R2 = _sawR::P64;
      R1 = SkipList._getKey_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  caOn:
      I64[Sp - 8] = caOd;
      R1 = _sawR::P64;
      Sp = Sp - 8;
      if (R1 & 7 != 0) goto caOd; else goto caOe;
  caOe:
      call (I64[R1])(R1) returns to caOd, args: 8, res: 8, upd: 8;
  caOd:
      if (R1 & 7 != 1) goto caOi; else goto caOh;
  caOi:
      R1 = P64[R1 + 6];
      Sp = Sp + 8;
      call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
  caOh:
      R1 = SkipList._getKey1_closure;
      Sp = Sp + 8;
      call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:44.719127 UTC

[(caOd, {SkipList._getKey1_closure}),
 (caOe, {SkipList._getKey1_closure}),
 (caOh, {SkipList._getKey1_closure}), (caOi, {}),
 (caOk, {SkipList._getKey1_closure, SkipList._getKey_closure}),
 (caOl, {SkipList._getKey_closure}),
 (caOm, {SkipList._getKey1_closure, SkipList._getKey_closure}),
 (caOn, {SkipList._getKey1_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:44.719865 UTC

SkipList._getKey_entry() //  [R2]
        { info_tbl: [(caOd,
                      label: block_caOd_info
                      rep:StackRep []),
                     (caOk,
                      label: SkipList._getKey_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caOk:
          _sawR::P64 = R2;
          if ((Sp + -8) < SpLim) goto caOl; else goto caOm;
      caOm:
          if (HpLim == 0) goto caOl; else goto caOn;
      caOl:
          R2 = _sawR::P64;
          R1 = SkipList._getKey_closure;
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
      caOn:
          I64[Sp - 8] = caOd;
          R1 = _sawR::P64;
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto caOd; else goto caOe;
      caOe:
          call (I64[R1])(R1) returns to caOd, args: 8, res: 8, upd: 8;
      caOd:
          if (R1 & 7 != 1) goto caOi; else goto caOh;
      caOi:
          R1 = P64[R1 + 6];
          Sp = Sp + 8;
          call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
      caOh:
          R1 = SkipList._getKey1_closure;
          Sp = Sp + 8;
          call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:44.721594 UTC

SkipList._getKey_entry() //  [R2]
        { info_tbl: [(caOd,
                      label: block_caOd_info
                      rep:StackRep []),
                     (caOk,
                      label: SkipList._getKey_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caOk:
          _sawR::P64 = R2;
          if ((Sp + -8) < SpLim) goto caOl; else goto caOm;
      caOm:
          if (HpLim == 0) goto caOl; else goto caOn;
      caOl:
          R2 = _sawR::P64;
          R1 = SkipList._getKey_closure;
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
      caOn:
          I64[Sp - 8] = caOd;
          R1 = _sawR::P64;
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto caOd; else goto caOe;
      caOe:
          call (I64[R1])(R1) returns to caOd, args: 8, res: 8, upd: 8;
      caOd:
          if (R1 & 7 != 1) goto caOi; else goto caOh;
      caOi:
          R1 = P64[R1 + 6];
          Sp = Sp + 8;
          call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
      caOh:
          R1 = SkipList._getKey1_closure;
          Sp = Sp + 8;
          call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:44.723336 UTC

[section "data" {
     SkipList._getKey_closure:
         const SkipList._getKey_info;
         const 0;
 },
 SkipList._getKey_entry() //  [R2]
         { info_tbl: [(caOd,
                       label: block_caOd_info
                       rep:StackRep []),
                      (caOk,
                       label: SkipList._getKey_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caOk:
           _sawR::P64 = R2;
           if ((Sp + -8) < SpLim) goto caOl; else goto caOm;
       caOm:
           if (HpLim == 0) goto caOl; else goto caOn;
       caOl:
           R2 = _sawR::P64;
           R1 = SkipList._getKey_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caOn:
           I64[Sp - 8] = caOd;
           R1 = _sawR::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto caOd; else goto caOe;
       caOe:
           call (I64[R1])(R1) returns to caOd, args: 8, res: 8, upd: 8;
       caOd:
           if (R1 & 7 != 1) goto caOi; else goto caOh;
       caOi:
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       caOh:
           R1 = SkipList._getKey1_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:44.725277 UTC

[section "data" {
     SkipList._getKey_closure:
         const SkipList._getKey_info;
         const 0;
 },
 SkipList._getKey_entry() //  [R2]
         { info_tbl: [(caOd,
                       label: block_caOd_info
                       rep:StackRep []),
                      (caOk,
                       label: SkipList._getKey_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caOk:
           _sawR::P64 = R2;
           if ((Sp + -8) < SpLim) goto caOl; else goto caOm;
       caOm:
           if (HpLim == 0) goto caOl; else goto caOn;
       caOl:
           R2 = _sawR::P64;
           R1 = SkipList._getKey_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caOn:
           I64[Sp - 8] = caOd;
           R1 = _sawR::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto caOd; else goto caOe;
       caOe:
           call (I64[R1])(R1) returns to caOd, args: 8, res: 8, upd: 8;
       caOd:
           if (R1 & 7 != 1) goto caOi; else goto caOh;
       caOi:
           R1 = P64[R1 + 6];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       caOh:
           R1 = SkipList._getKey1_closure;
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:44.730419 UTC

[section "data" {
     SkipList._getStates_closure:
         const SkipList._getStates_info;
 },
 SkipList._getStates_entry() //  [R2]
         { info_tbl: [(caOL,
                       label: SkipList._getStates_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caOL:
           _sawW::P64 = R2;
           goto caOG;
       caOG:
           if ((old + 0) - <highSp> < SpLim) goto caOM; else goto caON;
       caON:
           goto caOF;
       caOF:
           if (HpLim == 0) goto caOM; else goto caOO;
       caOM:
           R2 = _sawW::P64;
           R1 = SkipList._getStates_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caOO:
           I64[(young<caOI> + 8)] = caOI;
           R1 = _sawW::P64;
           if (R1 & 7 != 0) goto caOI; else goto caOJ;
       caOJ:
           call (I64[R1])(R1) returns to caOI, args: 8, res: 8, upd: 8;
       caOI:
           _sawX::P64 = R1;
           _sawY::P64 = P64[_sawX::P64 + 7];
           _sawZ::P64 = P64[_sawX::P64 + 15];
           _sax0::P64 = P64[_sawX::P64 + 23];
           R1 = _sax0::P64;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:44.732902 UTC

{offset
  caOL:
      _sawW::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto caOM; else goto caON;
  caON:
      if (HpLim == 0) goto caOM; else goto caOO;
  caOM:
      R2 = _sawW::P64;
      R1 = SkipList._getStates_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  caOO:
      I64[(young<caOI> + 8)] = caOI;
      R1 = _sawW::P64;
      if (R1 & 7 != 0) goto caOI; else goto caOJ;
  caOJ:
      call (I64[R1])(R1) returns to caOI, args: 8, res: 8, upd: 8;
  caOI:
      _sawX::P64 = R1;
      _sawY::P64 = P64[_sawX::P64 + 7];
      _sawZ::P64 = P64[_sawX::P64 + 15];
      _sax0::P64 = P64[_sawX::P64 + 23];
      R1 = _sax0::P64;
      call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:44.734097 UTC

{offset
  caOL:
      _sawW::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto caOM; else goto caON;
  caON:
      if (HpLim == 0) goto caOM; else goto caOO;
  caOM:
      R2 = _sawW::P64;
      R1 = SkipList._getStates_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  caOO:
      I64[(young<caOI> + 8)] = caOI;
      R1 = _sawW::P64;
      if (R1 & 7 != 0) goto caOI; else goto caOJ;
  caOJ:
      call (I64[R1])(R1) returns to caOI, args: 8, res: 8, upd: 8;
  caOI:
      _sawX::P64 = R1;
      _sawY::P64 = P64[_sawX::P64 + 7];
      _sawZ::P64 = P64[_sawX::P64 + 15];
      _sax0::P64 = P64[_sawX::P64 + 23];
      R1 = _sax0::P64;
      call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:44.735328 UTC

{offset
  caOL:
      _sawW::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto caOM; else goto caON;
  caON:
      if (HpLim == 0) goto caOM; else goto caOO;
  caOM:
      R2 = _sawW::P64;
      R1 = SkipList._getStates_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  caOO:
      I64[(young<caOI> + 8)] = caOI;
      R1 = _sawW::P64;
      if (R1 & 7 != 0) goto caOI; else goto caOJ;
  caOJ:
      call (I64[R1])(R1) returns to caOI, args: 8, res: 8, upd: 8;
  caOI:
      _sawX::P64 = R1;
      _sawY::P64 = P64[_sawX::P64 + 7];
      _sawZ::P64 = P64[_sawX::P64 + 15];
      _sax0::P64 = P64[_sawX::P64 + 23];
      R1 = _sax0::P64;
      call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:44.736714 UTC

{offset
  caOL:
      _sawW::P64 = R2;
      if ((Sp + 8) - 16 < SpLim) goto caOM; else goto caON;
  caON:
      if (HpLim == 0) goto caOM; else goto caOO;
  caOM:
      R2 = _sawW::P64;
      R1 = SkipList._getStates_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  caOO:
      I64[Sp - 8] = caOI;
      R1 = _sawW::P64;
      Sp = Sp - 8;
      if (R1 & 7 != 0) goto caOI; else goto caOJ;
  caOJ:
      call (I64[R1])(R1) returns to caOI, args: 8, res: 8, upd: 8;
  caOI:
      _sawX::P64 = R1;
      _sawY::P64 = P64[_sawX::P64 + 7];
      _sawZ::P64 = P64[_sawX::P64 + 15];
      _sax0::P64 = P64[_sawX::P64 + 23];
      R1 = _sax0::P64;
      Sp = Sp + 8;
      call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:44.737992 UTC

{offset
  caOL:
      _sawW::P64 = R2;
      if ((Sp + -8) < SpLim) goto caOM; else goto caON;
  caON:
      if (HpLim == 0) goto caOM; else goto caOO;
  caOM:
      R2 = _sawW::P64;
      R1 = SkipList._getStates_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  caOO:
      I64[Sp - 8] = caOI;
      R1 = _sawW::P64;
      Sp = Sp - 8;
      if (R1 & 7 != 0) goto caOI; else goto caOJ;
  caOJ:
      call (I64[R1])(R1) returns to caOI, args: 8, res: 8, upd: 8;
  caOI:
      R1 = P64[R1 + 23];
      Sp = Sp + 8;
      call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:44.7392 UTC

[(caOI, {}), (caOJ, {}), (caOL, {}), (caOM, {}), (caON, {}),
 (caOO, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:44.739579 UTC

SkipList._getStates_entry() //  [R2]
        { info_tbl: [(caOI,
                      label: block_caOI_info
                      rep:StackRep []),
                     (caOL,
                      label: SkipList._getStates_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caOL:
          _sawW::P64 = R2;
          if ((Sp + -8) < SpLim) goto caOM; else goto caON;
      caON:
          if (HpLim == 0) goto caOM; else goto caOO;
      caOM:
          R2 = _sawW::P64;
          R1 = SkipList._getStates_closure;
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
      caOO:
          I64[Sp - 8] = caOI;
          R1 = _sawW::P64;
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto caOI; else goto caOJ;
      caOJ:
          call (I64[R1])(R1) returns to caOI, args: 8, res: 8, upd: 8;
      caOI:
          R1 = P64[R1 + 23];
          Sp = Sp + 8;
          call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:44.741019 UTC

SkipList._getStates_entry() //  [R2]
        { info_tbl: [(caOI,
                      label: block_caOI_info
                      rep:StackRep []),
                     (caOL,
                      label: SkipList._getStates_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caOL:
          _sawW::P64 = R2;
          if ((Sp + -8) < SpLim) goto caOM; else goto caON;
      caON:
          if (HpLim == 0) goto caOM; else goto caOO;
      caOM:
          R2 = _sawW::P64;
          R1 = SkipList._getStates_closure;
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
      caOO:
          I64[Sp - 8] = caOI;
          R1 = _sawW::P64;
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto caOI; else goto caOJ;
      caOJ:
          call (I64[R1])(R1) returns to caOI, args: 8, res: 8, upd: 8;
      caOI:
          R1 = P64[R1 + 23];
          Sp = Sp + 8;
          call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:44.742438 UTC

[section "data" {
     SkipList._getStates_closure:
         const SkipList._getStates_info;
 },
 SkipList._getStates_entry() //  [R2]
         { info_tbl: [(caOI,
                       label: block_caOI_info
                       rep:StackRep []),
                      (caOL,
                       label: SkipList._getStates_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caOL:
           _sawW::P64 = R2;
           if ((Sp + -8) < SpLim) goto caOM; else goto caON;
       caON:
           if (HpLim == 0) goto caOM; else goto caOO;
       caOM:
           R2 = _sawW::P64;
           R1 = SkipList._getStates_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caOO:
           I64[Sp - 8] = caOI;
           R1 = _sawW::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto caOI; else goto caOJ;
       caOJ:
           call (I64[R1])(R1) returns to caOI, args: 8, res: 8, upd: 8;
       caOI:
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:44.744028 UTC

[section "data" {
     SkipList._getStates_closure:
         const SkipList._getStates_info;
 },
 SkipList._getStates_entry() //  [R2]
         { info_tbl: [(caOI,
                       label: block_caOI_info
                       rep:StackRep []),
                      (caOL,
                       label: SkipList._getStates_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caOL:
           _sawW::P64 = R2;
           if ((Sp + -8) < SpLim) goto caOM; else goto caON;
       caON:
           if (HpLim == 0) goto caOM; else goto caOO;
       caOM:
           R2 = _sawW::P64;
           R1 = SkipList._getStates_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caOO:
           I64[Sp - 8] = caOI;
           R1 = _sawW::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto caOI; else goto caOJ;
       caOJ:
           call (I64[R1])(R1) returns to caOI, args: 8, res: 8, upd: 8;
       caOI:
           R1 = P64[R1 + 23];
           Sp = Sp + 8;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:44.748154 UTC

[section "data" {
     SkipList._getHeight_closure:
         const SkipList._getHeight_info;
 },
 SkipList._getHeight_entry() //  [R2]
         { info_tbl: [(caP7,
                       label: SkipList._getHeight_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caP7:
           _sax1::P64 = R2;
           goto caP2;
       caP2:
           if ((old + 0) - <highSp> < SpLim) goto caP8; else goto caP9;
       caP9:
           goto caP1;
       caP1:
           if (HpLim == 0) goto caP8; else goto caPa;
       caP8:
           R2 = _sax1::P64;
           R1 = SkipList._getHeight_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caPa:
           I64[(young<caP4> + 8)] = caP4;
           R1 = _sax1::P64;
           if (R1 & 7 != 0) goto caP4; else goto caP5;
       caP5:
           call (I64[R1])(R1) returns to caP4, args: 8, res: 8, upd: 8;
       caP4:
           _sax2::P64 = R1;
           _sax3::P64 = P64[_sax2::P64 + 7];
           _sax4::P64 = P64[_sax2::P64 + 15];
           _sax5::P64 = P64[_sax2::P64 + 23];
           R1 = _sax4::P64 & (-8);
           call (I64[R1])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:44.750546 UTC

{offset
  caP7:
      _sax1::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto caP8; else goto caP9;
  caP9:
      if (HpLim == 0) goto caP8; else goto caPa;
  caP8:
      R2 = _sax1::P64;
      R1 = SkipList._getHeight_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  caPa:
      I64[(young<caP4> + 8)] = caP4;
      R1 = _sax1::P64;
      if (R1 & 7 != 0) goto caP4; else goto caP5;
  caP5:
      call (I64[R1])(R1) returns to caP4, args: 8, res: 8, upd: 8;
  caP4:
      _sax2::P64 = R1;
      _sax3::P64 = P64[_sax2::P64 + 7];
      _sax4::P64 = P64[_sax2::P64 + 15];
      _sax5::P64 = P64[_sax2::P64 + 23];
      R1 = _sax4::P64 & (-8);
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:44.751794 UTC

{offset
  caP7:
      _sax1::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto caP8; else goto caP9;
  caP9:
      if (HpLim == 0) goto caP8; else goto caPa;
  caP8:
      R2 = _sax1::P64;
      R1 = SkipList._getHeight_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  caPa:
      I64[(young<caP4> + 8)] = caP4;
      R1 = _sax1::P64;
      if (R1 & 7 != 0) goto caP4; else goto caP5;
  caP5:
      call (I64[R1])(R1) returns to caP4, args: 8, res: 8, upd: 8;
  caP4:
      _sax2::P64 = R1;
      _sax3::P64 = P64[_sax2::P64 + 7];
      _sax4::P64 = P64[_sax2::P64 + 15];
      _sax5::P64 = P64[_sax2::P64 + 23];
      R1 = _sax4::P64 & (-8);
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:44.753088 UTC

{offset
  caP7:
      _sax1::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto caP8; else goto caP9;
  caP9:
      if (HpLim == 0) goto caP8; else goto caPa;
  caP8:
      R2 = _sax1::P64;
      R1 = SkipList._getHeight_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  caPa:
      I64[(young<caP4> + 8)] = caP4;
      R1 = _sax1::P64;
      if (R1 & 7 != 0) goto caP4; else goto caP5;
  caP5:
      call (I64[R1])(R1) returns to caP4, args: 8, res: 8, upd: 8;
  caP4:
      _sax2::P64 = R1;
      _sax3::P64 = P64[_sax2::P64 + 7];
      _sax4::P64 = P64[_sax2::P64 + 15];
      _sax5::P64 = P64[_sax2::P64 + 23];
      R1 = _sax4::P64 & (-8);
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:44.754525 UTC

{offset
  caP7:
      _sax1::P64 = R2;
      if ((Sp + 8) - 16 < SpLim) goto caP8; else goto caP9;
  caP9:
      if (HpLim == 0) goto caP8; else goto caPa;
  caP8:
      R2 = _sax1::P64;
      R1 = SkipList._getHeight_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  caPa:
      I64[Sp - 8] = caP4;
      R1 = _sax1::P64;
      Sp = Sp - 8;
      if (R1 & 7 != 0) goto caP4; else goto caP5;
  caP5:
      call (I64[R1])(R1) returns to caP4, args: 8, res: 8, upd: 8;
  caP4:
      _sax2::P64 = R1;
      _sax3::P64 = P64[_sax2::P64 + 7];
      _sax4::P64 = P64[_sax2::P64 + 15];
      _sax5::P64 = P64[_sax2::P64 + 23];
      R1 = _sax4::P64 & (-8);
      Sp = Sp + 8;
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:44.756381 UTC

{offset
  caP7:
      _sax1::P64 = R2;
      if ((Sp + -8) < SpLim) goto caP8; else goto caP9;
  caP9:
      if (HpLim == 0) goto caP8; else goto caPa;
  caP8:
      R2 = _sax1::P64;
      R1 = SkipList._getHeight_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  caPa:
      I64[Sp - 8] = caP4;
      R1 = _sax1::P64;
      Sp = Sp - 8;
      if (R1 & 7 != 0) goto caP4; else goto caP5;
  caP5:
      call (I64[R1])(R1) returns to caP4, args: 8, res: 8, upd: 8;
  caP4:
      R1 = P64[R1 + 15] & (-8);
      Sp = Sp + 8;
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:44.757682 UTC

[(caP4, {}), (caP5, {}), (caP7, {}), (caP8, {}), (caP9, {}),
 (caPa, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:44.75807 UTC

SkipList._getHeight_entry() //  [R2]
        { info_tbl: [(caP4,
                      label: block_caP4_info
                      rep:StackRep []),
                     (caP7,
                      label: SkipList._getHeight_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caP7:
          _sax1::P64 = R2;
          if ((Sp + -8) < SpLim) goto caP8; else goto caP9;
      caP9:
          if (HpLim == 0) goto caP8; else goto caPa;
      caP8:
          R2 = _sax1::P64;
          R1 = SkipList._getHeight_closure;
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
      caPa:
          I64[Sp - 8] = caP4;
          R1 = _sax1::P64;
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto caP4; else goto caP5;
      caP5:
          call (I64[R1])(R1) returns to caP4, args: 8, res: 8, upd: 8;
      caP4:
          R1 = P64[R1 + 15] & (-8);
          Sp = Sp + 8;
          call (I64[R1])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:44.75955 UTC

SkipList._getHeight_entry() //  [R2]
        { info_tbl: [(caP4,
                      label: block_caP4_info
                      rep:StackRep []),
                     (caP7,
                      label: SkipList._getHeight_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caP7:
          _sax1::P64 = R2;
          if ((Sp + -8) < SpLim) goto caP8; else goto caP9;
      caP9:
          if (HpLim == 0) goto caP8; else goto caPa;
      caP8:
          R2 = _sax1::P64;
          R1 = SkipList._getHeight_closure;
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
      caPa:
          I64[Sp - 8] = caP4;
          R1 = _sax1::P64;
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto caP4; else goto caP5;
      caP5:
          call (I64[R1])(R1) returns to caP4, args: 8, res: 8, upd: 8;
      caP4:
          R1 = P64[R1 + 15] & (-8);
          Sp = Sp + 8;
          call (I64[R1])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:44.761028 UTC

[section "data" {
     SkipList._getHeight_closure:
         const SkipList._getHeight_info;
 },
 SkipList._getHeight_entry() //  [R2]
         { info_tbl: [(caP4,
                       label: block_caP4_info
                       rep:StackRep []),
                      (caP7,
                       label: SkipList._getHeight_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caP7:
           _sax1::P64 = R2;
           if ((Sp + -8) < SpLim) goto caP8; else goto caP9;
       caP9:
           if (HpLim == 0) goto caP8; else goto caPa;
       caP8:
           R2 = _sax1::P64;
           R1 = SkipList._getHeight_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caPa:
           I64[Sp - 8] = caP4;
           R1 = _sax1::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto caP4; else goto caP5;
       caP5:
           call (I64[R1])(R1) returns to caP4, args: 8, res: 8, upd: 8;
       caP4:
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[R1])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:44.762672 UTC

[section "data" {
     SkipList._getHeight_closure:
         const SkipList._getHeight_info;
 },
 SkipList._getHeight_entry() //  [R2]
         { info_tbl: [(caP4,
                       label: block_caP4_info
                       rep:StackRep []),
                      (caP7,
                       label: SkipList._getHeight_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caP7:
           _sax1::P64 = R2;
           if ((Sp + -8) < SpLim) goto caP8; else goto caP9;
       caP9:
           if (HpLim == 0) goto caP8; else goto caPa;
       caP8:
           R2 = _sax1::P64;
           R1 = SkipList._getHeight_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caPa:
           I64[Sp - 8] = caP4;
           R1 = _sax1::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto caP4; else goto caP5;
       caP5:
           call (I64[R1])(R1) returns to caP4, args: 8, res: 8, upd: 8;
       caP4:
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[R1])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:44.766945 UTC

[section "data" {
     SkipList._getHeadNodes_closure:
         const SkipList._getHeadNodes_info;
 },
 SkipList._getHeadNodes_entry() //  [R2]
         { info_tbl: [(caPu,
                       label: SkipList._getHeadNodes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caPu:
           _sax6::P64 = R2;
           goto caPp;
       caPp:
           if ((old + 0) - <highSp> < SpLim) goto caPv; else goto caPw;
       caPw:
           goto caPo;
       caPo:
           if (HpLim == 0) goto caPv; else goto caPx;
       caPv:
           R2 = _sax6::P64;
           R1 = SkipList._getHeadNodes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caPx:
           I64[(young<caPr> + 8)] = caPr;
           R1 = _sax6::P64;
           if (R1 & 7 != 0) goto caPr; else goto caPs;
       caPs:
           call (I64[R1])(R1) returns to caPr, args: 8, res: 8, upd: 8;
       caPr:
           _sax7::P64 = R1;
           _sax8::P64 = P64[_sax7::P64 + 7];
           _sax9::P64 = P64[_sax7::P64 + 15];
           _saxa::P64 = P64[_sax7::P64 + 23];
           R1 = _sax8::P64 & (-8);
           call (I64[R1])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:44.76939 UTC

{offset
  caPu:
      _sax6::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto caPv; else goto caPw;
  caPw:
      if (HpLim == 0) goto caPv; else goto caPx;
  caPv:
      R2 = _sax6::P64;
      R1 = SkipList._getHeadNodes_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  caPx:
      I64[(young<caPr> + 8)] = caPr;
      R1 = _sax6::P64;
      if (R1 & 7 != 0) goto caPr; else goto caPs;
  caPs:
      call (I64[R1])(R1) returns to caPr, args: 8, res: 8, upd: 8;
  caPr:
      _sax7::P64 = R1;
      _sax8::P64 = P64[_sax7::P64 + 7];
      _sax9::P64 = P64[_sax7::P64 + 15];
      _saxa::P64 = P64[_sax7::P64 + 23];
      R1 = _sax8::P64 & (-8);
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:44.770644 UTC

{offset
  caPu:
      _sax6::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto caPv; else goto caPw;
  caPw:
      if (HpLim == 0) goto caPv; else goto caPx;
  caPv:
      R2 = _sax6::P64;
      R1 = SkipList._getHeadNodes_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  caPx:
      I64[(young<caPr> + 8)] = caPr;
      R1 = _sax6::P64;
      if (R1 & 7 != 0) goto caPr; else goto caPs;
  caPs:
      call (I64[R1])(R1) returns to caPr, args: 8, res: 8, upd: 8;
  caPr:
      _sax7::P64 = R1;
      _sax8::P64 = P64[_sax7::P64 + 7];
      _sax9::P64 = P64[_sax7::P64 + 15];
      _saxa::P64 = P64[_sax7::P64 + 23];
      R1 = _sax8::P64 & (-8);
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:44.771905 UTC

{offset
  caPu:
      _sax6::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto caPv; else goto caPw;
  caPw:
      if (HpLim == 0) goto caPv; else goto caPx;
  caPv:
      R2 = _sax6::P64;
      R1 = SkipList._getHeadNodes_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  caPx:
      I64[(young<caPr> + 8)] = caPr;
      R1 = _sax6::P64;
      if (R1 & 7 != 0) goto caPr; else goto caPs;
  caPs:
      call (I64[R1])(R1) returns to caPr, args: 8, res: 8, upd: 8;
  caPr:
      _sax7::P64 = R1;
      _sax8::P64 = P64[_sax7::P64 + 7];
      _sax9::P64 = P64[_sax7::P64 + 15];
      _saxa::P64 = P64[_sax7::P64 + 23];
      R1 = _sax8::P64 & (-8);
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:44.773435 UTC

{offset
  caPu:
      _sax6::P64 = R2;
      if ((Sp + 8) - 16 < SpLim) goto caPv; else goto caPw;
  caPw:
      if (HpLim == 0) goto caPv; else goto caPx;
  caPv:
      R2 = _sax6::P64;
      R1 = SkipList._getHeadNodes_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  caPx:
      I64[Sp - 8] = caPr;
      R1 = _sax6::P64;
      Sp = Sp - 8;
      if (R1 & 7 != 0) goto caPr; else goto caPs;
  caPs:
      call (I64[R1])(R1) returns to caPr, args: 8, res: 8, upd: 8;
  caPr:
      _sax7::P64 = R1;
      _sax8::P64 = P64[_sax7::P64 + 7];
      _sax9::P64 = P64[_sax7::P64 + 15];
      _saxa::P64 = P64[_sax7::P64 + 23];
      R1 = _sax8::P64 & (-8);
      Sp = Sp + 8;
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:44.774716 UTC

{offset
  caPu:
      _sax6::P64 = R2;
      if ((Sp + -8) < SpLim) goto caPv; else goto caPw;
  caPw:
      if (HpLim == 0) goto caPv; else goto caPx;
  caPv:
      R2 = _sax6::P64;
      R1 = SkipList._getHeadNodes_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  caPx:
      I64[Sp - 8] = caPr;
      R1 = _sax6::P64;
      Sp = Sp - 8;
      if (R1 & 7 != 0) goto caPr; else goto caPs;
  caPs:
      call (I64[R1])(R1) returns to caPr, args: 8, res: 8, upd: 8;
  caPr:
      R1 = P64[R1 + 7] & (-8);
      Sp = Sp + 8;
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:44.775953 UTC

[(caPr, {}), (caPs, {}), (caPu, {}), (caPv, {}), (caPw, {}),
 (caPx, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:44.776332 UTC

SkipList._getHeadNodes_entry() //  [R2]
        { info_tbl: [(caPr,
                      label: block_caPr_info
                      rep:StackRep []),
                     (caPu,
                      label: SkipList._getHeadNodes_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caPu:
          _sax6::P64 = R2;
          if ((Sp + -8) < SpLim) goto caPv; else goto caPw;
      caPw:
          if (HpLim == 0) goto caPv; else goto caPx;
      caPv:
          R2 = _sax6::P64;
          R1 = SkipList._getHeadNodes_closure;
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
      caPx:
          I64[Sp - 8] = caPr;
          R1 = _sax6::P64;
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto caPr; else goto caPs;
      caPs:
          call (I64[R1])(R1) returns to caPr, args: 8, res: 8, upd: 8;
      caPr:
          R1 = P64[R1 + 7] & (-8);
          Sp = Sp + 8;
          call (I64[R1])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:44.777816 UTC

SkipList._getHeadNodes_entry() //  [R2]
        { info_tbl: [(caPr,
                      label: block_caPr_info
                      rep:StackRep []),
                     (caPu,
                      label: SkipList._getHeadNodes_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caPu:
          _sax6::P64 = R2;
          if ((Sp + -8) < SpLim) goto caPv; else goto caPw;
      caPw:
          if (HpLim == 0) goto caPv; else goto caPx;
      caPv:
          R2 = _sax6::P64;
          R1 = SkipList._getHeadNodes_closure;
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
      caPx:
          I64[Sp - 8] = caPr;
          R1 = _sax6::P64;
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto caPr; else goto caPs;
      caPs:
          call (I64[R1])(R1) returns to caPr, args: 8, res: 8, upd: 8;
      caPr:
          R1 = P64[R1 + 7] & (-8);
          Sp = Sp + 8;
          call (I64[R1])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:44.779267 UTC

[section "data" {
     SkipList._getHeadNodes_closure:
         const SkipList._getHeadNodes_info;
 },
 SkipList._getHeadNodes_entry() //  [R2]
         { info_tbl: [(caPr,
                       label: block_caPr_info
                       rep:StackRep []),
                      (caPu,
                       label: SkipList._getHeadNodes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caPu:
           _sax6::P64 = R2;
           if ((Sp + -8) < SpLim) goto caPv; else goto caPw;
       caPw:
           if (HpLim == 0) goto caPv; else goto caPx;
       caPv:
           R2 = _sax6::P64;
           R1 = SkipList._getHeadNodes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caPx:
           I64[Sp - 8] = caPr;
           R1 = _sax6::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto caPr; else goto caPs;
       caPs:
           call (I64[R1])(R1) returns to caPr, args: 8, res: 8, upd: 8;
       caPr:
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[R1])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:44.780868 UTC

[section "data" {
     SkipList._getHeadNodes_closure:
         const SkipList._getHeadNodes_info;
 },
 SkipList._getHeadNodes_entry() //  [R2]
         { info_tbl: [(caPr,
                       label: block_caPr_info
                       rep:StackRep []),
                      (caPu,
                       label: SkipList._getHeadNodes_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caPu:
           _sax6::P64 = R2;
           if ((Sp + -8) < SpLim) goto caPv; else goto caPw;
       caPw:
           if (HpLim == 0) goto caPv; else goto caPx;
       caPv:
           R2 = _sax6::P64;
           R1 = SkipList._getHeadNodes_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caPx:
           I64[Sp - 8] = caPr;
           R1 = _sax6::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto caPr; else goto caPs;
       caPs:
           call (I64[R1])(R1) returns to caPr, args: 8, res: 8, upd: 8;
       caPr:
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[R1])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:44.78528 UTC

[section "data" {
     SkipList.$fMArrayTArrayeSTM1_closure:
         const SkipList.$fMArrayTArrayeSTM1_info;
 },
 SkipList.$fMArrayTArrayeSTM1_entry() //  [R5, R4, R3, R2]
         { info_tbl: [(caQ1,
                       label: SkipList.$fMArrayTArrayeSTM1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caQ1:
           _saxe::P64 = R5;
           _saxd::P64 = R4;
           _saxc::P64 = R3;
           _saxb::P64 = R2;
           goto caPW;
       caPW:
           if ((old + 0) - <highSp> < SpLim) goto caQf; else goto caQg;
       caQg:
           goto caPV;
       caPV:
           if (HpLim == 0) goto caQf; else goto caQh;
       caQf:
           R5 = _saxe::P64;
           R4 = _saxd::P64;
           R3 = _saxc::P64;
           R2 = _saxb::P64;
           R1 = SkipList.$fMArrayTArrayeSTM1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caQh:
           I64[(young<caPY> + 8)] = caPY;
           R1 = _saxc::P64;
           if (R1 & 7 != 0) goto caPY; else goto caPZ;
       caPZ:
           call (I64[R1])(R1) returns to caPY, args: 8, res: 8, upd: 8;
       caPY:
           _saxg::P64 = R1;
           _saxh::P64 = P64[_saxg::P64 + 7];
           _saxi::P64 = P64[_saxg::P64 + 15];
           _saxk::P64 = P64[_saxg::P64 + 23];
           _saxj::I64 = I64[_saxg::P64 + 31];
           I64[(young<caQ4> + 8)] = caQ4;
           R1 = _saxd::P64;
           if (R1 & 7 != 0) goto caQ4; else goto caQ5;
       caQ5:
           call (I64[R1])(R1) returns to caQ4, args: 8, res: 8, upd: 8;
       caQ4:
           _saxl::P64 = R1;
           _saxm::I64 = I64[_saxl::P64 + 7];
           _saxo::P64 = P64[(_saxk::P64 + 24) + (_saxm::I64 << 3)];
           _saxo::P64 = _saxo::P64;
           I64[(young<caQ9> + 8)] = caQ9;
           R1 = _saxo::P64;
           if (R1 & 7 != 0) goto caQ9; else goto caQa;
       caQa:
           call (I64[R1])(R1) returns to caQ9, args: 8, res: 8, upd: 8;
       caQ9:
           _saxp::P64 = R1;
           _saxq::P64 = P64[_saxp::P64 + 7];
           I64[(young<caQe> + 8)] = caQe;
           R2 = _saxe::P64;
           R1 = _saxq::P64;
           call stg_norec_writeTVar#(R2,
                                     R1) returns to caQe, args: 8, res: 8, upd: 8;
       caQe:
           R1 = GHC.Tuple.()_closure+1;
           call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:44.789889 UTC

{offset
  caQ1:
      _saxe::P64 = R5;
      _saxd::P64 = R4;
      _saxc::P64 = R3;
      _saxb::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto caQf; else goto caQg;
  caQg:
      if (HpLim == 0) goto caQf; else goto caQh;
  caQf:
      R5 = _saxe::P64;
      R4 = _saxd::P64;
      R3 = _saxc::P64;
      R2 = _saxb::P64;
      R1 = SkipList.$fMArrayTArrayeSTM1_closure;
      call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  caQh:
      I64[(young<caPY> + 8)] = caPY;
      R1 = _saxc::P64;
      if (R1 & 7 != 0) goto caPY; else goto caPZ;
  caPZ:
      call (I64[R1])(R1) returns to caPY, args: 8, res: 8, upd: 8;
  caPY:
      _saxg::P64 = R1;
      _saxh::P64 = P64[_saxg::P64 + 7];
      _saxi::P64 = P64[_saxg::P64 + 15];
      _saxk::P64 = P64[_saxg::P64 + 23];
      _saxj::I64 = I64[_saxg::P64 + 31];
      I64[(young<caQ4> + 8)] = caQ4;
      R1 = _saxd::P64;
      if (R1 & 7 != 0) goto caQ4; else goto caQ5;
  caQ5:
      call (I64[R1])(R1) returns to caQ4, args: 8, res: 8, upd: 8;
  caQ4:
      _saxl::P64 = R1;
      _saxm::I64 = I64[_saxl::P64 + 7];
      _saxo::P64 = P64[(_saxk::P64 + 24) + (_saxm::I64 << 3)];
      _saxo::P64 = _saxo::P64;
      I64[(young<caQ9> + 8)] = caQ9;
      R1 = _saxo::P64;
      if (R1 & 7 != 0) goto caQ9; else goto caQa;
  caQa:
      call (I64[R1])(R1) returns to caQ9, args: 8, res: 8, upd: 8;
  caQ9:
      _saxp::P64 = R1;
      _saxq::P64 = P64[_saxp::P64 + 7];
      I64[(young<caQe> + 8)] = caQe;
      R2 = _saxe::P64;
      R1 = _saxq::P64;
      call stg_norec_writeTVar#(R2,
                                R1) returns to caQe, args: 8, res: 8, upd: 8;
  caQe:
      R1 = GHC.Tuple.()_closure+1;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:44.792563 UTC

{offset
  caQ1:
      _saxe::P64 = R5;
      _saxd::P64 = R4;
      _saxc::P64 = R3;
      _saxb::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto caQf; else goto caQg;
  caQg:
      if (HpLim == 0) goto caQf; else goto caQh;
  caQf:
      R5 = _saxe::P64;
      R4 = _saxd::P64;
      R3 = _saxc::P64;
      R2 = _saxb::P64;
      R1 = SkipList.$fMArrayTArrayeSTM1_closure;
      call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  caQh:
      I64[(young<caPY> + 8)] = caPY;
      R1 = _saxc::P64;
      if (R1 & 7 != 0) goto caPY; else goto caPZ;
  caPZ:
      call (I64[R1])(R1) returns to caPY, args: 8, res: 8, upd: 8;
  caPY:
      _saxg::P64 = R1;
      _saxh::P64 = P64[_saxg::P64 + 7];
      _saxi::P64 = P64[_saxg::P64 + 15];
      _saxk::P64 = P64[_saxg::P64 + 23];
      _saxj::I64 = I64[_saxg::P64 + 31];
      I64[(young<caQ4> + 8)] = caQ4;
      R1 = _saxd::P64;
      if (R1 & 7 != 0) goto caQ4; else goto caQ5;
  caQ5:
      call (I64[R1])(R1) returns to caQ4, args: 8, res: 8, upd: 8;
  caQ4:
      _saxl::P64 = R1;
      _saxm::I64 = I64[_saxl::P64 + 7];
      _saxo::P64 = P64[(_saxk::P64 + 24) + (_saxm::I64 << 3)];
      _saxo::P64 = _saxo::P64;
      I64[(young<caQ9> + 8)] = caQ9;
      R1 = _saxo::P64;
      if (R1 & 7 != 0) goto caQ9; else goto caQa;
  caQa:
      call (I64[R1])(R1) returns to caQ9, args: 8, res: 8, upd: 8;
  caQ9:
      _saxp::P64 = R1;
      _saxq::P64 = P64[_saxp::P64 + 7];
      I64[(young<caQe> + 8)] = caQe;
      R2 = _saxe::P64;
      R1 = _saxq::P64;
      call stg_norec_writeTVar#(R2,
                                R1) returns to caQe, args: 8, res: 8, upd: 8;
  caQe:
      R1 = GHC.Tuple.()_closure+1;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:44.795231 UTC

{offset
  caQ1:
      _saxe::P64 = R5;
      _saxd::P64 = R4;
      _saxc::P64 = R3;
      _saxb::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto caQf; else goto caQg;
  caQg:
      if (HpLim == 0) goto caQf; else goto caQh;
  caQf:
      R5 = _saxe::P64;
      R4 = _saxd::P64;
      R3 = _saxc::P64;
      R2 = _saxb::P64;
      R1 = SkipList.$fMArrayTArrayeSTM1_closure;
      call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  caQh:
      I64[(young<caPY> + 8)] = caPY;
      R1 = _saxc::P64;
      if (R1 & 7 != 0) goto caPY; else goto caPZ;
  caPZ:
      call (I64[R1])(R1) returns to caPY, args: 8, res: 8, upd: 8;
  caPY:
      _saxg::P64 = R1;
      _saxh::P64 = P64[_saxg::P64 + 7];
      _saxi::P64 = P64[_saxg::P64 + 15];
      _saxk::P64 = P64[_saxg::P64 + 23];
      _saxj::I64 = I64[_saxg::P64 + 31];
      I64[(young<caQ4> + 8)] = caQ4;
      R1 = _saxd::P64;
      if (R1 & 7 != 0) goto caQ4; else goto caQ5;
  caQ5:
      call (I64[R1])(R1) returns to caQ4, args: 8, res: 8, upd: 8;
  caQ4:
      _saxl::P64 = R1;
      _saxm::I64 = I64[_saxl::P64 + 7];
      _saxo::P64 = P64[(_saxk::P64 + 24) + (_saxm::I64 << 3)];
      _saxo::P64 = _saxo::P64;
      I64[(young<caQ9> + 8)] = caQ9;
      R1 = _saxo::P64;
      if (R1 & 7 != 0) goto caQ9; else goto caQa;
  caQa:
      call (I64[R1])(R1) returns to caQ9, args: 8, res: 8, upd: 8;
  caQ9:
      _saxp::P64 = R1;
      _saxq::P64 = P64[_saxp::P64 + 7];
      I64[(young<caQe> + 8)] = caQe;
      R2 = _saxe::P64;
      R1 = _saxq::P64;
      call stg_norec_writeTVar#(R2,
                                R1) returns to caQe, args: 8, res: 8, upd: 8;
  caQe:
      R1 = GHC.Tuple.()_closure+1;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:44.79885 UTC

{offset
  caQ1:
      _saxe::P64 = R5;
      _saxd::P64 = R4;
      _saxc::P64 = R3;
      _saxb::P64 = R2;
      if ((Sp + 8) - 32 < SpLim) goto caQf; else goto caQg;
  caQg:
      if (HpLim == 0) goto caQf; else goto caQh;
  caQf:
      R5 = _saxe::P64;
      R4 = _saxd::P64;
      R3 = _saxc::P64;
      R2 = _saxb::P64;
      R1 = SkipList.$fMArrayTArrayeSTM1_closure;
      call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  caQh:
      I64[Sp - 24] = caPY;
      R1 = _saxc::P64;
      P64[Sp - 16] = _saxd::P64;
      P64[Sp - 8] = _saxe::P64;
      Sp = Sp - 24;
      if (R1 & 7 != 0) goto caPY; else goto caPZ;
  caPZ:
      call (I64[R1])(R1) returns to caPY, args: 8, res: 8, upd: 8;
  caPY:
      _saxd::P64 = P64[Sp + 8];
      _saxe::P64 = P64[Sp + 16];
      _saxg::P64 = R1;
      _saxh::P64 = P64[_saxg::P64 + 7];
      _saxi::P64 = P64[_saxg::P64 + 15];
      _saxk::P64 = P64[_saxg::P64 + 23];
      _saxj::I64 = I64[_saxg::P64 + 31];
      I64[Sp] = caQ4;
      R1 = _saxd::P64;
      P64[Sp + 8] = _saxk::P64;
      if (R1 & 7 != 0) goto caQ4; else goto caQ5;
  caQ5:
      call (I64[R1])(R1) returns to caQ4, args: 8, res: 8, upd: 8;
  caQ4:
      _saxe::P64 = P64[Sp + 16];
      _saxk::P64 = P64[Sp + 8];
      _saxl::P64 = R1;
      _saxm::I64 = I64[_saxl::P64 + 7];
      _saxo::P64 = P64[(_saxk::P64 + 24) + (_saxm::I64 << 3)];
      _saxo::P64 = _saxo::P64;
      I64[Sp + 8] = caQ9;
      R1 = _saxo::P64;
      Sp = Sp + 8;
      if (R1 & 7 != 0) goto caQ9; else goto caQa;
  caQa:
      call (I64[R1])(R1) returns to caQ9, args: 8, res: 8, upd: 8;
  caQ9:
      _saxe::P64 = P64[Sp + 8];
      _saxp::P64 = R1;
      _saxq::P64 = P64[_saxp::P64 + 7];
      I64[Sp + 8] = caQe;
      R2 = _saxe::P64;
      R1 = _saxq::P64;
      Sp = Sp + 8;
      call stg_norec_writeTVar#(R2,
                                R1) returns to caQe, args: 8, res: 8, upd: 8;
  caQe:
      R1 = GHC.Tuple.()_closure+1;
      Sp = Sp + 8;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:44.802071 UTC

{offset
  caQ1:
      _saxe::P64 = R5;
      _saxd::P64 = R4;
      _saxc::P64 = R3;
      _saxb::P64 = R2;
      if ((Sp + -24) < SpLim) goto caQf; else goto caQg;
  caQg:
      if (HpLim == 0) goto caQf; else goto caQh;
  caQf:
      R5 = _saxe::P64;
      R4 = _saxd::P64;
      R3 = _saxc::P64;
      R2 = _saxb::P64;
      R1 = SkipList.$fMArrayTArrayeSTM1_closure;
      call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  caQh:
      I64[Sp - 24] = caPY;
      R1 = _saxc::P64;
      P64[Sp - 16] = _saxd::P64;
      P64[Sp - 8] = _saxe::P64;
      Sp = Sp - 24;
      if (R1 & 7 != 0) goto caPY; else goto caPZ;
  caPZ:
      call (I64[R1])(R1) returns to caPY, args: 8, res: 8, upd: 8;
  caPY:
      I64[Sp] = caQ4;
      _saxk::P64 = P64[R1 + 23];
      R1 = P64[Sp + 8];
      P64[Sp + 8] = _saxk::P64;
      if (R1 & 7 != 0) goto caQ4; else goto caQ5;
  caQ5:
      call (I64[R1])(R1) returns to caQ4, args: 8, res: 8, upd: 8;
  caQ4:
      _saxo::P64 = P64[P64[Sp + 8] + ((I64[R1 + 7] << 3) + 24)];
      I64[Sp + 8] = caQ9;
      R1 = _saxo::P64;
      Sp = Sp + 8;
      if (R1 & 7 != 0) goto caQ9; else goto caQa;
  caQa:
      call (I64[R1])(R1) returns to caQ9, args: 8, res: 8, upd: 8;
  caQ9:
      _saxe::P64 = P64[Sp + 8];
      I64[Sp + 8] = caQe;
      R2 = _saxe::P64;
      R1 = P64[R1 + 7];
      Sp = Sp + 8;
      call stg_norec_writeTVar#(R2,
                                R1) returns to caQe, args: 8, res: 8, upd: 8;
  caQe:
      R1 = GHC.Tuple.()_closure+1;
      Sp = Sp + 8;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:44.805028 UTC

[(caPY, {}), (caPZ, {}), (caQ1, {}), (caQ4, {}), (caQ5, {}),
 (caQ9, {}), (caQa, {}), (caQe, {}), (caQf, {}), (caQg, {}),
 (caQh, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:44.805571 UTC

SkipList.$fMArrayTArrayeSTM1_entry() //  [R5, R4, R3, R2]
        { info_tbl: [(caPY,
                      label: block_caPY_info
                      rep:StackRep [False, False]),
                     (caQ1,
                      label: SkipList.$fMArrayTArrayeSTM1_info
                      rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} }),
                     (caQ4,
                      label: block_caQ4_info
                      rep:StackRep [False, False]),
                     (caQ9,
                      label: block_caQ9_info
                      rep:StackRep [False]),
                     (caQe,
                      label: block_caQe_info
                      rep:StackRep [])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caQ1:
          _saxe::P64 = R5;
          _saxd::P64 = R4;
          _saxc::P64 = R3;
          _saxb::P64 = R2;
          if ((Sp + -24) < SpLim) goto caQf; else goto caQg;
      caQg:
          if (HpLim == 0) goto caQf; else goto caQh;
      caQf:
          R5 = _saxe::P64;
          R4 = _saxd::P64;
          R3 = _saxc::P64;
          R2 = _saxb::P64;
          R1 = SkipList.$fMArrayTArrayeSTM1_closure;
          call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
      caQh:
          I64[Sp - 24] = caPY;
          R1 = _saxc::P64;
          P64[Sp - 16] = _saxd::P64;
          P64[Sp - 8] = _saxe::P64;
          Sp = Sp - 24;
          if (R1 & 7 != 0) goto caPY; else goto caPZ;
      caPZ:
          call (I64[R1])(R1) returns to caPY, args: 8, res: 8, upd: 8;
      caPY:
          I64[Sp] = caQ4;
          _saxk::P64 = P64[R1 + 23];
          R1 = P64[Sp + 8];
          P64[Sp + 8] = _saxk::P64;
          if (R1 & 7 != 0) goto caQ4; else goto caQ5;
      caQ5:
          call (I64[R1])(R1) returns to caQ4, args: 8, res: 8, upd: 8;
      caQ4:
          _saxo::P64 = P64[P64[Sp + 8] + ((I64[R1 + 7] << 3) + 24)];
          I64[Sp + 8] = caQ9;
          R1 = _saxo::P64;
          Sp = Sp + 8;
          if (R1 & 7 != 0) goto caQ9; else goto caQa;
      caQa:
          call (I64[R1])(R1) returns to caQ9, args: 8, res: 8, upd: 8;
      caQ9:
          _saxe::P64 = P64[Sp + 8];
          I64[Sp + 8] = caQe;
          R2 = _saxe::P64;
          R1 = P64[R1 + 7];
          Sp = Sp + 8;
          call stg_norec_writeTVar#(R2,
                                    R1) returns to caQe, args: 8, res: 8, upd: 8;
      caQe:
          R1 = GHC.Tuple.()_closure+1;
          Sp = Sp + 8;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:44.808951 UTC

SkipList.$fMArrayTArrayeSTM1_entry() //  [R5, R4, R3, R2]
        { info_tbl: [(caPY,
                      label: block_caPY_info
                      rep:StackRep [False, False]),
                     (caQ1,
                      label: SkipList.$fMArrayTArrayeSTM1_info
                      rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} }),
                     (caQ4,
                      label: block_caQ4_info
                      rep:StackRep [False, False]),
                     (caQ9,
                      label: block_caQ9_info
                      rep:StackRep [False]),
                     (caQe,
                      label: block_caQe_info
                      rep:StackRep [])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caQ1:
          _saxe::P64 = R5;
          _saxd::P64 = R4;
          _saxc::P64 = R3;
          _saxb::P64 = R2;
          if ((Sp + -24) < SpLim) goto caQf; else goto caQg;
      caQg:
          if (HpLim == 0) goto caQf; else goto caQh;
      caQf:
          R5 = _saxe::P64;
          R4 = _saxd::P64;
          R3 = _saxc::P64;
          R2 = _saxb::P64;
          R1 = SkipList.$fMArrayTArrayeSTM1_closure;
          call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
      caQh:
          I64[Sp - 24] = caPY;
          R1 = _saxc::P64;
          P64[Sp - 16] = _saxd::P64;
          P64[Sp - 8] = _saxe::P64;
          Sp = Sp - 24;
          if (R1 & 7 != 0) goto caPY; else goto caPZ;
      caPZ:
          call (I64[R1])(R1) returns to caPY, args: 8, res: 8, upd: 8;
      caPY:
          I64[Sp] = caQ4;
          _saxk::P64 = P64[R1 + 23];
          R1 = P64[Sp + 8];
          P64[Sp + 8] = _saxk::P64;
          if (R1 & 7 != 0) goto caQ4; else goto caQ5;
      caQ5:
          call (I64[R1])(R1) returns to caQ4, args: 8, res: 8, upd: 8;
      caQ4:
          _saxo::P64 = P64[P64[Sp + 8] + ((I64[R1 + 7] << 3) + 24)];
          I64[Sp + 8] = caQ9;
          R1 = _saxo::P64;
          Sp = Sp + 8;
          if (R1 & 7 != 0) goto caQ9; else goto caQa;
      caQa:
          call (I64[R1])(R1) returns to caQ9, args: 8, res: 8, upd: 8;
      caQ9:
          _saxe::P64 = P64[Sp + 8];
          I64[Sp + 8] = caQe;
          R2 = _saxe::P64;
          R1 = P64[R1 + 7];
          Sp = Sp + 8;
          call stg_norec_writeTVar#(R2,
                                    R1) returns to caQe, args: 8, res: 8, upd: 8;
      caQe:
          R1 = GHC.Tuple.()_closure+1;
          Sp = Sp + 8;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:44.812309 UTC

[section "data" {
     SkipList.$fMArrayTArrayeSTM1_closure:
         const SkipList.$fMArrayTArrayeSTM1_info;
 },
 SkipList.$fMArrayTArrayeSTM1_entry() //  [R5, R4, R3, R2]
         { info_tbl: [(caPY,
                       label: block_caPY_info
                       rep:StackRep [False, False]),
                      (caQ1,
                       label: SkipList.$fMArrayTArrayeSTM1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} }),
                      (caQ4,
                       label: block_caQ4_info
                       rep:StackRep [False, False]),
                      (caQ9,
                       label: block_caQ9_info
                       rep:StackRep [False]),
                      (caQe,
                       label: block_caQe_info
                       rep:StackRep [])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caQ1:
           _saxe::P64 = R5;
           _saxd::P64 = R4;
           _saxc::P64 = R3;
           _saxb::P64 = R2;
           if ((Sp + -24) < SpLim) goto caQf; else goto caQg;
       caQg:
           if (HpLim == 0) goto caQf; else goto caQh;
       caQf:
           R5 = _saxe::P64;
           R4 = _saxd::P64;
           R3 = _saxc::P64;
           R2 = _saxb::P64;
           R1 = SkipList.$fMArrayTArrayeSTM1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caQh:
           I64[Sp - 24] = caPY;
           R1 = _saxc::P64;
           P64[Sp - 16] = _saxd::P64;
           P64[Sp - 8] = _saxe::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto caPY; else goto caPZ;
       caPZ:
           call (I64[R1])(R1) returns to caPY, args: 8, res: 8, upd: 8;
       caPY:
           I64[Sp] = caQ4;
           _saxk::P64 = P64[R1 + 23];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _saxk::P64;
           if (R1 & 7 != 0) goto caQ4; else goto caQ5;
       caQ5:
           call (I64[R1])(R1) returns to caQ4, args: 8, res: 8, upd: 8;
       caQ4:
           _saxo::P64 = P64[P64[Sp + 8] + ((I64[R1 + 7] << 3) + 24)];
           I64[Sp + 8] = caQ9;
           R1 = _saxo::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto caQ9; else goto caQa;
       caQa:
           call (I64[R1])(R1) returns to caQ9, args: 8, res: 8, upd: 8;
       caQ9:
           _saxe::P64 = P64[Sp + 8];
           I64[Sp + 8] = caQe;
           R2 = _saxe::P64;
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_norec_writeTVar#(R2,
                                     R1) returns to caQe, args: 8, res: 8, upd: 8;
       caQe:
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:44.815943 UTC

[section "data" {
     SkipList.$fMArrayTArrayeSTM1_closure:
         const SkipList.$fMArrayTArrayeSTM1_info;
 },
 SkipList.$fMArrayTArrayeSTM1_entry() //  [R5, R4, R3, R2]
         { info_tbl: [(caPY,
                       label: block_caPY_info
                       rep:StackRep [False, False]),
                      (caQ1,
                       label: SkipList.$fMArrayTArrayeSTM1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} }),
                      (caQ4,
                       label: block_caQ4_info
                       rep:StackRep [False, False]),
                      (caQ9,
                       label: block_caQ9_info
                       rep:StackRep [False]),
                      (caQe,
                       label: block_caQe_info
                       rep:StackRep [])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caQ1:
           _saxe::P64 = R5;
           _saxd::P64 = R4;
           _saxc::P64 = R3;
           _saxb::P64 = R2;
           if ((Sp + -24) < SpLim) goto caQf; else goto caQg;
       caQg:
           if (HpLim == 0) goto caQf; else goto caQh;
       caQf:
           R5 = _saxe::P64;
           R4 = _saxd::P64;
           R3 = _saxc::P64;
           R2 = _saxb::P64;
           R1 = SkipList.$fMArrayTArrayeSTM1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caQh:
           I64[Sp - 24] = caPY;
           R1 = _saxc::P64;
           P64[Sp - 16] = _saxd::P64;
           P64[Sp - 8] = _saxe::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto caPY; else goto caPZ;
       caPZ:
           call (I64[R1])(R1) returns to caPY, args: 8, res: 8, upd: 8;
       caPY:
           I64[Sp] = caQ4;
           _saxk::P64 = P64[R1 + 23];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _saxk::P64;
           if (R1 & 7 != 0) goto caQ4; else goto caQ5;
       caQ5:
           call (I64[R1])(R1) returns to caQ4, args: 8, res: 8, upd: 8;
       caQ4:
           _saxo::P64 = P64[P64[Sp + 8] + ((I64[R1 + 7] << 3) + 24)];
           I64[Sp + 8] = caQ9;
           R1 = _saxo::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto caQ9; else goto caQa;
       caQa:
           call (I64[R1])(R1) returns to caQ9, args: 8, res: 8, upd: 8;
       caQ9:
           _saxe::P64 = P64[Sp + 8];
           I64[Sp + 8] = caQe;
           R2 = _saxe::P64;
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_norec_writeTVar#(R2,
                                     R1) returns to caQe, args: 8, res: 8, upd: 8;
       caQe:
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:44.824637 UTC

[section "data" {
     SkipList.$fMArrayTArrayeSTM_$cunsafeWrite_closure:
         const SkipList.$fMArrayTArrayeSTM_$cunsafeWrite_info;
 },
 SkipList.$fMArrayTArrayeSTM_$cunsafeWrite_entry() //  [R5, R4, R3,
                                                        R2]
         { info_tbl: [(caQA,
                       label: SkipList.$fMArrayTArrayeSTM_$cunsafeWrite_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caQA:
           _B2::P64 = R5;
           _B3::P64 = R4;
           _B4::P64 = R3;
           _B5::P64 = R2;
           goto caQy;
       caQy:
           if ((old + 0) - <highSp> < SpLim) goto caQB; else goto caQC;
       caQC:
           goto caQx;
       caQx:
           if (HpLim == 0) goto caQB; else goto caQD;
       caQB:
           R5 = _B2::P64;
           R4 = _B3::P64;
           R3 = _B4::P64;
           R2 = _B5::P64;
           R1 = SkipList.$fMArrayTArrayeSTM_$cunsafeWrite_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caQD:
           R5 = _B2::P64;
           R4 = _B3::P64;
           R3 = _B4::P64;
           R2 = _B5::P64;
           call SkipList.$fMArrayTArrayeSTM1_info(R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:44.826766 UTC

{offset
  caQA:
      _B2::P64 = R5;
      _B3::P64 = R4;
      _B4::P64 = R3;
      _B5::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto caQB; else goto caQC;
  caQC:
      if (HpLim == 0) goto caQB; else goto caQD;
  caQB:
      R5 = _B2::P64;
      R4 = _B3::P64;
      R3 = _B4::P64;
      R2 = _B5::P64;
      R1 = SkipList.$fMArrayTArrayeSTM_$cunsafeWrite_closure;
      call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  caQD:
      R5 = _B2::P64;
      R4 = _B3::P64;
      R3 = _B4::P64;
      R2 = _B5::P64;
      call SkipList.$fMArrayTArrayeSTM1_info(R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:44.827873 UTC

{offset
  caQA:
      _B2::P64 = R5;
      _B3::P64 = R4;
      _B4::P64 = R3;
      _B5::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto caQB; else goto caQC;
  caQC:
      if (HpLim == 0) goto caQB; else goto caQD;
  caQB:
      R5 = _B2::P64;
      R4 = _B3::P64;
      R3 = _B4::P64;
      R2 = _B5::P64;
      R1 = SkipList.$fMArrayTArrayeSTM_$cunsafeWrite_closure;
      call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  caQD:
      R5 = _B2::P64;
      R4 = _B3::P64;
      R3 = _B4::P64;
      R2 = _B5::P64;
      call SkipList.$fMArrayTArrayeSTM1_info(R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:44.828979 UTC

{offset
  caQA:
      _B2::P64 = R5;
      _B3::P64 = R4;
      _B4::P64 = R3;
      _B5::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto caQB; else goto caQC;
  caQC:
      if (HpLim == 0) goto caQB; else goto caQD;
  caQB:
      R5 = _B2::P64;
      R4 = _B3::P64;
      R3 = _B4::P64;
      R2 = _B5::P64;
      R1 = SkipList.$fMArrayTArrayeSTM_$cunsafeWrite_closure;
      call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  caQD:
      R5 = _B2::P64;
      R4 = _B3::P64;
      R3 = _B4::P64;
      R2 = _B5::P64;
      call SkipList.$fMArrayTArrayeSTM1_info(R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:44.830129 UTC

{offset
  caQA:
      _B2::P64 = R5;
      _B3::P64 = R4;
      _B4::P64 = R3;
      _B5::P64 = R2;
      goto caQC;
  caQC:
      if (HpLim == 0) goto caQB; else goto caQD;
  caQB:
      R5 = _B2::P64;
      R4 = _B3::P64;
      R3 = _B4::P64;
      R2 = _B5::P64;
      R1 = SkipList.$fMArrayTArrayeSTM_$cunsafeWrite_closure;
      call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  caQD:
      R5 = _B2::P64;
      R4 = _B3::P64;
      R3 = _B4::P64;
      R2 = _B5::P64;
      call SkipList.$fMArrayTArrayeSTM1_info(R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:44.831154 UTC

{offset
  caQA:
      goto caQC;
  caQC:
      if (HpLim == 0) goto caQB; else goto caQD;
  caQB:
      R5 = R5;
      R4 = R4;
      R3 = R3;
      R2 = R2;
      R1 = SkipList.$fMArrayTArrayeSTM_$cunsafeWrite_closure;
      call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  caQD:
      R5 = R5;
      R4 = R4;
      R3 = R3;
      R2 = R2;
      call SkipList.$fMArrayTArrayeSTM1_info(R5,
                                             R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:44.832266 UTC

[(caQA, {}), (caQB, {}), (caQC, {}), (caQD, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:44.832616 UTC

SkipList.$fMArrayTArrayeSTM_$cunsafeWrite_entry() //  [R5, R4, R3,
                                                       R2]
        { info_tbl: [(caQA,
                      label: SkipList.$fMArrayTArrayeSTM_$cunsafeWrite_info
                      rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caQA:
          goto caQC;
      caQC:
          if (HpLim == 0) goto caQB; else goto caQD;
      caQB:
          R5 = R5;
          R4 = R4;
          R3 = R3;
          R2 = R2;
          R1 = SkipList.$fMArrayTArrayeSTM_$cunsafeWrite_closure;
          call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
      caQD:
          R5 = R5;
          R4 = R4;
          R3 = R3;
          R2 = R2;
          call SkipList.$fMArrayTArrayeSTM1_info(R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:44.833751 UTC

SkipList.$fMArrayTArrayeSTM_$cunsafeWrite_entry() //  [R5, R4, R3,
                                                       R2]
        { info_tbl: [(caQA,
                      label: SkipList.$fMArrayTArrayeSTM_$cunsafeWrite_info
                      rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caQA:
          if (HpLim == 0) goto caQB; else goto caQD;
      caQB:
          R5 = R5;
          R4 = R4;
          R3 = R3;
          R2 = R2;
          R1 = SkipList.$fMArrayTArrayeSTM_$cunsafeWrite_closure;
          call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
      caQD:
          R5 = R5;
          R4 = R4;
          R3 = R3;
          R2 = R2;
          call SkipList.$fMArrayTArrayeSTM1_info(R5,
                                                 R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:44.834863 UTC

[section "data" {
     SkipList.$fMArrayTArrayeSTM_$cunsafeWrite_closure:
         const SkipList.$fMArrayTArrayeSTM_$cunsafeWrite_info;
 },
 SkipList.$fMArrayTArrayeSTM_$cunsafeWrite_entry() //  [R5, R4, R3,
                                                        R2]
         { info_tbl: [(caQA,
                       label: SkipList.$fMArrayTArrayeSTM_$cunsafeWrite_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caQA:
           if (HpLim == 0) goto caQB; else goto caQD;
       caQB:
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = SkipList.$fMArrayTArrayeSTM_$cunsafeWrite_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caQD:
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call SkipList.$fMArrayTArrayeSTM1_info(R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:44.83613 UTC

[section "data" {
     SkipList.$fMArrayTArrayeSTM_$cunsafeWrite_closure:
         const SkipList.$fMArrayTArrayeSTM_$cunsafeWrite_info;
 },
 SkipList.$fMArrayTArrayeSTM_$cunsafeWrite_entry() //  [R5, R4, R3,
                                                        R2]
         { info_tbl: [(caQA,
                       label: SkipList.$fMArrayTArrayeSTM_$cunsafeWrite_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caQA:
           if (HpLim == 0) goto caQB; else goto caQD;
       caQB:
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = SkipList.$fMArrayTArrayeSTM_$cunsafeWrite_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caQD:
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call SkipList.$fMArrayTArrayeSTM1_info(R5,
                                                  R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:44.839146 UTC

[section "data" {
     SkipList.$fMArrayTArrayeSTM2_closure:
         const SkipList.$fMArrayTArrayeSTM2_info;
 },
 SkipList.$fMArrayTArrayeSTM2_entry() //  [R4, R3, R2]
         { info_tbl: [(caQZ,
                       label: SkipList.$fMArrayTArrayeSTM2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caQZ:
           _saxu::P64 = R4;
           _saxt::P64 = R3;
           _saxs::P64 = R2;
           goto caQU;
       caQU:
           if ((old + 0) - <highSp> < SpLim) goto caR8; else goto caR9;
       caR9:
           goto caQT;
       caQT:
           if (HpLim == 0) goto caR8; else goto caRa;
       caR8:
           R4 = _saxu::P64;
           R3 = _saxt::P64;
           R2 = _saxs::P64;
           R1 = SkipList.$fMArrayTArrayeSTM2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caRa:
           I64[(young<caQW> + 8)] = caQW;
           R1 = _saxt::P64;
           if (R1 & 7 != 0) goto caQW; else goto caQX;
       caQX:
           call (I64[R1])(R1) returns to caQW, args: 8, res: 8, upd: 8;
       caQW:
           _saxw::P64 = R1;
           _saxx::P64 = P64[_saxw::P64 + 7];
           _saxy::P64 = P64[_saxw::P64 + 15];
           _saxA::P64 = P64[_saxw::P64 + 23];
           _saxz::I64 = I64[_saxw::P64 + 31];
           I64[(young<caR2> + 8)] = caR2;
           R1 = _saxu::P64;
           if (R1 & 7 != 0) goto caR2; else goto caR3;
       caR3:
           call (I64[R1])(R1) returns to caR2, args: 8, res: 8, upd: 8;
       caR2:
           _saxB::P64 = R1;
           _saxC::I64 = I64[_saxB::P64 + 7];
           _saxE::P64 = P64[(_saxA::P64 + 24) + (_saxC::I64 << 3)];
           _saxE::P64 = _saxE::P64;
           I64[(young<caR7> + 8)] = caR7;
           R1 = _saxE::P64;
           if (R1 & 7 != 0) goto caR7; else goto caRd;
       caRd:
           call (I64[R1])(R1) returns to caR7, args: 8, res: 8, upd: 8;
       caR7:
           _saxF::P64 = R1;
           _saxG::P64 = P64[_saxF::P64 + 7];
           R1 = _saxG::P64;
           call stg_norec_readTVar#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:44.843241 UTC

{offset
  caQZ:
      _saxu::P64 = R4;
      _saxt::P64 = R3;
      _saxs::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto caR8; else goto caR9;
  caR9:
      if (HpLim == 0) goto caR8; else goto caRa;
  caR8:
      R4 = _saxu::P64;
      R3 = _saxt::P64;
      R2 = _saxs::P64;
      R1 = SkipList.$fMArrayTArrayeSTM2_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  caRa:
      I64[(young<caQW> + 8)] = caQW;
      R1 = _saxt::P64;
      if (R1 & 7 != 0) goto caQW; else goto caQX;
  caQX:
      call (I64[R1])(R1) returns to caQW, args: 8, res: 8, upd: 8;
  caQW:
      _saxw::P64 = R1;
      _saxx::P64 = P64[_saxw::P64 + 7];
      _saxy::P64 = P64[_saxw::P64 + 15];
      _saxA::P64 = P64[_saxw::P64 + 23];
      _saxz::I64 = I64[_saxw::P64 + 31];
      I64[(young<caR2> + 8)] = caR2;
      R1 = _saxu::P64;
      if (R1 & 7 != 0) goto caR2; else goto caR3;
  caR3:
      call (I64[R1])(R1) returns to caR2, args: 8, res: 8, upd: 8;
  caR2:
      _saxB::P64 = R1;
      _saxC::I64 = I64[_saxB::P64 + 7];
      _saxE::P64 = P64[(_saxA::P64 + 24) + (_saxC::I64 << 3)];
      _saxE::P64 = _saxE::P64;
      I64[(young<caR7> + 8)] = caR7;
      R1 = _saxE::P64;
      if (R1 & 7 != 0) goto caR7; else goto caRd;
  caRd:
      call (I64[R1])(R1) returns to caR7, args: 8, res: 8, upd: 8;
  caR7:
      _saxF::P64 = R1;
      _saxG::P64 = P64[_saxF::P64 + 7];
      R1 = _saxG::P64;
      call stg_norec_readTVar#(R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:44.845557 UTC

{offset
  caQZ:
      _saxu::P64 = R4;
      _saxt::P64 = R3;
      _saxs::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto caR8; else goto caR9;
  caR9:
      if (HpLim == 0) goto caR8; else goto caRa;
  caR8:
      R4 = _saxu::P64;
      R3 = _saxt::P64;
      R2 = _saxs::P64;
      R1 = SkipList.$fMArrayTArrayeSTM2_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  caRa:
      I64[(young<caQW> + 8)] = caQW;
      R1 = _saxt::P64;
      if (R1 & 7 != 0) goto caQW; else goto caQX;
  caQX:
      call (I64[R1])(R1) returns to caQW, args: 8, res: 8, upd: 8;
  caQW:
      _saxw::P64 = R1;
      _saxx::P64 = P64[_saxw::P64 + 7];
      _saxy::P64 = P64[_saxw::P64 + 15];
      _saxA::P64 = P64[_saxw::P64 + 23];
      _saxz::I64 = I64[_saxw::P64 + 31];
      I64[(young<caR2> + 8)] = caR2;
      R1 = _saxu::P64;
      if (R1 & 7 != 0) goto caR2; else goto caR3;
  caR3:
      call (I64[R1])(R1) returns to caR2, args: 8, res: 8, upd: 8;
  caR2:
      _saxB::P64 = R1;
      _saxC::I64 = I64[_saxB::P64 + 7];
      _saxE::P64 = P64[(_saxA::P64 + 24) + (_saxC::I64 << 3)];
      _saxE::P64 = _saxE::P64;
      I64[(young<caR7> + 8)] = caR7;
      R1 = _saxE::P64;
      if (R1 & 7 != 0) goto caR7; else goto caRd;
  caRd:
      call (I64[R1])(R1) returns to caR7, args: 8, res: 8, upd: 8;
  caR7:
      _saxF::P64 = R1;
      _saxG::P64 = P64[_saxF::P64 + 7];
      R1 = _saxG::P64;
      call stg_norec_readTVar#(R1) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:44.847931 UTC

{offset
  caQZ:
      _saxu::P64 = R4;
      _saxt::P64 = R3;
      _saxs::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto caR8; else goto caR9;
  caR9:
      if (HpLim == 0) goto caR8; else goto caRa;
  caR8:
      R4 = _saxu::P64;
      R3 = _saxt::P64;
      R2 = _saxs::P64;
      R1 = SkipList.$fMArrayTArrayeSTM2_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  caRa:
      I64[(young<caQW> + 8)] = caQW;
      R1 = _saxt::P64;
      if (R1 & 7 != 0) goto caQW; else goto caQX;
  caQX:
      call (I64[R1])(R1) returns to caQW, args: 8, res: 8, upd: 8;
  caQW:
      _saxw::P64 = R1;
      _saxx::P64 = P64[_saxw::P64 + 7];
      _saxy::P64 = P64[_saxw::P64 + 15];
      _saxA::P64 = P64[_saxw::P64 + 23];
      _saxz::I64 = I64[_saxw::P64 + 31];
      I64[(young<caR2> + 8)] = caR2;
      R1 = _saxu::P64;
      if (R1 & 7 != 0) goto caR2; else goto caR3;
  caR3:
      call (I64[R1])(R1) returns to caR2, args: 8, res: 8, upd: 8;
  caR2:
      _saxB::P64 = R1;
      _saxC::I64 = I64[_saxB::P64 + 7];
      _saxE::P64 = P64[(_saxA::P64 + 24) + (_saxC::I64 << 3)];
      _saxE::P64 = _saxE::P64;
      I64[(young<caR7> + 8)] = caR7;
      R1 = _saxE::P64;
      if (R1 & 7 != 0) goto caR7; else goto caRd;
  caRd:
      call (I64[R1])(R1) returns to caR7, args: 8, res: 8, upd: 8;
  caR7:
      _saxF::P64 = R1;
      _saxG::P64 = P64[_saxF::P64 + 7];
      R1 = _saxG::P64;
      call stg_norec_readTVar#(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:44.851084 UTC

{offset
  caQZ:
      _saxu::P64 = R4;
      _saxt::P64 = R3;
      _saxs::P64 = R2;
      if ((Sp + 8) - 24 < SpLim) goto caR8; else goto caR9;
  caR9:
      if (HpLim == 0) goto caR8; else goto caRa;
  caR8:
      R4 = _saxu::P64;
      R3 = _saxt::P64;
      R2 = _saxs::P64;
      R1 = SkipList.$fMArrayTArrayeSTM2_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  caRa:
      I64[Sp - 16] = caQW;
      R1 = _saxt::P64;
      P64[Sp - 8] = _saxu::P64;
      Sp = Sp - 16;
      if (R1 & 7 != 0) goto caQW; else goto caQX;
  caQX:
      call (I64[R1])(R1) returns to caQW, args: 8, res: 8, upd: 8;
  caQW:
      _saxu::P64 = P64[Sp + 8];
      _saxw::P64 = R1;
      _saxx::P64 = P64[_saxw::P64 + 7];
      _saxy::P64 = P64[_saxw::P64 + 15];
      _saxA::P64 = P64[_saxw::P64 + 23];
      _saxz::I64 = I64[_saxw::P64 + 31];
      I64[Sp] = caR2;
      R1 = _saxu::P64;
      P64[Sp + 8] = _saxA::P64;
      if (R1 & 7 != 0) goto caR2; else goto caR3;
  caR3:
      call (I64[R1])(R1) returns to caR2, args: 8, res: 8, upd: 8;
  caR2:
      _saxA::P64 = P64[Sp + 8];
      _saxB::P64 = R1;
      _saxC::I64 = I64[_saxB::P64 + 7];
      _saxE::P64 = P64[(_saxA::P64 + 24) + (_saxC::I64 << 3)];
      _saxE::P64 = _saxE::P64;
      I64[Sp + 8] = caR7;
      R1 = _saxE::P64;
      Sp = Sp + 8;
      if (R1 & 7 != 0) goto caR7; else goto caRd;
  caRd:
      call (I64[R1])(R1) returns to caR7, args: 8, res: 8, upd: 8;
  caR7:
      _saxF::P64 = R1;
      _saxG::P64 = P64[_saxF::P64 + 7];
      R1 = _saxG::P64;
      Sp = Sp + 8;
      call stg_norec_readTVar#(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:44.853778 UTC

{offset
  caQZ:
      _saxu::P64 = R4;
      _saxt::P64 = R3;
      _saxs::P64 = R2;
      if ((Sp + -16) < SpLim) goto caR8; else goto caR9;
  caR9:
      if (HpLim == 0) goto caR8; else goto caRa;
  caR8:
      R4 = _saxu::P64;
      R3 = _saxt::P64;
      R2 = _saxs::P64;
      R1 = SkipList.$fMArrayTArrayeSTM2_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  caRa:
      I64[Sp - 16] = caQW;
      R1 = _saxt::P64;
      P64[Sp - 8] = _saxu::P64;
      Sp = Sp - 16;
      if (R1 & 7 != 0) goto caQW; else goto caQX;
  caQX:
      call (I64[R1])(R1) returns to caQW, args: 8, res: 8, upd: 8;
  caQW:
      I64[Sp] = caR2;
      _saxA::P64 = P64[R1 + 23];
      R1 = P64[Sp + 8];
      P64[Sp + 8] = _saxA::P64;
      if (R1 & 7 != 0) goto caR2; else goto caR3;
  caR3:
      call (I64[R1])(R1) returns to caR2, args: 8, res: 8, upd: 8;
  caR2:
      _saxE::P64 = P64[P64[Sp + 8] + ((I64[R1 + 7] << 3) + 24)];
      I64[Sp + 8] = caR7;
      R1 = _saxE::P64;
      Sp = Sp + 8;
      if (R1 & 7 != 0) goto caR7; else goto caRd;
  caRd:
      call (I64[R1])(R1) returns to caR7, args: 8, res: 8, upd: 8;
  caR7:
      R1 = P64[R1 + 7];
      Sp = Sp + 8;
      call stg_norec_readTVar#(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:44.856185 UTC

[(caQW, {}), (caQX, {}), (caQZ, {}), (caR2, {}), (caR3, {}),
 (caR7, {}), (caR8, {}), (caR9, {}), (caRa, {}), (caRd, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:44.856674 UTC

SkipList.$fMArrayTArrayeSTM2_entry() //  [R4, R3, R2]
        { info_tbl: [(caQW,
                      label: block_caQW_info
                      rep:StackRep [False]),
                     (caQZ,
                      label: SkipList.$fMArrayTArrayeSTM2_info
                      rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} }),
                     (caR2,
                      label: block_caR2_info
                      rep:StackRep [False]),
                     (caR7,
                      label: block_caR7_info
                      rep:StackRep [])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caQZ:
          _saxu::P64 = R4;
          _saxt::P64 = R3;
          _saxs::P64 = R2;
          if ((Sp + -16) < SpLim) goto caR8; else goto caR9;
      caR9:
          if (HpLim == 0) goto caR8; else goto caRa;
      caR8:
          R4 = _saxu::P64;
          R3 = _saxt::P64;
          R2 = _saxs::P64;
          R1 = SkipList.$fMArrayTArrayeSTM2_closure;
          call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
      caRa:
          I64[Sp - 16] = caQW;
          R1 = _saxt::P64;
          P64[Sp - 8] = _saxu::P64;
          Sp = Sp - 16;
          if (R1 & 7 != 0) goto caQW; else goto caQX;
      caQX:
          call (I64[R1])(R1) returns to caQW, args: 8, res: 8, upd: 8;
      caQW:
          I64[Sp] = caR2;
          _saxA::P64 = P64[R1 + 23];
          R1 = P64[Sp + 8];
          P64[Sp + 8] = _saxA::P64;
          if (R1 & 7 != 0) goto caR2; else goto caR3;
      caR3:
          call (I64[R1])(R1) returns to caR2, args: 8, res: 8, upd: 8;
      caR2:
          _saxE::P64 = P64[P64[Sp + 8] + ((I64[R1 + 7] << 3) + 24)];
          I64[Sp + 8] = caR7;
          R1 = _saxE::P64;
          Sp = Sp + 8;
          if (R1 & 7 != 0) goto caR7; else goto caRd;
      caRd:
          call (I64[R1])(R1) returns to caR7, args: 8, res: 8, upd: 8;
      caR7:
          R1 = P64[R1 + 7];
          Sp = Sp + 8;
          call stg_norec_readTVar#(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:44.859444 UTC

SkipList.$fMArrayTArrayeSTM2_entry() //  [R4, R3, R2]
        { info_tbl: [(caQW,
                      label: block_caQW_info
                      rep:StackRep [False]),
                     (caQZ,
                      label: SkipList.$fMArrayTArrayeSTM2_info
                      rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} }),
                     (caR2,
                      label: block_caR2_info
                      rep:StackRep [False]),
                     (caR7,
                      label: block_caR7_info
                      rep:StackRep [])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caQZ:
          _saxu::P64 = R4;
          _saxt::P64 = R3;
          _saxs::P64 = R2;
          if ((Sp + -16) < SpLim) goto caR8; else goto caR9;
      caR9:
          if (HpLim == 0) goto caR8; else goto caRa;
      caR8:
          R4 = _saxu::P64;
          R3 = _saxt::P64;
          R2 = _saxs::P64;
          R1 = SkipList.$fMArrayTArrayeSTM2_closure;
          call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
      caRa:
          I64[Sp - 16] = caQW;
          R1 = _saxt::P64;
          P64[Sp - 8] = _saxu::P64;
          Sp = Sp - 16;
          if (R1 & 7 != 0) goto caQW; else goto caQX;
      caQX:
          call (I64[R1])(R1) returns to caQW, args: 8, res: 8, upd: 8;
      caQW:
          I64[Sp] = caR2;
          _saxA::P64 = P64[R1 + 23];
          R1 = P64[Sp + 8];
          P64[Sp + 8] = _saxA::P64;
          if (R1 & 7 != 0) goto caR2; else goto caR3;
      caR3:
          call (I64[R1])(R1) returns to caR2, args: 8, res: 8, upd: 8;
      caR2:
          _saxE::P64 = P64[P64[Sp + 8] + ((I64[R1 + 7] << 3) + 24)];
          I64[Sp + 8] = caR7;
          R1 = _saxE::P64;
          Sp = Sp + 8;
          if (R1 & 7 != 0) goto caR7; else goto caRd;
      caRd:
          call (I64[R1])(R1) returns to caR7, args: 8, res: 8, upd: 8;
      caR7:
          R1 = P64[R1 + 7];
          Sp = Sp + 8;
          call stg_norec_readTVar#(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:44.862146 UTC

[section "data" {
     SkipList.$fMArrayTArrayeSTM2_closure:
         const SkipList.$fMArrayTArrayeSTM2_info;
 },
 SkipList.$fMArrayTArrayeSTM2_entry() //  [R4, R3, R2]
         { info_tbl: [(caQW,
                       label: block_caQW_info
                       rep:StackRep [False]),
                      (caQZ,
                       label: SkipList.$fMArrayTArrayeSTM2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} }),
                      (caR2,
                       label: block_caR2_info
                       rep:StackRep [False]),
                      (caR7,
                       label: block_caR7_info
                       rep:StackRep [])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caQZ:
           _saxu::P64 = R4;
           _saxt::P64 = R3;
           _saxs::P64 = R2;
           if ((Sp + -16) < SpLim) goto caR8; else goto caR9;
       caR9:
           if (HpLim == 0) goto caR8; else goto caRa;
       caR8:
           R4 = _saxu::P64;
           R3 = _saxt::P64;
           R2 = _saxs::P64;
           R1 = SkipList.$fMArrayTArrayeSTM2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caRa:
           I64[Sp - 16] = caQW;
           R1 = _saxt::P64;
           P64[Sp - 8] = _saxu::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto caQW; else goto caQX;
       caQX:
           call (I64[R1])(R1) returns to caQW, args: 8, res: 8, upd: 8;
       caQW:
           I64[Sp] = caR2;
           _saxA::P64 = P64[R1 + 23];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _saxA::P64;
           if (R1 & 7 != 0) goto caR2; else goto caR3;
       caR3:
           call (I64[R1])(R1) returns to caR2, args: 8, res: 8, upd: 8;
       caR2:
           _saxE::P64 = P64[P64[Sp + 8] + ((I64[R1 + 7] << 3) + 24)];
           I64[Sp + 8] = caR7;
           R1 = _saxE::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto caR7; else goto caRd;
       caRd:
           call (I64[R1])(R1) returns to caR7, args: 8, res: 8, upd: 8;
       caR7:
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_norec_readTVar#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:44.865098 UTC

[section "data" {
     SkipList.$fMArrayTArrayeSTM2_closure:
         const SkipList.$fMArrayTArrayeSTM2_info;
 },
 SkipList.$fMArrayTArrayeSTM2_entry() //  [R4, R3, R2]
         { info_tbl: [(caQW,
                       label: block_caQW_info
                       rep:StackRep [False]),
                      (caQZ,
                       label: SkipList.$fMArrayTArrayeSTM2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} }),
                      (caR2,
                       label: block_caR2_info
                       rep:StackRep [False]),
                      (caR7,
                       label: block_caR7_info
                       rep:StackRep [])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caQZ:
           _saxu::P64 = R4;
           _saxt::P64 = R3;
           _saxs::P64 = R2;
           if ((Sp + -16) < SpLim) goto caR8; else goto caR9;
       caR9:
           if (HpLim == 0) goto caR8; else goto caRa;
       caR8:
           R4 = _saxu::P64;
           R3 = _saxt::P64;
           R2 = _saxs::P64;
           R1 = SkipList.$fMArrayTArrayeSTM2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caRa:
           I64[Sp - 16] = caQW;
           R1 = _saxt::P64;
           P64[Sp - 8] = _saxu::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto caQW; else goto caQX;
       caQX:
           call (I64[R1])(R1) returns to caQW, args: 8, res: 8, upd: 8;
       caQW:
           I64[Sp] = caR2;
           _saxA::P64 = P64[R1 + 23];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _saxA::P64;
           if (R1 & 7 != 0) goto caR2; else goto caR3;
       caR3:
           call (I64[R1])(R1) returns to caR2, args: 8, res: 8, upd: 8;
       caR2:
           _saxE::P64 = P64[P64[Sp + 8] + ((I64[R1 + 7] << 3) + 24)];
           I64[Sp + 8] = caR7;
           R1 = _saxE::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto caR7; else goto caRd;
       caRd:
           call (I64[R1])(R1) returns to caR7, args: 8, res: 8, upd: 8;
       caR7:
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_norec_readTVar#(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:44.872417 UTC

[section "data" {
     SkipList.$fMArrayTArrayeSTM_$cunsafeRead_closure:
         const SkipList.$fMArrayTArrayeSTM_$cunsafeRead_info;
 },
 SkipList.$fMArrayTArrayeSTM_$cunsafeRead_entry() //  [R4, R3, R2]
         { info_tbl: [(caRt,
                       label: SkipList.$fMArrayTArrayeSTM_$cunsafeRead_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caRt:
           _B2::P64 = R4;
           _B3::P64 = R3;
           _B4::P64 = R2;
           goto caRr;
       caRr:
           if ((old + 0) - <highSp> < SpLim) goto caRu; else goto caRv;
       caRv:
           goto caRq;
       caRq:
           if (HpLim == 0) goto caRu; else goto caRw;
       caRu:
           R4 = _B2::P64;
           R3 = _B3::P64;
           R2 = _B4::P64;
           R1 = SkipList.$fMArrayTArrayeSTM_$cunsafeRead_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caRw:
           R4 = _B2::P64;
           R3 = _B3::P64;
           R2 = _B4::P64;
           call SkipList.$fMArrayTArrayeSTM2_info(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:44.874373 UTC

{offset
  caRt:
      _B2::P64 = R4;
      _B3::P64 = R3;
      _B4::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto caRu; else goto caRv;
  caRv:
      if (HpLim == 0) goto caRu; else goto caRw;
  caRu:
      R4 = _B2::P64;
      R3 = _B3::P64;
      R2 = _B4::P64;
      R1 = SkipList.$fMArrayTArrayeSTM_$cunsafeRead_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  caRw:
      R4 = _B2::P64;
      R3 = _B3::P64;
      R2 = _B4::P64;
      call SkipList.$fMArrayTArrayeSTM2_info(R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:44.875358 UTC

{offset
  caRt:
      _B2::P64 = R4;
      _B3::P64 = R3;
      _B4::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto caRu; else goto caRv;
  caRv:
      if (HpLim == 0) goto caRu; else goto caRw;
  caRu:
      R4 = _B2::P64;
      R3 = _B3::P64;
      R2 = _B4::P64;
      R1 = SkipList.$fMArrayTArrayeSTM_$cunsafeRead_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  caRw:
      R4 = _B2::P64;
      R3 = _B3::P64;
      R2 = _B4::P64;
      call SkipList.$fMArrayTArrayeSTM2_info(R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:44.876356 UTC

{offset
  caRt:
      _B2::P64 = R4;
      _B3::P64 = R3;
      _B4::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto caRu; else goto caRv;
  caRv:
      if (HpLim == 0) goto caRu; else goto caRw;
  caRu:
      R4 = _B2::P64;
      R3 = _B3::P64;
      R2 = _B4::P64;
      R1 = SkipList.$fMArrayTArrayeSTM_$cunsafeRead_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  caRw:
      R4 = _B2::P64;
      R3 = _B3::P64;
      R2 = _B4::P64;
      call SkipList.$fMArrayTArrayeSTM2_info(R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:44.877425 UTC

{offset
  caRt:
      _B2::P64 = R4;
      _B3::P64 = R3;
      _B4::P64 = R2;
      goto caRv;
  caRv:
      if (HpLim == 0) goto caRu; else goto caRw;
  caRu:
      R4 = _B2::P64;
      R3 = _B3::P64;
      R2 = _B4::P64;
      R1 = SkipList.$fMArrayTArrayeSTM_$cunsafeRead_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  caRw:
      R4 = _B2::P64;
      R3 = _B3::P64;
      R2 = _B4::P64;
      call SkipList.$fMArrayTArrayeSTM2_info(R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:44.878346 UTC

{offset
  caRt:
      goto caRv;
  caRv:
      if (HpLim == 0) goto caRu; else goto caRw;
  caRu:
      R4 = R4;
      R3 = R3;
      R2 = R2;
      R1 = SkipList.$fMArrayTArrayeSTM_$cunsafeRead_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  caRw:
      R4 = R4;
      R3 = R3;
      R2 = R2;
      call SkipList.$fMArrayTArrayeSTM2_info(R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:44.879328 UTC

[(caRt, {}), (caRu, {}), (caRv, {}), (caRw, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:44.879643 UTC

SkipList.$fMArrayTArrayeSTM_$cunsafeRead_entry() //  [R4, R3, R2]
        { info_tbl: [(caRt,
                      label: SkipList.$fMArrayTArrayeSTM_$cunsafeRead_info
                      rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caRt:
          goto caRv;
      caRv:
          if (HpLim == 0) goto caRu; else goto caRw;
      caRu:
          R4 = R4;
          R3 = R3;
          R2 = R2;
          R1 = SkipList.$fMArrayTArrayeSTM_$cunsafeRead_closure;
          call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
      caRw:
          R4 = R4;
          R3 = R3;
          R2 = R2;
          call SkipList.$fMArrayTArrayeSTM2_info(R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:44.880676 UTC

SkipList.$fMArrayTArrayeSTM_$cunsafeRead_entry() //  [R4, R3, R2]
        { info_tbl: [(caRt,
                      label: SkipList.$fMArrayTArrayeSTM_$cunsafeRead_info
                      rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caRt:
          if (HpLim == 0) goto caRu; else goto caRw;
      caRu:
          R4 = R4;
          R3 = R3;
          R2 = R2;
          R1 = SkipList.$fMArrayTArrayeSTM_$cunsafeRead_closure;
          call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
      caRw:
          R4 = R4;
          R3 = R3;
          R2 = R2;
          call SkipList.$fMArrayTArrayeSTM2_info(R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:44.881682 UTC

[section "data" {
     SkipList.$fMArrayTArrayeSTM_$cunsafeRead_closure:
         const SkipList.$fMArrayTArrayeSTM_$cunsafeRead_info;
 },
 SkipList.$fMArrayTArrayeSTM_$cunsafeRead_entry() //  [R4, R3, R2]
         { info_tbl: [(caRt,
                       label: SkipList.$fMArrayTArrayeSTM_$cunsafeRead_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caRt:
           if (HpLim == 0) goto caRu; else goto caRw;
       caRu:
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = SkipList.$fMArrayTArrayeSTM_$cunsafeRead_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caRw:
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call SkipList.$fMArrayTArrayeSTM2_info(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:44.882871 UTC

[section "data" {
     SkipList.$fMArrayTArrayeSTM_$cunsafeRead_closure:
         const SkipList.$fMArrayTArrayeSTM_$cunsafeRead_info;
 },
 SkipList.$fMArrayTArrayeSTM_$cunsafeRead_entry() //  [R4, R3, R2]
         { info_tbl: [(caRt,
                       label: SkipList.$fMArrayTArrayeSTM_$cunsafeRead_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caRt:
           if (HpLim == 0) goto caRu; else goto caRw;
       caRu:
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = SkipList.$fMArrayTArrayeSTM_$cunsafeRead_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caRw:
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call SkipList.$fMArrayTArrayeSTM2_info(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:44.885675 UTC

[section "data" {
     SkipList.$fMArrayTArrayeSTM10_closure:
         const SkipList.$fMArrayTArrayeSTM10_info;
 },
 sat_saxK_entry() //  [R1]
         { info_tbl: [(caRJ,
                       label: sat_saxK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caRJ:
           _saxK::P64 = R1;
           goto caRH;
       caRH:
           if ((old + 0) - <highSp> < SpLim) goto caRK; else goto caRL;
       caRL:
           if (HpLim == 0) goto caRK; else goto caRM;
       caRK:
           R1 = _saxK::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caRM:
           I64[(old + 24)] = stg_upd_frame_info;
           P64[(old + 16)] = _saxK::P64;
           _saxI::P64 = P64[_saxK::P64 + 16];
           R2 = _saxI::P64;
           call GHC.Arr.numElements_info(R2) args: 24, res: 0, upd: 24;
     }
 },
 SkipList.$fMArrayTArrayeSTM10_entry() //  [R3, R2]
         { info_tbl: [(caRN,
                       label: SkipList.$fMArrayTArrayeSTM10_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caRN:
           _saxI::P64 = R3;
           _saxH::P64 = R2;
           goto caRD;
       caRD:
           if ((old + 0) - <highSp> < SpLim) goto caRO; else goto caRP;
       caRP:
           goto caRC;
       caRC:
           Hp = Hp + 24;
           if (Hp > HpLim) goto caRR; else goto caRQ;
       caRR:
           HpAlloc = 24;
           goto caRO;
       caRO:
           R3 = _saxI::P64;
           R2 = _saxH::P64;
           R1 = SkipList.$fMArrayTArrayeSTM10_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caRQ:
           I64[Hp - 16] = sat_saxK_info;
           P64[Hp] = _saxI::P64;
           _caRF::P64 = Hp - 16;
           R1 = _caRF::P64;
           call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:44.888989 UTC

{offset
  caRJ:
      _saxK::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto caRK; else goto caRL;
  caRL:
      if (HpLim == 0) goto caRK; else goto caRM;
  caRK:
      R1 = _saxK::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caRM:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _saxK::P64;
      _saxI::P64 = P64[_saxK::P64 + 16];
      R2 = _saxI::P64;
      call GHC.Arr.numElements_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:44.889837 UTC

{offset
  caRJ:
      _saxK::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto caRK; else goto caRL;
  caRL:
      if (HpLim == 0) goto caRK; else goto caRM;
  caRK:
      R1 = _saxK::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caRM:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _saxK::P64;
      _saxI::P64 = P64[_saxK::P64 + 16];
      R2 = _saxI::P64;
      call GHC.Arr.numElements_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:44.891227 UTC

{offset
  caRJ:
      _saxK::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto caRK; else goto caRL;
  caRL:
      if (HpLim == 0) goto caRK; else goto caRM;
  caRK:
      R1 = _saxK::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caRM:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _saxK::P64;
      _saxI::P64 = P64[_saxK::P64 + 16];
      R2 = _saxI::P64;
      call GHC.Arr.numElements_info(R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:44.89215 UTC

{offset
  caRJ:
      _saxK::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto caRK; else goto caRL;
  caRL:
      if (HpLim == 0) goto caRK; else goto caRM;
  caRK:
      R1 = _saxK::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caRM:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _saxK::P64;
      _saxI::P64 = P64[_saxK::P64 + 16];
      R2 = _saxI::P64;
      Sp = Sp - 16;
      call GHC.Arr.numElements_info(R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:44.893126 UTC

{offset
  caRJ:
      _saxK::P64 = R1;
      if ((Sp + -16) < SpLim) goto caRK; else goto caRL;
  caRL:
      if (HpLim == 0) goto caRK; else goto caRM;
  caRK:
      R1 = _saxK::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caRM:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _saxK::P64;
      R2 = P64[_saxK::P64 + 16];
      Sp = Sp - 16;
      call GHC.Arr.numElements_info(R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:44.894079 UTC

[(caRJ, {}), (caRK, {}), (caRL, {}), (caRM, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:44.894392 UTC

sat_saxK_entry() //  [R1]
        { info_tbl: [(caRJ,
                      label: sat_saxK_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caRJ:
          _saxK::P64 = R1;
          if ((Sp + -16) < SpLim) goto caRK; else goto caRL;
      caRL:
          if (HpLim == 0) goto caRK; else goto caRM;
      caRK:
          R1 = _saxK::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      caRM:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _saxK::P64;
          R2 = P64[_saxK::P64 + 16];
          Sp = Sp - 16;
          call GHC.Arr.numElements_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:44.895427 UTC

sat_saxK_entry() //  [R1]
        { info_tbl: [(caRJ,
                      label: sat_saxK_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caRJ:
          _saxK::P64 = R1;
          if ((Sp + -16) < SpLim) goto caRK; else goto caRL;
      caRL:
          if (HpLim == 0) goto caRK; else goto caRM;
      caRK:
          R1 = _saxK::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      caRM:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _saxK::P64;
          R2 = P64[_saxK::P64 + 16];
          Sp = Sp - 16;
          call GHC.Arr.numElements_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:44.896474 UTC

{offset
  caRN:
      _saxI::P64 = R3;
      _saxH::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto caRO; else goto caRP;
  caRP:
      Hp = Hp + 24;
      if (Hp > HpLim) goto caRR; else goto caRQ;
  caRR:
      HpAlloc = 24;
      goto caRO;
  caRO:
      R3 = _saxI::P64;
      R2 = _saxH::P64;
      R1 = SkipList.$fMArrayTArrayeSTM10_closure;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  caRQ:
      I64[Hp - 16] = sat_saxK_info;
      P64[Hp] = _saxI::P64;
      _caRF::P64 = Hp - 16;
      R1 = _caRF::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:44.897536 UTC

{offset
  caRN:
      _saxI::P64 = R3;
      _saxH::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto caRO; else goto caRP;
  caRP:
      Hp = Hp + 24;
      if (Hp > HpLim) goto caRR; else goto caRQ;
  caRR:
      HpAlloc = 24;
      goto caRO;
  caRO:
      R3 = _saxI::P64;
      R2 = _saxH::P64;
      R1 = SkipList.$fMArrayTArrayeSTM10_closure;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  caRQ:
      I64[Hp - 16] = sat_saxK_info;
      P64[Hp] = _saxI::P64;
      _caRF::P64 = Hp - 16;
      R1 = _caRF::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:44.898592 UTC

{offset
  caRN:
      _saxI::P64 = R3;
      _saxH::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto caRO; else goto caRP;
  caRP:
      Hp = Hp + 24;
      if (Hp > HpLim) goto caRR; else goto caRQ;
  caRR:
      HpAlloc = 24;
      goto caRO;
  caRO:
      R3 = _saxI::P64;
      R2 = _saxH::P64;
      R1 = SkipList.$fMArrayTArrayeSTM10_closure;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  caRQ:
      I64[Hp - 16] = sat_saxK_info;
      P64[Hp] = _saxI::P64;
      _caRF::P64 = Hp - 16;
      R1 = _caRF::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:44.899674 UTC

{offset
  caRN:
      _saxI::P64 = R3;
      _saxH::P64 = R2;
      goto caRP;
  caRP:
      Hp = Hp + 24;
      if (Hp > HpLim) goto caRR; else goto caRQ;
  caRR:
      HpAlloc = 24;
      goto caRO;
  caRO:
      R3 = _saxI::P64;
      R2 = _saxH::P64;
      R1 = SkipList.$fMArrayTArrayeSTM10_closure;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  caRQ:
      I64[Hp - 16] = sat_saxK_info;
      P64[Hp] = _saxI::P64;
      _caRF::P64 = Hp - 16;
      R1 = _caRF::P64;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:44.900643 UTC

{offset
  caRN:
      goto caRP;
  caRP:
      Hp = Hp + 24;
      if (Hp > HpLim) goto caRR; else goto caRQ;
  caRR:
      HpAlloc = 24;
      goto caRO;
  caRO:
      R3 = R3;
      R2 = R2;
      R1 = SkipList.$fMArrayTArrayeSTM10_closure;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  caRQ:
      I64[Hp - 16] = sat_saxK_info;
      P64[Hp] = R3;
      R1 = Hp - 16;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:44.901693 UTC

[(caRN, {sat_saxK_closure}), (caRO, {}),
 (caRP, {sat_saxK_closure}), (caRQ, {sat_saxK_closure}), (caRR, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:44.902126 UTC

SkipList.$fMArrayTArrayeSTM10_entry() //  [R3, R2]
        { info_tbl: [(caRN,
                      label: SkipList.$fMArrayTArrayeSTM10_info
                      rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caRN:
          goto caRP;
      caRP:
          Hp = Hp + 24;
          if (Hp > HpLim) goto caRR; else goto caRQ;
      caRR:
          HpAlloc = 24;
          goto caRO;
      caRO:
          R3 = R3;
          R2 = R2;
          R1 = SkipList.$fMArrayTArrayeSTM10_closure;
          call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
      caRQ:
          I64[Hp - 16] = sat_saxK_info;
          P64[Hp] = R3;
          R1 = Hp - 16;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:44.903273 UTC

SkipList.$fMArrayTArrayeSTM10_entry() //  [R3, R2]
        { info_tbl: [(caRN,
                      label: SkipList.$fMArrayTArrayeSTM10_info
                      rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caRN:
          Hp = Hp + 24;
          if (Hp > HpLim) goto caRR; else goto caRQ;
      caRR:
          HpAlloc = 24;
          R3 = R3;
          R2 = R2;
          R1 = SkipList.$fMArrayTArrayeSTM10_closure;
          call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
      caRQ:
          I64[Hp - 16] = sat_saxK_info;
          P64[Hp] = R3;
          R1 = Hp - 16;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:44.904314 UTC

[section "data" {
     SkipList.$fMArrayTArrayeSTM10_closure:
         const SkipList.$fMArrayTArrayeSTM10_info;
 },
 sat_saxK_entry() //  [R1]
         { info_tbl: [(caRJ,
                       label: sat_saxK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caRJ:
           _saxK::P64 = R1;
           if ((Sp + -16) < SpLim) goto caRK; else goto caRL;
       caRL:
           if (HpLim == 0) goto caRK; else goto caRM;
       caRK:
           R1 = _saxK::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caRM:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _saxK::P64;
           R2 = P64[_saxK::P64 + 16];
           Sp = Sp - 16;
           call GHC.Arr.numElements_info(R2) args: 24, res: 0, upd: 24;
     }
 },
 SkipList.$fMArrayTArrayeSTM10_entry() //  [R3, R2]
         { info_tbl: [(caRN,
                       label: SkipList.$fMArrayTArrayeSTM10_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caRN:
           Hp = Hp + 24;
           if (Hp > HpLim) goto caRR; else goto caRQ;
       caRR:
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = SkipList.$fMArrayTArrayeSTM10_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caRQ:
           I64[Hp - 16] = sat_saxK_info;
           P64[Hp] = R3;
           R1 = Hp - 16;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:44.906449 UTC

[section "data" {
     SkipList.$fMArrayTArrayeSTM10_closure:
         const SkipList.$fMArrayTArrayeSTM10_info;
 },
 sat_saxK_entry() //  [R1]
         { info_tbl: [(caRJ,
                       label: sat_saxK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caRJ:
           _saxK::P64 = R1;
           if ((Sp + -16) < SpLim) goto caRK; else goto caRL;
       caRL:
           if (HpLim == 0) goto caRK; else goto caRM;
       caRK:
           R1 = _saxK::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caRM:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _saxK::P64;
           R2 = P64[_saxK::P64 + 16];
           Sp = Sp - 16;
           call GHC.Arr.numElements_info(R2) args: 24, res: 0, upd: 24;
     }
 },
 SkipList.$fMArrayTArrayeSTM10_entry() //  [R3, R2]
         { info_tbl: [(caRN,
                       label: SkipList.$fMArrayTArrayeSTM10_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caRN:
           Hp = Hp + 24;
           if (Hp > HpLim) goto caRR; else goto caRQ;
       caRR:
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = SkipList.$fMArrayTArrayeSTM10_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caRQ:
           I64[Hp - 16] = sat_saxK_info;
           P64[Hp] = R3;
           R1 = Hp - 16;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:44.911899 UTC

[section "data" {
     SkipList.$fMArrayTArrayeSTM_$cgetNumElements_closure:
         const SkipList.$fMArrayTArrayeSTM_$cgetNumElements_info;
 },
 SkipList.$fMArrayTArrayeSTM_$cgetNumElements_entry() //  [R3, R2]
         { info_tbl: [(caS3,
                       label: SkipList.$fMArrayTArrayeSTM_$cgetNumElements_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caS3:
           _B2::P64 = R3;
           _B3::P64 = R2;
           goto caS1;
       caS1:
           if ((old + 0) - <highSp> < SpLim) goto caS4; else goto caS5;
       caS5:
           goto caS0;
       caS0:
           if (HpLim == 0) goto caS4; else goto caS6;
       caS4:
           R3 = _B2::P64;
           R2 = _B3::P64;
           R1 = SkipList.$fMArrayTArrayeSTM_$cgetNumElements_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caS6:
           R3 = _B2::P64;
           R2 = _B3::P64;
           call SkipList.$fMArrayTArrayeSTM10_info(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:44.913678 UTC

{offset
  caS3:
      _B2::P64 = R3;
      _B3::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto caS4; else goto caS5;
  caS5:
      if (HpLim == 0) goto caS4; else goto caS6;
  caS4:
      R3 = _B2::P64;
      R2 = _B3::P64;
      R1 = SkipList.$fMArrayTArrayeSTM_$cgetNumElements_closure;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  caS6:
      R3 = _B2::P64;
      R2 = _B3::P64;
      call SkipList.$fMArrayTArrayeSTM10_info(R3,
                                              R2) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:44.91454 UTC

{offset
  caS3:
      _B2::P64 = R3;
      _B3::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto caS4; else goto caS5;
  caS5:
      if (HpLim == 0) goto caS4; else goto caS6;
  caS4:
      R3 = _B2::P64;
      R2 = _B3::P64;
      R1 = SkipList.$fMArrayTArrayeSTM_$cgetNumElements_closure;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  caS6:
      R3 = _B2::P64;
      R2 = _B3::P64;
      call SkipList.$fMArrayTArrayeSTM10_info(R3,
                                              R2) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:44.915404 UTC

{offset
  caS3:
      _B2::P64 = R3;
      _B3::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto caS4; else goto caS5;
  caS5:
      if (HpLim == 0) goto caS4; else goto caS6;
  caS4:
      R3 = _B2::P64;
      R2 = _B3::P64;
      R1 = SkipList.$fMArrayTArrayeSTM_$cgetNumElements_closure;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  caS6:
      R3 = _B2::P64;
      R2 = _B3::P64;
      call SkipList.$fMArrayTArrayeSTM10_info(R3,
                                              R2) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:44.916316 UTC

{offset
  caS3:
      _B2::P64 = R3;
      _B3::P64 = R2;
      goto caS5;
  caS5:
      if (HpLim == 0) goto caS4; else goto caS6;
  caS4:
      R3 = _B2::P64;
      R2 = _B3::P64;
      R1 = SkipList.$fMArrayTArrayeSTM_$cgetNumElements_closure;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  caS6:
      R3 = _B2::P64;
      R2 = _B3::P64;
      call SkipList.$fMArrayTArrayeSTM10_info(R3,
                                              R2) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:44.917147 UTC

{offset
  caS3:
      goto caS5;
  caS5:
      if (HpLim == 0) goto caS4; else goto caS6;
  caS4:
      R3 = R3;
      R2 = R2;
      R1 = SkipList.$fMArrayTArrayeSTM_$cgetNumElements_closure;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  caS6:
      R3 = R3;
      R2 = R2;
      call SkipList.$fMArrayTArrayeSTM10_info(R3,
                                              R2) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:44.918557 UTC

[(caS3, {}), (caS4, {}), (caS5, {}), (caS6, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:44.918872 UTC

SkipList.$fMArrayTArrayeSTM_$cgetNumElements_entry() //  [R3, R2]
        { info_tbl: [(caS3,
                      label: SkipList.$fMArrayTArrayeSTM_$cgetNumElements_info
                      rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caS3:
          goto caS5;
      caS5:
          if (HpLim == 0) goto caS4; else goto caS6;
      caS4:
          R3 = R3;
          R2 = R2;
          R1 = SkipList.$fMArrayTArrayeSTM_$cgetNumElements_closure;
          call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
      caS6:
          R3 = R3;
          R2 = R2;
          call SkipList.$fMArrayTArrayeSTM10_info(R3,
                                                  R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:44.919801 UTC

SkipList.$fMArrayTArrayeSTM_$cgetNumElements_entry() //  [R3, R2]
        { info_tbl: [(caS3,
                      label: SkipList.$fMArrayTArrayeSTM_$cgetNumElements_info
                      rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caS3:
          if (HpLim == 0) goto caS4; else goto caS6;
      caS4:
          R3 = R3;
          R2 = R2;
          R1 = SkipList.$fMArrayTArrayeSTM_$cgetNumElements_closure;
          call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
      caS6:
          R3 = R3;
          R2 = R2;
          call SkipList.$fMArrayTArrayeSTM10_info(R3,
                                                  R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:44.920729 UTC

[section "data" {
     SkipList.$fMArrayTArrayeSTM_$cgetNumElements_closure:
         const SkipList.$fMArrayTArrayeSTM_$cgetNumElements_info;
 },
 SkipList.$fMArrayTArrayeSTM_$cgetNumElements_entry() //  [R3, R2]
         { info_tbl: [(caS3,
                       label: SkipList.$fMArrayTArrayeSTM_$cgetNumElements_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caS3:
           if (HpLim == 0) goto caS4; else goto caS6;
       caS4:
           R3 = R3;
           R2 = R2;
           R1 = SkipList.$fMArrayTArrayeSTM_$cgetNumElements_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caS6:
           R3 = R3;
           R2 = R2;
           call SkipList.$fMArrayTArrayeSTM10_info(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:44.921783 UTC

[section "data" {
     SkipList.$fMArrayTArrayeSTM_$cgetNumElements_closure:
         const SkipList.$fMArrayTArrayeSTM_$cgetNumElements_info;
 },
 SkipList.$fMArrayTArrayeSTM_$cgetNumElements_entry() //  [R3, R2]
         { info_tbl: [(caS3,
                       label: SkipList.$fMArrayTArrayeSTM_$cgetNumElements_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caS3:
           if (HpLim == 0) goto caS4; else goto caS6;
       caS4:
           R3 = R3;
           R2 = R2;
           R1 = SkipList.$fMArrayTArrayeSTM_$cgetNumElements_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caS6:
           R3 = R3;
           R2 = R2;
           call SkipList.$fMArrayTArrayeSTM10_info(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:44.924455 UTC

[section "data" {
     SkipList.$fMArrayTArrayeSTM11_closure:
         const SkipList.$fMArrayTArrayeSTM11_info;
 },
 sat_saxO_entry() //  [R1]
         { info_tbl: [(caSj,
                       label: sat_saxO_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caSj:
           _saxO::P64 = R1;
           goto caSh;
       caSh:
           if ((old + 0) - <highSp> < SpLim) goto caSk; else goto caSl;
       caSl:
           if (HpLim == 0) goto caSk; else goto caSm;
       caSk:
           R1 = _saxO::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caSm:
           I64[(old + 24)] = stg_upd_frame_info;
           P64[(old + 16)] = _saxO::P64;
           _saxM::P64 = P64[_saxO::P64 + 16];
           R2 = _saxM::P64;
           call GHC.Arr.bounds_info(R2) args: 24, res: 0, upd: 24;
     }
 },
 SkipList.$fMArrayTArrayeSTM11_entry() //  [R3, R2]
         { info_tbl: [(caSn,
                       label: SkipList.$fMArrayTArrayeSTM11_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caSn:
           _saxM::P64 = R3;
           _saxL::P64 = R2;
           goto caSd;
       caSd:
           if ((old + 0) - <highSp> < SpLim) goto caSo; else goto caSp;
       caSp:
           goto caSc;
       caSc:
           Hp = Hp + 24;
           if (Hp > HpLim) goto caSr; else goto caSq;
       caSr:
           HpAlloc = 24;
           goto caSo;
       caSo:
           R3 = _saxM::P64;
           R2 = _saxL::P64;
           R1 = SkipList.$fMArrayTArrayeSTM11_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caSq:
           I64[Hp - 16] = sat_saxO_info;
           P64[Hp] = _saxM::P64;
           _caSf::P64 = Hp - 16;
           R1 = _caSf::P64;
           call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:44.927747 UTC

{offset
  caSj:
      _saxO::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto caSk; else goto caSl;
  caSl:
      if (HpLim == 0) goto caSk; else goto caSm;
  caSk:
      R1 = _saxO::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caSm:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _saxO::P64;
      _saxM::P64 = P64[_saxO::P64 + 16];
      R2 = _saxM::P64;
      call GHC.Arr.bounds_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:44.928595 UTC

{offset
  caSj:
      _saxO::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto caSk; else goto caSl;
  caSl:
      if (HpLim == 0) goto caSk; else goto caSm;
  caSk:
      R1 = _saxO::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caSm:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _saxO::P64;
      _saxM::P64 = P64[_saxO::P64 + 16];
      R2 = _saxM::P64;
      call GHC.Arr.bounds_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:44.929471 UTC

{offset
  caSj:
      _saxO::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto caSk; else goto caSl;
  caSl:
      if (HpLim == 0) goto caSk; else goto caSm;
  caSk:
      R1 = _saxO::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caSm:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _saxO::P64;
      _saxM::P64 = P64[_saxO::P64 + 16];
      R2 = _saxM::P64;
      call GHC.Arr.bounds_info(R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:44.930377 UTC

{offset
  caSj:
      _saxO::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto caSk; else goto caSl;
  caSl:
      if (HpLim == 0) goto caSk; else goto caSm;
  caSk:
      R1 = _saxO::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caSm:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _saxO::P64;
      _saxM::P64 = P64[_saxO::P64 + 16];
      R2 = _saxM::P64;
      Sp = Sp - 16;
      call GHC.Arr.bounds_info(R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:44.931256 UTC

{offset
  caSj:
      _saxO::P64 = R1;
      if ((Sp + -16) < SpLim) goto caSk; else goto caSl;
  caSl:
      if (HpLim == 0) goto caSk; else goto caSm;
  caSk:
      R1 = _saxO::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caSm:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _saxO::P64;
      R2 = P64[_saxO::P64 + 16];
      Sp = Sp - 16;
      call GHC.Arr.bounds_info(R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:44.932227 UTC

[(caSj, {}), (caSk, {}), (caSl, {}), (caSm, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:44.93266 UTC

sat_saxO_entry() //  [R1]
        { info_tbl: [(caSj,
                      label: sat_saxO_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caSj:
          _saxO::P64 = R1;
          if ((Sp + -16) < SpLim) goto caSk; else goto caSl;
      caSl:
          if (HpLim == 0) goto caSk; else goto caSm;
      caSk:
          R1 = _saxO::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      caSm:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _saxO::P64;
          R2 = P64[_saxO::P64 + 16];
          Sp = Sp - 16;
          call GHC.Arr.bounds_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:44.933713 UTC

sat_saxO_entry() //  [R1]
        { info_tbl: [(caSj,
                      label: sat_saxO_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caSj:
          _saxO::P64 = R1;
          if ((Sp + -16) < SpLim) goto caSk; else goto caSl;
      caSl:
          if (HpLim == 0) goto caSk; else goto caSm;
      caSk:
          R1 = _saxO::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      caSm:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _saxO::P64;
          R2 = P64[_saxO::P64 + 16];
          Sp = Sp - 16;
          call GHC.Arr.bounds_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:44.934761 UTC

{offset
  caSn:
      _saxM::P64 = R3;
      _saxL::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto caSo; else goto caSp;
  caSp:
      Hp = Hp + 24;
      if (Hp > HpLim) goto caSr; else goto caSq;
  caSr:
      HpAlloc = 24;
      goto caSo;
  caSo:
      R3 = _saxM::P64;
      R2 = _saxL::P64;
      R1 = SkipList.$fMArrayTArrayeSTM11_closure;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  caSq:
      I64[Hp - 16] = sat_saxO_info;
      P64[Hp] = _saxM::P64;
      _caSf::P64 = Hp - 16;
      R1 = _caSf::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:44.935801 UTC

{offset
  caSn:
      _saxM::P64 = R3;
      _saxL::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto caSo; else goto caSp;
  caSp:
      Hp = Hp + 24;
      if (Hp > HpLim) goto caSr; else goto caSq;
  caSr:
      HpAlloc = 24;
      goto caSo;
  caSo:
      R3 = _saxM::P64;
      R2 = _saxL::P64;
      R1 = SkipList.$fMArrayTArrayeSTM11_closure;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  caSq:
      I64[Hp - 16] = sat_saxO_info;
      P64[Hp] = _saxM::P64;
      _caSf::P64 = Hp - 16;
      R1 = _caSf::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:44.936863 UTC

{offset
  caSn:
      _saxM::P64 = R3;
      _saxL::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto caSo; else goto caSp;
  caSp:
      Hp = Hp + 24;
      if (Hp > HpLim) goto caSr; else goto caSq;
  caSr:
      HpAlloc = 24;
      goto caSo;
  caSo:
      R3 = _saxM::P64;
      R2 = _saxL::P64;
      R1 = SkipList.$fMArrayTArrayeSTM11_closure;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  caSq:
      I64[Hp - 16] = sat_saxO_info;
      P64[Hp] = _saxM::P64;
      _caSf::P64 = Hp - 16;
      R1 = _caSf::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:44.937961 UTC

{offset
  caSn:
      _saxM::P64 = R3;
      _saxL::P64 = R2;
      goto caSp;
  caSp:
      Hp = Hp + 24;
      if (Hp > HpLim) goto caSr; else goto caSq;
  caSr:
      HpAlloc = 24;
      goto caSo;
  caSo:
      R3 = _saxM::P64;
      R2 = _saxL::P64;
      R1 = SkipList.$fMArrayTArrayeSTM11_closure;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  caSq:
      I64[Hp - 16] = sat_saxO_info;
      P64[Hp] = _saxM::P64;
      _caSf::P64 = Hp - 16;
      R1 = _caSf::P64;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:44.938912 UTC

{offset
  caSn:
      goto caSp;
  caSp:
      Hp = Hp + 24;
      if (Hp > HpLim) goto caSr; else goto caSq;
  caSr:
      HpAlloc = 24;
      goto caSo;
  caSo:
      R3 = R3;
      R2 = R2;
      R1 = SkipList.$fMArrayTArrayeSTM11_closure;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  caSq:
      I64[Hp - 16] = sat_saxO_info;
      P64[Hp] = R3;
      R1 = Hp - 16;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:44.93996 UTC

[(caSn, {sat_saxO_closure}), (caSo, {}),
 (caSp, {sat_saxO_closure}), (caSq, {sat_saxO_closure}), (caSr, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:44.940386 UTC

SkipList.$fMArrayTArrayeSTM11_entry() //  [R3, R2]
        { info_tbl: [(caSn,
                      label: SkipList.$fMArrayTArrayeSTM11_info
                      rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caSn:
          goto caSp;
      caSp:
          Hp = Hp + 24;
          if (Hp > HpLim) goto caSr; else goto caSq;
      caSr:
          HpAlloc = 24;
          goto caSo;
      caSo:
          R3 = R3;
          R2 = R2;
          R1 = SkipList.$fMArrayTArrayeSTM11_closure;
          call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
      caSq:
          I64[Hp - 16] = sat_saxO_info;
          P64[Hp] = R3;
          R1 = Hp - 16;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:44.941984 UTC

SkipList.$fMArrayTArrayeSTM11_entry() //  [R3, R2]
        { info_tbl: [(caSn,
                      label: SkipList.$fMArrayTArrayeSTM11_info
                      rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caSn:
          Hp = Hp + 24;
          if (Hp > HpLim) goto caSr; else goto caSq;
      caSr:
          HpAlloc = 24;
          R3 = R3;
          R2 = R2;
          R1 = SkipList.$fMArrayTArrayeSTM11_closure;
          call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
      caSq:
          I64[Hp - 16] = sat_saxO_info;
          P64[Hp] = R3;
          R1 = Hp - 16;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:44.943058 UTC

[section "data" {
     SkipList.$fMArrayTArrayeSTM11_closure:
         const SkipList.$fMArrayTArrayeSTM11_info;
 },
 sat_saxO_entry() //  [R1]
         { info_tbl: [(caSj,
                       label: sat_saxO_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caSj:
           _saxO::P64 = R1;
           if ((Sp + -16) < SpLim) goto caSk; else goto caSl;
       caSl:
           if (HpLim == 0) goto caSk; else goto caSm;
       caSk:
           R1 = _saxO::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caSm:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _saxO::P64;
           R2 = P64[_saxO::P64 + 16];
           Sp = Sp - 16;
           call GHC.Arr.bounds_info(R2) args: 24, res: 0, upd: 24;
     }
 },
 SkipList.$fMArrayTArrayeSTM11_entry() //  [R3, R2]
         { info_tbl: [(caSn,
                       label: SkipList.$fMArrayTArrayeSTM11_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caSn:
           Hp = Hp + 24;
           if (Hp > HpLim) goto caSr; else goto caSq;
       caSr:
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = SkipList.$fMArrayTArrayeSTM11_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caSq:
           I64[Hp - 16] = sat_saxO_info;
           P64[Hp] = R3;
           R1 = Hp - 16;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:44.945169 UTC

[section "data" {
     SkipList.$fMArrayTArrayeSTM11_closure:
         const SkipList.$fMArrayTArrayeSTM11_info;
 },
 sat_saxO_entry() //  [R1]
         { info_tbl: [(caSj,
                       label: sat_saxO_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caSj:
           _saxO::P64 = R1;
           if ((Sp + -16) < SpLim) goto caSk; else goto caSl;
       caSl:
           if (HpLim == 0) goto caSk; else goto caSm;
       caSk:
           R1 = _saxO::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caSm:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _saxO::P64;
           R2 = P64[_saxO::P64 + 16];
           Sp = Sp - 16;
           call GHC.Arr.bounds_info(R2) args: 24, res: 0, upd: 24;
     }
 },
 SkipList.$fMArrayTArrayeSTM11_entry() //  [R3, R2]
         { info_tbl: [(caSn,
                       label: SkipList.$fMArrayTArrayeSTM11_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caSn:
           Hp = Hp + 24;
           if (Hp > HpLim) goto caSr; else goto caSq;
       caSr:
           HpAlloc = 24;
           R3 = R3;
           R2 = R2;
           R1 = SkipList.$fMArrayTArrayeSTM11_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caSq:
           I64[Hp - 16] = sat_saxO_info;
           P64[Hp] = R3;
           R1 = Hp - 16;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:44.950546 UTC

[section "data" {
     SkipList.$fMArrayTArrayeSTM_$cgetBounds_closure:
         const SkipList.$fMArrayTArrayeSTM_$cgetBounds_info;
 },
 SkipList.$fMArrayTArrayeSTM_$cgetBounds_entry() //  [R3, R2]
         { info_tbl: [(caSD,
                       label: SkipList.$fMArrayTArrayeSTM_$cgetBounds_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caSD:
           _B2::P64 = R3;
           _B3::P64 = R2;
           goto caSB;
       caSB:
           if ((old + 0) - <highSp> < SpLim) goto caSE; else goto caSF;
       caSF:
           goto caSA;
       caSA:
           if (HpLim == 0) goto caSE; else goto caSG;
       caSE:
           R3 = _B2::P64;
           R2 = _B3::P64;
           R1 = SkipList.$fMArrayTArrayeSTM_$cgetBounds_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caSG:
           R3 = _B2::P64;
           R2 = _B3::P64;
           call SkipList.$fMArrayTArrayeSTM11_info(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:44.952302 UTC

{offset
  caSD:
      _B2::P64 = R3;
      _B3::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto caSE; else goto caSF;
  caSF:
      if (HpLim == 0) goto caSE; else goto caSG;
  caSE:
      R3 = _B2::P64;
      R2 = _B3::P64;
      R1 = SkipList.$fMArrayTArrayeSTM_$cgetBounds_closure;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  caSG:
      R3 = _B2::P64;
      R2 = _B3::P64;
      call SkipList.$fMArrayTArrayeSTM11_info(R3,
                                              R2) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:44.95329 UTC

{offset
  caSD:
      _B2::P64 = R3;
      _B3::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto caSE; else goto caSF;
  caSF:
      if (HpLim == 0) goto caSE; else goto caSG;
  caSE:
      R3 = _B2::P64;
      R2 = _B3::P64;
      R1 = SkipList.$fMArrayTArrayeSTM_$cgetBounds_closure;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  caSG:
      R3 = _B2::P64;
      R2 = _B3::P64;
      call SkipList.$fMArrayTArrayeSTM11_info(R3,
                                              R2) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:44.954159 UTC

{offset
  caSD:
      _B2::P64 = R3;
      _B3::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto caSE; else goto caSF;
  caSF:
      if (HpLim == 0) goto caSE; else goto caSG;
  caSE:
      R3 = _B2::P64;
      R2 = _B3::P64;
      R1 = SkipList.$fMArrayTArrayeSTM_$cgetBounds_closure;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  caSG:
      R3 = _B2::P64;
      R2 = _B3::P64;
      call SkipList.$fMArrayTArrayeSTM11_info(R3,
                                              R2) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:44.95505 UTC

{offset
  caSD:
      _B2::P64 = R3;
      _B3::P64 = R2;
      goto caSF;
  caSF:
      if (HpLim == 0) goto caSE; else goto caSG;
  caSE:
      R3 = _B2::P64;
      R2 = _B3::P64;
      R1 = SkipList.$fMArrayTArrayeSTM_$cgetBounds_closure;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  caSG:
      R3 = _B2::P64;
      R2 = _B3::P64;
      call SkipList.$fMArrayTArrayeSTM11_info(R3,
                                              R2) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:44.955825 UTC

{offset
  caSD:
      goto caSF;
  caSF:
      if (HpLim == 0) goto caSE; else goto caSG;
  caSE:
      R3 = R3;
      R2 = R2;
      R1 = SkipList.$fMArrayTArrayeSTM_$cgetBounds_closure;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  caSG:
      R3 = R3;
      R2 = R2;
      call SkipList.$fMArrayTArrayeSTM11_info(R3,
                                              R2) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:44.956694 UTC

[(caSD, {}), (caSE, {}), (caSF, {}), (caSG, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:44.95704 UTC

SkipList.$fMArrayTArrayeSTM_$cgetBounds_entry() //  [R3, R2]
        { info_tbl: [(caSD,
                      label: SkipList.$fMArrayTArrayeSTM_$cgetBounds_info
                      rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caSD:
          goto caSF;
      caSF:
          if (HpLim == 0) goto caSE; else goto caSG;
      caSE:
          R3 = R3;
          R2 = R2;
          R1 = SkipList.$fMArrayTArrayeSTM_$cgetBounds_closure;
          call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
      caSG:
          R3 = R3;
          R2 = R2;
          call SkipList.$fMArrayTArrayeSTM11_info(R3,
                                                  R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:44.95799 UTC

SkipList.$fMArrayTArrayeSTM_$cgetBounds_entry() //  [R3, R2]
        { info_tbl: [(caSD,
                      label: SkipList.$fMArrayTArrayeSTM_$cgetBounds_info
                      rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caSD:
          if (HpLim == 0) goto caSE; else goto caSG;
      caSE:
          R3 = R3;
          R2 = R2;
          R1 = SkipList.$fMArrayTArrayeSTM_$cgetBounds_closure;
          call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
      caSG:
          R3 = R3;
          R2 = R2;
          call SkipList.$fMArrayTArrayeSTM11_info(R3,
                                                  R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:44.958906 UTC

[section "data" {
     SkipList.$fMArrayTArrayeSTM_$cgetBounds_closure:
         const SkipList.$fMArrayTArrayeSTM_$cgetBounds_info;
 },
 SkipList.$fMArrayTArrayeSTM_$cgetBounds_entry() //  [R3, R2]
         { info_tbl: [(caSD,
                       label: SkipList.$fMArrayTArrayeSTM_$cgetBounds_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caSD:
           if (HpLim == 0) goto caSE; else goto caSG;
       caSE:
           R3 = R3;
           R2 = R2;
           R1 = SkipList.$fMArrayTArrayeSTM_$cgetBounds_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caSG:
           R3 = R3;
           R2 = R2;
           call SkipList.$fMArrayTArrayeSTM11_info(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:44.95996 UTC

[section "data" {
     SkipList.$fMArrayTArrayeSTM_$cgetBounds_closure:
         const SkipList.$fMArrayTArrayeSTM_$cgetBounds_info;
 },
 SkipList.$fMArrayTArrayeSTM_$cgetBounds_entry() //  [R3, R2]
         { info_tbl: [(caSD,
                       label: SkipList.$fMArrayTArrayeSTM_$cgetBounds_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caSD:
           if (HpLim == 0) goto caSE; else goto caSG;
       caSE:
           R3 = R3;
           R2 = R2;
           R1 = SkipList.$fMArrayTArrayeSTM_$cgetBounds_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caSG:
           R3 = R3;
           R2 = R2;
           call SkipList.$fMArrayTArrayeSTM11_info(R3,
                                                   R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:44.962645 UTC

[section "data" {
     SkipList.$fEqTArray1_closure:
         const SkipList.$fEqTArray1_info;
 },
 SkipList.$fEqTArray1_entry() //  [R4, R3, R2]
         { info_tbl: [(caSP,
                       label: SkipList.$fEqTArray1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caSP:
           _B1::P64 = R4;
           _B2::P64 = R3;
           _saxP::P64 = R2;
           goto caSN;
       caSN:
           if ((old + 0) - <highSp> < SpLim) goto caSQ; else goto caSR;
       caSR:
           goto caSM;
       caSM:
           if (HpLim == 0) goto caSQ; else goto caSS;
       caSQ:
           R4 = _B1::P64;
           R3 = _B2::P64;
           R2 = _saxP::P64;
           R1 = SkipList.$fEqTArray1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caSS:
           R5 = _B1::P64;
           R4 = _B2::P64;
           R3 = GHC.Conc.Sync.$fEqTVar_closure;
           R2 = _saxP::P64;
           call GHC.Arr.$fEqArray_$c/=_info(R5,
                                            R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:44.964572 UTC

{offset
  caSP:
      _B1::P64 = R4;
      _B2::P64 = R3;
      _saxP::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto caSQ; else goto caSR;
  caSR:
      if (HpLim == 0) goto caSQ; else goto caSS;
  caSQ:
      R4 = _B1::P64;
      R3 = _B2::P64;
      R2 = _saxP::P64;
      R1 = SkipList.$fEqTArray1_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  caSS:
      R5 = _B1::P64;
      R4 = _B2::P64;
      R3 = GHC.Conc.Sync.$fEqTVar_closure;
      R2 = _saxP::P64;
      call GHC.Arr.$fEqArray_$c/=_info(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:44.965602 UTC

{offset
  caSP:
      _B1::P64 = R4;
      _B2::P64 = R3;
      _saxP::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto caSQ; else goto caSR;
  caSR:
      if (HpLim == 0) goto caSQ; else goto caSS;
  caSQ:
      R4 = _B1::P64;
      R3 = _B2::P64;
      R2 = _saxP::P64;
      R1 = SkipList.$fEqTArray1_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  caSS:
      R5 = _B1::P64;
      R4 = _B2::P64;
      R3 = GHC.Conc.Sync.$fEqTVar_closure;
      R2 = _saxP::P64;
      call GHC.Arr.$fEqArray_$c/=_info(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:44.966647 UTC

{offset
  caSP:
      _B1::P64 = R4;
      _B2::P64 = R3;
      _saxP::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto caSQ; else goto caSR;
  caSR:
      if (HpLim == 0) goto caSQ; else goto caSS;
  caSQ:
      R4 = _B1::P64;
      R3 = _B2::P64;
      R2 = _saxP::P64;
      R1 = SkipList.$fEqTArray1_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  caSS:
      R5 = _B1::P64;
      R4 = _B2::P64;
      R3 = GHC.Conc.Sync.$fEqTVar_closure;
      R2 = _saxP::P64;
      call GHC.Arr.$fEqArray_$c/=_info(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:44.967744 UTC

{offset
  caSP:
      _B1::P64 = R4;
      _B2::P64 = R3;
      _saxP::P64 = R2;
      goto caSR;
  caSR:
      if (HpLim == 0) goto caSQ; else goto caSS;
  caSQ:
      R4 = _B1::P64;
      R3 = _B2::P64;
      R2 = _saxP::P64;
      R1 = SkipList.$fEqTArray1_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  caSS:
      R5 = _B1::P64;
      R4 = _B2::P64;
      R3 = GHC.Conc.Sync.$fEqTVar_closure;
      R2 = _saxP::P64;
      call GHC.Arr.$fEqArray_$c/=_info(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:44.968691 UTC

{offset
  caSP:
      goto caSR;
  caSR:
      if (HpLim == 0) goto caSQ; else goto caSS;
  caSQ:
      R4 = R4;
      R3 = R3;
      R2 = R2;
      R1 = SkipList.$fEqTArray1_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  caSS:
      R5 = R4;
      R4 = R3;
      R3 = GHC.Conc.Sync.$fEqTVar_closure;
      R2 = R2;
      call GHC.Arr.$fEqArray_$c/=_info(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:44.969736 UTC

[(caSP, {}), (caSQ, {}), (caSR, {}), (caSS, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:44.970056 UTC

SkipList.$fEqTArray1_entry() //  [R4, R3, R2]
        { info_tbl: [(caSP,
                      label: SkipList.$fEqTArray1_info
                      rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caSP:
          goto caSR;
      caSR:
          if (HpLim == 0) goto caSQ; else goto caSS;
      caSQ:
          R4 = R4;
          R3 = R3;
          R2 = R2;
          R1 = SkipList.$fEqTArray1_closure;
          call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
      caSS:
          R5 = R4;
          R4 = R3;
          R3 = GHC.Conc.Sync.$fEqTVar_closure;
          R2 = R2;
          call GHC.Arr.$fEqArray_$c/=_info(R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:44.97165 UTC

SkipList.$fEqTArray1_entry() //  [R4, R3, R2]
        { info_tbl: [(caSP,
                      label: SkipList.$fEqTArray1_info
                      rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caSP:
          if (HpLim == 0) goto caSQ; else goto caSS;
      caSQ:
          R4 = R4;
          R3 = R3;
          R2 = R2;
          R1 = SkipList.$fEqTArray1_closure;
          call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
      caSS:
          R5 = R4;
          R4 = R3;
          R3 = GHC.Conc.Sync.$fEqTVar_closure;
          R2 = R2;
          call GHC.Arr.$fEqArray_$c/=_info(R5,
                                           R4,
                                           R3,
                                           R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:44.972813 UTC

[section "data" {
     SkipList.$fEqTArray1_closure:
         const SkipList.$fEqTArray1_info;
 },
 SkipList.$fEqTArray1_entry() //  [R4, R3, R2]
         { info_tbl: [(caSP,
                       label: SkipList.$fEqTArray1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caSP:
           if (HpLim == 0) goto caSQ; else goto caSS;
       caSQ:
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = SkipList.$fEqTArray1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caSS:
           R5 = R4;
           R4 = R3;
           R3 = GHC.Conc.Sync.$fEqTVar_closure;
           R2 = R2;
           call GHC.Arr.$fEqArray_$c/=_info(R5,
                                            R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:44.973995 UTC

[section "data" {
     SkipList.$fEqTArray1_closure:
         const SkipList.$fEqTArray1_info;
 },
 SkipList.$fEqTArray1_entry() //  [R4, R3, R2]
         { info_tbl: [(caSP,
                       label: SkipList.$fEqTArray1_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caSP:
           if (HpLim == 0) goto caSQ; else goto caSS;
       caSQ:
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = SkipList.$fEqTArray1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caSS:
           R5 = R4;
           R4 = R3;
           R3 = GHC.Conc.Sync.$fEqTVar_closure;
           R2 = R2;
           call GHC.Arr.$fEqArray_$c/=_info(R5,
                                            R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:44.977043 UTC

[section "data" {
     SkipList.$fEqTArray_$c/=_closure:
         const SkipList.$fEqTArray_$c/=_info;
 },
 SkipList.$fEqTArray_$c/=_entry() //  [R4, R3, R2]
         { info_tbl: [(caT1,
                       label: SkipList.$fEqTArray_$c/=_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caT1:
           _B1::P64 = R4;
           _B2::P64 = R3;
           _B3::P64 = R2;
           goto caSZ;
       caSZ:
           if ((old + 0) - <highSp> < SpLim) goto caT2; else goto caT3;
       caT3:
           goto caSY;
       caSY:
           if (HpLim == 0) goto caT2; else goto caT4;
       caT2:
           R4 = _B1::P64;
           R3 = _B2::P64;
           R2 = _B3::P64;
           R1 = SkipList.$fEqTArray_$c/=_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caT4:
           R4 = _B1::P64;
           R3 = _B2::P64;
           R2 = _B3::P64;
           call SkipList.$fEqTArray1_info(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:44.978833 UTC

{offset
  caT1:
      _B1::P64 = R4;
      _B2::P64 = R3;
      _B3::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto caT2; else goto caT3;
  caT3:
      if (HpLim == 0) goto caT2; else goto caT4;
  caT2:
      R4 = _B1::P64;
      R3 = _B2::P64;
      R2 = _B3::P64;
      R1 = SkipList.$fEqTArray_$c/=_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  caT4:
      R4 = _B1::P64;
      R3 = _B2::P64;
      R2 = _B3::P64;
      call SkipList.$fEqTArray1_info(R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:44.979782 UTC

{offset
  caT1:
      _B1::P64 = R4;
      _B2::P64 = R3;
      _B3::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto caT2; else goto caT3;
  caT3:
      if (HpLim == 0) goto caT2; else goto caT4;
  caT2:
      R4 = _B1::P64;
      R3 = _B2::P64;
      R2 = _B3::P64;
      R1 = SkipList.$fEqTArray_$c/=_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  caT4:
      R4 = _B1::P64;
      R3 = _B2::P64;
      R2 = _B3::P64;
      call SkipList.$fEqTArray1_info(R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:44.980733 UTC

{offset
  caT1:
      _B1::P64 = R4;
      _B2::P64 = R3;
      _B3::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto caT2; else goto caT3;
  caT3:
      if (HpLim == 0) goto caT2; else goto caT4;
  caT2:
      R4 = _B1::P64;
      R3 = _B2::P64;
      R2 = _B3::P64;
      R1 = SkipList.$fEqTArray_$c/=_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  caT4:
      R4 = _B1::P64;
      R3 = _B2::P64;
      R2 = _B3::P64;
      call SkipList.$fEqTArray1_info(R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:44.981745 UTC

{offset
  caT1:
      _B1::P64 = R4;
      _B2::P64 = R3;
      _B3::P64 = R2;
      goto caT3;
  caT3:
      if (HpLim == 0) goto caT2; else goto caT4;
  caT2:
      R4 = _B1::P64;
      R3 = _B2::P64;
      R2 = _B3::P64;
      R1 = SkipList.$fEqTArray_$c/=_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  caT4:
      R4 = _B1::P64;
      R3 = _B2::P64;
      R2 = _B3::P64;
      call SkipList.$fEqTArray1_info(R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:44.982642 UTC

{offset
  caT1:
      goto caT3;
  caT3:
      if (HpLim == 0) goto caT2; else goto caT4;
  caT2:
      R4 = R4;
      R3 = R3;
      R2 = R2;
      R1 = SkipList.$fEqTArray_$c/=_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  caT4:
      R4 = R4;
      R3 = R3;
      R2 = R2;
      call SkipList.$fEqTArray1_info(R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:44.983592 UTC

[(caT1, {}), (caT2, {}), (caT3, {}), (caT4, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:44.983907 UTC

SkipList.$fEqTArray_$c/=_entry() //  [R4, R3, R2]
        { info_tbl: [(caT1,
                      label: SkipList.$fEqTArray_$c/=_info
                      rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caT1:
          goto caT3;
      caT3:
          if (HpLim == 0) goto caT2; else goto caT4;
      caT2:
          R4 = R4;
          R3 = R3;
          R2 = R2;
          R1 = SkipList.$fEqTArray_$c/=_closure;
          call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
      caT4:
          R4 = R4;
          R3 = R3;
          R2 = R2;
          call SkipList.$fEqTArray1_info(R4, R3, R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:44.984896 UTC

SkipList.$fEqTArray_$c/=_entry() //  [R4, R3, R2]
        { info_tbl: [(caT1,
                      label: SkipList.$fEqTArray_$c/=_info
                      rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caT1:
          if (HpLim == 0) goto caT2; else goto caT4;
      caT2:
          R4 = R4;
          R3 = R3;
          R2 = R2;
          R1 = SkipList.$fEqTArray_$c/=_closure;
          call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
      caT4:
          R4 = R4;
          R3 = R3;
          R2 = R2;
          call SkipList.$fEqTArray1_info(R4, R3, R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:44.985872 UTC

[section "data" {
     SkipList.$fEqTArray_$c/=_closure:
         const SkipList.$fEqTArray_$c/=_info;
 },
 SkipList.$fEqTArray_$c/=_entry() //  [R4, R3, R2]
         { info_tbl: [(caT1,
                       label: SkipList.$fEqTArray_$c/=_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caT1:
           if (HpLim == 0) goto caT2; else goto caT4;
       caT2:
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = SkipList.$fEqTArray_$c/=_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caT4:
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call SkipList.$fEqTArray1_info(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:44.987016 UTC

[section "data" {
     SkipList.$fEqTArray_$c/=_closure:
         const SkipList.$fEqTArray_$c/=_info;
 },
 SkipList.$fEqTArray_$c/=_entry() //  [R4, R3, R2]
         { info_tbl: [(caT1,
                       label: SkipList.$fEqTArray_$c/=_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caT1:
           if (HpLim == 0) goto caT2; else goto caT4;
       caT2:
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = SkipList.$fEqTArray_$c/=_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caT4:
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call SkipList.$fEqTArray1_info(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:44.989792 UTC

[section "data" {
     SkipList.$fEqTArray2_closure:
         const SkipList.$fEqTArray2_info;
 },
 SkipList.$fEqTArray2_entry() //  [R4, R3, R2]
         { info_tbl: [(caTd,
                       label: SkipList.$fEqTArray2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caTd:
           _B1::P64 = R4;
           _B2::P64 = R3;
           _saxQ::P64 = R2;
           goto caTb;
       caTb:
           if ((old + 0) - <highSp> < SpLim) goto caTe; else goto caTf;
       caTf:
           goto caTa;
       caTa:
           if (HpLim == 0) goto caTe; else goto caTg;
       caTe:
           R4 = _B1::P64;
           R3 = _B2::P64;
           R2 = _saxQ::P64;
           R1 = SkipList.$fEqTArray2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caTg:
           R5 = _B1::P64;
           R4 = _B2::P64;
           R3 = GHC.Conc.Sync.$fEqTVar_closure;
           R2 = _saxQ::P64;
           call GHC.Arr.eqArray_info(R5, R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:44.991637 UTC

{offset
  caTd:
      _B1::P64 = R4;
      _B2::P64 = R3;
      _saxQ::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto caTe; else goto caTf;
  caTf:
      if (HpLim == 0) goto caTe; else goto caTg;
  caTe:
      R4 = _B1::P64;
      R3 = _B2::P64;
      R2 = _saxQ::P64;
      R1 = SkipList.$fEqTArray2_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  caTg:
      R5 = _B1::P64;
      R4 = _B2::P64;
      R3 = GHC.Conc.Sync.$fEqTVar_closure;
      R2 = _saxQ::P64;
      call GHC.Arr.eqArray_info(R5, R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:44.992641 UTC

{offset
  caTd:
      _B1::P64 = R4;
      _B2::P64 = R3;
      _saxQ::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto caTe; else goto caTf;
  caTf:
      if (HpLim == 0) goto caTe; else goto caTg;
  caTe:
      R4 = _B1::P64;
      R3 = _B2::P64;
      R2 = _saxQ::P64;
      R1 = SkipList.$fEqTArray2_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  caTg:
      R5 = _B1::P64;
      R4 = _B2::P64;
      R3 = GHC.Conc.Sync.$fEqTVar_closure;
      R2 = _saxQ::P64;
      call GHC.Arr.eqArray_info(R5, R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:44.993648 UTC

{offset
  caTd:
      _B1::P64 = R4;
      _B2::P64 = R3;
      _saxQ::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto caTe; else goto caTf;
  caTf:
      if (HpLim == 0) goto caTe; else goto caTg;
  caTe:
      R4 = _B1::P64;
      R3 = _B2::P64;
      R2 = _saxQ::P64;
      R1 = SkipList.$fEqTArray2_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  caTg:
      R5 = _B1::P64;
      R4 = _B2::P64;
      R3 = GHC.Conc.Sync.$fEqTVar_closure;
      R2 = _saxQ::P64;
      call GHC.Arr.eqArray_info(R5, R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:44.99468 UTC

{offset
  caTd:
      _B1::P64 = R4;
      _B2::P64 = R3;
      _saxQ::P64 = R2;
      goto caTf;
  caTf:
      if (HpLim == 0) goto caTe; else goto caTg;
  caTe:
      R4 = _B1::P64;
      R3 = _B2::P64;
      R2 = _saxQ::P64;
      R1 = SkipList.$fEqTArray2_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  caTg:
      R5 = _B1::P64;
      R4 = _B2::P64;
      R3 = GHC.Conc.Sync.$fEqTVar_closure;
      R2 = _saxQ::P64;
      call GHC.Arr.eqArray_info(R5, R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:44.995595 UTC

{offset
  caTd:
      goto caTf;
  caTf:
      if (HpLim == 0) goto caTe; else goto caTg;
  caTe:
      R4 = R4;
      R3 = R3;
      R2 = R2;
      R1 = SkipList.$fEqTArray2_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  caTg:
      R5 = R4;
      R4 = R3;
      R3 = GHC.Conc.Sync.$fEqTVar_closure;
      R2 = R2;
      call GHC.Arr.eqArray_info(R5, R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:44.996603 UTC

[(caTd, {}), (caTe, {}), (caTf, {}), (caTg, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:44.997463 UTC

SkipList.$fEqTArray2_entry() //  [R4, R3, R2]
        { info_tbl: [(caTd,
                      label: SkipList.$fEqTArray2_info
                      rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caTd:
          goto caTf;
      caTf:
          if (HpLim == 0) goto caTe; else goto caTg;
      caTe:
          R4 = R4;
          R3 = R3;
          R2 = R2;
          R1 = SkipList.$fEqTArray2_closure;
          call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
      caTg:
          R5 = R4;
          R4 = R3;
          R3 = GHC.Conc.Sync.$fEqTVar_closure;
          R2 = R2;
          call GHC.Arr.eqArray_info(R5, R4, R3, R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:44.998536 UTC

SkipList.$fEqTArray2_entry() //  [R4, R3, R2]
        { info_tbl: [(caTd,
                      label: SkipList.$fEqTArray2_info
                      rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caTd:
          if (HpLim == 0) goto caTe; else goto caTg;
      caTe:
          R4 = R4;
          R3 = R3;
          R2 = R2;
          R1 = SkipList.$fEqTArray2_closure;
          call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
      caTg:
          R5 = R4;
          R4 = R3;
          R3 = GHC.Conc.Sync.$fEqTVar_closure;
          R2 = R2;
          call GHC.Arr.eqArray_info(R5, R4, R3, R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:44.999553 UTC

[section "data" {
     SkipList.$fEqTArray2_closure:
         const SkipList.$fEqTArray2_info;
 },
 SkipList.$fEqTArray2_entry() //  [R4, R3, R2]
         { info_tbl: [(caTd,
                       label: SkipList.$fEqTArray2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caTd:
           if (HpLim == 0) goto caTe; else goto caTg;
       caTe:
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = SkipList.$fEqTArray2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caTg:
           R5 = R4;
           R4 = R3;
           R3 = GHC.Conc.Sync.$fEqTVar_closure;
           R2 = R2;
           call GHC.Arr.eqArray_info(R5, R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:45.000709 UTC

[section "data" {
     SkipList.$fEqTArray2_closure:
         const SkipList.$fEqTArray2_info;
 },
 SkipList.$fEqTArray2_entry() //  [R4, R3, R2]
         { info_tbl: [(caTd,
                       label: SkipList.$fEqTArray2_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caTd:
           if (HpLim == 0) goto caTe; else goto caTg;
       caTe:
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = SkipList.$fEqTArray2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caTg:
           R5 = R4;
           R4 = R3;
           R3 = GHC.Conc.Sync.$fEqTVar_closure;
           R2 = R2;
           call GHC.Arr.eqArray_info(R5, R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:45.003702 UTC

[section "data" {
     SkipList.$fEqTArray_$c==_closure:
         const SkipList.$fEqTArray_$c==_info;
 },
 SkipList.$fEqTArray_$c==_entry() //  [R4, R3, R2]
         { info_tbl: [(caTp,
                       label: SkipList.$fEqTArray_$c==_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caTp:
           _B1::P64 = R4;
           _B2::P64 = R3;
           _B3::P64 = R2;
           goto caTn;
       caTn:
           if ((old + 0) - <highSp> < SpLim) goto caTq; else goto caTr;
       caTr:
           goto caTm;
       caTm:
           if (HpLim == 0) goto caTq; else goto caTs;
       caTq:
           R4 = _B1::P64;
           R3 = _B2::P64;
           R2 = _B3::P64;
           R1 = SkipList.$fEqTArray_$c==_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caTs:
           R4 = _B1::P64;
           R3 = _B2::P64;
           R2 = _B3::P64;
           call SkipList.$fEqTArray2_info(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:45.005479 UTC

{offset
  caTp:
      _B1::P64 = R4;
      _B2::P64 = R3;
      _B3::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto caTq; else goto caTr;
  caTr:
      if (HpLim == 0) goto caTq; else goto caTs;
  caTq:
      R4 = _B1::P64;
      R3 = _B2::P64;
      R2 = _B3::P64;
      R1 = SkipList.$fEqTArray_$c==_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  caTs:
      R4 = _B1::P64;
      R3 = _B2::P64;
      R2 = _B3::P64;
      call SkipList.$fEqTArray2_info(R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:45.006428 UTC

{offset
  caTp:
      _B1::P64 = R4;
      _B2::P64 = R3;
      _B3::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto caTq; else goto caTr;
  caTr:
      if (HpLim == 0) goto caTq; else goto caTs;
  caTq:
      R4 = _B1::P64;
      R3 = _B2::P64;
      R2 = _B3::P64;
      R1 = SkipList.$fEqTArray_$c==_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  caTs:
      R4 = _B1::P64;
      R3 = _B2::P64;
      R2 = _B3::P64;
      call SkipList.$fEqTArray2_info(R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:45.007401 UTC

{offset
  caTp:
      _B1::P64 = R4;
      _B2::P64 = R3;
      _B3::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto caTq; else goto caTr;
  caTr:
      if (HpLim == 0) goto caTq; else goto caTs;
  caTq:
      R4 = _B1::P64;
      R3 = _B2::P64;
      R2 = _B3::P64;
      R1 = SkipList.$fEqTArray_$c==_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  caTs:
      R4 = _B1::P64;
      R3 = _B2::P64;
      R2 = _B3::P64;
      call SkipList.$fEqTArray2_info(R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:45.008411 UTC

{offset
  caTp:
      _B1::P64 = R4;
      _B2::P64 = R3;
      _B3::P64 = R2;
      goto caTr;
  caTr:
      if (HpLim == 0) goto caTq; else goto caTs;
  caTq:
      R4 = _B1::P64;
      R3 = _B2::P64;
      R2 = _B3::P64;
      R1 = SkipList.$fEqTArray_$c==_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  caTs:
      R4 = _B1::P64;
      R3 = _B2::P64;
      R2 = _B3::P64;
      call SkipList.$fEqTArray2_info(R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:45.009287 UTC

{offset
  caTp:
      goto caTr;
  caTr:
      if (HpLim == 0) goto caTq; else goto caTs;
  caTq:
      R4 = R4;
      R3 = R3;
      R2 = R2;
      R1 = SkipList.$fEqTArray_$c==_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  caTs:
      R4 = R4;
      R3 = R3;
      R2 = R2;
      call SkipList.$fEqTArray2_info(R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:45.010249 UTC

[(caTp, {}), (caTq, {}), (caTr, {}), (caTs, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:45.01056 UTC

SkipList.$fEqTArray_$c==_entry() //  [R4, R3, R2]
        { info_tbl: [(caTp,
                      label: SkipList.$fEqTArray_$c==_info
                      rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caTp:
          goto caTr;
      caTr:
          if (HpLim == 0) goto caTq; else goto caTs;
      caTq:
          R4 = R4;
          R3 = R3;
          R2 = R2;
          R1 = SkipList.$fEqTArray_$c==_closure;
          call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
      caTs:
          R4 = R4;
          R3 = R3;
          R2 = R2;
          call SkipList.$fEqTArray2_info(R4, R3, R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:45.011539 UTC

SkipList.$fEqTArray_$c==_entry() //  [R4, R3, R2]
        { info_tbl: [(caTp,
                      label: SkipList.$fEqTArray_$c==_info
                      rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caTp:
          if (HpLim == 0) goto caTq; else goto caTs;
      caTq:
          R4 = R4;
          R3 = R3;
          R2 = R2;
          R1 = SkipList.$fEqTArray_$c==_closure;
          call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
      caTs:
          R4 = R4;
          R3 = R3;
          R2 = R2;
          call SkipList.$fEqTArray2_info(R4, R3, R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:45.012629 UTC

[section "data" {
     SkipList.$fEqTArray_$c==_closure:
         const SkipList.$fEqTArray_$c==_info;
 },
 SkipList.$fEqTArray_$c==_entry() //  [R4, R3, R2]
         { info_tbl: [(caTp,
                       label: SkipList.$fEqTArray_$c==_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caTp:
           if (HpLim == 0) goto caTq; else goto caTs;
       caTq:
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = SkipList.$fEqTArray_$c==_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caTs:
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call SkipList.$fEqTArray2_info(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:45.013741 UTC

[section "data" {
     SkipList.$fEqTArray_$c==_closure:
         const SkipList.$fEqTArray_$c==_info;
 },
 SkipList.$fEqTArray_$c==_entry() //  [R4, R3, R2]
         { info_tbl: [(caTp,
                       label: SkipList.$fEqTArray_$c==_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caTp:
           if (HpLim == 0) goto caTq; else goto caTs;
       caTq:
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = SkipList.$fEqTArray_$c==_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caTs:
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call SkipList.$fEqTArray2_info(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:45.016667 UTC

[section "data" {
     SkipList.$fEqTArray_closure:
         const SkipList.$fEqTArray_info;
 },
 sat_saxT_entry() //  [R3, R2, R1]
         { info_tbl: [(caTG,
                       label: sat_saxT_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caTG:
           _B1::P64 = R3;
           _B2::P64 = R2;
           _saxT::P64 = R1;
           goto caTE;
       caTE:
           if ((old + 0) - <highSp> < SpLim) goto caTH; else goto caTI;
       caTI:
           goto caTD;
       caTD:
           if (HpLim == 0) goto caTH; else goto caTJ;
       caTH:
           R3 = _B1::P64;
           R2 = _B2::P64;
           R1 = _saxT::P64;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caTJ:
           _saxR::P64 = P64[_saxT::P64 + 6];
           R4 = _B1::P64;
           R3 = _B2::P64;
           R2 = _saxR::P64;
           call SkipList.$fEqTArray1_info(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_saxS_entry() //  [R3, R2, R1]
         { info_tbl: [(caTP,
                       label: sat_saxS_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caTP:
           _B1::P64 = R3;
           _B2::P64 = R2;
           _saxS::P64 = R1;
           goto caTN;
       caTN:
           if ((old + 0) - <highSp> < SpLim) goto caTQ; else goto caTR;
       caTR:
           goto caTM;
       caTM:
           if (HpLim == 0) goto caTQ; else goto caTS;
       caTQ:
           R3 = _B1::P64;
           R2 = _B2::P64;
           R1 = _saxS::P64;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caTS:
           _saxR::P64 = P64[_saxS::P64 + 6];
           R4 = _B1::P64;
           R3 = _B2::P64;
           R2 = _saxR::P64;
           call SkipList.$fEqTArray2_info(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 SkipList.$fEqTArray_entry() //  [R2]
         { info_tbl: [(caTU,
                       label: SkipList.$fEqTArray_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caTU:
           _saxR::P64 = R2;
           goto caTz;
       caTz:
           if ((old + 0) - <highSp> < SpLim) goto caTV; else goto caTW;
       caTW:
           goto caTy;
       caTy:
           Hp = Hp + 56;
           if (Hp > HpLim) goto caTY; else goto caTX;
       caTY:
           HpAlloc = 56;
           goto caTV;
       caTV:
           R2 = _saxR::P64;
           R1 = SkipList.$fEqTArray_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caTX:
           I64[Hp - 48] = sat_saxT_info;
           P64[Hp - 40] = _saxR::P64;
           _caTB::P64 = Hp - 46;
           I64[Hp - 32] = sat_saxS_info;
           P64[Hp - 24] = _saxR::P64;
           _caTK::P64 = Hp - 30;
           I64[Hp - 16] = GHC.Classes.D:Eq_con_info;
           P64[Hp - 8] = _caTK::P64;
           P64[Hp] = _caTB::P64;
           _caTT::P64 = Hp - 15;
           R1 = _caTT::P64;
           call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:45.021936 UTC

{offset
  caTG:
      _B1::P64 = R3;
      _B2::P64 = R2;
      _saxT::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto caTH; else goto caTI;
  caTI:
      if (HpLim == 0) goto caTH; else goto caTJ;
  caTH:
      R3 = _B1::P64;
      R2 = _B2::P64;
      R1 = _saxT::P64;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  caTJ:
      _saxR::P64 = P64[_saxT::P64 + 6];
      R4 = _B1::P64;
      R3 = _B2::P64;
      R2 = _saxR::P64;
      call SkipList.$fEqTArray1_info(R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:45.022943 UTC

{offset
  caTG:
      _B1::P64 = R3;
      _B2::P64 = R2;
      _saxT::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto caTH; else goto caTI;
  caTI:
      if (HpLim == 0) goto caTH; else goto caTJ;
  caTH:
      R3 = _B1::P64;
      R2 = _B2::P64;
      R1 = _saxT::P64;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  caTJ:
      _saxR::P64 = P64[_saxT::P64 + 6];
      R4 = _B1::P64;
      R3 = _B2::P64;
      R2 = _saxR::P64;
      call SkipList.$fEqTArray1_info(R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:45.023918 UTC

{offset
  caTG:
      _B1::P64 = R3;
      _B2::P64 = R2;
      _saxT::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto caTH; else goto caTI;
  caTI:
      if (HpLim == 0) goto caTH; else goto caTJ;
  caTH:
      R3 = _B1::P64;
      R2 = _B2::P64;
      R1 = _saxT::P64;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  caTJ:
      _saxR::P64 = P64[_saxT::P64 + 6];
      R4 = _B1::P64;
      R3 = _B2::P64;
      R2 = _saxR::P64;
      call SkipList.$fEqTArray1_info(R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:45.024929 UTC

{offset
  caTG:
      _B1::P64 = R3;
      _B2::P64 = R2;
      _saxT::P64 = R1;
      goto caTI;
  caTI:
      if (HpLim == 0) goto caTH; else goto caTJ;
  caTH:
      R3 = _B1::P64;
      R2 = _B2::P64;
      R1 = _saxT::P64;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  caTJ:
      _saxR::P64 = P64[_saxT::P64 + 6];
      R4 = _B1::P64;
      R3 = _B2::P64;
      R2 = _saxR::P64;
      call SkipList.$fEqTArray1_info(R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:45.025816 UTC

{offset
  caTG:
      goto caTI;
  caTI:
      if (HpLim == 0) goto caTH; else goto caTJ;
  caTH:
      R3 = R3;
      R2 = R2;
      R1 = R1;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  caTJ:
      R4 = R3;
      R3 = R2;
      R2 = P64[R1 + 6];
      call SkipList.$fEqTArray1_info(R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:45.026764 UTC

[(caTG, {}), (caTH, {}), (caTI, {}), (caTJ, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:45.027709 UTC

sat_saxT_entry() //  [R3, R2, R1]
        { info_tbl: [(caTG,
                      label: sat_saxT_info
                      rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caTG:
          goto caTI;
      caTI:
          if (HpLim == 0) goto caTH; else goto caTJ;
      caTH:
          R3 = R3;
          R2 = R2;
          R1 = R1;
          call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
      caTJ:
          R4 = R3;
          R3 = R2;
          R2 = P64[R1 + 6];
          call SkipList.$fEqTArray1_info(R4, R3, R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:45.028674 UTC

sat_saxT_entry() //  [R3, R2, R1]
        { info_tbl: [(caTG,
                      label: sat_saxT_info
                      rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caTG:
          if (HpLim == 0) goto caTH; else goto caTJ;
      caTH:
          R3 = R3;
          R2 = R2;
          R1 = R1;
          call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
      caTJ:
          R4 = R3;
          R3 = R2;
          R2 = P64[R1 + 6];
          call SkipList.$fEqTArray1_info(R4, R3, R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:45.029633 UTC

{offset
  caTP:
      _B1::P64 = R3;
      _B2::P64 = R2;
      _saxS::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto caTQ; else goto caTR;
  caTR:
      if (HpLim == 0) goto caTQ; else goto caTS;
  caTQ:
      R3 = _B1::P64;
      R2 = _B2::P64;
      R1 = _saxS::P64;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  caTS:
      _saxR::P64 = P64[_saxS::P64 + 6];
      R4 = _B1::P64;
      R3 = _B2::P64;
      R2 = _saxR::P64;
      call SkipList.$fEqTArray2_info(R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:45.030583 UTC

{offset
  caTP:
      _B1::P64 = R3;
      _B2::P64 = R2;
      _saxS::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto caTQ; else goto caTR;
  caTR:
      if (HpLim == 0) goto caTQ; else goto caTS;
  caTQ:
      R3 = _B1::P64;
      R2 = _B2::P64;
      R1 = _saxS::P64;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  caTS:
      _saxR::P64 = P64[_saxS::P64 + 6];
      R4 = _B1::P64;
      R3 = _B2::P64;
      R2 = _saxR::P64;
      call SkipList.$fEqTArray2_info(R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:45.031557 UTC

{offset
  caTP:
      _B1::P64 = R3;
      _B2::P64 = R2;
      _saxS::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto caTQ; else goto caTR;
  caTR:
      if (HpLim == 0) goto caTQ; else goto caTS;
  caTQ:
      R3 = _B1::P64;
      R2 = _B2::P64;
      R1 = _saxS::P64;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  caTS:
      _saxR::P64 = P64[_saxS::P64 + 6];
      R4 = _B1::P64;
      R3 = _B2::P64;
      R2 = _saxR::P64;
      call SkipList.$fEqTArray2_info(R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:45.032658 UTC

{offset
  caTP:
      _B1::P64 = R3;
      _B2::P64 = R2;
      _saxS::P64 = R1;
      goto caTR;
  caTR:
      if (HpLim == 0) goto caTQ; else goto caTS;
  caTQ:
      R3 = _B1::P64;
      R2 = _B2::P64;
      R1 = _saxS::P64;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  caTS:
      _saxR::P64 = P64[_saxS::P64 + 6];
      R4 = _B1::P64;
      R3 = _B2::P64;
      R2 = _saxR::P64;
      call SkipList.$fEqTArray2_info(R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:45.033536 UTC

{offset
  caTP:
      goto caTR;
  caTR:
      if (HpLim == 0) goto caTQ; else goto caTS;
  caTQ:
      R3 = R3;
      R2 = R2;
      R1 = R1;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  caTS:
      R4 = R3;
      R3 = R2;
      R2 = P64[R1 + 6];
      call SkipList.$fEqTArray2_info(R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:45.03445 UTC

[(caTP, {}), (caTQ, {}), (caTR, {}), (caTS, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:45.034756 UTC

sat_saxS_entry() //  [R3, R2, R1]
        { info_tbl: [(caTP,
                      label: sat_saxS_info
                      rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caTP:
          goto caTR;
      caTR:
          if (HpLim == 0) goto caTQ; else goto caTS;
      caTQ:
          R3 = R3;
          R2 = R2;
          R1 = R1;
          call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
      caTS:
          R4 = R3;
          R3 = R2;
          R2 = P64[R1 + 6];
          call SkipList.$fEqTArray2_info(R4, R3, R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:45.035711 UTC

sat_saxS_entry() //  [R3, R2, R1]
        { info_tbl: [(caTP,
                      label: sat_saxS_info
                      rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caTP:
          if (HpLim == 0) goto caTQ; else goto caTS;
      caTQ:
          R3 = R3;
          R2 = R2;
          R1 = R1;
          call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
      caTS:
          R4 = R3;
          R3 = R2;
          R2 = P64[R1 + 6];
          call SkipList.$fEqTArray2_info(R4, R3, R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:45.036664 UTC

{offset
  caTU:
      _saxR::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto caTV; else goto caTW;
  caTW:
      Hp = Hp + 56;
      if (Hp > HpLim) goto caTY; else goto caTX;
  caTY:
      HpAlloc = 56;
      goto caTV;
  caTV:
      R2 = _saxR::P64;
      R1 = SkipList.$fEqTArray_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  caTX:
      I64[Hp - 48] = sat_saxT_info;
      P64[Hp - 40] = _saxR::P64;
      _caTB::P64 = Hp - 46;
      I64[Hp - 32] = sat_saxS_info;
      P64[Hp - 24] = _saxR::P64;
      _caTK::P64 = Hp - 30;
      I64[Hp - 16] = GHC.Classes.D:Eq_con_info;
      P64[Hp - 8] = _caTK::P64;
      P64[Hp] = _caTB::P64;
      _caTT::P64 = Hp - 15;
      R1 = _caTT::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:45.038036 UTC

{offset
  caTU:
      _saxR::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto caTV; else goto caTW;
  caTW:
      Hp = Hp + 56;
      if (Hp > HpLim) goto caTY; else goto caTX;
  caTY:
      HpAlloc = 56;
      goto caTV;
  caTV:
      R2 = _saxR::P64;
      R1 = SkipList.$fEqTArray_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  caTX:
      I64[Hp - 48] = sat_saxT_info;
      P64[Hp - 40] = _saxR::P64;
      _caTB::P64 = Hp - 46;
      I64[Hp - 32] = sat_saxS_info;
      P64[Hp - 24] = _saxR::P64;
      _caTK::P64 = Hp - 30;
      I64[Hp - 16] = GHC.Classes.D:Eq_con_info;
      P64[Hp - 8] = _caTK::P64;
      P64[Hp] = _caTB::P64;
      _caTT::P64 = Hp - 15;
      R1 = _caTT::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:45.039362 UTC

{offset
  caTU:
      _saxR::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto caTV; else goto caTW;
  caTW:
      Hp = Hp + 56;
      if (Hp > HpLim) goto caTY; else goto caTX;
  caTY:
      HpAlloc = 56;
      goto caTV;
  caTV:
      R2 = _saxR::P64;
      R1 = SkipList.$fEqTArray_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  caTX:
      I64[Hp - 48] = sat_saxT_info;
      P64[Hp - 40] = _saxR::P64;
      _caTB::P64 = Hp - 46;
      I64[Hp - 32] = sat_saxS_info;
      P64[Hp - 24] = _saxR::P64;
      _caTK::P64 = Hp - 30;
      I64[Hp - 16] = GHC.Classes.D:Eq_con_info;
      P64[Hp - 8] = _caTK::P64;
      P64[Hp] = _caTB::P64;
      _caTT::P64 = Hp - 15;
      R1 = _caTT::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:45.040712 UTC

{offset
  caTU:
      _saxR::P64 = R2;
      goto caTW;
  caTW:
      Hp = Hp + 56;
      if (Hp > HpLim) goto caTY; else goto caTX;
  caTY:
      HpAlloc = 56;
      goto caTV;
  caTV:
      R2 = _saxR::P64;
      R1 = SkipList.$fEqTArray_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  caTX:
      I64[Hp - 48] = sat_saxT_info;
      P64[Hp - 40] = _saxR::P64;
      _caTB::P64 = Hp - 46;
      I64[Hp - 32] = sat_saxS_info;
      P64[Hp - 24] = _saxR::P64;
      _caTK::P64 = Hp - 30;
      I64[Hp - 16] = GHC.Classes.D:Eq_con_info;
      P64[Hp - 8] = _caTK::P64;
      P64[Hp] = _caTB::P64;
      _caTT::P64 = Hp - 15;
      R1 = _caTT::P64;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:45.041928 UTC

{offset
  caTU:
      goto caTW;
  caTW:
      Hp = Hp + 56;
      if (Hp > HpLim) goto caTY; else goto caTX;
  caTY:
      HpAlloc = 56;
      goto caTV;
  caTV:
      R2 = R2;
      R1 = SkipList.$fEqTArray_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  caTX:
      I64[Hp - 48] = sat_saxT_info;
      P64[Hp - 40] = R2;
      I64[Hp - 32] = sat_saxS_info;
      P64[Hp - 24] = R2;
      I64[Hp - 16] = GHC.Classes.D:Eq_con_info;
      P64[Hp - 8] = Hp - 30;
      P64[Hp] = Hp - 46;
      R1 = Hp - 15;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:45.043225 UTC

[(caTU, {sat_saxS_closure, sat_saxT_closure}), (caTV, {}),
 (caTW, {sat_saxS_closure, sat_saxT_closure}),
 (caTX, {sat_saxS_closure, sat_saxT_closure}), (caTY, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:45.043745 UTC

SkipList.$fEqTArray_entry() //  [R2]
        { info_tbl: [(caTU,
                      label: SkipList.$fEqTArray_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caTU:
          goto caTW;
      caTW:
          Hp = Hp + 56;
          if (Hp > HpLim) goto caTY; else goto caTX;
      caTY:
          HpAlloc = 56;
          goto caTV;
      caTV:
          R2 = R2;
          R1 = SkipList.$fEqTArray_closure;
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
      caTX:
          I64[Hp - 48] = sat_saxT_info;
          P64[Hp - 40] = R2;
          I64[Hp - 32] = sat_saxS_info;
          P64[Hp - 24] = R2;
          I64[Hp - 16] = GHC.Classes.D:Eq_con_info;
          P64[Hp - 8] = Hp - 30;
          P64[Hp] = Hp - 46;
          R1 = Hp - 15;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:45.045064 UTC

SkipList.$fEqTArray_entry() //  [R2]
        { info_tbl: [(caTU,
                      label: SkipList.$fEqTArray_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caTU:
          Hp = Hp + 56;
          if (Hp > HpLim) goto caTY; else goto caTX;
      caTY:
          HpAlloc = 56;
          R2 = R2;
          R1 = SkipList.$fEqTArray_closure;
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
      caTX:
          I64[Hp - 48] = sat_saxT_info;
          P64[Hp - 40] = R2;
          I64[Hp - 32] = sat_saxS_info;
          P64[Hp - 24] = R2;
          I64[Hp - 16] = GHC.Classes.D:Eq_con_info;
          P64[Hp - 8] = Hp - 30;
          P64[Hp] = Hp - 46;
          R1 = Hp - 15;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:45.046347 UTC

[section "data" {
     SkipList.$fEqTArray_closure:
         const SkipList.$fEqTArray_info;
 },
 sat_saxT_entry() //  [R3, R2, R1]
         { info_tbl: [(caTG,
                       label: sat_saxT_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caTG:
           if (HpLim == 0) goto caTH; else goto caTJ;
       caTH:
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caTJ:
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call SkipList.$fEqTArray1_info(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_saxS_entry() //  [R3, R2, R1]
         { info_tbl: [(caTP,
                       label: sat_saxS_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caTP:
           if (HpLim == 0) goto caTQ; else goto caTS;
       caTQ:
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caTS:
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call SkipList.$fEqTArray2_info(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 SkipList.$fEqTArray_entry() //  [R2]
         { info_tbl: [(caTU,
                       label: SkipList.$fEqTArray_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caTU:
           Hp = Hp + 56;
           if (Hp > HpLim) goto caTY; else goto caTX;
       caTY:
           HpAlloc = 56;
           R2 = R2;
           R1 = SkipList.$fEqTArray_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caTX:
           I64[Hp - 48] = sat_saxT_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_saxS_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Classes.D:Eq_con_info;
           P64[Hp - 8] = Hp - 30;
           P64[Hp] = Hp - 46;
           R1 = Hp - 15;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:45.049402 UTC

[section "data" {
     SkipList.$fEqTArray_closure:
         const SkipList.$fEqTArray_info;
 },
 sat_saxT_entry() //  [R3, R2, R1]
         { info_tbl: [(caTG,
                       label: sat_saxT_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caTG:
           if (HpLim == 0) goto caTH; else goto caTJ;
       caTH:
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caTJ:
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call SkipList.$fEqTArray1_info(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_saxS_entry() //  [R3, R2, R1]
         { info_tbl: [(caTP,
                       label: sat_saxS_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caTP:
           if (HpLim == 0) goto caTQ; else goto caTS;
       caTQ:
           R3 = R3;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caTS:
           R4 = R3;
           R3 = R2;
           R2 = P64[R1 + 6];
           call SkipList.$fEqTArray2_info(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 SkipList.$fEqTArray_entry() //  [R2]
         { info_tbl: [(caTU,
                       label: SkipList.$fEqTArray_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caTU:
           Hp = Hp + 56;
           if (Hp > HpLim) goto caTY; else goto caTX;
       caTY:
           HpAlloc = 56;
           R2 = R2;
           R1 = SkipList.$fEqTArray_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       caTX:
           I64[Hp - 48] = sat_saxT_info;
           P64[Hp - 40] = R2;
           I64[Hp - 32] = sat_saxS_info;
           P64[Hp - 24] = R2;
           I64[Hp - 16] = GHC.Classes.D:Eq_con_info;
           P64[Hp - 8] = Hp - 30;
           P64[Hp] = Hp - 46;
           R1 = Hp - 15;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:45.056739 UTC

[section "data" {
     lvl7_raw1_closure:
         const lvl7_raw1_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     caUf_str:
         I8[] [101,114,114,111,114]
 },
 lvl7_raw1_entry() //  [R1]
         { info_tbl: [(caUg,
                       label: lvl7_raw1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caUg:
           _raw1::P64 = R1;
           goto caUa;
       caUa:
           if ((old + 0) - <highSp> < SpLim) goto caUh; else goto caUi;
       caUi:
           if (HpLim == 0) goto caUh; else goto caUj;
       caUh:
           R1 = _raw1::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caUj:
           (_caUc::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _raw1::P64);
           if (_caUc::I64 == 0) goto caUe; else goto caUd;
       caUe:
           call (I64[_raw1::P64])() args: 8, res: 0, upd: 8;
       caUd:
           I64[(old + 24)] = stg_bh_upd_frame_info;
           I64[(old + 16)] = _caUc::I64;
           R2 = caUf_str;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:45.059384 UTC

{offset
  caUg:
      _raw1::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto caUh; else goto caUi;
  caUi:
      if (HpLim == 0) goto caUh; else goto caUj;
  caUh:
      R1 = _raw1::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caUj:
      (_caUc::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _raw1::P64);
      if (_caUc::I64 == 0) goto caUe; else goto caUd;
  caUe:
      call (I64[_raw1::P64])() args: 8, res: 0, upd: 8;
  caUd:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _caUc::I64;
      R2 = caUf_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:45.060476 UTC

{offset
  caUg:
      _raw1::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto caUh; else goto caUi;
  caUi:
      if (HpLim == 0) goto caUh; else goto caUj;
  caUh:
      R1 = _raw1::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caUj:
      (_caUc::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _raw1::P64);
      if (_caUc::I64 == 0) goto caUe; else goto caUd;
  caUe:
      call (I64[_raw1::P64])() args: 8, res: 0, upd: 8;
  caUd:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _caUc::I64;
      R2 = caUf_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:45.061575 UTC

{offset
  caUg:
      _raw1::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto caUh; else goto caUi;
  caUi:
      if (HpLim == 0) goto caUh; else goto caUj;
  caUh:
      R1 = _raw1::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caUj:
      (_caUc::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _raw1::P64);
      if (_caUc::I64 == 0) goto caUe; else goto caUd;
  caUe:
      call (I64[_raw1::P64])() args: 8, res: 0, upd: 8;
  caUd:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _caUc::I64;
      R2 = caUf_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:45.062736 UTC

{offset
  caUg:
      _raw1::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto caUh; else goto caUi;
  caUi:
      if (HpLim == 0) goto caUh; else goto caUj;
  caUh:
      R1 = _raw1::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caUj:
      (_caUc::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _raw1::P64);
      if (_caUc::I64 == 0) goto caUe; else goto caUd;
  caUe:
      call (I64[_raw1::P64])() args: 8, res: 0, upd: 8;
  caUd:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _caUc::I64;
      R2 = caUf_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:45.063855 UTC

{offset
  caUg:
      _raw1::P64 = R1;
      if ((Sp + -16) < SpLim) goto caUh; else goto caUi;
  caUi:
      if (HpLim == 0) goto caUh; else goto caUj;
  caUh:
      R1 = _raw1::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caUj:
      (_caUc::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _raw1::P64);
      if (_caUc::I64 == 0) goto caUe; else goto caUd;
  caUe:
      call (I64[_raw1::P64])() args: 8, res: 0, upd: 8;
  caUd:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _caUc::I64;
      R2 = caUf_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:45.065142 UTC

[(caUd, {}), (caUe, {}), (caUg, {}), (caUh, {}), (caUi, {}),
 (caUj, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:45.065522 UTC

lvl7_raw1_entry() //  [R1]
        { info_tbl: [(caUg,
                      label: lvl7_raw1_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caUg:
          _raw1::P64 = R1;
          if ((Sp + -16) < SpLim) goto caUh; else goto caUi;
      caUi:
          if (HpLim == 0) goto caUh; else goto caUj;
      caUh:
          R1 = _raw1::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      caUj:
          (_caUc::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _raw1::P64);
          if (_caUc::I64 == 0) goto caUe; else goto caUd;
      caUe:
          call (I64[_raw1::P64])() args: 8, res: 0, upd: 8;
      caUd:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _caUc::I64;
          R2 = caUf_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:45.066865 UTC

lvl7_raw1_entry() //  [R1]
        { info_tbl: [(caUg,
                      label: lvl7_raw1_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caUg:
          _raw1::P64 = R1;
          if ((Sp + -16) < SpLim) goto caUh; else goto caUi;
      caUi:
          if (HpLim == 0) goto caUh; else goto caUj;
      caUh:
          R1 = _raw1::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      caUj:
          (_caUc::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _raw1::P64);
          if (_caUc::I64 == 0) goto caUe; else goto caUd;
      caUe:
          call (I64[_raw1::P64])() args: 8, res: 0, upd: 8;
      caUd:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _caUc::I64;
          R2 = caUf_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:45.068274 UTC

[section "data" {
     lvl7_raw1_closure:
         const lvl7_raw1_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     caUf_str:
         I8[] [101,114,114,111,114]
 },
 lvl7_raw1_entry() //  [R1]
         { info_tbl: [(caUg,
                       label: lvl7_raw1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caUg:
           _raw1::P64 = R1;
           if ((Sp + -16) < SpLim) goto caUh; else goto caUi;
       caUi:
           if (HpLim == 0) goto caUh; else goto caUj;
       caUh:
           R1 = _raw1::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caUj:
           (_caUc::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _raw1::P64);
           if (_caUc::I64 == 0) goto caUe; else goto caUd;
       caUe:
           call (I64[_raw1::P64])() args: 8, res: 0, upd: 8;
       caUd:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caUc::I64;
           R2 = caUf_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:45.070005 UTC

[section "data" {
     lvl7_raw1_closure:
         const lvl7_raw1_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     caUf_str:
         I8[] [101,114,114,111,114]
 },
 lvl7_raw1_entry() //  [R1]
         { info_tbl: [(caUg,
                       label: lvl7_raw1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caUg:
           _raw1::P64 = R1;
           if ((Sp + -16) < SpLim) goto caUh; else goto caUi;
       caUi:
           if (HpLim == 0) goto caUh; else goto caUj;
       caUh:
           R1 = _raw1::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caUj:
           (_caUc::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _raw1::P64);
           if (_caUc::I64 == 0) goto caUe; else goto caUd;
       caUe:
           call (I64[_raw1::P64])() args: 8, res: 0, upd: 8;
       caUd:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caUc::I64;
           R2 = caUf_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:45.074627 UTC

[section "data" {
     lvl8_raw2_closure:
         const lvl8_raw2_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     caUw_str:
         I8[] [97,114,114,97,121,45,48,46,53,46,49,46,48]
 },
 lvl8_raw2_entry() //  [R1]
         { info_tbl: [(caUx,
                       label: lvl8_raw2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caUx:
           _raw2::P64 = R1;
           goto caUr;
       caUr:
           if ((old + 0) - <highSp> < SpLim) goto caUy; else goto caUz;
       caUz:
           if (HpLim == 0) goto caUy; else goto caUA;
       caUy:
           R1 = _raw2::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caUA:
           (_caUt::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _raw2::P64);
           if (_caUt::I64 == 0) goto caUv; else goto caUu;
       caUv:
           call (I64[_raw2::P64])() args: 8, res: 0, upd: 8;
       caUu:
           I64[(old + 24)] = stg_bh_upd_frame_info;
           I64[(old + 16)] = _caUt::I64;
           R2 = caUw_str;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:45.076747 UTC

{offset
  caUx:
      _raw2::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto caUy; else goto caUz;
  caUz:
      if (HpLim == 0) goto caUy; else goto caUA;
  caUy:
      R1 = _raw2::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caUA:
      (_caUt::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _raw2::P64);
      if (_caUt::I64 == 0) goto caUv; else goto caUu;
  caUv:
      call (I64[_raw2::P64])() args: 8, res: 0, upd: 8;
  caUu:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _caUt::I64;
      R2 = caUw_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:45.077889 UTC

{offset
  caUx:
      _raw2::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto caUy; else goto caUz;
  caUz:
      if (HpLim == 0) goto caUy; else goto caUA;
  caUy:
      R1 = _raw2::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caUA:
      (_caUt::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _raw2::P64);
      if (_caUt::I64 == 0) goto caUv; else goto caUu;
  caUv:
      call (I64[_raw2::P64])() args: 8, res: 0, upd: 8;
  caUu:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _caUt::I64;
      R2 = caUw_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:45.079009 UTC

{offset
  caUx:
      _raw2::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto caUy; else goto caUz;
  caUz:
      if (HpLim == 0) goto caUy; else goto caUA;
  caUy:
      R1 = _raw2::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caUA:
      (_caUt::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _raw2::P64);
      if (_caUt::I64 == 0) goto caUv; else goto caUu;
  caUv:
      call (I64[_raw2::P64])() args: 8, res: 0, upd: 8;
  caUu:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _caUt::I64;
      R2 = caUw_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:45.080156 UTC

{offset
  caUx:
      _raw2::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto caUy; else goto caUz;
  caUz:
      if (HpLim == 0) goto caUy; else goto caUA;
  caUy:
      R1 = _raw2::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caUA:
      (_caUt::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _raw2::P64);
      if (_caUt::I64 == 0) goto caUv; else goto caUu;
  caUv:
      call (I64[_raw2::P64])() args: 8, res: 0, upd: 8;
  caUu:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _caUt::I64;
      R2 = caUw_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:45.081283 UTC

{offset
  caUx:
      _raw2::P64 = R1;
      if ((Sp + -16) < SpLim) goto caUy; else goto caUz;
  caUz:
      if (HpLim == 0) goto caUy; else goto caUA;
  caUy:
      R1 = _raw2::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caUA:
      (_caUt::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _raw2::P64);
      if (_caUt::I64 == 0) goto caUv; else goto caUu;
  caUv:
      call (I64[_raw2::P64])() args: 8, res: 0, upd: 8;
  caUu:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _caUt::I64;
      R2 = caUw_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:45.08258 UTC

[(caUu, {}), (caUv, {}), (caUx, {}), (caUy, {}), (caUz, {}),
 (caUA, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:45.082962 UTC

lvl8_raw2_entry() //  [R1]
        { info_tbl: [(caUx,
                      label: lvl8_raw2_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caUx:
          _raw2::P64 = R1;
          if ((Sp + -16) < SpLim) goto caUy; else goto caUz;
      caUz:
          if (HpLim == 0) goto caUy; else goto caUA;
      caUy:
          R1 = _raw2::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      caUA:
          (_caUt::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _raw2::P64);
          if (_caUt::I64 == 0) goto caUv; else goto caUu;
      caUv:
          call (I64[_raw2::P64])() args: 8, res: 0, upd: 8;
      caUu:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _caUt::I64;
          R2 = caUw_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:45.084344 UTC

lvl8_raw2_entry() //  [R1]
        { info_tbl: [(caUx,
                      label: lvl8_raw2_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caUx:
          _raw2::P64 = R1;
          if ((Sp + -16) < SpLim) goto caUy; else goto caUz;
      caUz:
          if (HpLim == 0) goto caUy; else goto caUA;
      caUy:
          R1 = _raw2::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      caUA:
          (_caUt::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _raw2::P64);
          if (_caUt::I64 == 0) goto caUv; else goto caUu;
      caUv:
          call (I64[_raw2::P64])() args: 8, res: 0, upd: 8;
      caUu:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _caUt::I64;
          R2 = caUw_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:45.085736 UTC

[section "data" {
     lvl8_raw2_closure:
         const lvl8_raw2_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     caUw_str:
         I8[] [97,114,114,97,121,45,48,46,53,46,49,46,48]
 },
 lvl8_raw2_entry() //  [R1]
         { info_tbl: [(caUx,
                       label: lvl8_raw2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caUx:
           _raw2::P64 = R1;
           if ((Sp + -16) < SpLim) goto caUy; else goto caUz;
       caUz:
           if (HpLim == 0) goto caUy; else goto caUA;
       caUy:
           R1 = _raw2::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caUA:
           (_caUt::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _raw2::P64);
           if (_caUt::I64 == 0) goto caUv; else goto caUu;
       caUv:
           call (I64[_raw2::P64])() args: 8, res: 0, upd: 8;
       caUu:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caUt::I64;
           R2 = caUw_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:45.087484 UTC

[section "data" {
     lvl8_raw2_closure:
         const lvl8_raw2_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     caUw_str:
         I8[] [97,114,114,97,121,45,48,46,53,46,49,46,48]
 },
 lvl8_raw2_entry() //  [R1]
         { info_tbl: [(caUx,
                       label: lvl8_raw2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caUx:
           _raw2::P64 = R1;
           if ((Sp + -16) < SpLim) goto caUy; else goto caUz;
       caUz:
           if (HpLim == 0) goto caUy; else goto caUA;
       caUy:
           R1 = _raw2::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caUA:
           (_caUt::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _raw2::P64);
           if (_caUt::I64 == 0) goto caUv; else goto caUu;
       caUv:
           call (I64[_raw2::P64])() args: 8, res: 0, upd: 8;
       caUu:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caUt::I64;
           R2 = caUw_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:45.092087 UTC

[section "data" {
     lvl9_raw3_closure:
         const lvl9_raw3_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     caUN_str:
         I8[] [68,97,116,97,46,65,114,114,97,121,46,66,97,115,101]
 },
 lvl9_raw3_entry() //  [R1]
         { info_tbl: [(caUO,
                       label: lvl9_raw3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caUO:
           _raw3::P64 = R1;
           goto caUI;
       caUI:
           if ((old + 0) - <highSp> < SpLim) goto caUP; else goto caUQ;
       caUQ:
           if (HpLim == 0) goto caUP; else goto caUR;
       caUP:
           R1 = _raw3::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caUR:
           (_caUK::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _raw3::P64);
           if (_caUK::I64 == 0) goto caUM; else goto caUL;
       caUM:
           call (I64[_raw3::P64])() args: 8, res: 0, upd: 8;
       caUL:
           I64[(old + 24)] = stg_bh_upd_frame_info;
           I64[(old + 16)] = _caUK::I64;
           R2 = caUN_str;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:45.094803 UTC

{offset
  caUO:
      _raw3::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto caUP; else goto caUQ;
  caUQ:
      if (HpLim == 0) goto caUP; else goto caUR;
  caUP:
      R1 = _raw3::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caUR:
      (_caUK::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _raw3::P64);
      if (_caUK::I64 == 0) goto caUM; else goto caUL;
  caUM:
      call (I64[_raw3::P64])() args: 8, res: 0, upd: 8;
  caUL:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _caUK::I64;
      R2 = caUN_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:45.095896 UTC

{offset
  caUO:
      _raw3::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto caUP; else goto caUQ;
  caUQ:
      if (HpLim == 0) goto caUP; else goto caUR;
  caUP:
      R1 = _raw3::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caUR:
      (_caUK::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _raw3::P64);
      if (_caUK::I64 == 0) goto caUM; else goto caUL;
  caUM:
      call (I64[_raw3::P64])() args: 8, res: 0, upd: 8;
  caUL:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _caUK::I64;
      R2 = caUN_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:45.09701 UTC

{offset
  caUO:
      _raw3::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto caUP; else goto caUQ;
  caUQ:
      if (HpLim == 0) goto caUP; else goto caUR;
  caUP:
      R1 = _raw3::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caUR:
      (_caUK::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _raw3::P64);
      if (_caUK::I64 == 0) goto caUM; else goto caUL;
  caUM:
      call (I64[_raw3::P64])() args: 8, res: 0, upd: 8;
  caUL:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _caUK::I64;
      R2 = caUN_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:45.098155 UTC

{offset
  caUO:
      _raw3::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto caUP; else goto caUQ;
  caUQ:
      if (HpLim == 0) goto caUP; else goto caUR;
  caUP:
      R1 = _raw3::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caUR:
      (_caUK::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _raw3::P64);
      if (_caUK::I64 == 0) goto caUM; else goto caUL;
  caUM:
      call (I64[_raw3::P64])() args: 8, res: 0, upd: 8;
  caUL:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _caUK::I64;
      R2 = caUN_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:45.099305 UTC

{offset
  caUO:
      _raw3::P64 = R1;
      if ((Sp + -16) < SpLim) goto caUP; else goto caUQ;
  caUQ:
      if (HpLim == 0) goto caUP; else goto caUR;
  caUP:
      R1 = _raw3::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caUR:
      (_caUK::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _raw3::P64);
      if (_caUK::I64 == 0) goto caUM; else goto caUL;
  caUM:
      call (I64[_raw3::P64])() args: 8, res: 0, upd: 8;
  caUL:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _caUK::I64;
      R2 = caUN_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:45.100562 UTC

[(caUL, {}), (caUM, {}), (caUO, {}), (caUP, {}), (caUQ, {}),
 (caUR, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:45.100937 UTC

lvl9_raw3_entry() //  [R1]
        { info_tbl: [(caUO,
                      label: lvl9_raw3_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caUO:
          _raw3::P64 = R1;
          if ((Sp + -16) < SpLim) goto caUP; else goto caUQ;
      caUQ:
          if (HpLim == 0) goto caUP; else goto caUR;
      caUP:
          R1 = _raw3::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      caUR:
          (_caUK::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _raw3::P64);
          if (_caUK::I64 == 0) goto caUM; else goto caUL;
      caUM:
          call (I64[_raw3::P64])() args: 8, res: 0, upd: 8;
      caUL:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _caUK::I64;
          R2 = caUN_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:45.102295 UTC

lvl9_raw3_entry() //  [R1]
        { info_tbl: [(caUO,
                      label: lvl9_raw3_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caUO:
          _raw3::P64 = R1;
          if ((Sp + -16) < SpLim) goto caUP; else goto caUQ;
      caUQ:
          if (HpLim == 0) goto caUP; else goto caUR;
      caUP:
          R1 = _raw3::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      caUR:
          (_caUK::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _raw3::P64);
          if (_caUK::I64 == 0) goto caUM; else goto caUL;
      caUM:
          call (I64[_raw3::P64])() args: 8, res: 0, upd: 8;
      caUL:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _caUK::I64;
          R2 = caUN_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:45.103708 UTC

[section "data" {
     lvl9_raw3_closure:
         const lvl9_raw3_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     caUN_str:
         I8[] [68,97,116,97,46,65,114,114,97,121,46,66,97,115,101]
 },
 lvl9_raw3_entry() //  [R1]
         { info_tbl: [(caUO,
                       label: lvl9_raw3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caUO:
           _raw3::P64 = R1;
           if ((Sp + -16) < SpLim) goto caUP; else goto caUQ;
       caUQ:
           if (HpLim == 0) goto caUP; else goto caUR;
       caUP:
           R1 = _raw3::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caUR:
           (_caUK::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _raw3::P64);
           if (_caUK::I64 == 0) goto caUM; else goto caUL;
       caUM:
           call (I64[_raw3::P64])() args: 8, res: 0, upd: 8;
       caUL:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caUK::I64;
           R2 = caUN_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:45.105427 UTC

[section "data" {
     lvl9_raw3_closure:
         const lvl9_raw3_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     caUN_str:
         I8[] [68,97,116,97,46,65,114,114,97,121,46,66,97,115,101]
 },
 lvl9_raw3_entry() //  [R1]
         { info_tbl: [(caUO,
                       label: lvl9_raw3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caUO:
           _raw3::P64 = R1;
           if ((Sp + -16) < SpLim) goto caUP; else goto caUQ;
       caUQ:
           if (HpLim == 0) goto caUP; else goto caUR;
       caUP:
           R1 = _raw3::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caUR:
           (_caUK::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _raw3::P64);
           if (_caUK::I64 == 0) goto caUM; else goto caUL;
       caUM:
           call (I64[_raw3::P64])() args: 8, res: 0, upd: 8;
       caUL:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caUK::I64;
           R2 = caUN_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:45.110029 UTC

[section "data" {
     lvl10_raw4_closure:
         const lvl10_raw4_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     caV4_str:
         I8[] [108,105,98,114,97,114,105,101,115,47,97,114,114,97,121,47,68,97,116,97,47,65,114,114,97,121,47,66,97,115,101,46,104,115]
 },
 lvl10_raw4_entry() //  [R1]
         { info_tbl: [(caV5,
                       label: lvl10_raw4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caV5:
           _raw4::P64 = R1;
           goto caUZ;
       caUZ:
           if ((old + 0) - <highSp> < SpLim) goto caV6; else goto caV7;
       caV7:
           if (HpLim == 0) goto caV6; else goto caV8;
       caV6:
           R1 = _raw4::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caV8:
           (_caV1::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _raw4::P64);
           if (_caV1::I64 == 0) goto caV3; else goto caV2;
       caV3:
           call (I64[_raw4::P64])() args: 8, res: 0, upd: 8;
       caV2:
           I64[(old + 24)] = stg_bh_upd_frame_info;
           I64[(old + 16)] = _caV1::I64;
           R2 = caV4_str;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:45.112125 UTC

{offset
  caV5:
      _raw4::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto caV6; else goto caV7;
  caV7:
      if (HpLim == 0) goto caV6; else goto caV8;
  caV6:
      R1 = _raw4::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caV8:
      (_caV1::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _raw4::P64);
      if (_caV1::I64 == 0) goto caV3; else goto caV2;
  caV3:
      call (I64[_raw4::P64])() args: 8, res: 0, upd: 8;
  caV2:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _caV1::I64;
      R2 = caV4_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:45.113264 UTC

{offset
  caV5:
      _raw4::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto caV6; else goto caV7;
  caV7:
      if (HpLim == 0) goto caV6; else goto caV8;
  caV6:
      R1 = _raw4::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caV8:
      (_caV1::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _raw4::P64);
      if (_caV1::I64 == 0) goto caV3; else goto caV2;
  caV3:
      call (I64[_raw4::P64])() args: 8, res: 0, upd: 8;
  caV2:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _caV1::I64;
      R2 = caV4_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:45.114378 UTC

{offset
  caV5:
      _raw4::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto caV6; else goto caV7;
  caV7:
      if (HpLim == 0) goto caV6; else goto caV8;
  caV6:
      R1 = _raw4::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caV8:
      (_caV1::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _raw4::P64);
      if (_caV1::I64 == 0) goto caV3; else goto caV2;
  caV3:
      call (I64[_raw4::P64])() args: 8, res: 0, upd: 8;
  caV2:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _caV1::I64;
      R2 = caV4_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:45.115539 UTC

{offset
  caV5:
      _raw4::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto caV6; else goto caV7;
  caV7:
      if (HpLim == 0) goto caV6; else goto caV8;
  caV6:
      R1 = _raw4::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caV8:
      (_caV1::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _raw4::P64);
      if (_caV1::I64 == 0) goto caV3; else goto caV2;
  caV3:
      call (I64[_raw4::P64])() args: 8, res: 0, upd: 8;
  caV2:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _caV1::I64;
      R2 = caV4_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:45.116665 UTC

{offset
  caV5:
      _raw4::P64 = R1;
      if ((Sp + -16) < SpLim) goto caV6; else goto caV7;
  caV7:
      if (HpLim == 0) goto caV6; else goto caV8;
  caV6:
      R1 = _raw4::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caV8:
      (_caV1::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _raw4::P64);
      if (_caV1::I64 == 0) goto caV3; else goto caV2;
  caV3:
      call (I64[_raw4::P64])() args: 8, res: 0, upd: 8;
  caV2:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _caV1::I64;
      R2 = caV4_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:45.117989 UTC

[(caV2, {}), (caV3, {}), (caV5, {}), (caV6, {}), (caV7, {}),
 (caV8, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:45.118382 UTC

lvl10_raw4_entry() //  [R1]
        { info_tbl: [(caV5,
                      label: lvl10_raw4_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caV5:
          _raw4::P64 = R1;
          if ((Sp + -16) < SpLim) goto caV6; else goto caV7;
      caV7:
          if (HpLim == 0) goto caV6; else goto caV8;
      caV6:
          R1 = _raw4::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      caV8:
          (_caV1::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _raw4::P64);
          if (_caV1::I64 == 0) goto caV3; else goto caV2;
      caV3:
          call (I64[_raw4::P64])() args: 8, res: 0, upd: 8;
      caV2:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _caV1::I64;
          R2 = caV4_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:45.11974 UTC

lvl10_raw4_entry() //  [R1]
        { info_tbl: [(caV5,
                      label: lvl10_raw4_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caV5:
          _raw4::P64 = R1;
          if ((Sp + -16) < SpLim) goto caV6; else goto caV7;
      caV7:
          if (HpLim == 0) goto caV6; else goto caV8;
      caV6:
          R1 = _raw4::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      caV8:
          (_caV1::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _raw4::P64);
          if (_caV1::I64 == 0) goto caV3; else goto caV2;
      caV3:
          call (I64[_raw4::P64])() args: 8, res: 0, upd: 8;
      caV2:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _caV1::I64;
          R2 = caV4_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:45.12113 UTC

[section "data" {
     lvl10_raw4_closure:
         const lvl10_raw4_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     caV4_str:
         I8[] [108,105,98,114,97,114,105,101,115,47,97,114,114,97,121,47,68,97,116,97,47,65,114,114,97,121,47,66,97,115,101,46,104,115]
 },
 lvl10_raw4_entry() //  [R1]
         { info_tbl: [(caV5,
                       label: lvl10_raw4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caV5:
           _raw4::P64 = R1;
           if ((Sp + -16) < SpLim) goto caV6; else goto caV7;
       caV7:
           if (HpLim == 0) goto caV6; else goto caV8;
       caV6:
           R1 = _raw4::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caV8:
           (_caV1::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _raw4::P64);
           if (_caV1::I64 == 0) goto caV3; else goto caV2;
       caV3:
           call (I64[_raw4::P64])() args: 8, res: 0, upd: 8;
       caV2:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caV1::I64;
           R2 = caV4_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:45.122882 UTC

[section "data" {
     lvl10_raw4_closure:
         const lvl10_raw4_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     caV4_str:
         I8[] [108,105,98,114,97,114,105,101,115,47,97,114,114,97,121,47,68,97,116,97,47,65,114,114,97,121,47,66,97,115,101,46,104,115]
 },
 lvl10_raw4_entry() //  [R1]
         { info_tbl: [(caV5,
                       label: lvl10_raw4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caV5:
           _raw4::P64 = R1;
           if ((Sp + -16) < SpLim) goto caV6; else goto caV7;
       caV7:
           if (HpLim == 0) goto caV6; else goto caV8;
       caV6:
           R1 = _raw4::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caV8:
           (_caV1::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _raw4::P64);
           if (_caV1::I64 == 0) goto caV3; else goto caV2;
       caV3:
           call (I64[_raw4::P64])() args: 8, res: 0, upd: 8;
       caV2:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caV1::I64;
           R2 = caV4_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:45.128162 UTC

[section "data" {
     lvl11_raw5_closure:
         const GHC.Types.I#_static_info;
         const 79;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:45.128565 UTC

[section "data" {
     lvl11_raw5_closure:
         const GHC.Types.I#_static_info;
         const 79;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:45.12888 UTC

[section "data" {
     lvl11_raw5_closure:
         const GHC.Types.I#_static_info;
         const 79;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:45.129432 UTC

[section "data" {
     lvl12_raw6_closure:
         const GHC.Types.I#_static_info;
         const 40;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:45.129779 UTC

[section "data" {
     lvl12_raw6_closure:
         const GHC.Types.I#_static_info;
         const 40;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:45.130085 UTC

[section "data" {
     lvl12_raw6_closure:
         const GHC.Types.I#_static_info;
         const 40;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:45.130632 UTC

[section "data" {
     lvl13_raw7_closure:
         const GHC.Types.I#_static_info;
         const 45;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:45.130975 UTC

[section "data" {
     lvl13_raw7_closure:
         const GHC.Types.I#_static_info;
         const 45;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:45.131279 UTC

[section "data" {
     lvl13_raw7_closure:
         const GHC.Types.I#_static_info;
         const 45;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:45.131927 UTC

[section "data" {
     lvl14_raw8_closure:
         const GHC.Stack.Types.SrcLoc_static_info;
         const lvl8_raw2_closure;
         const lvl9_raw3_closure;
         const lvl10_raw4_closure;
         const lvl11_raw5_closure+1;
         const lvl12_raw6_closure+1;
         const lvl11_raw5_closure+1;
         const lvl13_raw7_closure+1;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:45.132631 UTC

[section "data" {
     lvl14_raw8_closure:
         const GHC.Stack.Types.SrcLoc_static_info;
         const lvl8_raw2_closure;
         const lvl9_raw3_closure;
         const lvl10_raw4_closure;
         const lvl11_raw5_closure+1;
         const lvl12_raw6_closure+1;
         const lvl11_raw5_closure+1;
         const lvl13_raw7_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:45.133187 UTC

[section "data" {
     lvl14_raw8_closure:
         const GHC.Stack.Types.SrcLoc_static_info;
         const lvl8_raw2_closure;
         const lvl9_raw3_closure;
         const lvl10_raw4_closure;
         const lvl11_raw5_closure+1;
         const lvl12_raw6_closure+1;
         const lvl11_raw5_closure+1;
         const lvl13_raw7_closure+1;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:45.134224 UTC

[section "data" {
     lvl15_raw9_closure:
         const (,)_static_info;
         const lvl7_raw1_closure;
         const lvl14_raw8_closure+1;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:45.134641 UTC

[section "data" {
     lvl15_raw9_closure:
         const (,)_static_info;
         const lvl7_raw1_closure;
         const lvl14_raw8_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:45.135011 UTC

[section "data" {
     lvl15_raw9_closure:
         const (,)_static_info;
         const lvl7_raw1_closure;
         const lvl14_raw8_closure+1;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:45.135723 UTC

[section "data" {
     lvl16_rawa_closure:
         const :_static_info;
         const lvl15_raw9_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:45.136142 UTC

[section "data" {
     lvl16_rawa_closure:
         const :_static_info;
         const lvl15_raw9_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:45.13653 UTC

[section "data" {
     lvl16_rawa_closure:
         const :_static_info;
         const lvl15_raw9_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:45.137251 UTC

[section "data" {
     lvl17_rawb_closure:
         const GHC.Stack.Types.CallStack_static_info;
         const lvl16_rawa_closure+2;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:45.137636 UTC

[section "data" {
     lvl17_rawb_closure:
         const GHC.Stack.Types.CallStack_static_info;
         const lvl16_rawa_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:45.137984 UTC

[section "data" {
     lvl17_rawb_closure:
         const GHC.Stack.Types.CallStack_static_info;
         const lvl16_rawa_closure+2;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:45.138593 UTC

[section "data" {
     lvl18_rawc_closure:
         const lvl18_rawc_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     caVz_str:
         I8[] [78,101,103,97,116,105,118,101,32,114,97,110,103,101,32,115,105,122,101]
 },
 lvl18_rawc_entry() //  [R1]
         { info_tbl: [(caVA,
                       label: lvl18_rawc_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caVA:
           _rawc::P64 = R1;
           goto caVu;
       caVu:
           if ((old + 0) - <highSp> < SpLim) goto caVB; else goto caVC;
       caVC:
           if (HpLim == 0) goto caVB; else goto caVD;
       caVB:
           R1 = _rawc::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caVD:
           (_caVw::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rawc::P64);
           if (_caVw::I64 == 0) goto caVy; else goto caVx;
       caVy:
           call (I64[_rawc::P64])() args: 8, res: 0, upd: 8;
       caVx:
           I64[(old + 24)] = stg_bh_upd_frame_info;
           I64[(old + 16)] = _caVw::I64;
           R2 = caVz_str;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:45.141156 UTC

{offset
  caVA:
      _rawc::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto caVB; else goto caVC;
  caVC:
      if (HpLim == 0) goto caVB; else goto caVD;
  caVB:
      R1 = _rawc::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caVD:
      (_caVw::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rawc::P64);
      if (_caVw::I64 == 0) goto caVy; else goto caVx;
  caVy:
      call (I64[_rawc::P64])() args: 8, res: 0, upd: 8;
  caVx:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _caVw::I64;
      R2 = caVz_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:45.142247 UTC

{offset
  caVA:
      _rawc::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto caVB; else goto caVC;
  caVC:
      if (HpLim == 0) goto caVB; else goto caVD;
  caVB:
      R1 = _rawc::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caVD:
      (_caVw::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rawc::P64);
      if (_caVw::I64 == 0) goto caVy; else goto caVx;
  caVy:
      call (I64[_rawc::P64])() args: 8, res: 0, upd: 8;
  caVx:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _caVw::I64;
      R2 = caVz_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:45.143372 UTC

{offset
  caVA:
      _rawc::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto caVB; else goto caVC;
  caVC:
      if (HpLim == 0) goto caVB; else goto caVD;
  caVB:
      R1 = _rawc::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caVD:
      (_caVw::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rawc::P64);
      if (_caVw::I64 == 0) goto caVy; else goto caVx;
  caVy:
      call (I64[_rawc::P64])() args: 8, res: 0, upd: 8;
  caVx:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _caVw::I64;
      R2 = caVz_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:45.144524 UTC

{offset
  caVA:
      _rawc::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto caVB; else goto caVC;
  caVC:
      if (HpLim == 0) goto caVB; else goto caVD;
  caVB:
      R1 = _rawc::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caVD:
      (_caVw::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rawc::P64);
      if (_caVw::I64 == 0) goto caVy; else goto caVx;
  caVy:
      call (I64[_rawc::P64])() args: 8, res: 0, upd: 8;
  caVx:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _caVw::I64;
      R2 = caVz_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:45.145656 UTC

{offset
  caVA:
      _rawc::P64 = R1;
      if ((Sp + -16) < SpLim) goto caVB; else goto caVC;
  caVC:
      if (HpLim == 0) goto caVB; else goto caVD;
  caVB:
      R1 = _rawc::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caVD:
      (_caVw::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rawc::P64);
      if (_caVw::I64 == 0) goto caVy; else goto caVx;
  caVy:
      call (I64[_rawc::P64])() args: 8, res: 0, upd: 8;
  caVx:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _caVw::I64;
      R2 = caVz_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:45.146945 UTC

[(caVx, {}), (caVy, {}), (caVA, {}), (caVB, {}), (caVC, {}),
 (caVD, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:45.147343 UTC

lvl18_rawc_entry() //  [R1]
        { info_tbl: [(caVA,
                      label: lvl18_rawc_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caVA:
          _rawc::P64 = R1;
          if ((Sp + -16) < SpLim) goto caVB; else goto caVC;
      caVC:
          if (HpLim == 0) goto caVB; else goto caVD;
      caVB:
          R1 = _rawc::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      caVD:
          (_caVw::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rawc::P64);
          if (_caVw::I64 == 0) goto caVy; else goto caVx;
      caVy:
          call (I64[_rawc::P64])() args: 8, res: 0, upd: 8;
      caVx:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _caVw::I64;
          R2 = caVz_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:45.148713 UTC

lvl18_rawc_entry() //  [R1]
        { info_tbl: [(caVA,
                      label: lvl18_rawc_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caVA:
          _rawc::P64 = R1;
          if ((Sp + -16) < SpLim) goto caVB; else goto caVC;
      caVC:
          if (HpLim == 0) goto caVB; else goto caVD;
      caVB:
          R1 = _rawc::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      caVD:
          (_caVw::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rawc::P64);
          if (_caVw::I64 == 0) goto caVy; else goto caVx;
      caVy:
          call (I64[_rawc::P64])() args: 8, res: 0, upd: 8;
      caVx:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _caVw::I64;
          R2 = caVz_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:45.150123 UTC

[section "data" {
     lvl18_rawc_closure:
         const lvl18_rawc_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     caVz_str:
         I8[] [78,101,103,97,116,105,118,101,32,114,97,110,103,101,32,115,105,122,101]
 },
 lvl18_rawc_entry() //  [R1]
         { info_tbl: [(caVA,
                       label: lvl18_rawc_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caVA:
           _rawc::P64 = R1;
           if ((Sp + -16) < SpLim) goto caVB; else goto caVC;
       caVC:
           if (HpLim == 0) goto caVB; else goto caVD;
       caVB:
           R1 = _rawc::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caVD:
           (_caVw::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rawc::P64);
           if (_caVw::I64 == 0) goto caVy; else goto caVx;
       caVy:
           call (I64[_rawc::P64])() args: 8, res: 0, upd: 8;
       caVx:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caVw::I64;
           R2 = caVz_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:45.151859 UTC

[section "data" {
     lvl18_rawc_closure:
         const lvl18_rawc_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     caVz_str:
         I8[] [78,101,103,97,116,105,118,101,32,114,97,110,103,101,32,115,105,122,101]
 },
 lvl18_rawc_entry() //  [R1]
         { info_tbl: [(caVA,
                       label: lvl18_rawc_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caVA:
           _rawc::P64 = R1;
           if ((Sp + -16) < SpLim) goto caVB; else goto caVC;
       caVC:
           if (HpLim == 0) goto caVB; else goto caVD;
       caVB:
           R1 = _rawc::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caVD:
           (_caVw::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rawc::P64);
           if (_caVw::I64 == 0) goto caVy; else goto caVx;
       caVy:
           call (I64[_rawc::P64])() args: 8, res: 0, upd: 8;
       caVx:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caVw::I64;
           R2 = caVz_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:45.156598 UTC

[section "data" {
     SkipList.$fMArrayTArrayeSTM5_closure:
         const SkipList.$fMArrayTArrayeSTM5_info;
         const 0;
         const 0;
         const 0;
 },
 SkipList.$fMArrayTArrayeSTM5_entry() //  [R1]
         { info_tbl: [(caVQ,
                       label: SkipList.$fMArrayTArrayeSTM5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caVQ:
           _ravr::P64 = R1;
           goto caVL;
       caVL:
           if ((old + 0) - <highSp> < SpLim) goto caVR; else goto caVS;
       caVS:
           if (HpLim == 0) goto caVR; else goto caVT;
       caVR:
           R1 = _ravr::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caVT:
           (_caVN::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _ravr::P64);
           if (_caVN::I64 == 0) goto caVP; else goto caVO;
       caVP:
           call (I64[_ravr::P64])() args: 8, res: 0, upd: 8;
       caVO:
           I64[(old + 24)] = stg_bh_upd_frame_info;
           I64[(old + 16)] = _caVN::I64;
           R3 = lvl18_rawc_closure;
           R2 = lvl17_rawb_closure+1;
           call GHC.Err.error_info(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:45.158758 UTC

{offset
  caVQ:
      _ravr::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto caVR; else goto caVS;
  caVS:
      if (HpLim == 0) goto caVR; else goto caVT;
  caVR:
      R1 = _ravr::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caVT:
      (_caVN::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _ravr::P64);
      if (_caVN::I64 == 0) goto caVP; else goto caVO;
  caVP:
      call (I64[_ravr::P64])() args: 8, res: 0, upd: 8;
  caVO:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _caVN::I64;
      R3 = lvl18_rawc_closure;
      R2 = lvl17_rawb_closure+1;
      call GHC.Err.error_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:45.159918 UTC

{offset
  caVQ:
      _ravr::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto caVR; else goto caVS;
  caVS:
      if (HpLim == 0) goto caVR; else goto caVT;
  caVR:
      R1 = _ravr::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caVT:
      (_caVN::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _ravr::P64);
      if (_caVN::I64 == 0) goto caVP; else goto caVO;
  caVP:
      call (I64[_ravr::P64])() args: 8, res: 0, upd: 8;
  caVO:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _caVN::I64;
      R3 = lvl18_rawc_closure;
      R2 = lvl17_rawb_closure+1;
      call GHC.Err.error_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:45.161104 UTC

{offset
  caVQ:
      _ravr::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto caVR; else goto caVS;
  caVS:
      if (HpLim == 0) goto caVR; else goto caVT;
  caVR:
      R1 = _ravr::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caVT:
      (_caVN::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _ravr::P64);
      if (_caVN::I64 == 0) goto caVP; else goto caVO;
  caVP:
      call (I64[_ravr::P64])() args: 8, res: 0, upd: 8;
  caVO:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _caVN::I64;
      R3 = lvl18_rawc_closure;
      R2 = lvl17_rawb_closure+1;
      call GHC.Err.error_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:45.162308 UTC

{offset
  caVQ:
      _ravr::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto caVR; else goto caVS;
  caVS:
      if (HpLim == 0) goto caVR; else goto caVT;
  caVR:
      R1 = _ravr::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caVT:
      (_caVN::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _ravr::P64);
      if (_caVN::I64 == 0) goto caVP; else goto caVO;
  caVP:
      call (I64[_ravr::P64])() args: 8, res: 0, upd: 8;
  caVO:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _caVN::I64;
      R3 = lvl18_rawc_closure;
      R2 = lvl17_rawb_closure+1;
      Sp = Sp - 16;
      call GHC.Err.error_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:45.163526 UTC

{offset
  caVQ:
      _ravr::P64 = R1;
      if ((Sp + -16) < SpLim) goto caVR; else goto caVS;
  caVS:
      if (HpLim == 0) goto caVR; else goto caVT;
  caVR:
      R1 = _ravr::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caVT:
      (_caVN::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _ravr::P64);
      if (_caVN::I64 == 0) goto caVP; else goto caVO;
  caVP:
      call (I64[_ravr::P64])() args: 8, res: 0, upd: 8;
  caVO:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _caVN::I64;
      R3 = lvl18_rawc_closure;
      R2 = lvl17_rawb_closure+1;
      Sp = Sp - 16;
      call GHC.Err.error_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:45.16486 UTC

[(caVO,
  {GHC.Err.error_closure, lvl17_rawb_closure, lvl18_rawc_closure}),
 (caVP, {}),
 (caVQ,
  {GHC.Err.error_closure, lvl17_rawb_closure, lvl18_rawc_closure}),
 (caVR, {}),
 (caVS,
  {GHC.Err.error_closure, lvl17_rawb_closure, lvl18_rawc_closure}),
 (caVT,
  {GHC.Err.error_closure, lvl17_rawb_closure, lvl18_rawc_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:45.165661 UTC

SkipList.$fMArrayTArrayeSTM5_entry() //  [R1]
        { info_tbl: [(caVQ,
                      label: SkipList.$fMArrayTArrayeSTM5_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caVQ:
          _ravr::P64 = R1;
          if ((Sp + -16) < SpLim) goto caVR; else goto caVS;
      caVS:
          if (HpLim == 0) goto caVR; else goto caVT;
      caVR:
          R1 = _ravr::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      caVT:
          (_caVN::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _ravr::P64);
          if (_caVN::I64 == 0) goto caVP; else goto caVO;
      caVP:
          call (I64[_ravr::P64])() args: 8, res: 0, upd: 8;
      caVO:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _caVN::I64;
          R3 = lvl18_rawc_closure;
          R2 = lvl17_rawb_closure+1;
          Sp = Sp - 16;
          call GHC.Err.error_info(R3, R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:45.167126 UTC

SkipList.$fMArrayTArrayeSTM5_entry() //  [R1]
        { info_tbl: [(caVQ,
                      label: SkipList.$fMArrayTArrayeSTM5_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caVQ:
          _ravr::P64 = R1;
          if ((Sp + -16) < SpLim) goto caVR; else goto caVS;
      caVS:
          if (HpLim == 0) goto caVR; else goto caVT;
      caVR:
          R1 = _ravr::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      caVT:
          (_caVN::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _ravr::P64);
          if (_caVN::I64 == 0) goto caVP; else goto caVO;
      caVP:
          call (I64[_ravr::P64])() args: 8, res: 0, upd: 8;
      caVO:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _caVN::I64;
          R3 = lvl18_rawc_closure;
          R2 = lvl17_rawb_closure+1;
          Sp = Sp - 16;
          call GHC.Err.error_info(R3, R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:45.168585 UTC

[section "data" {
     SkipList.$fMArrayTArrayeSTM5_closure:
         const SkipList.$fMArrayTArrayeSTM5_info;
         const 0;
         const 0;
         const 0;
 },
 SkipList.$fMArrayTArrayeSTM5_entry() //  [R1]
         { info_tbl: [(caVQ,
                       label: SkipList.$fMArrayTArrayeSTM5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caVQ:
           _ravr::P64 = R1;
           if ((Sp + -16) < SpLim) goto caVR; else goto caVS;
       caVS:
           if (HpLim == 0) goto caVR; else goto caVT;
       caVR:
           R1 = _ravr::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caVT:
           (_caVN::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _ravr::P64);
           if (_caVN::I64 == 0) goto caVP; else goto caVO;
       caVP:
           call (I64[_ravr::P64])() args: 8, res: 0, upd: 8;
       caVO:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caVN::I64;
           R3 = lvl18_rawc_closure;
           R2 = lvl17_rawb_closure+1;
           Sp = Sp - 16;
           call GHC.Err.error_info(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:45.17035 UTC

[section "data" {
     SkipList.$fMArrayTArrayeSTM5_closure:
         const SkipList.$fMArrayTArrayeSTM5_info;
         const 0;
         const 0;
         const 0;
 },
 SkipList.$fMArrayTArrayeSTM5_entry() //  [R1]
         { info_tbl: [(caVQ,
                       label: SkipList.$fMArrayTArrayeSTM5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caVQ:
           _ravr::P64 = R1;
           if ((Sp + -16) < SpLim) goto caVR; else goto caVS;
       caVS:
           if (HpLim == 0) goto caVR; else goto caVT;
       caVR:
           R1 = _ravr::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caVT:
           (_caVN::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _ravr::P64);
           if (_caVN::I64 == 0) goto caVP; else goto caVO;
       caVP:
           call (I64[_ravr::P64])() args: 8, res: 0, upd: 8;
       caVO:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _caVN::I64;
           R3 = lvl18_rawc_closure;
           R2 = lvl17_rawb_closure+1;
           Sp = Sp - 16;
           call GHC.Err.error_info(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:45.177064 UTC

[section "data" {
     SkipList.$fMArrayTArrayeSTM4_closure:
         const SkipList.$fMArrayTArrayeSTM4_info;
         const 0;
 },
 $wa8_say0_entry() //  [R3, R2, R1]
         { info_tbl: [(caXh,
                       label: $wa8_say0_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caXh:
           _say2::P64 = R3;
           _say1::I64 = R2;
           _say0::P64 = R1;
           goto caXb;
       caXb:
           if ((old + 0) - <highSp> < SpLim) goto caXi; else goto caXj;
       caXj:
           goto caXa;
       caXa:
           if (HpLim == 0) goto caXi; else goto caXs;
       caXi:
           R3 = _say2::P64;
           R2 = _say1::I64;
           R1 = _say0::P64;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caXs:
           _saxW::P64 = P64[_say0::P64 + 5];
           _say4::I64 = _say1::I64;
           switch [-9223372036854775808 .. 9223372036854775807] _say4::I64 {
               case 0 : goto caXg;
               default: goto caXf;
           }
       caXg:
           R1 = _say2::P64;
           call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
       caXf:
           I64[(young<caXl> + 8)] = caXl;
           R1 = _saxW::P64;
           call stg_newNOrecTVar#(R1) returns to caXl, args: 8, res: 8, upd: 8;
       caXl:
           _say7::P64 = R1;
           Hp = Hp + 40;
           if (Hp > HpLim) goto caXr; else goto caXq;
       caXr:
           HpAlloc = 40;
           goto caXp;
       caXp:
           R1 = _say7::P64;
           call stg_gc_unpt_r1(R1) returns to caXl, args: 8, res: 8, upd: 8;
       caXq:
           I64[Hp - 32] = GHC.Conc.Sync.TVar_con_info;
           P64[Hp - 24] = _say7::P64;
           _caXn::P64 = Hp - 31;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _caXn::P64;
           P64[Hp] = _say2::P64;
           _caXo::P64 = Hp - 14;
           _caXt::I64 = _say4::I64 - 1;
           _say8::I64 = _caXt::I64;
           R3 = _caXo::P64;
           R2 = _say8::I64;
           R1 = _say0::P64;
           call $wa8_say0_info(R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 $wa9_sayr_entry() //  [R3, R2, R1]
         { info_tbl: [(caY7,
                       label: $wa9_sayr_info
                       rep:HeapRep 1 ptrs 1 nonptrs {
                             Fun {arity: 3 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caY7:
           _sayt::P64 = R3;
           _says::I64 = R2;
           _sayr::P64 = R1;
           goto caY3;
       caY3:
           if ((old + 0) - <highSp> < SpLim) goto caY8; else goto caY9;
       caY9:
           goto caY2;
       caY2:
           if (HpLim == 0) goto caY8; else goto caYs;
       caY8:
           R3 = _sayt::P64;
           R2 = _says::I64;
           R1 = _sayr::P64;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caYs:
           _saym::P64 = P64[_sayr::P64 + 5];
           _saxZ::I64 = I64[_sayr::P64 + 13];
           _caY5::I64 = _says::I64 == _saxZ::I64;
           _sayv::I64 = _caY5::I64;
           switch [0 .. 1] _sayv::I64 {
               case 0 : goto caYf;
               case 1 : goto caYr;
           }
       caYr:
           R1 = GHC.Tuple.()_closure+1;
           call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
       caYf:
           I64[(young<caYd> + 8)] = caYd;
           R1 = _sayt::P64;
           if (R1 & 7 != 0) goto caYd; else goto caYg;
       caYg:
           call (I64[R1])(R1) returns to caYd, args: 8, res: 8, upd: 8;
       caYd:
           _sayx::P64 = R1;
           _caYt::P64 = _sayx::P64 & 7;
           switch [1 .. 2] _caYt::P64 {
               case 1 : goto caYm;
               case 2 : goto caYq;
           }
       caYq:
           _sayy::P64 = P64[_sayx::P64 + 6];
           _sayz::P64 = P64[_sayx::P64 + 14];
           P64[(_saym::P64 + 24) + (_says::I64 << 3)] = _sayy::P64;
           I64[_saym::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
           I8[(_saym::P64 + 24) + (I64[_saym::P64 + 8] << 3) + (_says::I64 >> 7)] = 1 :: W8;
           _caYw::I64 = _says::I64 + 1;
           _sayB::I64 = _caYw::I64;
           R3 = _sayz::P64;
           R2 = _sayB::I64;
           R1 = _sayr::P64;
           call $wa9_sayr_info(R3, R2, R1) args: 8, res: 0, upd: 8;
       caYm:
           R1 = GHC.Tuple.()_closure+1;
           call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sayL_entry() //  [R1]
         { info_tbl: [(caYx,
                       label: sat_sayL_info
                       rep:HeapRep 2 ptrs 1 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caYx:
           _sayL::P64 = R1;
           goto caXD;
       caXD:
           if ((old + 0) - <highSp> < SpLim) goto caYy; else goto caYz;
       caYz:
           goto caXC;
       caXC:
           if (HpLim == 0) goto caYy; else goto caYA;
       caYy:
           R1 = _sayL::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caYA:
           _saxV::P64 = P64[_sayL::P64 + 7];
           _sayd::P64 = P64[_sayL::P64 + 15];
           _saxZ::I64 = I64[_sayL::P64 + 23];
           I64[(young<caXF> + 8)] = caXF;
           R1 = _saxV::P64;
           if (R1 & 7 != 0) goto caXF; else goto caXG;
       caXG:
           call (I64[R1])(R1) returns to caXF, args: 8, res: 8, upd: 8;
       caXF:
           _sayf::P64 = R1;
           _sayg::P64 = P64[_sayf::P64 + 7];
           _sayh::P64 = P64[_sayf::P64 + 15];
           _caXK::I64 = %MO_S_Lt_W64(_saxZ::I64, 0);
           _sayi::I64 = _caXK::I64;
           switch [0 .. 1] _sayi::I64 {
               case 0 : goto caYD;
               case 1 : goto caYS;
           }
       caYS:
           R1 = GHC.Arr.negRange_closure;
           call (I64[R1])(R1) args: 8, res: 0, upd: 8;
       caYD:
           I64[(young<caXP> + 8)] = caXP;
           R2 = Data.Array.Base.arrEleBottom_closure;
           R1 = _saxZ::I64;
           call stg_newArray#(R2,
                              R1) returns to caXP, args: 8, res: 8, upd: 8;
       caXP:
           _saym::P64 = R1;
           I64[(young<caXR> + 8)] = caXR;
           R1 = _sayg::P64;
           call stg_ap_0_fast(R1) returns to caXR, args: 8, res: 8, upd: 8;
       caXR:
           _sayn::P64 = R1;
           I64[(young<caXT> + 8)] = caXT;
           R1 = _sayh::P64;
           call stg_ap_0_fast(R1) returns to caXT, args: 8, res: 8, upd: 8;
       caXT:
           _sayo::P64 = R1;
           Hp = Hp + 24;
           if (Hp > HpLim) goto caYI; else goto caYH;
       caYI:
           HpAlloc = 24;
           goto caYG;
       caYG:
           R1 = _sayo::P64;
           call stg_gc_unpt_r1(R1) returns to caXT, args: 8, res: 8, upd: 8;
       caYH:
           _caXV::I64 = %MO_S_Lt_W64(_saxZ::I64, 0);
           _sayp::I64 = _caXV::I64;
           switch [0 .. 1] _sayp::I64 {
               case 0 : goto caYN;
               case 1 : goto caYR;
           }
       caYR:
           Hp = Hp - 24;
           R1 = SkipList.$fMArrayTArrayeSTM5_closure;
           call (I64[R1])(R1) args: 8, res: 0, upd: 8;
       caYN:
           _caY0::P64 = Hp - 13;
           I64[Hp - 16] = $wa9_sayr_info;
           P64[Hp - 8] = _saym::P64;
           I64[Hp] = _saxZ::I64;
           I64[(young<caYJ> + 8)] = caYJ;
           R3 = _sayd::P64;
           R2 = 0;
           R1 = _caY0::P64;
           call $wa9_sayr_info(R3,
                               R2,
                               R1) returns to caYJ, args: 8, res: 8, upd: 8;
       caYJ:
           _sayE::P64 = R1;
           Hp = Hp + 40;
           if (Hp > HpLim) goto caYQ; else goto caYP;
       caYQ:
           HpAlloc = 40;
           goto caYO;
       caYO:
           R1 = _sayE::P64;
           call stg_gc_unpt_r1(R1) returns to caYJ, args: 8, res: 8, upd: 8;
       caYP:
           I64[_saym::P64] = stg_MUT_ARR_PTRS_FROZEN0_info;
           _sayH::P64 = _saym::P64;
           _sayH::P64 = _sayH::P64;
           I64[Hp - 32] = GHC.Arr.Array_con_info;
           P64[Hp - 24] = _sayn::P64;
           P64[Hp - 16] = _sayo::P64;
           P64[Hp - 8] = _sayH::P64;
           I64[Hp] = _saxZ::I64;
           _caYL::P64 = Hp - 31;
           R1 = _caYL::P64;
           call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sayM_entry() //  [R1]
         { info_tbl: [(caYT,
                       label: sat_sayM_info
                       rep:HeapRep 2 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caYT:
           _sayM::P64 = R1;
           goto caXy;
       caXy:
           if ((old + 0) - <highSp> < SpLim) goto caYU; else goto caYV;
       caYV:
           Hp = Hp + 32;
           if (Hp > HpLim) goto caYX; else goto caYW;
       caYX:
           HpAlloc = 32;
           goto caYU;
       caYU:
           R1 = _sayM::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caYW:
           I64[(old + 24)] = stg_upd_frame_info;
           P64[(old + 16)] = _sayM::P64;
           _saxV::P64 = P64[_sayM::P64 + 16];
           _sayd::P64 = P64[_sayM::P64 + 24];
           _saxZ::I64 = I64[_sayM::P64 + 32];
           I64[Hp - 24] = sat_sayL_info;
           P64[Hp - 16] = _saxV::P64;
           P64[Hp - 8] = _sayd::P64;
           I64[Hp] = _saxZ::I64;
           _caXA::P64 = Hp - 23;
           R2 = _caXA::P64;
           call GHC.ST.runSTRep_info(R2) args: 24, res: 0, upd: 24;
     }
 },
 SkipList.$fMArrayTArrayeSTM4_entry() //  [R4, R3, R2]
         { info_tbl: [(caYY,
                       label: SkipList.$fMArrayTArrayeSTM4_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caYY:
           _saxW::P64 = R4;
           _saxV::P64 = R3;
           _saxU::P64 = R2;
           goto caX2;
       caX2:
           if ((old + 0) - <highSp> < SpLim) goto caYZ; else goto caZ0;
       caZ0:
           goto caX1;
       caX1:
           if (HpLim == 0) goto caYZ; else goto caZ1;
       caYZ:
           R4 = _saxW::P64;
           R3 = _saxV::P64;
           R2 = _saxU::P64;
           R1 = SkipList.$fMArrayTArrayeSTM4_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caZ1:
           I64[(young<caX4> + 8)] = caX4;
           R2 = _saxU::P64;
           I64[(young<caX4> + 24)] = stg_ap_p_info;
           P64[(young<caX4> + 16)] = _saxV::P64;
           call GHC.Arr.rangeSize_info(R2) returns to caX4, args: 24, res: 8, upd: 8;
       caX4:
           _saxY::P64 = R1;
           Hp = Hp + 16;
           if (Hp > HpLim) goto caZ4; else goto caZ3;
       caZ4:
           HpAlloc = 16;
           goto caZ2;
       caZ2:
           R1 = _saxY::P64;
           call stg_gc_unpt_r1(R1) returns to caX4, args: 8, res: 8, upd: 8;
       caZ3:
           _saxZ::I64 = I64[_saxY::P64 + 7];
           _caX8::P64 = Hp - 5;
           I64[Hp - 8] = $wa8_say0_info;
           P64[Hp] = _saxW::P64;
           I64[(young<caXu> + 8)] = caXu;
           R3 = GHC.Types.[]_closure+1;
           R2 = _saxZ::I64;
           R1 = _caX8::P64;
           call $wa8_say0_info(R3,
                               R2,
                               R1) returns to caXu, args: 8, res: 8, upd: 8;
       caXu:
           _sayd::P64 = R1;
           Hp = Hp + 40;
           if (Hp > HpLim) goto caZ7; else goto caZ6;
       caZ7:
           HpAlloc = 40;
           goto caZ5;
       caZ5:
           R1 = _sayd::P64;
           call stg_gc_unpt_r1(R1) returns to caXu, args: 8, res: 8, upd: 8;
       caZ6:
           I64[Hp - 32] = sat_sayM_info;
           P64[Hp - 16] = _saxV::P64;
           P64[Hp - 8] = _sayd::P64;
           I64[Hp] = _saxZ::I64;
           _caXw::P64 = Hp - 32;
           R1 = _caXw::P64;
           call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:45.198118 UTC

{offset
  caXh:
      _say2::P64 = R3;
      _say1::I64 = R2;
      _say0::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto caXi; else goto caXj;
  caXj:
      if (HpLim == 0) goto caXi; else goto caXs;
  caXi:
      R3 = _say2::P64;
      R2 = _say1::I64;
      R1 = _say0::P64;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  caXs:
      _saxW::P64 = P64[_say0::P64 + 5];
      _say4::I64 = _say1::I64;
      switch [-9223372036854775808 .. 9223372036854775807] _say4::I64 {
          case 0 : goto caXg;
          default: goto caXf;
      }
  caXg:
      R1 = _say2::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
  caXf:
      I64[(young<caXl> + 8)] = caXl;
      R1 = _saxW::P64;
      call stg_newNOrecTVar#(R1) returns to caXl, args: 8, res: 8, upd: 8;
  caXl:
      _say7::P64 = R1;
      Hp = Hp + 40;
      if (Hp > HpLim) goto caXr; else goto caXq;
  caXr:
      HpAlloc = 40;
      R1 = _say7::P64;
      call stg_gc_unpt_r1(R1) returns to caXl, args: 8, res: 8, upd: 8;
  caXq:
      I64[Hp - 32] = GHC.Conc.Sync.TVar_con_info;
      P64[Hp - 24] = _say7::P64;
      _caXn::P64 = Hp - 31;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _caXn::P64;
      P64[Hp] = _say2::P64;
      _caXo::P64 = Hp - 14;
      _caXt::I64 = _say4::I64 - 1;
      _say8::I64 = _caXt::I64;
      R3 = _caXo::P64;
      R2 = _say8::I64;
      R1 = _say0::P64;
      call $wa8_say0_info(R3, R2, R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:45.200406 UTC

{offset
  caXh:
      _say2::P64 = R3;
      _say1::I64 = R2;
      _say0::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto caXi; else goto caXj;
  caXj:
      if (HpLim == 0) goto caXi; else goto caXs;
  caXi:
      R3 = _say2::P64;
      R2 = _say1::I64;
      R1 = _say0::P64;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  caXs:
      _saxW::P64 = P64[_say0::P64 + 5];
      _say4::I64 = _say1::I64;
      switch [-9223372036854775808 .. 9223372036854775807] _say4::I64 {
          case 0 : goto caXg;
          default: goto caXf;
      }
  caXg:
      R1 = _say2::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
  caXf:
      I64[(young<caXl> + 8)] = caXl;
      R1 = _saxW::P64;
      call stg_newNOrecTVar#(R1) returns to caXl, args: 8, res: 8, upd: 8;
  caXl:
      _say7::P64 = R1;
      Hp = Hp + 40;
      if (Hp > HpLim) goto caXr; else goto caXq;
  caXr:
      HpAlloc = 40;
      R1 = _say7::P64;
      call stg_gc_unpt_r1(R1) returns to caXl, args: 8, res: 8, upd: 8;
  caXq:
      I64[Hp - 32] = GHC.Conc.Sync.TVar_con_info;
      P64[Hp - 24] = _say7::P64;
      _caXn::P64 = Hp - 31;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _caXn::P64;
      P64[Hp] = _say2::P64;
      _caXo::P64 = Hp - 14;
      _caXt::I64 = _say4::I64 - 1;
      _say8::I64 = _caXt::I64;
      R3 = _caXo::P64;
      R2 = _say8::I64;
      R1 = _say0::P64;
      call $wa8_say0_info(R3, R2, R1) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:45.202624 UTC

{offset
  caXh:
      _say2::P64 = R3;
      _say1::I64 = R2;
      _say0::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto caXi; else goto caXj;
  caXj:
      if (HpLim == 0) goto caXi; else goto caXs;
  caXi:
      R3 = _say2::P64;
      R2 = _say1::I64;
      R1 = _say0::P64;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  caXs:
      _saxW::P64 = P64[_say0::P64 + 5];
      _say4::I64 = _say1::I64;
      if (_say4::I64 != 0) goto caXf; else goto caXg;
  caXf:
      I64[(young<caXl> + 8)] = caXl;
      R1 = _saxW::P64;
      call stg_newNOrecTVar#(R1) returns to caXl, args: 8, res: 8, upd: 8;
  caXl:
      _say7::P64 = R1;
      Hp = Hp + 40;
      if (Hp > HpLim) goto caXr; else goto caXq;
  caXr:
      HpAlloc = 40;
      R1 = _say7::P64;
      call stg_gc_unpt_r1(R1) returns to caXl, args: 8, res: 8, upd: 8;
  caXq:
      I64[Hp - 32] = GHC.Conc.Sync.TVar_con_info;
      P64[Hp - 24] = _say7::P64;
      _caXn::P64 = Hp - 31;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _caXn::P64;
      P64[Hp] = _say2::P64;
      _caXo::P64 = Hp - 14;
      _caXt::I64 = _say4::I64 - 1;
      _say8::I64 = _caXt::I64;
      R3 = _caXo::P64;
      R2 = _say8::I64;
      R1 = _say0::P64;
      call $wa8_say0_info(R3, R2, R1) args: 8, res: 0, upd: 8;
  caXg:
      R1 = _say2::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:45.205045 UTC

{offset
  caXh:
      _say2::P64 = R3;
      _say1::I64 = R2;
      _say0::P64 = R1;
      if ((Sp + 8) - 40 < SpLim) goto caXi; else goto caXj;
  caXj:
      if (HpLim == 0) goto caXi; else goto caXs;
  caXi:
      R3 = _say2::P64;
      R2 = _say1::I64;
      R1 = _say0::P64;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  caXs:
      _saxW::P64 = P64[_say0::P64 + 5];
      _say4::I64 = _say1::I64;
      if (_say4::I64 != 0) goto caXf; else goto caXg;
  caXf:
      I64[Sp - 32] = caXl;
      R1 = _saxW::P64;
      P64[Sp - 24] = _say0::P64;
      P64[Sp - 16] = _say2::P64;
      I64[Sp - 8] = _say4::I64;
      Sp = Sp - 32;
      call stg_newNOrecTVar#(R1) returns to caXl, args: 8, res: 8, upd: 8;
  caXl:
      _say0::P64 = P64[Sp + 8];
      _say2::P64 = P64[Sp + 16];
      _say4::I64 = I64[Sp + 24];
      _say7::P64 = R1;
      Hp = Hp + 40;
      if (Hp > HpLim) goto caXr; else goto caXq;
  caXr:
      HpAlloc = 40;
      R1 = _say7::P64;
      call stg_gc_unpt_r1(R1) returns to caXl, args: 8, res: 8, upd: 8;
  caXq:
      I64[Hp - 32] = GHC.Conc.Sync.TVar_con_info;
      P64[Hp - 24] = _say7::P64;
      _caXn::P64 = Hp - 31;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _caXn::P64;
      P64[Hp] = _say2::P64;
      _caXo::P64 = Hp - 14;
      _caXt::I64 = _say4::I64 - 1;
      _say8::I64 = _caXt::I64;
      R3 = _caXo::P64;
      R2 = _say8::I64;
      R1 = _say0::P64;
      Sp = Sp + 32;
      call $wa8_say0_info(R3, R2, R1) args: 8, res: 0, upd: 8;
  caXg:
      R1 = _say2::P64;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:45.207679 UTC

{offset
  caXh:
      _say2::P64 = R3;
      _say1::I64 = R2;
      _say0::P64 = R1;
      if ((Sp + -32) < SpLim) goto caXi; else goto caXj;
  caXj:
      if (HpLim == 0) goto caXi; else goto caXs;
  caXi:
      R3 = _say2::P64;
      R2 = _say1::I64;
      R1 = _say0::P64;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  caXs:
      if (_say1::I64 != 0) goto caXf; else goto caXg;
  caXf:
      I64[Sp - 32] = caXl;
      R1 = P64[_say0::P64 + 5];
      P64[Sp - 24] = _say0::P64;
      P64[Sp - 16] = _say2::P64;
      I64[Sp - 8] = _say1::I64;
      Sp = Sp - 32;
      call stg_newNOrecTVar#(R1) returns to caXl, args: 8, res: 8, upd: 8;
  caXl:
      Hp = Hp + 40;
      if (Hp > HpLim) goto caXr; else goto caXq;
  caXr:
      HpAlloc = 40;
      R1 = R1;
      call stg_gc_unpt_r1(R1) returns to caXl, args: 8, res: 8, upd: 8;
  caXq:
      I64[Hp - 32] = GHC.Conc.Sync.TVar_con_info;
      P64[Hp - 24] = R1;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = Hp - 31;
      P64[Hp] = P64[Sp + 16];
      R3 = Hp - 14;
      R2 = I64[Sp + 24] - 1;
      R1 = P64[Sp + 8];
      Sp = Sp + 32;
      call $wa8_say0_info(R3, R2, R1) args: 8, res: 0, upd: 8;
  caXg:
      R1 = _say2::P64;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:45.210291 UTC

[(caXf, {$wa8_say0_closure}), (caXg, {}),
 (caXh, {$wa8_say0_closure}), (caXi, {}),
 (caXj, {$wa8_say0_closure}), (caXl, {$wa8_say0_closure}),
 (caXq, {$wa8_say0_closure}), (caXr, {$wa8_say0_closure}),
 (caXs, {$wa8_say0_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:45.211005 UTC

$wa8_say0_entry() //  [R3, R2, R1]
        { info_tbl: [(caXh,
                      label: $wa8_say0_info
                      rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 13} }),
                     (caXl,
                      label: block_caXl_info
                      rep:StackRep [False, False, True])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caXh:
          _say2::P64 = R3;
          _say1::I64 = R2;
          _say0::P64 = R1;
          if ((Sp + -32) < SpLim) goto caXi; else goto caXj;
      caXj:
          if (HpLim == 0) goto caXi; else goto caXs;
      caXi:
          R3 = _say2::P64;
          R2 = _say1::I64;
          R1 = _say0::P64;
          call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
      caXs:
          if (_say1::I64 != 0) goto caXf; else goto caXg;
      caXf:
          I64[Sp - 32] = caXl;
          R1 = P64[_say0::P64 + 5];
          P64[Sp - 24] = _say0::P64;
          P64[Sp - 16] = _say2::P64;
          I64[Sp - 8] = _say1::I64;
          Sp = Sp - 32;
          call stg_newNOrecTVar#(R1) returns to caXl, args: 8, res: 8, upd: 8;
      caXl:
          Hp = Hp + 40;
          if (Hp > HpLim) goto caXr; else goto caXq;
      caXr:
          HpAlloc = 40;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to caXl, args: 8, res: 8, upd: 8;
      caXq:
          I64[Hp - 32] = GHC.Conc.Sync.TVar_con_info;
          P64[Hp - 24] = R1;
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = Hp - 31;
          P64[Hp] = P64[Sp + 16];
          R3 = Hp - 14;
          R2 = I64[Sp + 24] - 1;
          R1 = P64[Sp + 8];
          Sp = Sp + 32;
          call $wa8_say0_info(R3, R2, R1) args: 8, res: 0, upd: 8;
      caXg:
          R1 = _say2::P64;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:45.213658 UTC

$wa8_say0_entry() //  [R3, R2, R1]
        { info_tbl: [(caXh,
                      label: $wa8_say0_info
                      rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 13} }),
                     (caXl,
                      label: block_caXl_info
                      rep:StackRep [False, False, True])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caXh:
          _say2::P64 = R3;
          _say1::I64 = R2;
          _say0::P64 = R1;
          if ((Sp + -32) < SpLim) goto caXi; else goto caXj;
      caXj:
          if (HpLim == 0) goto caXi; else goto caXs;
      caXi:
          R3 = _say2::P64;
          R2 = _say1::I64;
          R1 = _say0::P64;
          call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
      caXs:
          if (_say1::I64 != 0) goto caXf; else goto caXg;
      caXf:
          I64[Sp - 32] = caXl;
          R1 = P64[_say0::P64 + 5];
          P64[Sp - 24] = _say0::P64;
          P64[Sp - 16] = _say2::P64;
          I64[Sp - 8] = _say1::I64;
          Sp = Sp - 32;
          call stg_newNOrecTVar#(R1) returns to caXl, args: 8, res: 8, upd: 8;
      caXl:
          Hp = Hp + 40;
          if (Hp > HpLim) goto caXr; else goto caXq;
      caXr:
          HpAlloc = 40;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to caXl, args: 8, res: 8, upd: 8;
      caXq:
          I64[Hp - 32] = GHC.Conc.Sync.TVar_con_info;
          P64[Hp - 24] = R1;
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = Hp - 31;
          P64[Hp] = P64[Sp + 16];
          R3 = Hp - 14;
          R2 = I64[Sp + 24] - 1;
          R1 = P64[Sp + 8];
          Sp = Sp + 32;
          call $wa8_say0_info(R3, R2, R1) args: 8, res: 0, upd: 8;
      caXg:
          R1 = _say2::P64;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:45.216291 UTC

{offset
  caY7:
      _sayt::P64 = R3;
      _says::I64 = R2;
      _sayr::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto caY8; else goto caY9;
  caY9:
      if (HpLim == 0) goto caY8; else goto caYs;
  caY8:
      R3 = _sayt::P64;
      R2 = _says::I64;
      R1 = _sayr::P64;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  caYs:
      _saym::P64 = P64[_sayr::P64 + 5];
      _saxZ::I64 = I64[_sayr::P64 + 13];
      _caY5::I64 = _says::I64 == _saxZ::I64;
      _sayv::I64 = _caY5::I64;
      switch [0 .. 1] _sayv::I64 {
          case 0 : goto caYf;
          case 1 : goto caYr;
      }
  caYr:
      R1 = GHC.Tuple.()_closure+1;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
  caYf:
      I64[(young<caYd> + 8)] = caYd;
      R1 = _sayt::P64;
      if (R1 & 7 != 0) goto caYd; else goto caYg;
  caYg:
      call (I64[R1])(R1) returns to caYd, args: 8, res: 8, upd: 8;
  caYd:
      _sayx::P64 = R1;
      _caYt::P64 = _sayx::P64 & 7;
      switch [1 .. 2] _caYt::P64 {
          case 1 : goto caYm;
          case 2 : goto caYq;
      }
  caYq:
      _sayy::P64 = P64[_sayx::P64 + 6];
      _sayz::P64 = P64[_sayx::P64 + 14];
      P64[(_saym::P64 + 24) + (_says::I64 << 3)] = _sayy::P64;
      I64[_saym::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
      I8[(_saym::P64 + 24) + (I64[_saym::P64 + 8] << 3) + (_says::I64 >> 7)] = 1 :: W8;
      _caYw::I64 = _says::I64 + 1;
      _sayB::I64 = _caYw::I64;
      R3 = _sayz::P64;
      R2 = _sayB::I64;
      R1 = _sayr::P64;
      call $wa9_sayr_info(R3, R2, R1) args: 8, res: 0, upd: 8;
  caYm:
      R1 = GHC.Tuple.()_closure+1;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:45.21903 UTC

{offset
  caY7:
      _sayt::P64 = R3;
      _says::I64 = R2;
      _sayr::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto caY8; else goto caY9;
  caY9:
      if (HpLim == 0) goto caY8; else goto caYs;
  caY8:
      R3 = _sayt::P64;
      R2 = _says::I64;
      R1 = _sayr::P64;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  caYs:
      _saym::P64 = P64[_sayr::P64 + 5];
      _saxZ::I64 = I64[_sayr::P64 + 13];
      _caY5::I64 = _says::I64 == _saxZ::I64;
      _sayv::I64 = _caY5::I64;
      switch [0 .. 1] _sayv::I64 {
          case 0 : goto caYf;
          case 1 : goto caYr;
      }
  caYf:
      I64[(young<caYd> + 8)] = caYd;
      R1 = _sayt::P64;
      if (R1 & 7 != 0) goto caYd; else goto caYg;
  caYg:
      call (I64[R1])(R1) returns to caYd, args: 8, res: 8, upd: 8;
  caYd:
      _sayx::P64 = R1;
      _caYt::P64 = _sayx::P64 & 7;
      switch [1 .. 2] _caYt::P64 {
          case 1 : goto caYr;
          case 2 : goto caYq;
      }
  caYq:
      _sayy::P64 = P64[_sayx::P64 + 6];
      _sayz::P64 = P64[_sayx::P64 + 14];
      P64[(_saym::P64 + 24) + (_says::I64 << 3)] = _sayy::P64;
      I64[_saym::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
      I8[(_saym::P64 + 24) + (I64[_saym::P64 + 8] << 3) + (_says::I64 >> 7)] = 1 :: W8;
      _caYw::I64 = _says::I64 + 1;
      _sayB::I64 = _caYw::I64;
      R3 = _sayz::P64;
      R2 = _sayB::I64;
      R1 = _sayr::P64;
      call $wa9_sayr_info(R3, R2, R1) args: 8, res: 0, upd: 8;
  caYr:
      R1 = GHC.Tuple.()_closure+1;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:45.22174 UTC

{offset
  caY7:
      _sayt::P64 = R3;
      _says::I64 = R2;
      _sayr::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto caY8; else goto caY9;
  caY9:
      if (HpLim == 0) goto caY8; else goto caYs;
  caY8:
      R3 = _sayt::P64;
      R2 = _says::I64;
      R1 = _sayr::P64;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  caYs:
      _saym::P64 = P64[_sayr::P64 + 5];
      _saxZ::I64 = I64[_sayr::P64 + 13];
      _caY5::I64 = _says::I64 == _saxZ::I64;
      _sayv::I64 = _caY5::I64;
      if (_sayv::I64 != 0) goto caYr; else goto caYf;
  caYf:
      I64[(young<caYd> + 8)] = caYd;
      R1 = _sayt::P64;
      if (R1 & 7 != 0) goto caYd; else goto caYg;
  caYg:
      call (I64[R1])(R1) returns to caYd, args: 8, res: 8, upd: 8;
  caYd:
      _sayx::P64 = R1;
      _caYt::P64 = _sayx::P64 & 7;
      if (_caYt::P64 != 1) goto caYq; else goto caYr;
  caYq:
      _sayy::P64 = P64[_sayx::P64 + 6];
      _sayz::P64 = P64[_sayx::P64 + 14];
      P64[(_saym::P64 + 24) + (_says::I64 << 3)] = _sayy::P64;
      I64[_saym::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
      I8[(_saym::P64 + 24) + (I64[_saym::P64 + 8] << 3) + (_says::I64 >> 7)] = 1 :: W8;
      _caYw::I64 = _says::I64 + 1;
      _sayB::I64 = _caYw::I64;
      R3 = _sayz::P64;
      R2 = _sayB::I64;
      R1 = _sayr::P64;
      call $wa9_sayr_info(R3, R2, R1) args: 8, res: 0, upd: 8;
  caYr:
      R1 = GHC.Tuple.()_closure+1;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:45.224468 UTC

{offset
  caY7:
      _sayt::P64 = R3;
      _says::I64 = R2;
      _sayr::P64 = R1;
      if ((Sp + 8) - 40 < SpLim) goto caY8; else goto caY9;
  caY9:
      if (HpLim == 0) goto caY8; else goto caYs;
  caY8:
      R3 = _sayt::P64;
      R2 = _says::I64;
      R1 = _sayr::P64;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  caYs:
      _saym::P64 = P64[_sayr::P64 + 5];
      _saxZ::I64 = I64[_sayr::P64 + 13];
      _caY5::I64 = _says::I64 == _saxZ::I64;
      _sayv::I64 = _caY5::I64;
      if (_sayv::I64 != 0) goto caYr; else goto caYf;
  caYf:
      I64[Sp - 32] = caYd;
      R1 = _sayt::P64;
      P64[Sp - 24] = _saym::P64;
      P64[Sp - 16] = _sayr::P64;
      I64[Sp - 8] = _says::I64;
      Sp = Sp - 32;
      if (R1 & 7 != 0) goto caYd; else goto caYg;
  caYg:
      call (I64[R1])(R1) returns to caYd, args: 8, res: 8, upd: 8;
  caYd:
      _saym::P64 = P64[Sp + 8];
      _sayr::P64 = P64[Sp + 16];
      _says::I64 = I64[Sp + 24];
      _sayx::P64 = R1;
      _caYt::P64 = _sayx::P64 & 7;
      if (_caYt::P64 != 1) goto caYq; else goto uaZ8;
  caYq:
      _sayy::P64 = P64[_sayx::P64 + 6];
      _sayz::P64 = P64[_sayx::P64 + 14];
      P64[(_saym::P64 + 24) + (_says::I64 << 3)] = _sayy::P64;
      I64[_saym::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
      I8[(_saym::P64 + 24) + (I64[_saym::P64 + 8] << 3) + (_says::I64 >> 7)] = 1 :: W8;
      _caYw::I64 = _says::I64 + 1;
      _sayB::I64 = _caYw::I64;
      R3 = _sayz::P64;
      R2 = _sayB::I64;
      R1 = _sayr::P64;
      Sp = Sp + 32;
      call $wa9_sayr_info(R3, R2, R1) args: 8, res: 0, upd: 8;
  uaZ8:
      Sp = Sp + 32;
      goto caYr;
  caYr:
      R1 = GHC.Tuple.()_closure+1;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:45.227333 UTC

{offset
  caY7:
      _sayt::P64 = R3;
      _says::I64 = R2;
      _sayr::P64 = R1;
      if ((Sp + -32) < SpLim) goto caY8; else goto caY9;
  caY9:
      if (HpLim == 0) goto caY8; else goto caYs;
  caY8:
      R3 = _sayt::P64;
      R2 = _says::I64;
      R1 = _sayr::P64;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  caYs:
      if (_says::I64 == I64[_sayr::P64 + 13]) goto caYr; else goto caYf;
  caYf:
      I64[Sp - 32] = caYd;
      R1 = _sayt::P64;
      P64[Sp - 24] = P64[_sayr::P64 + 5];
      P64[Sp - 16] = _sayr::P64;
      I64[Sp - 8] = _says::I64;
      Sp = Sp - 32;
      if (R1 & 7 != 0) goto caYd; else goto caYg;
  caYg:
      call (I64[R1])(R1) returns to caYd, args: 8, res: 8, upd: 8;
  caYd:
      if (R1 & 7 != 1) goto caYq; else goto uaZ8;
  caYq:
      _saym::P64 = P64[Sp + 8];
      _sayr::P64 = P64[Sp + 16];
      _says::I64 = I64[Sp + 24];
      _sayz::P64 = P64[R1 + 14];
      P64[(_saym::P64 + 24) + (_says::I64 << 3)] = P64[R1 + 6];
      I64[_saym::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
      I8[(_saym::P64 + 24) + ((I64[_saym::P64 + 8] << 3) + (_says::I64 >> 7))] = 1 :: W8;
      R3 = _sayz::P64;
      R2 = _says::I64 + 1;
      R1 = _sayr::P64;
      Sp = Sp + 32;
      call $wa9_sayr_info(R3, R2, R1) args: 8, res: 0, upd: 8;
  uaZ8:
      Sp = Sp + 32;
      goto caYr;
  caYr:
      R1 = GHC.Tuple.()_closure+1;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:45.230244 UTC

[(caY7, {$wa9_sayr_closure}), (caY8, {}),
 (caY9, {$wa9_sayr_closure}), (caYd, {$wa9_sayr_closure}),
 (caYf, {$wa9_sayr_closure}), (caYg, {$wa9_sayr_closure}),
 (caYq, {$wa9_sayr_closure}), (caYr, {}),
 (caYs, {$wa9_sayr_closure}), (uaZ8, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:45.230957 UTC

$wa9_sayr_entry() //  [R3, R2, R1]
        { info_tbl: [(caY7,
                      label: $wa9_sayr_info
                      rep:HeapRep 1 ptrs 1 nonptrs {
                            Fun {arity: 3 fun_type: ArgSpec 13} }),
                     (caYd,
                      label: block_caYd_info
                      rep:StackRep [False, False, True])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caY7:
          _sayt::P64 = R3;
          _says::I64 = R2;
          _sayr::P64 = R1;
          if ((Sp + -32) < SpLim) goto caY8; else goto caY9;
      caY9:
          if (HpLim == 0) goto caY8; else goto caYs;
      caY8:
          R3 = _sayt::P64;
          R2 = _says::I64;
          R1 = _sayr::P64;
          call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
      caYs:
          if (_says::I64 == I64[_sayr::P64 + 13]) goto caYr; else goto caYf;
      caYf:
          I64[Sp - 32] = caYd;
          R1 = _sayt::P64;
          P64[Sp - 24] = P64[_sayr::P64 + 5];
          P64[Sp - 16] = _sayr::P64;
          I64[Sp - 8] = _says::I64;
          Sp = Sp - 32;
          if (R1 & 7 != 0) goto caYd; else goto caYg;
      caYg:
          call (I64[R1])(R1) returns to caYd, args: 8, res: 8, upd: 8;
      caYd:
          if (R1 & 7 != 1) goto caYq; else goto uaZ8;
      caYq:
          _saym::P64 = P64[Sp + 8];
          _sayr::P64 = P64[Sp + 16];
          _says::I64 = I64[Sp + 24];
          _sayz::P64 = P64[R1 + 14];
          P64[(_saym::P64 + 24) + (_says::I64 << 3)] = P64[R1 + 6];
          I64[_saym::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
          I8[(_saym::P64 + 24) + ((I64[_saym::P64 + 8] << 3) + (_says::I64 >> 7))] = 1 :: W8;
          R3 = _sayz::P64;
          R2 = _says::I64 + 1;
          R1 = _sayr::P64;
          Sp = Sp + 32;
          call $wa9_sayr_info(R3, R2, R1) args: 8, res: 0, upd: 8;
      uaZ8:
          Sp = Sp + 32;
          goto caYr;
      caYr:
          R1 = GHC.Tuple.()_closure+1;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:45.233941 UTC

$wa9_sayr_entry() //  [R3, R2, R1]
        { info_tbl: [(caY7,
                      label: $wa9_sayr_info
                      rep:HeapRep 1 ptrs 1 nonptrs {
                            Fun {arity: 3 fun_type: ArgSpec 13} }),
                     (caYd,
                      label: block_caYd_info
                      rep:StackRep [False, False, True])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caY7:
          _sayt::P64 = R3;
          _says::I64 = R2;
          _sayr::P64 = R1;
          if ((Sp + -32) < SpLim) goto caY8; else goto caY9;
      caY9:
          if (HpLim == 0) goto caY8; else goto caYs;
      caY8:
          R3 = _sayt::P64;
          R2 = _says::I64;
          R1 = _sayr::P64;
          call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
      caYs:
          if (_says::I64 == I64[_sayr::P64 + 13]) goto caYr; else goto caYf;
      caYf:
          I64[Sp - 32] = caYd;
          R1 = _sayt::P64;
          P64[Sp - 24] = P64[_sayr::P64 + 5];
          P64[Sp - 16] = _sayr::P64;
          I64[Sp - 8] = _says::I64;
          Sp = Sp - 32;
          if (R1 & 7 != 0) goto caYd; else goto caYg;
      caYg:
          call (I64[R1])(R1) returns to caYd, args: 8, res: 8, upd: 8;
      caYd:
          if (R1 & 7 != 1) goto caYq; else goto uaZ8;
      caYq:
          _saym::P64 = P64[Sp + 8];
          _sayr::P64 = P64[Sp + 16];
          _says::I64 = I64[Sp + 24];
          _sayz::P64 = P64[R1 + 14];
          P64[(_saym::P64 + 24) + (_says::I64 << 3)] = P64[R1 + 6];
          I64[_saym::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
          I8[(_saym::P64 + 24) + ((I64[_saym::P64 + 8] << 3) + (_says::I64 >> 7))] = 1 :: W8;
          R3 = _sayz::P64;
          R2 = _says::I64 + 1;
          R1 = _sayr::P64;
          Sp = Sp + 32;
          call $wa9_sayr_info(R3, R2, R1) args: 8, res: 0, upd: 8;
      uaZ8:
          Sp = Sp + 32;
          goto caYr;
      caYr:
          R1 = GHC.Tuple.()_closure+1;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:45.236943 UTC

{offset
  caYx:
      _sayL::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto caYy; else goto caYz;
  caYz:
      if (HpLim == 0) goto caYy; else goto caYA;
  caYy:
      R1 = _sayL::P64;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  caYA:
      _saxV::P64 = P64[_sayL::P64 + 7];
      _sayd::P64 = P64[_sayL::P64 + 15];
      _saxZ::I64 = I64[_sayL::P64 + 23];
      I64[(young<caXF> + 8)] = caXF;
      R1 = _saxV::P64;
      if (R1 & 7 != 0) goto caXF; else goto caXG;
  caXG:
      call (I64[R1])(R1) returns to caXF, args: 8, res: 8, upd: 8;
  caXF:
      _sayf::P64 = R1;
      _sayg::P64 = P64[_sayf::P64 + 7];
      _sayh::P64 = P64[_sayf::P64 + 15];
      _caXK::I64 = %MO_S_Lt_W64(_saxZ::I64, 0);
      _sayi::I64 = _caXK::I64;
      switch [0 .. 1] _sayi::I64 {
          case 0 : goto caYD;
          case 1 : goto caYS;
      }
  caYS:
      R1 = GHC.Arr.negRange_closure;
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
  caYD:
      I64[(young<caXP> + 8)] = caXP;
      R2 = Data.Array.Base.arrEleBottom_closure;
      R1 = _saxZ::I64;
      call stg_newArray#(R2,
                         R1) returns to caXP, args: 8, res: 8, upd: 8;
  caXP:
      _saym::P64 = R1;
      I64[(young<caXR> + 8)] = caXR;
      R1 = _sayg::P64;
      call stg_ap_0_fast(R1) returns to caXR, args: 8, res: 8, upd: 8;
  caXR:
      _sayn::P64 = R1;
      I64[(young<caXT> + 8)] = caXT;
      R1 = _sayh::P64;
      call stg_ap_0_fast(R1) returns to caXT, args: 8, res: 8, upd: 8;
  caXT:
      _sayo::P64 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto caYI; else goto caYH;
  caYI:
      HpAlloc = 24;
      R1 = _sayo::P64;
      call stg_gc_unpt_r1(R1) returns to caXT, args: 8, res: 8, upd: 8;
  caYH:
      _caXV::I64 = %MO_S_Lt_W64(_saxZ::I64, 0);
      _sayp::I64 = _caXV::I64;
      switch [0 .. 1] _sayp::I64 {
          case 0 : goto caYN;
          case 1 : goto caYR;
      }
  caYR:
      Hp = Hp - 24;
      R1 = SkipList.$fMArrayTArrayeSTM5_closure;
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
  caYN:
      _caY0::P64 = Hp - 13;
      I64[Hp - 16] = $wa9_sayr_info;
      P64[Hp - 8] = _saym::P64;
      I64[Hp] = _saxZ::I64;
      I64[(young<caYJ> + 8)] = caYJ;
      R3 = _sayd::P64;
      R2 = 0;
      R1 = _caY0::P64;
      call $wa9_sayr_info(R3,
                          R2,
                          R1) returns to caYJ, args: 8, res: 8, upd: 8;
  caYJ:
      _sayE::P64 = R1;
      Hp = Hp + 40;
      if (Hp > HpLim) goto caYQ; else goto caYP;
  caYQ:
      HpAlloc = 40;
      R1 = _sayE::P64;
      call stg_gc_unpt_r1(R1) returns to caYJ, args: 8, res: 8, upd: 8;
  caYP:
      I64[_saym::P64] = stg_MUT_ARR_PTRS_FROZEN0_info;
      _sayH::P64 = _saym::P64;
      _sayH::P64 = _sayH::P64;
      I64[Hp - 32] = GHC.Arr.Array_con_info;
      P64[Hp - 24] = _sayn::P64;
      P64[Hp - 16] = _sayo::P64;
      P64[Hp - 8] = _sayH::P64;
      I64[Hp] = _saxZ::I64;
      _caYL::P64 = Hp - 31;
      R1 = _caYL::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:45.24232 UTC

{offset
  caYx:
      _sayL::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto caYy; else goto caYz;
  caYz:
      if (HpLim == 0) goto caYy; else goto caYA;
  caYy:
      R1 = _sayL::P64;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  caYA:
      _saxV::P64 = P64[_sayL::P64 + 7];
      _sayd::P64 = P64[_sayL::P64 + 15];
      _saxZ::I64 = I64[_sayL::P64 + 23];
      I64[(young<caXF> + 8)] = caXF;
      R1 = _saxV::P64;
      if (R1 & 7 != 0) goto caXF; else goto caXG;
  caXG:
      call (I64[R1])(R1) returns to caXF, args: 8, res: 8, upd: 8;
  caXF:
      _sayf::P64 = R1;
      _sayg::P64 = P64[_sayf::P64 + 7];
      _sayh::P64 = P64[_sayf::P64 + 15];
      _caXK::I64 = %MO_S_Lt_W64(_saxZ::I64, 0);
      _sayi::I64 = _caXK::I64;
      switch [0 .. 1] _sayi::I64 {
          case 0 : goto caYD;
          case 1 : goto caYS;
      }
  caYS:
      R1 = GHC.Arr.negRange_closure;
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
  caYD:
      I64[(young<caXP> + 8)] = caXP;
      R2 = Data.Array.Base.arrEleBottom_closure;
      R1 = _saxZ::I64;
      call stg_newArray#(R2,
                         R1) returns to caXP, args: 8, res: 8, upd: 8;
  caXP:
      _saym::P64 = R1;
      I64[(young<caXR> + 8)] = caXR;
      R1 = _sayg::P64;
      call stg_ap_0_fast(R1) returns to caXR, args: 8, res: 8, upd: 8;
  caXR:
      _sayn::P64 = R1;
      I64[(young<caXT> + 8)] = caXT;
      R1 = _sayh::P64;
      call stg_ap_0_fast(R1) returns to caXT, args: 8, res: 8, upd: 8;
  caXT:
      _sayo::P64 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto caYI; else goto caYH;
  caYI:
      HpAlloc = 24;
      R1 = _sayo::P64;
      call stg_gc_unpt_r1(R1) returns to caXT, args: 8, res: 8, upd: 8;
  caYH:
      _caXV::I64 = %MO_S_Lt_W64(_saxZ::I64, 0);
      _sayp::I64 = _caXV::I64;
      switch [0 .. 1] _sayp::I64 {
          case 0 : goto caYN;
          case 1 : goto caYR;
      }
  caYR:
      Hp = Hp - 24;
      R1 = SkipList.$fMArrayTArrayeSTM5_closure;
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
  caYN:
      _caY0::P64 = Hp - 13;
      I64[Hp - 16] = $wa9_sayr_info;
      P64[Hp - 8] = _saym::P64;
      I64[Hp] = _saxZ::I64;
      I64[(young<caYJ> + 8)] = caYJ;
      R3 = _sayd::P64;
      R2 = 0;
      R1 = _caY0::P64;
      call $wa9_sayr_info(R3,
                          R2,
                          R1) returns to caYJ, args: 8, res: 8, upd: 8;
  caYJ:
      _sayE::P64 = R1;
      Hp = Hp + 40;
      if (Hp > HpLim) goto caYQ; else goto caYP;
  caYQ:
      HpAlloc = 40;
      R1 = _sayE::P64;
      call stg_gc_unpt_r1(R1) returns to caYJ, args: 8, res: 8, upd: 8;
  caYP:
      I64[_saym::P64] = stg_MUT_ARR_PTRS_FROZEN0_info;
      _sayH::P64 = _saym::P64;
      _sayH::P64 = _sayH::P64;
      I64[Hp - 32] = GHC.Arr.Array_con_info;
      P64[Hp - 24] = _sayn::P64;
      P64[Hp - 16] = _sayo::P64;
      P64[Hp - 8] = _sayH::P64;
      I64[Hp] = _saxZ::I64;
      _caYL::P64 = Hp - 31;
      R1 = _caYL::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:45.24676 UTC

{offset
  caYx:
      _sayL::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto caYy; else goto caYz;
  caYz:
      if (HpLim == 0) goto caYy; else goto caYA;
  caYy:
      R1 = _sayL::P64;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  caYA:
      _saxV::P64 = P64[_sayL::P64 + 7];
      _sayd::P64 = P64[_sayL::P64 + 15];
      _saxZ::I64 = I64[_sayL::P64 + 23];
      I64[(young<caXF> + 8)] = caXF;
      R1 = _saxV::P64;
      if (R1 & 7 != 0) goto caXF; else goto caXG;
  caXG:
      call (I64[R1])(R1) returns to caXF, args: 8, res: 8, upd: 8;
  caXF:
      _sayf::P64 = R1;
      _sayg::P64 = P64[_sayf::P64 + 7];
      _sayh::P64 = P64[_sayf::P64 + 15];
      _caXK::I64 = %MO_S_Lt_W64(_saxZ::I64, 0);
      _sayi::I64 = _caXK::I64;
      if (_sayi::I64 != 0) goto caYS; else goto caYD;
  caYS:
      R1 = GHC.Arr.negRange_closure;
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
  caYD:
      I64[(young<caXP> + 8)] = caXP;
      R2 = Data.Array.Base.arrEleBottom_closure;
      R1 = _saxZ::I64;
      call stg_newArray#(R2,
                         R1) returns to caXP, args: 8, res: 8, upd: 8;
  caXP:
      _saym::P64 = R1;
      I64[(young<caXR> + 8)] = caXR;
      R1 = _sayg::P64;
      call stg_ap_0_fast(R1) returns to caXR, args: 8, res: 8, upd: 8;
  caXR:
      _sayn::P64 = R1;
      I64[(young<caXT> + 8)] = caXT;
      R1 = _sayh::P64;
      call stg_ap_0_fast(R1) returns to caXT, args: 8, res: 8, upd: 8;
  caXT:
      _sayo::P64 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto caYI; else goto caYH;
  caYI:
      HpAlloc = 24;
      R1 = _sayo::P64;
      call stg_gc_unpt_r1(R1) returns to caXT, args: 8, res: 8, upd: 8;
  caYH:
      _caXV::I64 = %MO_S_Lt_W64(_saxZ::I64, 0);
      _sayp::I64 = _caXV::I64;
      if (_sayp::I64 != 0) goto caYR; else goto caYN;
  caYR:
      Hp = Hp - 24;
      R1 = SkipList.$fMArrayTArrayeSTM5_closure;
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
  caYN:
      _caY0::P64 = Hp - 13;
      I64[Hp - 16] = $wa9_sayr_info;
      P64[Hp - 8] = _saym::P64;
      I64[Hp] = _saxZ::I64;
      I64[(young<caYJ> + 8)] = caYJ;
      R3 = _sayd::P64;
      R2 = 0;
      R1 = _caY0::P64;
      call $wa9_sayr_info(R3,
                          R2,
                          R1) returns to caYJ, args: 8, res: 8, upd: 8;
  caYJ:
      _sayE::P64 = R1;
      Hp = Hp + 40;
      if (Hp > HpLim) goto caYQ; else goto caYP;
  caYQ:
      HpAlloc = 40;
      R1 = _sayE::P64;
      call stg_gc_unpt_r1(R1) returns to caYJ, args: 8, res: 8, upd: 8;
  caYP:
      I64[_saym::P64] = stg_MUT_ARR_PTRS_FROZEN0_info;
      _sayH::P64 = _saym::P64;
      _sayH::P64 = _sayH::P64;
      I64[Hp - 32] = GHC.Arr.Array_con_info;
      P64[Hp - 24] = _sayn::P64;
      P64[Hp - 16] = _sayo::P64;
      P64[Hp - 8] = _sayH::P64;
      I64[Hp] = _saxZ::I64;
      _caYL::P64 = Hp - 31;
      R1 = _caYL::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:45.251622 UTC

{offset
  caYx:
      _sayL::P64 = R1;
      if ((Sp + 8) - 48 < SpLim) goto caYy; else goto caYz;
  caYz:
      if (HpLim == 0) goto caYy; else goto caYA;
  caYy:
      R1 = _sayL::P64;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  caYA:
      _saxV::P64 = P64[_sayL::P64 + 7];
      _sayd::P64 = P64[_sayL::P64 + 15];
      _saxZ::I64 = I64[_sayL::P64 + 23];
      I64[Sp - 24] = caXF;
      R1 = _saxV::P64;
      I64[Sp - 16] = _saxZ::I64;
      P64[Sp - 8] = _sayd::P64;
      Sp = Sp - 24;
      if (R1 & 7 != 0) goto caXF; else goto caXG;
  caXG:
      call (I64[R1])(R1) returns to caXF, args: 8, res: 8, upd: 8;
  caXF:
      _saxZ::I64 = I64[Sp + 8];
      _sayd::P64 = P64[Sp + 16];
      _sayf::P64 = R1;
      _sayg::P64 = P64[_sayf::P64 + 7];
      _sayh::P64 = P64[_sayf::P64 + 15];
      _caXK::I64 = %MO_S_Lt_W64(_saxZ::I64, 0);
      _sayi::I64 = _caXK::I64;
      if (_sayi::I64 != 0) goto caYS; else goto caYD;
  caYS:
      R1 = GHC.Arr.negRange_closure;
      Sp = Sp + 24;
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
  caYD:
      I64[Sp - 16] = caXP;
      R2 = Data.Array.Base.arrEleBottom_closure;
      R1 = _saxZ::I64;
      P64[Sp - 8] = _sayh::P64;
      P64[Sp] = _sayg::P64;
      Sp = Sp - 16;
      call stg_newArray#(R2,
                         R1) returns to caXP, args: 8, res: 8, upd: 8;
  caXP:
      _saxZ::I64 = I64[Sp + 24];
      _sayd::P64 = P64[Sp + 32];
      _sayg::P64 = P64[Sp + 16];
      _sayh::P64 = P64[Sp + 8];
      _saym::P64 = R1;
      I64[Sp] = caXR;
      R1 = _sayg::P64;
      P64[Sp + 16] = _saym::P64;
      call stg_ap_0_fast(R1) returns to caXR, args: 8, res: 8, upd: 8;
  caXR:
      _saxZ::I64 = I64[Sp + 24];
      _sayd::P64 = P64[Sp + 32];
      _sayh::P64 = P64[Sp + 8];
      _saym::P64 = P64[Sp + 16];
      _sayn::P64 = R1;
      I64[Sp] = caXT;
      R1 = _sayh::P64;
      P64[Sp + 8] = _sayn::P64;
      call stg_ap_0_fast(R1) returns to caXT, args: 8, res: 8, upd: 8;
  caXT:
      _saxZ::I64 = I64[Sp + 24];
      _sayd::P64 = P64[Sp + 32];
      _saym::P64 = P64[Sp + 16];
      _sayn::P64 = P64[Sp + 8];
      _sayo::P64 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto caYI; else goto caYH;
  caYI:
      HpAlloc = 24;
      R1 = _sayo::P64;
      call stg_gc_unpt_r1(R1) returns to caXT, args: 8, res: 8, upd: 8;
  caYH:
      _caXV::I64 = %MO_S_Lt_W64(_saxZ::I64, 0);
      _sayp::I64 = _caXV::I64;
      if (_sayp::I64 != 0) goto caYR; else goto caYN;
  caYR:
      Hp = Hp - 24;
      R1 = SkipList.$fMArrayTArrayeSTM5_closure;
      Sp = Sp + 40;
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
  caYN:
      _caY0::P64 = Hp - 13;
      I64[Hp - 16] = $wa9_sayr_info;
      P64[Hp - 8] = _saym::P64;
      I64[Hp] = _saxZ::I64;
      I64[Sp] = caYJ;
      R3 = _sayd::P64;
      R2 = 0;
      R1 = _caY0::P64;
      P64[Sp + 32] = _sayo::P64;
      call $wa9_sayr_info(R3,
                          R2,
                          R1) returns to caYJ, args: 8, res: 8, upd: 8;
  caYJ:
      _saxZ::I64 = I64[Sp + 24];
      _saym::P64 = P64[Sp + 16];
      _sayn::P64 = P64[Sp + 8];
      _sayo::P64 = P64[Sp + 32];
      _sayE::P64 = R1;
      Hp = Hp + 40;
      if (Hp > HpLim) goto caYQ; else goto caYP;
  caYQ:
      HpAlloc = 40;
      R1 = _sayE::P64;
      call stg_gc_unpt_r1(R1) returns to caYJ, args: 8, res: 8, upd: 8;
  caYP:
      I64[_saym::P64] = stg_MUT_ARR_PTRS_FROZEN0_info;
      _sayH::P64 = _saym::P64;
      _sayH::P64 = _sayH::P64;
      I64[Hp - 32] = GHC.Arr.Array_con_info;
      P64[Hp - 24] = _sayn::P64;
      P64[Hp - 16] = _sayo::P64;
      P64[Hp - 8] = _sayH::P64;
      I64[Hp] = _saxZ::I64;
      _caYL::P64 = Hp - 31;
      R1 = _caYL::P64;
      Sp = Sp + 40;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:45.257393 UTC

{offset
  caYx:
      _sayL::P64 = R1;
      if ((Sp + -40) < SpLim) goto caYy; else goto caYz;
  caYz:
      if (HpLim == 0) goto caYy; else goto caYA;
  caYy:
      R1 = _sayL::P64;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  caYA:
      I64[Sp - 24] = caXF;
      R1 = P64[_sayL::P64 + 7];
      I64[Sp - 16] = I64[_sayL::P64 + 23];
      P64[Sp - 8] = P64[_sayL::P64 + 15];
      Sp = Sp - 24;
      if (R1 & 7 != 0) goto caXF; else goto caXG;
  caXG:
      call (I64[R1])(R1) returns to caXF, args: 8, res: 8, upd: 8;
  caXF:
      _saxZ::I64 = I64[Sp + 8];
      if (%MO_S_Lt_W64(_saxZ::I64, 0)) goto caYS; else goto caYD;
  caYS:
      R1 = GHC.Arr.negRange_closure;
      Sp = Sp + 24;
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
  caYD:
      I64[Sp - 16] = caXP;
      R2 = Data.Array.Base.arrEleBottom_closure;
      _sayg::P64 = P64[R1 + 7];
      _sayh::P64 = P64[R1 + 15];
      R1 = _saxZ::I64;
      P64[Sp - 8] = _sayh::P64;
      P64[Sp] = _sayg::P64;
      Sp = Sp - 16;
      call stg_newArray#(R2,
                         R1) returns to caXP, args: 8, res: 8, upd: 8;
  caXP:
      I64[Sp] = caXR;
      _saym::P64 = R1;
      R1 = P64[Sp + 16];
      P64[Sp + 16] = _saym::P64;
      call stg_ap_0_fast(R1) returns to caXR, args: 8, res: 8, upd: 8;
  caXR:
      I64[Sp] = caXT;
      _sayn::P64 = R1;
      R1 = P64[Sp + 8];
      P64[Sp + 8] = _sayn::P64;
      call stg_ap_0_fast(R1) returns to caXT, args: 8, res: 8, upd: 8;
  caXT:
      Hp = Hp + 24;
      if (Hp > HpLim) goto caYI; else goto caYH;
  caYI:
      HpAlloc = 24;
      R1 = R1;
      call stg_gc_unpt_r1(R1) returns to caXT, args: 8, res: 8, upd: 8;
  caYH:
      _saxZ::I64 = I64[Sp + 24];
      if (%MO_S_Lt_W64(_saxZ::I64, 0)) goto caYR; else goto caYN;
  caYR:
      Hp = Hp - 24;
      R1 = SkipList.$fMArrayTArrayeSTM5_closure;
      Sp = Sp + 40;
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
  caYN:
      I64[Hp - 16] = $wa9_sayr_info;
      P64[Hp - 8] = P64[Sp + 16];
      I64[Hp] = _saxZ::I64;
      I64[Sp] = caYJ;
      R3 = P64[Sp + 32];
      R2 = 0;
      _sayo::P64 = R1;
      R1 = Hp - 13;
      P64[Sp + 32] = _sayo::P64;
      call $wa9_sayr_info(R3,
                          R2,
                          R1) returns to caYJ, args: 8, res: 8, upd: 8;
  caYJ:
      Hp = Hp + 40;
      if (Hp > HpLim) goto caYQ; else goto caYP;
  caYQ:
      HpAlloc = 40;
      R1 = R1;
      call stg_gc_unpt_r1(R1) returns to caYJ, args: 8, res: 8, upd: 8;
  caYP:
      _saym::P64 = P64[Sp + 16];
      I64[_saym::P64] = stg_MUT_ARR_PTRS_FROZEN0_info;
      I64[Hp - 32] = GHC.Arr.Array_con_info;
      P64[Hp - 24] = P64[Sp + 8];
      P64[Hp - 16] = P64[Sp + 32];
      P64[Hp - 8] = _saym::P64;
      I64[Hp] = I64[Sp + 24];
      R1 = Hp - 31;
      Sp = Sp + 40;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:45.262676 UTC

[(caXF,
  {GHC.Arr.negRange_closure, Data.Array.Base.arrEleBottom_closure,
   SkipList.$fMArrayTArrayeSTM5_closure, $wa9_sayr_closure}),
 (caXG,
  {GHC.Arr.negRange_closure, Data.Array.Base.arrEleBottom_closure,
   SkipList.$fMArrayTArrayeSTM5_closure, $wa9_sayr_closure}),
 (caXP, {SkipList.$fMArrayTArrayeSTM5_closure, $wa9_sayr_closure}),
 (caXR, {SkipList.$fMArrayTArrayeSTM5_closure, $wa9_sayr_closure}),
 (caXT, {SkipList.$fMArrayTArrayeSTM5_closure, $wa9_sayr_closure}),
 (caYx,
  {GHC.Arr.negRange_closure, Data.Array.Base.arrEleBottom_closure,
   SkipList.$fMArrayTArrayeSTM5_closure, $wa9_sayr_closure}),
 (caYy, {}),
 (caYz,
  {GHC.Arr.negRange_closure, Data.Array.Base.arrEleBottom_closure,
   SkipList.$fMArrayTArrayeSTM5_closure, $wa9_sayr_closure}),
 (caYA,
  {GHC.Arr.negRange_closure, Data.Array.Base.arrEleBottom_closure,
   SkipList.$fMArrayTArrayeSTM5_closure, $wa9_sayr_closure}),
 (caYD,
  {Data.Array.Base.arrEleBottom_closure,
   SkipList.$fMArrayTArrayeSTM5_closure, $wa9_sayr_closure}),
 (caYH, {SkipList.$fMArrayTArrayeSTM5_closure, $wa9_sayr_closure}),
 (caYI, {SkipList.$fMArrayTArrayeSTM5_closure, $wa9_sayr_closure}),
 (caYJ, {}), (caYN, {$wa9_sayr_closure}), (caYP, {}), (caYQ, {}),
 (caYR, {SkipList.$fMArrayTArrayeSTM5_closure}),
 (caYS, {GHC.Arr.negRange_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:45.264546 UTC

sat_sayL_entry() //  [R1]
        { info_tbl: [(caXF,
                      label: block_caXF_info
                      rep:StackRep [True, False]),
                     (caXP,
                      label: block_caXP_info
                      rep:StackRep [False, False, True, False]),
                     (caXR,
                      label: block_caXR_info
                      rep:StackRep [False, False, True, False]),
                     (caXT,
                      label: block_caXT_info
                      rep:StackRep [False, False, True, False]),
                     (caYx,
                      label: sat_sayL_info
                      rep:HeapRep 2 ptrs 1 nonptrs {
                            Fun {arity: 1 fun_type: ArgSpec 3} }),
                     (caYJ,
                      label: block_caYJ_info
                      rep:StackRep [False, False, True, False])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caYx:
          _sayL::P64 = R1;
          if ((Sp + -40) < SpLim) goto caYy; else goto caYz;
      caYz:
          if (HpLim == 0) goto caYy; else goto caYA;
      caYy:
          R1 = _sayL::P64;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
      caYA:
          I64[Sp - 24] = caXF;
          R1 = P64[_sayL::P64 + 7];
          I64[Sp - 16] = I64[_sayL::P64 + 23];
          P64[Sp - 8] = P64[_sayL::P64 + 15];
          Sp = Sp - 24;
          if (R1 & 7 != 0) goto caXF; else goto caXG;
      caXG:
          call (I64[R1])(R1) returns to caXF, args: 8, res: 8, upd: 8;
      caXF:
          _saxZ::I64 = I64[Sp + 8];
          if (%MO_S_Lt_W64(_saxZ::I64, 0)) goto caYS; else goto caYD;
      caYS:
          R1 = GHC.Arr.negRange_closure;
          Sp = Sp + 24;
          call (I64[R1])(R1) args: 8, res: 0, upd: 8;
      caYD:
          I64[Sp - 16] = caXP;
          R2 = Data.Array.Base.arrEleBottom_closure;
          _sayg::P64 = P64[R1 + 7];
          _sayh::P64 = P64[R1 + 15];
          R1 = _saxZ::I64;
          P64[Sp - 8] = _sayh::P64;
          P64[Sp] = _sayg::P64;
          Sp = Sp - 16;
          call stg_newArray#(R2,
                             R1) returns to caXP, args: 8, res: 8, upd: 8;
      caXP:
          I64[Sp] = caXR;
          _saym::P64 = R1;
          R1 = P64[Sp + 16];
          P64[Sp + 16] = _saym::P64;
          call stg_ap_0_fast(R1) returns to caXR, args: 8, res: 8, upd: 8;
      caXR:
          I64[Sp] = caXT;
          _sayn::P64 = R1;
          R1 = P64[Sp + 8];
          P64[Sp + 8] = _sayn::P64;
          call stg_ap_0_fast(R1) returns to caXT, args: 8, res: 8, upd: 8;
      caXT:
          Hp = Hp + 24;
          if (Hp > HpLim) goto caYI; else goto caYH;
      caYI:
          HpAlloc = 24;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to caXT, args: 8, res: 8, upd: 8;
      caYH:
          _saxZ::I64 = I64[Sp + 24];
          if (%MO_S_Lt_W64(_saxZ::I64, 0)) goto caYR; else goto caYN;
      caYR:
          Hp = Hp - 24;
          R1 = SkipList.$fMArrayTArrayeSTM5_closure;
          Sp = Sp + 40;
          call (I64[R1])(R1) args: 8, res: 0, upd: 8;
      caYN:
          I64[Hp - 16] = $wa9_sayr_info;
          P64[Hp - 8] = P64[Sp + 16];
          I64[Hp] = _saxZ::I64;
          I64[Sp] = caYJ;
          R3 = P64[Sp + 32];
          R2 = 0;
          _sayo::P64 = R1;
          R1 = Hp - 13;
          P64[Sp + 32] = _sayo::P64;
          call $wa9_sayr_info(R3,
                              R2,
                              R1) returns to caYJ, args: 8, res: 8, upd: 8;
      caYJ:
          Hp = Hp + 40;
          if (Hp > HpLim) goto caYQ; else goto caYP;
      caYQ:
          HpAlloc = 40;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to caYJ, args: 8, res: 8, upd: 8;
      caYP:
          _saym::P64 = P64[Sp + 16];
          I64[_saym::P64] = stg_MUT_ARR_PTRS_FROZEN0_info;
          I64[Hp - 32] = GHC.Arr.Array_con_info;
          P64[Hp - 24] = P64[Sp + 8];
          P64[Hp - 16] = P64[Sp + 32];
          P64[Hp - 8] = _saym::P64;
          I64[Hp] = I64[Sp + 24];
          R1 = Hp - 31;
          Sp = Sp + 40;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:45.270178 UTC

sat_sayL_entry() //  [R1]
        { info_tbl: [(caXF,
                      label: block_caXF_info
                      rep:StackRep [True, False]),
                     (caXP,
                      label: block_caXP_info
                      rep:StackRep [False, False, True, False]),
                     (caXR,
                      label: block_caXR_info
                      rep:StackRep [False, False, True, False]),
                     (caXT,
                      label: block_caXT_info
                      rep:StackRep [False, False, True, False]),
                     (caYx,
                      label: sat_sayL_info
                      rep:HeapRep 2 ptrs 1 nonptrs {
                            Fun {arity: 1 fun_type: ArgSpec 3} }),
                     (caYJ,
                      label: block_caYJ_info
                      rep:StackRep [False, False, True, False])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caYx:
          _sayL::P64 = R1;
          if ((Sp + -40) < SpLim) goto caYy; else goto caYz;
      caYz:
          if (HpLim == 0) goto caYy; else goto caYA;
      caYy:
          R1 = _sayL::P64;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
      caYA:
          I64[Sp - 24] = caXF;
          R1 = P64[_sayL::P64 + 7];
          I64[Sp - 16] = I64[_sayL::P64 + 23];
          P64[Sp - 8] = P64[_sayL::P64 + 15];
          Sp = Sp - 24;
          if (R1 & 7 != 0) goto caXF; else goto caXG;
      caXG:
          call (I64[R1])(R1) returns to caXF, args: 8, res: 8, upd: 8;
      caXF:
          _saxZ::I64 = I64[Sp + 8];
          if (%MO_S_Lt_W64(_saxZ::I64, 0)) goto caYS; else goto caYD;
      caYS:
          R1 = GHC.Arr.negRange_closure;
          Sp = Sp + 24;
          call (I64[R1])(R1) args: 8, res: 0, upd: 8;
      caYD:
          I64[Sp - 16] = caXP;
          R2 = Data.Array.Base.arrEleBottom_closure;
          _sayg::P64 = P64[R1 + 7];
          _sayh::P64 = P64[R1 + 15];
          R1 = _saxZ::I64;
          P64[Sp - 8] = _sayh::P64;
          P64[Sp] = _sayg::P64;
          Sp = Sp - 16;
          call stg_newArray#(R2,
                             R1) returns to caXP, args: 8, res: 8, upd: 8;
      caXP:
          I64[Sp] = caXR;
          _saym::P64 = R1;
          R1 = P64[Sp + 16];
          P64[Sp + 16] = _saym::P64;
          call stg_ap_0_fast(R1) returns to caXR, args: 8, res: 8, upd: 8;
      caXR:
          I64[Sp] = caXT;
          _sayn::P64 = R1;
          R1 = P64[Sp + 8];
          P64[Sp + 8] = _sayn::P64;
          call stg_ap_0_fast(R1) returns to caXT, args: 8, res: 8, upd: 8;
      caXT:
          Hp = Hp + 24;
          if (Hp > HpLim) goto caYI; else goto caYH;
      caYI:
          HpAlloc = 24;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to caXT, args: 8, res: 8, upd: 8;
      caYH:
          _saxZ::I64 = I64[Sp + 24];
          if (%MO_S_Lt_W64(_saxZ::I64, 0)) goto caYR; else goto caYN;
      caYR:
          Hp = Hp - 24;
          R1 = SkipList.$fMArrayTArrayeSTM5_closure;
          Sp = Sp + 40;
          call (I64[R1])(R1) args: 8, res: 0, upd: 8;
      caYN:
          I64[Hp - 16] = $wa9_sayr_info;
          P64[Hp - 8] = P64[Sp + 16];
          I64[Hp] = _saxZ::I64;
          I64[Sp] = caYJ;
          R3 = P64[Sp + 32];
          R2 = 0;
          _sayo::P64 = R1;
          R1 = Hp - 13;
          P64[Sp + 32] = _sayo::P64;
          call $wa9_sayr_info(R3,
                              R2,
                              R1) returns to caYJ, args: 8, res: 8, upd: 8;
      caYJ:
          Hp = Hp + 40;
          if (Hp > HpLim) goto caYQ; else goto caYP;
      caYQ:
          HpAlloc = 40;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to caYJ, args: 8, res: 8, upd: 8;
      caYP:
          _saym::P64 = P64[Sp + 16];
          I64[_saym::P64] = stg_MUT_ARR_PTRS_FROZEN0_info;
          I64[Hp - 32] = GHC.Arr.Array_con_info;
          P64[Hp - 24] = P64[Sp + 8];
          P64[Hp - 16] = P64[Sp + 32];
          P64[Hp - 8] = _saym::P64;
          I64[Hp] = I64[Sp + 24];
          R1 = Hp - 31;
          Sp = Sp + 40;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:45.275712 UTC

{offset
  caYT:
      _sayM::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto caYU; else goto caYV;
  caYV:
      Hp = Hp + 32;
      if (Hp > HpLim) goto caYX; else goto caYW;
  caYX:
      HpAlloc = 32;
      goto caYU;
  caYU:
      R1 = _sayM::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caYW:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sayM::P64;
      _saxV::P64 = P64[_sayM::P64 + 16];
      _sayd::P64 = P64[_sayM::P64 + 24];
      _saxZ::I64 = I64[_sayM::P64 + 32];
      I64[Hp - 24] = sat_sayL_info;
      P64[Hp - 16] = _saxV::P64;
      P64[Hp - 8] = _sayd::P64;
      I64[Hp] = _saxZ::I64;
      _caXA::P64 = Hp - 23;
      R2 = _caXA::P64;
      call GHC.ST.runSTRep_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:45.277107 UTC

{offset
  caYT:
      _sayM::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto caYU; else goto caYV;
  caYV:
      Hp = Hp + 32;
      if (Hp > HpLim) goto caYX; else goto caYW;
  caYX:
      HpAlloc = 32;
      goto caYU;
  caYU:
      R1 = _sayM::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caYW:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sayM::P64;
      _saxV::P64 = P64[_sayM::P64 + 16];
      _sayd::P64 = P64[_sayM::P64 + 24];
      _saxZ::I64 = I64[_sayM::P64 + 32];
      I64[Hp - 24] = sat_sayL_info;
      P64[Hp - 16] = _saxV::P64;
      P64[Hp - 8] = _sayd::P64;
      I64[Hp] = _saxZ::I64;
      _caXA::P64 = Hp - 23;
      R2 = _caXA::P64;
      call GHC.ST.runSTRep_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:45.278456 UTC

{offset
  caYT:
      _sayM::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto caYU; else goto caYV;
  caYV:
      Hp = Hp + 32;
      if (Hp > HpLim) goto caYX; else goto caYW;
  caYX:
      HpAlloc = 32;
      goto caYU;
  caYU:
      R1 = _sayM::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caYW:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sayM::P64;
      _saxV::P64 = P64[_sayM::P64 + 16];
      _sayd::P64 = P64[_sayM::P64 + 24];
      _saxZ::I64 = I64[_sayM::P64 + 32];
      I64[Hp - 24] = sat_sayL_info;
      P64[Hp - 16] = _saxV::P64;
      P64[Hp - 8] = _sayd::P64;
      I64[Hp] = _saxZ::I64;
      _caXA::P64 = Hp - 23;
      R2 = _caXA::P64;
      call GHC.ST.runSTRep_info(R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:45.279865 UTC

{offset
  caYT:
      _sayM::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto caYU; else goto caYV;
  caYV:
      Hp = Hp + 32;
      if (Hp > HpLim) goto caYX; else goto caYW;
  caYX:
      HpAlloc = 32;
      goto caYU;
  caYU:
      R1 = _sayM::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caYW:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _sayM::P64;
      _saxV::P64 = P64[_sayM::P64 + 16];
      _sayd::P64 = P64[_sayM::P64 + 24];
      _saxZ::I64 = I64[_sayM::P64 + 32];
      I64[Hp - 24] = sat_sayL_info;
      P64[Hp - 16] = _saxV::P64;
      P64[Hp - 8] = _sayd::P64;
      I64[Hp] = _saxZ::I64;
      _caXA::P64 = Hp - 23;
      R2 = _caXA::P64;
      Sp = Sp - 16;
      call GHC.ST.runSTRep_info(R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:45.281216 UTC

{offset
  caYT:
      _sayM::P64 = R1;
      if ((Sp + -16) < SpLim) goto caYU; else goto caYV;
  caYV:
      Hp = Hp + 32;
      if (Hp > HpLim) goto caYX; else goto caYW;
  caYX:
      HpAlloc = 32;
      goto caYU;
  caYU:
      R1 = _sayM::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  caYW:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _sayM::P64;
      _saxV::P64 = P64[_sayM::P64 + 16];
      _sayd::P64 = P64[_sayM::P64 + 24];
      _saxZ::I64 = I64[_sayM::P64 + 32];
      I64[Hp - 24] = sat_sayL_info;
      P64[Hp - 16] = _saxV::P64;
      P64[Hp - 8] = _sayd::P64;
      I64[Hp] = _saxZ::I64;
      R2 = Hp - 23;
      Sp = Sp - 16;
      call GHC.ST.runSTRep_info(R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:45.282702 UTC

[(caYT, {sat_sayL_closure}), (caYU, {}),
 (caYV, {sat_sayL_closure}), (caYW, {sat_sayL_closure}), (caYX, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:45.283143 UTC

sat_sayM_entry() //  [R1]
        { info_tbl: [(caYT,
                      label: sat_sayM_info
                      rep:HeapRep 2 ptrs 1 nonptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caYT:
          _sayM::P64 = R1;
          if ((Sp + -16) < SpLim) goto caYU; else goto caYV;
      caYV:
          Hp = Hp + 32;
          if (Hp > HpLim) goto caYX; else goto caYW;
      caYX:
          HpAlloc = 32;
          goto caYU;
      caYU:
          R1 = _sayM::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      caYW:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _sayM::P64;
          _saxV::P64 = P64[_sayM::P64 + 16];
          _sayd::P64 = P64[_sayM::P64 + 24];
          _saxZ::I64 = I64[_sayM::P64 + 32];
          I64[Hp - 24] = sat_sayL_info;
          P64[Hp - 16] = _saxV::P64;
          P64[Hp - 8] = _sayd::P64;
          I64[Hp] = _saxZ::I64;
          R2 = Hp - 23;
          Sp = Sp - 16;
          call GHC.ST.runSTRep_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:45.284699 UTC

sat_sayM_entry() //  [R1]
        { info_tbl: [(caYT,
                      label: sat_sayM_info
                      rep:HeapRep 2 ptrs 1 nonptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caYT:
          _sayM::P64 = R1;
          if ((Sp + -16) < SpLim) goto caYU; else goto caYV;
      caYV:
          Hp = Hp + 32;
          if (Hp > HpLim) goto caYX; else goto caYW;
      caYX:
          HpAlloc = 32;
          goto caYU;
      caYU:
          R1 = _sayM::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      caYW:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _sayM::P64;
          _saxV::P64 = P64[_sayM::P64 + 16];
          _sayd::P64 = P64[_sayM::P64 + 24];
          _saxZ::I64 = I64[_sayM::P64 + 32];
          I64[Hp - 24] = sat_sayL_info;
          P64[Hp - 16] = _saxV::P64;
          P64[Hp - 8] = _sayd::P64;
          I64[Hp] = _saxZ::I64;
          R2 = Hp - 23;
          Sp = Sp - 16;
          call GHC.ST.runSTRep_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:45.286299 UTC

{offset
  caYY:
      _saxW::P64 = R4;
      _saxV::P64 = R3;
      _saxU::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto caYZ; else goto caZ0;
  caZ0:
      if (HpLim == 0) goto caYZ; else goto caZ1;
  caYZ:
      R4 = _saxW::P64;
      R3 = _saxV::P64;
      R2 = _saxU::P64;
      R1 = SkipList.$fMArrayTArrayeSTM4_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  caZ1:
      I64[(young<caX4> + 8)] = caX4;
      R2 = _saxU::P64;
      I64[(young<caX4> + 24)] = stg_ap_p_info;
      P64[(young<caX4> + 16)] = _saxV::P64;
      call GHC.Arr.rangeSize_info(R2) returns to caX4, args: 24, res: 8, upd: 8;
  caX4:
      _saxY::P64 = R1;
      Hp = Hp + 16;
      if (Hp > HpLim) goto caZ4; else goto caZ3;
  caZ4:
      HpAlloc = 16;
      R1 = _saxY::P64;
      call stg_gc_unpt_r1(R1) returns to caX4, args: 8, res: 8, upd: 8;
  caZ3:
      _saxZ::I64 = I64[_saxY::P64 + 7];
      _caX8::P64 = Hp - 5;
      I64[Hp - 8] = $wa8_say0_info;
      P64[Hp] = _saxW::P64;
      I64[(young<caXu> + 8)] = caXu;
      R3 = GHC.Types.[]_closure+1;
      R2 = _saxZ::I64;
      R1 = _caX8::P64;
      call $wa8_say0_info(R3,
                          R2,
                          R1) returns to caXu, args: 8, res: 8, upd: 8;
  caXu:
      _sayd::P64 = R1;
      Hp = Hp + 40;
      if (Hp > HpLim) goto caZ7; else goto caZ6;
  caZ7:
      HpAlloc = 40;
      R1 = _sayd::P64;
      call stg_gc_unpt_r1(R1) returns to caXu, args: 8, res: 8, upd: 8;
  caZ6:
      I64[Hp - 32] = sat_sayM_info;
      P64[Hp - 16] = _saxV::P64;
      P64[Hp - 8] = _sayd::P64;
      I64[Hp] = _saxZ::I64;
      _caXw::P64 = Hp - 32;
      R1 = _caXw::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:45.288857 UTC

{offset
  caYY:
      _saxW::P64 = R4;
      _saxV::P64 = R3;
      _saxU::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto caYZ; else goto caZ0;
  caZ0:
      if (HpLim == 0) goto caYZ; else goto caZ1;
  caYZ:
      R4 = _saxW::P64;
      R3 = _saxV::P64;
      R2 = _saxU::P64;
      R1 = SkipList.$fMArrayTArrayeSTM4_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  caZ1:
      I64[(young<caX4> + 8)] = caX4;
      R2 = _saxU::P64;
      I64[(young<caX4> + 24)] = stg_ap_p_info;
      P64[(young<caX4> + 16)] = _saxV::P64;
      call GHC.Arr.rangeSize_info(R2) returns to caX4, args: 24, res: 8, upd: 8;
  caX4:
      _saxY::P64 = R1;
      Hp = Hp + 16;
      if (Hp > HpLim) goto caZ4; else goto caZ3;
  caZ4:
      HpAlloc = 16;
      R1 = _saxY::P64;
      call stg_gc_unpt_r1(R1) returns to caX4, args: 8, res: 8, upd: 8;
  caZ3:
      _saxZ::I64 = I64[_saxY::P64 + 7];
      _caX8::P64 = Hp - 5;
      I64[Hp - 8] = $wa8_say0_info;
      P64[Hp] = _saxW::P64;
      I64[(young<caXu> + 8)] = caXu;
      R3 = GHC.Types.[]_closure+1;
      R2 = _saxZ::I64;
      R1 = _caX8::P64;
      call $wa8_say0_info(R3,
                          R2,
                          R1) returns to caXu, args: 8, res: 8, upd: 8;
  caXu:
      _sayd::P64 = R1;
      Hp = Hp + 40;
      if (Hp > HpLim) goto caZ7; else goto caZ6;
  caZ7:
      HpAlloc = 40;
      R1 = _sayd::P64;
      call stg_gc_unpt_r1(R1) returns to caXu, args: 8, res: 8, upd: 8;
  caZ6:
      I64[Hp - 32] = sat_sayM_info;
      P64[Hp - 16] = _saxV::P64;
      P64[Hp - 8] = _sayd::P64;
      I64[Hp] = _saxZ::I64;
      _caXw::P64 = Hp - 32;
      R1 = _caXw::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:45.291455 UTC

{offset
  caYY:
      _saxW::P64 = R4;
      _saxV::P64 = R3;
      _saxU::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto caYZ; else goto caZ0;
  caZ0:
      if (HpLim == 0) goto caYZ; else goto caZ1;
  caYZ:
      R4 = _saxW::P64;
      R3 = _saxV::P64;
      R2 = _saxU::P64;
      R1 = SkipList.$fMArrayTArrayeSTM4_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  caZ1:
      I64[(young<caX4> + 8)] = caX4;
      R2 = _saxU::P64;
      I64[(young<caX4> + 24)] = stg_ap_p_info;
      P64[(young<caX4> + 16)] = _saxV::P64;
      call GHC.Arr.rangeSize_info(R2) returns to caX4, args: 24, res: 8, upd: 8;
  caX4:
      _saxY::P64 = R1;
      Hp = Hp + 16;
      if (Hp > HpLim) goto caZ4; else goto caZ3;
  caZ4:
      HpAlloc = 16;
      R1 = _saxY::P64;
      call stg_gc_unpt_r1(R1) returns to caX4, args: 8, res: 8, upd: 8;
  caZ3:
      _saxZ::I64 = I64[_saxY::P64 + 7];
      _caX8::P64 = Hp - 5;
      I64[Hp - 8] = $wa8_say0_info;
      P64[Hp] = _saxW::P64;
      I64[(young<caXu> + 8)] = caXu;
      R3 = GHC.Types.[]_closure+1;
      R2 = _saxZ::I64;
      R1 = _caX8::P64;
      call $wa8_say0_info(R3,
                          R2,
                          R1) returns to caXu, args: 8, res: 8, upd: 8;
  caXu:
      _sayd::P64 = R1;
      Hp = Hp + 40;
      if (Hp > HpLim) goto caZ7; else goto caZ6;
  caZ7:
      HpAlloc = 40;
      R1 = _sayd::P64;
      call stg_gc_unpt_r1(R1) returns to caXu, args: 8, res: 8, upd: 8;
  caZ6:
      I64[Hp - 32] = sat_sayM_info;
      P64[Hp - 16] = _saxV::P64;
      P64[Hp - 8] = _sayd::P64;
      I64[Hp] = _saxZ::I64;
      _caXw::P64 = Hp - 32;
      R1 = _caXw::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:45.294342 UTC

{offset
  caYY:
      _saxW::P64 = R4;
      _saxV::P64 = R3;
      _saxU::P64 = R2;
      if ((Sp + 8) - 48 < SpLim) goto caYZ; else goto caZ0;
  caZ0:
      if (HpLim == 0) goto caYZ; else goto caZ1;
  caYZ:
      R4 = _saxW::P64;
      R3 = _saxV::P64;
      R2 = _saxU::P64;
      R1 = SkipList.$fMArrayTArrayeSTM4_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  caZ1:
      I64[Sp - 24] = caX4;
      R2 = _saxU::P64;
      I64[Sp - 40] = stg_ap_p_info;
      P64[Sp - 32] = _saxV::P64;
      P64[Sp - 16] = _saxV::P64;
      P64[Sp - 8] = _saxW::P64;
      Sp = Sp - 40;
      call GHC.Arr.rangeSize_info(R2) returns to caX4, args: 24, res: 8, upd: 8;
  caX4:
      _saxV::P64 = P64[Sp + 8];
      _saxW::P64 = P64[Sp + 16];
      _saxY::P64 = R1;
      Hp = Hp + 16;
      if (Hp > HpLim) goto caZ4; else goto caZ3;
  caZ4:
      HpAlloc = 16;
      R1 = _saxY::P64;
      call stg_gc_unpt_r1(R1) returns to caX4, args: 8, res: 8, upd: 8;
  caZ3:
      _saxZ::I64 = I64[_saxY::P64 + 7];
      _caX8::P64 = Hp - 5;
      I64[Hp - 8] = $wa8_say0_info;
      P64[Hp] = _saxW::P64;
      I64[Sp] = caXu;
      R3 = GHC.Types.[]_closure+1;
      R2 = _saxZ::I64;
      R1 = _caX8::P64;
      I64[Sp + 16] = _saxZ::I64;
      call $wa8_say0_info(R3,
                          R2,
                          R1) returns to caXu, args: 8, res: 8, upd: 8;
  caXu:
      _saxV::P64 = P64[Sp + 8];
      _saxZ::I64 = I64[Sp + 16];
      _sayd::P64 = R1;
      Hp = Hp + 40;
      if (Hp > HpLim) goto caZ7; else goto caZ6;
  caZ7:
      HpAlloc = 40;
      R1 = _sayd::P64;
      call stg_gc_unpt_r1(R1) returns to caXu, args: 8, res: 8, upd: 8;
  caZ6:
      I64[Hp - 32] = sat_sayM_info;
      P64[Hp - 16] = _saxV::P64;
      P64[Hp - 8] = _sayd::P64;
      I64[Hp] = _saxZ::I64;
      _caXw::P64 = Hp - 32;
      R1 = _caXw::P64;
      Sp = Sp + 24;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:45.297364 UTC

{offset
  caYY:
      _saxW::P64 = R4;
      _saxV::P64 = R3;
      _saxU::P64 = R2;
      if ((Sp + -40) < SpLim) goto caYZ; else goto caZ0;
  caZ0:
      if (HpLim == 0) goto caYZ; else goto caZ1;
  caYZ:
      R4 = _saxW::P64;
      R3 = _saxV::P64;
      R2 = _saxU::P64;
      R1 = SkipList.$fMArrayTArrayeSTM4_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  caZ1:
      I64[Sp - 24] = caX4;
      R2 = _saxU::P64;
      I64[Sp - 40] = stg_ap_p_info;
      P64[Sp - 32] = _saxV::P64;
      P64[Sp - 16] = _saxV::P64;
      P64[Sp - 8] = _saxW::P64;
      Sp = Sp - 40;
      call GHC.Arr.rangeSize_info(R2) returns to caX4, args: 24, res: 8, upd: 8;
  caX4:
      Hp = Hp + 16;
      if (Hp > HpLim) goto caZ4; else goto caZ3;
  caZ4:
      HpAlloc = 16;
      R1 = R1;
      call stg_gc_unpt_r1(R1) returns to caX4, args: 8, res: 8, upd: 8;
  caZ3:
      _saxZ::I64 = I64[R1 + 7];
      I64[Hp - 8] = $wa8_say0_info;
      P64[Hp] = P64[Sp + 16];
      I64[Sp] = caXu;
      R3 = GHC.Types.[]_closure+1;
      R2 = _saxZ::I64;
      R1 = Hp - 5;
      I64[Sp + 16] = _saxZ::I64;
      call $wa8_say0_info(R3,
                          R2,
                          R1) returns to caXu, args: 8, res: 8, upd: 8;
  caXu:
      Hp = Hp + 40;
      if (Hp > HpLim) goto caZ7; else goto caZ6;
  caZ7:
      HpAlloc = 40;
      R1 = R1;
      call stg_gc_unpt_r1(R1) returns to caXu, args: 8, res: 8, upd: 8;
  caZ6:
      I64[Hp - 32] = sat_sayM_info;
      P64[Hp - 16] = P64[Sp + 8];
      P64[Hp - 8] = R1;
      I64[Hp] = I64[Sp + 16];
      R1 = Hp - 32;
      Sp = Sp + 24;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:45.300395 UTC

[(caX4, {$wa8_say0_closure, sat_sayM_closure}),
 (caXu, {sat_sayM_closure}),
 (caYY,
  {SkipList.$fMArrayTArrayeSTM4_closure, $wa8_say0_closure,
   sat_sayM_closure}),
 (caYZ, {SkipList.$fMArrayTArrayeSTM4_closure}),
 (caZ0,
  {SkipList.$fMArrayTArrayeSTM4_closure, $wa8_say0_closure,
   sat_sayM_closure}),
 (caZ1, {$wa8_say0_closure, sat_sayM_closure}),
 (caZ3, {$wa8_say0_closure, sat_sayM_closure}),
 (caZ4, {$wa8_say0_closure, sat_sayM_closure}),
 (caZ6, {sat_sayM_closure}), (caZ7, {sat_sayM_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:45.30221 UTC

SkipList.$fMArrayTArrayeSTM4_entry() //  [R4, R3, R2]
        { info_tbl: [(caX4,
                      label: block_caX4_info
                      rep:StackRep [False, False]),
                     (caXu,
                      label: block_caXu_info
                      rep:StackRep [False, True]),
                     (caYY,
                      label: SkipList.$fMArrayTArrayeSTM4_info
                      rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caYY:
          _saxW::P64 = R4;
          _saxV::P64 = R3;
          _saxU::P64 = R2;
          if ((Sp + -40) < SpLim) goto caYZ; else goto caZ0;
      caZ0:
          if (HpLim == 0) goto caYZ; else goto caZ1;
      caYZ:
          R4 = _saxW::P64;
          R3 = _saxV::P64;
          R2 = _saxU::P64;
          R1 = SkipList.$fMArrayTArrayeSTM4_closure;
          call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
      caZ1:
          I64[Sp - 24] = caX4;
          R2 = _saxU::P64;
          I64[Sp - 40] = stg_ap_p_info;
          P64[Sp - 32] = _saxV::P64;
          P64[Sp - 16] = _saxV::P64;
          P64[Sp - 8] = _saxW::P64;
          Sp = Sp - 40;
          call GHC.Arr.rangeSize_info(R2) returns to caX4, args: 24, res: 8, upd: 8;
      caX4:
          Hp = Hp + 16;
          if (Hp > HpLim) goto caZ4; else goto caZ3;
      caZ4:
          HpAlloc = 16;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to caX4, args: 8, res: 8, upd: 8;
      caZ3:
          _saxZ::I64 = I64[R1 + 7];
          I64[Hp - 8] = $wa8_say0_info;
          P64[Hp] = P64[Sp + 16];
          I64[Sp] = caXu;
          R3 = GHC.Types.[]_closure+1;
          R2 = _saxZ::I64;
          R1 = Hp - 5;
          I64[Sp + 16] = _saxZ::I64;
          call $wa8_say0_info(R3,
                              R2,
                              R1) returns to caXu, args: 8, res: 8, upd: 8;
      caXu:
          Hp = Hp + 40;
          if (Hp > HpLim) goto caZ7; else goto caZ6;
      caZ7:
          HpAlloc = 40;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to caXu, args: 8, res: 8, upd: 8;
      caZ6:
          I64[Hp - 32] = sat_sayM_info;
          P64[Hp - 16] = P64[Sp + 8];
          P64[Hp - 8] = R1;
          I64[Hp] = I64[Sp + 16];
          R1 = Hp - 32;
          Sp = Sp + 24;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:45.305446 UTC

SkipList.$fMArrayTArrayeSTM4_entry() //  [R4, R3, R2]
        { info_tbl: [(caX4,
                      label: block_caX4_info
                      rep:StackRep [False, False]),
                     (caXu,
                      label: block_caXu_info
                      rep:StackRep [False, True]),
                     (caYY,
                      label: SkipList.$fMArrayTArrayeSTM4_info
                      rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caYY:
          _saxW::P64 = R4;
          _saxV::P64 = R3;
          _saxU::P64 = R2;
          if ((Sp + -40) < SpLim) goto caYZ; else goto caZ0;
      caZ0:
          if (HpLim == 0) goto caYZ; else goto caZ1;
      caYZ:
          R4 = _saxW::P64;
          R3 = _saxV::P64;
          R2 = _saxU::P64;
          R1 = SkipList.$fMArrayTArrayeSTM4_closure;
          call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
      caZ1:
          I64[Sp - 24] = caX4;
          R2 = _saxU::P64;
          I64[Sp - 40] = stg_ap_p_info;
          P64[Sp - 32] = _saxV::P64;
          P64[Sp - 16] = _saxV::P64;
          P64[Sp - 8] = _saxW::P64;
          Sp = Sp - 40;
          call GHC.Arr.rangeSize_info(R2) returns to caX4, args: 24, res: 8, upd: 8;
      caX4:
          Hp = Hp + 16;
          if (Hp > HpLim) goto caZ4; else goto caZ3;
      caZ4:
          HpAlloc = 16;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to caX4, args: 8, res: 8, upd: 8;
      caZ3:
          _saxZ::I64 = I64[R1 + 7];
          I64[Hp - 8] = $wa8_say0_info;
          P64[Hp] = P64[Sp + 16];
          I64[Sp] = caXu;
          R3 = GHC.Types.[]_closure+1;
          R2 = _saxZ::I64;
          R1 = Hp - 5;
          I64[Sp + 16] = _saxZ::I64;
          call $wa8_say0_info(R3,
                              R2,
                              R1) returns to caXu, args: 8, res: 8, upd: 8;
      caXu:
          Hp = Hp + 40;
          if (Hp > HpLim) goto caZ7; else goto caZ6;
      caZ7:
          HpAlloc = 40;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to caXu, args: 8, res: 8, upd: 8;
      caZ6:
          I64[Hp - 32] = sat_sayM_info;
          P64[Hp - 16] = P64[Sp + 8];
          P64[Hp - 8] = R1;
          I64[Hp] = I64[Sp + 16];
          R1 = Hp - 32;
          Sp = Sp + 24;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:45.308646 UTC

[section "data" {
     SkipList.$fMArrayTArrayeSTM4_closure:
         const SkipList.$fMArrayTArrayeSTM4_info;
         const 0;
 },
 $wa8_say0_entry() //  [R3, R2, R1]
         { info_tbl: [(caXh,
                       label: $wa8_say0_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 13} }),
                      (caXl,
                       label: block_caXl_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caXh:
           _say2::P64 = R3;
           _say1::I64 = R2;
           _say0::P64 = R1;
           if ((Sp + -32) < SpLim) goto caXi; else goto caXj;
       caXj:
           if (HpLim == 0) goto caXi; else goto caXs;
       caXi:
           R3 = _say2::P64;
           R2 = _say1::I64;
           R1 = _say0::P64;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caXs:
           if (_say1::I64 != 0) goto caXf; else goto caXg;
       caXf:
           I64[Sp - 32] = caXl;
           R1 = P64[_say0::P64 + 5];
           P64[Sp - 24] = _say0::P64;
           P64[Sp - 16] = _say2::P64;
           I64[Sp - 8] = _say1::I64;
           Sp = Sp - 32;
           call stg_newNOrecTVar#(R1) returns to caXl, args: 8, res: 8, upd: 8;
       caXl:
           Hp = Hp + 40;
           if (Hp > HpLim) goto caXr; else goto caXq;
       caXr:
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to caXl, args: 8, res: 8, upd: 8;
       caXq:
           I64[Hp - 32] = GHC.Conc.Sync.TVar_con_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = P64[Sp + 16];
           R3 = Hp - 14;
           R2 = I64[Sp + 24] - 1;
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call $wa8_say0_info(R3, R2, R1) args: 8, res: 0, upd: 8;
       caXg:
           R1 = _say2::P64;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 },
 $wa9_sayr_entry() //  [R3, R2, R1]
         { info_tbl: [(caY7,
                       label: $wa9_sayr_info
                       rep:HeapRep 1 ptrs 1 nonptrs {
                             Fun {arity: 3 fun_type: ArgSpec 13} }),
                      (caYd,
                       label: block_caYd_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caY7:
           _sayt::P64 = R3;
           _says::I64 = R2;
           _sayr::P64 = R1;
           if ((Sp + -32) < SpLim) goto caY8; else goto caY9;
       caY9:
           if (HpLim == 0) goto caY8; else goto caYs;
       caY8:
           R3 = _sayt::P64;
           R2 = _says::I64;
           R1 = _sayr::P64;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caYs:
           if (_says::I64 == I64[_sayr::P64 + 13]) goto caYr; else goto caYf;
       caYf:
           I64[Sp - 32] = caYd;
           R1 = _sayt::P64;
           P64[Sp - 24] = P64[_sayr::P64 + 5];
           P64[Sp - 16] = _sayr::P64;
           I64[Sp - 8] = _says::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto caYd; else goto caYg;
       caYg:
           call (I64[R1])(R1) returns to caYd, args: 8, res: 8, upd: 8;
       caYd:
           if (R1 & 7 != 1) goto caYq; else goto uaZ8;
       caYq:
           _saym::P64 = P64[Sp + 8];
           _sayr::P64 = P64[Sp + 16];
           _says::I64 = I64[Sp + 24];
           _sayz::P64 = P64[R1 + 14];
           P64[(_saym::P64 + 24) + (_says::I64 << 3)] = P64[R1 + 6];
           I64[_saym::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
           I8[(_saym::P64 + 24) + ((I64[_saym::P64 + 8] << 3) + (_says::I64 >> 7))] = 1 :: W8;
           R3 = _sayz::P64;
           R2 = _says::I64 + 1;
           R1 = _sayr::P64;
           Sp = Sp + 32;
           call $wa9_sayr_info(R3, R2, R1) args: 8, res: 0, upd: 8;
       uaZ8:
           Sp = Sp + 32;
           goto caYr;
       caYr:
           R1 = GHC.Tuple.()_closure+1;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sayL_entry() //  [R1]
         { info_tbl: [(caXF,
                       label: block_caXF_info
                       rep:StackRep [True, False]),
                      (caXP,
                       label: block_caXP_info
                       rep:StackRep [False, False, True, False]),
                      (caXR,
                       label: block_caXR_info
                       rep:StackRep [False, False, True, False]),
                      (caXT,
                       label: block_caXT_info
                       rep:StackRep [False, False, True, False]),
                      (caYx,
                       label: sat_sayL_info
                       rep:HeapRep 2 ptrs 1 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} }),
                      (caYJ,
                       label: block_caYJ_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caYx:
           _sayL::P64 = R1;
           if ((Sp + -40) < SpLim) goto caYy; else goto caYz;
       caYz:
           if (HpLim == 0) goto caYy; else goto caYA;
       caYy:
           R1 = _sayL::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caYA:
           I64[Sp - 24] = caXF;
           R1 = P64[_sayL::P64 + 7];
           I64[Sp - 16] = I64[_sayL::P64 + 23];
           P64[Sp - 8] = P64[_sayL::P64 + 15];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto caXF; else goto caXG;
       caXG:
           call (I64[R1])(R1) returns to caXF, args: 8, res: 8, upd: 8;
       caXF:
           _saxZ::I64 = I64[Sp + 8];
           if (%MO_S_Lt_W64(_saxZ::I64, 0)) goto caYS; else goto caYD;
       caYS:
           R1 = GHC.Arr.negRange_closure;
           Sp = Sp + 24;
           call (I64[R1])(R1) args: 8, res: 0, upd: 8;
       caYD:
           I64[Sp - 16] = caXP;
           R2 = Data.Array.Base.arrEleBottom_closure;
           _sayg::P64 = P64[R1 + 7];
           _sayh::P64 = P64[R1 + 15];
           R1 = _saxZ::I64;
           P64[Sp - 8] = _sayh::P64;
           P64[Sp] = _sayg::P64;
           Sp = Sp - 16;
           call stg_newArray#(R2,
                              R1) returns to caXP, args: 8, res: 8, upd: 8;
       caXP:
           I64[Sp] = caXR;
           _saym::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _saym::P64;
           call stg_ap_0_fast(R1) returns to caXR, args: 8, res: 8, upd: 8;
       caXR:
           I64[Sp] = caXT;
           _sayn::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sayn::P64;
           call stg_ap_0_fast(R1) returns to caXT, args: 8, res: 8, upd: 8;
       caXT:
           Hp = Hp + 24;
           if (Hp > HpLim) goto caYI; else goto caYH;
       caYI:
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to caXT, args: 8, res: 8, upd: 8;
       caYH:
           _saxZ::I64 = I64[Sp + 24];
           if (%MO_S_Lt_W64(_saxZ::I64, 0)) goto caYR; else goto caYN;
       caYR:
           Hp = Hp - 24;
           R1 = SkipList.$fMArrayTArrayeSTM5_closure;
           Sp = Sp + 40;
           call (I64[R1])(R1) args: 8, res: 0, upd: 8;
       caYN:
           I64[Hp - 16] = $wa9_sayr_info;
           P64[Hp - 8] = P64[Sp + 16];
           I64[Hp] = _saxZ::I64;
           I64[Sp] = caYJ;
           R3 = P64[Sp + 32];
           R2 = 0;
           _sayo::P64 = R1;
           R1 = Hp - 13;
           P64[Sp + 32] = _sayo::P64;
           call $wa9_sayr_info(R3,
                               R2,
                               R1) returns to caYJ, args: 8, res: 8, upd: 8;
       caYJ:
           Hp = Hp + 40;
           if (Hp > HpLim) goto caYQ; else goto caYP;
       caYQ:
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to caYJ, args: 8, res: 8, upd: 8;
       caYP:
           _saym::P64 = P64[Sp + 16];
           I64[_saym::P64] = stg_MUT_ARR_PTRS_FROZEN0_info;
           I64[Hp - 32] = GHC.Arr.Array_con_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = _saym::P64;
           I64[Hp] = I64[Sp + 24];
           R1 = Hp - 31;
           Sp = Sp + 40;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sayM_entry() //  [R1]
         { info_tbl: [(caYT,
                       label: sat_sayM_info
                       rep:HeapRep 2 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caYT:
           _sayM::P64 = R1;
           if ((Sp + -16) < SpLim) goto caYU; else goto caYV;
       caYV:
           Hp = Hp + 32;
           if (Hp > HpLim) goto caYX; else goto caYW;
       caYX:
           HpAlloc = 32;
           goto caYU;
       caYU:
           R1 = _sayM::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caYW:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sayM::P64;
           _saxV::P64 = P64[_sayM::P64 + 16];
           _sayd::P64 = P64[_sayM::P64 + 24];
           _saxZ::I64 = I64[_sayM::P64 + 32];
           I64[Hp - 24] = sat_sayL_info;
           P64[Hp - 16] = _saxV::P64;
           P64[Hp - 8] = _sayd::P64;
           I64[Hp] = _saxZ::I64;
           R2 = Hp - 23;
           Sp = Sp - 16;
           call GHC.ST.runSTRep_info(R2) args: 24, res: 0, upd: 24;
     }
 },
 SkipList.$fMArrayTArrayeSTM4_entry() //  [R4, R3, R2]
         { info_tbl: [(caX4,
                       label: block_caX4_info
                       rep:StackRep [False, False]),
                      (caXu,
                       label: block_caXu_info
                       rep:StackRep [False, True]),
                      (caYY,
                       label: SkipList.$fMArrayTArrayeSTM4_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caYY:
           _saxW::P64 = R4;
           _saxV::P64 = R3;
           _saxU::P64 = R2;
           if ((Sp + -40) < SpLim) goto caYZ; else goto caZ0;
       caZ0:
           if (HpLim == 0) goto caYZ; else goto caZ1;
       caYZ:
           R4 = _saxW::P64;
           R3 = _saxV::P64;
           R2 = _saxU::P64;
           R1 = SkipList.$fMArrayTArrayeSTM4_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caZ1:
           I64[Sp - 24] = caX4;
           R2 = _saxU::P64;
           I64[Sp - 40] = stg_ap_p_info;
           P64[Sp - 32] = _saxV::P64;
           P64[Sp - 16] = _saxV::P64;
           P64[Sp - 8] = _saxW::P64;
           Sp = Sp - 40;
           call GHC.Arr.rangeSize_info(R2) returns to caX4, args: 24, res: 8, upd: 8;
       caX4:
           Hp = Hp + 16;
           if (Hp > HpLim) goto caZ4; else goto caZ3;
       caZ4:
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to caX4, args: 8, res: 8, upd: 8;
       caZ3:
           _saxZ::I64 = I64[R1 + 7];
           I64[Hp - 8] = $wa8_say0_info;
           P64[Hp] = P64[Sp + 16];
           I64[Sp] = caXu;
           R3 = GHC.Types.[]_closure+1;
           R2 = _saxZ::I64;
           R1 = Hp - 5;
           I64[Sp + 16] = _saxZ::I64;
           call $wa8_say0_info(R3,
                               R2,
                               R1) returns to caXu, args: 8, res: 8, upd: 8;
       caXu:
           Hp = Hp + 40;
           if (Hp > HpLim) goto caZ7; else goto caZ6;
       caZ7:
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to caXu, args: 8, res: 8, upd: 8;
       caZ6:
           I64[Hp - 32] = sat_sayM_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 16];
           R1 = Hp - 32;
           Sp = Sp + 24;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:45.324676 UTC

[section "data" {
     SkipList.$fMArrayTArrayeSTM4_closure:
         const SkipList.$fMArrayTArrayeSTM4_info;
         const 0;
 },
 $wa8_say0_entry() //  [R3, R2, R1]
         { info_tbl: [(caXh,
                       label: $wa8_say0_info
                       rep:HeapRep 1 ptrs { Fun {arity: 3 fun_type: ArgSpec 13} }),
                      (caXl,
                       label: block_caXl_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caXh:
           _say2::P64 = R3;
           _say1::I64 = R2;
           _say0::P64 = R1;
           if ((Sp + -32) < SpLim) goto caXi; else goto caXj;
       caXj:
           if (HpLim == 0) goto caXi; else goto caXs;
       caXi:
           R3 = _say2::P64;
           R2 = _say1::I64;
           R1 = _say0::P64;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caXs:
           if (_say1::I64 != 0) goto caXf; else goto caXg;
       caXf:
           I64[Sp - 32] = caXl;
           R1 = P64[_say0::P64 + 5];
           P64[Sp - 24] = _say0::P64;
           P64[Sp - 16] = _say2::P64;
           I64[Sp - 8] = _say1::I64;
           Sp = Sp - 32;
           call stg_newNOrecTVar#(R1) returns to caXl, args: 8, res: 8, upd: 8;
       caXl:
           Hp = Hp + 40;
           if (Hp > HpLim) goto caXr; else goto caXq;
       caXr:
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to caXl, args: 8, res: 8, upd: 8;
       caXq:
           I64[Hp - 32] = GHC.Conc.Sync.TVar_con_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = P64[Sp + 16];
           R3 = Hp - 14;
           R2 = I64[Sp + 24] - 1;
           R1 = P64[Sp + 8];
           Sp = Sp + 32;
           call $wa8_say0_info(R3, R2, R1) args: 8, res: 0, upd: 8;
       caXg:
           R1 = _say2::P64;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 },
 $wa9_sayr_entry() //  [R3, R2, R1]
         { info_tbl: [(caY7,
                       label: $wa9_sayr_info
                       rep:HeapRep 1 ptrs 1 nonptrs {
                             Fun {arity: 3 fun_type: ArgSpec 13} }),
                      (caYd,
                       label: block_caYd_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caY7:
           _sayt::P64 = R3;
           _says::I64 = R2;
           _sayr::P64 = R1;
           if ((Sp + -32) < SpLim) goto caY8; else goto caY9;
       caY9:
           if (HpLim == 0) goto caY8; else goto caYs;
       caY8:
           R3 = _sayt::P64;
           R2 = _says::I64;
           R1 = _sayr::P64;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       caYs:
           if (_says::I64 == I64[_sayr::P64 + 13]) goto caYr; else goto caYf;
       caYf:
           I64[Sp - 32] = caYd;
           R1 = _sayt::P64;
           P64[Sp - 24] = P64[_sayr::P64 + 5];
           P64[Sp - 16] = _sayr::P64;
           I64[Sp - 8] = _says::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto caYd; else goto caYg;
       caYg:
           call (I64[R1])(R1) returns to caYd, args: 8, res: 8, upd: 8;
       caYd:
           if (R1 & 7 != 1) goto caYq; else goto uaZ8;
       caYq:
           _saym::P64 = P64[Sp + 8];
           _sayr::P64 = P64[Sp + 16];
           _says::I64 = I64[Sp + 24];
           _sayz::P64 = P64[R1 + 14];
           P64[(_saym::P64 + 24) + (_says::I64 << 3)] = P64[R1 + 6];
           I64[_saym::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
           I8[(_saym::P64 + 24) + ((I64[_saym::P64 + 8] << 3) + (_says::I64 >> 7))] = 1 :: W8;
           R3 = _sayz::P64;
           R2 = _says::I64 + 1;
           R1 = _sayr::P64;
           Sp = Sp + 32;
           call $wa9_sayr_info(R3, R2, R1) args: 8, res: 0, upd: 8;
       uaZ8:
           Sp = Sp + 32;
           goto caYr;
       caYr:
           R1 = GHC.Tuple.()_closure+1;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sayL_entry() //  [R1]
         { info_tbl: [(caXF,
                       label: block_caXF_info
                       rep:StackRep [True, False]),
                      (caXP,
                       label: block_caXP_info
                       rep:StackRep [False, False, True, False]),
                      (caXR,
                       label: block_caXR_info
                       rep:StackRep [False, False, True, False]),
                      (caXT,
                       label: block_caXT_info
                       rep:StackRep [False, False, True, False]),
                      (caYx,
                       label: sat_sayL_info
                       rep:HeapRep 2 ptrs 1 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} }),
                      (caYJ,
                       label: block_caYJ_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caYx:
           _sayL::P64 = R1;
           if ((Sp + -40) < SpLim) goto caYy; else goto caYz;
       caYz:
           if (HpLim == 0) goto caYy; else goto caYA;
       caYy:
           R1 = _sayL::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       caYA:
           I64[Sp - 24] = caXF;
           R1 = P64[_sayL::P64 + 7];
           I64[Sp - 16] = I64[_sayL::P64 + 23];
           P64[Sp - 8] = P64[_sayL::P64 + 15];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto caXF; else goto caXG;
       caXG:
           call (I64[R1])(R1) returns to caXF, args: 8, res: 8, upd: 8;
       caXF:
           _saxZ::I64 = I64[Sp + 8];
           if (%MO_S_Lt_W64(_saxZ::I64, 0)) goto caYS; else goto caYD;
       caYS:
           R1 = GHC.Arr.negRange_closure;
           Sp = Sp + 24;
           call (I64[R1])(R1) args: 8, res: 0, upd: 8;
       caYD:
           I64[Sp - 16] = caXP;
           R2 = Data.Array.Base.arrEleBottom_closure;
           _sayg::P64 = P64[R1 + 7];
           _sayh::P64 = P64[R1 + 15];
           R1 = _saxZ::I64;
           P64[Sp - 8] = _sayh::P64;
           P64[Sp] = _sayg::P64;
           Sp = Sp - 16;
           call stg_newArray#(R2,
                              R1) returns to caXP, args: 8, res: 8, upd: 8;
       caXP:
           I64[Sp] = caXR;
           _saym::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _saym::P64;
           call stg_ap_0_fast(R1) returns to caXR, args: 8, res: 8, upd: 8;
       caXR:
           I64[Sp] = caXT;
           _sayn::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sayn::P64;
           call stg_ap_0_fast(R1) returns to caXT, args: 8, res: 8, upd: 8;
       caXT:
           Hp = Hp + 24;
           if (Hp > HpLim) goto caYI; else goto caYH;
       caYI:
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to caXT, args: 8, res: 8, upd: 8;
       caYH:
           _saxZ::I64 = I64[Sp + 24];
           if (%MO_S_Lt_W64(_saxZ::I64, 0)) goto caYR; else goto caYN;
       caYR:
           Hp = Hp - 24;
           R1 = SkipList.$fMArrayTArrayeSTM5_closure;
           Sp = Sp + 40;
           call (I64[R1])(R1) args: 8, res: 0, upd: 8;
       caYN:
           I64[Hp - 16] = $wa9_sayr_info;
           P64[Hp - 8] = P64[Sp + 16];
           I64[Hp] = _saxZ::I64;
           I64[Sp] = caYJ;
           R3 = P64[Sp + 32];
           R2 = 0;
           _sayo::P64 = R1;
           R1 = Hp - 13;
           P64[Sp + 32] = _sayo::P64;
           call $wa9_sayr_info(R3,
                               R2,
                               R1) returns to caYJ, args: 8, res: 8, upd: 8;
       caYJ:
           Hp = Hp + 40;
           if (Hp > HpLim) goto caYQ; else goto caYP;
       caYQ:
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to caYJ, args: 8, res: 8, upd: 8;
       caYP:
           _saym::P64 = P64[Sp + 16];
           I64[_saym::P64] = stg_MUT_ARR_PTRS_FROZEN0_info;
           I64[Hp - 32] = GHC.Arr.Array_con_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = _saym::P64;
           I64[Hp] = I64[Sp + 24];
           R1 = Hp - 31;
           Sp = Sp + 40;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sayM_entry() //  [R1]
         { info_tbl: [(caYT,
                       label: sat_sayM_info
                       rep:HeapRep 2 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caYT:
           _sayM::P64 = R1;
           if ((Sp + -16) < SpLim) goto caYU; else goto caYV;
       caYV:
           Hp = Hp + 32;
           if (Hp > HpLim) goto caYX; else goto caYW;
       caYX:
           HpAlloc = 32;
           goto caYU;
       caYU:
           R1 = _sayM::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       caYW:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sayM::P64;
           _saxV::P64 = P64[_sayM::P64 + 16];
           _sayd::P64 = P64[_sayM::P64 + 24];
           _saxZ::I64 = I64[_sayM::P64 + 32];
           I64[Hp - 24] = sat_sayL_info;
           P64[Hp - 16] = _saxV::P64;
           P64[Hp - 8] = _sayd::P64;
           I64[Hp] = _saxZ::I64;
           R2 = Hp - 23;
           Sp = Sp - 16;
           call GHC.ST.runSTRep_info(R2) args: 24, res: 0, upd: 24;
     }
 },
 SkipList.$fMArrayTArrayeSTM4_entry() //  [R4, R3, R2]
         { info_tbl: [(caX4,
                       label: block_caX4_info
                       rep:StackRep [False, False]),
                      (caXu,
                       label: block_caXu_info
                       rep:StackRep [False, True]),
                      (caYY,
                       label: SkipList.$fMArrayTArrayeSTM4_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caYY:
           _saxW::P64 = R4;
           _saxV::P64 = R3;
           _saxU::P64 = R2;
           if ((Sp + -40) < SpLim) goto caYZ; else goto caZ0;
       caZ0:
           if (HpLim == 0) goto caYZ; else goto caZ1;
       caYZ:
           R4 = _saxW::P64;
           R3 = _saxV::P64;
           R2 = _saxU::P64;
           R1 = SkipList.$fMArrayTArrayeSTM4_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caZ1:
           I64[Sp - 24] = caX4;
           R2 = _saxU::P64;
           I64[Sp - 40] = stg_ap_p_info;
           P64[Sp - 32] = _saxV::P64;
           P64[Sp - 16] = _saxV::P64;
           P64[Sp - 8] = _saxW::P64;
           Sp = Sp - 40;
           call GHC.Arr.rangeSize_info(R2) returns to caX4, args: 24, res: 8, upd: 8;
       caX4:
           Hp = Hp + 16;
           if (Hp > HpLim) goto caZ4; else goto caZ3;
       caZ4:
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to caX4, args: 8, res: 8, upd: 8;
       caZ3:
           _saxZ::I64 = I64[R1 + 7];
           I64[Hp - 8] = $wa8_say0_info;
           P64[Hp] = P64[Sp + 16];
           I64[Sp] = caXu;
           R3 = GHC.Types.[]_closure+1;
           R2 = _saxZ::I64;
           R1 = Hp - 5;
           I64[Sp + 16] = _saxZ::I64;
           call $wa8_say0_info(R3,
                               R2,
                               R1) returns to caXu, args: 8, res: 8, upd: 8;
       caXu:
           Hp = Hp + 40;
           if (Hp > HpLim) goto caZ7; else goto caZ6;
       caZ7:
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to caXu, args: 8, res: 8, upd: 8;
       caZ6:
           I64[Hp - 32] = sat_sayM_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 16];
           R1 = Hp - 32;
           Sp = Sp + 24;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:45.363026 UTC

[section "data" {
     SkipList.$fMArrayTArrayeSTM_$cnewArray_closure:
         const SkipList.$fMArrayTArrayeSTM_$cnewArray_info;
         const 0;
 },
 SkipList.$fMArrayTArrayeSTM_$cnewArray_entry() //  [R4, R3, R2]
         { info_tbl: [(caZO,
                       label: SkipList.$fMArrayTArrayeSTM_$cnewArray_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caZO:
           _B2::P64 = R4;
           _B3::P64 = R3;
           _B4::P64 = R2;
           goto caZM;
       caZM:
           if ((old + 0) - <highSp> < SpLim) goto caZP; else goto caZQ;
       caZQ:
           goto caZL;
       caZL:
           if (HpLim == 0) goto caZP; else goto caZR;
       caZP:
           R4 = _B2::P64;
           R3 = _B3::P64;
           R2 = _B4::P64;
           R1 = SkipList.$fMArrayTArrayeSTM_$cnewArray_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caZR:
           R4 = _B2::P64;
           R3 = _B3::P64;
           R2 = _B4::P64;
           call SkipList.$fMArrayTArrayeSTM4_info(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:45.365554 UTC

{offset
  caZO:
      _B2::P64 = R4;
      _B3::P64 = R3;
      _B4::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto caZP; else goto caZQ;
  caZQ:
      if (HpLim == 0) goto caZP; else goto caZR;
  caZP:
      R4 = _B2::P64;
      R3 = _B3::P64;
      R2 = _B4::P64;
      R1 = SkipList.$fMArrayTArrayeSTM_$cnewArray_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  caZR:
      R4 = _B2::P64;
      R3 = _B3::P64;
      R2 = _B4::P64;
      call SkipList.$fMArrayTArrayeSTM4_info(R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:45.366539 UTC

{offset
  caZO:
      _B2::P64 = R4;
      _B3::P64 = R3;
      _B4::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto caZP; else goto caZQ;
  caZQ:
      if (HpLim == 0) goto caZP; else goto caZR;
  caZP:
      R4 = _B2::P64;
      R3 = _B3::P64;
      R2 = _B4::P64;
      R1 = SkipList.$fMArrayTArrayeSTM_$cnewArray_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  caZR:
      R4 = _B2::P64;
      R3 = _B3::P64;
      R2 = _B4::P64;
      call SkipList.$fMArrayTArrayeSTM4_info(R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:45.367555 UTC

{offset
  caZO:
      _B2::P64 = R4;
      _B3::P64 = R3;
      _B4::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto caZP; else goto caZQ;
  caZQ:
      if (HpLim == 0) goto caZP; else goto caZR;
  caZP:
      R4 = _B2::P64;
      R3 = _B3::P64;
      R2 = _B4::P64;
      R1 = SkipList.$fMArrayTArrayeSTM_$cnewArray_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  caZR:
      R4 = _B2::P64;
      R3 = _B3::P64;
      R2 = _B4::P64;
      call SkipList.$fMArrayTArrayeSTM4_info(R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:45.368579 UTC

{offset
  caZO:
      _B2::P64 = R4;
      _B3::P64 = R3;
      _B4::P64 = R2;
      goto caZQ;
  caZQ:
      if (HpLim == 0) goto caZP; else goto caZR;
  caZP:
      R4 = _B2::P64;
      R3 = _B3::P64;
      R2 = _B4::P64;
      R1 = SkipList.$fMArrayTArrayeSTM_$cnewArray_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  caZR:
      R4 = _B2::P64;
      R3 = _B3::P64;
      R2 = _B4::P64;
      call SkipList.$fMArrayTArrayeSTM4_info(R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:45.369481 UTC

{offset
  caZO:
      goto caZQ;
  caZQ:
      if (HpLim == 0) goto caZP; else goto caZR;
  caZP:
      R4 = R4;
      R3 = R3;
      R2 = R2;
      R1 = SkipList.$fMArrayTArrayeSTM_$cnewArray_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  caZR:
      R4 = R4;
      R3 = R3;
      R2 = R2;
      call SkipList.$fMArrayTArrayeSTM4_info(R4,
                                             R3,
                                             R2) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:45.370484 UTC

[(caZO,
  {SkipList.$fMArrayTArrayeSTM_$cnewArray_closure,
   SkipList.$fMArrayTArrayeSTM4_closure}),
 (caZP, {SkipList.$fMArrayTArrayeSTM_$cnewArray_closure}),
 (caZQ,
  {SkipList.$fMArrayTArrayeSTM_$cnewArray_closure,
   SkipList.$fMArrayTArrayeSTM4_closure}),
 (caZR, {SkipList.$fMArrayTArrayeSTM4_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:45.371029 UTC

SkipList.$fMArrayTArrayeSTM_$cnewArray_entry() //  [R4, R3, R2]
        { info_tbl: [(caZO,
                      label: SkipList.$fMArrayTArrayeSTM_$cnewArray_info
                      rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caZO:
          goto caZQ;
      caZQ:
          if (HpLim == 0) goto caZP; else goto caZR;
      caZP:
          R4 = R4;
          R3 = R3;
          R2 = R2;
          R1 = SkipList.$fMArrayTArrayeSTM_$cnewArray_closure;
          call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
      caZR:
          R4 = R4;
          R3 = R3;
          R2 = R2;
          call SkipList.$fMArrayTArrayeSTM4_info(R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:45.372057 UTC

SkipList.$fMArrayTArrayeSTM_$cnewArray_entry() //  [R4, R3, R2]
        { info_tbl: [(caZO,
                      label: SkipList.$fMArrayTArrayeSTM_$cnewArray_info
                      rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      caZO:
          if (HpLim == 0) goto caZP; else goto caZR;
      caZP:
          R4 = R4;
          R3 = R3;
          R2 = R2;
          R1 = SkipList.$fMArrayTArrayeSTM_$cnewArray_closure;
          call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
      caZR:
          R4 = R4;
          R3 = R3;
          R2 = R2;
          call SkipList.$fMArrayTArrayeSTM4_info(R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:45.373185 UTC

[section "data" {
     SkipList.$fMArrayTArrayeSTM_$cnewArray_closure:
         const SkipList.$fMArrayTArrayeSTM_$cnewArray_info;
         const 0;
 },
 SkipList.$fMArrayTArrayeSTM_$cnewArray_entry() //  [R4, R3, R2]
         { info_tbl: [(caZO,
                       label: SkipList.$fMArrayTArrayeSTM_$cnewArray_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caZO:
           if (HpLim == 0) goto caZP; else goto caZR;
       caZP:
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = SkipList.$fMArrayTArrayeSTM_$cnewArray_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caZR:
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call SkipList.$fMArrayTArrayeSTM4_info(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:45.37441 UTC

[section "data" {
     SkipList.$fMArrayTArrayeSTM_$cnewArray_closure:
         const SkipList.$fMArrayTArrayeSTM_$cnewArray_info;
         const 0;
 },
 SkipList.$fMArrayTArrayeSTM_$cnewArray_entry() //  [R4, R3, R2]
         { info_tbl: [(caZO,
                       label: SkipList.$fMArrayTArrayeSTM_$cnewArray_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       caZO:
           if (HpLim == 0) goto caZP; else goto caZR;
       caZP:
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = SkipList.$fMArrayTArrayeSTM_$cnewArray_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       caZR:
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call SkipList.$fMArrayTArrayeSTM4_info(R4,
                                                  R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:45.377524 UTC

[section "data" {
     SkipList.$fMArrayTArrayeSTM9_closure:
         const SkipList.$fMArrayTArrayeSTM9_info;
         const 0;
 },
 SkipList.$fMArrayTArrayeSTM9_entry() //  [R3, R2]
         { info_tbl: [(cb0g,
                       label: SkipList.$fMArrayTArrayeSTM9_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cb0g:
           _sayO::P64 = R3;
           _sayN::I64 = R2;
           goto cb0a;
       cb0a:
           if ((old + 0) - <highSp> < SpLim) goto cb0h; else goto cb0i;
       cb0i:
           goto cb09;
       cb09:
           if (HpLim == 0) goto cb0h; else goto cb0r;
       cb0h:
           R3 = _sayO::P64;
           R2 = _sayN::I64;
           R1 = SkipList.$fMArrayTArrayeSTM9_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb0r:
           _sayQ::I64 = _sayN::I64;
           switch [-9223372036854775808 .. 9223372036854775807] _sayQ::I64 {
               case 0 : goto cb0f;
               default: goto cb0e;
           }
       cb0f:
           R1 = _sayO::P64;
           call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
       cb0e:
           I64[(young<cb0k> + 8)] = cb0k;
           R1 = Data.Array.Base.arrEleBottom_closure;
           call stg_newNOrecTVar#(R1) returns to cb0k, args: 8, res: 8, upd: 8;
       cb0k:
           _sayT::P64 = R1;
           Hp = Hp + 40;
           if (Hp > HpLim) goto cb0q; else goto cb0p;
       cb0q:
           HpAlloc = 40;
           goto cb0o;
       cb0o:
           R1 = _sayT::P64;
           call stg_gc_unpt_r1(R1) returns to cb0k, args: 8, res: 8, upd: 8;
       cb0p:
           I64[Hp - 32] = GHC.Conc.Sync.TVar_con_info;
           P64[Hp - 24] = _sayT::P64;
           _cb0m::P64 = Hp - 31;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _cb0m::P64;
           P64[Hp] = _sayO::P64;
           _cb0n::P64 = Hp - 14;
           _cb0s::I64 = _sayQ::I64 - 1;
           _sayU::I64 = _cb0s::I64;
           R3 = _cb0n::P64;
           R2 = _sayU::I64;
           call SkipList.$fMArrayTArrayeSTM9_info(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:45.381368 UTC

{offset
  cb0g:
      _sayO::P64 = R3;
      _sayN::I64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cb0h; else goto cb0i;
  cb0i:
      if (HpLim == 0) goto cb0h; else goto cb0r;
  cb0h:
      R3 = _sayO::P64;
      R2 = _sayN::I64;
      R1 = SkipList.$fMArrayTArrayeSTM9_closure;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  cb0r:
      _sayQ::I64 = _sayN::I64;
      switch [-9223372036854775808 .. 9223372036854775807] _sayQ::I64 {
          case 0 : goto cb0f;
          default: goto cb0e;
      }
  cb0f:
      R1 = _sayO::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
  cb0e:
      I64[(young<cb0k> + 8)] = cb0k;
      R1 = Data.Array.Base.arrEleBottom_closure;
      call stg_newNOrecTVar#(R1) returns to cb0k, args: 8, res: 8, upd: 8;
  cb0k:
      _sayT::P64 = R1;
      Hp = Hp + 40;
      if (Hp > HpLim) goto cb0q; else goto cb0p;
  cb0q:
      HpAlloc = 40;
      R1 = _sayT::P64;
      call stg_gc_unpt_r1(R1) returns to cb0k, args: 8, res: 8, upd: 8;
  cb0p:
      I64[Hp - 32] = GHC.Conc.Sync.TVar_con_info;
      P64[Hp - 24] = _sayT::P64;
      _cb0m::P64 = Hp - 31;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _cb0m::P64;
      P64[Hp] = _sayO::P64;
      _cb0n::P64 = Hp - 14;
      _cb0s::I64 = _sayQ::I64 - 1;
      _sayU::I64 = _cb0s::I64;
      R3 = _cb0n::P64;
      R2 = _sayU::I64;
      call SkipList.$fMArrayTArrayeSTM9_info(R3,
                                             R2) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:45.383531 UTC

{offset
  cb0g:
      _sayO::P64 = R3;
      _sayN::I64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cb0h; else goto cb0i;
  cb0i:
      if (HpLim == 0) goto cb0h; else goto cb0r;
  cb0h:
      R3 = _sayO::P64;
      R2 = _sayN::I64;
      R1 = SkipList.$fMArrayTArrayeSTM9_closure;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  cb0r:
      _sayQ::I64 = _sayN::I64;
      switch [-9223372036854775808 .. 9223372036854775807] _sayQ::I64 {
          case 0 : goto cb0f;
          default: goto cb0e;
      }
  cb0f:
      R1 = _sayO::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
  cb0e:
      I64[(young<cb0k> + 8)] = cb0k;
      R1 = Data.Array.Base.arrEleBottom_closure;
      call stg_newNOrecTVar#(R1) returns to cb0k, args: 8, res: 8, upd: 8;
  cb0k:
      _sayT::P64 = R1;
      Hp = Hp + 40;
      if (Hp > HpLim) goto cb0q; else goto cb0p;
  cb0q:
      HpAlloc = 40;
      R1 = _sayT::P64;
      call stg_gc_unpt_r1(R1) returns to cb0k, args: 8, res: 8, upd: 8;
  cb0p:
      I64[Hp - 32] = GHC.Conc.Sync.TVar_con_info;
      P64[Hp - 24] = _sayT::P64;
      _cb0m::P64 = Hp - 31;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _cb0m::P64;
      P64[Hp] = _sayO::P64;
      _cb0n::P64 = Hp - 14;
      _cb0s::I64 = _sayQ::I64 - 1;
      _sayU::I64 = _cb0s::I64;
      R3 = _cb0n::P64;
      R2 = _sayU::I64;
      call SkipList.$fMArrayTArrayeSTM9_info(R3,
                                             R2) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:45.38567 UTC

{offset
  cb0g:
      _sayO::P64 = R3;
      _sayN::I64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cb0h; else goto cb0i;
  cb0i:
      if (HpLim == 0) goto cb0h; else goto cb0r;
  cb0h:
      R3 = _sayO::P64;
      R2 = _sayN::I64;
      R1 = SkipList.$fMArrayTArrayeSTM9_closure;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  cb0r:
      _sayQ::I64 = _sayN::I64;
      if (_sayQ::I64 != 0) goto cb0e; else goto cb0f;
  cb0e:
      I64[(young<cb0k> + 8)] = cb0k;
      R1 = Data.Array.Base.arrEleBottom_closure;
      call stg_newNOrecTVar#(R1) returns to cb0k, args: 8, res: 8, upd: 8;
  cb0k:
      _sayT::P64 = R1;
      Hp = Hp + 40;
      if (Hp > HpLim) goto cb0q; else goto cb0p;
  cb0q:
      HpAlloc = 40;
      R1 = _sayT::P64;
      call stg_gc_unpt_r1(R1) returns to cb0k, args: 8, res: 8, upd: 8;
  cb0p:
      I64[Hp - 32] = GHC.Conc.Sync.TVar_con_info;
      P64[Hp - 24] = _sayT::P64;
      _cb0m::P64 = Hp - 31;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _cb0m::P64;
      P64[Hp] = _sayO::P64;
      _cb0n::P64 = Hp - 14;
      _cb0s::I64 = _sayQ::I64 - 1;
      _sayU::I64 = _cb0s::I64;
      R3 = _cb0n::P64;
      R2 = _sayU::I64;
      call SkipList.$fMArrayTArrayeSTM9_info(R3,
                                             R2) args: 8, res: 0, upd: 8;
  cb0f:
      R1 = _sayO::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:45.388022 UTC

{offset
  cb0g:
      _sayO::P64 = R3;
      _sayN::I64 = R2;
      if ((Sp + 8) - 32 < SpLim) goto cb0h; else goto cb0i;
  cb0i:
      if (HpLim == 0) goto cb0h; else goto cb0r;
  cb0h:
      R3 = _sayO::P64;
      R2 = _sayN::I64;
      R1 = SkipList.$fMArrayTArrayeSTM9_closure;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  cb0r:
      _sayQ::I64 = _sayN::I64;
      if (_sayQ::I64 != 0) goto cb0e; else goto cb0f;
  cb0e:
      I64[Sp - 24] = cb0k;
      R1 = Data.Array.Base.arrEleBottom_closure;
      P64[Sp - 16] = _sayO::P64;
      I64[Sp - 8] = _sayQ::I64;
      Sp = Sp - 24;
      call stg_newNOrecTVar#(R1) returns to cb0k, args: 8, res: 8, upd: 8;
  cb0k:
      _sayO::P64 = P64[Sp + 8];
      _sayQ::I64 = I64[Sp + 16];
      _sayT::P64 = R1;
      Hp = Hp + 40;
      if (Hp > HpLim) goto cb0q; else goto cb0p;
  cb0q:
      HpAlloc = 40;
      R1 = _sayT::P64;
      call stg_gc_unpt_r1(R1) returns to cb0k, args: 8, res: 8, upd: 8;
  cb0p:
      I64[Hp - 32] = GHC.Conc.Sync.TVar_con_info;
      P64[Hp - 24] = _sayT::P64;
      _cb0m::P64 = Hp - 31;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _cb0m::P64;
      P64[Hp] = _sayO::P64;
      _cb0n::P64 = Hp - 14;
      _cb0s::I64 = _sayQ::I64 - 1;
      _sayU::I64 = _cb0s::I64;
      R3 = _cb0n::P64;
      R2 = _sayU::I64;
      Sp = Sp + 24;
      call SkipList.$fMArrayTArrayeSTM9_info(R3,
                                             R2) args: 8, res: 0, upd: 8;
  cb0f:
      R1 = _sayO::P64;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:45.390423 UTC

{offset
  cb0g:
      _sayO::P64 = R3;
      _sayN::I64 = R2;
      if ((Sp + -24) < SpLim) goto cb0h; else goto cb0i;
  cb0i:
      if (HpLim == 0) goto cb0h; else goto cb0r;
  cb0h:
      R3 = _sayO::P64;
      R2 = _sayN::I64;
      R1 = SkipList.$fMArrayTArrayeSTM9_closure;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  cb0r:
      if (_sayN::I64 != 0) goto cb0e; else goto cb0f;
  cb0e:
      I64[Sp - 24] = cb0k;
      R1 = Data.Array.Base.arrEleBottom_closure;
      P64[Sp - 16] = _sayO::P64;
      I64[Sp - 8] = _sayN::I64;
      Sp = Sp - 24;
      call stg_newNOrecTVar#(R1) returns to cb0k, args: 8, res: 8, upd: 8;
  cb0k:
      Hp = Hp + 40;
      if (Hp > HpLim) goto cb0q; else goto cb0p;
  cb0q:
      HpAlloc = 40;
      R1 = R1;
      call stg_gc_unpt_r1(R1) returns to cb0k, args: 8, res: 8, upd: 8;
  cb0p:
      I64[Hp - 32] = GHC.Conc.Sync.TVar_con_info;
      P64[Hp - 24] = R1;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = Hp - 31;
      P64[Hp] = P64[Sp + 8];
      R3 = Hp - 14;
      R2 = I64[Sp + 16] - 1;
      Sp = Sp + 24;
      call SkipList.$fMArrayTArrayeSTM9_info(R3,
                                             R2) args: 8, res: 0, upd: 8;
  cb0f:
      R1 = _sayO::P64;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:45.392829 UTC

[(cb0e,
  {Data.Array.Base.arrEleBottom_closure,
   SkipList.$fMArrayTArrayeSTM9_closure}),
 (cb0f, {}),
 (cb0g,
  {Data.Array.Base.arrEleBottom_closure,
   SkipList.$fMArrayTArrayeSTM9_closure}),
 (cb0h, {SkipList.$fMArrayTArrayeSTM9_closure}),
 (cb0i,
  {Data.Array.Base.arrEleBottom_closure,
   SkipList.$fMArrayTArrayeSTM9_closure}),
 (cb0k, {SkipList.$fMArrayTArrayeSTM9_closure}),
 (cb0p, {SkipList.$fMArrayTArrayeSTM9_closure}),
 (cb0q, {SkipList.$fMArrayTArrayeSTM9_closure}),
 (cb0r,
  {Data.Array.Base.arrEleBottom_closure,
   SkipList.$fMArrayTArrayeSTM9_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:45.393765 UTC

SkipList.$fMArrayTArrayeSTM9_entry() //  [R3, R2]
        { info_tbl: [(cb0g,
                      label: SkipList.$fMArrayTArrayeSTM9_info
                      rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 13} }),
                     (cb0k,
                      label: block_cb0k_info
                      rep:StackRep [False, True])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cb0g:
          _sayO::P64 = R3;
          _sayN::I64 = R2;
          if ((Sp + -24) < SpLim) goto cb0h; else goto cb0i;
      cb0i:
          if (HpLim == 0) goto cb0h; else goto cb0r;
      cb0h:
          R3 = _sayO::P64;
          R2 = _sayN::I64;
          R1 = SkipList.$fMArrayTArrayeSTM9_closure;
          call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
      cb0r:
          if (_sayN::I64 != 0) goto cb0e; else goto cb0f;
      cb0e:
          I64[Sp - 24] = cb0k;
          R1 = Data.Array.Base.arrEleBottom_closure;
          P64[Sp - 16] = _sayO::P64;
          I64[Sp - 8] = _sayN::I64;
          Sp = Sp - 24;
          call stg_newNOrecTVar#(R1) returns to cb0k, args: 8, res: 8, upd: 8;
      cb0k:
          Hp = Hp + 40;
          if (Hp > HpLim) goto cb0q; else goto cb0p;
      cb0q:
          HpAlloc = 40;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to cb0k, args: 8, res: 8, upd: 8;
      cb0p:
          I64[Hp - 32] = GHC.Conc.Sync.TVar_con_info;
          P64[Hp - 24] = R1;
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = Hp - 31;
          P64[Hp] = P64[Sp + 8];
          R3 = Hp - 14;
          R2 = I64[Sp + 16] - 1;
          Sp = Sp + 24;
          call SkipList.$fMArrayTArrayeSTM9_info(R3,
                                                 R2) args: 8, res: 0, upd: 8;
      cb0f:
          R1 = _sayO::P64;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:45.396247 UTC

SkipList.$fMArrayTArrayeSTM9_entry() //  [R3, R2]
        { info_tbl: [(cb0g,
                      label: SkipList.$fMArrayTArrayeSTM9_info
                      rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 13} }),
                     (cb0k,
                      label: block_cb0k_info
                      rep:StackRep [False, True])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cb0g:
          _sayO::P64 = R3;
          _sayN::I64 = R2;
          if ((Sp + -24) < SpLim) goto cb0h; else goto cb0i;
      cb0i:
          if (HpLim == 0) goto cb0h; else goto cb0r;
      cb0h:
          R3 = _sayO::P64;
          R2 = _sayN::I64;
          R1 = SkipList.$fMArrayTArrayeSTM9_closure;
          call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
      cb0r:
          if (_sayN::I64 != 0) goto cb0e; else goto cb0f;
      cb0e:
          I64[Sp - 24] = cb0k;
          R1 = Data.Array.Base.arrEleBottom_closure;
          P64[Sp - 16] = _sayO::P64;
          I64[Sp - 8] = _sayN::I64;
          Sp = Sp - 24;
          call stg_newNOrecTVar#(R1) returns to cb0k, args: 8, res: 8, upd: 8;
      cb0k:
          Hp = Hp + 40;
          if (Hp > HpLim) goto cb0q; else goto cb0p;
      cb0q:
          HpAlloc = 40;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to cb0k, args: 8, res: 8, upd: 8;
      cb0p:
          I64[Hp - 32] = GHC.Conc.Sync.TVar_con_info;
          P64[Hp - 24] = R1;
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = Hp - 31;
          P64[Hp] = P64[Sp + 8];
          R3 = Hp - 14;
          R2 = I64[Sp + 16] - 1;
          Sp = Sp + 24;
          call SkipList.$fMArrayTArrayeSTM9_info(R3,
                                                 R2) args: 8, res: 0, upd: 8;
      cb0f:
          R1 = _sayO::P64;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:45.398734 UTC

[section "data" {
     SkipList.$fMArrayTArrayeSTM9_closure:
         const SkipList.$fMArrayTArrayeSTM9_info;
         const 0;
 },
 SkipList.$fMArrayTArrayeSTM9_entry() //  [R3, R2]
         { info_tbl: [(cb0g,
                       label: SkipList.$fMArrayTArrayeSTM9_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 13} }),
                      (cb0k,
                       label: block_cb0k_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cb0g:
           _sayO::P64 = R3;
           _sayN::I64 = R2;
           if ((Sp + -24) < SpLim) goto cb0h; else goto cb0i;
       cb0i:
           if (HpLim == 0) goto cb0h; else goto cb0r;
       cb0h:
           R3 = _sayO::P64;
           R2 = _sayN::I64;
           R1 = SkipList.$fMArrayTArrayeSTM9_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb0r:
           if (_sayN::I64 != 0) goto cb0e; else goto cb0f;
       cb0e:
           I64[Sp - 24] = cb0k;
           R1 = Data.Array.Base.arrEleBottom_closure;
           P64[Sp - 16] = _sayO::P64;
           I64[Sp - 8] = _sayN::I64;
           Sp = Sp - 24;
           call stg_newNOrecTVar#(R1) returns to cb0k, args: 8, res: 8, upd: 8;
       cb0k:
           Hp = Hp + 40;
           if (Hp > HpLim) goto cb0q; else goto cb0p;
       cb0q:
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to cb0k, args: 8, res: 8, upd: 8;
       cb0p:
           I64[Hp - 32] = GHC.Conc.Sync.TVar_con_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = P64[Sp + 8];
           R3 = Hp - 14;
           R2 = I64[Sp + 16] - 1;
           Sp = Sp + 24;
           call SkipList.$fMArrayTArrayeSTM9_info(R3,
                                                  R2) args: 8, res: 0, upd: 8;
       cb0f:
           R1 = _sayO::P64;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:45.401452 UTC

[section "data" {
     SkipList.$fMArrayTArrayeSTM9_closure:
         const SkipList.$fMArrayTArrayeSTM9_info;
         const 0;
 },
 SkipList.$fMArrayTArrayeSTM9_entry() //  [R3, R2]
         { info_tbl: [(cb0g,
                       label: SkipList.$fMArrayTArrayeSTM9_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 13} }),
                      (cb0k,
                       label: block_cb0k_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cb0g:
           _sayO::P64 = R3;
           _sayN::I64 = R2;
           if ((Sp + -24) < SpLim) goto cb0h; else goto cb0i;
       cb0i:
           if (HpLim == 0) goto cb0h; else goto cb0r;
       cb0h:
           R3 = _sayO::P64;
           R2 = _sayN::I64;
           R1 = SkipList.$fMArrayTArrayeSTM9_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb0r:
           if (_sayN::I64 != 0) goto cb0e; else goto cb0f;
       cb0e:
           I64[Sp - 24] = cb0k;
           R1 = Data.Array.Base.arrEleBottom_closure;
           P64[Sp - 16] = _sayO::P64;
           I64[Sp - 8] = _sayN::I64;
           Sp = Sp - 24;
           call stg_newNOrecTVar#(R1) returns to cb0k, args: 8, res: 8, upd: 8;
       cb0k:
           Hp = Hp + 40;
           if (Hp > HpLim) goto cb0q; else goto cb0p;
       cb0q:
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to cb0k, args: 8, res: 8, upd: 8;
       cb0p:
           I64[Hp - 32] = GHC.Conc.Sync.TVar_con_info;
           P64[Hp - 24] = R1;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = P64[Sp + 8];
           R3 = Hp - 14;
           R2 = I64[Sp + 16] - 1;
           Sp = Sp + 24;
           call SkipList.$fMArrayTArrayeSTM9_info(R3,
                                                  R2) args: 8, res: 0, upd: 8;
       cb0f:
           R1 = _sayO::P64;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:45.410127 UTC

[section "data" {
     SkipList.$fMArrayTArrayeSTM8_closure:
         const SkipList.$fMArrayTArrayeSTM8_info;
         const 0;
 },
 $wa8_sazi_entry() //  [R3, R2, R1]
         { info_tbl: [(cb2a,
                       label: $wa8_sazi_info
                       rep:HeapRep 1 ptrs 1 nonptrs {
                             Fun {arity: 3 fun_type: ArgSpec 13} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cb2a:
           _sazk::P64 = R3;
           _sazj::I64 = R2;
           _sazi::P64 = R1;
           goto cb26;
       cb26:
           if ((old + 0) - <highSp> < SpLim) goto cb2b; else goto cb2c;
       cb2c:
           goto cb25;
       cb25:
           if (HpLim == 0) goto cb2b; else goto cb2v;
       cb2b:
           R3 = _sazk::P64;
           R2 = _sazj::I64;
           R1 = _sazi::P64;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb2v:
           _sazd::P64 = P64[_sazi::P64 + 5];
           _saz1::I64 = I64[_sazi::P64 + 13];
           _cb28::I64 = _sazj::I64 == _saz1::I64;
           _sazm::I64 = _cb28::I64;
           switch [0 .. 1] _sazm::I64 {
               case 0 : goto cb2i;
               case 1 : goto cb2u;
           }
       cb2u:
           R1 = GHC.Tuple.()_closure+1;
           call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
       cb2i:
           I64[(young<cb2g> + 8)] = cb2g;
           R1 = _sazk::P64;
           if (R1 & 7 != 0) goto cb2g; else goto cb2j;
       cb2j:
           call (I64[R1])(R1) returns to cb2g, args: 8, res: 8, upd: 8;
       cb2g:
           _sazo::P64 = R1;
           _cb2w::P64 = _sazo::P64 & 7;
           switch [1 .. 2] _cb2w::P64 {
               case 1 : goto cb2p;
               case 2 : goto cb2t;
           }
       cb2t:
           _sazp::P64 = P64[_sazo::P64 + 6];
           _sazq::P64 = P64[_sazo::P64 + 14];
           P64[(_sazd::P64 + 24) + (_sazj::I64 << 3)] = _sazp::P64;
           I64[_sazd::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
           I8[(_sazd::P64 + 24) + (I64[_sazd::P64 + 8] << 3) + (_sazj::I64 >> 7)] = 1 :: W8;
           _cb2z::I64 = _sazj::I64 + 1;
           _sazs::I64 = _cb2z::I64;
           R3 = _sazq::P64;
           R2 = _sazs::I64;
           R1 = _sazi::P64;
           call $wa8_sazi_info(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb2p:
           R1 = GHC.Tuple.()_closure+1;
           call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sazC_entry() //  [R1]
         { info_tbl: [(cb2A,
                       label: sat_sazC_info
                       rep:HeapRep 2 ptrs 1 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cb2A:
           _sazC::P64 = R1;
           goto cb1G;
       cb1G:
           if ((old + 0) - <highSp> < SpLim) goto cb2B; else goto cb2C;
       cb2C:
           goto cb1F;
       cb1F:
           if (HpLim == 0) goto cb2B; else goto cb2D;
       cb2B:
           R1 = _sazC::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cb2D:
           _sayY::P64 = P64[_sazC::P64 + 7];
           _saz4::P64 = P64[_sazC::P64 + 15];
           _saz1::I64 = I64[_sazC::P64 + 23];
           I64[(young<cb1I> + 8)] = cb1I;
           R1 = _sayY::P64;
           if (R1 & 7 != 0) goto cb1I; else goto cb1J;
       cb1J:
           call (I64[R1])(R1) returns to cb1I, args: 8, res: 8, upd: 8;
       cb1I:
           _saz6::P64 = R1;
           _saz7::P64 = P64[_saz6::P64 + 7];
           _saz8::P64 = P64[_saz6::P64 + 15];
           _cb1N::I64 = %MO_S_Lt_W64(_saz1::I64, 0);
           _saz9::I64 = _cb1N::I64;
           switch [0 .. 1] _saz9::I64 {
               case 0 : goto cb2G;
               case 1 : goto cb2V;
           }
       cb2V:
           R1 = GHC.Arr.negRange_closure;
           call (I64[R1])(R1) args: 8, res: 0, upd: 8;
       cb2G:
           I64[(young<cb1S> + 8)] = cb1S;
           R2 = Data.Array.Base.arrEleBottom_closure;
           R1 = _saz1::I64;
           call stg_newArray#(R2,
                              R1) returns to cb1S, args: 8, res: 8, upd: 8;
       cb1S:
           _sazd::P64 = R1;
           I64[(young<cb1U> + 8)] = cb1U;
           R1 = _saz7::P64;
           call stg_ap_0_fast(R1) returns to cb1U, args: 8, res: 8, upd: 8;
       cb1U:
           _saze::P64 = R1;
           I64[(young<cb1W> + 8)] = cb1W;
           R1 = _saz8::P64;
           call stg_ap_0_fast(R1) returns to cb1W, args: 8, res: 8, upd: 8;
       cb1W:
           _sazf::P64 = R1;
           Hp = Hp + 24;
           if (Hp > HpLim) goto cb2L; else goto cb2K;
       cb2L:
           HpAlloc = 24;
           goto cb2J;
       cb2J:
           R1 = _sazf::P64;
           call stg_gc_unpt_r1(R1) returns to cb1W, args: 8, res: 8, upd: 8;
       cb2K:
           _cb1Y::I64 = %MO_S_Lt_W64(_saz1::I64, 0);
           _sazg::I64 = _cb1Y::I64;
           switch [0 .. 1] _sazg::I64 {
               case 0 : goto cb2Q;
               case 1 : goto cb2U;
           }
       cb2U:
           Hp = Hp - 24;
           R1 = SkipList.$fMArrayTArrayeSTM5_closure;
           call (I64[R1])(R1) args: 8, res: 0, upd: 8;
       cb2Q:
           _cb23::P64 = Hp - 13;
           I64[Hp - 16] = $wa8_sazi_info;
           P64[Hp - 8] = _sazd::P64;
           I64[Hp] = _saz1::I64;
           I64[(young<cb2M> + 8)] = cb2M;
           R3 = _saz4::P64;
           R2 = 0;
           R1 = _cb23::P64;
           call $wa8_sazi_info(R3,
                               R2,
                               R1) returns to cb2M, args: 8, res: 8, upd: 8;
       cb2M:
           _sazv::P64 = R1;
           Hp = Hp + 40;
           if (Hp > HpLim) goto cb2T; else goto cb2S;
       cb2T:
           HpAlloc = 40;
           goto cb2R;
       cb2R:
           R1 = _sazv::P64;
           call stg_gc_unpt_r1(R1) returns to cb2M, args: 8, res: 8, upd: 8;
       cb2S:
           I64[_sazd::P64] = stg_MUT_ARR_PTRS_FROZEN0_info;
           _sazy::P64 = _sazd::P64;
           _sazy::P64 = _sazy::P64;
           I64[Hp - 32] = GHC.Arr.Array_con_info;
           P64[Hp - 24] = _saze::P64;
           P64[Hp - 16] = _sazf::P64;
           P64[Hp - 8] = _sazy::P64;
           I64[Hp] = _saz1::I64;
           _cb2O::P64 = Hp - 31;
           R1 = _cb2O::P64;
           call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sazD_entry() //  [R1]
         { info_tbl: [(cb2W,
                       label: sat_sazD_info
                       rep:HeapRep 2 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cb2W:
           _sazD::P64 = R1;
           goto cb1B;
       cb1B:
           if ((old + 0) - <highSp> < SpLim) goto cb2X; else goto cb2Y;
       cb2Y:
           Hp = Hp + 32;
           if (Hp > HpLim) goto cb30; else goto cb2Z;
       cb30:
           HpAlloc = 32;
           goto cb2X;
       cb2X:
           R1 = _sazD::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb2Z:
           I64[(old + 24)] = stg_upd_frame_info;
           P64[(old + 16)] = _sazD::P64;
           _sayY::P64 = P64[_sazD::P64 + 16];
           _saz4::P64 = P64[_sazD::P64 + 24];
           _saz1::I64 = I64[_sazD::P64 + 32];
           I64[Hp - 24] = sat_sazC_info;
           P64[Hp - 16] = _sayY::P64;
           P64[Hp - 8] = _saz4::P64;
           I64[Hp] = _saz1::I64;
           _cb1D::P64 = Hp - 23;
           R2 = _cb1D::P64;
           call GHC.ST.runSTRep_info(R2) args: 24, res: 0, upd: 24;
     }
 },
 SkipList.$fMArrayTArrayeSTM8_entry() //  [R3, R2]
         { info_tbl: [(cb31,
                       label: SkipList.$fMArrayTArrayeSTM8_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cb31:
           _sayY::P64 = R3;
           _sayX::P64 = R2;
           goto cb1r;
       cb1r:
           if ((old + 0) - <highSp> < SpLim) goto cb32; else goto cb33;
       cb33:
           goto cb1q;
       cb1q:
           if (HpLim == 0) goto cb32; else goto cb34;
       cb32:
           R3 = _sayY::P64;
           R2 = _sayX::P64;
           R1 = SkipList.$fMArrayTArrayeSTM8_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb34:
           I64[(young<cb1t> + 8)] = cb1t;
           R2 = _sayX::P64;
           I64[(young<cb1t> + 24)] = stg_ap_p_info;
           P64[(young<cb1t> + 16)] = _sayY::P64;
           call GHC.Arr.rangeSize_info(R2) returns to cb1t, args: 24, res: 8, upd: 8;
       cb1t:
           _saz0::P64 = R1;
           _saz1::I64 = I64[_saz0::P64 + 7];
           I64[(young<cb1x> + 8)] = cb1x;
           R3 = GHC.Types.[]_closure+1;
           R2 = _saz1::I64;
           call SkipList.$fMArrayTArrayeSTM9_info(R3,
                                                  R2) returns to cb1x, args: 8, res: 8, upd: 8;
       cb1x:
           _saz4::P64 = R1;
           Hp = Hp + 40;
           if (Hp > HpLim) goto cb38; else goto cb37;
       cb38:
           HpAlloc = 40;
           goto cb36;
       cb36:
           R1 = _saz4::P64;
           call stg_gc_unpt_r1(R1) returns to cb1x, args: 8, res: 8, upd: 8;
       cb37:
           I64[Hp - 32] = sat_sazD_info;
           P64[Hp - 16] = _sayY::P64;
           P64[Hp - 8] = _saz4::P64;
           I64[Hp] = _saz1::I64;
           _cb1z::P64 = Hp - 32;
           R1 = _cb1z::P64;
           call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:45.42712 UTC

{offset
  cb2a:
      _sazk::P64 = R3;
      _sazj::I64 = R2;
      _sazi::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cb2b; else goto cb2c;
  cb2c:
      if (HpLim == 0) goto cb2b; else goto cb2v;
  cb2b:
      R3 = _sazk::P64;
      R2 = _sazj::I64;
      R1 = _sazi::P64;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  cb2v:
      _sazd::P64 = P64[_sazi::P64 + 5];
      _saz1::I64 = I64[_sazi::P64 + 13];
      _cb28::I64 = _sazj::I64 == _saz1::I64;
      _sazm::I64 = _cb28::I64;
      switch [0 .. 1] _sazm::I64 {
          case 0 : goto cb2i;
          case 1 : goto cb2u;
      }
  cb2u:
      R1 = GHC.Tuple.()_closure+1;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
  cb2i:
      I64[(young<cb2g> + 8)] = cb2g;
      R1 = _sazk::P64;
      if (R1 & 7 != 0) goto cb2g; else goto cb2j;
  cb2j:
      call (I64[R1])(R1) returns to cb2g, args: 8, res: 8, upd: 8;
  cb2g:
      _sazo::P64 = R1;
      _cb2w::P64 = _sazo::P64 & 7;
      switch [1 .. 2] _cb2w::P64 {
          case 1 : goto cb2p;
          case 2 : goto cb2t;
      }
  cb2t:
      _sazp::P64 = P64[_sazo::P64 + 6];
      _sazq::P64 = P64[_sazo::P64 + 14];
      P64[(_sazd::P64 + 24) + (_sazj::I64 << 3)] = _sazp::P64;
      I64[_sazd::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
      I8[(_sazd::P64 + 24) + (I64[_sazd::P64 + 8] << 3) + (_sazj::I64 >> 7)] = 1 :: W8;
      _cb2z::I64 = _sazj::I64 + 1;
      _sazs::I64 = _cb2z::I64;
      R3 = _sazq::P64;
      R2 = _sazs::I64;
      R1 = _sazi::P64;
      call $wa8_sazi_info(R3, R2, R1) args: 8, res: 0, upd: 8;
  cb2p:
      R1 = GHC.Tuple.()_closure+1;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:45.429825 UTC

{offset
  cb2a:
      _sazk::P64 = R3;
      _sazj::I64 = R2;
      _sazi::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cb2b; else goto cb2c;
  cb2c:
      if (HpLim == 0) goto cb2b; else goto cb2v;
  cb2b:
      R3 = _sazk::P64;
      R2 = _sazj::I64;
      R1 = _sazi::P64;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  cb2v:
      _sazd::P64 = P64[_sazi::P64 + 5];
      _saz1::I64 = I64[_sazi::P64 + 13];
      _cb28::I64 = _sazj::I64 == _saz1::I64;
      _sazm::I64 = _cb28::I64;
      switch [0 .. 1] _sazm::I64 {
          case 0 : goto cb2i;
          case 1 : goto cb2u;
      }
  cb2i:
      I64[(young<cb2g> + 8)] = cb2g;
      R1 = _sazk::P64;
      if (R1 & 7 != 0) goto cb2g; else goto cb2j;
  cb2j:
      call (I64[R1])(R1) returns to cb2g, args: 8, res: 8, upd: 8;
  cb2g:
      _sazo::P64 = R1;
      _cb2w::P64 = _sazo::P64 & 7;
      switch [1 .. 2] _cb2w::P64 {
          case 1 : goto cb2u;
          case 2 : goto cb2t;
      }
  cb2t:
      _sazp::P64 = P64[_sazo::P64 + 6];
      _sazq::P64 = P64[_sazo::P64 + 14];
      P64[(_sazd::P64 + 24) + (_sazj::I64 << 3)] = _sazp::P64;
      I64[_sazd::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
      I8[(_sazd::P64 + 24) + (I64[_sazd::P64 + 8] << 3) + (_sazj::I64 >> 7)] = 1 :: W8;
      _cb2z::I64 = _sazj::I64 + 1;
      _sazs::I64 = _cb2z::I64;
      R3 = _sazq::P64;
      R2 = _sazs::I64;
      R1 = _sazi::P64;
      call $wa8_sazi_info(R3, R2, R1) args: 8, res: 0, upd: 8;
  cb2u:
      R1 = GHC.Tuple.()_closure+1;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:45.432491 UTC

{offset
  cb2a:
      _sazk::P64 = R3;
      _sazj::I64 = R2;
      _sazi::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cb2b; else goto cb2c;
  cb2c:
      if (HpLim == 0) goto cb2b; else goto cb2v;
  cb2b:
      R3 = _sazk::P64;
      R2 = _sazj::I64;
      R1 = _sazi::P64;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  cb2v:
      _sazd::P64 = P64[_sazi::P64 + 5];
      _saz1::I64 = I64[_sazi::P64 + 13];
      _cb28::I64 = _sazj::I64 == _saz1::I64;
      _sazm::I64 = _cb28::I64;
      if (_sazm::I64 != 0) goto cb2u; else goto cb2i;
  cb2i:
      I64[(young<cb2g> + 8)] = cb2g;
      R1 = _sazk::P64;
      if (R1 & 7 != 0) goto cb2g; else goto cb2j;
  cb2j:
      call (I64[R1])(R1) returns to cb2g, args: 8, res: 8, upd: 8;
  cb2g:
      _sazo::P64 = R1;
      _cb2w::P64 = _sazo::P64 & 7;
      if (_cb2w::P64 != 1) goto cb2t; else goto cb2u;
  cb2t:
      _sazp::P64 = P64[_sazo::P64 + 6];
      _sazq::P64 = P64[_sazo::P64 + 14];
      P64[(_sazd::P64 + 24) + (_sazj::I64 << 3)] = _sazp::P64;
      I64[_sazd::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
      I8[(_sazd::P64 + 24) + (I64[_sazd::P64 + 8] << 3) + (_sazj::I64 >> 7)] = 1 :: W8;
      _cb2z::I64 = _sazj::I64 + 1;
      _sazs::I64 = _cb2z::I64;
      R3 = _sazq::P64;
      R2 = _sazs::I64;
      R1 = _sazi::P64;
      call $wa8_sazi_info(R3, R2, R1) args: 8, res: 0, upd: 8;
  cb2u:
      R1 = GHC.Tuple.()_closure+1;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:45.435182 UTC

{offset
  cb2a:
      _sazk::P64 = R3;
      _sazj::I64 = R2;
      _sazi::P64 = R1;
      if ((Sp + 8) - 40 < SpLim) goto cb2b; else goto cb2c;
  cb2c:
      if (HpLim == 0) goto cb2b; else goto cb2v;
  cb2b:
      R3 = _sazk::P64;
      R2 = _sazj::I64;
      R1 = _sazi::P64;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  cb2v:
      _sazd::P64 = P64[_sazi::P64 + 5];
      _saz1::I64 = I64[_sazi::P64 + 13];
      _cb28::I64 = _sazj::I64 == _saz1::I64;
      _sazm::I64 = _cb28::I64;
      if (_sazm::I64 != 0) goto cb2u; else goto cb2i;
  cb2i:
      I64[Sp - 32] = cb2g;
      R1 = _sazk::P64;
      P64[Sp - 24] = _sazd::P64;
      P64[Sp - 16] = _sazi::P64;
      I64[Sp - 8] = _sazj::I64;
      Sp = Sp - 32;
      if (R1 & 7 != 0) goto cb2g; else goto cb2j;
  cb2j:
      call (I64[R1])(R1) returns to cb2g, args: 8, res: 8, upd: 8;
  cb2g:
      _sazd::P64 = P64[Sp + 8];
      _sazi::P64 = P64[Sp + 16];
      _sazj::I64 = I64[Sp + 24];
      _sazo::P64 = R1;
      _cb2w::P64 = _sazo::P64 & 7;
      if (_cb2w::P64 != 1) goto cb2t; else goto ub39;
  cb2t:
      _sazp::P64 = P64[_sazo::P64 + 6];
      _sazq::P64 = P64[_sazo::P64 + 14];
      P64[(_sazd::P64 + 24) + (_sazj::I64 << 3)] = _sazp::P64;
      I64[_sazd::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
      I8[(_sazd::P64 + 24) + (I64[_sazd::P64 + 8] << 3) + (_sazj::I64 >> 7)] = 1 :: W8;
      _cb2z::I64 = _sazj::I64 + 1;
      _sazs::I64 = _cb2z::I64;
      R3 = _sazq::P64;
      R2 = _sazs::I64;
      R1 = _sazi::P64;
      Sp = Sp + 32;
      call $wa8_sazi_info(R3, R2, R1) args: 8, res: 0, upd: 8;
  ub39:
      Sp = Sp + 32;
      goto cb2u;
  cb2u:
      R1 = GHC.Tuple.()_closure+1;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:45.438089 UTC

{offset
  cb2a:
      _sazk::P64 = R3;
      _sazj::I64 = R2;
      _sazi::P64 = R1;
      if ((Sp + -32) < SpLim) goto cb2b; else goto cb2c;
  cb2c:
      if (HpLim == 0) goto cb2b; else goto cb2v;
  cb2b:
      R3 = _sazk::P64;
      R2 = _sazj::I64;
      R1 = _sazi::P64;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  cb2v:
      if (_sazj::I64 == I64[_sazi::P64 + 13]) goto cb2u; else goto cb2i;
  cb2i:
      I64[Sp - 32] = cb2g;
      R1 = _sazk::P64;
      P64[Sp - 24] = P64[_sazi::P64 + 5];
      P64[Sp - 16] = _sazi::P64;
      I64[Sp - 8] = _sazj::I64;
      Sp = Sp - 32;
      if (R1 & 7 != 0) goto cb2g; else goto cb2j;
  cb2j:
      call (I64[R1])(R1) returns to cb2g, args: 8, res: 8, upd: 8;
  cb2g:
      if (R1 & 7 != 1) goto cb2t; else goto ub39;
  cb2t:
      _sazd::P64 = P64[Sp + 8];
      _sazi::P64 = P64[Sp + 16];
      _sazj::I64 = I64[Sp + 24];
      _sazq::P64 = P64[R1 + 14];
      P64[(_sazd::P64 + 24) + (_sazj::I64 << 3)] = P64[R1 + 6];
      I64[_sazd::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
      I8[(_sazd::P64 + 24) + ((I64[_sazd::P64 + 8] << 3) + (_sazj::I64 >> 7))] = 1 :: W8;
      R3 = _sazq::P64;
      R2 = _sazj::I64 + 1;
      R1 = _sazi::P64;
      Sp = Sp + 32;
      call $wa8_sazi_info(R3, R2, R1) args: 8, res: 0, upd: 8;
  ub39:
      Sp = Sp + 32;
      goto cb2u;
  cb2u:
      R1 = GHC.Tuple.()_closure+1;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:45.441001 UTC

[(cb2a, {$wa8_sazi_closure}), (cb2b, {}),
 (cb2c, {$wa8_sazi_closure}), (cb2g, {$wa8_sazi_closure}),
 (cb2i, {$wa8_sazi_closure}), (cb2j, {$wa8_sazi_closure}),
 (cb2t, {$wa8_sazi_closure}), (cb2u, {}),
 (cb2v, {$wa8_sazi_closure}), (ub39, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:45.441709 UTC

$wa8_sazi_entry() //  [R3, R2, R1]
        { info_tbl: [(cb2a,
                      label: $wa8_sazi_info
                      rep:HeapRep 1 ptrs 1 nonptrs {
                            Fun {arity: 3 fun_type: ArgSpec 13} }),
                     (cb2g,
                      label: block_cb2g_info
                      rep:StackRep [False, False, True])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cb2a:
          _sazk::P64 = R3;
          _sazj::I64 = R2;
          _sazi::P64 = R1;
          if ((Sp + -32) < SpLim) goto cb2b; else goto cb2c;
      cb2c:
          if (HpLim == 0) goto cb2b; else goto cb2v;
      cb2b:
          R3 = _sazk::P64;
          R2 = _sazj::I64;
          R1 = _sazi::P64;
          call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
      cb2v:
          if (_sazj::I64 == I64[_sazi::P64 + 13]) goto cb2u; else goto cb2i;
      cb2i:
          I64[Sp - 32] = cb2g;
          R1 = _sazk::P64;
          P64[Sp - 24] = P64[_sazi::P64 + 5];
          P64[Sp - 16] = _sazi::P64;
          I64[Sp - 8] = _sazj::I64;
          Sp = Sp - 32;
          if (R1 & 7 != 0) goto cb2g; else goto cb2j;
      cb2j:
          call (I64[R1])(R1) returns to cb2g, args: 8, res: 8, upd: 8;
      cb2g:
          if (R1 & 7 != 1) goto cb2t; else goto ub39;
      cb2t:
          _sazd::P64 = P64[Sp + 8];
          _sazi::P64 = P64[Sp + 16];
          _sazj::I64 = I64[Sp + 24];
          _sazq::P64 = P64[R1 + 14];
          P64[(_sazd::P64 + 24) + (_sazj::I64 << 3)] = P64[R1 + 6];
          I64[_sazd::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
          I8[(_sazd::P64 + 24) + ((I64[_sazd::P64 + 8] << 3) + (_sazj::I64 >> 7))] = 1 :: W8;
          R3 = _sazq::P64;
          R2 = _sazj::I64 + 1;
          R1 = _sazi::P64;
          Sp = Sp + 32;
          call $wa8_sazi_info(R3, R2, R1) args: 8, res: 0, upd: 8;
      ub39:
          Sp = Sp + 32;
          goto cb2u;
      cb2u:
          R1 = GHC.Tuple.()_closure+1;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:45.444705 UTC

$wa8_sazi_entry() //  [R3, R2, R1]
        { info_tbl: [(cb2a,
                      label: $wa8_sazi_info
                      rep:HeapRep 1 ptrs 1 nonptrs {
                            Fun {arity: 3 fun_type: ArgSpec 13} }),
                     (cb2g,
                      label: block_cb2g_info
                      rep:StackRep [False, False, True])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cb2a:
          _sazk::P64 = R3;
          _sazj::I64 = R2;
          _sazi::P64 = R1;
          if ((Sp + -32) < SpLim) goto cb2b; else goto cb2c;
      cb2c:
          if (HpLim == 0) goto cb2b; else goto cb2v;
      cb2b:
          R3 = _sazk::P64;
          R2 = _sazj::I64;
          R1 = _sazi::P64;
          call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
      cb2v:
          if (_sazj::I64 == I64[_sazi::P64 + 13]) goto cb2u; else goto cb2i;
      cb2i:
          I64[Sp - 32] = cb2g;
          R1 = _sazk::P64;
          P64[Sp - 24] = P64[_sazi::P64 + 5];
          P64[Sp - 16] = _sazi::P64;
          I64[Sp - 8] = _sazj::I64;
          Sp = Sp - 32;
          if (R1 & 7 != 0) goto cb2g; else goto cb2j;
      cb2j:
          call (I64[R1])(R1) returns to cb2g, args: 8, res: 8, upd: 8;
      cb2g:
          if (R1 & 7 != 1) goto cb2t; else goto ub39;
      cb2t:
          _sazd::P64 = P64[Sp + 8];
          _sazi::P64 = P64[Sp + 16];
          _sazj::I64 = I64[Sp + 24];
          _sazq::P64 = P64[R1 + 14];
          P64[(_sazd::P64 + 24) + (_sazj::I64 << 3)] = P64[R1 + 6];
          I64[_sazd::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
          I8[(_sazd::P64 + 24) + ((I64[_sazd::P64 + 8] << 3) + (_sazj::I64 >> 7))] = 1 :: W8;
          R3 = _sazq::P64;
          R2 = _sazj::I64 + 1;
          R1 = _sazi::P64;
          Sp = Sp + 32;
          call $wa8_sazi_info(R3, R2, R1) args: 8, res: 0, upd: 8;
      ub39:
          Sp = Sp + 32;
          goto cb2u;
      cb2u:
          R1 = GHC.Tuple.()_closure+1;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:45.447707 UTC

{offset
  cb2A:
      _sazC::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cb2B; else goto cb2C;
  cb2C:
      if (HpLim == 0) goto cb2B; else goto cb2D;
  cb2B:
      R1 = _sazC::P64;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  cb2D:
      _sayY::P64 = P64[_sazC::P64 + 7];
      _saz4::P64 = P64[_sazC::P64 + 15];
      _saz1::I64 = I64[_sazC::P64 + 23];
      I64[(young<cb1I> + 8)] = cb1I;
      R1 = _sayY::P64;
      if (R1 & 7 != 0) goto cb1I; else goto cb1J;
  cb1J:
      call (I64[R1])(R1) returns to cb1I, args: 8, res: 8, upd: 8;
  cb1I:
      _saz6::P64 = R1;
      _saz7::P64 = P64[_saz6::P64 + 7];
      _saz8::P64 = P64[_saz6::P64 + 15];
      _cb1N::I64 = %MO_S_Lt_W64(_saz1::I64, 0);
      _saz9::I64 = _cb1N::I64;
      switch [0 .. 1] _saz9::I64 {
          case 0 : goto cb2G;
          case 1 : goto cb2V;
      }
  cb2V:
      R1 = GHC.Arr.negRange_closure;
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
  cb2G:
      I64[(young<cb1S> + 8)] = cb1S;
      R2 = Data.Array.Base.arrEleBottom_closure;
      R1 = _saz1::I64;
      call stg_newArray#(R2,
                         R1) returns to cb1S, args: 8, res: 8, upd: 8;
  cb1S:
      _sazd::P64 = R1;
      I64[(young<cb1U> + 8)] = cb1U;
      R1 = _saz7::P64;
      call stg_ap_0_fast(R1) returns to cb1U, args: 8, res: 8, upd: 8;
  cb1U:
      _saze::P64 = R1;
      I64[(young<cb1W> + 8)] = cb1W;
      R1 = _saz8::P64;
      call stg_ap_0_fast(R1) returns to cb1W, args: 8, res: 8, upd: 8;
  cb1W:
      _sazf::P64 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto cb2L; else goto cb2K;
  cb2L:
      HpAlloc = 24;
      R1 = _sazf::P64;
      call stg_gc_unpt_r1(R1) returns to cb1W, args: 8, res: 8, upd: 8;
  cb2K:
      _cb1Y::I64 = %MO_S_Lt_W64(_saz1::I64, 0);
      _sazg::I64 = _cb1Y::I64;
      switch [0 .. 1] _sazg::I64 {
          case 0 : goto cb2Q;
          case 1 : goto cb2U;
      }
  cb2U:
      Hp = Hp - 24;
      R1 = SkipList.$fMArrayTArrayeSTM5_closure;
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
  cb2Q:
      _cb23::P64 = Hp - 13;
      I64[Hp - 16] = $wa8_sazi_info;
      P64[Hp - 8] = _sazd::P64;
      I64[Hp] = _saz1::I64;
      I64[(young<cb2M> + 8)] = cb2M;
      R3 = _saz4::P64;
      R2 = 0;
      R1 = _cb23::P64;
      call $wa8_sazi_info(R3,
                          R2,
                          R1) returns to cb2M, args: 8, res: 8, upd: 8;
  cb2M:
      _sazv::P64 = R1;
      Hp = Hp + 40;
      if (Hp > HpLim) goto cb2T; else goto cb2S;
  cb2T:
      HpAlloc = 40;
      R1 = _sazv::P64;
      call stg_gc_unpt_r1(R1) returns to cb2M, args: 8, res: 8, upd: 8;
  cb2S:
      I64[_sazd::P64] = stg_MUT_ARR_PTRS_FROZEN0_info;
      _sazy::P64 = _sazd::P64;
      _sazy::P64 = _sazy::P64;
      I64[Hp - 32] = GHC.Arr.Array_con_info;
      P64[Hp - 24] = _saze::P64;
      P64[Hp - 16] = _sazf::P64;
      P64[Hp - 8] = _sazy::P64;
      I64[Hp] = _saz1::I64;
      _cb2O::P64 = Hp - 31;
      R1 = _cb2O::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:45.452172 UTC

{offset
  cb2A:
      _sazC::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cb2B; else goto cb2C;
  cb2C:
      if (HpLim == 0) goto cb2B; else goto cb2D;
  cb2B:
      R1 = _sazC::P64;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  cb2D:
      _sayY::P64 = P64[_sazC::P64 + 7];
      _saz4::P64 = P64[_sazC::P64 + 15];
      _saz1::I64 = I64[_sazC::P64 + 23];
      I64[(young<cb1I> + 8)] = cb1I;
      R1 = _sayY::P64;
      if (R1 & 7 != 0) goto cb1I; else goto cb1J;
  cb1J:
      call (I64[R1])(R1) returns to cb1I, args: 8, res: 8, upd: 8;
  cb1I:
      _saz6::P64 = R1;
      _saz7::P64 = P64[_saz6::P64 + 7];
      _saz8::P64 = P64[_saz6::P64 + 15];
      _cb1N::I64 = %MO_S_Lt_W64(_saz1::I64, 0);
      _saz9::I64 = _cb1N::I64;
      switch [0 .. 1] _saz9::I64 {
          case 0 : goto cb2G;
          case 1 : goto cb2V;
      }
  cb2V:
      R1 = GHC.Arr.negRange_closure;
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
  cb2G:
      I64[(young<cb1S> + 8)] = cb1S;
      R2 = Data.Array.Base.arrEleBottom_closure;
      R1 = _saz1::I64;
      call stg_newArray#(R2,
                         R1) returns to cb1S, args: 8, res: 8, upd: 8;
  cb1S:
      _sazd::P64 = R1;
      I64[(young<cb1U> + 8)] = cb1U;
      R1 = _saz7::P64;
      call stg_ap_0_fast(R1) returns to cb1U, args: 8, res: 8, upd: 8;
  cb1U:
      _saze::P64 = R1;
      I64[(young<cb1W> + 8)] = cb1W;
      R1 = _saz8::P64;
      call stg_ap_0_fast(R1) returns to cb1W, args: 8, res: 8, upd: 8;
  cb1W:
      _sazf::P64 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto cb2L; else goto cb2K;
  cb2L:
      HpAlloc = 24;
      R1 = _sazf::P64;
      call stg_gc_unpt_r1(R1) returns to cb1W, args: 8, res: 8, upd: 8;
  cb2K:
      _cb1Y::I64 = %MO_S_Lt_W64(_saz1::I64, 0);
      _sazg::I64 = _cb1Y::I64;
      switch [0 .. 1] _sazg::I64 {
          case 0 : goto cb2Q;
          case 1 : goto cb2U;
      }
  cb2U:
      Hp = Hp - 24;
      R1 = SkipList.$fMArrayTArrayeSTM5_closure;
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
  cb2Q:
      _cb23::P64 = Hp - 13;
      I64[Hp - 16] = $wa8_sazi_info;
      P64[Hp - 8] = _sazd::P64;
      I64[Hp] = _saz1::I64;
      I64[(young<cb2M> + 8)] = cb2M;
      R3 = _saz4::P64;
      R2 = 0;
      R1 = _cb23::P64;
      call $wa8_sazi_info(R3,
                          R2,
                          R1) returns to cb2M, args: 8, res: 8, upd: 8;
  cb2M:
      _sazv::P64 = R1;
      Hp = Hp + 40;
      if (Hp > HpLim) goto cb2T; else goto cb2S;
  cb2T:
      HpAlloc = 40;
      R1 = _sazv::P64;
      call stg_gc_unpt_r1(R1) returns to cb2M, args: 8, res: 8, upd: 8;
  cb2S:
      I64[_sazd::P64] = stg_MUT_ARR_PTRS_FROZEN0_info;
      _sazy::P64 = _sazd::P64;
      _sazy::P64 = _sazy::P64;
      I64[Hp - 32] = GHC.Arr.Array_con_info;
      P64[Hp - 24] = _saze::P64;
      P64[Hp - 16] = _sazf::P64;
      P64[Hp - 8] = _sazy::P64;
      I64[Hp] = _saz1::I64;
      _cb2O::P64 = Hp - 31;
      R1 = _cb2O::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:45.456657 UTC

{offset
  cb2A:
      _sazC::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cb2B; else goto cb2C;
  cb2C:
      if (HpLim == 0) goto cb2B; else goto cb2D;
  cb2B:
      R1 = _sazC::P64;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  cb2D:
      _sayY::P64 = P64[_sazC::P64 + 7];
      _saz4::P64 = P64[_sazC::P64 + 15];
      _saz1::I64 = I64[_sazC::P64 + 23];
      I64[(young<cb1I> + 8)] = cb1I;
      R1 = _sayY::P64;
      if (R1 & 7 != 0) goto cb1I; else goto cb1J;
  cb1J:
      call (I64[R1])(R1) returns to cb1I, args: 8, res: 8, upd: 8;
  cb1I:
      _saz6::P64 = R1;
      _saz7::P64 = P64[_saz6::P64 + 7];
      _saz8::P64 = P64[_saz6::P64 + 15];
      _cb1N::I64 = %MO_S_Lt_W64(_saz1::I64, 0);
      _saz9::I64 = _cb1N::I64;
      if (_saz9::I64 != 0) goto cb2V; else goto cb2G;
  cb2V:
      R1 = GHC.Arr.negRange_closure;
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
  cb2G:
      I64[(young<cb1S> + 8)] = cb1S;
      R2 = Data.Array.Base.arrEleBottom_closure;
      R1 = _saz1::I64;
      call stg_newArray#(R2,
                         R1) returns to cb1S, args: 8, res: 8, upd: 8;
  cb1S:
      _sazd::P64 = R1;
      I64[(young<cb1U> + 8)] = cb1U;
      R1 = _saz7::P64;
      call stg_ap_0_fast(R1) returns to cb1U, args: 8, res: 8, upd: 8;
  cb1U:
      _saze::P64 = R1;
      I64[(young<cb1W> + 8)] = cb1W;
      R1 = _saz8::P64;
      call stg_ap_0_fast(R1) returns to cb1W, args: 8, res: 8, upd: 8;
  cb1W:
      _sazf::P64 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto cb2L; else goto cb2K;
  cb2L:
      HpAlloc = 24;
      R1 = _sazf::P64;
      call stg_gc_unpt_r1(R1) returns to cb1W, args: 8, res: 8, upd: 8;
  cb2K:
      _cb1Y::I64 = %MO_S_Lt_W64(_saz1::I64, 0);
      _sazg::I64 = _cb1Y::I64;
      if (_sazg::I64 != 0) goto cb2U; else goto cb2Q;
  cb2U:
      Hp = Hp - 24;
      R1 = SkipList.$fMArrayTArrayeSTM5_closure;
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
  cb2Q:
      _cb23::P64 = Hp - 13;
      I64[Hp - 16] = $wa8_sazi_info;
      P64[Hp - 8] = _sazd::P64;
      I64[Hp] = _saz1::I64;
      I64[(young<cb2M> + 8)] = cb2M;
      R3 = _saz4::P64;
      R2 = 0;
      R1 = _cb23::P64;
      call $wa8_sazi_info(R3,
                          R2,
                          R1) returns to cb2M, args: 8, res: 8, upd: 8;
  cb2M:
      _sazv::P64 = R1;
      Hp = Hp + 40;
      if (Hp > HpLim) goto cb2T; else goto cb2S;
  cb2T:
      HpAlloc = 40;
      R1 = _sazv::P64;
      call stg_gc_unpt_r1(R1) returns to cb2M, args: 8, res: 8, upd: 8;
  cb2S:
      I64[_sazd::P64] = stg_MUT_ARR_PTRS_FROZEN0_info;
      _sazy::P64 = _sazd::P64;
      _sazy::P64 = _sazy::P64;
      I64[Hp - 32] = GHC.Arr.Array_con_info;
      P64[Hp - 24] = _saze::P64;
      P64[Hp - 16] = _sazf::P64;
      P64[Hp - 8] = _sazy::P64;
      I64[Hp] = _saz1::I64;
      _cb2O::P64 = Hp - 31;
      R1 = _cb2O::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:45.461487 UTC

{offset
  cb2A:
      _sazC::P64 = R1;
      if ((Sp + 8) - 48 < SpLim) goto cb2B; else goto cb2C;
  cb2C:
      if (HpLim == 0) goto cb2B; else goto cb2D;
  cb2B:
      R1 = _sazC::P64;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  cb2D:
      _sayY::P64 = P64[_sazC::P64 + 7];
      _saz4::P64 = P64[_sazC::P64 + 15];
      _saz1::I64 = I64[_sazC::P64 + 23];
      I64[Sp - 24] = cb1I;
      R1 = _sayY::P64;
      I64[Sp - 16] = _saz1::I64;
      P64[Sp - 8] = _saz4::P64;
      Sp = Sp - 24;
      if (R1 & 7 != 0) goto cb1I; else goto cb1J;
  cb1J:
      call (I64[R1])(R1) returns to cb1I, args: 8, res: 8, upd: 8;
  cb1I:
      _saz1::I64 = I64[Sp + 8];
      _saz4::P64 = P64[Sp + 16];
      _saz6::P64 = R1;
      _saz7::P64 = P64[_saz6::P64 + 7];
      _saz8::P64 = P64[_saz6::P64 + 15];
      _cb1N::I64 = %MO_S_Lt_W64(_saz1::I64, 0);
      _saz9::I64 = _cb1N::I64;
      if (_saz9::I64 != 0) goto cb2V; else goto cb2G;
  cb2V:
      R1 = GHC.Arr.negRange_closure;
      Sp = Sp + 24;
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
  cb2G:
      I64[Sp - 16] = cb1S;
      R2 = Data.Array.Base.arrEleBottom_closure;
      R1 = _saz1::I64;
      P64[Sp - 8] = _saz8::P64;
      P64[Sp] = _saz7::P64;
      Sp = Sp - 16;
      call stg_newArray#(R2,
                         R1) returns to cb1S, args: 8, res: 8, upd: 8;
  cb1S:
      _saz1::I64 = I64[Sp + 24];
      _saz4::P64 = P64[Sp + 32];
      _saz7::P64 = P64[Sp + 16];
      _saz8::P64 = P64[Sp + 8];
      _sazd::P64 = R1;
      I64[Sp] = cb1U;
      R1 = _saz7::P64;
      P64[Sp + 16] = _sazd::P64;
      call stg_ap_0_fast(R1) returns to cb1U, args: 8, res: 8, upd: 8;
  cb1U:
      _saz1::I64 = I64[Sp + 24];
      _saz4::P64 = P64[Sp + 32];
      _saz8::P64 = P64[Sp + 8];
      _sazd::P64 = P64[Sp + 16];
      _saze::P64 = R1;
      I64[Sp] = cb1W;
      R1 = _saz8::P64;
      P64[Sp + 8] = _saze::P64;
      call stg_ap_0_fast(R1) returns to cb1W, args: 8, res: 8, upd: 8;
  cb1W:
      _saz1::I64 = I64[Sp + 24];
      _saz4::P64 = P64[Sp + 32];
      _sazd::P64 = P64[Sp + 16];
      _saze::P64 = P64[Sp + 8];
      _sazf::P64 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto cb2L; else goto cb2K;
  cb2L:
      HpAlloc = 24;
      R1 = _sazf::P64;
      call stg_gc_unpt_r1(R1) returns to cb1W, args: 8, res: 8, upd: 8;
  cb2K:
      _cb1Y::I64 = %MO_S_Lt_W64(_saz1::I64, 0);
      _sazg::I64 = _cb1Y::I64;
      if (_sazg::I64 != 0) goto cb2U; else goto cb2Q;
  cb2U:
      Hp = Hp - 24;
      R1 = SkipList.$fMArrayTArrayeSTM5_closure;
      Sp = Sp + 40;
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
  cb2Q:
      _cb23::P64 = Hp - 13;
      I64[Hp - 16] = $wa8_sazi_info;
      P64[Hp - 8] = _sazd::P64;
      I64[Hp] = _saz1::I64;
      I64[Sp] = cb2M;
      R3 = _saz4::P64;
      R2 = 0;
      R1 = _cb23::P64;
      P64[Sp + 32] = _sazf::P64;
      call $wa8_sazi_info(R3,
                          R2,
                          R1) returns to cb2M, args: 8, res: 8, upd: 8;
  cb2M:
      _saz1::I64 = I64[Sp + 24];
      _sazd::P64 = P64[Sp + 16];
      _saze::P64 = P64[Sp + 8];
      _sazf::P64 = P64[Sp + 32];
      _sazv::P64 = R1;
      Hp = Hp + 40;
      if (Hp > HpLim) goto cb2T; else goto cb2S;
  cb2T:
      HpAlloc = 40;
      R1 = _sazv::P64;
      call stg_gc_unpt_r1(R1) returns to cb2M, args: 8, res: 8, upd: 8;
  cb2S:
      I64[_sazd::P64] = stg_MUT_ARR_PTRS_FROZEN0_info;
      _sazy::P64 = _sazd::P64;
      _sazy::P64 = _sazy::P64;
      I64[Hp - 32] = GHC.Arr.Array_con_info;
      P64[Hp - 24] = _saze::P64;
      P64[Hp - 16] = _sazf::P64;
      P64[Hp - 8] = _sazy::P64;
      I64[Hp] = _saz1::I64;
      _cb2O::P64 = Hp - 31;
      R1 = _cb2O::P64;
      Sp = Sp + 40;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:45.467393 UTC

{offset
  cb2A:
      _sazC::P64 = R1;
      if ((Sp + -40) < SpLim) goto cb2B; else goto cb2C;
  cb2C:
      if (HpLim == 0) goto cb2B; else goto cb2D;
  cb2B:
      R1 = _sazC::P64;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  cb2D:
      I64[Sp - 24] = cb1I;
      R1 = P64[_sazC::P64 + 7];
      I64[Sp - 16] = I64[_sazC::P64 + 23];
      P64[Sp - 8] = P64[_sazC::P64 + 15];
      Sp = Sp - 24;
      if (R1 & 7 != 0) goto cb1I; else goto cb1J;
  cb1J:
      call (I64[R1])(R1) returns to cb1I, args: 8, res: 8, upd: 8;
  cb1I:
      _saz1::I64 = I64[Sp + 8];
      if (%MO_S_Lt_W64(_saz1::I64, 0)) goto cb2V; else goto cb2G;
  cb2V:
      R1 = GHC.Arr.negRange_closure;
      Sp = Sp + 24;
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
  cb2G:
      I64[Sp - 16] = cb1S;
      R2 = Data.Array.Base.arrEleBottom_closure;
      _saz7::P64 = P64[R1 + 7];
      _saz8::P64 = P64[R1 + 15];
      R1 = _saz1::I64;
      P64[Sp - 8] = _saz8::P64;
      P64[Sp] = _saz7::P64;
      Sp = Sp - 16;
      call stg_newArray#(R2,
                         R1) returns to cb1S, args: 8, res: 8, upd: 8;
  cb1S:
      I64[Sp] = cb1U;
      _sazd::P64 = R1;
      R1 = P64[Sp + 16];
      P64[Sp + 16] = _sazd::P64;
      call stg_ap_0_fast(R1) returns to cb1U, args: 8, res: 8, upd: 8;
  cb1U:
      I64[Sp] = cb1W;
      _saze::P64 = R1;
      R1 = P64[Sp + 8];
      P64[Sp + 8] = _saze::P64;
      call stg_ap_0_fast(R1) returns to cb1W, args: 8, res: 8, upd: 8;
  cb1W:
      Hp = Hp + 24;
      if (Hp > HpLim) goto cb2L; else goto cb2K;
  cb2L:
      HpAlloc = 24;
      R1 = R1;
      call stg_gc_unpt_r1(R1) returns to cb1W, args: 8, res: 8, upd: 8;
  cb2K:
      _saz1::I64 = I64[Sp + 24];
      if (%MO_S_Lt_W64(_saz1::I64, 0)) goto cb2U; else goto cb2Q;
  cb2U:
      Hp = Hp - 24;
      R1 = SkipList.$fMArrayTArrayeSTM5_closure;
      Sp = Sp + 40;
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
  cb2Q:
      I64[Hp - 16] = $wa8_sazi_info;
      P64[Hp - 8] = P64[Sp + 16];
      I64[Hp] = _saz1::I64;
      I64[Sp] = cb2M;
      R3 = P64[Sp + 32];
      R2 = 0;
      _sazf::P64 = R1;
      R1 = Hp - 13;
      P64[Sp + 32] = _sazf::P64;
      call $wa8_sazi_info(R3,
                          R2,
                          R1) returns to cb2M, args: 8, res: 8, upd: 8;
  cb2M:
      Hp = Hp + 40;
      if (Hp > HpLim) goto cb2T; else goto cb2S;
  cb2T:
      HpAlloc = 40;
      R1 = R1;
      call stg_gc_unpt_r1(R1) returns to cb2M, args: 8, res: 8, upd: 8;
  cb2S:
      _sazd::P64 = P64[Sp + 16];
      I64[_sazd::P64] = stg_MUT_ARR_PTRS_FROZEN0_info;
      I64[Hp - 32] = GHC.Arr.Array_con_info;
      P64[Hp - 24] = P64[Sp + 8];
      P64[Hp - 16] = P64[Sp + 32];
      P64[Hp - 8] = _sazd::P64;
      I64[Hp] = I64[Sp + 24];
      R1 = Hp - 31;
      Sp = Sp + 40;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:45.473932 UTC

[(cb1I,
  {GHC.Arr.negRange_closure, Data.Array.Base.arrEleBottom_closure,
   SkipList.$fMArrayTArrayeSTM5_closure, $wa8_sazi_closure}),
 (cb1J,
  {GHC.Arr.negRange_closure, Data.Array.Base.arrEleBottom_closure,
   SkipList.$fMArrayTArrayeSTM5_closure, $wa8_sazi_closure}),
 (cb1S, {SkipList.$fMArrayTArrayeSTM5_closure, $wa8_sazi_closure}),
 (cb1U, {SkipList.$fMArrayTArrayeSTM5_closure, $wa8_sazi_closure}),
 (cb1W, {SkipList.$fMArrayTArrayeSTM5_closure, $wa8_sazi_closure}),
 (cb2A,
  {GHC.Arr.negRange_closure, Data.Array.Base.arrEleBottom_closure,
   SkipList.$fMArrayTArrayeSTM5_closure, $wa8_sazi_closure}),
 (cb2B, {}),
 (cb2C,
  {GHC.Arr.negRange_closure, Data.Array.Base.arrEleBottom_closure,
   SkipList.$fMArrayTArrayeSTM5_closure, $wa8_sazi_closure}),
 (cb2D,
  {GHC.Arr.negRange_closure, Data.Array.Base.arrEleBottom_closure,
   SkipList.$fMArrayTArrayeSTM5_closure, $wa8_sazi_closure}),
 (cb2G,
  {Data.Array.Base.arrEleBottom_closure,
   SkipList.$fMArrayTArrayeSTM5_closure, $wa8_sazi_closure}),
 (cb2K, {SkipList.$fMArrayTArrayeSTM5_closure, $wa8_sazi_closure}),
 (cb2L, {SkipList.$fMArrayTArrayeSTM5_closure, $wa8_sazi_closure}),
 (cb2M, {}), (cb2Q, {$wa8_sazi_closure}), (cb2S, {}), (cb2T, {}),
 (cb2U, {SkipList.$fMArrayTArrayeSTM5_closure}),
 (cb2V, {GHC.Arr.negRange_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:45.475711 UTC

sat_sazC_entry() //  [R1]
        { info_tbl: [(cb1I,
                      label: block_cb1I_info
                      rep:StackRep [True, False]),
                     (cb1S,
                      label: block_cb1S_info
                      rep:StackRep [False, False, True, False]),
                     (cb1U,
                      label: block_cb1U_info
                      rep:StackRep [False, False, True, False]),
                     (cb1W,
                      label: block_cb1W_info
                      rep:StackRep [False, False, True, False]),
                     (cb2A,
                      label: sat_sazC_info
                      rep:HeapRep 2 ptrs 1 nonptrs {
                            Fun {arity: 1 fun_type: ArgSpec 3} }),
                     (cb2M,
                      label: block_cb2M_info
                      rep:StackRep [False, False, True, False])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cb2A:
          _sazC::P64 = R1;
          if ((Sp + -40) < SpLim) goto cb2B; else goto cb2C;
      cb2C:
          if (HpLim == 0) goto cb2B; else goto cb2D;
      cb2B:
          R1 = _sazC::P64;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
      cb2D:
          I64[Sp - 24] = cb1I;
          R1 = P64[_sazC::P64 + 7];
          I64[Sp - 16] = I64[_sazC::P64 + 23];
          P64[Sp - 8] = P64[_sazC::P64 + 15];
          Sp = Sp - 24;
          if (R1 & 7 != 0) goto cb1I; else goto cb1J;
      cb1J:
          call (I64[R1])(R1) returns to cb1I, args: 8, res: 8, upd: 8;
      cb1I:
          _saz1::I64 = I64[Sp + 8];
          if (%MO_S_Lt_W64(_saz1::I64, 0)) goto cb2V; else goto cb2G;
      cb2V:
          R1 = GHC.Arr.negRange_closure;
          Sp = Sp + 24;
          call (I64[R1])(R1) args: 8, res: 0, upd: 8;
      cb2G:
          I64[Sp - 16] = cb1S;
          R2 = Data.Array.Base.arrEleBottom_closure;
          _saz7::P64 = P64[R1 + 7];
          _saz8::P64 = P64[R1 + 15];
          R1 = _saz1::I64;
          P64[Sp - 8] = _saz8::P64;
          P64[Sp] = _saz7::P64;
          Sp = Sp - 16;
          call stg_newArray#(R2,
                             R1) returns to cb1S, args: 8, res: 8, upd: 8;
      cb1S:
          I64[Sp] = cb1U;
          _sazd::P64 = R1;
          R1 = P64[Sp + 16];
          P64[Sp + 16] = _sazd::P64;
          call stg_ap_0_fast(R1) returns to cb1U, args: 8, res: 8, upd: 8;
      cb1U:
          I64[Sp] = cb1W;
          _saze::P64 = R1;
          R1 = P64[Sp + 8];
          P64[Sp + 8] = _saze::P64;
          call stg_ap_0_fast(R1) returns to cb1W, args: 8, res: 8, upd: 8;
      cb1W:
          Hp = Hp + 24;
          if (Hp > HpLim) goto cb2L; else goto cb2K;
      cb2L:
          HpAlloc = 24;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to cb1W, args: 8, res: 8, upd: 8;
      cb2K:
          _saz1::I64 = I64[Sp + 24];
          if (%MO_S_Lt_W64(_saz1::I64, 0)) goto cb2U; else goto cb2Q;
      cb2U:
          Hp = Hp - 24;
          R1 = SkipList.$fMArrayTArrayeSTM5_closure;
          Sp = Sp + 40;
          call (I64[R1])(R1) args: 8, res: 0, upd: 8;
      cb2Q:
          I64[Hp - 16] = $wa8_sazi_info;
          P64[Hp - 8] = P64[Sp + 16];
          I64[Hp] = _saz1::I64;
          I64[Sp] = cb2M;
          R3 = P64[Sp + 32];
          R2 = 0;
          _sazf::P64 = R1;
          R1 = Hp - 13;
          P64[Sp + 32] = _sazf::P64;
          call $wa8_sazi_info(R3,
                              R2,
                              R1) returns to cb2M, args: 8, res: 8, upd: 8;
      cb2M:
          Hp = Hp + 40;
          if (Hp > HpLim) goto cb2T; else goto cb2S;
      cb2T:
          HpAlloc = 40;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to cb2M, args: 8, res: 8, upd: 8;
      cb2S:
          _sazd::P64 = P64[Sp + 16];
          I64[_sazd::P64] = stg_MUT_ARR_PTRS_FROZEN0_info;
          I64[Hp - 32] = GHC.Arr.Array_con_info;
          P64[Hp - 24] = P64[Sp + 8];
          P64[Hp - 16] = P64[Sp + 32];
          P64[Hp - 8] = _sazd::P64;
          I64[Hp] = I64[Sp + 24];
          R1 = Hp - 31;
          Sp = Sp + 40;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:45.481192 UTC

sat_sazC_entry() //  [R1]
        { info_tbl: [(cb1I,
                      label: block_cb1I_info
                      rep:StackRep [True, False]),
                     (cb1S,
                      label: block_cb1S_info
                      rep:StackRep [False, False, True, False]),
                     (cb1U,
                      label: block_cb1U_info
                      rep:StackRep [False, False, True, False]),
                     (cb1W,
                      label: block_cb1W_info
                      rep:StackRep [False, False, True, False]),
                     (cb2A,
                      label: sat_sazC_info
                      rep:HeapRep 2 ptrs 1 nonptrs {
                            Fun {arity: 1 fun_type: ArgSpec 3} }),
                     (cb2M,
                      label: block_cb2M_info
                      rep:StackRep [False, False, True, False])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cb2A:
          _sazC::P64 = R1;
          if ((Sp + -40) < SpLim) goto cb2B; else goto cb2C;
      cb2C:
          if (HpLim == 0) goto cb2B; else goto cb2D;
      cb2B:
          R1 = _sazC::P64;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
      cb2D:
          I64[Sp - 24] = cb1I;
          R1 = P64[_sazC::P64 + 7];
          I64[Sp - 16] = I64[_sazC::P64 + 23];
          P64[Sp - 8] = P64[_sazC::P64 + 15];
          Sp = Sp - 24;
          if (R1 & 7 != 0) goto cb1I; else goto cb1J;
      cb1J:
          call (I64[R1])(R1) returns to cb1I, args: 8, res: 8, upd: 8;
      cb1I:
          _saz1::I64 = I64[Sp + 8];
          if (%MO_S_Lt_W64(_saz1::I64, 0)) goto cb2V; else goto cb2G;
      cb2V:
          R1 = GHC.Arr.negRange_closure;
          Sp = Sp + 24;
          call (I64[R1])(R1) args: 8, res: 0, upd: 8;
      cb2G:
          I64[Sp - 16] = cb1S;
          R2 = Data.Array.Base.arrEleBottom_closure;
          _saz7::P64 = P64[R1 + 7];
          _saz8::P64 = P64[R1 + 15];
          R1 = _saz1::I64;
          P64[Sp - 8] = _saz8::P64;
          P64[Sp] = _saz7::P64;
          Sp = Sp - 16;
          call stg_newArray#(R2,
                             R1) returns to cb1S, args: 8, res: 8, upd: 8;
      cb1S:
          I64[Sp] = cb1U;
          _sazd::P64 = R1;
          R1 = P64[Sp + 16];
          P64[Sp + 16] = _sazd::P64;
          call stg_ap_0_fast(R1) returns to cb1U, args: 8, res: 8, upd: 8;
      cb1U:
          I64[Sp] = cb1W;
          _saze::P64 = R1;
          R1 = P64[Sp + 8];
          P64[Sp + 8] = _saze::P64;
          call stg_ap_0_fast(R1) returns to cb1W, args: 8, res: 8, upd: 8;
      cb1W:
          Hp = Hp + 24;
          if (Hp > HpLim) goto cb2L; else goto cb2K;
      cb2L:
          HpAlloc = 24;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to cb1W, args: 8, res: 8, upd: 8;
      cb2K:
          _saz1::I64 = I64[Sp + 24];
          if (%MO_S_Lt_W64(_saz1::I64, 0)) goto cb2U; else goto cb2Q;
      cb2U:
          Hp = Hp - 24;
          R1 = SkipList.$fMArrayTArrayeSTM5_closure;
          Sp = Sp + 40;
          call (I64[R1])(R1) args: 8, res: 0, upd: 8;
      cb2Q:
          I64[Hp - 16] = $wa8_sazi_info;
          P64[Hp - 8] = P64[Sp + 16];
          I64[Hp] = _saz1::I64;
          I64[Sp] = cb2M;
          R3 = P64[Sp + 32];
          R2 = 0;
          _sazf::P64 = R1;
          R1 = Hp - 13;
          P64[Sp + 32] = _sazf::P64;
          call $wa8_sazi_info(R3,
                              R2,
                              R1) returns to cb2M, args: 8, res: 8, upd: 8;
      cb2M:
          Hp = Hp + 40;
          if (Hp > HpLim) goto cb2T; else goto cb2S;
      cb2T:
          HpAlloc = 40;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to cb2M, args: 8, res: 8, upd: 8;
      cb2S:
          _sazd::P64 = P64[Sp + 16];
          I64[_sazd::P64] = stg_MUT_ARR_PTRS_FROZEN0_info;
          I64[Hp - 32] = GHC.Arr.Array_con_info;
          P64[Hp - 24] = P64[Sp + 8];
          P64[Hp - 16] = P64[Sp + 32];
          P64[Hp - 8] = _sazd::P64;
          I64[Hp] = I64[Sp + 24];
          R1 = Hp - 31;
          Sp = Sp + 40;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:45.486688 UTC

{offset
  cb2W:
      _sazD::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cb2X; else goto cb2Y;
  cb2Y:
      Hp = Hp + 32;
      if (Hp > HpLim) goto cb30; else goto cb2Z;
  cb30:
      HpAlloc = 32;
      goto cb2X;
  cb2X:
      R1 = _sazD::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cb2Z:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sazD::P64;
      _sayY::P64 = P64[_sazD::P64 + 16];
      _saz4::P64 = P64[_sazD::P64 + 24];
      _saz1::I64 = I64[_sazD::P64 + 32];
      I64[Hp - 24] = sat_sazC_info;
      P64[Hp - 16] = _sayY::P64;
      P64[Hp - 8] = _saz4::P64;
      I64[Hp] = _saz1::I64;
      _cb1D::P64 = Hp - 23;
      R2 = _cb1D::P64;
      call GHC.ST.runSTRep_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:45.488011 UTC

{offset
  cb2W:
      _sazD::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cb2X; else goto cb2Y;
  cb2Y:
      Hp = Hp + 32;
      if (Hp > HpLim) goto cb30; else goto cb2Z;
  cb30:
      HpAlloc = 32;
      goto cb2X;
  cb2X:
      R1 = _sazD::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cb2Z:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sazD::P64;
      _sayY::P64 = P64[_sazD::P64 + 16];
      _saz4::P64 = P64[_sazD::P64 + 24];
      _saz1::I64 = I64[_sazD::P64 + 32];
      I64[Hp - 24] = sat_sazC_info;
      P64[Hp - 16] = _sayY::P64;
      P64[Hp - 8] = _saz4::P64;
      I64[Hp] = _saz1::I64;
      _cb1D::P64 = Hp - 23;
      R2 = _cb1D::P64;
      call GHC.ST.runSTRep_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:45.489337 UTC

{offset
  cb2W:
      _sazD::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cb2X; else goto cb2Y;
  cb2Y:
      Hp = Hp + 32;
      if (Hp > HpLim) goto cb30; else goto cb2Z;
  cb30:
      HpAlloc = 32;
      goto cb2X;
  cb2X:
      R1 = _sazD::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cb2Z:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sazD::P64;
      _sayY::P64 = P64[_sazD::P64 + 16];
      _saz4::P64 = P64[_sazD::P64 + 24];
      _saz1::I64 = I64[_sazD::P64 + 32];
      I64[Hp - 24] = sat_sazC_info;
      P64[Hp - 16] = _sayY::P64;
      P64[Hp - 8] = _saz4::P64;
      I64[Hp] = _saz1::I64;
      _cb1D::P64 = Hp - 23;
      R2 = _cb1D::P64;
      call GHC.ST.runSTRep_info(R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:45.490696 UTC

{offset
  cb2W:
      _sazD::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto cb2X; else goto cb2Y;
  cb2Y:
      Hp = Hp + 32;
      if (Hp > HpLim) goto cb30; else goto cb2Z;
  cb30:
      HpAlloc = 32;
      goto cb2X;
  cb2X:
      R1 = _sazD::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cb2Z:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _sazD::P64;
      _sayY::P64 = P64[_sazD::P64 + 16];
      _saz4::P64 = P64[_sazD::P64 + 24];
      _saz1::I64 = I64[_sazD::P64 + 32];
      I64[Hp - 24] = sat_sazC_info;
      P64[Hp - 16] = _sayY::P64;
      P64[Hp - 8] = _saz4::P64;
      I64[Hp] = _saz1::I64;
      _cb1D::P64 = Hp - 23;
      R2 = _cb1D::P64;
      Sp = Sp - 16;
      call GHC.ST.runSTRep_info(R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:45.492012 UTC

{offset
  cb2W:
      _sazD::P64 = R1;
      if ((Sp + -16) < SpLim) goto cb2X; else goto cb2Y;
  cb2Y:
      Hp = Hp + 32;
      if (Hp > HpLim) goto cb30; else goto cb2Z;
  cb30:
      HpAlloc = 32;
      goto cb2X;
  cb2X:
      R1 = _sazD::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cb2Z:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _sazD::P64;
      _sayY::P64 = P64[_sazD::P64 + 16];
      _saz4::P64 = P64[_sazD::P64 + 24];
      _saz1::I64 = I64[_sazD::P64 + 32];
      I64[Hp - 24] = sat_sazC_info;
      P64[Hp - 16] = _sayY::P64;
      P64[Hp - 8] = _saz4::P64;
      I64[Hp] = _saz1::I64;
      R2 = Hp - 23;
      Sp = Sp - 16;
      call GHC.ST.runSTRep_info(R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:45.493493 UTC

[(cb2W, {sat_sazC_closure}), (cb2X, {}),
 (cb2Y, {sat_sazC_closure}), (cb2Z, {sat_sazC_closure}), (cb30, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:45.493932 UTC

sat_sazD_entry() //  [R1]
        { info_tbl: [(cb2W,
                      label: sat_sazD_info
                      rep:HeapRep 2 ptrs 1 nonptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cb2W:
          _sazD::P64 = R1;
          if ((Sp + -16) < SpLim) goto cb2X; else goto cb2Y;
      cb2Y:
          Hp = Hp + 32;
          if (Hp > HpLim) goto cb30; else goto cb2Z;
      cb30:
          HpAlloc = 32;
          goto cb2X;
      cb2X:
          R1 = _sazD::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      cb2Z:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _sazD::P64;
          _sayY::P64 = P64[_sazD::P64 + 16];
          _saz4::P64 = P64[_sazD::P64 + 24];
          _saz1::I64 = I64[_sazD::P64 + 32];
          I64[Hp - 24] = sat_sazC_info;
          P64[Hp - 16] = _sayY::P64;
          P64[Hp - 8] = _saz4::P64;
          I64[Hp] = _saz1::I64;
          R2 = Hp - 23;
          Sp = Sp - 16;
          call GHC.ST.runSTRep_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:45.49548 UTC

sat_sazD_entry() //  [R1]
        { info_tbl: [(cb2W,
                      label: sat_sazD_info
                      rep:HeapRep 2 ptrs 1 nonptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cb2W:
          _sazD::P64 = R1;
          if ((Sp + -16) < SpLim) goto cb2X; else goto cb2Y;
      cb2Y:
          Hp = Hp + 32;
          if (Hp > HpLim) goto cb30; else goto cb2Z;
      cb30:
          HpAlloc = 32;
          goto cb2X;
      cb2X:
          R1 = _sazD::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      cb2Z:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _sazD::P64;
          _sayY::P64 = P64[_sazD::P64 + 16];
          _saz4::P64 = P64[_sazD::P64 + 24];
          _saz1::I64 = I64[_sazD::P64 + 32];
          I64[Hp - 24] = sat_sazC_info;
          P64[Hp - 16] = _sayY::P64;
          P64[Hp - 8] = _saz4::P64;
          I64[Hp] = _saz1::I64;
          R2 = Hp - 23;
          Sp = Sp - 16;
          call GHC.ST.runSTRep_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:45.497078 UTC

{offset
  cb31:
      _sayY::P64 = R3;
      _sayX::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cb32; else goto cb33;
  cb33:
      if (HpLim == 0) goto cb32; else goto cb34;
  cb32:
      R3 = _sayY::P64;
      R2 = _sayX::P64;
      R1 = SkipList.$fMArrayTArrayeSTM8_closure;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  cb34:
      I64[(young<cb1t> + 8)] = cb1t;
      R2 = _sayX::P64;
      I64[(young<cb1t> + 24)] = stg_ap_p_info;
      P64[(young<cb1t> + 16)] = _sayY::P64;
      call GHC.Arr.rangeSize_info(R2) returns to cb1t, args: 24, res: 8, upd: 8;
  cb1t:
      _saz0::P64 = R1;
      _saz1::I64 = I64[_saz0::P64 + 7];
      I64[(young<cb1x> + 8)] = cb1x;
      R3 = GHC.Types.[]_closure+1;
      R2 = _saz1::I64;
      call SkipList.$fMArrayTArrayeSTM9_info(R3,
                                             R2) returns to cb1x, args: 8, res: 8, upd: 8;
  cb1x:
      _saz4::P64 = R1;
      Hp = Hp + 40;
      if (Hp > HpLim) goto cb38; else goto cb37;
  cb38:
      HpAlloc = 40;
      R1 = _saz4::P64;
      call stg_gc_unpt_r1(R1) returns to cb1x, args: 8, res: 8, upd: 8;
  cb37:
      I64[Hp - 32] = sat_sazD_info;
      P64[Hp - 16] = _sayY::P64;
      P64[Hp - 8] = _saz4::P64;
      I64[Hp] = _saz1::I64;
      _cb1z::P64 = Hp - 32;
      R1 = _cb1z::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:45.499086 UTC

{offset
  cb31:
      _sayY::P64 = R3;
      _sayX::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cb32; else goto cb33;
  cb33:
      if (HpLim == 0) goto cb32; else goto cb34;
  cb32:
      R3 = _sayY::P64;
      R2 = _sayX::P64;
      R1 = SkipList.$fMArrayTArrayeSTM8_closure;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  cb34:
      I64[(young<cb1t> + 8)] = cb1t;
      R2 = _sayX::P64;
      I64[(young<cb1t> + 24)] = stg_ap_p_info;
      P64[(young<cb1t> + 16)] = _sayY::P64;
      call GHC.Arr.rangeSize_info(R2) returns to cb1t, args: 24, res: 8, upd: 8;
  cb1t:
      _saz0::P64 = R1;
      _saz1::I64 = I64[_saz0::P64 + 7];
      I64[(young<cb1x> + 8)] = cb1x;
      R3 = GHC.Types.[]_closure+1;
      R2 = _saz1::I64;
      call SkipList.$fMArrayTArrayeSTM9_info(R3,
                                             R2) returns to cb1x, args: 8, res: 8, upd: 8;
  cb1x:
      _saz4::P64 = R1;
      Hp = Hp + 40;
      if (Hp > HpLim) goto cb38; else goto cb37;
  cb38:
      HpAlloc = 40;
      R1 = _saz4::P64;
      call stg_gc_unpt_r1(R1) returns to cb1x, args: 8, res: 8, upd: 8;
  cb37:
      I64[Hp - 32] = sat_sazD_info;
      P64[Hp - 16] = _sayY::P64;
      P64[Hp - 8] = _saz4::P64;
      I64[Hp] = _saz1::I64;
      _cb1z::P64 = Hp - 32;
      R1 = _cb1z::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:45.501117 UTC

{offset
  cb31:
      _sayY::P64 = R3;
      _sayX::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cb32; else goto cb33;
  cb33:
      if (HpLim == 0) goto cb32; else goto cb34;
  cb32:
      R3 = _sayY::P64;
      R2 = _sayX::P64;
      R1 = SkipList.$fMArrayTArrayeSTM8_closure;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  cb34:
      I64[(young<cb1t> + 8)] = cb1t;
      R2 = _sayX::P64;
      I64[(young<cb1t> + 24)] = stg_ap_p_info;
      P64[(young<cb1t> + 16)] = _sayY::P64;
      call GHC.Arr.rangeSize_info(R2) returns to cb1t, args: 24, res: 8, upd: 8;
  cb1t:
      _saz0::P64 = R1;
      _saz1::I64 = I64[_saz0::P64 + 7];
      I64[(young<cb1x> + 8)] = cb1x;
      R3 = GHC.Types.[]_closure+1;
      R2 = _saz1::I64;
      call SkipList.$fMArrayTArrayeSTM9_info(R3,
                                             R2) returns to cb1x, args: 8, res: 8, upd: 8;
  cb1x:
      _saz4::P64 = R1;
      Hp = Hp + 40;
      if (Hp > HpLim) goto cb38; else goto cb37;
  cb38:
      HpAlloc = 40;
      R1 = _saz4::P64;
      call stg_gc_unpt_r1(R1) returns to cb1x, args: 8, res: 8, upd: 8;
  cb37:
      I64[Hp - 32] = sat_sazD_info;
      P64[Hp - 16] = _sayY::P64;
      P64[Hp - 8] = _saz4::P64;
      I64[Hp] = _saz1::I64;
      _cb1z::P64 = Hp - 32;
      R1 = _cb1z::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:45.50343 UTC

{offset
  cb31:
      _sayY::P64 = R3;
      _sayX::P64 = R2;
      if ((Sp + 8) - 40 < SpLim) goto cb32; else goto cb33;
  cb33:
      if (HpLim == 0) goto cb32; else goto cb34;
  cb32:
      R3 = _sayY::P64;
      R2 = _sayX::P64;
      R1 = SkipList.$fMArrayTArrayeSTM8_closure;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  cb34:
      I64[Sp - 16] = cb1t;
      R2 = _sayX::P64;
      I64[Sp - 32] = stg_ap_p_info;
      P64[Sp - 24] = _sayY::P64;
      P64[Sp - 8] = _sayY::P64;
      Sp = Sp - 32;
      call GHC.Arr.rangeSize_info(R2) returns to cb1t, args: 24, res: 8, upd: 8;
  cb1t:
      _sayY::P64 = P64[Sp + 8];
      _saz0::P64 = R1;
      _saz1::I64 = I64[_saz0::P64 + 7];
      I64[Sp - 8] = cb1x;
      R3 = GHC.Types.[]_closure+1;
      R2 = _saz1::I64;
      I64[Sp] = _saz1::I64;
      Sp = Sp - 8;
      call SkipList.$fMArrayTArrayeSTM9_info(R3,
                                             R2) returns to cb1x, args: 8, res: 8, upd: 8;
  cb1x:
      _sayY::P64 = P64[Sp + 16];
      _saz1::I64 = I64[Sp + 8];
      _saz4::P64 = R1;
      Hp = Hp + 40;
      if (Hp > HpLim) goto cb38; else goto cb37;
  cb38:
      HpAlloc = 40;
      R1 = _saz4::P64;
      call stg_gc_unpt_r1(R1) returns to cb1x, args: 8, res: 8, upd: 8;
  cb37:
      I64[Hp - 32] = sat_sazD_info;
      P64[Hp - 16] = _sayY::P64;
      P64[Hp - 8] = _saz4::P64;
      I64[Hp] = _saz1::I64;
      _cb1z::P64 = Hp - 32;
      R1 = _cb1z::P64;
      Sp = Sp + 24;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:45.505829 UTC

{offset
  cb31:
      _sayY::P64 = R3;
      _sayX::P64 = R2;
      if ((Sp + -32) < SpLim) goto cb32; else goto cb33;
  cb33:
      if (HpLim == 0) goto cb32; else goto cb34;
  cb32:
      R3 = _sayY::P64;
      R2 = _sayX::P64;
      R1 = SkipList.$fMArrayTArrayeSTM8_closure;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  cb34:
      I64[Sp - 16] = cb1t;
      R2 = _sayX::P64;
      I64[Sp - 32] = stg_ap_p_info;
      P64[Sp - 24] = _sayY::P64;
      P64[Sp - 8] = _sayY::P64;
      Sp = Sp - 32;
      call GHC.Arr.rangeSize_info(R2) returns to cb1t, args: 24, res: 8, upd: 8;
  cb1t:
      I64[Sp - 8] = cb1x;
      R3 = GHC.Types.[]_closure+1;
      _saz1::I64 = I64[R1 + 7];
      R2 = _saz1::I64;
      I64[Sp] = _saz1::I64;
      Sp = Sp - 8;
      call SkipList.$fMArrayTArrayeSTM9_info(R3,
                                             R2) returns to cb1x, args: 8, res: 8, upd: 8;
  cb1x:
      Hp = Hp + 40;
      if (Hp > HpLim) goto cb38; else goto cb37;
  cb38:
      HpAlloc = 40;
      R1 = R1;
      call stg_gc_unpt_r1(R1) returns to cb1x, args: 8, res: 8, upd: 8;
  cb37:
      I64[Hp - 32] = sat_sazD_info;
      P64[Hp - 16] = P64[Sp + 16];
      P64[Hp - 8] = R1;
      I64[Hp] = I64[Sp + 8];
      R1 = Hp - 32;
      Sp = Sp + 24;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:45.50825 UTC

[(cb1t, {SkipList.$fMArrayTArrayeSTM9_closure, sat_sazD_closure}),
 (cb1x, {sat_sazD_closure}),
 (cb31,
  {SkipList.$fMArrayTArrayeSTM8_closure,
   SkipList.$fMArrayTArrayeSTM9_closure, sat_sazD_closure}),
 (cb32, {SkipList.$fMArrayTArrayeSTM8_closure}),
 (cb33,
  {SkipList.$fMArrayTArrayeSTM8_closure,
   SkipList.$fMArrayTArrayeSTM9_closure, sat_sazD_closure}),
 (cb34, {SkipList.$fMArrayTArrayeSTM9_closure, sat_sazD_closure}),
 (cb37, {sat_sazD_closure}), (cb38, {sat_sazD_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:45.50917 UTC

SkipList.$fMArrayTArrayeSTM8_entry() //  [R3, R2]
        { info_tbl: [(cb1t,
                      label: block_cb1t_info
                      rep:StackRep [False]),
                     (cb1x,
                      label: block_cb1x_info
                      rep:StackRep [True, False]),
                     (cb31,
                      label: SkipList.$fMArrayTArrayeSTM8_info
                      rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cb31:
          _sayY::P64 = R3;
          _sayX::P64 = R2;
          if ((Sp + -32) < SpLim) goto cb32; else goto cb33;
      cb33:
          if (HpLim == 0) goto cb32; else goto cb34;
      cb32:
          R3 = _sayY::P64;
          R2 = _sayX::P64;
          R1 = SkipList.$fMArrayTArrayeSTM8_closure;
          call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
      cb34:
          I64[Sp - 16] = cb1t;
          R2 = _sayX::P64;
          I64[Sp - 32] = stg_ap_p_info;
          P64[Sp - 24] = _sayY::P64;
          P64[Sp - 8] = _sayY::P64;
          Sp = Sp - 32;
          call GHC.Arr.rangeSize_info(R2) returns to cb1t, args: 24, res: 8, upd: 8;
      cb1t:
          I64[Sp - 8] = cb1x;
          R3 = GHC.Types.[]_closure+1;
          _saz1::I64 = I64[R1 + 7];
          R2 = _saz1::I64;
          I64[Sp] = _saz1::I64;
          Sp = Sp - 8;
          call SkipList.$fMArrayTArrayeSTM9_info(R3,
                                                 R2) returns to cb1x, args: 8, res: 8, upd: 8;
      cb1x:
          Hp = Hp + 40;
          if (Hp > HpLim) goto cb38; else goto cb37;
      cb38:
          HpAlloc = 40;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to cb1x, args: 8, res: 8, upd: 8;
      cb37:
          I64[Hp - 32] = sat_sazD_info;
          P64[Hp - 16] = P64[Sp + 16];
          P64[Hp - 8] = R1;
          I64[Hp] = I64[Sp + 8];
          R1 = Hp - 32;
          Sp = Sp + 24;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:45.511841 UTC

SkipList.$fMArrayTArrayeSTM8_entry() //  [R3, R2]
        { info_tbl: [(cb1t,
                      label: block_cb1t_info
                      rep:StackRep [False]),
                     (cb1x,
                      label: block_cb1x_info
                      rep:StackRep [True, False]),
                     (cb31,
                      label: SkipList.$fMArrayTArrayeSTM8_info
                      rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cb31:
          _sayY::P64 = R3;
          _sayX::P64 = R2;
          if ((Sp + -32) < SpLim) goto cb32; else goto cb33;
      cb33:
          if (HpLim == 0) goto cb32; else goto cb34;
      cb32:
          R3 = _sayY::P64;
          R2 = _sayX::P64;
          R1 = SkipList.$fMArrayTArrayeSTM8_closure;
          call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
      cb34:
          I64[Sp - 16] = cb1t;
          R2 = _sayX::P64;
          I64[Sp - 32] = stg_ap_p_info;
          P64[Sp - 24] = _sayY::P64;
          P64[Sp - 8] = _sayY::P64;
          Sp = Sp - 32;
          call GHC.Arr.rangeSize_info(R2) returns to cb1t, args: 24, res: 8, upd: 8;
      cb1t:
          I64[Sp - 8] = cb1x;
          R3 = GHC.Types.[]_closure+1;
          _saz1::I64 = I64[R1 + 7];
          R2 = _saz1::I64;
          I64[Sp] = _saz1::I64;
          Sp = Sp - 8;
          call SkipList.$fMArrayTArrayeSTM9_info(R3,
                                                 R2) returns to cb1x, args: 8, res: 8, upd: 8;
      cb1x:
          Hp = Hp + 40;
          if (Hp > HpLim) goto cb38; else goto cb37;
      cb38:
          HpAlloc = 40;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to cb1x, args: 8, res: 8, upd: 8;
      cb37:
          I64[Hp - 32] = sat_sazD_info;
          P64[Hp - 16] = P64[Sp + 16];
          P64[Hp - 8] = R1;
          I64[Hp] = I64[Sp + 8];
          R1 = Hp - 32;
          Sp = Sp + 24;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:45.514514 UTC

[section "data" {
     SkipList.$fMArrayTArrayeSTM8_closure:
         const SkipList.$fMArrayTArrayeSTM8_info;
         const 0;
 },
 $wa8_sazi_entry() //  [R3, R2, R1]
         { info_tbl: [(cb2a,
                       label: $wa8_sazi_info
                       rep:HeapRep 1 ptrs 1 nonptrs {
                             Fun {arity: 3 fun_type: ArgSpec 13} }),
                      (cb2g,
                       label: block_cb2g_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cb2a:
           _sazk::P64 = R3;
           _sazj::I64 = R2;
           _sazi::P64 = R1;
           if ((Sp + -32) < SpLim) goto cb2b; else goto cb2c;
       cb2c:
           if (HpLim == 0) goto cb2b; else goto cb2v;
       cb2b:
           R3 = _sazk::P64;
           R2 = _sazj::I64;
           R1 = _sazi::P64;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb2v:
           if (_sazj::I64 == I64[_sazi::P64 + 13]) goto cb2u; else goto cb2i;
       cb2i:
           I64[Sp - 32] = cb2g;
           R1 = _sazk::P64;
           P64[Sp - 24] = P64[_sazi::P64 + 5];
           P64[Sp - 16] = _sazi::P64;
           I64[Sp - 8] = _sazj::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto cb2g; else goto cb2j;
       cb2j:
           call (I64[R1])(R1) returns to cb2g, args: 8, res: 8, upd: 8;
       cb2g:
           if (R1 & 7 != 1) goto cb2t; else goto ub39;
       cb2t:
           _sazd::P64 = P64[Sp + 8];
           _sazi::P64 = P64[Sp + 16];
           _sazj::I64 = I64[Sp + 24];
           _sazq::P64 = P64[R1 + 14];
           P64[(_sazd::P64 + 24) + (_sazj::I64 << 3)] = P64[R1 + 6];
           I64[_sazd::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
           I8[(_sazd::P64 + 24) + ((I64[_sazd::P64 + 8] << 3) + (_sazj::I64 >> 7))] = 1 :: W8;
           R3 = _sazq::P64;
           R2 = _sazj::I64 + 1;
           R1 = _sazi::P64;
           Sp = Sp + 32;
           call $wa8_sazi_info(R3, R2, R1) args: 8, res: 0, upd: 8;
       ub39:
           Sp = Sp + 32;
           goto cb2u;
       cb2u:
           R1 = GHC.Tuple.()_closure+1;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sazC_entry() //  [R1]
         { info_tbl: [(cb1I,
                       label: block_cb1I_info
                       rep:StackRep [True, False]),
                      (cb1S,
                       label: block_cb1S_info
                       rep:StackRep [False, False, True, False]),
                      (cb1U,
                       label: block_cb1U_info
                       rep:StackRep [False, False, True, False]),
                      (cb1W,
                       label: block_cb1W_info
                       rep:StackRep [False, False, True, False]),
                      (cb2A,
                       label: sat_sazC_info
                       rep:HeapRep 2 ptrs 1 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} }),
                      (cb2M,
                       label: block_cb2M_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cb2A:
           _sazC::P64 = R1;
           if ((Sp + -40) < SpLim) goto cb2B; else goto cb2C;
       cb2C:
           if (HpLim == 0) goto cb2B; else goto cb2D;
       cb2B:
           R1 = _sazC::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cb2D:
           I64[Sp - 24] = cb1I;
           R1 = P64[_sazC::P64 + 7];
           I64[Sp - 16] = I64[_sazC::P64 + 23];
           P64[Sp - 8] = P64[_sazC::P64 + 15];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto cb1I; else goto cb1J;
       cb1J:
           call (I64[R1])(R1) returns to cb1I, args: 8, res: 8, upd: 8;
       cb1I:
           _saz1::I64 = I64[Sp + 8];
           if (%MO_S_Lt_W64(_saz1::I64, 0)) goto cb2V; else goto cb2G;
       cb2V:
           R1 = GHC.Arr.negRange_closure;
           Sp = Sp + 24;
           call (I64[R1])(R1) args: 8, res: 0, upd: 8;
       cb2G:
           I64[Sp - 16] = cb1S;
           R2 = Data.Array.Base.arrEleBottom_closure;
           _saz7::P64 = P64[R1 + 7];
           _saz8::P64 = P64[R1 + 15];
           R1 = _saz1::I64;
           P64[Sp - 8] = _saz8::P64;
           P64[Sp] = _saz7::P64;
           Sp = Sp - 16;
           call stg_newArray#(R2,
                              R1) returns to cb1S, args: 8, res: 8, upd: 8;
       cb1S:
           I64[Sp] = cb1U;
           _sazd::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _sazd::P64;
           call stg_ap_0_fast(R1) returns to cb1U, args: 8, res: 8, upd: 8;
       cb1U:
           I64[Sp] = cb1W;
           _saze::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _saze::P64;
           call stg_ap_0_fast(R1) returns to cb1W, args: 8, res: 8, upd: 8;
       cb1W:
           Hp = Hp + 24;
           if (Hp > HpLim) goto cb2L; else goto cb2K;
       cb2L:
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to cb1W, args: 8, res: 8, upd: 8;
       cb2K:
           _saz1::I64 = I64[Sp + 24];
           if (%MO_S_Lt_W64(_saz1::I64, 0)) goto cb2U; else goto cb2Q;
       cb2U:
           Hp = Hp - 24;
           R1 = SkipList.$fMArrayTArrayeSTM5_closure;
           Sp = Sp + 40;
           call (I64[R1])(R1) args: 8, res: 0, upd: 8;
       cb2Q:
           I64[Hp - 16] = $wa8_sazi_info;
           P64[Hp - 8] = P64[Sp + 16];
           I64[Hp] = _saz1::I64;
           I64[Sp] = cb2M;
           R3 = P64[Sp + 32];
           R2 = 0;
           _sazf::P64 = R1;
           R1 = Hp - 13;
           P64[Sp + 32] = _sazf::P64;
           call $wa8_sazi_info(R3,
                               R2,
                               R1) returns to cb2M, args: 8, res: 8, upd: 8;
       cb2M:
           Hp = Hp + 40;
           if (Hp > HpLim) goto cb2T; else goto cb2S;
       cb2T:
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to cb2M, args: 8, res: 8, upd: 8;
       cb2S:
           _sazd::P64 = P64[Sp + 16];
           I64[_sazd::P64] = stg_MUT_ARR_PTRS_FROZEN0_info;
           I64[Hp - 32] = GHC.Arr.Array_con_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = _sazd::P64;
           I64[Hp] = I64[Sp + 24];
           R1 = Hp - 31;
           Sp = Sp + 40;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sazD_entry() //  [R1]
         { info_tbl: [(cb2W,
                       label: sat_sazD_info
                       rep:HeapRep 2 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cb2W:
           _sazD::P64 = R1;
           if ((Sp + -16) < SpLim) goto cb2X; else goto cb2Y;
       cb2Y:
           Hp = Hp + 32;
           if (Hp > HpLim) goto cb30; else goto cb2Z;
       cb30:
           HpAlloc = 32;
           goto cb2X;
       cb2X:
           R1 = _sazD::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb2Z:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sazD::P64;
           _sayY::P64 = P64[_sazD::P64 + 16];
           _saz4::P64 = P64[_sazD::P64 + 24];
           _saz1::I64 = I64[_sazD::P64 + 32];
           I64[Hp - 24] = sat_sazC_info;
           P64[Hp - 16] = _sayY::P64;
           P64[Hp - 8] = _saz4::P64;
           I64[Hp] = _saz1::I64;
           R2 = Hp - 23;
           Sp = Sp - 16;
           call GHC.ST.runSTRep_info(R2) args: 24, res: 0, upd: 24;
     }
 },
 SkipList.$fMArrayTArrayeSTM8_entry() //  [R3, R2]
         { info_tbl: [(cb1t,
                       label: block_cb1t_info
                       rep:StackRep [False]),
                      (cb1x,
                       label: block_cb1x_info
                       rep:StackRep [True, False]),
                      (cb31,
                       label: SkipList.$fMArrayTArrayeSTM8_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cb31:
           _sayY::P64 = R3;
           _sayX::P64 = R2;
           if ((Sp + -32) < SpLim) goto cb32; else goto cb33;
       cb33:
           if (HpLim == 0) goto cb32; else goto cb34;
       cb32:
           R3 = _sayY::P64;
           R2 = _sayX::P64;
           R1 = SkipList.$fMArrayTArrayeSTM8_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb34:
           I64[Sp - 16] = cb1t;
           R2 = _sayX::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = _sayY::P64;
           P64[Sp - 8] = _sayY::P64;
           Sp = Sp - 32;
           call GHC.Arr.rangeSize_info(R2) returns to cb1t, args: 24, res: 8, upd: 8;
       cb1t:
           I64[Sp - 8] = cb1x;
           R3 = GHC.Types.[]_closure+1;
           _saz1::I64 = I64[R1 + 7];
           R2 = _saz1::I64;
           I64[Sp] = _saz1::I64;
           Sp = Sp - 8;
           call SkipList.$fMArrayTArrayeSTM9_info(R3,
                                                  R2) returns to cb1x, args: 8, res: 8, upd: 8;
       cb1x:
           Hp = Hp + 40;
           if (Hp > HpLim) goto cb38; else goto cb37;
       cb38:
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to cb1x, args: 8, res: 8, upd: 8;
       cb37:
           I64[Hp - 32] = sat_sazD_info;
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 32;
           Sp = Sp + 24;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:45.527713 UTC

[section "data" {
     SkipList.$fMArrayTArrayeSTM8_closure:
         const SkipList.$fMArrayTArrayeSTM8_info;
         const 0;
 },
 $wa8_sazi_entry() //  [R3, R2, R1]
         { info_tbl: [(cb2a,
                       label: $wa8_sazi_info
                       rep:HeapRep 1 ptrs 1 nonptrs {
                             Fun {arity: 3 fun_type: ArgSpec 13} }),
                      (cb2g,
                       label: block_cb2g_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cb2a:
           _sazk::P64 = R3;
           _sazj::I64 = R2;
           _sazi::P64 = R1;
           if ((Sp + -32) < SpLim) goto cb2b; else goto cb2c;
       cb2c:
           if (HpLim == 0) goto cb2b; else goto cb2v;
       cb2b:
           R3 = _sazk::P64;
           R2 = _sazj::I64;
           R1 = _sazi::P64;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb2v:
           if (_sazj::I64 == I64[_sazi::P64 + 13]) goto cb2u; else goto cb2i;
       cb2i:
           I64[Sp - 32] = cb2g;
           R1 = _sazk::P64;
           P64[Sp - 24] = P64[_sazi::P64 + 5];
           P64[Sp - 16] = _sazi::P64;
           I64[Sp - 8] = _sazj::I64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto cb2g; else goto cb2j;
       cb2j:
           call (I64[R1])(R1) returns to cb2g, args: 8, res: 8, upd: 8;
       cb2g:
           if (R1 & 7 != 1) goto cb2t; else goto ub39;
       cb2t:
           _sazd::P64 = P64[Sp + 8];
           _sazi::P64 = P64[Sp + 16];
           _sazj::I64 = I64[Sp + 24];
           _sazq::P64 = P64[R1 + 14];
           P64[(_sazd::P64 + 24) + (_sazj::I64 << 3)] = P64[R1 + 6];
           I64[_sazd::P64] = stg_MUT_ARR_PTRS_DIRTY_info;
           I8[(_sazd::P64 + 24) + ((I64[_sazd::P64 + 8] << 3) + (_sazj::I64 >> 7))] = 1 :: W8;
           R3 = _sazq::P64;
           R2 = _sazj::I64 + 1;
           R1 = _sazi::P64;
           Sp = Sp + 32;
           call $wa8_sazi_info(R3, R2, R1) args: 8, res: 0, upd: 8;
       ub39:
           Sp = Sp + 32;
           goto cb2u;
       cb2u:
           R1 = GHC.Tuple.()_closure+1;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sazC_entry() //  [R1]
         { info_tbl: [(cb1I,
                       label: block_cb1I_info
                       rep:StackRep [True, False]),
                      (cb1S,
                       label: block_cb1S_info
                       rep:StackRep [False, False, True, False]),
                      (cb1U,
                       label: block_cb1U_info
                       rep:StackRep [False, False, True, False]),
                      (cb1W,
                       label: block_cb1W_info
                       rep:StackRep [False, False, True, False]),
                      (cb2A,
                       label: sat_sazC_info
                       rep:HeapRep 2 ptrs 1 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} }),
                      (cb2M,
                       label: block_cb2M_info
                       rep:StackRep [False, False, True, False])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cb2A:
           _sazC::P64 = R1;
           if ((Sp + -40) < SpLim) goto cb2B; else goto cb2C;
       cb2C:
           if (HpLim == 0) goto cb2B; else goto cb2D;
       cb2B:
           R1 = _sazC::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cb2D:
           I64[Sp - 24] = cb1I;
           R1 = P64[_sazC::P64 + 7];
           I64[Sp - 16] = I64[_sazC::P64 + 23];
           P64[Sp - 8] = P64[_sazC::P64 + 15];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto cb1I; else goto cb1J;
       cb1J:
           call (I64[R1])(R1) returns to cb1I, args: 8, res: 8, upd: 8;
       cb1I:
           _saz1::I64 = I64[Sp + 8];
           if (%MO_S_Lt_W64(_saz1::I64, 0)) goto cb2V; else goto cb2G;
       cb2V:
           R1 = GHC.Arr.negRange_closure;
           Sp = Sp + 24;
           call (I64[R1])(R1) args: 8, res: 0, upd: 8;
       cb2G:
           I64[Sp - 16] = cb1S;
           R2 = Data.Array.Base.arrEleBottom_closure;
           _saz7::P64 = P64[R1 + 7];
           _saz8::P64 = P64[R1 + 15];
           R1 = _saz1::I64;
           P64[Sp - 8] = _saz8::P64;
           P64[Sp] = _saz7::P64;
           Sp = Sp - 16;
           call stg_newArray#(R2,
                              R1) returns to cb1S, args: 8, res: 8, upd: 8;
       cb1S:
           I64[Sp] = cb1U;
           _sazd::P64 = R1;
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _sazd::P64;
           call stg_ap_0_fast(R1) returns to cb1U, args: 8, res: 8, upd: 8;
       cb1U:
           I64[Sp] = cb1W;
           _saze::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _saze::P64;
           call stg_ap_0_fast(R1) returns to cb1W, args: 8, res: 8, upd: 8;
       cb1W:
           Hp = Hp + 24;
           if (Hp > HpLim) goto cb2L; else goto cb2K;
       cb2L:
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to cb1W, args: 8, res: 8, upd: 8;
       cb2K:
           _saz1::I64 = I64[Sp + 24];
           if (%MO_S_Lt_W64(_saz1::I64, 0)) goto cb2U; else goto cb2Q;
       cb2U:
           Hp = Hp - 24;
           R1 = SkipList.$fMArrayTArrayeSTM5_closure;
           Sp = Sp + 40;
           call (I64[R1])(R1) args: 8, res: 0, upd: 8;
       cb2Q:
           I64[Hp - 16] = $wa8_sazi_info;
           P64[Hp - 8] = P64[Sp + 16];
           I64[Hp] = _saz1::I64;
           I64[Sp] = cb2M;
           R3 = P64[Sp + 32];
           R2 = 0;
           _sazf::P64 = R1;
           R1 = Hp - 13;
           P64[Sp + 32] = _sazf::P64;
           call $wa8_sazi_info(R3,
                               R2,
                               R1) returns to cb2M, args: 8, res: 8, upd: 8;
       cb2M:
           Hp = Hp + 40;
           if (Hp > HpLim) goto cb2T; else goto cb2S;
       cb2T:
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to cb2M, args: 8, res: 8, upd: 8;
       cb2S:
           _sazd::P64 = P64[Sp + 16];
           I64[_sazd::P64] = stg_MUT_ARR_PTRS_FROZEN0_info;
           I64[Hp - 32] = GHC.Arr.Array_con_info;
           P64[Hp - 24] = P64[Sp + 8];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = _sazd::P64;
           I64[Hp] = I64[Sp + 24];
           R1 = Hp - 31;
           Sp = Sp + 40;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sazD_entry() //  [R1]
         { info_tbl: [(cb2W,
                       label: sat_sazD_info
                       rep:HeapRep 2 ptrs 1 nonptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cb2W:
           _sazD::P64 = R1;
           if ((Sp + -16) < SpLim) goto cb2X; else goto cb2Y;
       cb2Y:
           Hp = Hp + 32;
           if (Hp > HpLim) goto cb30; else goto cb2Z;
       cb30:
           HpAlloc = 32;
           goto cb2X;
       cb2X:
           R1 = _sazD::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb2Z:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sazD::P64;
           _sayY::P64 = P64[_sazD::P64 + 16];
           _saz4::P64 = P64[_sazD::P64 + 24];
           _saz1::I64 = I64[_sazD::P64 + 32];
           I64[Hp - 24] = sat_sazC_info;
           P64[Hp - 16] = _sayY::P64;
           P64[Hp - 8] = _saz4::P64;
           I64[Hp] = _saz1::I64;
           R2 = Hp - 23;
           Sp = Sp - 16;
           call GHC.ST.runSTRep_info(R2) args: 24, res: 0, upd: 24;
     }
 },
 SkipList.$fMArrayTArrayeSTM8_entry() //  [R3, R2]
         { info_tbl: [(cb1t,
                       label: block_cb1t_info
                       rep:StackRep [False]),
                      (cb1x,
                       label: block_cb1x_info
                       rep:StackRep [True, False]),
                      (cb31,
                       label: SkipList.$fMArrayTArrayeSTM8_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cb31:
           _sayY::P64 = R3;
           _sayX::P64 = R2;
           if ((Sp + -32) < SpLim) goto cb32; else goto cb33;
       cb33:
           if (HpLim == 0) goto cb32; else goto cb34;
       cb32:
           R3 = _sayY::P64;
           R2 = _sayX::P64;
           R1 = SkipList.$fMArrayTArrayeSTM8_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb34:
           I64[Sp - 16] = cb1t;
           R2 = _sayX::P64;
           I64[Sp - 32] = stg_ap_p_info;
           P64[Sp - 24] = _sayY::P64;
           P64[Sp - 8] = _sayY::P64;
           Sp = Sp - 32;
           call GHC.Arr.rangeSize_info(R2) returns to cb1t, args: 24, res: 8, upd: 8;
       cb1t:
           I64[Sp - 8] = cb1x;
           R3 = GHC.Types.[]_closure+1;
           _saz1::I64 = I64[R1 + 7];
           R2 = _saz1::I64;
           I64[Sp] = _saz1::I64;
           Sp = Sp - 8;
           call SkipList.$fMArrayTArrayeSTM9_info(R3,
                                                  R2) returns to cb1x, args: 8, res: 8, upd: 8;
       cb1x:
           Hp = Hp + 40;
           if (Hp > HpLim) goto cb38; else goto cb37;
       cb38:
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to cb1x, args: 8, res: 8, upd: 8;
       cb37:
           I64[Hp - 32] = sat_sazD_info;
           P64[Hp - 16] = P64[Sp + 16];
           P64[Hp - 8] = R1;
           I64[Hp] = I64[Sp + 8];
           R1 = Hp - 32;
           Sp = Sp + 24;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:45.559508 UTC

[section "data" {
     SkipList.$fMArrayTArrayeSTM_$cnewArray__closure:
         const SkipList.$fMArrayTArrayeSTM_$cnewArray__info;
         const 0;
 },
 SkipList.$fMArrayTArrayeSTM_$cnewArray__entry() //  [R3, R2]
         { info_tbl: [(cb3I,
                       label: SkipList.$fMArrayTArrayeSTM_$cnewArray__info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cb3I:
           _B2::P64 = R3;
           _B3::P64 = R2;
           goto cb3G;
       cb3G:
           if ((old + 0) - <highSp> < SpLim) goto cb3J; else goto cb3K;
       cb3K:
           goto cb3F;
       cb3F:
           if (HpLim == 0) goto cb3J; else goto cb3L;
       cb3J:
           R3 = _B2::P64;
           R2 = _B3::P64;
           R1 = SkipList.$fMArrayTArrayeSTM_$cnewArray__closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb3L:
           R3 = _B2::P64;
           R2 = _B3::P64;
           call SkipList.$fMArrayTArrayeSTM8_info(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:45.561382 UTC

{offset
  cb3I:
      _B2::P64 = R3;
      _B3::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cb3J; else goto cb3K;
  cb3K:
      if (HpLim == 0) goto cb3J; else goto cb3L;
  cb3J:
      R3 = _B2::P64;
      R2 = _B3::P64;
      R1 = SkipList.$fMArrayTArrayeSTM_$cnewArray__closure;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  cb3L:
      R3 = _B2::P64;
      R2 = _B3::P64;
      call SkipList.$fMArrayTArrayeSTM8_info(R3,
                                             R2) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:45.562251 UTC

{offset
  cb3I:
      _B2::P64 = R3;
      _B3::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cb3J; else goto cb3K;
  cb3K:
      if (HpLim == 0) goto cb3J; else goto cb3L;
  cb3J:
      R3 = _B2::P64;
      R2 = _B3::P64;
      R1 = SkipList.$fMArrayTArrayeSTM_$cnewArray__closure;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  cb3L:
      R3 = _B2::P64;
      R2 = _B3::P64;
      call SkipList.$fMArrayTArrayeSTM8_info(R3,
                                             R2) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:45.56315 UTC

{offset
  cb3I:
      _B2::P64 = R3;
      _B3::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cb3J; else goto cb3K;
  cb3K:
      if (HpLim == 0) goto cb3J; else goto cb3L;
  cb3J:
      R3 = _B2::P64;
      R2 = _B3::P64;
      R1 = SkipList.$fMArrayTArrayeSTM_$cnewArray__closure;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  cb3L:
      R3 = _B2::P64;
      R2 = _B3::P64;
      call SkipList.$fMArrayTArrayeSTM8_info(R3,
                                             R2) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:45.564065 UTC

{offset
  cb3I:
      _B2::P64 = R3;
      _B3::P64 = R2;
      goto cb3K;
  cb3K:
      if (HpLim == 0) goto cb3J; else goto cb3L;
  cb3J:
      R3 = _B2::P64;
      R2 = _B3::P64;
      R1 = SkipList.$fMArrayTArrayeSTM_$cnewArray__closure;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  cb3L:
      R3 = _B2::P64;
      R2 = _B3::P64;
      call SkipList.$fMArrayTArrayeSTM8_info(R3,
                                             R2) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:45.564856 UTC

{offset
  cb3I:
      goto cb3K;
  cb3K:
      if (HpLim == 0) goto cb3J; else goto cb3L;
  cb3J:
      R3 = R3;
      R2 = R2;
      R1 = SkipList.$fMArrayTArrayeSTM_$cnewArray__closure;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  cb3L:
      R3 = R3;
      R2 = R2;
      call SkipList.$fMArrayTArrayeSTM8_info(R3,
                                             R2) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:45.565758 UTC

[(cb3I,
  {SkipList.$fMArrayTArrayeSTM_$cnewArray__closure,
   SkipList.$fMArrayTArrayeSTM8_closure}),
 (cb3J, {SkipList.$fMArrayTArrayeSTM_$cnewArray__closure}),
 (cb3K,
  {SkipList.$fMArrayTArrayeSTM_$cnewArray__closure,
   SkipList.$fMArrayTArrayeSTM8_closure}),
 (cb3L, {SkipList.$fMArrayTArrayeSTM8_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:45.566294 UTC

SkipList.$fMArrayTArrayeSTM_$cnewArray__entry() //  [R3, R2]
        { info_tbl: [(cb3I,
                      label: SkipList.$fMArrayTArrayeSTM_$cnewArray__info
                      rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cb3I:
          goto cb3K;
      cb3K:
          if (HpLim == 0) goto cb3J; else goto cb3L;
      cb3J:
          R3 = R3;
          R2 = R2;
          R1 = SkipList.$fMArrayTArrayeSTM_$cnewArray__closure;
          call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
      cb3L:
          R3 = R3;
          R2 = R2;
          call SkipList.$fMArrayTArrayeSTM8_info(R3,
                                                 R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:45.567267 UTC

SkipList.$fMArrayTArrayeSTM_$cnewArray__entry() //  [R3, R2]
        { info_tbl: [(cb3I,
                      label: SkipList.$fMArrayTArrayeSTM_$cnewArray__info
                      rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cb3I:
          if (HpLim == 0) goto cb3J; else goto cb3L;
      cb3J:
          R3 = R3;
          R2 = R2;
          R1 = SkipList.$fMArrayTArrayeSTM_$cnewArray__closure;
          call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
      cb3L:
          R3 = R3;
          R2 = R2;
          call SkipList.$fMArrayTArrayeSTM8_info(R3,
                                                 R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:45.568202 UTC

[section "data" {
     SkipList.$fMArrayTArrayeSTM_$cnewArray__closure:
         const SkipList.$fMArrayTArrayeSTM_$cnewArray__info;
         const 0;
 },
 SkipList.$fMArrayTArrayeSTM_$cnewArray__entry() //  [R3, R2]
         { info_tbl: [(cb3I,
                       label: SkipList.$fMArrayTArrayeSTM_$cnewArray__info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cb3I:
           if (HpLim == 0) goto cb3J; else goto cb3L;
       cb3J:
           R3 = R3;
           R2 = R2;
           R1 = SkipList.$fMArrayTArrayeSTM_$cnewArray__closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb3L:
           R3 = R3;
           R2 = R2;
           call SkipList.$fMArrayTArrayeSTM8_info(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:45.56937 UTC

[section "data" {
     SkipList.$fMArrayTArrayeSTM_$cnewArray__closure:
         const SkipList.$fMArrayTArrayeSTM_$cnewArray__info;
         const 0;
 },
 SkipList.$fMArrayTArrayeSTM_$cnewArray__entry() //  [R3, R2]
         { info_tbl: [(cb3I,
                       label: SkipList.$fMArrayTArrayeSTM_$cnewArray__info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cb3I:
           if (HpLim == 0) goto cb3J; else goto cb3L;
       cb3J:
           R3 = R3;
           R2 = R2;
           R1 = SkipList.$fMArrayTArrayeSTM_$cnewArray__closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb3L:
           R3 = R3;
           R2 = R2;
           call SkipList.$fMArrayTArrayeSTM8_info(R3,
                                                  R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:45.572432 UTC

[section "data" {
     SkipList.$fMArrayTArrayeSTM_$cunsafeNewArray__closure:
         const SkipList.$fMArrayTArrayeSTM_$cunsafeNewArray__info;
         const 0;
 },
 SkipList.$fMArrayTArrayeSTM_$cunsafeNewArray__entry() //  [R3, R2]
         { info_tbl: [(cb43,
                       label: SkipList.$fMArrayTArrayeSTM_$cunsafeNewArray__info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cb43:
           _sazF::P64 = R3;
           _sazE::P64 = R2;
           goto cb3Y;
       cb3Y:
           if ((old + 0) - <highSp> < SpLim) goto cb44; else goto cb45;
       cb45:
           goto cb3X;
       cb3X:
           if (HpLim == 0) goto cb44; else goto cb46;
       cb44:
           R3 = _sazF::P64;
           R2 = _sazE::P64;
           R1 = SkipList.$fMArrayTArrayeSTM_$cunsafeNewArray__closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb46:
           I64[(young<cb40> + 8)] = cb40;
           R1 = _sazF::P64;
           if (R1 & 7 != 0) goto cb40; else goto cb41;
       cb41:
           call (I64[R1])(R1) returns to cb40, args: 8, res: 8, upd: 8;
       cb40:
           _sazG::P64 = R1;
           _sazH::P64 = P64[_sazG::P64 + 7];
           _sazI::P64 = P64[_sazG::P64 + 15];
           R2 = SkipList.$fMArrayTArrayeSTM_closure+1;
           I64[(old + 40)] = stg_ap_ppp_info;
           P64[(old + 32)] = _sazE::P64;
           P64[(old + 24)] = _sazG::P64;
           P64[(old + 16)] = Data.Array.Base.arrEleBottom_closure;
           call Data.Array.Base.newArray_info(R2) args: 40, res: 0, upd: 8;
     }
 },
 section "data" {
     SkipList.$fMArrayTArrayeSTM_closure:
         const Data.Array.Base.D:MArray_static_info;
         const Control.NoRec.STM.$fMonadSTM_closure;
         const SkipList.$fMArrayTArrayeSTM11_closure+3;
         const SkipList.$fMArrayTArrayeSTM10_closure+3;
         const SkipList.$fMArrayTArrayeSTM4_closure+4;
         const SkipList.$fMArrayTArrayeSTM8_closure+3;
         const SkipList.$fMArrayTArrayeSTM_$cunsafeNewArray__closure+2;
         const SkipList.$fMArrayTArrayeSTM2_closure+4;
         const SkipList.$fMArrayTArrayeSTM1_closure+5;
         const 0;
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:45.575635 UTC

{offset
  cb43:
      _sazF::P64 = R3;
      _sazE::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cb44; else goto cb45;
  cb45:
      if (HpLim == 0) goto cb44; else goto cb46;
  cb44:
      R3 = _sazF::P64;
      R2 = _sazE::P64;
      R1 = SkipList.$fMArrayTArrayeSTM_$cunsafeNewArray__closure;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  cb46:
      I64[(young<cb40> + 8)] = cb40;
      R1 = _sazF::P64;
      if (R1 & 7 != 0) goto cb40; else goto cb41;
  cb41:
      call (I64[R1])(R1) returns to cb40, args: 8, res: 8, upd: 8;
  cb40:
      _sazG::P64 = R1;
      _sazH::P64 = P64[_sazG::P64 + 7];
      _sazI::P64 = P64[_sazG::P64 + 15];
      R2 = SkipList.$fMArrayTArrayeSTM_closure+1;
      I64[(old + 40)] = stg_ap_ppp_info;
      P64[(old + 32)] = _sazE::P64;
      P64[(old + 24)] = _sazG::P64;
      P64[(old + 16)] = Data.Array.Base.arrEleBottom_closure;
      call Data.Array.Base.newArray_info(R2) args: 40, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:45.577109 UTC

{offset
  cb43:
      _sazF::P64 = R3;
      _sazE::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cb44; else goto cb45;
  cb45:
      if (HpLim == 0) goto cb44; else goto cb46;
  cb44:
      R3 = _sazF::P64;
      R2 = _sazE::P64;
      R1 = SkipList.$fMArrayTArrayeSTM_$cunsafeNewArray__closure;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  cb46:
      I64[(young<cb40> + 8)] = cb40;
      R1 = _sazF::P64;
      if (R1 & 7 != 0) goto cb40; else goto cb41;
  cb41:
      call (I64[R1])(R1) returns to cb40, args: 8, res: 8, upd: 8;
  cb40:
      _sazG::P64 = R1;
      _sazH::P64 = P64[_sazG::P64 + 7];
      _sazI::P64 = P64[_sazG::P64 + 15];
      R2 = SkipList.$fMArrayTArrayeSTM_closure+1;
      I64[(old + 40)] = stg_ap_ppp_info;
      P64[(old + 32)] = _sazE::P64;
      P64[(old + 24)] = _sazG::P64;
      P64[(old + 16)] = Data.Array.Base.arrEleBottom_closure;
      call Data.Array.Base.newArray_info(R2) args: 40, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:45.578593 UTC

{offset
  cb43:
      _sazF::P64 = R3;
      _sazE::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cb44; else goto cb45;
  cb45:
      if (HpLim == 0) goto cb44; else goto cb46;
  cb44:
      R3 = _sazF::P64;
      R2 = _sazE::P64;
      R1 = SkipList.$fMArrayTArrayeSTM_$cunsafeNewArray__closure;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  cb46:
      I64[(young<cb40> + 8)] = cb40;
      R1 = _sazF::P64;
      if (R1 & 7 != 0) goto cb40; else goto cb41;
  cb41:
      call (I64[R1])(R1) returns to cb40, args: 8, res: 8, upd: 8;
  cb40:
      _sazG::P64 = R1;
      _sazH::P64 = P64[_sazG::P64 + 7];
      _sazI::P64 = P64[_sazG::P64 + 15];
      R2 = SkipList.$fMArrayTArrayeSTM_closure+1;
      I64[(old + 40)] = stg_ap_ppp_info;
      P64[(old + 32)] = _sazE::P64;
      P64[(old + 24)] = _sazG::P64;
      P64[(old + 16)] = Data.Array.Base.arrEleBottom_closure;
      call Data.Array.Base.newArray_info(R2) args: 40, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:45.580229 UTC

{offset
  cb43:
      _sazF::P64 = R3;
      _sazE::P64 = R2;
      if ((Sp + 8) - 40 < SpLim) goto cb44; else goto cb45;
  cb45:
      if (HpLim == 0) goto cb44; else goto cb46;
  cb44:
      R3 = _sazF::P64;
      R2 = _sazE::P64;
      R1 = SkipList.$fMArrayTArrayeSTM_$cunsafeNewArray__closure;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  cb46:
      I64[Sp - 16] = cb40;
      R1 = _sazF::P64;
      P64[Sp - 8] = _sazE::P64;
      Sp = Sp - 16;
      if (R1 & 7 != 0) goto cb40; else goto cb41;
  cb41:
      call (I64[R1])(R1) returns to cb40, args: 8, res: 8, upd: 8;
  cb40:
      _sazE::P64 = P64[Sp + 8];
      _sazG::P64 = R1;
      _sazH::P64 = P64[_sazG::P64 + 7];
      _sazI::P64 = P64[_sazG::P64 + 15];
      R2 = SkipList.$fMArrayTArrayeSTM_closure+1;
      I64[Sp - 16] = stg_ap_ppp_info;
      P64[Sp - 8] = _sazE::P64;
      P64[Sp] = _sazG::P64;
      P64[Sp + 8] = Data.Array.Base.arrEleBottom_closure;
      Sp = Sp - 16;
      call Data.Array.Base.newArray_info(R2) args: 40, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:45.581893 UTC

{offset
  cb43:
      _sazF::P64 = R3;
      _sazE::P64 = R2;
      if ((Sp + -32) < SpLim) goto cb44; else goto cb45;
  cb45:
      if (HpLim == 0) goto cb44; else goto cb46;
  cb44:
      R3 = _sazF::P64;
      R2 = _sazE::P64;
      R1 = SkipList.$fMArrayTArrayeSTM_$cunsafeNewArray__closure;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  cb46:
      I64[Sp - 16] = cb40;
      R1 = _sazF::P64;
      P64[Sp - 8] = _sazE::P64;
      Sp = Sp - 16;
      if (R1 & 7 != 0) goto cb40; else goto cb41;
  cb41:
      call (I64[R1])(R1) returns to cb40, args: 8, res: 8, upd: 8;
  cb40:
      R2 = SkipList.$fMArrayTArrayeSTM_closure+1;
      I64[Sp - 16] = stg_ap_ppp_info;
      P64[Sp - 8] = P64[Sp + 8];
      P64[Sp] = R1;
      P64[Sp + 8] = Data.Array.Base.arrEleBottom_closure;
      Sp = Sp - 16;
      call Data.Array.Base.newArray_info(R2) args: 40, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:45.583529 UTC

[(cb40,
  {Data.Array.Base.arrEleBottom_closure,
   SkipList.$fMArrayTArrayeSTM_closure}),
 (cb41,
  {Data.Array.Base.arrEleBottom_closure,
   SkipList.$fMArrayTArrayeSTM_closure}),
 (cb43,
  {Data.Array.Base.arrEleBottom_closure,
   SkipList.$fMArrayTArrayeSTM_closure,
   SkipList.$fMArrayTArrayeSTM_$cunsafeNewArray__closure}),
 (cb44, {SkipList.$fMArrayTArrayeSTM_$cunsafeNewArray__closure}),
 (cb45,
  {Data.Array.Base.arrEleBottom_closure,
   SkipList.$fMArrayTArrayeSTM_closure,
   SkipList.$fMArrayTArrayeSTM_$cunsafeNewArray__closure}),
 (cb46,
  {Data.Array.Base.arrEleBottom_closure,
   SkipList.$fMArrayTArrayeSTM_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:45.584396 UTC

SkipList.$fMArrayTArrayeSTM_$cunsafeNewArray__entry() //  [R3, R2]
        { info_tbl: [(cb40,
                      label: block_cb40_info
                      rep:StackRep [False]),
                     (cb43,
                      label: SkipList.$fMArrayTArrayeSTM_$cunsafeNewArray__info
                      rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cb43:
          _sazF::P64 = R3;
          _sazE::P64 = R2;
          if ((Sp + -32) < SpLim) goto cb44; else goto cb45;
      cb45:
          if (HpLim == 0) goto cb44; else goto cb46;
      cb44:
          R3 = _sazF::P64;
          R2 = _sazE::P64;
          R1 = SkipList.$fMArrayTArrayeSTM_$cunsafeNewArray__closure;
          call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
      cb46:
          I64[Sp - 16] = cb40;
          R1 = _sazF::P64;
          P64[Sp - 8] = _sazE::P64;
          Sp = Sp - 16;
          if (R1 & 7 != 0) goto cb40; else goto cb41;
      cb41:
          call (I64[R1])(R1) returns to cb40, args: 8, res: 8, upd: 8;
      cb40:
          R2 = SkipList.$fMArrayTArrayeSTM_closure+1;
          I64[Sp - 16] = stg_ap_ppp_info;
          P64[Sp - 8] = P64[Sp + 8];
          P64[Sp] = R1;
          P64[Sp + 8] = Data.Array.Base.arrEleBottom_closure;
          Sp = Sp - 16;
          call Data.Array.Base.newArray_info(R2) args: 40, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:45.586234 UTC

SkipList.$fMArrayTArrayeSTM_$cunsafeNewArray__entry() //  [R3, R2]
        { info_tbl: [(cb40,
                      label: block_cb40_info
                      rep:StackRep [False]),
                     (cb43,
                      label: SkipList.$fMArrayTArrayeSTM_$cunsafeNewArray__info
                      rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cb43:
          _sazF::P64 = R3;
          _sazE::P64 = R2;
          if ((Sp + -32) < SpLim) goto cb44; else goto cb45;
      cb45:
          if (HpLim == 0) goto cb44; else goto cb46;
      cb44:
          R3 = _sazF::P64;
          R2 = _sazE::P64;
          R1 = SkipList.$fMArrayTArrayeSTM_$cunsafeNewArray__closure;
          call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
      cb46:
          I64[Sp - 16] = cb40;
          R1 = _sazF::P64;
          P64[Sp - 8] = _sazE::P64;
          Sp = Sp - 16;
          if (R1 & 7 != 0) goto cb40; else goto cb41;
      cb41:
          call (I64[R1])(R1) returns to cb40, args: 8, res: 8, upd: 8;
      cb40:
          R2 = SkipList.$fMArrayTArrayeSTM_closure+1;
          I64[Sp - 16] = stg_ap_ppp_info;
          P64[Sp - 8] = P64[Sp + 8];
          P64[Sp] = R1;
          P64[Sp + 8] = Data.Array.Base.arrEleBottom_closure;
          Sp = Sp - 16;
          call Data.Array.Base.newArray_info(R2) args: 40, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:45.588109 UTC

[section "data" {
     SkipList.$fMArrayTArrayeSTM_$cunsafeNewArray__closure:
         const SkipList.$fMArrayTArrayeSTM_$cunsafeNewArray__info;
         const 0;
 },
 SkipList.$fMArrayTArrayeSTM_$cunsafeNewArray__entry() //  [R3, R2]
         { info_tbl: [(cb40,
                       label: block_cb40_info
                       rep:StackRep [False]),
                      (cb43,
                       label: SkipList.$fMArrayTArrayeSTM_$cunsafeNewArray__info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cb43:
           _sazF::P64 = R3;
           _sazE::P64 = R2;
           if ((Sp + -32) < SpLim) goto cb44; else goto cb45;
       cb45:
           if (HpLim == 0) goto cb44; else goto cb46;
       cb44:
           R3 = _sazF::P64;
           R2 = _sazE::P64;
           R1 = SkipList.$fMArrayTArrayeSTM_$cunsafeNewArray__closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb46:
           I64[Sp - 16] = cb40;
           R1 = _sazF::P64;
           P64[Sp - 8] = _sazE::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto cb40; else goto cb41;
       cb41:
           call (I64[R1])(R1) returns to cb40, args: 8, res: 8, upd: 8;
       cb40:
           R2 = SkipList.$fMArrayTArrayeSTM_closure+1;
           I64[Sp - 16] = stg_ap_ppp_info;
           P64[Sp - 8] = P64[Sp + 8];
           P64[Sp] = R1;
           P64[Sp + 8] = Data.Array.Base.arrEleBottom_closure;
           Sp = Sp - 16;
           call Data.Array.Base.newArray_info(R2) args: 40, res: 0, upd: 8;
     }
 },
 section "data" {
     SkipList.$fMArrayTArrayeSTM_closure:
         const Data.Array.Base.D:MArray_static_info;
         const Control.NoRec.STM.$fMonadSTM_closure;
         const SkipList.$fMArrayTArrayeSTM11_closure+3;
         const SkipList.$fMArrayTArrayeSTM10_closure+3;
         const SkipList.$fMArrayTArrayeSTM4_closure+4;
         const SkipList.$fMArrayTArrayeSTM8_closure+3;
         const SkipList.$fMArrayTArrayeSTM_$cunsafeNewArray__closure+2;
         const SkipList.$fMArrayTArrayeSTM2_closure+4;
         const SkipList.$fMArrayTArrayeSTM1_closure+5;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:45.59138 UTC

[section "data" {
     SkipList.$fMArrayTArrayeSTM_$cunsafeNewArray__closure:
         const SkipList.$fMArrayTArrayeSTM_$cunsafeNewArray__info;
         const 0;
 },
 SkipList.$fMArrayTArrayeSTM_$cunsafeNewArray__entry() //  [R3, R2]
         { info_tbl: [(cb40,
                       label: block_cb40_info
                       rep:StackRep [False]),
                      (cb43,
                       label: SkipList.$fMArrayTArrayeSTM_$cunsafeNewArray__info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cb43:
           _sazF::P64 = R3;
           _sazE::P64 = R2;
           if ((Sp + -32) < SpLim) goto cb44; else goto cb45;
       cb45:
           if (HpLim == 0) goto cb44; else goto cb46;
       cb44:
           R3 = _sazF::P64;
           R2 = _sazE::P64;
           R1 = SkipList.$fMArrayTArrayeSTM_$cunsafeNewArray__closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb46:
           I64[Sp - 16] = cb40;
           R1 = _sazF::P64;
           P64[Sp - 8] = _sazE::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto cb40; else goto cb41;
       cb41:
           call (I64[R1])(R1) returns to cb40, args: 8, res: 8, upd: 8;
       cb40:
           R2 = SkipList.$fMArrayTArrayeSTM_closure+1;
           I64[Sp - 16] = stg_ap_ppp_info;
           P64[Sp - 8] = P64[Sp + 8];
           P64[Sp] = R1;
           P64[Sp + 8] = Data.Array.Base.arrEleBottom_closure;
           Sp = Sp - 16;
           call Data.Array.Base.newArray_info(R2) args: 40, res: 0, upd: 8;
     }
 },
 section "data" {
     SkipList.$fMArrayTArrayeSTM_closure:
         const Data.Array.Base.D:MArray_static_info;
         const Control.NoRec.STM.$fMonadSTM_closure;
         const SkipList.$fMArrayTArrayeSTM11_closure+3;
         const SkipList.$fMArrayTArrayeSTM10_closure+3;
         const SkipList.$fMArrayTArrayeSTM4_closure+4;
         const SkipList.$fMArrayTArrayeSTM8_closure+3;
         const SkipList.$fMArrayTArrayeSTM_$cunsafeNewArray__closure+2;
         const SkipList.$fMArrayTArrayeSTM2_closure+4;
         const SkipList.$fMArrayTArrayeSTM1_closure+5;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:45.597686 UTC

[section "data" {
     lvl19_rawd_closure:
         const lvl19_rawd_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     cb4n_str:
         I8[] [73,110,116]
 },
 lvl19_rawd_entry() //  [R1]
         { info_tbl: [(cb4o,
                       label: lvl19_rawd_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cb4o:
           _rawd::P64 = R1;
           goto cb4i;
       cb4i:
           if ((old + 0) - <highSp> < SpLim) goto cb4p; else goto cb4q;
       cb4q:
           if (HpLim == 0) goto cb4p; else goto cb4r;
       cb4p:
           R1 = _rawd::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb4r:
           (_cb4k::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rawd::P64);
           if (_cb4k::I64 == 0) goto cb4m; else goto cb4l;
       cb4m:
           call (I64[_rawd::P64])() args: 8, res: 0, upd: 8;
       cb4l:
           I64[(old + 24)] = stg_bh_upd_frame_info;
           I64[(old + 16)] = _cb4k::I64;
           R2 = cb4n_str;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:45.599804 UTC

{offset
  cb4o:
      _rawd::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cb4p; else goto cb4q;
  cb4q:
      if (HpLim == 0) goto cb4p; else goto cb4r;
  cb4p:
      R1 = _rawd::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cb4r:
      (_cb4k::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rawd::P64);
      if (_cb4k::I64 == 0) goto cb4m; else goto cb4l;
  cb4m:
      call (I64[_rawd::P64])() args: 8, res: 0, upd: 8;
  cb4l:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _cb4k::I64;
      R2 = cb4n_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:45.600911 UTC

{offset
  cb4o:
      _rawd::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cb4p; else goto cb4q;
  cb4q:
      if (HpLim == 0) goto cb4p; else goto cb4r;
  cb4p:
      R1 = _rawd::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cb4r:
      (_cb4k::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rawd::P64);
      if (_cb4k::I64 == 0) goto cb4m; else goto cb4l;
  cb4m:
      call (I64[_rawd::P64])() args: 8, res: 0, upd: 8;
  cb4l:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _cb4k::I64;
      R2 = cb4n_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:45.602023 UTC

{offset
  cb4o:
      _rawd::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cb4p; else goto cb4q;
  cb4q:
      if (HpLim == 0) goto cb4p; else goto cb4r;
  cb4p:
      R1 = _rawd::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cb4r:
      (_cb4k::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rawd::P64);
      if (_cb4k::I64 == 0) goto cb4m; else goto cb4l;
  cb4m:
      call (I64[_rawd::P64])() args: 8, res: 0, upd: 8;
  cb4l:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _cb4k::I64;
      R2 = cb4n_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:45.603211 UTC

{offset
  cb4o:
      _rawd::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto cb4p; else goto cb4q;
  cb4q:
      if (HpLim == 0) goto cb4p; else goto cb4r;
  cb4p:
      R1 = _rawd::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cb4r:
      (_cb4k::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rawd::P64);
      if (_cb4k::I64 == 0) goto cb4m; else goto cb4l;
  cb4m:
      call (I64[_rawd::P64])() args: 8, res: 0, upd: 8;
  cb4l:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _cb4k::I64;
      R2 = cb4n_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:45.604353 UTC

{offset
  cb4o:
      _rawd::P64 = R1;
      if ((Sp + -16) < SpLim) goto cb4p; else goto cb4q;
  cb4q:
      if (HpLim == 0) goto cb4p; else goto cb4r;
  cb4p:
      R1 = _rawd::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cb4r:
      (_cb4k::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rawd::P64);
      if (_cb4k::I64 == 0) goto cb4m; else goto cb4l;
  cb4m:
      call (I64[_rawd::P64])() args: 8, res: 0, upd: 8;
  cb4l:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _cb4k::I64;
      R2 = cb4n_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:45.605632 UTC

[(cb4l, {}), (cb4m, {}), (cb4o, {}), (cb4p, {}), (cb4q, {}),
 (cb4r, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:45.606013 UTC

lvl19_rawd_entry() //  [R1]
        { info_tbl: [(cb4o,
                      label: lvl19_rawd_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cb4o:
          _rawd::P64 = R1;
          if ((Sp + -16) < SpLim) goto cb4p; else goto cb4q;
      cb4q:
          if (HpLim == 0) goto cb4p; else goto cb4r;
      cb4p:
          R1 = _rawd::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      cb4r:
          (_cb4k::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rawd::P64);
          if (_cb4k::I64 == 0) goto cb4m; else goto cb4l;
      cb4m:
          call (I64[_rawd::P64])() args: 8, res: 0, upd: 8;
      cb4l:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _cb4k::I64;
          R2 = cb4n_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:45.607414 UTC

lvl19_rawd_entry() //  [R1]
        { info_tbl: [(cb4o,
                      label: lvl19_rawd_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cb4o:
          _rawd::P64 = R1;
          if ((Sp + -16) < SpLim) goto cb4p; else goto cb4q;
      cb4q:
          if (HpLim == 0) goto cb4p; else goto cb4r;
      cb4p:
          R1 = _rawd::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      cb4r:
          (_cb4k::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rawd::P64);
          if (_cb4k::I64 == 0) goto cb4m; else goto cb4l;
      cb4m:
          call (I64[_rawd::P64])() args: 8, res: 0, upd: 8;
      cb4l:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _cb4k::I64;
          R2 = cb4n_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:45.608819 UTC

[section "data" {
     lvl19_rawd_closure:
         const lvl19_rawd_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     cb4n_str:
         I8[] [73,110,116]
 },
 lvl19_rawd_entry() //  [R1]
         { info_tbl: [(cb4o,
                       label: lvl19_rawd_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cb4o:
           _rawd::P64 = R1;
           if ((Sp + -16) < SpLim) goto cb4p; else goto cb4q;
       cb4q:
           if (HpLim == 0) goto cb4p; else goto cb4r;
       cb4p:
           R1 = _rawd::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb4r:
           (_cb4k::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rawd::P64);
           if (_cb4k::I64 == 0) goto cb4m; else goto cb4l;
       cb4m:
           call (I64[_rawd::P64])() args: 8, res: 0, upd: 8;
       cb4l:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb4k::I64;
           R2 = cb4n_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:45.610546 UTC

[section "data" {
     lvl19_rawd_closure:
         const lvl19_rawd_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     cb4n_str:
         I8[] [73,110,116]
 },
 lvl19_rawd_entry() //  [R1]
         { info_tbl: [(cb4o,
                       label: lvl19_rawd_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cb4o:
           _rawd::P64 = R1;
           if ((Sp + -16) < SpLim) goto cb4p; else goto cb4q;
       cb4q:
           if (HpLim == 0) goto cb4p; else goto cb4r;
       cb4p:
           R1 = _rawd::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb4r:
           (_cb4k::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rawd::P64);
           if (_cb4k::I64 == 0) goto cb4m; else goto cb4l;
       cb4m:
           call (I64[_rawd::P64])() args: 8, res: 0, upd: 8;
       cb4l:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb4k::I64;
           R2 = cb4n_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:45.615298 UTC

[section "data" {
     lvl20_rawe_closure:
         const lvl20_rawe_info;
         const 0;
 },
 lvl20_rawe_entry() //  [R4, R3, R2]
         { info_tbl: [(cb4E,
                       label: lvl20_rawe_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 19} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cb4E:
           _sazL::P64 = R4;
           _sazK::P64 = R3;
           _sazJ::I64 = R2;
           goto cb4A;
       cb4A:
           if ((old + 0) - <highSp> < SpLim) goto cb4F; else goto cb4G;
       cb4G:
           goto cb4z;
       cb4z:
           Hp = Hp + 40;
           if (Hp > HpLim) goto cb4I; else goto cb4H;
       cb4I:
           HpAlloc = 40;
           goto cb4F;
       cb4F:
           R4 = _sazL::P64;
           R3 = _sazK::P64;
           R2 = _sazJ::I64;
           R1 = lvl20_rawe_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb4H:
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = _sazJ::I64;
           _cb4C::P64 = Hp - 31;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _sazK::P64;
           P64[Hp] = _sazL::P64;
           _cb4D::P64 = Hp - 15;
           R5 = lvl19_rawd_closure;
           R4 = _cb4C::P64;
           R3 = _cb4D::P64;
           R2 = GHC.Show.$fShowInt_closure;
           call GHC.Arr.indexError_info(R5,
                                        R4,
                                        R3,
                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:45.618023 UTC

{offset
  cb4E:
      _sazL::P64 = R4;
      _sazK::P64 = R3;
      _sazJ::I64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cb4F; else goto cb4G;
  cb4G:
      Hp = Hp + 40;
      if (Hp > HpLim) goto cb4I; else goto cb4H;
  cb4I:
      HpAlloc = 40;
      goto cb4F;
  cb4F:
      R4 = _sazL::P64;
      R3 = _sazK::P64;
      R2 = _sazJ::I64;
      R1 = lvl20_rawe_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  cb4H:
      I64[Hp - 32] = GHC.Types.I#_con_info;
      I64[Hp - 24] = _sazJ::I64;
      _cb4C::P64 = Hp - 31;
      I64[Hp - 16] = (,)_con_info;
      P64[Hp - 8] = _sazK::P64;
      P64[Hp] = _sazL::P64;
      _cb4D::P64 = Hp - 15;
      R5 = lvl19_rawd_closure;
      R4 = _cb4C::P64;
      R3 = _cb4D::P64;
      R2 = GHC.Show.$fShowInt_closure;
      call GHC.Arr.indexError_info(R5,
                                   R4,
                                   R3,
                                   R2) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:45.619493 UTC

{offset
  cb4E:
      _sazL::P64 = R4;
      _sazK::P64 = R3;
      _sazJ::I64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cb4F; else goto cb4G;
  cb4G:
      Hp = Hp + 40;
      if (Hp > HpLim) goto cb4I; else goto cb4H;
  cb4I:
      HpAlloc = 40;
      goto cb4F;
  cb4F:
      R4 = _sazL::P64;
      R3 = _sazK::P64;
      R2 = _sazJ::I64;
      R1 = lvl20_rawe_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  cb4H:
      I64[Hp - 32] = GHC.Types.I#_con_info;
      I64[Hp - 24] = _sazJ::I64;
      _cb4C::P64 = Hp - 31;
      I64[Hp - 16] = (,)_con_info;
      P64[Hp - 8] = _sazK::P64;
      P64[Hp] = _sazL::P64;
      _cb4D::P64 = Hp - 15;
      R5 = lvl19_rawd_closure;
      R4 = _cb4C::P64;
      R3 = _cb4D::P64;
      R2 = GHC.Show.$fShowInt_closure;
      call GHC.Arr.indexError_info(R5,
                                   R4,
                                   R3,
                                   R2) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:45.620986 UTC

{offset
  cb4E:
      _sazL::P64 = R4;
      _sazK::P64 = R3;
      _sazJ::I64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cb4F; else goto cb4G;
  cb4G:
      Hp = Hp + 40;
      if (Hp > HpLim) goto cb4I; else goto cb4H;
  cb4I:
      HpAlloc = 40;
      goto cb4F;
  cb4F:
      R4 = _sazL::P64;
      R3 = _sazK::P64;
      R2 = _sazJ::I64;
      R1 = lvl20_rawe_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  cb4H:
      I64[Hp - 32] = GHC.Types.I#_con_info;
      I64[Hp - 24] = _sazJ::I64;
      _cb4C::P64 = Hp - 31;
      I64[Hp - 16] = (,)_con_info;
      P64[Hp - 8] = _sazK::P64;
      P64[Hp] = _sazL::P64;
      _cb4D::P64 = Hp - 15;
      R5 = lvl19_rawd_closure;
      R4 = _cb4C::P64;
      R3 = _cb4D::P64;
      R2 = GHC.Show.$fShowInt_closure;
      call GHC.Arr.indexError_info(R5,
                                   R4,
                                   R3,
                                   R2) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:45.622525 UTC

{offset
  cb4E:
      _sazL::P64 = R4;
      _sazK::P64 = R3;
      _sazJ::I64 = R2;
      goto cb4G;
  cb4G:
      Hp = Hp + 40;
      if (Hp > HpLim) goto cb4I; else goto cb4H;
  cb4I:
      HpAlloc = 40;
      goto cb4F;
  cb4F:
      R4 = _sazL::P64;
      R3 = _sazK::P64;
      R2 = _sazJ::I64;
      R1 = lvl20_rawe_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  cb4H:
      I64[Hp - 32] = GHC.Types.I#_con_info;
      I64[Hp - 24] = _sazJ::I64;
      _cb4C::P64 = Hp - 31;
      I64[Hp - 16] = (,)_con_info;
      P64[Hp - 8] = _sazK::P64;
      P64[Hp] = _sazL::P64;
      _cb4D::P64 = Hp - 15;
      R5 = lvl19_rawd_closure;
      R4 = _cb4C::P64;
      R3 = _cb4D::P64;
      R2 = GHC.Show.$fShowInt_closure;
      call GHC.Arr.indexError_info(R5,
                                   R4,
                                   R3,
                                   R2) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:45.623941 UTC

{offset
  cb4E:
      goto cb4G;
  cb4G:
      Hp = Hp + 40;
      if (Hp > HpLim) goto cb4I; else goto cb4H;
  cb4I:
      HpAlloc = 40;
      goto cb4F;
  cb4F:
      R4 = R4;
      R3 = R3;
      R2 = R2;
      R1 = lvl20_rawe_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  cb4H:
      I64[Hp - 32] = GHC.Types.I#_con_info;
      I64[Hp - 24] = R2;
      I64[Hp - 16] = (,)_con_info;
      P64[Hp - 8] = R3;
      P64[Hp] = R4;
      R5 = lvl19_rawd_closure;
      R4 = Hp - 31;
      R3 = Hp - 15;
      R2 = GHC.Show.$fShowInt_closure;
      call GHC.Arr.indexError_info(R5,
                                   R4,
                                   R3,
                                   R2) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:45.625466 UTC

[(cb4E,
  {GHC.Arr.indexError_closure, lvl19_rawd_closure,
   lvl20_rawe_closure}),
 (cb4F, {lvl20_rawe_closure}),
 (cb4G,
  {GHC.Arr.indexError_closure, lvl19_rawd_closure,
   lvl20_rawe_closure}),
 (cb4H, {GHC.Arr.indexError_closure, lvl19_rawd_closure}),
 (cb4I, {lvl20_rawe_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:45.62617 UTC

lvl20_rawe_entry() //  [R4, R3, R2]
        { info_tbl: [(cb4E,
                      label: lvl20_rawe_info
                      rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 19} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cb4E:
          goto cb4G;
      cb4G:
          Hp = Hp + 40;
          if (Hp > HpLim) goto cb4I; else goto cb4H;
      cb4I:
          HpAlloc = 40;
          goto cb4F;
      cb4F:
          R4 = R4;
          R3 = R3;
          R2 = R2;
          R1 = lvl20_rawe_closure;
          call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
      cb4H:
          I64[Hp - 32] = GHC.Types.I#_con_info;
          I64[Hp - 24] = R2;
          I64[Hp - 16] = (,)_con_info;
          P64[Hp - 8] = R3;
          P64[Hp] = R4;
          R5 = lvl19_rawd_closure;
          R4 = Hp - 31;
          R3 = Hp - 15;
          R2 = GHC.Show.$fShowInt_closure;
          call GHC.Arr.indexError_info(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:45.627676 UTC

lvl20_rawe_entry() //  [R4, R3, R2]
        { info_tbl: [(cb4E,
                      label: lvl20_rawe_info
                      rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 19} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cb4E:
          Hp = Hp + 40;
          if (Hp > HpLim) goto cb4I; else goto cb4H;
      cb4I:
          HpAlloc = 40;
          R4 = R4;
          R3 = R3;
          R2 = R2;
          R1 = lvl20_rawe_closure;
          call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
      cb4H:
          I64[Hp - 32] = GHC.Types.I#_con_info;
          I64[Hp - 24] = R2;
          I64[Hp - 16] = (,)_con_info;
          P64[Hp - 8] = R3;
          P64[Hp] = R4;
          R5 = lvl19_rawd_closure;
          R4 = Hp - 31;
          R3 = Hp - 15;
          R2 = GHC.Show.$fShowInt_closure;
          call GHC.Arr.indexError_info(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:45.629118 UTC

[section "data" {
     lvl20_rawe_closure:
         const lvl20_rawe_info;
         const 0;
 },
 lvl20_rawe_entry() //  [R4, R3, R2]
         { info_tbl: [(cb4E,
                       label: lvl20_rawe_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 19} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cb4E:
           Hp = Hp + 40;
           if (Hp > HpLim) goto cb4I; else goto cb4H;
       cb4I:
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = lvl20_rawe_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb4H:
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R5 = lvl19_rawd_closure;
           R4 = Hp - 31;
           R3 = Hp - 15;
           R2 = GHC.Show.$fShowInt_closure;
           call GHC.Arr.indexError_info(R5,
                                        R4,
                                        R3,
                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:45.631366 UTC

[section "data" {
     lvl20_rawe_closure:
         const lvl20_rawe_info;
         const 0;
 },
 lvl20_rawe_entry() //  [R4, R3, R2]
         { info_tbl: [(cb4E,
                       label: lvl20_rawe_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 19} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cb4E:
           Hp = Hp + 40;
           if (Hp > HpLim) goto cb4I; else goto cb4H;
       cb4I:
           HpAlloc = 40;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = lvl20_rawe_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb4H:
           I64[Hp - 32] = GHC.Types.I#_con_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R5 = lvl19_rawd_closure;
           R4 = Hp - 31;
           R3 = Hp - 15;
           R2 = GHC.Show.$fShowInt_closure;
           call GHC.Arr.indexError_info(R5,
                                        R4,
                                        R3,
                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:45.635364 UTC

[section "data" {
     lvl21_rawf_closure:
         const GHC.Types.I#_static_info;
         const 87;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:45.635736 UTC

[section "data" {
     lvl21_rawf_closure:
         const GHC.Types.I#_static_info;
         const 87;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:45.636045 UTC

[section "data" {
     lvl21_rawf_closure:
         const GHC.Types.I#_static_info;
         const 87;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:45.636591 UTC

[section "data" {
     lvl22_rawg_closure:
         const GHC.Types.I#_static_info;
         const 31;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:45.636935 UTC

[section "data" {
     lvl22_rawg_closure:
         const GHC.Types.I#_static_info;
         const 31;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:45.637282 UTC

[section "data" {
     lvl22_rawg_closure:
         const GHC.Types.I#_static_info;
         const 31;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:45.637828 UTC

[section "data" {
     lvl23_rawh_closure:
         const GHC.Types.I#_static_info;
         const 36;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:45.638179 UTC

[section "data" {
     lvl23_rawh_closure:
         const GHC.Types.I#_static_info;
         const 36;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:45.638489 UTC

[section "data" {
     lvl23_rawh_closure:
         const GHC.Types.I#_static_info;
         const 36;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:45.639137 UTC

[section "data" {
     lvl24_rawi_closure:
         const GHC.Stack.Types.SrcLoc_static_info;
         const lvl8_raw2_closure;
         const lvl9_raw3_closure;
         const lvl10_raw4_closure;
         const lvl21_rawf_closure+1;
         const lvl22_rawg_closure+1;
         const lvl21_rawf_closure+1;
         const lvl23_rawh_closure+1;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:45.639763 UTC

[section "data" {
     lvl24_rawi_closure:
         const GHC.Stack.Types.SrcLoc_static_info;
         const lvl8_raw2_closure;
         const lvl9_raw3_closure;
         const lvl10_raw4_closure;
         const lvl21_rawf_closure+1;
         const lvl22_rawg_closure+1;
         const lvl21_rawf_closure+1;
         const lvl23_rawh_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:45.640325 UTC

[section "data" {
     lvl24_rawi_closure:
         const GHC.Stack.Types.SrcLoc_static_info;
         const lvl8_raw2_closure;
         const lvl9_raw3_closure;
         const lvl10_raw4_closure;
         const lvl21_rawf_closure+1;
         const lvl22_rawg_closure+1;
         const lvl21_rawf_closure+1;
         const lvl23_rawh_closure+1;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:45.64134 UTC

[section "data" {
     lvl25_rawj_closure:
         const (,)_static_info;
         const lvl7_raw1_closure;
         const lvl24_rawi_closure+1;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:45.641763 UTC

[section "data" {
     lvl25_rawj_closure:
         const (,)_static_info;
         const lvl7_raw1_closure;
         const lvl24_rawi_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:45.642143 UTC

[section "data" {
     lvl25_rawj_closure:
         const (,)_static_info;
         const lvl7_raw1_closure;
         const lvl24_rawi_closure+1;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:45.642871 UTC

[section "data" {
     lvl26_rawk_closure:
         const :_static_info;
         const lvl25_rawj_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:45.64329 UTC

[section "data" {
     lvl26_rawk_closure:
         const :_static_info;
         const lvl25_rawj_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:45.643672 UTC

[section "data" {
     lvl26_rawk_closure:
         const :_static_info;
         const lvl25_rawj_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:45.644377 UTC

[section "data" {
     lvl27_rawl_closure:
         const GHC.Stack.Types.CallStack_static_info;
         const lvl26_rawk_closure+2;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:45.644764 UTC

[section "data" {
     lvl27_rawl_closure:
         const GHC.Stack.Types.CallStack_static_info;
         const lvl26_rawk_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:45.645602 UTC

[section "data" {
     lvl27_rawl_closure:
         const GHC.Stack.Types.CallStack_static_info;
         const lvl26_rawk_closure+2;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:45.646253 UTC

[section "data" {
     lvl28_rawm_closure:
         const lvl28_rawm_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     cb57_str:
         I8[] [41]
 },
 lvl28_rawm_entry() //  [R1]
         { info_tbl: [(cb58,
                       label: lvl28_rawm_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cb58:
           _rawm::P64 = R1;
           goto cb52;
       cb52:
           if ((old + 0) - <highSp> < SpLim) goto cb59; else goto cb5a;
       cb5a:
           if (HpLim == 0) goto cb59; else goto cb5b;
       cb59:
           R1 = _rawm::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb5b:
           (_cb54::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rawm::P64);
           if (_cb54::I64 == 0) goto cb56; else goto cb55;
       cb56:
           call (I64[_rawm::P64])() args: 8, res: 0, upd: 8;
       cb55:
           I64[(old + 24)] = stg_bh_upd_frame_info;
           I64[(old + 16)] = _cb54::I64;
           R2 = cb57_str;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:45.648416 UTC

{offset
  cb58:
      _rawm::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cb59; else goto cb5a;
  cb5a:
      if (HpLim == 0) goto cb59; else goto cb5b;
  cb59:
      R1 = _rawm::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cb5b:
      (_cb54::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rawm::P64);
      if (_cb54::I64 == 0) goto cb56; else goto cb55;
  cb56:
      call (I64[_rawm::P64])() args: 8, res: 0, upd: 8;
  cb55:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _cb54::I64;
      R2 = cb57_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:45.649522 UTC

{offset
  cb58:
      _rawm::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cb59; else goto cb5a;
  cb5a:
      if (HpLim == 0) goto cb59; else goto cb5b;
  cb59:
      R1 = _rawm::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cb5b:
      (_cb54::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rawm::P64);
      if (_cb54::I64 == 0) goto cb56; else goto cb55;
  cb56:
      call (I64[_rawm::P64])() args: 8, res: 0, upd: 8;
  cb55:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _cb54::I64;
      R2 = cb57_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:45.650642 UTC

{offset
  cb58:
      _rawm::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cb59; else goto cb5a;
  cb5a:
      if (HpLim == 0) goto cb59; else goto cb5b;
  cb59:
      R1 = _rawm::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cb5b:
      (_cb54::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rawm::P64);
      if (_cb54::I64 == 0) goto cb56; else goto cb55;
  cb56:
      call (I64[_rawm::P64])() args: 8, res: 0, upd: 8;
  cb55:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _cb54::I64;
      R2 = cb57_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:45.6518 UTC

{offset
  cb58:
      _rawm::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto cb59; else goto cb5a;
  cb5a:
      if (HpLim == 0) goto cb59; else goto cb5b;
  cb59:
      R1 = _rawm::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cb5b:
      (_cb54::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rawm::P64);
      if (_cb54::I64 == 0) goto cb56; else goto cb55;
  cb56:
      call (I64[_rawm::P64])() args: 8, res: 0, upd: 8;
  cb55:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _cb54::I64;
      R2 = cb57_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:45.653071 UTC

{offset
  cb58:
      _rawm::P64 = R1;
      if ((Sp + -16) < SpLim) goto cb59; else goto cb5a;
  cb5a:
      if (HpLim == 0) goto cb59; else goto cb5b;
  cb59:
      R1 = _rawm::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cb5b:
      (_cb54::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rawm::P64);
      if (_cb54::I64 == 0) goto cb56; else goto cb55;
  cb56:
      call (I64[_rawm::P64])() args: 8, res: 0, upd: 8;
  cb55:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _cb54::I64;
      R2 = cb57_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:45.654337 UTC

[(cb55, {}), (cb56, {}), (cb58, {}), (cb59, {}), (cb5a, {}),
 (cb5b, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:45.654713 UTC

lvl28_rawm_entry() //  [R1]
        { info_tbl: [(cb58,
                      label: lvl28_rawm_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cb58:
          _rawm::P64 = R1;
          if ((Sp + -16) < SpLim) goto cb59; else goto cb5a;
      cb5a:
          if (HpLim == 0) goto cb59; else goto cb5b;
      cb59:
          R1 = _rawm::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      cb5b:
          (_cb54::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rawm::P64);
          if (_cb54::I64 == 0) goto cb56; else goto cb55;
      cb56:
          call (I64[_rawm::P64])() args: 8, res: 0, upd: 8;
      cb55:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _cb54::I64;
          R2 = cb57_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:45.656058 UTC

lvl28_rawm_entry() //  [R1]
        { info_tbl: [(cb58,
                      label: lvl28_rawm_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cb58:
          _rawm::P64 = R1;
          if ((Sp + -16) < SpLim) goto cb59; else goto cb5a;
      cb5a:
          if (HpLim == 0) goto cb59; else goto cb5b;
      cb59:
          R1 = _rawm::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      cb5b:
          (_cb54::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rawm::P64);
          if (_cb54::I64 == 0) goto cb56; else goto cb55;
      cb56:
          call (I64[_rawm::P64])() args: 8, res: 0, upd: 8;
      cb55:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _cb54::I64;
          R2 = cb57_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:45.65744 UTC

[section "data" {
     lvl28_rawm_closure:
         const lvl28_rawm_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     cb57_str:
         I8[] [41]
 },
 lvl28_rawm_entry() //  [R1]
         { info_tbl: [(cb58,
                       label: lvl28_rawm_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cb58:
           _rawm::P64 = R1;
           if ((Sp + -16) < SpLim) goto cb59; else goto cb5a;
       cb5a:
           if (HpLim == 0) goto cb59; else goto cb5b;
       cb59:
           R1 = _rawm::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb5b:
           (_cb54::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rawm::P64);
           if (_cb54::I64 == 0) goto cb56; else goto cb55;
       cb56:
           call (I64[_rawm::P64])() args: 8, res: 0, upd: 8;
       cb55:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb54::I64;
           R2 = cb57_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:45.659139 UTC

[section "data" {
     lvl28_rawm_closure:
         const lvl28_rawm_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     cb57_str:
         I8[] [41]
 },
 lvl28_rawm_entry() //  [R1]
         { info_tbl: [(cb58,
                       label: lvl28_rawm_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cb58:
           _rawm::P64 = R1;
           if ((Sp + -16) < SpLim) goto cb59; else goto cb5a;
       cb5a:
           if (HpLim == 0) goto cb59; else goto cb5b;
       cb59:
           R1 = _rawm::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb5b:
           (_cb54::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rawm::P64);
           if (_cb54::I64 == 0) goto cb56; else goto cb55;
       cb56:
           call (I64[_rawm::P64])() args: 8, res: 0, upd: 8;
       cb55:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cb54::I64;
           R2 = cb57_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:45.664067 UTC

[section "data" {
     lvl29_rawn_closure:
         const lvl29_rawn_info;
         const 0;
 },
 sat_sazY_entry() //  [R1]
         { info_tbl: [(cb5H,
                       label: sat_sazY_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cb5H:
           _sazY::P64 = R1;
           goto cb5C;
       cb5C:
           if ((old + 0) - <highSp> < SpLim) goto cb5I; else goto cb5J;
       cb5J:
           if (HpLim == 0) goto cb5I; else goto cb5K;
       cb5I:
           R1 = _sazY::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb5K:
           I64[(old + 24)] = stg_upd_frame_info;
           P64[(old + 16)] = _sazY::P64;
           _sazO::I64 = I64[_sazY::P64 + 16];
           I64[(young<cb5E> + 8)] = cb5E;
           R4 = GHC.Types.[]_closure+1;
           R3 = _sazO::I64;
           R2 = 0;
           call GHC.Show.$wshowSignedInt_info(R4,
                                              R3,
                                              R2) returns to cb5E, args: 8, res: 8, upd: 24;
       cb5E:
           _sazW::P64 = R2;
           _sazV::P64 = R1;
           Hp = Hp + 24;
           if (Hp > HpLim) goto cb5N; else goto cb5M;
       cb5N:
           HpAlloc = 24;
           goto cb5L;
       cb5L:
           R2 = _sazW::P64;
           R1 = _sazV::P64;
           call stg_gc_pp(R2, R1) returns to cb5E, args: 8, res: 8, upd: 24;
       cb5M:
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sazV::P64;
           P64[Hp] = _sazW::P64;
           _cb5G::P64 = Hp - 14;
           R3 = lvl28_rawm_closure;
           R2 = _cb5G::P64;
           call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section "readonly" {
     cb5O_str:
         I8[] [32,110,111,116,32,105,110,32,114,97,110,103,101,32,91,48,46,46]
 },
 sat_sazZ_entry() //  [R1]
         { info_tbl: [(cb5P,
                       label: sat_sazZ_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cb5P:
           _sazZ::P64 = R1;
           goto cb5y;
       cb5y:
           if ((old + 0) - <highSp> < SpLim) goto cb5Q; else goto cb5R;
       cb5R:
           Hp = Hp + 24;
           if (Hp > HpLim) goto cb5T; else goto cb5S;
       cb5T:
           HpAlloc = 24;
           goto cb5Q;
       cb5Q:
           R1 = _sazZ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb5S:
           _sazO::I64 = I64[_sazZ::P64 + 16];
           I64[Hp - 16] = sat_sazY_info;
           I64[Hp] = _sazO::I64;
           _cb5A::P64 = Hp - 16;
           R3 = _cb5A::P64;
           R2 = cb5O_str;
           call GHC.CString.unpackAppendCString#_info(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_saA0_entry() //  [R1]
         { info_tbl: [(cb5V,
                       label: sat_saA0_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cb5V:
           _saA0::P64 = R1;
           goto cb5s;
       cb5s:
           if ((old + 0) - <highSp> < SpLim) goto cb5W; else goto cb5X;
       cb5X:
           if (HpLim == 0) goto cb5W; else goto cb5Y;
       cb5W:
           R1 = _saA0::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb5Y:
           I64[(old + 24)] = stg_upd_frame_info;
           P64[(old + 16)] = _saA0::P64;
           _sazO::I64 = I64[_saA0::P64 + 16];
           _sazP::I64 = I64[_saA0::P64 + 24];
           I64[(young<cb5u> + 8)] = cb5u;
           R4 = GHC.Types.[]_closure+1;
           R3 = _sazP::I64;
           R2 = 0;
           call GHC.Show.$wshowSignedInt_info(R4,
                                              R3,
                                              R2) returns to cb5u, args: 8, res: 8, upd: 24;
       cb5u:
           _sazS::P64 = R2;
           _sazR::P64 = R1;
           Hp = Hp + 48;
           if (Hp > HpLim) goto cb61; else goto cb60;
       cb61:
           HpAlloc = 48;
           goto cb5Z;
       cb5Z:
           R2 = _sazS::P64;
           R1 = _sazR::P64;
           call stg_gc_pp(R2, R1) returns to cb5u, args: 8, res: 8, upd: 24;
       cb60:
           I64[Hp - 40] = sat_sazZ_info;
           I64[Hp - 24] = _sazO::I64;
           _cb5w::P64 = Hp - 40;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sazR::P64;
           P64[Hp] = _sazS::P64;
           _cb5U::P64 = Hp - 14;
           R3 = _cb5w::P64;
           R2 = _cb5U::P64;
           call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section "readonly" {
     cb62_str:
         I8[] [69,114,114,111,114,32,105,110,32,97,114,114,97,121,32,105,110,100,101,120,59,32]
 },
 lvl29_rawn_entry() //  [R3, R2]
         { info_tbl: [(cb65,
                       label: lvl29_rawn_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cb65:
           _sazP::I64 = R3;
           _sazO::I64 = R2;
           goto cb5o;
       cb5o:
           if ((old + 0) - <highSp> < SpLim) goto cb66; else goto cb67;
       cb67:
           goto cb5n;
       cb5n:
           Hp = Hp + 32;
           if (Hp > HpLim) goto cb69; else goto cb68;
       cb69:
           HpAlloc = 32;
           goto cb66;
       cb66:
           R3 = _sazP::I64;
           R2 = _sazO::I64;
           R1 = lvl29_rawn_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb68:
           I64[Hp - 24] = sat_saA0_info;
           I64[Hp - 8] = _sazO::I64;
           I64[Hp] = _sazP::I64;
           _cb5q::P64 = Hp - 24;
           I64[(young<cb63> + 8)] = cb63;
           R3 = _cb5q::P64;
           R2 = cb62_str;
           call GHC.CString.unpackAppendCString#_info(R3,
                                                      R2) returns to cb63, args: 8, res: 8, upd: 8;
       cb63:
           _saA1::P64 = R1;
           R3 = _saA1::P64;
           R2 = lvl27_rawl_closure+1;
           call GHC.Err.error_info(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:45.673934 UTC

{offset
  cb5H:
      _sazY::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cb5I; else goto cb5J;
  cb5J:
      if (HpLim == 0) goto cb5I; else goto cb5K;
  cb5I:
      R1 = _sazY::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cb5K:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sazY::P64;
      _sazO::I64 = I64[_sazY::P64 + 16];
      I64[(young<cb5E> + 8)] = cb5E;
      R4 = GHC.Types.[]_closure+1;
      R3 = _sazO::I64;
      R2 = 0;
      call GHC.Show.$wshowSignedInt_info(R4,
                                         R3,
                                         R2) returns to cb5E, args: 8, res: 8, upd: 24;
  cb5E:
      _sazW::P64 = R2;
      _sazV::P64 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto cb5N; else goto cb5M;
  cb5N:
      HpAlloc = 24;
      R2 = _sazW::P64;
      R1 = _sazV::P64;
      call stg_gc_pp(R2, R1) returns to cb5E, args: 8, res: 8, upd: 24;
  cb5M:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _sazV::P64;
      P64[Hp] = _sazW::P64;
      _cb5G::P64 = Hp - 14;
      R3 = lvl28_rawm_closure;
      R2 = _cb5G::P64;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:45.675756 UTC

{offset
  cb5H:
      _sazY::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cb5I; else goto cb5J;
  cb5J:
      if (HpLim == 0) goto cb5I; else goto cb5K;
  cb5I:
      R1 = _sazY::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cb5K:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sazY::P64;
      _sazO::I64 = I64[_sazY::P64 + 16];
      I64[(young<cb5E> + 8)] = cb5E;
      R4 = GHC.Types.[]_closure+1;
      R3 = _sazO::I64;
      R2 = 0;
      call GHC.Show.$wshowSignedInt_info(R4,
                                         R3,
                                         R2) returns to cb5E, args: 8, res: 8, upd: 24;
  cb5E:
      _sazW::P64 = R2;
      _sazV::P64 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto cb5N; else goto cb5M;
  cb5N:
      HpAlloc = 24;
      R2 = _sazW::P64;
      R1 = _sazV::P64;
      call stg_gc_pp(R2, R1) returns to cb5E, args: 8, res: 8, upd: 24;
  cb5M:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _sazV::P64;
      P64[Hp] = _sazW::P64;
      _cb5G::P64 = Hp - 14;
      R3 = lvl28_rawm_closure;
      R2 = _cb5G::P64;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:45.67757 UTC

{offset
  cb5H:
      _sazY::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cb5I; else goto cb5J;
  cb5J:
      if (HpLim == 0) goto cb5I; else goto cb5K;
  cb5I:
      R1 = _sazY::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cb5K:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sazY::P64;
      _sazO::I64 = I64[_sazY::P64 + 16];
      I64[(young<cb5E> + 8)] = cb5E;
      R4 = GHC.Types.[]_closure+1;
      R3 = _sazO::I64;
      R2 = 0;
      call GHC.Show.$wshowSignedInt_info(R4,
                                         R3,
                                         R2) returns to cb5E, args: 8, res: 8, upd: 24;
  cb5E:
      _sazW::P64 = R2;
      _sazV::P64 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto cb5N; else goto cb5M;
  cb5N:
      HpAlloc = 24;
      R2 = _sazW::P64;
      R1 = _sazV::P64;
      call stg_gc_pp(R2, R1) returns to cb5E, args: 8, res: 8, upd: 24;
  cb5M:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _sazV::P64;
      P64[Hp] = _sazW::P64;
      _cb5G::P64 = Hp - 14;
      R3 = lvl28_rawm_closure;
      R2 = _cb5G::P64;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:45.67955 UTC

{offset
  cb5H:
      _sazY::P64 = R1;
      if ((Sp + 8) - 32 < SpLim) goto cb5I; else goto cb5J;
  cb5J:
      if (HpLim == 0) goto cb5I; else goto cb5K;
  cb5I:
      R1 = _sazY::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cb5K:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _sazY::P64;
      _sazO::I64 = I64[_sazY::P64 + 16];
      I64[Sp - 24] = cb5E;
      R4 = GHC.Types.[]_closure+1;
      R3 = _sazO::I64;
      R2 = 0;
      Sp = Sp - 24;
      call GHC.Show.$wshowSignedInt_info(R4,
                                         R3,
                                         R2) returns to cb5E, args: 8, res: 8, upd: 24;
  cb5E:
      _sazW::P64 = R2;
      _sazV::P64 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto cb5N; else goto cb5M;
  cb5N:
      HpAlloc = 24;
      R2 = _sazW::P64;
      R1 = _sazV::P64;
      call stg_gc_pp(R2, R1) returns to cb5E, args: 8, res: 8, upd: 24;
  cb5M:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _sazV::P64;
      P64[Hp] = _sazW::P64;
      _cb5G::P64 = Hp - 14;
      R3 = lvl28_rawm_closure;
      R2 = _cb5G::P64;
      Sp = Sp + 8;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:45.681389 UTC

{offset
  cb5H:
      _sazY::P64 = R1;
      if ((Sp + -24) < SpLim) goto cb5I; else goto cb5J;
  cb5J:
      if (HpLim == 0) goto cb5I; else goto cb5K;
  cb5I:
      R1 = _sazY::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cb5K:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _sazY::P64;
      I64[Sp - 24] = cb5E;
      R4 = GHC.Types.[]_closure+1;
      R3 = I64[_sazY::P64 + 16];
      R2 = 0;
      Sp = Sp - 24;
      call GHC.Show.$wshowSignedInt_info(R4,
                                         R3,
                                         R2) returns to cb5E, args: 8, res: 8, upd: 24;
  cb5E:
      Hp = Hp + 24;
      if (Hp > HpLim) goto cb5N; else goto cb5M;
  cb5N:
      HpAlloc = 24;
      R2 = R2;
      R1 = R1;
      call stg_gc_pp(R2, R1) returns to cb5E, args: 8, res: 8, upd: 24;
  cb5M:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = R1;
      P64[Hp] = R2;
      R3 = lvl28_rawm_closure;
      R2 = Hp - 14;
      Sp = Sp + 8;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:45.683304 UTC

[(cb5E, {lvl28_rawm_closure}), (cb5H, {lvl28_rawm_closure}),
 (cb5I, {}), (cb5J, {lvl28_rawm_closure}),
 (cb5K, {lvl28_rawm_closure}), (cb5M, {lvl28_rawm_closure}),
 (cb5N, {lvl28_rawm_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:45.683908 UTC

sat_sazY_entry() //  [R1]
        { info_tbl: [(cb5E,
                      label: block_cb5E_info
                      rep:StackRep []),
                     (cb5H,
                      label: sat_sazY_info
                      rep:HeapRep 1 nonptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cb5H:
          _sazY::P64 = R1;
          if ((Sp + -24) < SpLim) goto cb5I; else goto cb5J;
      cb5J:
          if (HpLim == 0) goto cb5I; else goto cb5K;
      cb5I:
          R1 = _sazY::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      cb5K:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _sazY::P64;
          I64[Sp - 24] = cb5E;
          R4 = GHC.Types.[]_closure+1;
          R3 = I64[_sazY::P64 + 16];
          R2 = 0;
          Sp = Sp - 24;
          call GHC.Show.$wshowSignedInt_info(R4,
                                             R3,
                                             R2) returns to cb5E, args: 8, res: 8, upd: 24;
      cb5E:
          Hp = Hp + 24;
          if (Hp > HpLim) goto cb5N; else goto cb5M;
      cb5N:
          HpAlloc = 24;
          R2 = R2;
          R1 = R1;
          call stg_gc_pp(R2, R1) returns to cb5E, args: 8, res: 8, upd: 24;
      cb5M:
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = R1;
          P64[Hp] = R2;
          R3 = lvl28_rawm_closure;
          R2 = Hp - 14;
          Sp = Sp + 8;
          call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:45.685952 UTC

sat_sazY_entry() //  [R1]
        { info_tbl: [(cb5E,
                      label: block_cb5E_info
                      rep:StackRep []),
                     (cb5H,
                      label: sat_sazY_info
                      rep:HeapRep 1 nonptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cb5H:
          _sazY::P64 = R1;
          if ((Sp + -24) < SpLim) goto cb5I; else goto cb5J;
      cb5J:
          if (HpLim == 0) goto cb5I; else goto cb5K;
      cb5I:
          R1 = _sazY::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      cb5K:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _sazY::P64;
          I64[Sp - 24] = cb5E;
          R4 = GHC.Types.[]_closure+1;
          R3 = I64[_sazY::P64 + 16];
          R2 = 0;
          Sp = Sp - 24;
          call GHC.Show.$wshowSignedInt_info(R4,
                                             R3,
                                             R2) returns to cb5E, args: 8, res: 8, upd: 24;
      cb5E:
          Hp = Hp + 24;
          if (Hp > HpLim) goto cb5N; else goto cb5M;
      cb5N:
          HpAlloc = 24;
          R2 = R2;
          R1 = R1;
          call stg_gc_pp(R2, R1) returns to cb5E, args: 8, res: 8, upd: 24;
      cb5M:
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = R1;
          P64[Hp] = R2;
          R3 = lvl28_rawm_closure;
          R2 = Hp - 14;
          Sp = Sp + 8;
          call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:45.687994 UTC

{offset
  cb5P:
      _sazZ::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cb5Q; else goto cb5R;
  cb5R:
      Hp = Hp + 24;
      if (Hp > HpLim) goto cb5T; else goto cb5S;
  cb5T:
      HpAlloc = 24;
      goto cb5Q;
  cb5Q:
      R1 = _sazZ::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cb5S:
      _sazO::I64 = I64[_sazZ::P64 + 16];
      I64[Hp - 16] = sat_sazY_info;
      I64[Hp] = _sazO::I64;
      _cb5A::P64 = Hp - 16;
      R3 = _cb5A::P64;
      R2 = cb5O_str;
      call GHC.CString.unpackAppendCString#_info(R3,
                                                 R2) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:45.689898 UTC

{offset
  cb5P:
      _sazZ::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cb5Q; else goto cb5R;
  cb5R:
      Hp = Hp + 24;
      if (Hp > HpLim) goto cb5T; else goto cb5S;
  cb5T:
      HpAlloc = 24;
      goto cb5Q;
  cb5Q:
      R1 = _sazZ::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cb5S:
      _sazO::I64 = I64[_sazZ::P64 + 16];
      I64[Hp - 16] = sat_sazY_info;
      I64[Hp] = _sazO::I64;
      _cb5A::P64 = Hp - 16;
      R3 = _cb5A::P64;
      R2 = cb5O_str;
      call GHC.CString.unpackAppendCString#_info(R3,
                                                 R2) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:45.690947 UTC

{offset
  cb5P:
      _sazZ::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cb5Q; else goto cb5R;
  cb5R:
      Hp = Hp + 24;
      if (Hp > HpLim) goto cb5T; else goto cb5S;
  cb5T:
      HpAlloc = 24;
      goto cb5Q;
  cb5Q:
      R1 = _sazZ::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cb5S:
      _sazO::I64 = I64[_sazZ::P64 + 16];
      I64[Hp - 16] = sat_sazY_info;
      I64[Hp] = _sazO::I64;
      _cb5A::P64 = Hp - 16;
      R3 = _cb5A::P64;
      R2 = cb5O_str;
      call GHC.CString.unpackAppendCString#_info(R3,
                                                 R2) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:45.692048 UTC

{offset
  cb5P:
      _sazZ::P64 = R1;
      goto cb5R;
  cb5R:
      Hp = Hp + 24;
      if (Hp > HpLim) goto cb5T; else goto cb5S;
  cb5T:
      HpAlloc = 24;
      goto cb5Q;
  cb5Q:
      R1 = _sazZ::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cb5S:
      _sazO::I64 = I64[_sazZ::P64 + 16];
      I64[Hp - 16] = sat_sazY_info;
      I64[Hp] = _sazO::I64;
      _cb5A::P64 = Hp - 16;
      R3 = _cb5A::P64;
      R2 = cb5O_str;
      call GHC.CString.unpackAppendCString#_info(R3,
                                                 R2) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:45.693125 UTC

{offset
  cb5P:
      goto cb5R;
  cb5R:
      Hp = Hp + 24;
      if (Hp > HpLim) goto cb5T; else goto cb5S;
  cb5T:
      HpAlloc = 24;
      goto cb5Q;
  cb5Q:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cb5S:
      _sazO::I64 = I64[R1 + 16];
      I64[Hp - 16] = sat_sazY_info;
      I64[Hp] = _sazO::I64;
      R3 = Hp - 16;
      R2 = cb5O_str;
      call GHC.CString.unpackAppendCString#_info(R3,
                                                 R2) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:45.694189 UTC

[(cb5P, {sat_sazY_closure}), (cb5Q, {}),
 (cb5R, {sat_sazY_closure}), (cb5S, {sat_sazY_closure}), (cb5T, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:45.69462 UTC

sat_sazZ_entry() //  [R1]
        { info_tbl: [(cb5P,
                      label: sat_sazZ_info
                      rep:HeapRep 1 nonptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cb5P:
          goto cb5R;
      cb5R:
          Hp = Hp + 24;
          if (Hp > HpLim) goto cb5T; else goto cb5S;
      cb5T:
          HpAlloc = 24;
          goto cb5Q;
      cb5Q:
          R1 = R1;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      cb5S:
          _sazO::I64 = I64[R1 + 16];
          I64[Hp - 16] = sat_sazY_info;
          I64[Hp] = _sazO::I64;
          R3 = Hp - 16;
          R2 = cb5O_str;
          call GHC.CString.unpackAppendCString#_info(R3,
                                                     R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:45.695731 UTC

sat_sazZ_entry() //  [R1]
        { info_tbl: [(cb5P,
                      label: sat_sazZ_info
                      rep:HeapRep 1 nonptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cb5P:
          Hp = Hp + 24;
          if (Hp > HpLim) goto cb5T; else goto cb5S;
      cb5T:
          HpAlloc = 24;
          R1 = R1;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      cb5S:
          _sazO::I64 = I64[R1 + 16];
          I64[Hp - 16] = sat_sazY_info;
          I64[Hp] = _sazO::I64;
          R3 = Hp - 16;
          R2 = cb5O_str;
          call GHC.CString.unpackAppendCString#_info(R3,
                                                     R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:45.696785 UTC

{offset
  cb5V:
      _saA0::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cb5W; else goto cb5X;
  cb5X:
      if (HpLim == 0) goto cb5W; else goto cb5Y;
  cb5W:
      R1 = _saA0::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cb5Y:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _saA0::P64;
      _sazO::I64 = I64[_saA0::P64 + 16];
      _sazP::I64 = I64[_saA0::P64 + 24];
      I64[(young<cb5u> + 8)] = cb5u;
      R4 = GHC.Types.[]_closure+1;
      R3 = _sazP::I64;
      R2 = 0;
      call GHC.Show.$wshowSignedInt_info(R4,
                                         R3,
                                         R2) returns to cb5u, args: 8, res: 8, upd: 24;
  cb5u:
      _sazS::P64 = R2;
      _sazR::P64 = R1;
      Hp = Hp + 48;
      if (Hp > HpLim) goto cb61; else goto cb60;
  cb61:
      HpAlloc = 48;
      R2 = _sazS::P64;
      R1 = _sazR::P64;
      call stg_gc_pp(R2, R1) returns to cb5u, args: 8, res: 8, upd: 24;
  cb60:
      I64[Hp - 40] = sat_sazZ_info;
      I64[Hp - 24] = _sazO::I64;
      _cb5w::P64 = Hp - 40;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _sazR::P64;
      P64[Hp] = _sazS::P64;
      _cb5U::P64 = Hp - 14;
      R3 = _cb5w::P64;
      R2 = _cb5U::P64;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:45.698755 UTC

{offset
  cb5V:
      _saA0::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cb5W; else goto cb5X;
  cb5X:
      if (HpLim == 0) goto cb5W; else goto cb5Y;
  cb5W:
      R1 = _saA0::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cb5Y:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _saA0::P64;
      _sazO::I64 = I64[_saA0::P64 + 16];
      _sazP::I64 = I64[_saA0::P64 + 24];
      I64[(young<cb5u> + 8)] = cb5u;
      R4 = GHC.Types.[]_closure+1;
      R3 = _sazP::I64;
      R2 = 0;
      call GHC.Show.$wshowSignedInt_info(R4,
                                         R3,
                                         R2) returns to cb5u, args: 8, res: 8, upd: 24;
  cb5u:
      _sazS::P64 = R2;
      _sazR::P64 = R1;
      Hp = Hp + 48;
      if (Hp > HpLim) goto cb61; else goto cb60;
  cb61:
      HpAlloc = 48;
      R2 = _sazS::P64;
      R1 = _sazR::P64;
      call stg_gc_pp(R2, R1) returns to cb5u, args: 8, res: 8, upd: 24;
  cb60:
      I64[Hp - 40] = sat_sazZ_info;
      I64[Hp - 24] = _sazO::I64;
      _cb5w::P64 = Hp - 40;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _sazR::P64;
      P64[Hp] = _sazS::P64;
      _cb5U::P64 = Hp - 14;
      R3 = _cb5w::P64;
      R2 = _cb5U::P64;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:45.70073 UTC

{offset
  cb5V:
      _saA0::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cb5W; else goto cb5X;
  cb5X:
      if (HpLim == 0) goto cb5W; else goto cb5Y;
  cb5W:
      R1 = _saA0::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cb5Y:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _saA0::P64;
      _sazO::I64 = I64[_saA0::P64 + 16];
      _sazP::I64 = I64[_saA0::P64 + 24];
      I64[(young<cb5u> + 8)] = cb5u;
      R4 = GHC.Types.[]_closure+1;
      R3 = _sazP::I64;
      R2 = 0;
      call GHC.Show.$wshowSignedInt_info(R4,
                                         R3,
                                         R2) returns to cb5u, args: 8, res: 8, upd: 24;
  cb5u:
      _sazS::P64 = R2;
      _sazR::P64 = R1;
      Hp = Hp + 48;
      if (Hp > HpLim) goto cb61; else goto cb60;
  cb61:
      HpAlloc = 48;
      R2 = _sazS::P64;
      R1 = _sazR::P64;
      call stg_gc_pp(R2, R1) returns to cb5u, args: 8, res: 8, upd: 24;
  cb60:
      I64[Hp - 40] = sat_sazZ_info;
      I64[Hp - 24] = _sazO::I64;
      _cb5w::P64 = Hp - 40;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _sazR::P64;
      P64[Hp] = _sazS::P64;
      _cb5U::P64 = Hp - 14;
      R3 = _cb5w::P64;
      R2 = _cb5U::P64;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:45.702897 UTC

{offset
  cb5V:
      _saA0::P64 = R1;
      if ((Sp + 8) - 40 < SpLim) goto cb5W; else goto cb5X;
  cb5X:
      if (HpLim == 0) goto cb5W; else goto cb5Y;
  cb5W:
      R1 = _saA0::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cb5Y:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _saA0::P64;
      _sazO::I64 = I64[_saA0::P64 + 16];
      _sazP::I64 = I64[_saA0::P64 + 24];
      I64[Sp - 32] = cb5u;
      R4 = GHC.Types.[]_closure+1;
      R3 = _sazP::I64;
      R2 = 0;
      I64[Sp - 24] = _sazO::I64;
      Sp = Sp - 32;
      call GHC.Show.$wshowSignedInt_info(R4,
                                         R3,
                                         R2) returns to cb5u, args: 8, res: 8, upd: 24;
  cb5u:
      _sazO::I64 = I64[Sp + 8];
      _sazS::P64 = R2;
      _sazR::P64 = R1;
      Hp = Hp + 48;
      if (Hp > HpLim) goto cb61; else goto cb60;
  cb61:
      HpAlloc = 48;
      R2 = _sazS::P64;
      R1 = _sazR::P64;
      call stg_gc_pp(R2, R1) returns to cb5u, args: 8, res: 8, upd: 24;
  cb60:
      I64[Hp - 40] = sat_sazZ_info;
      I64[Hp - 24] = _sazO::I64;
      _cb5w::P64 = Hp - 40;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _sazR::P64;
      P64[Hp] = _sazS::P64;
      _cb5U::P64 = Hp - 14;
      R3 = _cb5w::P64;
      R2 = _cb5U::P64;
      Sp = Sp + 16;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:45.705067 UTC

{offset
  cb5V:
      _saA0::P64 = R1;
      if ((Sp + -32) < SpLim) goto cb5W; else goto cb5X;
  cb5X:
      if (HpLim == 0) goto cb5W; else goto cb5Y;
  cb5W:
      R1 = _saA0::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cb5Y:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _saA0::P64;
      I64[Sp - 32] = cb5u;
      R4 = GHC.Types.[]_closure+1;
      R3 = I64[_saA0::P64 + 24];
      R2 = 0;
      I64[Sp - 24] = I64[_saA0::P64 + 16];
      Sp = Sp - 32;
      call GHC.Show.$wshowSignedInt_info(R4,
                                         R3,
                                         R2) returns to cb5u, args: 8, res: 8, upd: 24;
  cb5u:
      Hp = Hp + 48;
      if (Hp > HpLim) goto cb61; else goto cb60;
  cb61:
      HpAlloc = 48;
      R2 = R2;
      R1 = R1;
      call stg_gc_pp(R2, R1) returns to cb5u, args: 8, res: 8, upd: 24;
  cb60:
      I64[Hp - 40] = sat_sazZ_info;
      I64[Hp - 24] = I64[Sp + 8];
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = R1;
      P64[Hp] = R2;
      R3 = Hp - 40;
      R2 = Hp - 14;
      Sp = Sp + 16;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:45.707277 UTC

[(cb5u, {sat_sazZ_closure}), (cb5V, {sat_sazZ_closure}),
 (cb5W, {}), (cb5X, {sat_sazZ_closure}), (cb5Y, {sat_sazZ_closure}),
 (cb60, {sat_sazZ_closure}), (cb61, {sat_sazZ_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:45.707858 UTC

sat_saA0_entry() //  [R1]
        { info_tbl: [(cb5u,
                      label: block_cb5u_info
                      rep:StackRep [True]),
                     (cb5V,
                      label: sat_saA0_info
                      rep:HeapRep 2 nonptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cb5V:
          _saA0::P64 = R1;
          if ((Sp + -32) < SpLim) goto cb5W; else goto cb5X;
      cb5X:
          if (HpLim == 0) goto cb5W; else goto cb5Y;
      cb5W:
          R1 = _saA0::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      cb5Y:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _saA0::P64;
          I64[Sp - 32] = cb5u;
          R4 = GHC.Types.[]_closure+1;
          R3 = I64[_saA0::P64 + 24];
          R2 = 0;
          I64[Sp - 24] = I64[_saA0::P64 + 16];
          Sp = Sp - 32;
          call GHC.Show.$wshowSignedInt_info(R4,
                                             R3,
                                             R2) returns to cb5u, args: 8, res: 8, upd: 24;
      cb5u:
          Hp = Hp + 48;
          if (Hp > HpLim) goto cb61; else goto cb60;
      cb61:
          HpAlloc = 48;
          R2 = R2;
          R1 = R1;
          call stg_gc_pp(R2, R1) returns to cb5u, args: 8, res: 8, upd: 24;
      cb60:
          I64[Hp - 40] = sat_sazZ_info;
          I64[Hp - 24] = I64[Sp + 8];
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = R1;
          P64[Hp] = R2;
          R3 = Hp - 40;
          R2 = Hp - 14;
          Sp = Sp + 16;
          call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:45.71011 UTC

sat_saA0_entry() //  [R1]
        { info_tbl: [(cb5u,
                      label: block_cb5u_info
                      rep:StackRep [True]),
                     (cb5V,
                      label: sat_saA0_info
                      rep:HeapRep 2 nonptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cb5V:
          _saA0::P64 = R1;
          if ((Sp + -32) < SpLim) goto cb5W; else goto cb5X;
      cb5X:
          if (HpLim == 0) goto cb5W; else goto cb5Y;
      cb5W:
          R1 = _saA0::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      cb5Y:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _saA0::P64;
          I64[Sp - 32] = cb5u;
          R4 = GHC.Types.[]_closure+1;
          R3 = I64[_saA0::P64 + 24];
          R2 = 0;
          I64[Sp - 24] = I64[_saA0::P64 + 16];
          Sp = Sp - 32;
          call GHC.Show.$wshowSignedInt_info(R4,
                                             R3,
                                             R2) returns to cb5u, args: 8, res: 8, upd: 24;
      cb5u:
          Hp = Hp + 48;
          if (Hp > HpLim) goto cb61; else goto cb60;
      cb61:
          HpAlloc = 48;
          R2 = R2;
          R1 = R1;
          call stg_gc_pp(R2, R1) returns to cb5u, args: 8, res: 8, upd: 24;
      cb60:
          I64[Hp - 40] = sat_sazZ_info;
          I64[Hp - 24] = I64[Sp + 8];
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = R1;
          P64[Hp] = R2;
          R3 = Hp - 40;
          R2 = Hp - 14;
          Sp = Sp + 16;
          call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:45.712352 UTC

{offset
  cb65:
      _sazP::I64 = R3;
      _sazO::I64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cb66; else goto cb67;
  cb67:
      Hp = Hp + 32;
      if (Hp > HpLim) goto cb69; else goto cb68;
  cb69:
      HpAlloc = 32;
      goto cb66;
  cb66:
      R3 = _sazP::I64;
      R2 = _sazO::I64;
      R1 = lvl29_rawn_closure;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  cb68:
      I64[Hp - 24] = sat_saA0_info;
      I64[Hp - 8] = _sazO::I64;
      I64[Hp] = _sazP::I64;
      _cb5q::P64 = Hp - 24;
      I64[(young<cb63> + 8)] = cb63;
      R3 = _cb5q::P64;
      R2 = cb62_str;
      call GHC.CString.unpackAppendCString#_info(R3,
                                                 R2) returns to cb63, args: 8, res: 8, upd: 8;
  cb63:
      _saA1::P64 = R1;
      R3 = _saA1::P64;
      R2 = lvl27_rawl_closure+1;
      call GHC.Err.error_info(R3, R2) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:45.713814 UTC

{offset
  cb65:
      _sazP::I64 = R3;
      _sazO::I64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cb66; else goto cb67;
  cb67:
      Hp = Hp + 32;
      if (Hp > HpLim) goto cb69; else goto cb68;
  cb69:
      HpAlloc = 32;
      goto cb66;
  cb66:
      R3 = _sazP::I64;
      R2 = _sazO::I64;
      R1 = lvl29_rawn_closure;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  cb68:
      I64[Hp - 24] = sat_saA0_info;
      I64[Hp - 8] = _sazO::I64;
      I64[Hp] = _sazP::I64;
      _cb5q::P64 = Hp - 24;
      I64[(young<cb63> + 8)] = cb63;
      R3 = _cb5q::P64;
      R2 = cb62_str;
      call GHC.CString.unpackAppendCString#_info(R3,
                                                 R2) returns to cb63, args: 8, res: 8, upd: 8;
  cb63:
      _saA1::P64 = R1;
      R3 = _saA1::P64;
      R2 = lvl27_rawl_closure+1;
      call GHC.Err.error_info(R3, R2) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:45.715281 UTC

{offset
  cb65:
      _sazP::I64 = R3;
      _sazO::I64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cb66; else goto cb67;
  cb67:
      Hp = Hp + 32;
      if (Hp > HpLim) goto cb69; else goto cb68;
  cb69:
      HpAlloc = 32;
      goto cb66;
  cb66:
      R3 = _sazP::I64;
      R2 = _sazO::I64;
      R1 = lvl29_rawn_closure;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  cb68:
      I64[Hp - 24] = sat_saA0_info;
      I64[Hp - 8] = _sazO::I64;
      I64[Hp] = _sazP::I64;
      _cb5q::P64 = Hp - 24;
      I64[(young<cb63> + 8)] = cb63;
      R3 = _cb5q::P64;
      R2 = cb62_str;
      call GHC.CString.unpackAppendCString#_info(R3,
                                                 R2) returns to cb63, args: 8, res: 8, upd: 8;
  cb63:
      _saA1::P64 = R1;
      R3 = _saA1::P64;
      R2 = lvl27_rawl_closure+1;
      call GHC.Err.error_info(R3, R2) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:45.716876 UTC

{offset
  cb65:
      _sazP::I64 = R3;
      _sazO::I64 = R2;
      if ((Sp + 8) - 16 < SpLim) goto cb66; else goto cb67;
  cb67:
      Hp = Hp + 32;
      if (Hp > HpLim) goto cb69; else goto cb68;
  cb69:
      HpAlloc = 32;
      goto cb66;
  cb66:
      R3 = _sazP::I64;
      R2 = _sazO::I64;
      R1 = lvl29_rawn_closure;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  cb68:
      I64[Hp - 24] = sat_saA0_info;
      I64[Hp - 8] = _sazO::I64;
      I64[Hp] = _sazP::I64;
      _cb5q::P64 = Hp - 24;
      I64[Sp - 8] = cb63;
      R3 = _cb5q::P64;
      R2 = cb62_str;
      Sp = Sp - 8;
      call GHC.CString.unpackAppendCString#_info(R3,
                                                 R2) returns to cb63, args: 8, res: 8, upd: 8;
  cb63:
      _saA1::P64 = R1;
      R3 = _saA1::P64;
      R2 = lvl27_rawl_closure+1;
      Sp = Sp + 8;
      call GHC.Err.error_info(R3, R2) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:45.71841 UTC

{offset
  cb65:
      _sazP::I64 = R3;
      _sazO::I64 = R2;
      if ((Sp + -8) < SpLim) goto cb66; else goto cb67;
  cb67:
      Hp = Hp + 32;
      if (Hp > HpLim) goto cb69; else goto cb68;
  cb69:
      HpAlloc = 32;
      goto cb66;
  cb66:
      R3 = _sazP::I64;
      R2 = _sazO::I64;
      R1 = lvl29_rawn_closure;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  cb68:
      I64[Hp - 24] = sat_saA0_info;
      I64[Hp - 8] = _sazO::I64;
      I64[Hp] = _sazP::I64;
      I64[Sp - 8] = cb63;
      R3 = Hp - 24;
      R2 = cb62_str;
      Sp = Sp - 8;
      call GHC.CString.unpackAppendCString#_info(R3,
                                                 R2) returns to cb63, args: 8, res: 8, upd: 8;
  cb63:
      R3 = R1;
      R2 = lvl27_rawl_closure+1;
      Sp = Sp + 8;
      call GHC.Err.error_info(R3, R2) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:45.71997 UTC

[(cb63, {GHC.Err.error_closure, lvl27_rawl_closure}),
 (cb65,
  {GHC.Err.error_closure, lvl27_rawl_closure, lvl29_rawn_closure,
   sat_saA0_closure}),
 (cb66, {lvl29_rawn_closure}),
 (cb67,
  {GHC.Err.error_closure, lvl27_rawl_closure, lvl29_rawn_closure,
   sat_saA0_closure}),
 (cb68,
  {GHC.Err.error_closure, lvl27_rawl_closure, sat_saA0_closure}),
 (cb69, {lvl29_rawn_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:45.721405 UTC

lvl29_rawn_entry() //  [R3, R2]
        { info_tbl: [(cb63,
                      label: block_cb63_info
                      rep:StackRep []),
                     (cb65,
                      label: lvl29_rawn_info
                      rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cb65:
          _sazP::I64 = R3;
          _sazO::I64 = R2;
          if ((Sp + -8) < SpLim) goto cb66; else goto cb67;
      cb67:
          Hp = Hp + 32;
          if (Hp > HpLim) goto cb69; else goto cb68;
      cb69:
          HpAlloc = 32;
          goto cb66;
      cb66:
          R3 = _sazP::I64;
          R2 = _sazO::I64;
          R1 = lvl29_rawn_closure;
          call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
      cb68:
          I64[Hp - 24] = sat_saA0_info;
          I64[Hp - 8] = _sazO::I64;
          I64[Hp] = _sazP::I64;
          I64[Sp - 8] = cb63;
          R3 = Hp - 24;
          R2 = cb62_str;
          Sp = Sp - 8;
          call GHC.CString.unpackAppendCString#_info(R3,
                                                     R2) returns to cb63, args: 8, res: 8, upd: 8;
      cb63:
          R3 = R1;
          R2 = lvl27_rawl_closure+1;
          Sp = Sp + 8;
          call GHC.Err.error_info(R3, R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:45.723316 UTC

lvl29_rawn_entry() //  [R3, R2]
        { info_tbl: [(cb63,
                      label: block_cb63_info
                      rep:StackRep []),
                     (cb65,
                      label: lvl29_rawn_info
                      rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cb65:
          _sazP::I64 = R3;
          _sazO::I64 = R2;
          if ((Sp + -8) < SpLim) goto cb66; else goto cb67;
      cb67:
          Hp = Hp + 32;
          if (Hp > HpLim) goto cb69; else goto cb68;
      cb69:
          HpAlloc = 32;
          goto cb66;
      cb66:
          R3 = _sazP::I64;
          R2 = _sazO::I64;
          R1 = lvl29_rawn_closure;
          call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
      cb68:
          I64[Hp - 24] = sat_saA0_info;
          I64[Hp - 8] = _sazO::I64;
          I64[Hp] = _sazP::I64;
          I64[Sp - 8] = cb63;
          R3 = Hp - 24;
          R2 = cb62_str;
          Sp = Sp - 8;
          call GHC.CString.unpackAppendCString#_info(R3,
                                                     R2) returns to cb63, args: 8, res: 8, upd: 8;
      cb63:
          R3 = R1;
          R2 = lvl27_rawl_closure+1;
          Sp = Sp + 8;
          call GHC.Err.error_info(R3, R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:45.725135 UTC

[section "data" {
     lvl29_rawn_closure:
         const lvl29_rawn_info;
         const 0;
 },
 sat_sazY_entry() //  [R1]
         { info_tbl: [(cb5E,
                       label: block_cb5E_info
                       rep:StackRep []),
                      (cb5H,
                       label: sat_sazY_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cb5H:
           _sazY::P64 = R1;
           if ((Sp + -24) < SpLim) goto cb5I; else goto cb5J;
       cb5J:
           if (HpLim == 0) goto cb5I; else goto cb5K;
       cb5I:
           R1 = _sazY::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb5K:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sazY::P64;
           I64[Sp - 24] = cb5E;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[_sazY::P64 + 16];
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_info(R4,
                                              R3,
                                              R2) returns to cb5E, args: 8, res: 8, upd: 24;
       cb5E:
           Hp = Hp + 24;
           if (Hp > HpLim) goto cb5N; else goto cb5M;
       cb5N:
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) returns to cb5E, args: 8, res: 8, upd: 24;
       cb5M:
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = lvl28_rawm_closure;
           R2 = Hp - 14;
           Sp = Sp + 8;
           call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section "readonly" {
     cb5O_str:
         I8[] [32,110,111,116,32,105,110,32,114,97,110,103,101,32,91,48,46,46]
 },
 sat_sazZ_entry() //  [R1]
         { info_tbl: [(cb5P,
                       label: sat_sazZ_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cb5P:
           Hp = Hp + 24;
           if (Hp > HpLim) goto cb5T; else goto cb5S;
       cb5T:
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb5S:
           _sazO::I64 = I64[R1 + 16];
           I64[Hp - 16] = sat_sazY_info;
           I64[Hp] = _sazO::I64;
           R3 = Hp - 16;
           R2 = cb5O_str;
           call GHC.CString.unpackAppendCString#_info(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_saA0_entry() //  [R1]
         { info_tbl: [(cb5u,
                       label: block_cb5u_info
                       rep:StackRep [True]),
                      (cb5V,
                       label: sat_saA0_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cb5V:
           _saA0::P64 = R1;
           if ((Sp + -32) < SpLim) goto cb5W; else goto cb5X;
       cb5X:
           if (HpLim == 0) goto cb5W; else goto cb5Y;
       cb5W:
           R1 = _saA0::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb5Y:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _saA0::P64;
           I64[Sp - 32] = cb5u;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[_saA0::P64 + 24];
           R2 = 0;
           I64[Sp - 24] = I64[_saA0::P64 + 16];
           Sp = Sp - 32;
           call GHC.Show.$wshowSignedInt_info(R4,
                                              R3,
                                              R2) returns to cb5u, args: 8, res: 8, upd: 24;
       cb5u:
           Hp = Hp + 48;
           if (Hp > HpLim) goto cb61; else goto cb60;
       cb61:
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) returns to cb5u, args: 8, res: 8, upd: 24;
       cb60:
           I64[Hp - 40] = sat_sazZ_info;
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 14;
           Sp = Sp + 16;
           call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section "readonly" {
     cb62_str:
         I8[] [69,114,114,111,114,32,105,110,32,97,114,114,97,121,32,105,110,100,101,120,59,32]
 },
 lvl29_rawn_entry() //  [R3, R2]
         { info_tbl: [(cb63,
                       label: block_cb63_info
                       rep:StackRep []),
                      (cb65,
                       label: lvl29_rawn_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cb65:
           _sazP::I64 = R3;
           _sazO::I64 = R2;
           if ((Sp + -8) < SpLim) goto cb66; else goto cb67;
       cb67:
           Hp = Hp + 32;
           if (Hp > HpLim) goto cb69; else goto cb68;
       cb69:
           HpAlloc = 32;
           goto cb66;
       cb66:
           R3 = _sazP::I64;
           R2 = _sazO::I64;
           R1 = lvl29_rawn_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb68:
           I64[Hp - 24] = sat_saA0_info;
           I64[Hp - 8] = _sazO::I64;
           I64[Hp] = _sazP::I64;
           I64[Sp - 8] = cb63;
           R3 = Hp - 24;
           R2 = cb62_str;
           Sp = Sp - 8;
           call GHC.CString.unpackAppendCString#_info(R3,
                                                      R2) returns to cb63, args: 8, res: 8, upd: 8;
       cb63:
           R3 = R1;
           R2 = lvl27_rawl_closure+1;
           Sp = Sp + 8;
           call GHC.Err.error_info(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:45.732682 UTC

[section "data" {
     lvl29_rawn_closure:
         const lvl29_rawn_info;
         const 0;
 },
 sat_sazY_entry() //  [R1]
         { info_tbl: [(cb5E,
                       label: block_cb5E_info
                       rep:StackRep []),
                      (cb5H,
                       label: sat_sazY_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cb5H:
           _sazY::P64 = R1;
           if ((Sp + -24) < SpLim) goto cb5I; else goto cb5J;
       cb5J:
           if (HpLim == 0) goto cb5I; else goto cb5K;
       cb5I:
           R1 = _sazY::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb5K:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sazY::P64;
           I64[Sp - 24] = cb5E;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[_sazY::P64 + 16];
           R2 = 0;
           Sp = Sp - 24;
           call GHC.Show.$wshowSignedInt_info(R4,
                                              R3,
                                              R2) returns to cb5E, args: 8, res: 8, upd: 24;
       cb5E:
           Hp = Hp + 24;
           if (Hp > HpLim) goto cb5N; else goto cb5M;
       cb5N:
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) returns to cb5E, args: 8, res: 8, upd: 24;
       cb5M:
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = lvl28_rawm_closure;
           R2 = Hp - 14;
           Sp = Sp + 8;
           call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section "readonly" {
     cb5O_str:
         I8[] [32,110,111,116,32,105,110,32,114,97,110,103,101,32,91,48,46,46]
 },
 sat_sazZ_entry() //  [R1]
         { info_tbl: [(cb5P,
                       label: sat_sazZ_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cb5P:
           Hp = Hp + 24;
           if (Hp > HpLim) goto cb5T; else goto cb5S;
       cb5T:
           HpAlloc = 24;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb5S:
           _sazO::I64 = I64[R1 + 16];
           I64[Hp - 16] = sat_sazY_info;
           I64[Hp] = _sazO::I64;
           R3 = Hp - 16;
           R2 = cb5O_str;
           call GHC.CString.unpackAppendCString#_info(R3,
                                                      R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_saA0_entry() //  [R1]
         { info_tbl: [(cb5u,
                       label: block_cb5u_info
                       rep:StackRep [True]),
                      (cb5V,
                       label: sat_saA0_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cb5V:
           _saA0::P64 = R1;
           if ((Sp + -32) < SpLim) goto cb5W; else goto cb5X;
       cb5X:
           if (HpLim == 0) goto cb5W; else goto cb5Y;
       cb5W:
           R1 = _saA0::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cb5Y:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _saA0::P64;
           I64[Sp - 32] = cb5u;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[_saA0::P64 + 24];
           R2 = 0;
           I64[Sp - 24] = I64[_saA0::P64 + 16];
           Sp = Sp - 32;
           call GHC.Show.$wshowSignedInt_info(R4,
                                              R3,
                                              R2) returns to cb5u, args: 8, res: 8, upd: 24;
       cb5u:
           Hp = Hp + 48;
           if (Hp > HpLim) goto cb61; else goto cb60;
       cb61:
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) returns to cb5u, args: 8, res: 8, upd: 24;
       cb60:
           I64[Hp - 40] = sat_sazZ_info;
           I64[Hp - 24] = I64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = Hp - 40;
           R2 = Hp - 14;
           Sp = Sp + 16;
           call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 section "readonly" {
     cb62_str:
         I8[] [69,114,114,111,114,32,105,110,32,97,114,114,97,121,32,105,110,100,101,120,59,32]
 },
 lvl29_rawn_entry() //  [R3, R2]
         { info_tbl: [(cb63,
                       label: block_cb63_info
                       rep:StackRep []),
                      (cb65,
                       label: lvl29_rawn_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cb65:
           _sazP::I64 = R3;
           _sazO::I64 = R2;
           if ((Sp + -8) < SpLim) goto cb66; else goto cb67;
       cb67:
           Hp = Hp + 32;
           if (Hp > HpLim) goto cb69; else goto cb68;
       cb69:
           HpAlloc = 32;
           goto cb66;
       cb66:
           R3 = _sazP::I64;
           R2 = _sazO::I64;
           R1 = lvl29_rawn_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cb68:
           I64[Hp - 24] = sat_saA0_info;
           I64[Hp - 8] = _sazO::I64;
           I64[Hp] = _sazP::I64;
           I64[Sp - 8] = cb63;
           R3 = Hp - 24;
           R2 = cb62_str;
           Sp = Sp - 8;
           call GHC.CString.unpackAppendCString#_info(R3,
                                                      R2) returns to cb63, args: 8, res: 8, upd: 8;
       cb63:
           R3 = R1;
           R2 = lvl27_rawl_closure+1;
           Sp = Sp + 8;
           call GHC.Err.error_info(R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:45.752827 UTC

[section "data" {
     SkipList.$wa3_closure:
         const SkipList.$wa3_info;
         const 0;
 },
 SkipList.$wa3_entry() //  [R5, R4, R3, R2]
         { info_tbl: [(cb8S,
                       label: SkipList.$wa3_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cb8S:
           _saA5::P64 = R5;
           _saA4::P64 = R4;
           _saA3::P64 = R3;
           _saA2::P64 = R2;
           goto cb8L;
       cb8L:
           if ((old + 0) - <highSp> < SpLim) goto cb8T; else goto cb8U;
       cb8U:
           goto cb8K;
       cb8K:
           if (HpLim == 0) goto cb8T; else goto cb8V;
       cb8T:
           R5 = _saA5::P64;
           R4 = _saA4::P64;
           R3 = _saA3::P64;
           R2 = _saA2::P64;
           R1 = SkipList.$wa3_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb8V:
           I64[(young<cb8N> + 8)] = cb8N;
           R1 = _saA4::P64;
           call stg_norec_readTVar#(R1) returns to cb8N, args: 8, res: 8, upd: 8;
       cb8N:
           _saA9::P64 = R1;
           I64[(young<cb8P> + 8)] = cb8P;
           R1 = _saA9::P64;
           if (R1 & 7 != 0) goto cb8P; else goto cb8Q;
       cb8Q:
           call (I64[R1])(R1) returns to cb8P, args: 8, res: 8, upd: 8;
       cb8P:
           _saAa::P64 = R1;
           _saAb::I64 = I64[_saAa::P64 + 7];
           _saAY::P64 = _saA3::P64;
           _saAX::I64 = _saAb::I64;
           goto saAd;
       saAd:
           goto cb92;
       cb92:
           if (HpLim == 0) goto cb95; else goto cbaZ;
       cb95:
           I64[(young<cb93> + 8)] = cb93;
           call stg_gc_noregs() returns to cb93, args: 8, res: 8, upd: 8;
       cb93:
           goto cb92;
       cbaZ:
           _saB0::I64 = _saAX::I64;
           switch [-9223372036854775808 .. 9223372036854775807] _saB0::I64 {
               case 0 : goto cbaY;
               default: goto cb9k;
           }
       cbaY:
           R1 = GHC.Base.Nothing_closure+1;
           call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
       cb9k:
           I64[(young<cb98> + 8)] = cb98;
           R1 = _saAY::P64;
           if (R1 & 7 != 0) goto cb98; else goto cb99;
       cb99:
           call (I64[R1])(R1) returns to cb98, args: 8, res: 8, upd: 8;
       cb98:
           _saB1::P64 = R1;
           _saB2::P64 = P64[_saB1::P64 + 7];
           _saB3::P64 = P64[_saB1::P64 + 15];
           _saB5::P64 = P64[_saB1::P64 + 23];
           _saB4::I64 = I64[_saB1::P64 + 31];
           I64[(young<cb9d> + 8)] = cb9d;
           R1 = _saB2::P64;
           if (R1 & 7 != 0) goto cb9d; else goto cb9e;
       cb9e:
           call (I64[R1])(R1) returns to cb9d, args: 8, res: 8, upd: 8;
       cb9d:
           _saB6::P64 = R1;
           _saB7::I64 = I64[_saB6::P64 + 7];
           I64[(young<cb9i> + 8)] = cb9i;
           R1 = _saB3::P64;
           if (R1 & 7 != 0) goto cb9i; else goto cb9n;
       cb9n:
           call (I64[R1])(R1) returns to cb9i, args: 8, res: 8, upd: 8;
       cb9i:
           _saB8::P64 = R1;
           _saB9::I64 = I64[_saB8::P64 + 7];
           _cb9s::I64 = %MO_S_Le_W64(_saB7::I64, _saB0::I64);
           _saBa::I64 = _cb9s::I64;
           switch [0 .. 1] _saBa::I64 {
               case 0 : goto cb9x;
               case 1 : goto cbaX;
           }
       cbaX:
           _cb9A::I64 = %MO_S_Le_W64(_saB0::I64, _saB9::I64);
           _saBd::I64 = _cb9A::I64;
           switch [0 .. 1] _saBd::I64 {
               case 0 : goto cb9F;
               case 1 : goto cbaW;
           }
       cbaW:
           _cb9I::I64 = _saB0::I64 - _saB7::I64;
           _saBg::I64 = _cb9I::I64;
           _cb9L::I64 = %MO_S_Le_W64(0, _saBg::I64);
           _saBh::I64 = _cb9L::I64;
           switch [0 .. 1] _saBh::I64 {
               case 0 : goto cb9Q;
               case 1 : goto cbaV;
           }
       cbaV:
           _cb9T::I64 = %MO_S_Lt_W64(_saBg::I64, _saB4::I64);
           _saBk::I64 = _cb9T::I64;
           switch [0 .. 1] _saBk::I64 {
               case 0 : goto cb9Y;
               case 1 : goto cba2;
           }
       cba2:
           _saBo::P64 = P64[(_saB5::P64 + 24) + (_saBg::I64 << 3)];
           _saBo::P64 = _saBo::P64;
           I64[(young<cba1> + 8)] = cba1;
           R1 = _saBo::P64;
           if (R1 & 7 != 0) goto cba1; else goto cba3;
       cba3:
           call (I64[R1])(R1) returns to cba1, args: 8, res: 8, upd: 8;
       cba1:
           _saBp::P64 = R1;
           _saBq::P64 = P64[_saBp::P64 + 7];
           I64[(young<cba7> + 8)] = cba7;
           R1 = _saBq::P64;
           call stg_norec_readTVar#(R1) returns to cba7, args: 8, res: 8, upd: 8;
       cba7:
           _saBt::P64 = R1;
           I64[(young<cba9> + 8)] = cba9;
           R1 = _saBt::P64;
           if (R1 & 7 != 0) goto cba9; else goto cbac;
       cbac:
           call (I64[R1])(R1) returns to cba9, args: 8, res: 8, upd: 8;
       cba9:
           _saBu::P64 = R1;
           _cbcM::P64 = _saBu::P64 & 7;
           switch [1 .. 2] _cbcM::P64 {
               case 1 : goto cbai;
               case 2 : goto cban;
           }
       cban:
           _saBw::P64 = P64[_saBu::P64 + 6];
           _saBx::P64 = P64[_saBu::P64 + 14];
           _saBy::P64 = P64[_saBu::P64 + 22];
           I64[(young<cbal> + 8)] = cbal;
           R2 = _saA2::P64;
           I64[(young<cbal> + 32)] = stg_ap_pp_info;
           P64[(young<cbal> + 24)] = _saBw::P64;
           P64[(young<cbal> + 16)] = _saA5::P64;
           call GHC.Classes.>_info(R2) returns to cbal, args: 32, res: 8, upd: 8;
       cbal:
           _saBz::P64 = R1;
           _cbcN::P64 = _saBz::P64 & 7;
           switch [1 .. 2] _cbcN::P64 {
               case 1 : goto cbau;
               case 2 : goto cbaU;
           }
       cbaU:
           _cbcO::I64 = _saB0::I64 - 1;
           _saBH::I64 = _cbcO::I64;
           _saAi::P64 = _saB5::P64;
           _saAh::I64 = _saB4::I64;
           _saAg::I64 = _saB9::I64;
           _saAf::I64 = _saB7::I64;
           _saAe::I64 = _saBH::I64;
           goto saAc;
       cbau:
           I64[(young<cbar> + 8)] = cbar;
           R2 = _saA2::P64;
           I64[(young<cbar> + 32)] = stg_ap_pp_info;
           P64[(young<cbar> + 24)] = _saBw::P64;
           P64[(young<cbar> + 16)] = _saA5::P64;
           call GHC.Classes.<_info(R2) returns to cbar, args: 32, res: 8, upd: 8;
       cbar:
           _saBA::P64 = R1;
           _cbcP::P64 = _saBA::P64 & 7;
           switch [1 .. 2] _cbcP::P64 {
               case 1 : goto cbaI;
               case 2 : goto cbaQ;
           }
       cbaQ:
           _saAY::P64 = _saBy::P64;
           _saAX::I64 = _saB0::I64;
           goto saAd;
       cbaI:
           I64[(young<cbay> + 8)] = cbay;
           R1 = _saBx::P64;
           if (R1 & 7 != 0) goto cbay; else goto cbaz;
       cbaz:
           call (I64[R1])(R1) returns to cbay, args: 8, res: 8, upd: 8;
       cbay:
           _saBB::P64 = R1;
           _saBC::P64 = P64[_saBB::P64 + 7];
           I64[(young<cbaD> + 8)] = cbaD;
           R1 = _saBC::P64;
           call stg_norec_readTVar#(R1) returns to cbaD, args: 8, res: 8, upd: 8;
       cbaD:
           _saBF::P64 = R1;
           Hp = Hp + 16;
           if (Hp > HpLim) goto cbaM; else goto cbaL;
       cbaM:
           HpAlloc = 16;
           goto cbaK;
       cbaK:
           R1 = _saBF::P64;
           call stg_gc_unpt_r1(R1) returns to cbaD, args: 8, res: 8, upd: 8;
       cbaL:
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _saBF::P64;
           _cbaF::P64 = Hp - 6;
           R1 = _cbaF::P64;
           call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
       cbai:
           _cbcQ::I64 = _saB0::I64 - 1;
           _saBv::I64 = _cbcQ::I64;
           _saAi::P64 = _saB5::P64;
           _saAh::I64 = _saB4::I64;
           _saAg::I64 = _saB9::I64;
           _saAf::I64 = _saB7::I64;
           _saAe::I64 = _saBv::I64;
           goto saAc;
       saAc:
           goto cbb1;
       cbb1:
           Hp = Hp + 32;
           if (Hp > HpLim) goto cbb6; else goto cbb5;
       cbb6:
           HpAlloc = 32;
           goto cbb4;
       cbb4:
           I64[(young<cbb2> + 8)] = cbb2;
           call stg_gc_noregs() returns to cbb2, args: 8, res: 8, upd: 8;
       cbb2:
           goto cbb1;
       cbb5:
           _saAk::I64 = _saAe::I64;
           switch [-9223372036854775808 .. 9223372036854775807] _saAk::I64 {
               case 0 : goto cbcL;
               default: goto cbcK;
           }
       cbcL:
           Hp = Hp - 32;
           R1 = GHC.Base.Nothing_closure+1;
           call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
       cbcK:
           _cbb9::I64 = %MO_S_Le_W64(_saAf::I64, _saAk::I64);
           _saAl::I64 = _cbb9::I64;
           switch [0 .. 1] _saAl::I64 {
               case 0 : goto cbbh;
               case 1 : goto cbcI;
           }
       cbcI:
           _cbbj::I64 = %MO_S_Le_W64(_saAk::I64, _saAg::I64);
           _saAq::I64 = _cbbj::I64;
           switch [0 .. 1] _saAq::I64 {
               case 0 : goto cbbr;
               case 1 : goto cbcH;
           }
       cbcH:
           _cbbt::I64 = _saAk::I64 - _saAf::I64;
           _saAv::I64 = _cbbt::I64;
           _cbbw::I64 = %MO_S_Le_W64(0, _saAv::I64);
           _saAw::I64 = _cbbw::I64;
           switch [0 .. 1] _saAw::I64 {
               case 0 : goto cbbB;
               case 1 : goto cbcG;
           }
       cbcG:
           _cbbE::I64 = %MO_S_Lt_W64(_saAv::I64, _saAh::I64);
           _saAz::I64 = _cbbE::I64;
           switch [0 .. 1] _saAz::I64 {
               case 0 : goto cbbJ;
               case 1 : goto cbbN;
           }
       cbbN:
           _saAD::P64 = P64[(_saAi::P64 + 24) + (_saAv::I64 << 3)];
           _saAD::P64 = _saAD::P64;
           Hp = Hp - 32;
           I64[(young<cbbM> + 8)] = cbbM;
           R1 = _saAD::P64;
           if (R1 & 7 != 0) goto cbbM; else goto cbbO;
       cbbO:
           call (I64[R1])(R1) returns to cbbM, args: 8, res: 8, upd: 8;
       cbbM:
           _saAE::P64 = R1;
           _saAF::P64 = P64[_saAE::P64 + 7];
           I64[(young<cbbS> + 8)] = cbbS;
           R1 = _saAF::P64;
           call stg_norec_readTVar#(R1) returns to cbbS, args: 8, res: 8, upd: 8;
       cbbS:
           _saAI::P64 = R1;
           I64[(young<cbbU> + 8)] = cbbU;
           R1 = _saAI::P64;
           if (R1 & 7 != 0) goto cbbU; else goto cbbX;
       cbbX:
           call (I64[R1])(R1) returns to cbbU, args: 8, res: 8, upd: 8;
       cbbU:
           _saAJ::P64 = R1;
           _cbcR::P64 = _saAJ::P64 & 7;
           switch [1 .. 2] _cbcR::P64 {
               case 1 : goto cbc3;
               case 2 : goto cbc8;
           }
       cbc8:
           _saAL::P64 = P64[_saAJ::P64 + 6];
           _saAM::P64 = P64[_saAJ::P64 + 14];
           _saAN::P64 = P64[_saAJ::P64 + 22];
           I64[(young<cbc6> + 8)] = cbc6;
           R2 = _saA2::P64;
           I64[(young<cbc6> + 32)] = stg_ap_pp_info;
           P64[(young<cbc6> + 24)] = _saAL::P64;
           P64[(young<cbc6> + 16)] = _saA5::P64;
           call GHC.Classes.>_info(R2) returns to cbc6, args: 32, res: 8, upd: 8;
       cbc6:
           _saAO::P64 = R1;
           _cbcS::P64 = _saAO::P64 & 7;
           switch [1 .. 2] _cbcS::P64 {
               case 1 : goto cbcf;
               case 2 : goto cbcF;
           }
       cbcF:
           _cbcT::I64 = _saAk::I64 - 1;
           _saAW::I64 = _cbcT::I64;
           _saAi::P64 = _saAi::P64;
           _saAh::I64 = _saAh::I64;
           _saAg::I64 = _saAg::I64;
           _saAf::I64 = _saAf::I64;
           _saAe::I64 = _saAW::I64;
           goto saAc;
       cbcf:
           I64[(young<cbcc> + 8)] = cbcc;
           R2 = _saA2::P64;
           I64[(young<cbcc> + 32)] = stg_ap_pp_info;
           P64[(young<cbcc> + 24)] = _saAL::P64;
           P64[(young<cbcc> + 16)] = _saA5::P64;
           call GHC.Classes.<_info(R2) returns to cbcc, args: 32, res: 8, upd: 8;
       cbcc:
           _saAP::P64 = R1;
           _cbcU::P64 = _saAP::P64 & 7;
           switch [1 .. 2] _cbcU::P64 {
               case 1 : goto cbct;
               case 2 : goto cbcB;
           }
       cbcB:
           _saAY::P64 = _saAN::P64;
           _saAX::I64 = _saAk::I64;
           goto saAd;
       cbct:
           I64[(young<cbcj> + 8)] = cbcj;
           R1 = _saAM::P64;
           if (R1 & 7 != 0) goto cbcj; else goto cbck;
       cbck:
           call (I64[R1])(R1) returns to cbcj, args: 8, res: 8, upd: 8;
       cbcj:
           _saAQ::P64 = R1;
           _saAR::P64 = P64[_saAQ::P64 + 7];
           I64[(young<cbco> + 8)] = cbco;
           R1 = _saAR::P64;
           call stg_norec_readTVar#(R1) returns to cbco, args: 8, res: 8, upd: 8;
       cbco:
           _saAU::P64 = R1;
           Hp = Hp + 16;
           if (Hp > HpLim) goto cbcx; else goto cbcw;
       cbcx:
           HpAlloc = 16;
           goto cbcv;
       cbcv:
           R1 = _saAU::P64;
           call stg_gc_unpt_r1(R1) returns to cbco, args: 8, res: 8, upd: 8;
       cbcw:
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = _saAU::P64;
           _cbcq::P64 = Hp - 6;
           R1 = _cbcq::P64;
           call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
       cbc3:
           _cbcV::I64 = _saAk::I64 - 1;
           _saAK::I64 = _cbcV::I64;
           _saAi::P64 = _saAi::P64;
           _saAh::I64 = _saAh::I64;
           _saAg::I64 = _saAg::I64;
           _saAf::I64 = _saAf::I64;
           _saAe::I64 = _saAK::I64;
           goto saAc;
       cbbJ:
           Hp = Hp - 32;
           R3 = _saAv::I64;
           R2 = _saAh::I64;
           call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
       cbbB:
           Hp = Hp - 32;
           R3 = _saAv::I64;
           R2 = _saAh::I64;
           call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
       cbbr:
           I64[Hp - 24] = GHC.Types.I#_con_info;
           I64[Hp - 16] = _saAg::I64;
           _cbbo::P64 = Hp - 23;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saAf::I64;
           _cbbp::P64 = Hp - 7;
           R4 = _cbbo::P64;
           R3 = _cbbp::P64;
           R2 = _saAk::I64;
           call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
       cbbh:
           I64[Hp - 24] = GHC.Types.I#_con_info;
           I64[Hp - 16] = _saAg::I64;
           _cbbe::P64 = Hp - 23;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saAf::I64;
           _cbbf::P64 = Hp - 7;
           R4 = _cbbe::P64;
           R3 = _cbbf::P64;
           R2 = _saAk::I64;
           call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
       cb9Y:
           R3 = _saBg::I64;
           R2 = _saB4::I64;
           call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
       cb9Q:
           R3 = _saBg::I64;
           R2 = _saB4::I64;
           call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
       cb9F:
           R4 = _saB8::P64;
           R3 = _saB6::P64;
           R2 = _saB0::I64;
           call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
       cb9x:
           R4 = _saB8::P64;
           R3 = _saB6::P64;
           R2 = _saB0::I64;
           call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:45.781579 UTC

{offset
  cb8S:
      _saA5::P64 = R5;
      _saA4::P64 = R4;
      _saA3::P64 = R3;
      _saA2::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cb8T; else goto cb8U;
  cb8U:
      if (HpLim == 0) goto cb8T; else goto cb8V;
  cb8T:
      R5 = _saA5::P64;
      R4 = _saA4::P64;
      R3 = _saA3::P64;
      R2 = _saA2::P64;
      R1 = SkipList.$wa3_closure;
      call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  cb8V:
      I64[(young<cb8N> + 8)] = cb8N;
      R1 = _saA4::P64;
      call stg_norec_readTVar#(R1) returns to cb8N, args: 8, res: 8, upd: 8;
  cb8N:
      _saA9::P64 = R1;
      I64[(young<cb8P> + 8)] = cb8P;
      R1 = _saA9::P64;
      if (R1 & 7 != 0) goto cb8P; else goto cb8Q;
  cb8Q:
      call (I64[R1])(R1) returns to cb8P, args: 8, res: 8, upd: 8;
  cb8P:
      _saAa::P64 = R1;
      _saAb::I64 = I64[_saAa::P64 + 7];
      _saAY::P64 = _saA3::P64;
      _saAX::I64 = _saAb::I64;
      goto cb92;
  cb92:
      if (HpLim == 0) goto cb95; else goto cbaZ;
  cb95:
      I64[(young<cb93> + 8)] = cb93;
      call stg_gc_noregs() returns to cb93, args: 8, res: 8, upd: 8;
  cb93:
      goto cb92;
  cbaZ:
      _saB0::I64 = _saAX::I64;
      switch [-9223372036854775808 .. 9223372036854775807] _saB0::I64 {
          case 0 : goto cbaY;
          default: goto cb9k;
      }
  cbaY:
      R1 = GHC.Base.Nothing_closure+1;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
  cb9k:
      I64[(young<cb98> + 8)] = cb98;
      R1 = _saAY::P64;
      if (R1 & 7 != 0) goto cb98; else goto cb99;
  cb99:
      call (I64[R1])(R1) returns to cb98, args: 8, res: 8, upd: 8;
  cb98:
      _saB1::P64 = R1;
      _saB2::P64 = P64[_saB1::P64 + 7];
      _saB3::P64 = P64[_saB1::P64 + 15];
      _saB5::P64 = P64[_saB1::P64 + 23];
      _saB4::I64 = I64[_saB1::P64 + 31];
      I64[(young<cb9d> + 8)] = cb9d;
      R1 = _saB2::P64;
      if (R1 & 7 != 0) goto cb9d; else goto cb9e;
  cb9e:
      call (I64[R1])(R1) returns to cb9d, args: 8, res: 8, upd: 8;
  cb9d:
      _saB6::P64 = R1;
      _saB7::I64 = I64[_saB6::P64 + 7];
      I64[(young<cb9i> + 8)] = cb9i;
      R1 = _saB3::P64;
      if (R1 & 7 != 0) goto cb9i; else goto cb9n;
  cb9n:
      call (I64[R1])(R1) returns to cb9i, args: 8, res: 8, upd: 8;
  cb9i:
      _saB8::P64 = R1;
      _saB9::I64 = I64[_saB8::P64 + 7];
      _cb9s::I64 = %MO_S_Le_W64(_saB7::I64, _saB0::I64);
      _saBa::I64 = _cb9s::I64;
      switch [0 .. 1] _saBa::I64 {
          case 0 : goto cb9x;
          case 1 : goto cbaX;
      }
  cbaX:
      _cb9A::I64 = %MO_S_Le_W64(_saB0::I64, _saB9::I64);
      _saBd::I64 = _cb9A::I64;
      switch [0 .. 1] _saBd::I64 {
          case 0 : goto cb9F;
          case 1 : goto cbaW;
      }
  cbaW:
      _cb9I::I64 = _saB0::I64 - _saB7::I64;
      _saBg::I64 = _cb9I::I64;
      _cb9L::I64 = %MO_S_Le_W64(0, _saBg::I64);
      _saBh::I64 = _cb9L::I64;
      switch [0 .. 1] _saBh::I64 {
          case 0 : goto cb9Q;
          case 1 : goto cbaV;
      }
  cbaV:
      _cb9T::I64 = %MO_S_Lt_W64(_saBg::I64, _saB4::I64);
      _saBk::I64 = _cb9T::I64;
      switch [0 .. 1] _saBk::I64 {
          case 0 : goto cb9Y;
          case 1 : goto cba2;
      }
  cba2:
      _saBo::P64 = P64[(_saB5::P64 + 24) + (_saBg::I64 << 3)];
      _saBo::P64 = _saBo::P64;
      I64[(young<cba1> + 8)] = cba1;
      R1 = _saBo::P64;
      if (R1 & 7 != 0) goto cba1; else goto cba3;
  cba3:
      call (I64[R1])(R1) returns to cba1, args: 8, res: 8, upd: 8;
  cba1:
      _saBp::P64 = R1;
      _saBq::P64 = P64[_saBp::P64 + 7];
      I64[(young<cba7> + 8)] = cba7;
      R1 = _saBq::P64;
      call stg_norec_readTVar#(R1) returns to cba7, args: 8, res: 8, upd: 8;
  cba7:
      _saBt::P64 = R1;
      I64[(young<cba9> + 8)] = cba9;
      R1 = _saBt::P64;
      if (R1 & 7 != 0) goto cba9; else goto cbac;
  cbac:
      call (I64[R1])(R1) returns to cba9, args: 8, res: 8, upd: 8;
  cba9:
      _saBu::P64 = R1;
      _cbcM::P64 = _saBu::P64 & 7;
      switch [1 .. 2] _cbcM::P64 {
          case 1 : goto cbai;
          case 2 : goto cban;
      }
  cban:
      _saBw::P64 = P64[_saBu::P64 + 6];
      _saBx::P64 = P64[_saBu::P64 + 14];
      _saBy::P64 = P64[_saBu::P64 + 22];
      I64[(young<cbal> + 8)] = cbal;
      R2 = _saA2::P64;
      I64[(young<cbal> + 32)] = stg_ap_pp_info;
      P64[(young<cbal> + 24)] = _saBw::P64;
      P64[(young<cbal> + 16)] = _saA5::P64;
      call GHC.Classes.>_info(R2) returns to cbal, args: 32, res: 8, upd: 8;
  cbal:
      _saBz::P64 = R1;
      _cbcN::P64 = _saBz::P64 & 7;
      switch [1 .. 2] _cbcN::P64 {
          case 1 : goto cbau;
          case 2 : goto cbaU;
      }
  cbaU:
      _cbcO::I64 = _saB0::I64 - 1;
      _saBH::I64 = _cbcO::I64;
      _saAi::P64 = _saB5::P64;
      _saAh::I64 = _saB4::I64;
      _saAg::I64 = _saB9::I64;
      _saAf::I64 = _saB7::I64;
      _saAe::I64 = _saBH::I64;
      goto cbb1;
  cbau:
      I64[(young<cbar> + 8)] = cbar;
      R2 = _saA2::P64;
      I64[(young<cbar> + 32)] = stg_ap_pp_info;
      P64[(young<cbar> + 24)] = _saBw::P64;
      P64[(young<cbar> + 16)] = _saA5::P64;
      call GHC.Classes.<_info(R2) returns to cbar, args: 32, res: 8, upd: 8;
  cbar:
      _saBA::P64 = R1;
      _cbcP::P64 = _saBA::P64 & 7;
      switch [1 .. 2] _cbcP::P64 {
          case 1 : goto cbaI;
          case 2 : goto cbaQ;
      }
  cbaQ:
      _saAY::P64 = _saBy::P64;
      _saAX::I64 = _saB0::I64;
      goto cb92;
  cbaI:
      I64[(young<cbay> + 8)] = cbay;
      R1 = _saBx::P64;
      if (R1 & 7 != 0) goto cbay; else goto cbaz;
  cbaz:
      call (I64[R1])(R1) returns to cbay, args: 8, res: 8, upd: 8;
  cbay:
      _saBB::P64 = R1;
      _saBC::P64 = P64[_saBB::P64 + 7];
      I64[(young<cbaD> + 8)] = cbaD;
      R1 = _saBC::P64;
      call stg_norec_readTVar#(R1) returns to cbaD, args: 8, res: 8, upd: 8;
  cbaD:
      _saBF::P64 = R1;
      Hp = Hp + 16;
      if (Hp > HpLim) goto cbaM; else goto cbaL;
  cbaM:
      HpAlloc = 16;
      R1 = _saBF::P64;
      call stg_gc_unpt_r1(R1) returns to cbaD, args: 8, res: 8, upd: 8;
  cbaL:
      I64[Hp - 8] = GHC.Base.Just_con_info;
      P64[Hp] = _saBF::P64;
      _cbaF::P64 = Hp - 6;
      R1 = _cbaF::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
  cbai:
      _cbcQ::I64 = _saB0::I64 - 1;
      _saBv::I64 = _cbcQ::I64;
      _saAi::P64 = _saB5::P64;
      _saAh::I64 = _saB4::I64;
      _saAg::I64 = _saB9::I64;
      _saAf::I64 = _saB7::I64;
      _saAe::I64 = _saBv::I64;
      goto cbb1;
  cbb1:
      Hp = Hp + 32;
      if (Hp > HpLim) goto cbb6; else goto cbb5;
  cbb6:
      HpAlloc = 32;
      I64[(young<cbb2> + 8)] = cbb2;
      call stg_gc_noregs() returns to cbb2, args: 8, res: 8, upd: 8;
  cbb2:
      goto cbb1;
  cbb5:
      _saAk::I64 = _saAe::I64;
      switch [-9223372036854775808 .. 9223372036854775807] _saAk::I64 {
          case 0 : goto cbcL;
          default: goto cbcK;
      }
  cbcL:
      Hp = Hp - 32;
      R1 = GHC.Base.Nothing_closure+1;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
  cbcK:
      _cbb9::I64 = %MO_S_Le_W64(_saAf::I64, _saAk::I64);
      _saAl::I64 = _cbb9::I64;
      switch [0 .. 1] _saAl::I64 {
          case 0 : goto cbbh;
          case 1 : goto cbcI;
      }
  cbcI:
      _cbbj::I64 = %MO_S_Le_W64(_saAk::I64, _saAg::I64);
      _saAq::I64 = _cbbj::I64;
      switch [0 .. 1] _saAq::I64 {
          case 0 : goto cbbr;
          case 1 : goto cbcH;
      }
  cbcH:
      _cbbt::I64 = _saAk::I64 - _saAf::I64;
      _saAv::I64 = _cbbt::I64;
      _cbbw::I64 = %MO_S_Le_W64(0, _saAv::I64);
      _saAw::I64 = _cbbw::I64;
      switch [0 .. 1] _saAw::I64 {
          case 0 : goto cbbB;
          case 1 : goto cbcG;
      }
  cbcG:
      _cbbE::I64 = %MO_S_Lt_W64(_saAv::I64, _saAh::I64);
      _saAz::I64 = _cbbE::I64;
      switch [0 .. 1] _saAz::I64 {
          case 0 : goto cbbJ;
          case 1 : goto cbbN;
      }
  cbbN:
      _saAD::P64 = P64[(_saAi::P64 + 24) + (_saAv::I64 << 3)];
      _saAD::P64 = _saAD::P64;
      Hp = Hp - 32;
      I64[(young<cbbM> + 8)] = cbbM;
      R1 = _saAD::P64;
      if (R1 & 7 != 0) goto cbbM; else goto cbbO;
  cbbO:
      call (I64[R1])(R1) returns to cbbM, args: 8, res: 8, upd: 8;
  cbbM:
      _saAE::P64 = R1;
      _saAF::P64 = P64[_saAE::P64 + 7];
      I64[(young<cbbS> + 8)] = cbbS;
      R1 = _saAF::P64;
      call stg_norec_readTVar#(R1) returns to cbbS, args: 8, res: 8, upd: 8;
  cbbS:
      _saAI::P64 = R1;
      I64[(young<cbbU> + 8)] = cbbU;
      R1 = _saAI::P64;
      if (R1 & 7 != 0) goto cbbU; else goto cbbX;
  cbbX:
      call (I64[R1])(R1) returns to cbbU, args: 8, res: 8, upd: 8;
  cbbU:
      _saAJ::P64 = R1;
      _cbcR::P64 = _saAJ::P64 & 7;
      switch [1 .. 2] _cbcR::P64 {
          case 1 : goto cbc3;
          case 2 : goto cbc8;
      }
  cbc8:
      _saAL::P64 = P64[_saAJ::P64 + 6];
      _saAM::P64 = P64[_saAJ::P64 + 14];
      _saAN::P64 = P64[_saAJ::P64 + 22];
      I64[(young<cbc6> + 8)] = cbc6;
      R2 = _saA2::P64;
      I64[(young<cbc6> + 32)] = stg_ap_pp_info;
      P64[(young<cbc6> + 24)] = _saAL::P64;
      P64[(young<cbc6> + 16)] = _saA5::P64;
      call GHC.Classes.>_info(R2) returns to cbc6, args: 32, res: 8, upd: 8;
  cbc6:
      _saAO::P64 = R1;
      _cbcS::P64 = _saAO::P64 & 7;
      switch [1 .. 2] _cbcS::P64 {
          case 1 : goto cbcf;
          case 2 : goto cbcF;
      }
  cbcF:
      _cbcT::I64 = _saAk::I64 - 1;
      _saAW::I64 = _cbcT::I64;
      _saAi::P64 = _saAi::P64;
      _saAh::I64 = _saAh::I64;
      _saAg::I64 = _saAg::I64;
      _saAf::I64 = _saAf::I64;
      _saAe::I64 = _saAW::I64;
      goto cbb1;
  cbcf:
      I64[(young<cbcc> + 8)] = cbcc;
      R2 = _saA2::P64;
      I64[(young<cbcc> + 32)] = stg_ap_pp_info;
      P64[(young<cbcc> + 24)] = _saAL::P64;
      P64[(young<cbcc> + 16)] = _saA5::P64;
      call GHC.Classes.<_info(R2) returns to cbcc, args: 32, res: 8, upd: 8;
  cbcc:
      _saAP::P64 = R1;
      _cbcU::P64 = _saAP::P64 & 7;
      switch [1 .. 2] _cbcU::P64 {
          case 1 : goto cbct;
          case 2 : goto cbcB;
      }
  cbcB:
      _saAY::P64 = _saAN::P64;
      _saAX::I64 = _saAk::I64;
      goto cb92;
  cbct:
      I64[(young<cbcj> + 8)] = cbcj;
      R1 = _saAM::P64;
      if (R1 & 7 != 0) goto cbcj; else goto cbck;
  cbck:
      call (I64[R1])(R1) returns to cbcj, args: 8, res: 8, upd: 8;
  cbcj:
      _saAQ::P64 = R1;
      _saAR::P64 = P64[_saAQ::P64 + 7];
      I64[(young<cbco> + 8)] = cbco;
      R1 = _saAR::P64;
      call stg_norec_readTVar#(R1) returns to cbco, args: 8, res: 8, upd: 8;
  cbco:
      _saAU::P64 = R1;
      Hp = Hp + 16;
      if (Hp > HpLim) goto cbcx; else goto cbcw;
  cbcx:
      HpAlloc = 16;
      R1 = _saAU::P64;
      call stg_gc_unpt_r1(R1) returns to cbco, args: 8, res: 8, upd: 8;
  cbcw:
      I64[Hp - 8] = GHC.Base.Just_con_info;
      P64[Hp] = _saAU::P64;
      _cbcq::P64 = Hp - 6;
      R1 = _cbcq::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
  cbc3:
      _cbcV::I64 = _saAk::I64 - 1;
      _saAK::I64 = _cbcV::I64;
      _saAi::P64 = _saAi::P64;
      _saAh::I64 = _saAh::I64;
      _saAg::I64 = _saAg::I64;
      _saAf::I64 = _saAf::I64;
      _saAe::I64 = _saAK::I64;
      goto cbb1;
  cbbJ:
      Hp = Hp - 32;
      R3 = _saAv::I64;
      R2 = _saAh::I64;
      call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
  cbbB:
      Hp = Hp - 32;
      R3 = _saAv::I64;
      R2 = _saAh::I64;
      call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
  cbbr:
      I64[Hp - 24] = GHC.Types.I#_con_info;
      I64[Hp - 16] = _saAg::I64;
      _cbbo::P64 = Hp - 23;
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _saAf::I64;
      _cbbp::P64 = Hp - 7;
      R4 = _cbbo::P64;
      R3 = _cbbp::P64;
      R2 = _saAk::I64;
      call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbbh:
      I64[Hp - 24] = GHC.Types.I#_con_info;
      I64[Hp - 16] = _saAg::I64;
      _cbbe::P64 = Hp - 23;
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _saAf::I64;
      _cbbf::P64 = Hp - 7;
      R4 = _cbbe::P64;
      R3 = _cbbf::P64;
      R2 = _saAk::I64;
      call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cb9Y:
      R3 = _saBg::I64;
      R2 = _saB4::I64;
      call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
  cb9Q:
      R3 = _saBg::I64;
      R2 = _saB4::I64;
      call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
  cb9F:
      R4 = _saB8::P64;
      R3 = _saB6::P64;
      R2 = _saB0::I64;
      call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cb9x:
      R4 = _saB8::P64;
      R3 = _saB6::P64;
      R2 = _saB0::I64;
      call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:45.801442 UTC

{offset
  cb8S:
      _saA5::P64 = R5;
      _saA4::P64 = R4;
      _saA3::P64 = R3;
      _saA2::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cb8T; else goto cb8U;
  cb8U:
      if (HpLim == 0) goto cb8T; else goto cb8V;
  cb8T:
      R5 = _saA5::P64;
      R4 = _saA4::P64;
      R3 = _saA3::P64;
      R2 = _saA2::P64;
      R1 = SkipList.$wa3_closure;
      call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  cb8V:
      I64[(young<cb8N> + 8)] = cb8N;
      R1 = _saA4::P64;
      call stg_norec_readTVar#(R1) returns to cb8N, args: 8, res: 8, upd: 8;
  cb8N:
      _saA9::P64 = R1;
      I64[(young<cb8P> + 8)] = cb8P;
      R1 = _saA9::P64;
      if (R1 & 7 != 0) goto cb8P; else goto cb8Q;
  cb8Q:
      call (I64[R1])(R1) returns to cb8P, args: 8, res: 8, upd: 8;
  cb8P:
      _saAa::P64 = R1;
      _saAb::I64 = I64[_saAa::P64 + 7];
      _saAY::P64 = _saA3::P64;
      _saAX::I64 = _saAb::I64;
      goto cb92;
  cb92:
      if (HpLim == 0) goto cb95; else goto cbaZ;
  cb95:
      I64[(young<cb93> + 8)] = cb93;
      call stg_gc_noregs() returns to cb93, args: 8, res: 8, upd: 8;
  cb93:
      goto cb92;
  cbaZ:
      _saB0::I64 = _saAX::I64;
      switch [-9223372036854775808 .. 9223372036854775807] _saB0::I64 {
          case 0 : goto cbaY;
          default: goto cb9k;
      }
  cbaY:
      R1 = GHC.Base.Nothing_closure+1;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
  cb9k:
      I64[(young<cb98> + 8)] = cb98;
      R1 = _saAY::P64;
      if (R1 & 7 != 0) goto cb98; else goto cb99;
  cb99:
      call (I64[R1])(R1) returns to cb98, args: 8, res: 8, upd: 8;
  cb98:
      _saB1::P64 = R1;
      _saB2::P64 = P64[_saB1::P64 + 7];
      _saB3::P64 = P64[_saB1::P64 + 15];
      _saB5::P64 = P64[_saB1::P64 + 23];
      _saB4::I64 = I64[_saB1::P64 + 31];
      I64[(young<cb9d> + 8)] = cb9d;
      R1 = _saB2::P64;
      if (R1 & 7 != 0) goto cb9d; else goto cb9e;
  cb9e:
      call (I64[R1])(R1) returns to cb9d, args: 8, res: 8, upd: 8;
  cb9d:
      _saB6::P64 = R1;
      _saB7::I64 = I64[_saB6::P64 + 7];
      I64[(young<cb9i> + 8)] = cb9i;
      R1 = _saB3::P64;
      if (R1 & 7 != 0) goto cb9i; else goto cb9n;
  cb9n:
      call (I64[R1])(R1) returns to cb9i, args: 8, res: 8, upd: 8;
  cb9i:
      _saB8::P64 = R1;
      _saB9::I64 = I64[_saB8::P64 + 7];
      _cb9s::I64 = %MO_S_Le_W64(_saB7::I64, _saB0::I64);
      _saBa::I64 = _cb9s::I64;
      switch [0 .. 1] _saBa::I64 {
          case 0 : goto cb9F;
          case 1 : goto cbaX;
      }
  cbaX:
      _cb9A::I64 = %MO_S_Le_W64(_saB0::I64, _saB9::I64);
      _saBd::I64 = _cb9A::I64;
      switch [0 .. 1] _saBd::I64 {
          case 0 : goto cb9F;
          case 1 : goto cbaW;
      }
  cbaW:
      _cb9I::I64 = _saB0::I64 - _saB7::I64;
      _saBg::I64 = _cb9I::I64;
      _cb9L::I64 = %MO_S_Le_W64(0, _saBg::I64);
      _saBh::I64 = _cb9L::I64;
      switch [0 .. 1] _saBh::I64 {
          case 0 : goto cb9Y;
          case 1 : goto cbaV;
      }
  cbaV:
      _cb9T::I64 = %MO_S_Lt_W64(_saBg::I64, _saB4::I64);
      _saBk::I64 = _cb9T::I64;
      switch [0 .. 1] _saBk::I64 {
          case 0 : goto cb9Y;
          case 1 : goto cba2;
      }
  cba2:
      _saBo::P64 = P64[(_saB5::P64 + 24) + (_saBg::I64 << 3)];
      _saBo::P64 = _saBo::P64;
      I64[(young<cba1> + 8)] = cba1;
      R1 = _saBo::P64;
      if (R1 & 7 != 0) goto cba1; else goto cba3;
  cba3:
      call (I64[R1])(R1) returns to cba1, args: 8, res: 8, upd: 8;
  cba1:
      _saBp::P64 = R1;
      _saBq::P64 = P64[_saBp::P64 + 7];
      I64[(young<cba7> + 8)] = cba7;
      R1 = _saBq::P64;
      call stg_norec_readTVar#(R1) returns to cba7, args: 8, res: 8, upd: 8;
  cba7:
      _saBt::P64 = R1;
      I64[(young<cba9> + 8)] = cba9;
      R1 = _saBt::P64;
      if (R1 & 7 != 0) goto cba9; else goto cbac;
  cbac:
      call (I64[R1])(R1) returns to cba9, args: 8, res: 8, upd: 8;
  cba9:
      _saBu::P64 = R1;
      _cbcM::P64 = _saBu::P64 & 7;
      switch [1 .. 2] _cbcM::P64 {
          case 1 : goto cbai;
          case 2 : goto cban;
      }
  cban:
      _saBw::P64 = P64[_saBu::P64 + 6];
      _saBx::P64 = P64[_saBu::P64 + 14];
      _saBy::P64 = P64[_saBu::P64 + 22];
      I64[(young<cbal> + 8)] = cbal;
      R2 = _saA2::P64;
      I64[(young<cbal> + 32)] = stg_ap_pp_info;
      P64[(young<cbal> + 24)] = _saBw::P64;
      P64[(young<cbal> + 16)] = _saA5::P64;
      call GHC.Classes.>_info(R2) returns to cbal, args: 32, res: 8, upd: 8;
  cbal:
      _saBz::P64 = R1;
      _cbcN::P64 = _saBz::P64 & 7;
      switch [1 .. 2] _cbcN::P64 {
          case 1 : goto cbau;
          case 2 : goto cbaU;
      }
  cbaU:
      _cbcO::I64 = _saB0::I64 - 1;
      _saBH::I64 = _cbcO::I64;
      _saAi::P64 = _saB5::P64;
      _saAh::I64 = _saB4::I64;
      _saAg::I64 = _saB9::I64;
      _saAf::I64 = _saB7::I64;
      _saAe::I64 = _saBH::I64;
      goto cbb1;
  cbau:
      I64[(young<cbar> + 8)] = cbar;
      R2 = _saA2::P64;
      I64[(young<cbar> + 32)] = stg_ap_pp_info;
      P64[(young<cbar> + 24)] = _saBw::P64;
      P64[(young<cbar> + 16)] = _saA5::P64;
      call GHC.Classes.<_info(R2) returns to cbar, args: 32, res: 8, upd: 8;
  cbar:
      _saBA::P64 = R1;
      _cbcP::P64 = _saBA::P64 & 7;
      switch [1 .. 2] _cbcP::P64 {
          case 1 : goto cbaI;
          case 2 : goto cbaQ;
      }
  cbaQ:
      _saAY::P64 = _saBy::P64;
      _saAX::I64 = _saB0::I64;
      goto cb92;
  cbaI:
      I64[(young<cbay> + 8)] = cbay;
      R1 = _saBx::P64;
      if (R1 & 7 != 0) goto cbay; else goto cbaz;
  cbaz:
      call (I64[R1])(R1) returns to cbay, args: 8, res: 8, upd: 8;
  cbay:
      _saBB::P64 = R1;
      _saBC::P64 = P64[_saBB::P64 + 7];
      I64[(young<cbaD> + 8)] = cbaD;
      R1 = _saBC::P64;
      call stg_norec_readTVar#(R1) returns to cbaD, args: 8, res: 8, upd: 8;
  cbaD:
      _saBF::P64 = R1;
      Hp = Hp + 16;
      if (Hp > HpLim) goto cbaM; else goto cbaL;
  cbaM:
      HpAlloc = 16;
      R1 = _saBF::P64;
      call stg_gc_unpt_r1(R1) returns to cbaD, args: 8, res: 8, upd: 8;
  cbaL:
      I64[Hp - 8] = GHC.Base.Just_con_info;
      P64[Hp] = _saBF::P64;
      _cbaF::P64 = Hp - 6;
      R1 = _cbaF::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
  cbai:
      _cbcQ::I64 = _saB0::I64 - 1;
      _saBv::I64 = _cbcQ::I64;
      _saAi::P64 = _saB5::P64;
      _saAh::I64 = _saB4::I64;
      _saAg::I64 = _saB9::I64;
      _saAf::I64 = _saB7::I64;
      _saAe::I64 = _saBv::I64;
      goto cbb1;
  cbb1:
      Hp = Hp + 32;
      if (Hp > HpLim) goto cbb6; else goto cbb5;
  cbb6:
      HpAlloc = 32;
      I64[(young<cbb2> + 8)] = cbb2;
      call stg_gc_noregs() returns to cbb2, args: 8, res: 8, upd: 8;
  cbb2:
      goto cbb1;
  cbb5:
      _saAk::I64 = _saAe::I64;
      switch [-9223372036854775808 .. 9223372036854775807] _saAk::I64 {
          case 0 : goto cbcL;
          default: goto cbcK;
      }
  cbcL:
      Hp = Hp - 32;
      R1 = GHC.Base.Nothing_closure+1;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
  cbcK:
      _cbb9::I64 = %MO_S_Le_W64(_saAf::I64, _saAk::I64);
      _saAl::I64 = _cbb9::I64;
      switch [0 .. 1] _saAl::I64 {
          case 0 : goto cbbh;
          case 1 : goto cbcI;
      }
  cbcI:
      _cbbj::I64 = %MO_S_Le_W64(_saAk::I64, _saAg::I64);
      _saAq::I64 = _cbbj::I64;
      switch [0 .. 1] _saAq::I64 {
          case 0 : goto cbbr;
          case 1 : goto cbcH;
      }
  cbcH:
      _cbbt::I64 = _saAk::I64 - _saAf::I64;
      _saAv::I64 = _cbbt::I64;
      _cbbw::I64 = %MO_S_Le_W64(0, _saAv::I64);
      _saAw::I64 = _cbbw::I64;
      switch [0 .. 1] _saAw::I64 {
          case 0 : goto cbbJ;
          case 1 : goto cbcG;
      }
  cbcG:
      _cbbE::I64 = %MO_S_Lt_W64(_saAv::I64, _saAh::I64);
      _saAz::I64 = _cbbE::I64;
      switch [0 .. 1] _saAz::I64 {
          case 0 : goto cbbJ;
          case 1 : goto cbbN;
      }
  cbbN:
      _saAD::P64 = P64[(_saAi::P64 + 24) + (_saAv::I64 << 3)];
      _saAD::P64 = _saAD::P64;
      Hp = Hp - 32;
      I64[(young<cbbM> + 8)] = cbbM;
      R1 = _saAD::P64;
      if (R1 & 7 != 0) goto cbbM; else goto cbbO;
  cbbO:
      call (I64[R1])(R1) returns to cbbM, args: 8, res: 8, upd: 8;
  cbbM:
      _saAE::P64 = R1;
      _saAF::P64 = P64[_saAE::P64 + 7];
      I64[(young<cbbS> + 8)] = cbbS;
      R1 = _saAF::P64;
      call stg_norec_readTVar#(R1) returns to cbbS, args: 8, res: 8, upd: 8;
  cbbS:
      _saAI::P64 = R1;
      I64[(young<cbbU> + 8)] = cbbU;
      R1 = _saAI::P64;
      if (R1 & 7 != 0) goto cbbU; else goto cbbX;
  cbbX:
      call (I64[R1])(R1) returns to cbbU, args: 8, res: 8, upd: 8;
  cbbU:
      _saAJ::P64 = R1;
      _cbcR::P64 = _saAJ::P64 & 7;
      switch [1 .. 2] _cbcR::P64 {
          case 1 : goto cbc3;
          case 2 : goto cbc8;
      }
  cbc8:
      _saAL::P64 = P64[_saAJ::P64 + 6];
      _saAM::P64 = P64[_saAJ::P64 + 14];
      _saAN::P64 = P64[_saAJ::P64 + 22];
      I64[(young<cbc6> + 8)] = cbc6;
      R2 = _saA2::P64;
      I64[(young<cbc6> + 32)] = stg_ap_pp_info;
      P64[(young<cbc6> + 24)] = _saAL::P64;
      P64[(young<cbc6> + 16)] = _saA5::P64;
      call GHC.Classes.>_info(R2) returns to cbc6, args: 32, res: 8, upd: 8;
  cbc6:
      _saAO::P64 = R1;
      _cbcS::P64 = _saAO::P64 & 7;
      switch [1 .. 2] _cbcS::P64 {
          case 1 : goto cbcf;
          case 2 : goto cbcF;
      }
  cbcF:
      _cbcT::I64 = _saAk::I64 - 1;
      _saAW::I64 = _cbcT::I64;
      _saAi::P64 = _saAi::P64;
      _saAh::I64 = _saAh::I64;
      _saAg::I64 = _saAg::I64;
      _saAf::I64 = _saAf::I64;
      _saAe::I64 = _saAW::I64;
      goto cbb1;
  cbcf:
      I64[(young<cbcc> + 8)] = cbcc;
      R2 = _saA2::P64;
      I64[(young<cbcc> + 32)] = stg_ap_pp_info;
      P64[(young<cbcc> + 24)] = _saAL::P64;
      P64[(young<cbcc> + 16)] = _saA5::P64;
      call GHC.Classes.<_info(R2) returns to cbcc, args: 32, res: 8, upd: 8;
  cbcc:
      _saAP::P64 = R1;
      _cbcU::P64 = _saAP::P64 & 7;
      switch [1 .. 2] _cbcU::P64 {
          case 1 : goto cbct;
          case 2 : goto cbcB;
      }
  cbcB:
      _saAY::P64 = _saAN::P64;
      _saAX::I64 = _saAk::I64;
      goto cb92;
  cbct:
      I64[(young<cbcj> + 8)] = cbcj;
      R1 = _saAM::P64;
      if (R1 & 7 != 0) goto cbcj; else goto cbck;
  cbck:
      call (I64[R1])(R1) returns to cbcj, args: 8, res: 8, upd: 8;
  cbcj:
      _saAQ::P64 = R1;
      _saAR::P64 = P64[_saAQ::P64 + 7];
      I64[(young<cbco> + 8)] = cbco;
      R1 = _saAR::P64;
      call stg_norec_readTVar#(R1) returns to cbco, args: 8, res: 8, upd: 8;
  cbco:
      _saAU::P64 = R1;
      Hp = Hp + 16;
      if (Hp > HpLim) goto cbcx; else goto cbcw;
  cbcx:
      HpAlloc = 16;
      R1 = _saAU::P64;
      call stg_gc_unpt_r1(R1) returns to cbco, args: 8, res: 8, upd: 8;
  cbcw:
      I64[Hp - 8] = GHC.Base.Just_con_info;
      P64[Hp] = _saAU::P64;
      _cbcq::P64 = Hp - 6;
      R1 = _cbcq::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
  cbc3:
      _cbcV::I64 = _saAk::I64 - 1;
      _saAK::I64 = _cbcV::I64;
      _saAi::P64 = _saAi::P64;
      _saAh::I64 = _saAh::I64;
      _saAg::I64 = _saAg::I64;
      _saAf::I64 = _saAf::I64;
      _saAe::I64 = _saAK::I64;
      goto cbb1;
  cbbJ:
      Hp = Hp - 32;
      R3 = _saAv::I64;
      R2 = _saAh::I64;
      call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
  cbbr:
      I64[Hp - 24] = GHC.Types.I#_con_info;
      I64[Hp - 16] = _saAg::I64;
      _cbbo::P64 = Hp - 23;
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _saAf::I64;
      _cbbp::P64 = Hp - 7;
      R4 = _cbbo::P64;
      R3 = _cbbp::P64;
      R2 = _saAk::I64;
      call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbbh:
      I64[Hp - 24] = GHC.Types.I#_con_info;
      I64[Hp - 16] = _saAg::I64;
      _cbbe::P64 = Hp - 23;
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _saAf::I64;
      _cbbf::P64 = Hp - 7;
      R4 = _cbbe::P64;
      R3 = _cbbf::P64;
      R2 = _saAk::I64;
      call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cb9Y:
      R3 = _saBg::I64;
      R2 = _saB4::I64;
      call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
  cb9F:
      R4 = _saB8::P64;
      R3 = _saB6::P64;
      R2 = _saB0::I64;
      call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:45.819529 UTC

{offset
  cb8S:
      _saA5::P64 = R5;
      _saA4::P64 = R4;
      _saA3::P64 = R3;
      _saA2::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cb8T; else goto cb8U;
  cb8U:
      if (HpLim == 0) goto cb8T; else goto cb8V;
  cb8T:
      R5 = _saA5::P64;
      R4 = _saA4::P64;
      R3 = _saA3::P64;
      R2 = _saA2::P64;
      R1 = SkipList.$wa3_closure;
      call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  cb8V:
      I64[(young<cb8N> + 8)] = cb8N;
      R1 = _saA4::P64;
      call stg_norec_readTVar#(R1) returns to cb8N, args: 8, res: 8, upd: 8;
  cb8N:
      _saA9::P64 = R1;
      I64[(young<cb8P> + 8)] = cb8P;
      R1 = _saA9::P64;
      if (R1 & 7 != 0) goto cb8P; else goto cb8Q;
  cb8Q:
      call (I64[R1])(R1) returns to cb8P, args: 8, res: 8, upd: 8;
  cb8P:
      _saAa::P64 = R1;
      _saAb::I64 = I64[_saAa::P64 + 7];
      _saAY::P64 = _saA3::P64;
      _saAX::I64 = _saAb::I64;
      goto cb92;
  cb92:
      if (HpLim == 0) goto cb95; else goto cbaZ;
  cb95:
      I64[(young<cb93> + 8)] = cb93;
      call stg_gc_noregs() returns to cb93, args: 8, res: 8, upd: 8;
  cb93:
      goto cb92;
  cbaZ:
      _saB0::I64 = _saAX::I64;
      if (_saB0::I64 != 0) goto cb9k; else goto cbaY;
  cb9k:
      I64[(young<cb98> + 8)] = cb98;
      R1 = _saAY::P64;
      if (R1 & 7 != 0) goto cb98; else goto cb99;
  cb99:
      call (I64[R1])(R1) returns to cb98, args: 8, res: 8, upd: 8;
  cb98:
      _saB1::P64 = R1;
      _saB2::P64 = P64[_saB1::P64 + 7];
      _saB3::P64 = P64[_saB1::P64 + 15];
      _saB5::P64 = P64[_saB1::P64 + 23];
      _saB4::I64 = I64[_saB1::P64 + 31];
      I64[(young<cb9d> + 8)] = cb9d;
      R1 = _saB2::P64;
      if (R1 & 7 != 0) goto cb9d; else goto cb9e;
  cb9e:
      call (I64[R1])(R1) returns to cb9d, args: 8, res: 8, upd: 8;
  cb9d:
      _saB6::P64 = R1;
      _saB7::I64 = I64[_saB6::P64 + 7];
      I64[(young<cb9i> + 8)] = cb9i;
      R1 = _saB3::P64;
      if (R1 & 7 != 0) goto cb9i; else goto cb9n;
  cb9n:
      call (I64[R1])(R1) returns to cb9i, args: 8, res: 8, upd: 8;
  cb9i:
      _saB8::P64 = R1;
      _saB9::I64 = I64[_saB8::P64 + 7];
      _cb9s::I64 = %MO_S_Le_W64(_saB7::I64, _saB0::I64);
      _saBa::I64 = _cb9s::I64;
      if (_saBa::I64 != 0) goto cbaX; else goto cb9F;
  cbaX:
      _cb9A::I64 = %MO_S_Le_W64(_saB0::I64, _saB9::I64);
      _saBd::I64 = _cb9A::I64;
      if (_saBd::I64 != 0) goto cbaW; else goto cb9F;
  cbaW:
      _cb9I::I64 = _saB0::I64 - _saB7::I64;
      _saBg::I64 = _cb9I::I64;
      _cb9L::I64 = %MO_S_Le_W64(0, _saBg::I64);
      _saBh::I64 = _cb9L::I64;
      if (_saBh::I64 != 0) goto cbaV; else goto cb9Y;
  cbaV:
      _cb9T::I64 = %MO_S_Lt_W64(_saBg::I64, _saB4::I64);
      _saBk::I64 = _cb9T::I64;
      if (_saBk::I64 != 0) goto cba2; else goto cb9Y;
  cba2:
      _saBo::P64 = P64[(_saB5::P64 + 24) + (_saBg::I64 << 3)];
      _saBo::P64 = _saBo::P64;
      I64[(young<cba1> + 8)] = cba1;
      R1 = _saBo::P64;
      if (R1 & 7 != 0) goto cba1; else goto cba3;
  cba3:
      call (I64[R1])(R1) returns to cba1, args: 8, res: 8, upd: 8;
  cba1:
      _saBp::P64 = R1;
      _saBq::P64 = P64[_saBp::P64 + 7];
      I64[(young<cba7> + 8)] = cba7;
      R1 = _saBq::P64;
      call stg_norec_readTVar#(R1) returns to cba7, args: 8, res: 8, upd: 8;
  cba7:
      _saBt::P64 = R1;
      I64[(young<cba9> + 8)] = cba9;
      R1 = _saBt::P64;
      if (R1 & 7 != 0) goto cba9; else goto cbac;
  cbac:
      call (I64[R1])(R1) returns to cba9, args: 8, res: 8, upd: 8;
  cba9:
      _saBu::P64 = R1;
      _cbcM::P64 = _saBu::P64 & 7;
      if (_cbcM::P64 != 1) goto cban; else goto cbai;
  cban:
      _saBw::P64 = P64[_saBu::P64 + 6];
      _saBx::P64 = P64[_saBu::P64 + 14];
      _saBy::P64 = P64[_saBu::P64 + 22];
      I64[(young<cbal> + 8)] = cbal;
      R2 = _saA2::P64;
      I64[(young<cbal> + 32)] = stg_ap_pp_info;
      P64[(young<cbal> + 24)] = _saBw::P64;
      P64[(young<cbal> + 16)] = _saA5::P64;
      call GHC.Classes.>_info(R2) returns to cbal, args: 32, res: 8, upd: 8;
  cbal:
      _saBz::P64 = R1;
      _cbcN::P64 = _saBz::P64 & 7;
      if (_cbcN::P64 != 1) goto cbaU; else goto cbau;
  cbaU:
      _cbcO::I64 = _saB0::I64 - 1;
      _saBH::I64 = _cbcO::I64;
      _saAi::P64 = _saB5::P64;
      _saAh::I64 = _saB4::I64;
      _saAg::I64 = _saB9::I64;
      _saAf::I64 = _saB7::I64;
      _saAe::I64 = _saBH::I64;
      goto cbb1;
  cbau:
      I64[(young<cbar> + 8)] = cbar;
      R2 = _saA2::P64;
      I64[(young<cbar> + 32)] = stg_ap_pp_info;
      P64[(young<cbar> + 24)] = _saBw::P64;
      P64[(young<cbar> + 16)] = _saA5::P64;
      call GHC.Classes.<_info(R2) returns to cbar, args: 32, res: 8, upd: 8;
  cbar:
      _saBA::P64 = R1;
      _cbcP::P64 = _saBA::P64 & 7;
      if (_cbcP::P64 != 1) goto cbaQ; else goto cbaI;
  cbaQ:
      _saAY::P64 = _saBy::P64;
      _saAX::I64 = _saB0::I64;
      goto cb92;
  cbaI:
      I64[(young<cbay> + 8)] = cbay;
      R1 = _saBx::P64;
      if (R1 & 7 != 0) goto cbay; else goto cbaz;
  cbaz:
      call (I64[R1])(R1) returns to cbay, args: 8, res: 8, upd: 8;
  cbay:
      _saBB::P64 = R1;
      _saBC::P64 = P64[_saBB::P64 + 7];
      I64[(young<cbaD> + 8)] = cbaD;
      R1 = _saBC::P64;
      call stg_norec_readTVar#(R1) returns to cbaD, args: 8, res: 8, upd: 8;
  cbaD:
      _saBF::P64 = R1;
      Hp = Hp + 16;
      if (Hp > HpLim) goto cbaM; else goto cbaL;
  cbaM:
      HpAlloc = 16;
      R1 = _saBF::P64;
      call stg_gc_unpt_r1(R1) returns to cbaD, args: 8, res: 8, upd: 8;
  cbaL:
      I64[Hp - 8] = GHC.Base.Just_con_info;
      P64[Hp] = _saBF::P64;
      _cbaF::P64 = Hp - 6;
      R1 = _cbaF::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
  cbai:
      _cbcQ::I64 = _saB0::I64 - 1;
      _saBv::I64 = _cbcQ::I64;
      _saAi::P64 = _saB5::P64;
      _saAh::I64 = _saB4::I64;
      _saAg::I64 = _saB9::I64;
      _saAf::I64 = _saB7::I64;
      _saAe::I64 = _saBv::I64;
      goto cbb1;
  cbb1:
      Hp = Hp + 32;
      if (Hp > HpLim) goto cbb6; else goto cbb5;
  cbb6:
      HpAlloc = 32;
      I64[(young<cbb2> + 8)] = cbb2;
      call stg_gc_noregs() returns to cbb2, args: 8, res: 8, upd: 8;
  cbb2:
      goto cbb1;
  cbb5:
      _saAk::I64 = _saAe::I64;
      if (_saAk::I64 != 0) goto cbcK; else goto cbcL;
  cbcK:
      _cbb9::I64 = %MO_S_Le_W64(_saAf::I64, _saAk::I64);
      _saAl::I64 = _cbb9::I64;
      if (_saAl::I64 != 0) goto cbcI; else goto cbbh;
  cbcI:
      _cbbj::I64 = %MO_S_Le_W64(_saAk::I64, _saAg::I64);
      _saAq::I64 = _cbbj::I64;
      if (_saAq::I64 != 0) goto cbcH; else goto cbbr;
  cbcH:
      _cbbt::I64 = _saAk::I64 - _saAf::I64;
      _saAv::I64 = _cbbt::I64;
      _cbbw::I64 = %MO_S_Le_W64(0, _saAv::I64);
      _saAw::I64 = _cbbw::I64;
      if (_saAw::I64 != 0) goto cbcG; else goto cbbJ;
  cbcG:
      _cbbE::I64 = %MO_S_Lt_W64(_saAv::I64, _saAh::I64);
      _saAz::I64 = _cbbE::I64;
      if (_saAz::I64 != 0) goto cbbN; else goto cbbJ;
  cbbN:
      _saAD::P64 = P64[(_saAi::P64 + 24) + (_saAv::I64 << 3)];
      _saAD::P64 = _saAD::P64;
      Hp = Hp - 32;
      I64[(young<cbbM> + 8)] = cbbM;
      R1 = _saAD::P64;
      if (R1 & 7 != 0) goto cbbM; else goto cbbO;
  cbbO:
      call (I64[R1])(R1) returns to cbbM, args: 8, res: 8, upd: 8;
  cbbM:
      _saAE::P64 = R1;
      _saAF::P64 = P64[_saAE::P64 + 7];
      I64[(young<cbbS> + 8)] = cbbS;
      R1 = _saAF::P64;
      call stg_norec_readTVar#(R1) returns to cbbS, args: 8, res: 8, upd: 8;
  cbbS:
      _saAI::P64 = R1;
      I64[(young<cbbU> + 8)] = cbbU;
      R1 = _saAI::P64;
      if (R1 & 7 != 0) goto cbbU; else goto cbbX;
  cbbX:
      call (I64[R1])(R1) returns to cbbU, args: 8, res: 8, upd: 8;
  cbbU:
      _saAJ::P64 = R1;
      _cbcR::P64 = _saAJ::P64 & 7;
      if (_cbcR::P64 != 1) goto cbc8; else goto cbc3;
  cbc8:
      _saAL::P64 = P64[_saAJ::P64 + 6];
      _saAM::P64 = P64[_saAJ::P64 + 14];
      _saAN::P64 = P64[_saAJ::P64 + 22];
      I64[(young<cbc6> + 8)] = cbc6;
      R2 = _saA2::P64;
      I64[(young<cbc6> + 32)] = stg_ap_pp_info;
      P64[(young<cbc6> + 24)] = _saAL::P64;
      P64[(young<cbc6> + 16)] = _saA5::P64;
      call GHC.Classes.>_info(R2) returns to cbc6, args: 32, res: 8, upd: 8;
  cbc6:
      _saAO::P64 = R1;
      _cbcS::P64 = _saAO::P64 & 7;
      if (_cbcS::P64 != 1) goto cbcF; else goto cbcf;
  cbcF:
      _cbcT::I64 = _saAk::I64 - 1;
      _saAW::I64 = _cbcT::I64;
      _saAi::P64 = _saAi::P64;
      _saAh::I64 = _saAh::I64;
      _saAg::I64 = _saAg::I64;
      _saAf::I64 = _saAf::I64;
      _saAe::I64 = _saAW::I64;
      goto cbb1;
  cbcf:
      I64[(young<cbcc> + 8)] = cbcc;
      R2 = _saA2::P64;
      I64[(young<cbcc> + 32)] = stg_ap_pp_info;
      P64[(young<cbcc> + 24)] = _saAL::P64;
      P64[(young<cbcc> + 16)] = _saA5::P64;
      call GHC.Classes.<_info(R2) returns to cbcc, args: 32, res: 8, upd: 8;
  cbcc:
      _saAP::P64 = R1;
      _cbcU::P64 = _saAP::P64 & 7;
      if (_cbcU::P64 != 1) goto cbcB; else goto cbct;
  cbcB:
      _saAY::P64 = _saAN::P64;
      _saAX::I64 = _saAk::I64;
      goto cb92;
  cbct:
      I64[(young<cbcj> + 8)] = cbcj;
      R1 = _saAM::P64;
      if (R1 & 7 != 0) goto cbcj; else goto cbck;
  cbck:
      call (I64[R1])(R1) returns to cbcj, args: 8, res: 8, upd: 8;
  cbcj:
      _saAQ::P64 = R1;
      _saAR::P64 = P64[_saAQ::P64 + 7];
      I64[(young<cbco> + 8)] = cbco;
      R1 = _saAR::P64;
      call stg_norec_readTVar#(R1) returns to cbco, args: 8, res: 8, upd: 8;
  cbco:
      _saAU::P64 = R1;
      Hp = Hp + 16;
      if (Hp > HpLim) goto cbcx; else goto cbcw;
  cbcx:
      HpAlloc = 16;
      R1 = _saAU::P64;
      call stg_gc_unpt_r1(R1) returns to cbco, args: 8, res: 8, upd: 8;
  cbcw:
      I64[Hp - 8] = GHC.Base.Just_con_info;
      P64[Hp] = _saAU::P64;
      _cbcq::P64 = Hp - 6;
      R1 = _cbcq::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
  cbc3:
      _cbcV::I64 = _saAk::I64 - 1;
      _saAK::I64 = _cbcV::I64;
      _saAi::P64 = _saAi::P64;
      _saAh::I64 = _saAh::I64;
      _saAg::I64 = _saAg::I64;
      _saAf::I64 = _saAf::I64;
      _saAe::I64 = _saAK::I64;
      goto cbb1;
  cbbJ:
      Hp = Hp - 32;
      R3 = _saAv::I64;
      R2 = _saAh::I64;
      call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
  cbbr:
      I64[Hp - 24] = GHC.Types.I#_con_info;
      I64[Hp - 16] = _saAg::I64;
      _cbbo::P64 = Hp - 23;
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _saAf::I64;
      _cbbp::P64 = Hp - 7;
      R4 = _cbbo::P64;
      R3 = _cbbp::P64;
      R2 = _saAk::I64;
      call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbbh:
      I64[Hp - 24] = GHC.Types.I#_con_info;
      I64[Hp - 16] = _saAg::I64;
      _cbbe::P64 = Hp - 23;
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _saAf::I64;
      _cbbf::P64 = Hp - 7;
      R4 = _cbbe::P64;
      R3 = _cbbf::P64;
      R2 = _saAk::I64;
      call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbcL:
      Hp = Hp - 32;
      R1 = GHC.Base.Nothing_closure+1;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
  cb9Y:
      R3 = _saBg::I64;
      R2 = _saB4::I64;
      call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
  cb9F:
      R4 = _saB8::P64;
      R3 = _saB6::P64;
      R2 = _saB0::I64;
      call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbaY:
      R1 = GHC.Base.Nothing_closure+1;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:45.83828 UTC

{offset
  cb8S:
      _saA5::P64 = R5;
      _saA4::P64 = R4;
      _saA3::P64 = R3;
      _saA2::P64 = R2;
      if ((Sp + 8) - 120 < SpLim) goto cb8T; else goto cb8U;
  cb8U:
      if (HpLim == 0) goto cb8T; else goto cb8V;
  cb8T:
      R5 = _saA5::P64;
      R4 = _saA4::P64;
      R3 = _saA3::P64;
      R2 = _saA2::P64;
      R1 = SkipList.$wa3_closure;
      call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  cb8V:
      I64[Sp - 32] = cb8N;
      R1 = _saA4::P64;
      P64[Sp - 24] = _saA2::P64;
      P64[Sp - 16] = _saA3::P64;
      P64[Sp - 8] = _saA5::P64;
      Sp = Sp - 32;
      call stg_norec_readTVar#(R1) returns to cb8N, args: 8, res: 8, upd: 8;
  cb8N:
      _saA2::P64 = P64[Sp + 8];
      _saA3::P64 = P64[Sp + 16];
      _saA5::P64 = P64[Sp + 24];
      _saA9::P64 = R1;
      I64[Sp] = cb8P;
      R1 = _saA9::P64;
      if (R1 & 7 != 0) goto cb8P; else goto cb8Q;
  cb8Q:
      call (I64[R1])(R1) returns to cb8P, args: 8, res: 8, upd: 8;
  cb8P:
      _saA2::P64 = P64[Sp + 8];
      _saA3::P64 = P64[Sp + 16];
      _saA5::P64 = P64[Sp + 24];
      _saAa::P64 = R1;
      _saAb::I64 = I64[_saAa::P64 + 7];
      _saAY::P64 = _saA3::P64;
      _saAX::I64 = _saAb::I64;
      goto cb92;
  cb92:
      if (HpLim == 0) goto cb95; else goto cbaZ;
  cb95:
      I64[Sp - 8] = cb93;
      P64[Sp] = _saAY::P64;
      I64[Sp + 16] = _saAX::I64;
      Sp = Sp - 8;
      call stg_gc_noregs() returns to cb93, args: 8, res: 8, upd: 8;
  cb93:
      _saA2::P64 = P64[Sp + 16];
      _saA5::P64 = P64[Sp + 32];
      _saAX::I64 = I64[Sp + 24];
      _saAY::P64 = P64[Sp + 8];
      goto ubcW;
  ubcW:
      Sp = Sp + 8;
      goto cb92;
  cbaZ:
      _saB0::I64 = _saAX::I64;
      if (_saB0::I64 != 0) goto cb9k; else goto cbaY;
  cb9k:
      I64[Sp] = cb98;
      R1 = _saAY::P64;
      I64[Sp + 16] = _saB0::I64;
      if (R1 & 7 != 0) goto cb98; else goto cb99;
  cb99:
      call (I64[R1])(R1) returns to cb98, args: 8, res: 8, upd: 8;
  cb98:
      _saA2::P64 = P64[Sp + 8];
      _saA5::P64 = P64[Sp + 24];
      _saB0::I64 = I64[Sp + 16];
      _saB1::P64 = R1;
      _saB2::P64 = P64[_saB1::P64 + 7];
      _saB3::P64 = P64[_saB1::P64 + 15];
      _saB5::P64 = P64[_saB1::P64 + 23];
      _saB4::I64 = I64[_saB1::P64 + 31];
      I64[Sp - 24] = cb9d;
      R1 = _saB2::P64;
      I64[Sp - 16] = _saB4::I64;
      P64[Sp - 8] = _saB5::P64;
      P64[Sp] = _saB3::P64;
      Sp = Sp - 24;
      if (R1 & 7 != 0) goto cb9d; else goto cb9e;
  cb9e:
      call (I64[R1])(R1) returns to cb9d, args: 8, res: 8, upd: 8;
  cb9d:
      _saA2::P64 = P64[Sp + 32];
      _saA5::P64 = P64[Sp + 48];
      _saB0::I64 = I64[Sp + 40];
      _saB3::P64 = P64[Sp + 24];
      _saB4::I64 = I64[Sp + 8];
      _saB5::P64 = P64[Sp + 16];
      _saB6::P64 = R1;
      _saB7::I64 = I64[_saB6::P64 + 7];
      I64[Sp - 8] = cb9i;
      R1 = _saB3::P64;
      I64[Sp] = _saB7::I64;
      P64[Sp + 24] = _saB6::P64;
      Sp = Sp - 8;
      if (R1 & 7 != 0) goto cb9i; else goto cb9n;
  cb9n:
      call (I64[R1])(R1) returns to cb9i, args: 8, res: 8, upd: 8;
  cb9i:
      _saA2::P64 = P64[Sp + 40];
      _saA5::P64 = P64[Sp + 56];
      _saB0::I64 = I64[Sp + 48];
      _saB4::I64 = I64[Sp + 16];
      _saB5::P64 = P64[Sp + 24];
      _saB6::P64 = P64[Sp + 32];
      _saB7::I64 = I64[Sp + 8];
      _saB8::P64 = R1;
      _saB9::I64 = I64[_saB8::P64 + 7];
      _cb9s::I64 = %MO_S_Le_W64(_saB7::I64, _saB0::I64);
      _saBa::I64 = _cb9s::I64;
      if (_saBa::I64 != 0) goto cbaX; else goto cb9F;
  cbaX:
      _cb9A::I64 = %MO_S_Le_W64(_saB0::I64, _saB9::I64);
      _saBd::I64 = _cb9A::I64;
      if (_saBd::I64 != 0) goto cbaW; else goto cb9F;
  cbaW:
      _cb9I::I64 = _saB0::I64 - _saB7::I64;
      _saBg::I64 = _cb9I::I64;
      _cb9L::I64 = %MO_S_Le_W64(0, _saBg::I64);
      _saBh::I64 = _cb9L::I64;
      if (_saBh::I64 != 0) goto cbaV; else goto cb9Y;
  cbaV:
      _cb9T::I64 = %MO_S_Lt_W64(_saBg::I64, _saB4::I64);
      _saBk::I64 = _cb9T::I64;
      if (_saBk::I64 != 0) goto cba2; else goto cb9Y;
  cba2:
      _saBo::P64 = P64[(_saB5::P64 + 24) + (_saBg::I64 << 3)];
      _saBo::P64 = _saBo::P64;
      I64[Sp] = cba1;
      R1 = _saBo::P64;
      I64[Sp + 32] = _saB9::I64;
      if (R1 & 7 != 0) goto cba1; else goto cba3;
  cba3:
      call (I64[R1])(R1) returns to cba1, args: 8, res: 8, upd: 8;
  cba1:
      _saA2::P64 = P64[Sp + 40];
      _saA5::P64 = P64[Sp + 56];
      _saB0::I64 = I64[Sp + 48];
      _saB4::I64 = I64[Sp + 16];
      _saB5::P64 = P64[Sp + 24];
      _saB7::I64 = I64[Sp + 8];
      _saB9::I64 = I64[Sp + 32];
      _saBp::P64 = R1;
      _saBq::P64 = P64[_saBp::P64 + 7];
      I64[Sp] = cba7;
      R1 = _saBq::P64;
      call stg_norec_readTVar#(R1) returns to cba7, args: 8, res: 8, upd: 8;
  cba7:
      _saA2::P64 = P64[Sp + 40];
      _saA5::P64 = P64[Sp + 56];
      _saB0::I64 = I64[Sp + 48];
      _saB4::I64 = I64[Sp + 16];
      _saB5::P64 = P64[Sp + 24];
      _saB7::I64 = I64[Sp + 8];
      _saB9::I64 = I64[Sp + 32];
      _saBt::P64 = R1;
      I64[Sp] = cba9;
      R1 = _saBt::P64;
      if (R1 & 7 != 0) goto cba9; else goto cbac;
  cbac:
      call (I64[R1])(R1) returns to cba9, args: 8, res: 8, upd: 8;
  cba9:
      _saA2::P64 = P64[Sp + 40];
      _saA5::P64 = P64[Sp + 56];
      _saB0::I64 = I64[Sp + 48];
      _saB4::I64 = I64[Sp + 16];
      _saB5::P64 = P64[Sp + 24];
      _saB7::I64 = I64[Sp + 8];
      _saB9::I64 = I64[Sp + 32];
      _saBu::P64 = R1;
      _cbcM::P64 = _saBu::P64 & 7;
      if (_cbcM::P64 != 1) goto cban; else goto cbai;
  cban:
      _saBw::P64 = P64[_saBu::P64 + 6];
      _saBx::P64 = P64[_saBu::P64 + 14];
      _saBy::P64 = P64[_saBu::P64 + 22];
      I64[Sp - 24] = cbal;
      R2 = _saA2::P64;
      I64[Sp - 48] = stg_ap_pp_info;
      P64[Sp - 40] = _saBw::P64;
      P64[Sp - 32] = _saA5::P64;
      P64[Sp - 16] = _saBx::P64;
      P64[Sp - 8] = _saBy::P64;
      P64[Sp] = _saBw::P64;
      Sp = Sp - 48;
      call GHC.Classes.>_info(R2) returns to cbal, args: 32, res: 8, upd: 8;
  cbal:
      _saA2::P64 = P64[Sp + 64];
      _saA5::P64 = P64[Sp + 80];
      _saB0::I64 = I64[Sp + 72];
      _saB4::I64 = I64[Sp + 40];
      _saB5::P64 = P64[Sp + 48];
      _saB7::I64 = I64[Sp + 32];
      _saB9::I64 = I64[Sp + 56];
      _saBw::P64 = P64[Sp + 24];
      _saBx::P64 = P64[Sp + 8];
      _saBy::P64 = P64[Sp + 16];
      _saBz::P64 = R1;
      _cbcN::P64 = _saBz::P64 & 7;
      if (_cbcN::P64 != 1) goto cbaU; else goto cbau;
  cbaU:
      _cbcO::I64 = _saB0::I64 - 1;
      _saBH::I64 = _cbcO::I64;
      _saAi::P64 = _saB5::P64;
      _saAh::I64 = _saB4::I64;
      _saAg::I64 = _saB9::I64;
      _saAf::I64 = _saB7::I64;
      _saAe::I64 = _saBH::I64;
      goto cbb1;
  cbau:
      I64[Sp] = cbar;
      R2 = _saA2::P64;
      I64[Sp - 24] = stg_ap_pp_info;
      P64[Sp - 16] = _saBw::P64;
      P64[Sp - 8] = _saA5::P64;
      Sp = Sp - 24;
      call GHC.Classes.<_info(R2) returns to cbar, args: 32, res: 8, upd: 8;
  cbar:
      _saA2::P64 = P64[Sp + 64];
      _saA5::P64 = P64[Sp + 80];
      _saB0::I64 = I64[Sp + 72];
      _saBx::P64 = P64[Sp + 8];
      _saBy::P64 = P64[Sp + 16];
      _saBA::P64 = R1;
      _cbcP::P64 = _saBA::P64 & 7;
      if (_cbcP::P64 != 1) goto cbaQ; else goto cbaI;
  cbaQ:
      _saAY::P64 = _saBy::P64;
      _saAX::I64 = _saB0::I64;
      goto ubcX;
  ubcX:
      Sp = Sp + 56;
      goto cb92;
  cbaI:
      I64[Sp + 80] = cbay;
      R1 = _saBx::P64;
      Sp = Sp + 80;
      if (R1 & 7 != 0) goto cbay; else goto cbaz;
  cbaz:
      call (I64[R1])(R1) returns to cbay, args: 8, res: 8, upd: 8;
  cbay:
      _saBB::P64 = R1;
      _saBC::P64 = P64[_saBB::P64 + 7];
      I64[Sp] = cbaD;
      R1 = _saBC::P64;
      call stg_norec_readTVar#(R1) returns to cbaD, args: 8, res: 8, upd: 8;
  cbaD:
      _saBF::P64 = R1;
      Hp = Hp + 16;
      if (Hp > HpLim) goto cbaM; else goto cbaL;
  cbaM:
      HpAlloc = 16;
      R1 = _saBF::P64;
      call stg_gc_unpt_r1(R1) returns to cbaD, args: 8, res: 8, upd: 8;
  cbaL:
      I64[Hp - 8] = GHC.Base.Just_con_info;
      P64[Hp] = _saBF::P64;
      _cbaF::P64 = Hp - 6;
      R1 = _cbaF::P64;
      Sp = Sp + 8;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
  cbai:
      _cbcQ::I64 = _saB0::I64 - 1;
      _saBv::I64 = _cbcQ::I64;
      _saAi::P64 = _saB5::P64;
      _saAh::I64 = _saB4::I64;
      _saAg::I64 = _saB9::I64;
      _saAf::I64 = _saB7::I64;
      _saAe::I64 = _saBv::I64;
      goto ubcY;
  ubcY:
      Sp = Sp - 24;
      goto cbb1;
  cbb1:
      Hp = Hp + 32;
      if (Hp > HpLim) goto cbb6; else goto cbb5;
  cbb6:
      HpAlloc = 32;
      I64[Sp + 24] = cbb2;
      P64[Sp + 32] = _saAi::P64;
      I64[Sp + 40] = _saAh::I64;
      I64[Sp + 48] = _saAg::I64;
      I64[Sp + 56] = _saAf::I64;
      I64[Sp + 72] = _saAe::I64;
      Sp = Sp + 24;
      call stg_gc_noregs() returns to cbb2, args: 8, res: 8, upd: 8;
  cbb2:
      _saA2::P64 = P64[Sp + 40];
      _saA5::P64 = P64[Sp + 56];
      _saAe::I64 = I64[Sp + 48];
      _saAf::I64 = I64[Sp + 32];
      _saAg::I64 = I64[Sp + 24];
      _saAh::I64 = I64[Sp + 16];
      _saAi::P64 = P64[Sp + 8];
      goto ubcZ;
  ubcZ:
      Sp = Sp - 24;
      goto cbb1;
  cbb5:
      _saAk::I64 = _saAe::I64;
      if (_saAk::I64 != 0) goto cbcK; else goto cbcL;
  cbcK:
      _cbb9::I64 = %MO_S_Le_W64(_saAf::I64, _saAk::I64);
      _saAl::I64 = _cbb9::I64;
      if (_saAl::I64 != 0) goto cbcI; else goto cbbh;
  cbcI:
      _cbbj::I64 = %MO_S_Le_W64(_saAk::I64, _saAg::I64);
      _saAq::I64 = _cbbj::I64;
      if (_saAq::I64 != 0) goto cbcH; else goto cbbr;
  cbcH:
      _cbbt::I64 = _saAk::I64 - _saAf::I64;
      _saAv::I64 = _cbbt::I64;
      _cbbw::I64 = %MO_S_Le_W64(0, _saAv::I64);
      _saAw::I64 = _cbbw::I64;
      if (_saAw::I64 != 0) goto cbcG; else goto cbbJ;
  cbcG:
      _cbbE::I64 = %MO_S_Lt_W64(_saAv::I64, _saAh::I64);
      _saAz::I64 = _cbbE::I64;
      if (_saAz::I64 != 0) goto cbbN; else goto cbbJ;
  cbbN:
      _saAD::P64 = P64[(_saAi::P64 + 24) + (_saAv::I64 << 3)];
      _saAD::P64 = _saAD::P64;
      Hp = Hp - 32;
      I64[Sp + 24] = cbbM;
      R1 = _saAD::P64;
      I64[Sp + 32] = _saAk::I64;
      P64[Sp + 40] = _saAi::P64;
      I64[Sp + 48] = _saAh::I64;
      I64[Sp + 56] = _saAg::I64;
      I64[Sp + 72] = _saAf::I64;
      Sp = Sp + 24;
      if (R1 & 7 != 0) goto cbbM; else goto cbbO;
  cbbO:
      call (I64[R1])(R1) returns to cbbM, args: 8, res: 8, upd: 8;
  cbbM:
      _saA2::P64 = P64[Sp + 40];
      _saA5::P64 = P64[Sp + 56];
      _saAf::I64 = I64[Sp + 48];
      _saAg::I64 = I64[Sp + 32];
      _saAh::I64 = I64[Sp + 24];
      _saAi::P64 = P64[Sp + 16];
      _saAk::I64 = I64[Sp + 8];
      _saAE::P64 = R1;
      _saAF::P64 = P64[_saAE::P64 + 7];
      I64[Sp] = cbbS;
      R1 = _saAF::P64;
      call stg_norec_readTVar#(R1) returns to cbbS, args: 8, res: 8, upd: 8;
  cbbS:
      _saA2::P64 = P64[Sp + 40];
      _saA5::P64 = P64[Sp + 56];
      _saAf::I64 = I64[Sp + 48];
      _saAg::I64 = I64[Sp + 32];
      _saAh::I64 = I64[Sp + 24];
      _saAi::P64 = P64[Sp + 16];
      _saAk::I64 = I64[Sp + 8];
      _saAI::P64 = R1;
      I64[Sp] = cbbU;
      R1 = _saAI::P64;
      if (R1 & 7 != 0) goto cbbU; else goto cbbX;
  cbbX:
      call (I64[R1])(R1) returns to cbbU, args: 8, res: 8, upd: 8;
  cbbU:
      _saA2::P64 = P64[Sp + 40];
      _saA5::P64 = P64[Sp + 56];
      _saAf::I64 = I64[Sp + 48];
      _saAg::I64 = I64[Sp + 32];
      _saAh::I64 = I64[Sp + 24];
      _saAi::P64 = P64[Sp + 16];
      _saAk::I64 = I64[Sp + 8];
      _saAJ::P64 = R1;
      _cbcR::P64 = _saAJ::P64 & 7;
      if (_cbcR::P64 != 1) goto cbc8; else goto cbc3;
  cbc8:
      _saAL::P64 = P64[_saAJ::P64 + 6];
      _saAM::P64 = P64[_saAJ::P64 + 14];
      _saAN::P64 = P64[_saAJ::P64 + 22];
      I64[Sp - 24] = cbc6;
      R2 = _saA2::P64;
      I64[Sp - 48] = stg_ap_pp_info;
      P64[Sp - 40] = _saAL::P64;
      P64[Sp - 32] = _saA5::P64;
      P64[Sp - 16] = _saAM::P64;
      P64[Sp - 8] = _saAN::P64;
      P64[Sp] = _saAL::P64;
      Sp = Sp - 48;
      call GHC.Classes.>_info(R2) returns to cbc6, args: 32, res: 8, upd: 8;
  cbc6:
      _saA2::P64 = P64[Sp + 64];
      _saA5::P64 = P64[Sp + 80];
      _saAf::I64 = I64[Sp + 72];
      _saAg::I64 = I64[Sp + 56];
      _saAh::I64 = I64[Sp + 48];
      _saAi::P64 = P64[Sp + 40];
      _saAk::I64 = I64[Sp + 32];
      _saAL::P64 = P64[Sp + 24];
      _saAM::P64 = P64[Sp + 8];
      _saAN::P64 = P64[Sp + 16];
      _saAO::P64 = R1;
      _cbcS::P64 = _saAO::P64 & 7;
      if (_cbcS::P64 != 1) goto cbcF; else goto cbcf;
  cbcF:
      _cbcT::I64 = _saAk::I64 - 1;
      _saAW::I64 = _cbcT::I64;
      _saAi::P64 = _saAi::P64;
      _saAh::I64 = _saAh::I64;
      _saAg::I64 = _saAg::I64;
      _saAf::I64 = _saAf::I64;
      _saAe::I64 = _saAW::I64;
      goto cbb1;
  cbcf:
      I64[Sp] = cbcc;
      R2 = _saA2::P64;
      I64[Sp - 24] = stg_ap_pp_info;
      P64[Sp - 16] = _saAL::P64;
      P64[Sp - 8] = _saA5::P64;
      Sp = Sp - 24;
      call GHC.Classes.<_info(R2) returns to cbcc, args: 32, res: 8, upd: 8;
  cbcc:
      _saA2::P64 = P64[Sp + 64];
      _saA5::P64 = P64[Sp + 80];
      _saAk::I64 = I64[Sp + 32];
      _saAM::P64 = P64[Sp + 8];
      _saAN::P64 = P64[Sp + 16];
      _saAP::P64 = R1;
      _cbcU::P64 = _saAP::P64 & 7;
      if (_cbcU::P64 != 1) goto cbcB; else goto cbct;
  cbcB:
      _saAY::P64 = _saAN::P64;
      _saAX::I64 = _saAk::I64;
      goto ubd0;
  ubd0:
      Sp = Sp + 56;
      goto cb92;
  cbct:
      I64[Sp + 80] = cbcj;
      R1 = _saAM::P64;
      Sp = Sp + 80;
      if (R1 & 7 != 0) goto cbcj; else goto cbck;
  cbck:
      call (I64[R1])(R1) returns to cbcj, args: 8, res: 8, upd: 8;
  cbcj:
      _saAQ::P64 = R1;
      _saAR::P64 = P64[_saAQ::P64 + 7];
      I64[Sp] = cbco;
      R1 = _saAR::P64;
      call stg_norec_readTVar#(R1) returns to cbco, args: 8, res: 8, upd: 8;
  cbco:
      _saAU::P64 = R1;
      Hp = Hp + 16;
      if (Hp > HpLim) goto cbcx; else goto cbcw;
  cbcx:
      HpAlloc = 16;
      R1 = _saAU::P64;
      call stg_gc_unpt_r1(R1) returns to cbco, args: 8, res: 8, upd: 8;
  cbcw:
      I64[Hp - 8] = GHC.Base.Just_con_info;
      P64[Hp] = _saAU::P64;
      _cbcq::P64 = Hp - 6;
      R1 = _cbcq::P64;
      Sp = Sp + 8;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
  cbc3:
      _cbcV::I64 = _saAk::I64 - 1;
      _saAK::I64 = _cbcV::I64;
      _saAi::P64 = _saAi::P64;
      _saAh::I64 = _saAh::I64;
      _saAg::I64 = _saAg::I64;
      _saAf::I64 = _saAf::I64;
      _saAe::I64 = _saAK::I64;
      goto ubd1;
  ubd1:
      Sp = Sp - 24;
      goto cbb1;
  cbbJ:
      Hp = Hp - 32;
      R3 = _saAv::I64;
      R2 = _saAh::I64;
      Sp = Sp + 88;
      call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
  cbbr:
      I64[Hp - 24] = GHC.Types.I#_con_info;
      I64[Hp - 16] = _saAg::I64;
      _cbbo::P64 = Hp - 23;
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _saAf::I64;
      _cbbp::P64 = Hp - 7;
      R4 = _cbbo::P64;
      R3 = _cbbp::P64;
      R2 = _saAk::I64;
      Sp = Sp + 88;
      call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbbh:
      I64[Hp - 24] = GHC.Types.I#_con_info;
      I64[Hp - 16] = _saAg::I64;
      _cbbe::P64 = Hp - 23;
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _saAf::I64;
      _cbbf::P64 = Hp - 7;
      R4 = _cbbe::P64;
      R3 = _cbbf::P64;
      R2 = _saAk::I64;
      Sp = Sp + 88;
      call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbcL:
      Hp = Hp - 32;
      R1 = GHC.Base.Nothing_closure+1;
      Sp = Sp + 88;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
  cb9Y:
      R3 = _saBg::I64;
      R2 = _saB4::I64;
      Sp = Sp + 64;
      call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
  cb9F:
      R4 = _saB8::P64;
      R3 = _saB6::P64;
      R2 = _saB0::I64;
      Sp = Sp + 64;
      call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbaY:
      R1 = GHC.Base.Nothing_closure+1;
      Sp = Sp + 32;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:45.863779 UTC

{offset
  cb8S:
      _saA5::P64 = R5;
      _saA4::P64 = R4;
      _saA3::P64 = R3;
      _saA2::P64 = R2;
      if ((Sp + -112) < SpLim) goto cb8T; else goto cb8U;
  cb8U:
      if (HpLim == 0) goto cb8T; else goto cb8V;
  cb8T:
      R5 = _saA5::P64;
      R4 = _saA4::P64;
      R3 = _saA3::P64;
      R2 = _saA2::P64;
      R1 = SkipList.$wa3_closure;
      call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  cb8V:
      I64[Sp - 32] = cb8N;
      R1 = _saA4::P64;
      P64[Sp - 24] = _saA2::P64;
      P64[Sp - 16] = _saA3::P64;
      P64[Sp - 8] = _saA5::P64;
      Sp = Sp - 32;
      call stg_norec_readTVar#(R1) returns to cb8N, args: 8, res: 8, upd: 8;
  cb8N:
      I64[Sp] = cb8P;
      R1 = R1;
      if (R1 & 7 != 0) goto cb8P; else goto cb8Q;
  cb8Q:
      call (I64[R1])(R1) returns to cb8P, args: 8, res: 8, upd: 8;
  cb8P:
      _saAY::P64 = P64[Sp + 16];
      _saAX::I64 = I64[R1 + 7];
      goto cb92;
  cb92:
      if (HpLim == 0) goto cb95; else goto cbaZ;
  cb95:
      I64[Sp - 8] = cb93;
      P64[Sp] = _saAY::P64;
      I64[Sp + 16] = _saAX::I64;
      Sp = Sp - 8;
      call stg_gc_noregs() returns to cb93, args: 8, res: 8, upd: 8;
  cb93:
      goto ubcW;
  ubcW:
      _saAX::I64 = I64[Sp + 24];
      _saAY::P64 = P64[Sp + 8];
      Sp = Sp + 8;
      goto cb92;
  cbaZ:
      if (_saAX::I64 != 0) goto cb9k; else goto cbaY;
  cb9k:
      I64[Sp] = cb98;
      R1 = _saAY::P64;
      I64[Sp + 16] = _saAX::I64;
      if (R1 & 7 != 0) goto cb98; else goto cb99;
  cb99:
      call (I64[R1])(R1) returns to cb98, args: 8, res: 8, upd: 8;
  cb98:
      I64[Sp - 24] = cb9d;
      _saB3::P64 = P64[R1 + 15];
      _saB5::P64 = P64[R1 + 23];
      _saB4::I64 = I64[R1 + 31];
      R1 = P64[R1 + 7];
      I64[Sp - 16] = _saB4::I64;
      P64[Sp - 8] = _saB5::P64;
      P64[Sp] = _saB3::P64;
      Sp = Sp - 24;
      if (R1 & 7 != 0) goto cb9d; else goto cb9e;
  cb9e:
      call (I64[R1])(R1) returns to cb9d, args: 8, res: 8, upd: 8;
  cb9d:
      I64[Sp - 8] = cb9i;
      _saB6::P64 = R1;
      _saB7::I64 = I64[R1 + 7];
      R1 = P64[Sp + 24];
      I64[Sp] = _saB7::I64;
      P64[Sp + 24] = _saB6::P64;
      Sp = Sp - 8;
      if (R1 & 7 != 0) goto cb9i; else goto cb9n;
  cb9n:
      call (I64[R1])(R1) returns to cb9i, args: 8, res: 8, upd: 8;
  cb9i:
      _saB0::I64 = I64[Sp + 48];
      _saB6::P64 = P64[Sp + 32];
      _saB7::I64 = I64[Sp + 8];
      _saB8::P64 = R1;
      if (%MO_S_Le_W64(_saB7::I64,
                       _saB0::I64)) goto cbaX; else goto cb9F;
  cbaX:
      _saB9::I64 = I64[R1 + 7];
      if (%MO_S_Le_W64(_saB0::I64,
                       _saB9::I64)) goto cbaW; else goto cb9F;
  cbaW:
      _saB4::I64 = I64[Sp + 16];
      _saBg::I64 = _saB0::I64 - _saB7::I64;
      if (%MO_S_Le_W64(0, _saBg::I64)) goto cbaV; else goto cb9Y;
  cbaV:
      if (%MO_S_Lt_W64(_saBg::I64,
                       _saB4::I64)) goto cba2; else goto cb9Y;
  cba2:
      _saBo::P64 = P64[P64[Sp + 24] + ((_saBg::I64 << 3) + 24)];
      I64[Sp] = cba1;
      R1 = _saBo::P64;
      I64[Sp + 32] = _saB9::I64;
      if (R1 & 7 != 0) goto cba1; else goto cba3;
  cba3:
      call (I64[R1])(R1) returns to cba1, args: 8, res: 8, upd: 8;
  cba1:
      I64[Sp] = cba7;
      R1 = P64[R1 + 7];
      call stg_norec_readTVar#(R1) returns to cba7, args: 8, res: 8, upd: 8;
  cba7:
      I64[Sp] = cba9;
      R1 = R1;
      if (R1 & 7 != 0) goto cba9; else goto cbac;
  cbac:
      call (I64[R1])(R1) returns to cba9, args: 8, res: 8, upd: 8;
  cba9:
      if (R1 & 7 != 1) goto cban; else goto cbai;
  cban:
      I64[Sp - 24] = cbal;
      R2 = P64[Sp + 40];
      I64[Sp - 48] = stg_ap_pp_info;
      _saBw::P64 = P64[R1 + 6];
      P64[Sp - 40] = _saBw::P64;
      P64[Sp - 32] = P64[Sp + 56];
      P64[Sp - 16] = P64[R1 + 14];
      P64[Sp - 8] = P64[R1 + 22];
      P64[Sp] = _saBw::P64;
      Sp = Sp - 48;
      call GHC.Classes.>_info(R2) returns to cbal, args: 32, res: 8, upd: 8;
  cbal:
      if (R1 & 7 != 1) goto cbaU; else goto cbau;
  cbaU:
      _saAi::P64 = P64[Sp + 48];
      _saAh::I64 = I64[Sp + 40];
      _saAg::I64 = I64[Sp + 56];
      _saAf::I64 = I64[Sp + 32];
      _saAe::I64 = I64[Sp + 72] - 1;
      goto cbb1;
  cbau:
      I64[Sp] = cbar;
      R2 = P64[Sp + 64];
      I64[Sp - 24] = stg_ap_pp_info;
      P64[Sp - 16] = P64[Sp + 24];
      P64[Sp - 8] = P64[Sp + 80];
      Sp = Sp - 24;
      call GHC.Classes.<_info(R2) returns to cbar, args: 32, res: 8, upd: 8;
  cbar:
      if (R1 & 7 != 1) goto cbaQ; else goto cbaI;
  cbaQ:
      goto ubcX;
  ubcX:
      _saAY::P64 = P64[Sp + 16];
      _saAX::I64 = I64[Sp + 72];
      Sp = Sp + 56;
      goto cb92;
  cbaI:
      I64[Sp + 80] = cbay;
      R1 = P64[Sp + 8];
      Sp = Sp + 80;
      if (R1 & 7 != 0) goto cbay; else goto cbaz;
  cbaz:
      call (I64[R1])(R1) returns to cbay, args: 8, res: 8, upd: 8;
  cbay:
      I64[Sp] = cbaD;
      R1 = P64[R1 + 7];
      call stg_norec_readTVar#(R1) returns to cbaD, args: 8, res: 8, upd: 8;
  cbaD:
      Hp = Hp + 16;
      if (Hp > HpLim) goto cbaM; else goto cbaL;
  cbaM:
      HpAlloc = 16;
      R1 = R1;
      call stg_gc_unpt_r1(R1) returns to cbaD, args: 8, res: 8, upd: 8;
  cbaL:
      I64[Hp - 8] = GHC.Base.Just_con_info;
      P64[Hp] = R1;
      R1 = Hp - 6;
      Sp = Sp + 8;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
  cbai:
      goto ubcY;
  ubcY:
      _saAi::P64 = P64[Sp + 24];
      _saAh::I64 = I64[Sp + 16];
      _saAg::I64 = I64[Sp + 32];
      _saAf::I64 = I64[Sp + 8];
      _saAe::I64 = I64[Sp + 48] - 1;
      Sp = Sp - 24;
      goto cbb1;
  cbb1:
      Hp = Hp + 32;
      if (Hp > HpLim) goto cbb6; else goto cbb5;
  cbb6:
      HpAlloc = 32;
      I64[Sp + 24] = cbb2;
      P64[Sp + 32] = _saAi::P64;
      I64[Sp + 40] = _saAh::I64;
      I64[Sp + 48] = _saAg::I64;
      I64[Sp + 56] = _saAf::I64;
      I64[Sp + 72] = _saAe::I64;
      Sp = Sp + 24;
      call stg_gc_noregs() returns to cbb2, args: 8, res: 8, upd: 8;
  cbb2:
      goto ubcZ;
  ubcZ:
      _saAe::I64 = I64[Sp + 48];
      _saAf::I64 = I64[Sp + 32];
      _saAg::I64 = I64[Sp + 24];
      _saAh::I64 = I64[Sp + 16];
      _saAi::P64 = P64[Sp + 8];
      Sp = Sp - 24;
      goto cbb1;
  cbb5:
      if (_saAe::I64 != 0) goto cbcK; else goto cbcL;
  cbcK:
      if (%MO_S_Le_W64(_saAf::I64,
                       _saAe::I64)) goto cbcI; else goto cbbh;
  cbcI:
      if (%MO_S_Le_W64(_saAe::I64,
                       _saAg::I64)) goto cbcH; else goto cbbr;
  cbcH:
      _saAv::I64 = _saAe::I64 - _saAf::I64;
      if (%MO_S_Le_W64(0, _saAv::I64)) goto cbcG; else goto cbbJ;
  cbcG:
      if (%MO_S_Lt_W64(_saAv::I64,
                       _saAh::I64)) goto cbbN; else goto cbbJ;
  cbbN:
      Hp = Hp - 32;
      _saAD::P64 = P64[(_saAi::P64 + 24) + (_saAv::I64 << 3)];
      I64[Sp + 24] = cbbM;
      R1 = _saAD::P64;
      I64[Sp + 32] = _saAe::I64;
      P64[Sp + 40] = _saAi::P64;
      I64[Sp + 48] = _saAh::I64;
      I64[Sp + 56] = _saAg::I64;
      I64[Sp + 72] = _saAf::I64;
      Sp = Sp + 24;
      if (R1 & 7 != 0) goto cbbM; else goto cbbO;
  cbbO:
      call (I64[R1])(R1) returns to cbbM, args: 8, res: 8, upd: 8;
  cbbM:
      I64[Sp] = cbbS;
      R1 = P64[R1 + 7];
      call stg_norec_readTVar#(R1) returns to cbbS, args: 8, res: 8, upd: 8;
  cbbS:
      I64[Sp] = cbbU;
      R1 = R1;
      if (R1 & 7 != 0) goto cbbU; else goto cbbX;
  cbbX:
      call (I64[R1])(R1) returns to cbbU, args: 8, res: 8, upd: 8;
  cbbU:
      if (R1 & 7 != 1) goto cbc8; else goto cbc3;
  cbc8:
      I64[Sp - 24] = cbc6;
      R2 = P64[Sp + 40];
      I64[Sp - 48] = stg_ap_pp_info;
      _saAL::P64 = P64[R1 + 6];
      P64[Sp - 40] = _saAL::P64;
      P64[Sp - 32] = P64[Sp + 56];
      P64[Sp - 16] = P64[R1 + 14];
      P64[Sp - 8] = P64[R1 + 22];
      P64[Sp] = _saAL::P64;
      Sp = Sp - 48;
      call GHC.Classes.>_info(R2) returns to cbc6, args: 32, res: 8, upd: 8;
  cbc6:
      if (R1 & 7 != 1) goto cbcF; else goto cbcf;
  cbcF:
      _saAf::I64 = I64[Sp + 72];
      _saAg::I64 = I64[Sp + 56];
      _saAh::I64 = I64[Sp + 48];
      _saAi::P64 = P64[Sp + 40];
      _saAe::I64 = I64[Sp + 32] - 1;
      goto cbb1;
  cbcf:
      I64[Sp] = cbcc;
      R2 = P64[Sp + 64];
      I64[Sp - 24] = stg_ap_pp_info;
      P64[Sp - 16] = P64[Sp + 24];
      P64[Sp - 8] = P64[Sp + 80];
      Sp = Sp - 24;
      call GHC.Classes.<_info(R2) returns to cbcc, args: 32, res: 8, upd: 8;
  cbcc:
      if (R1 & 7 != 1) goto cbcB; else goto cbct;
  cbcB:
      goto ubd0;
  ubd0:
      _saAY::P64 = P64[Sp + 16];
      _saAX::I64 = I64[Sp + 32];
      Sp = Sp + 56;
      goto cb92;
  cbct:
      I64[Sp + 80] = cbcj;
      R1 = P64[Sp + 8];
      Sp = Sp + 80;
      if (R1 & 7 != 0) goto cbcj; else goto cbck;
  cbck:
      call (I64[R1])(R1) returns to cbcj, args: 8, res: 8, upd: 8;
  cbcj:
      I64[Sp] = cbco;
      R1 = P64[R1 + 7];
      call stg_norec_readTVar#(R1) returns to cbco, args: 8, res: 8, upd: 8;
  cbco:
      Hp = Hp + 16;
      if (Hp > HpLim) goto cbcx; else goto cbcw;
  cbcx:
      HpAlloc = 16;
      R1 = R1;
      call stg_gc_unpt_r1(R1) returns to cbco, args: 8, res: 8, upd: 8;
  cbcw:
      I64[Hp - 8] = GHC.Base.Just_con_info;
      P64[Hp] = R1;
      R1 = Hp - 6;
      Sp = Sp + 8;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
  cbc3:
      goto ubd1;
  ubd1:
      _saAf::I64 = I64[Sp + 48];
      _saAg::I64 = I64[Sp + 32];
      _saAh::I64 = I64[Sp + 24];
      _saAi::P64 = P64[Sp + 16];
      _saAe::I64 = I64[Sp + 8] - 1;
      Sp = Sp - 24;
      goto cbb1;
  cbbJ:
      Hp = Hp - 32;
      R3 = _saAv::I64;
      R2 = _saAh::I64;
      Sp = Sp + 88;
      call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
  cbbr:
      I64[Hp - 24] = GHC.Types.I#_con_info;
      I64[Hp - 16] = _saAg::I64;
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _saAf::I64;
      R4 = Hp - 23;
      R3 = Hp - 7;
      R2 = _saAe::I64;
      Sp = Sp + 88;
      call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbbh:
      I64[Hp - 24] = GHC.Types.I#_con_info;
      I64[Hp - 16] = _saAg::I64;
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _saAf::I64;
      R4 = Hp - 23;
      R3 = Hp - 7;
      R2 = _saAe::I64;
      Sp = Sp + 88;
      call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbcL:
      Hp = Hp - 32;
      R1 = GHC.Base.Nothing_closure+1;
      Sp = Sp + 88;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
  cb9Y:
      R3 = _saBg::I64;
      R2 = _saB4::I64;
      Sp = Sp + 64;
      call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
  cb9F:
      R4 = _saB8::P64;
      R3 = _saB6::P64;
      R2 = _saB0::I64;
      Sp = Sp + 64;
      call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbaY:
      R1 = GHC.Base.Nothing_closure+1;
      Sp = Sp + 32;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:45.884933 UTC

[(cb8N, {lvl20_rawe_closure, lvl29_rawn_closure}),
 (cb8P, {lvl20_rawe_closure, lvl29_rawn_closure}),
 (cb8Q, {lvl20_rawe_closure, lvl29_rawn_closure}),
 (cb8S,
  {SkipList.$wa3_closure, lvl20_rawe_closure, lvl29_rawn_closure}),
 (cb8T, {SkipList.$wa3_closure}),
 (cb8U,
  {SkipList.$wa3_closure, lvl20_rawe_closure, lvl29_rawn_closure}),
 (cb8V, {lvl20_rawe_closure, lvl29_rawn_closure}),
 (cb92, {lvl20_rawe_closure, lvl29_rawn_closure}),
 (cb93, {lvl20_rawe_closure, lvl29_rawn_closure}),
 (cb95, {lvl20_rawe_closure, lvl29_rawn_closure}),
 (cb98, {lvl20_rawe_closure, lvl29_rawn_closure}),
 (cb99, {lvl20_rawe_closure, lvl29_rawn_closure}),
 (cb9d, {lvl20_rawe_closure, lvl29_rawn_closure}),
 (cb9e, {lvl20_rawe_closure, lvl29_rawn_closure}),
 (cb9i, {lvl20_rawe_closure, lvl29_rawn_closure}),
 (cb9k, {lvl20_rawe_closure, lvl29_rawn_closure}),
 (cb9n, {lvl20_rawe_closure, lvl29_rawn_closure}),
 (cb9F, {lvl20_rawe_closure}), (cb9Y, {lvl29_rawn_closure}),
 (cba1, {lvl20_rawe_closure, lvl29_rawn_closure}),
 (cba2, {lvl20_rawe_closure, lvl29_rawn_closure}),
 (cba3, {lvl20_rawe_closure, lvl29_rawn_closure}),
 (cba7, {lvl20_rawe_closure, lvl29_rawn_closure}),
 (cba9, {lvl20_rawe_closure, lvl29_rawn_closure}),
 (cbac, {lvl20_rawe_closure, lvl29_rawn_closure}),
 (cbai, {lvl20_rawe_closure, lvl29_rawn_closure}),
 (cbal, {lvl20_rawe_closure, lvl29_rawn_closure}),
 (cban, {lvl20_rawe_closure, lvl29_rawn_closure}),
 (cbar, {lvl20_rawe_closure, lvl29_rawn_closure}),
 (cbau, {lvl20_rawe_closure, lvl29_rawn_closure}), (cbay, {}),
 (cbaz, {}), (cbaD, {}), (cbaI, {}), (cbaL, {}), (cbaM, {}),
 (cbaQ, {lvl20_rawe_closure, lvl29_rawn_closure}),
 (cbaU, {lvl20_rawe_closure, lvl29_rawn_closure}),
 (cbaV, {lvl20_rawe_closure, lvl29_rawn_closure}),
 (cbaW, {lvl20_rawe_closure, lvl29_rawn_closure}),
 (cbaX, {lvl20_rawe_closure, lvl29_rawn_closure}), (cbaY, {}),
 (cbaZ, {lvl20_rawe_closure, lvl29_rawn_closure}),
 (cbb1, {lvl20_rawe_closure, lvl29_rawn_closure}),
 (cbb2, {lvl20_rawe_closure, lvl29_rawn_closure}),
 (cbb5, {lvl20_rawe_closure, lvl29_rawn_closure}),
 (cbb6, {lvl20_rawe_closure, lvl29_rawn_closure}),
 (cbbh, {lvl20_rawe_closure}), (cbbr, {lvl20_rawe_closure}),
 (cbbJ, {lvl29_rawn_closure}),
 (cbbM, {lvl20_rawe_closure, lvl29_rawn_closure}),
 (cbbN, {lvl20_rawe_closure, lvl29_rawn_closure}),
 (cbbO, {lvl20_rawe_closure, lvl29_rawn_closure}),
 (cbbS, {lvl20_rawe_closure, lvl29_rawn_closure}),
 (cbbU, {lvl20_rawe_closure, lvl29_rawn_closure}),
 (cbbX, {lvl20_rawe_closure, lvl29_rawn_closure}),
 (cbc3, {lvl20_rawe_closure, lvl29_rawn_closure}),
 (cbc6, {lvl20_rawe_closure, lvl29_rawn_closure}),
 (cbc8, {lvl20_rawe_closure, lvl29_rawn_closure}),
 (cbcc, {lvl20_rawe_closure, lvl29_rawn_closure}),
 (cbcf, {lvl20_rawe_closure, lvl29_rawn_closure}), (cbcj, {}),
 (cbck, {}), (cbco, {}), (cbct, {}), (cbcw, {}), (cbcx, {}),
 (cbcB, {lvl20_rawe_closure, lvl29_rawn_closure}),
 (cbcF, {lvl20_rawe_closure, lvl29_rawn_closure}),
 (cbcG, {lvl20_rawe_closure, lvl29_rawn_closure}),
 (cbcH, {lvl20_rawe_closure, lvl29_rawn_closure}),
 (cbcI, {lvl20_rawe_closure, lvl29_rawn_closure}),
 (cbcK, {lvl20_rawe_closure, lvl29_rawn_closure}), (cbcL, {}),
 (ubcW, {lvl20_rawe_closure, lvl29_rawn_closure}),
 (ubcX, {lvl20_rawe_closure, lvl29_rawn_closure}),
 (ubcY, {lvl20_rawe_closure, lvl29_rawn_closure}),
 (ubcZ, {lvl20_rawe_closure, lvl29_rawn_closure}),
 (ubd0, {lvl20_rawe_closure, lvl29_rawn_closure}),
 (ubd1, {lvl20_rawe_closure, lvl29_rawn_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:45.891341 UTC

SkipList.$wa3_entry() //  [R5, R4, R3, R2]
        { info_tbl: [(cb8N,
                      label: block_cb8N_info
                      rep:StackRep [False, False, False]),
                     (cb8P,
                      label: block_cb8P_info
                      rep:StackRep [False, False, False]),
                     (cb8S,
                      label: SkipList.$wa3_info
                      rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} }),
                     (cb93,
                      label: block_cb93_info
                      rep:StackRep [False, False, True, False]),
                     (cb98,
                      label: block_cb98_info
                      rep:StackRep [False, True, False]),
                     (cb9d,
                      label: block_cb9d_info
                      rep:StackRep [True, False, False, False, True, False]),
                     (cb9i,
                      label: block_cb9i_info
                      rep:StackRep [True, True, False, False, False, True, False]),
                     (cba1,
                      label: block_cba1_info
                      rep:StackRep [True, True, False, True, False, True, False]),
                     (cba7,
                      label: block_cba7_info
                      rep:StackRep [True, True, False, True, False, True, False]),
                     (cba9,
                      label: block_cba9_info
                      rep:StackRep [True, True, False, True, False, True, False]),
                     (cbal,
                      label: block_cbal_info
                      rep:StackRep [False, False, False, True, True, False, True, False,
                                    True, False]),
                     (cbar,
                      label: block_cbar_info
                      rep:StackRep [False, False, True, True, True, True, True, False,
                                    True, False]),
                     (cbay,
                      label: block_cbay_info
                      rep:StackRep []),
                     (cbaD,
                      label: block_cbaD_info
                      rep:StackRep []),
                     (cbb2,
                      label: block_cbb2_info
                      rep:StackRep [False, True, True, True, False, True, False]),
                     (cbbM,
                      label: block_cbbM_info
                      rep:StackRep [True, False, True, True, False, True, False]),
                     (cbbS,
                      label: block_cbbS_info
                      rep:StackRep [True, False, True, True, False, True, False]),
                     (cbbU,
                      label: block_cbbU_info
                      rep:StackRep [True, False, True, True, False, True, False]),
                     (cbc6,
                      label: block_cbc6_info
                      rep:StackRep [False, False, False, True, False, True, True, False,
                                    True, False]),
                     (cbcc,
                      label: block_cbcc_info
                      rep:StackRep [False, False, True, True, True, True, True, False,
                                    True, False]),
                     (cbcj,
                      label: block_cbcj_info
                      rep:StackRep []),
                     (cbco,
                      label: block_cbco_info
                      rep:StackRep [])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cb8S:
          _saA5::P64 = R5;
          _saA4::P64 = R4;
          _saA3::P64 = R3;
          _saA2::P64 = R2;
          if ((Sp + -112) < SpLim) goto cb8T; else goto cb8U;
      cb8U:
          if (HpLim == 0) goto cb8T; else goto cb8V;
      cb8T:
          R5 = _saA5::P64;
          R4 = _saA4::P64;
          R3 = _saA3::P64;
          R2 = _saA2::P64;
          R1 = SkipList.$wa3_closure;
          call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
      cb8V:
          I64[Sp - 32] = cb8N;
          R1 = _saA4::P64;
          P64[Sp - 24] = _saA2::P64;
          P64[Sp - 16] = _saA3::P64;
          P64[Sp - 8] = _saA5::P64;
          Sp = Sp - 32;
          call stg_norec_readTVar#(R1) returns to cb8N, args: 8, res: 8, upd: 8;
      cb8N:
          I64[Sp] = cb8P;
          R1 = R1;
          if (R1 & 7 != 0) goto cb8P; else goto cb8Q;
      cb8Q:
          call (I64[R1])(R1) returns to cb8P, args: 8, res: 8, upd: 8;
      cb8P:
          _saAY::P64 = P64[Sp + 16];
          _saAX::I64 = I64[R1 + 7];
          goto cb92;
      cb92:
          if (HpLim == 0) goto cb95; else goto cbaZ;
      cb95:
          I64[Sp - 8] = cb93;
          P64[Sp] = _saAY::P64;
          I64[Sp + 16] = _saAX::I64;
          Sp = Sp - 8;
          call stg_gc_noregs() returns to cb93, args: 8, res: 8, upd: 8;
      cb93:
          goto ubcW;
      ubcW:
          _saAX::I64 = I64[Sp + 24];
          _saAY::P64 = P64[Sp + 8];
          Sp = Sp + 8;
          goto cb92;
      cbaZ:
          if (_saAX::I64 != 0) goto cb9k; else goto cbaY;
      cb9k:
          I64[Sp] = cb98;
          R1 = _saAY::P64;
          I64[Sp + 16] = _saAX::I64;
          if (R1 & 7 != 0) goto cb98; else goto cb99;
      cb99:
          call (I64[R1])(R1) returns to cb98, args: 8, res: 8, upd: 8;
      cb98:
          I64[Sp - 24] = cb9d;
          _saB3::P64 = P64[R1 + 15];
          _saB5::P64 = P64[R1 + 23];
          _saB4::I64 = I64[R1 + 31];
          R1 = P64[R1 + 7];
          I64[Sp - 16] = _saB4::I64;
          P64[Sp - 8] = _saB5::P64;
          P64[Sp] = _saB3::P64;
          Sp = Sp - 24;
          if (R1 & 7 != 0) goto cb9d; else goto cb9e;
      cb9e:
          call (I64[R1])(R1) returns to cb9d, args: 8, res: 8, upd: 8;
      cb9d:
          I64[Sp - 8] = cb9i;
          _saB6::P64 = R1;
          _saB7::I64 = I64[R1 + 7];
          R1 = P64[Sp + 24];
          I64[Sp] = _saB7::I64;
          P64[Sp + 24] = _saB6::P64;
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto cb9i; else goto cb9n;
      cb9n:
          call (I64[R1])(R1) returns to cb9i, args: 8, res: 8, upd: 8;
      cb9i:
          _saB0::I64 = I64[Sp + 48];
          _saB6::P64 = P64[Sp + 32];
          _saB7::I64 = I64[Sp + 8];
          _saB8::P64 = R1;
          if (%MO_S_Le_W64(_saB7::I64,
                           _saB0::I64)) goto cbaX; else goto cb9F;
      cbaX:
          _saB9::I64 = I64[R1 + 7];
          if (%MO_S_Le_W64(_saB0::I64,
                           _saB9::I64)) goto cbaW; else goto cb9F;
      cbaW:
          _saB4::I64 = I64[Sp + 16];
          _saBg::I64 = _saB0::I64 - _saB7::I64;
          if (%MO_S_Le_W64(0, _saBg::I64)) goto cbaV; else goto cb9Y;
      cbaV:
          if (%MO_S_Lt_W64(_saBg::I64,
                           _saB4::I64)) goto cba2; else goto cb9Y;
      cba2:
          _saBo::P64 = P64[P64[Sp + 24] + ((_saBg::I64 << 3) + 24)];
          I64[Sp] = cba1;
          R1 = _saBo::P64;
          I64[Sp + 32] = _saB9::I64;
          if (R1 & 7 != 0) goto cba1; else goto cba3;
      cba3:
          call (I64[R1])(R1) returns to cba1, args: 8, res: 8, upd: 8;
      cba1:
          I64[Sp] = cba7;
          R1 = P64[R1 + 7];
          call stg_norec_readTVar#(R1) returns to cba7, args: 8, res: 8, upd: 8;
      cba7:
          I64[Sp] = cba9;
          R1 = R1;
          if (R1 & 7 != 0) goto cba9; else goto cbac;
      cbac:
          call (I64[R1])(R1) returns to cba9, args: 8, res: 8, upd: 8;
      cba9:
          if (R1 & 7 != 1) goto cban; else goto cbai;
      cban:
          I64[Sp - 24] = cbal;
          R2 = P64[Sp + 40];
          I64[Sp - 48] = stg_ap_pp_info;
          _saBw::P64 = P64[R1 + 6];
          P64[Sp - 40] = _saBw::P64;
          P64[Sp - 32] = P64[Sp + 56];
          P64[Sp - 16] = P64[R1 + 14];
          P64[Sp - 8] = P64[R1 + 22];
          P64[Sp] = _saBw::P64;
          Sp = Sp - 48;
          call GHC.Classes.>_info(R2) returns to cbal, args: 32, res: 8, upd: 8;
      cbal:
          if (R1 & 7 != 1) goto cbaU; else goto cbau;
      cbaU:
          _saAi::P64 = P64[Sp + 48];
          _saAh::I64 = I64[Sp + 40];
          _saAg::I64 = I64[Sp + 56];
          _saAf::I64 = I64[Sp + 32];
          _saAe::I64 = I64[Sp + 72] - 1;
          goto cbb1;
      cbau:
          I64[Sp] = cbar;
          R2 = P64[Sp + 64];
          I64[Sp - 24] = stg_ap_pp_info;
          P64[Sp - 16] = P64[Sp + 24];
          P64[Sp - 8] = P64[Sp + 80];
          Sp = Sp - 24;
          call GHC.Classes.<_info(R2) returns to cbar, args: 32, res: 8, upd: 8;
      cbar:
          if (R1 & 7 != 1) goto cbaQ; else goto cbaI;
      cbaQ:
          goto ubcX;
      ubcX:
          _saAY::P64 = P64[Sp + 16];
          _saAX::I64 = I64[Sp + 72];
          Sp = Sp + 56;
          goto cb92;
      cbaI:
          I64[Sp + 80] = cbay;
          R1 = P64[Sp + 8];
          Sp = Sp + 80;
          if (R1 & 7 != 0) goto cbay; else goto cbaz;
      cbaz:
          call (I64[R1])(R1) returns to cbay, args: 8, res: 8, upd: 8;
      cbay:
          I64[Sp] = cbaD;
          R1 = P64[R1 + 7];
          call stg_norec_readTVar#(R1) returns to cbaD, args: 8, res: 8, upd: 8;
      cbaD:
          Hp = Hp + 16;
          if (Hp > HpLim) goto cbaM; else goto cbaL;
      cbaM:
          HpAlloc = 16;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to cbaD, args: 8, res: 8, upd: 8;
      cbaL:
          I64[Hp - 8] = GHC.Base.Just_con_info;
          P64[Hp] = R1;
          R1 = Hp - 6;
          Sp = Sp + 8;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
      cbai:
          goto ubcY;
      ubcY:
          _saAi::P64 = P64[Sp + 24];
          _saAh::I64 = I64[Sp + 16];
          _saAg::I64 = I64[Sp + 32];
          _saAf::I64 = I64[Sp + 8];
          _saAe::I64 = I64[Sp + 48] - 1;
          Sp = Sp - 24;
          goto cbb1;
      cbb1:
          Hp = Hp + 32;
          if (Hp > HpLim) goto cbb6; else goto cbb5;
      cbb6:
          HpAlloc = 32;
          I64[Sp + 24] = cbb2;
          P64[Sp + 32] = _saAi::P64;
          I64[Sp + 40] = _saAh::I64;
          I64[Sp + 48] = _saAg::I64;
          I64[Sp + 56] = _saAf::I64;
          I64[Sp + 72] = _saAe::I64;
          Sp = Sp + 24;
          call stg_gc_noregs() returns to cbb2, args: 8, res: 8, upd: 8;
      cbb2:
          goto ubcZ;
      ubcZ:
          _saAe::I64 = I64[Sp + 48];
          _saAf::I64 = I64[Sp + 32];
          _saAg::I64 = I64[Sp + 24];
          _saAh::I64 = I64[Sp + 16];
          _saAi::P64 = P64[Sp + 8];
          Sp = Sp - 24;
          goto cbb1;
      cbb5:
          if (_saAe::I64 != 0) goto cbcK; else goto cbcL;
      cbcK:
          if (%MO_S_Le_W64(_saAf::I64,
                           _saAe::I64)) goto cbcI; else goto cbbh;
      cbcI:
          if (%MO_S_Le_W64(_saAe::I64,
                           _saAg::I64)) goto cbcH; else goto cbbr;
      cbcH:
          _saAv::I64 = _saAe::I64 - _saAf::I64;
          if (%MO_S_Le_W64(0, _saAv::I64)) goto cbcG; else goto cbbJ;
      cbcG:
          if (%MO_S_Lt_W64(_saAv::I64,
                           _saAh::I64)) goto cbbN; else goto cbbJ;
      cbbN:
          Hp = Hp - 32;
          _saAD::P64 = P64[(_saAi::P64 + 24) + (_saAv::I64 << 3)];
          I64[Sp + 24] = cbbM;
          R1 = _saAD::P64;
          I64[Sp + 32] = _saAe::I64;
          P64[Sp + 40] = _saAi::P64;
          I64[Sp + 48] = _saAh::I64;
          I64[Sp + 56] = _saAg::I64;
          I64[Sp + 72] = _saAf::I64;
          Sp = Sp + 24;
          if (R1 & 7 != 0) goto cbbM; else goto cbbO;
      cbbO:
          call (I64[R1])(R1) returns to cbbM, args: 8, res: 8, upd: 8;
      cbbM:
          I64[Sp] = cbbS;
          R1 = P64[R1 + 7];
          call stg_norec_readTVar#(R1) returns to cbbS, args: 8, res: 8, upd: 8;
      cbbS:
          I64[Sp] = cbbU;
          R1 = R1;
          if (R1 & 7 != 0) goto cbbU; else goto cbbX;
      cbbX:
          call (I64[R1])(R1) returns to cbbU, args: 8, res: 8, upd: 8;
      cbbU:
          if (R1 & 7 != 1) goto cbc8; else goto cbc3;
      cbc8:
          I64[Sp - 24] = cbc6;
          R2 = P64[Sp + 40];
          I64[Sp - 48] = stg_ap_pp_info;
          _saAL::P64 = P64[R1 + 6];
          P64[Sp - 40] = _saAL::P64;
          P64[Sp - 32] = P64[Sp + 56];
          P64[Sp - 16] = P64[R1 + 14];
          P64[Sp - 8] = P64[R1 + 22];
          P64[Sp] = _saAL::P64;
          Sp = Sp - 48;
          call GHC.Classes.>_info(R2) returns to cbc6, args: 32, res: 8, upd: 8;
      cbc6:
          if (R1 & 7 != 1) goto cbcF; else goto cbcf;
      cbcF:
          _saAf::I64 = I64[Sp + 72];
          _saAg::I64 = I64[Sp + 56];
          _saAh::I64 = I64[Sp + 48];
          _saAi::P64 = P64[Sp + 40];
          _saAe::I64 = I64[Sp + 32] - 1;
          goto cbb1;
      cbcf:
          I64[Sp] = cbcc;
          R2 = P64[Sp + 64];
          I64[Sp - 24] = stg_ap_pp_info;
          P64[Sp - 16] = P64[Sp + 24];
          P64[Sp - 8] = P64[Sp + 80];
          Sp = Sp - 24;
          call GHC.Classes.<_info(R2) returns to cbcc, args: 32, res: 8, upd: 8;
      cbcc:
          if (R1 & 7 != 1) goto cbcB; else goto cbct;
      cbcB:
          goto ubd0;
      ubd0:
          _saAY::P64 = P64[Sp + 16];
          _saAX::I64 = I64[Sp + 32];
          Sp = Sp + 56;
          goto cb92;
      cbct:
          I64[Sp + 80] = cbcj;
          R1 = P64[Sp + 8];
          Sp = Sp + 80;
          if (R1 & 7 != 0) goto cbcj; else goto cbck;
      cbck:
          call (I64[R1])(R1) returns to cbcj, args: 8, res: 8, upd: 8;
      cbcj:
          I64[Sp] = cbco;
          R1 = P64[R1 + 7];
          call stg_norec_readTVar#(R1) returns to cbco, args: 8, res: 8, upd: 8;
      cbco:
          Hp = Hp + 16;
          if (Hp > HpLim) goto cbcx; else goto cbcw;
      cbcx:
          HpAlloc = 16;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to cbco, args: 8, res: 8, upd: 8;
      cbcw:
          I64[Hp - 8] = GHC.Base.Just_con_info;
          P64[Hp] = R1;
          R1 = Hp - 6;
          Sp = Sp + 8;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
      cbc3:
          goto ubd1;
      ubd1:
          _saAf::I64 = I64[Sp + 48];
          _saAg::I64 = I64[Sp + 32];
          _saAh::I64 = I64[Sp + 24];
          _saAi::P64 = P64[Sp + 16];
          _saAe::I64 = I64[Sp + 8] - 1;
          Sp = Sp - 24;
          goto cbb1;
      cbbJ:
          Hp = Hp - 32;
          R3 = _saAv::I64;
          R2 = _saAh::I64;
          Sp = Sp + 88;
          call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
      cbbr:
          I64[Hp - 24] = GHC.Types.I#_con_info;
          I64[Hp - 16] = _saAg::I64;
          I64[Hp - 8] = GHC.Types.I#_con_info;
          I64[Hp] = _saAf::I64;
          R4 = Hp - 23;
          R3 = Hp - 7;
          R2 = _saAe::I64;
          Sp = Sp + 88;
          call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
      cbbh:
          I64[Hp - 24] = GHC.Types.I#_con_info;
          I64[Hp - 16] = _saAg::I64;
          I64[Hp - 8] = GHC.Types.I#_con_info;
          I64[Hp] = _saAf::I64;
          R4 = Hp - 23;
          R3 = Hp - 7;
          R2 = _saAe::I64;
          Sp = Sp + 88;
          call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
      cbcL:
          Hp = Hp - 32;
          R1 = GHC.Base.Nothing_closure+1;
          Sp = Sp + 88;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
      cb9Y:
          R3 = _saBg::I64;
          R2 = _saB4::I64;
          Sp = Sp + 64;
          call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
      cb9F:
          R4 = _saB8::P64;
          R3 = _saB6::P64;
          R2 = _saB0::I64;
          Sp = Sp + 64;
          call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
      cbaY:
          R1 = GHC.Base.Nothing_closure+1;
          Sp = Sp + 32;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:45.913519 UTC

SkipList.$wa3_entry() //  [R5, R4, R3, R2]
        { info_tbl: [(cb8N,
                      label: block_cb8N_info
                      rep:StackRep [False, False, False]),
                     (cb8P,
                      label: block_cb8P_info
                      rep:StackRep [False, False, False]),
                     (cb8S,
                      label: SkipList.$wa3_info
                      rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} }),
                     (cb93,
                      label: block_cb93_info
                      rep:StackRep [False, False, True, False]),
                     (cb98,
                      label: block_cb98_info
                      rep:StackRep [False, True, False]),
                     (cb9d,
                      label: block_cb9d_info
                      rep:StackRep [True, False, False, False, True, False]),
                     (cb9i,
                      label: block_cb9i_info
                      rep:StackRep [True, True, False, False, False, True, False]),
                     (cba1,
                      label: block_cba1_info
                      rep:StackRep [True, True, False, True, False, True, False]),
                     (cba7,
                      label: block_cba7_info
                      rep:StackRep [True, True, False, True, False, True, False]),
                     (cba9,
                      label: block_cba9_info
                      rep:StackRep [True, True, False, True, False, True, False]),
                     (cbal,
                      label: block_cbal_info
                      rep:StackRep [False, False, False, True, True, False, True, False,
                                    True, False]),
                     (cbar,
                      label: block_cbar_info
                      rep:StackRep [False, False, True, True, True, True, True, False,
                                    True, False]),
                     (cbay,
                      label: block_cbay_info
                      rep:StackRep []),
                     (cbaD,
                      label: block_cbaD_info
                      rep:StackRep []),
                     (cbb2,
                      label: block_cbb2_info
                      rep:StackRep [False, True, True, True, False, True, False]),
                     (cbbM,
                      label: block_cbbM_info
                      rep:StackRep [True, False, True, True, False, True, False]),
                     (cbbS,
                      label: block_cbbS_info
                      rep:StackRep [True, False, True, True, False, True, False]),
                     (cbbU,
                      label: block_cbbU_info
                      rep:StackRep [True, False, True, True, False, True, False]),
                     (cbc6,
                      label: block_cbc6_info
                      rep:StackRep [False, False, False, True, False, True, True, False,
                                    True, False]),
                     (cbcc,
                      label: block_cbcc_info
                      rep:StackRep [False, False, True, True, True, True, True, False,
                                    True, False]),
                     (cbcj,
                      label: block_cbcj_info
                      rep:StackRep []),
                     (cbco,
                      label: block_cbco_info
                      rep:StackRep [])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cb8S:
          _saA5::P64 = R5;
          _saA4::P64 = R4;
          _saA3::P64 = R3;
          _saA2::P64 = R2;
          if ((Sp + -112) < SpLim) goto cb8T; else goto cb8U;
      cb8U:
          if (HpLim == 0) goto cb8T; else goto cb8V;
      cb8T:
          R5 = _saA5::P64;
          R4 = _saA4::P64;
          R3 = _saA3::P64;
          R2 = _saA2::P64;
          R1 = SkipList.$wa3_closure;
          call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
      cb8V:
          I64[Sp - 32] = cb8N;
          R1 = _saA4::P64;
          P64[Sp - 24] = _saA2::P64;
          P64[Sp - 16] = _saA3::P64;
          P64[Sp - 8] = _saA5::P64;
          Sp = Sp - 32;
          call stg_norec_readTVar#(R1) returns to cb8N, args: 8, res: 8, upd: 8;
      cb8N:
          I64[Sp] = cb8P;
          R1 = R1;
          if (R1 & 7 != 0) goto cb8P; else goto cb8Q;
      cb8Q:
          call (I64[R1])(R1) returns to cb8P, args: 8, res: 8, upd: 8;
      cb8P:
          _saAY::P64 = P64[Sp + 16];
          _saAX::I64 = I64[R1 + 7];
          goto cb92;
      cb92:
          if (HpLim == 0) goto cb95; else goto cbaZ;
      cb95:
          I64[Sp - 8] = cb93;
          P64[Sp] = _saAY::P64;
          I64[Sp + 16] = _saAX::I64;
          Sp = Sp - 8;
          call stg_gc_noregs() returns to cb93, args: 8, res: 8, upd: 8;
      cb93:
          _saAX::I64 = I64[Sp + 24];
          _saAY::P64 = P64[Sp + 8];
          Sp = Sp + 8;
          goto cb92;
      cbaZ:
          if (_saAX::I64 != 0) goto cb9k; else goto cbaY;
      cb9k:
          I64[Sp] = cb98;
          R1 = _saAY::P64;
          I64[Sp + 16] = _saAX::I64;
          if (R1 & 7 != 0) goto cb98; else goto cb99;
      cb99:
          call (I64[R1])(R1) returns to cb98, args: 8, res: 8, upd: 8;
      cb98:
          I64[Sp - 24] = cb9d;
          _saB3::P64 = P64[R1 + 15];
          _saB5::P64 = P64[R1 + 23];
          _saB4::I64 = I64[R1 + 31];
          R1 = P64[R1 + 7];
          I64[Sp - 16] = _saB4::I64;
          P64[Sp - 8] = _saB5::P64;
          P64[Sp] = _saB3::P64;
          Sp = Sp - 24;
          if (R1 & 7 != 0) goto cb9d; else goto cb9e;
      cb9e:
          call (I64[R1])(R1) returns to cb9d, args: 8, res: 8, upd: 8;
      cb9d:
          I64[Sp - 8] = cb9i;
          _saB6::P64 = R1;
          _saB7::I64 = I64[R1 + 7];
          R1 = P64[Sp + 24];
          I64[Sp] = _saB7::I64;
          P64[Sp + 24] = _saB6::P64;
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto cb9i; else goto cb9n;
      cb9n:
          call (I64[R1])(R1) returns to cb9i, args: 8, res: 8, upd: 8;
      cb9i:
          _saB0::I64 = I64[Sp + 48];
          _saB6::P64 = P64[Sp + 32];
          _saB7::I64 = I64[Sp + 8];
          _saB8::P64 = R1;
          if (%MO_S_Gt_W64(_saB7::I64,
                           _saB0::I64)) goto cb9F; else goto cbaX;
      cbaX:
          _saB9::I64 = I64[R1 + 7];
          if (%MO_S_Gt_W64(_saB0::I64,
                           _saB9::I64)) goto cb9F; else goto cbaW;
      cb9F:
          R4 = _saB8::P64;
          R3 = _saB6::P64;
          R2 = _saB0::I64;
          Sp = Sp + 64;
          call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
      cbaW:
          _saB4::I64 = I64[Sp + 16];
          _saBg::I64 = _saB0::I64 - _saB7::I64;
          if (%MO_S_Gt_W64(0, _saBg::I64)) goto cb9Y; else goto cbaV;
      cbaV:
          if (%MO_S_Ge_W64(_saBg::I64,
                           _saB4::I64)) goto cb9Y; else goto cba2;
      cb9Y:
          R3 = _saBg::I64;
          R2 = _saB4::I64;
          Sp = Sp + 64;
          call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
      cba2:
          _saBo::P64 = P64[P64[Sp + 24] + ((_saBg::I64 << 3) + 24)];
          I64[Sp] = cba1;
          R1 = _saBo::P64;
          I64[Sp + 32] = _saB9::I64;
          if (R1 & 7 != 0) goto cba1; else goto cba3;
      cba3:
          call (I64[R1])(R1) returns to cba1, args: 8, res: 8, upd: 8;
      cba1:
          I64[Sp] = cba7;
          R1 = P64[R1 + 7];
          call stg_norec_readTVar#(R1) returns to cba7, args: 8, res: 8, upd: 8;
      cba7:
          I64[Sp] = cba9;
          R1 = R1;
          if (R1 & 7 != 0) goto cba9; else goto cbac;
      cbac:
          call (I64[R1])(R1) returns to cba9, args: 8, res: 8, upd: 8;
      cba9:
          if (R1 & 7 != 1) goto cban; else goto cbai;
      cban:
          I64[Sp - 24] = cbal;
          R2 = P64[Sp + 40];
          I64[Sp - 48] = stg_ap_pp_info;
          _saBw::P64 = P64[R1 + 6];
          P64[Sp - 40] = _saBw::P64;
          P64[Sp - 32] = P64[Sp + 56];
          P64[Sp - 16] = P64[R1 + 14];
          P64[Sp - 8] = P64[R1 + 22];
          P64[Sp] = _saBw::P64;
          Sp = Sp - 48;
          call GHC.Classes.>_info(R2) returns to cbal, args: 32, res: 8, upd: 8;
      cbal:
          if (R1 & 7 != 1) goto cbaU; else goto cbau;
      cbaU:
          _saAi::P64 = P64[Sp + 48];
          _saAh::I64 = I64[Sp + 40];
          _saAg::I64 = I64[Sp + 56];
          _saAf::I64 = I64[Sp + 32];
          _saAe::I64 = I64[Sp + 72] - 1;
          goto cbb1;
      cbau:
          I64[Sp] = cbar;
          R2 = P64[Sp + 64];
          I64[Sp - 24] = stg_ap_pp_info;
          P64[Sp - 16] = P64[Sp + 24];
          P64[Sp - 8] = P64[Sp + 80];
          Sp = Sp - 24;
          call GHC.Classes.<_info(R2) returns to cbar, args: 32, res: 8, upd: 8;
      cbar:
          if (R1 & 7 != 1) goto cbaQ; else goto cbaI;
      cbaQ:
          _saAY::P64 = P64[Sp + 16];
          _saAX::I64 = I64[Sp + 72];
          Sp = Sp + 56;
          goto cb92;
      cbaI:
          I64[Sp + 80] = cbay;
          R1 = P64[Sp + 8];
          Sp = Sp + 80;
          if (R1 & 7 != 0) goto cbay; else goto cbaz;
      cbaz:
          call (I64[R1])(R1) returns to cbay, args: 8, res: 8, upd: 8;
      cbay:
          I64[Sp] = cbaD;
          R1 = P64[R1 + 7];
          call stg_norec_readTVar#(R1) returns to cbaD, args: 8, res: 8, upd: 8;
      cbaD:
          Hp = Hp + 16;
          if (Hp > HpLim) goto cbaM; else goto cbaL;
      cbaM:
          HpAlloc = 16;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to cbaD, args: 8, res: 8, upd: 8;
      cbaL:
          I64[Hp - 8] = GHC.Base.Just_con_info;
          P64[Hp] = R1;
          R1 = Hp - 6;
          Sp = Sp + 8;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
      cbai:
          _saAi::P64 = P64[Sp + 24];
          _saAh::I64 = I64[Sp + 16];
          _saAg::I64 = I64[Sp + 32];
          _saAf::I64 = I64[Sp + 8];
          _saAe::I64 = I64[Sp + 48] - 1;
          Sp = Sp - 24;
          goto cbb1;
      cbb1:
          Hp = Hp + 32;
          if (Hp > HpLim) goto cbb6; else goto cbb5;
      cbb6:
          HpAlloc = 32;
          I64[Sp + 24] = cbb2;
          P64[Sp + 32] = _saAi::P64;
          I64[Sp + 40] = _saAh::I64;
          I64[Sp + 48] = _saAg::I64;
          I64[Sp + 56] = _saAf::I64;
          I64[Sp + 72] = _saAe::I64;
          Sp = Sp + 24;
          call stg_gc_noregs() returns to cbb2, args: 8, res: 8, upd: 8;
      cbb2:
          _saAe::I64 = I64[Sp + 48];
          _saAf::I64 = I64[Sp + 32];
          _saAg::I64 = I64[Sp + 24];
          _saAh::I64 = I64[Sp + 16];
          _saAi::P64 = P64[Sp + 8];
          Sp = Sp - 24;
          goto cbb1;
      cbb5:
          if (_saAe::I64 != 0) goto cbcK; else goto cbcL;
      cbcK:
          if (%MO_S_Le_W64(_saAf::I64,
                           _saAe::I64)) goto cbcI; else goto cbbh;
      cbcI:
          if (%MO_S_Le_W64(_saAe::I64,
                           _saAg::I64)) goto cbcH; else goto cbbr;
      cbcH:
          _saAv::I64 = _saAe::I64 - _saAf::I64;
          if (%MO_S_Gt_W64(0, _saAv::I64)) goto cbbJ; else goto cbcG;
      cbcG:
          if (%MO_S_Ge_W64(_saAv::I64,
                           _saAh::I64)) goto cbbJ; else goto cbbN;
      cbbJ:
          Hp = Hp - 32;
          R3 = _saAv::I64;
          R2 = _saAh::I64;
          Sp = Sp + 88;
          call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
      cbbN:
          Hp = Hp - 32;
          _saAD::P64 = P64[(_saAi::P64 + 24) + (_saAv::I64 << 3)];
          I64[Sp + 24] = cbbM;
          R1 = _saAD::P64;
          I64[Sp + 32] = _saAe::I64;
          P64[Sp + 40] = _saAi::P64;
          I64[Sp + 48] = _saAh::I64;
          I64[Sp + 56] = _saAg::I64;
          I64[Sp + 72] = _saAf::I64;
          Sp = Sp + 24;
          if (R1 & 7 != 0) goto cbbM; else goto cbbO;
      cbbO:
          call (I64[R1])(R1) returns to cbbM, args: 8, res: 8, upd: 8;
      cbbM:
          I64[Sp] = cbbS;
          R1 = P64[R1 + 7];
          call stg_norec_readTVar#(R1) returns to cbbS, args: 8, res: 8, upd: 8;
      cbbS:
          I64[Sp] = cbbU;
          R1 = R1;
          if (R1 & 7 != 0) goto cbbU; else goto cbbX;
      cbbX:
          call (I64[R1])(R1) returns to cbbU, args: 8, res: 8, upd: 8;
      cbbU:
          if (R1 & 7 != 1) goto cbc8; else goto cbc3;
      cbc8:
          I64[Sp - 24] = cbc6;
          R2 = P64[Sp + 40];
          I64[Sp - 48] = stg_ap_pp_info;
          _saAL::P64 = P64[R1 + 6];
          P64[Sp - 40] = _saAL::P64;
          P64[Sp - 32] = P64[Sp + 56];
          P64[Sp - 16] = P64[R1 + 14];
          P64[Sp - 8] = P64[R1 + 22];
          P64[Sp] = _saAL::P64;
          Sp = Sp - 48;
          call GHC.Classes.>_info(R2) returns to cbc6, args: 32, res: 8, upd: 8;
      cbc6:
          if (R1 & 7 != 1) goto cbcF; else goto cbcf;
      cbcF:
          _saAf::I64 = I64[Sp + 72];
          _saAg::I64 = I64[Sp + 56];
          _saAh::I64 = I64[Sp + 48];
          _saAi::P64 = P64[Sp + 40];
          _saAe::I64 = I64[Sp + 32] - 1;
          goto cbb1;
      cbcf:
          I64[Sp] = cbcc;
          R2 = P64[Sp + 64];
          I64[Sp - 24] = stg_ap_pp_info;
          P64[Sp - 16] = P64[Sp + 24];
          P64[Sp - 8] = P64[Sp + 80];
          Sp = Sp - 24;
          call GHC.Classes.<_info(R2) returns to cbcc, args: 32, res: 8, upd: 8;
      cbcc:
          if (R1 & 7 != 1) goto cbcB; else goto cbct;
      cbcB:
          _saAY::P64 = P64[Sp + 16];
          _saAX::I64 = I64[Sp + 32];
          Sp = Sp + 56;
          goto cb92;
      cbct:
          I64[Sp + 80] = cbcj;
          R1 = P64[Sp + 8];
          Sp = Sp + 80;
          if (R1 & 7 != 0) goto cbcj; else goto cbck;
      cbck:
          call (I64[R1])(R1) returns to cbcj, args: 8, res: 8, upd: 8;
      cbcj:
          I64[Sp] = cbco;
          R1 = P64[R1 + 7];
          call stg_norec_readTVar#(R1) returns to cbco, args: 8, res: 8, upd: 8;
      cbco:
          Hp = Hp + 16;
          if (Hp > HpLim) goto cbcx; else goto cbcw;
      cbcx:
          HpAlloc = 16;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to cbco, args: 8, res: 8, upd: 8;
      cbcw:
          I64[Hp - 8] = GHC.Base.Just_con_info;
          P64[Hp] = R1;
          R1 = Hp - 6;
          Sp = Sp + 8;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
      cbc3:
          _saAf::I64 = I64[Sp + 48];
          _saAg::I64 = I64[Sp + 32];
          _saAh::I64 = I64[Sp + 24];
          _saAi::P64 = P64[Sp + 16];
          _saAe::I64 = I64[Sp + 8] - 1;
          Sp = Sp - 24;
          goto cbb1;
      cbbr:
          I64[Hp - 24] = GHC.Types.I#_con_info;
          I64[Hp - 16] = _saAg::I64;
          I64[Hp - 8] = GHC.Types.I#_con_info;
          I64[Hp] = _saAf::I64;
          R4 = Hp - 23;
          R3 = Hp - 7;
          R2 = _saAe::I64;
          Sp = Sp + 88;
          call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
      cbbh:
          I64[Hp - 24] = GHC.Types.I#_con_info;
          I64[Hp - 16] = _saAg::I64;
          I64[Hp - 8] = GHC.Types.I#_con_info;
          I64[Hp] = _saAf::I64;
          R4 = Hp - 23;
          R3 = Hp - 7;
          R2 = _saAe::I64;
          Sp = Sp + 88;
          call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
      cbcL:
          Hp = Hp - 32;
          R1 = GHC.Base.Nothing_closure+1;
          Sp = Sp + 88;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
      cbaY:
          R1 = GHC.Base.Nothing_closure+1;
          Sp = Sp + 32;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:45.934041 UTC

[section "data" {
     SkipList.$wa3_closure:
         const SkipList.$wa3_info;
         const 0;
 },
 SkipList.$wa3_entry() //  [R5, R4, R3, R2]
         { info_tbl: [(cb8N,
                       label: block_cb8N_info
                       rep:StackRep [False, False, False]),
                      (cb8P,
                       label: block_cb8P_info
                       rep:StackRep [False, False, False]),
                      (cb8S,
                       label: SkipList.$wa3_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} }),
                      (cb93,
                       label: block_cb93_info
                       rep:StackRep [False, False, True, False]),
                      (cb98,
                       label: block_cb98_info
                       rep:StackRep [False, True, False]),
                      (cb9d,
                       label: block_cb9d_info
                       rep:StackRep [True, False, False, False, True, False]),
                      (cb9i,
                       label: block_cb9i_info
                       rep:StackRep [True, True, False, False, False, True, False]),
                      (cba1,
                       label: block_cba1_info
                       rep:StackRep [True, True, False, True, False, True, False]),
                      (cba7,
                       label: block_cba7_info
                       rep:StackRep [True, True, False, True, False, True, False]),
                      (cba9,
                       label: block_cba9_info
                       rep:StackRep [True, True, False, True, False, True, False]),
                      (cbal,
                       label: block_cbal_info
                       rep:StackRep [False, False, False, True, True, False, True, False,
                                     True, False]),
                      (cbar,
                       label: block_cbar_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False]),
                      (cbay,
                       label: block_cbay_info
                       rep:StackRep []),
                      (cbaD,
                       label: block_cbaD_info
                       rep:StackRep []),
                      (cbb2,
                       label: block_cbb2_info
                       rep:StackRep [False, True, True, True, False, True, False]),
                      (cbbM,
                       label: block_cbbM_info
                       rep:StackRep [True, False, True, True, False, True, False]),
                      (cbbS,
                       label: block_cbbS_info
                       rep:StackRep [True, False, True, True, False, True, False]),
                      (cbbU,
                       label: block_cbbU_info
                       rep:StackRep [True, False, True, True, False, True, False]),
                      (cbc6,
                       label: block_cbc6_info
                       rep:StackRep [False, False, False, True, False, True, True, False,
                                     True, False]),
                      (cbcc,
                       label: block_cbcc_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False]),
                      (cbcj,
                       label: block_cbcj_info
                       rep:StackRep []),
                      (cbco,
                       label: block_cbco_info
                       rep:StackRep [])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cb8S:
           _saA5::P64 = R5;
           _saA4::P64 = R4;
           _saA3::P64 = R3;
           _saA2::P64 = R2;
           if ((Sp + -112) < SpLim) goto cb8T; else goto cb8U;
       cb8U:
           if (HpLim == 0) goto cb8T; else goto cb8V;
       cb8T:
           R5 = _saA5::P64;
           R4 = _saA4::P64;
           R3 = _saA3::P64;
           R2 = _saA2::P64;
           R1 = SkipList.$wa3_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb8V:
           I64[Sp - 32] = cb8N;
           R1 = _saA4::P64;
           P64[Sp - 24] = _saA2::P64;
           P64[Sp - 16] = _saA3::P64;
           P64[Sp - 8] = _saA5::P64;
           Sp = Sp - 32;
           call stg_norec_readTVar#(R1) returns to cb8N, args: 8, res: 8, upd: 8;
       cb8N:
           I64[Sp] = cb8P;
           R1 = R1;
           if (R1 & 7 != 0) goto cb8P; else goto cb8Q;
       cb8Q:
           call (I64[R1])(R1) returns to cb8P, args: 8, res: 8, upd: 8;
       cb8P:
           _saAY::P64 = P64[Sp + 16];
           _saAX::I64 = I64[R1 + 7];
           goto cb92;
       cb92:
           if (HpLim == 0) goto cb95; else goto cbaZ;
       cb95:
           I64[Sp - 8] = cb93;
           P64[Sp] = _saAY::P64;
           I64[Sp + 16] = _saAX::I64;
           Sp = Sp - 8;
           call stg_gc_noregs() returns to cb93, args: 8, res: 8, upd: 8;
       cb93:
           _saAX::I64 = I64[Sp + 24];
           _saAY::P64 = P64[Sp + 8];
           Sp = Sp + 8;
           goto cb92;
       cbaZ:
           if (_saAX::I64 != 0) goto cb9k; else goto cbaY;
       cb9k:
           I64[Sp] = cb98;
           R1 = _saAY::P64;
           I64[Sp + 16] = _saAX::I64;
           if (R1 & 7 != 0) goto cb98; else goto cb99;
       cb99:
           call (I64[R1])(R1) returns to cb98, args: 8, res: 8, upd: 8;
       cb98:
           I64[Sp - 24] = cb9d;
           _saB3::P64 = P64[R1 + 15];
           _saB5::P64 = P64[R1 + 23];
           _saB4::I64 = I64[R1 + 31];
           R1 = P64[R1 + 7];
           I64[Sp - 16] = _saB4::I64;
           P64[Sp - 8] = _saB5::P64;
           P64[Sp] = _saB3::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto cb9d; else goto cb9e;
       cb9e:
           call (I64[R1])(R1) returns to cb9d, args: 8, res: 8, upd: 8;
       cb9d:
           I64[Sp - 8] = cb9i;
           _saB6::P64 = R1;
           _saB7::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp] = _saB7::I64;
           P64[Sp + 24] = _saB6::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto cb9i; else goto cb9n;
       cb9n:
           call (I64[R1])(R1) returns to cb9i, args: 8, res: 8, upd: 8;
       cb9i:
           _saB0::I64 = I64[Sp + 48];
           _saB6::P64 = P64[Sp + 32];
           _saB7::I64 = I64[Sp + 8];
           _saB8::P64 = R1;
           if (%MO_S_Gt_W64(_saB7::I64,
                            _saB0::I64)) goto cb9F; else goto cbaX;
       cbaX:
           _saB9::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(_saB0::I64,
                            _saB9::I64)) goto cb9F; else goto cbaW;
       cb9F:
           R4 = _saB8::P64;
           R3 = _saB6::P64;
           R2 = _saB0::I64;
           Sp = Sp + 64;
           call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
       cbaW:
           _saB4::I64 = I64[Sp + 16];
           _saBg::I64 = _saB0::I64 - _saB7::I64;
           if (%MO_S_Gt_W64(0, _saBg::I64)) goto cb9Y; else goto cbaV;
       cbaV:
           if (%MO_S_Ge_W64(_saBg::I64,
                            _saB4::I64)) goto cb9Y; else goto cba2;
       cb9Y:
           R3 = _saBg::I64;
           R2 = _saB4::I64;
           Sp = Sp + 64;
           call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
       cba2:
           _saBo::P64 = P64[P64[Sp + 24] + ((_saBg::I64 << 3) + 24)];
           I64[Sp] = cba1;
           R1 = _saBo::P64;
           I64[Sp + 32] = _saB9::I64;
           if (R1 & 7 != 0) goto cba1; else goto cba3;
       cba3:
           call (I64[R1])(R1) returns to cba1, args: 8, res: 8, upd: 8;
       cba1:
           I64[Sp] = cba7;
           R1 = P64[R1 + 7];
           call stg_norec_readTVar#(R1) returns to cba7, args: 8, res: 8, upd: 8;
       cba7:
           I64[Sp] = cba9;
           R1 = R1;
           if (R1 & 7 != 0) goto cba9; else goto cbac;
       cbac:
           call (I64[R1])(R1) returns to cba9, args: 8, res: 8, upd: 8;
       cba9:
           if (R1 & 7 != 1) goto cban; else goto cbai;
       cban:
           I64[Sp - 24] = cbal;
           R2 = P64[Sp + 40];
           I64[Sp - 48] = stg_ap_pp_info;
           _saBw::P64 = P64[R1 + 6];
           P64[Sp - 40] = _saBw::P64;
           P64[Sp - 32] = P64[Sp + 56];
           P64[Sp - 16] = P64[R1 + 14];
           P64[Sp - 8] = P64[R1 + 22];
           P64[Sp] = _saBw::P64;
           Sp = Sp - 48;
           call GHC.Classes.>_info(R2) returns to cbal, args: 32, res: 8, upd: 8;
       cbal:
           if (R1 & 7 != 1) goto cbaU; else goto cbau;
       cbaU:
           _saAi::P64 = P64[Sp + 48];
           _saAh::I64 = I64[Sp + 40];
           _saAg::I64 = I64[Sp + 56];
           _saAf::I64 = I64[Sp + 32];
           _saAe::I64 = I64[Sp + 72] - 1;
           goto cbb1;
       cbau:
           I64[Sp] = cbar;
           R2 = P64[Sp + 64];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 24];
           P64[Sp - 8] = P64[Sp + 80];
           Sp = Sp - 24;
           call GHC.Classes.<_info(R2) returns to cbar, args: 32, res: 8, upd: 8;
       cbar:
           if (R1 & 7 != 1) goto cbaQ; else goto cbaI;
       cbaQ:
           _saAY::P64 = P64[Sp + 16];
           _saAX::I64 = I64[Sp + 72];
           Sp = Sp + 56;
           goto cb92;
       cbaI:
           I64[Sp + 80] = cbay;
           R1 = P64[Sp + 8];
           Sp = Sp + 80;
           if (R1 & 7 != 0) goto cbay; else goto cbaz;
       cbaz:
           call (I64[R1])(R1) returns to cbay, args: 8, res: 8, upd: 8;
       cbay:
           I64[Sp] = cbaD;
           R1 = P64[R1 + 7];
           call stg_norec_readTVar#(R1) returns to cbaD, args: 8, res: 8, upd: 8;
       cbaD:
           Hp = Hp + 16;
           if (Hp > HpLim) goto cbaM; else goto cbaL;
       cbaM:
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to cbaD, args: 8, res: 8, upd: 8;
       cbaL:
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
       cbai:
           _saAi::P64 = P64[Sp + 24];
           _saAh::I64 = I64[Sp + 16];
           _saAg::I64 = I64[Sp + 32];
           _saAf::I64 = I64[Sp + 8];
           _saAe::I64 = I64[Sp + 48] - 1;
           Sp = Sp - 24;
           goto cbb1;
       cbb1:
           Hp = Hp + 32;
           if (Hp > HpLim) goto cbb6; else goto cbb5;
       cbb6:
           HpAlloc = 32;
           I64[Sp + 24] = cbb2;
           P64[Sp + 32] = _saAi::P64;
           I64[Sp + 40] = _saAh::I64;
           I64[Sp + 48] = _saAg::I64;
           I64[Sp + 56] = _saAf::I64;
           I64[Sp + 72] = _saAe::I64;
           Sp = Sp + 24;
           call stg_gc_noregs() returns to cbb2, args: 8, res: 8, upd: 8;
       cbb2:
           _saAe::I64 = I64[Sp + 48];
           _saAf::I64 = I64[Sp + 32];
           _saAg::I64 = I64[Sp + 24];
           _saAh::I64 = I64[Sp + 16];
           _saAi::P64 = P64[Sp + 8];
           Sp = Sp - 24;
           goto cbb1;
       cbb5:
           if (_saAe::I64 != 0) goto cbcK; else goto cbcL;
       cbcK:
           if (%MO_S_Le_W64(_saAf::I64,
                            _saAe::I64)) goto cbcI; else goto cbbh;
       cbcI:
           if (%MO_S_Le_W64(_saAe::I64,
                            _saAg::I64)) goto cbcH; else goto cbbr;
       cbcH:
           _saAv::I64 = _saAe::I64 - _saAf::I64;
           if (%MO_S_Gt_W64(0, _saAv::I64)) goto cbbJ; else goto cbcG;
       cbcG:
           if (%MO_S_Ge_W64(_saAv::I64,
                            _saAh::I64)) goto cbbJ; else goto cbbN;
       cbbJ:
           Hp = Hp - 32;
           R3 = _saAv::I64;
           R2 = _saAh::I64;
           Sp = Sp + 88;
           call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
       cbbN:
           Hp = Hp - 32;
           _saAD::P64 = P64[(_saAi::P64 + 24) + (_saAv::I64 << 3)];
           I64[Sp + 24] = cbbM;
           R1 = _saAD::P64;
           I64[Sp + 32] = _saAe::I64;
           P64[Sp + 40] = _saAi::P64;
           I64[Sp + 48] = _saAh::I64;
           I64[Sp + 56] = _saAg::I64;
           I64[Sp + 72] = _saAf::I64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto cbbM; else goto cbbO;
       cbbO:
           call (I64[R1])(R1) returns to cbbM, args: 8, res: 8, upd: 8;
       cbbM:
           I64[Sp] = cbbS;
           R1 = P64[R1 + 7];
           call stg_norec_readTVar#(R1) returns to cbbS, args: 8, res: 8, upd: 8;
       cbbS:
           I64[Sp] = cbbU;
           R1 = R1;
           if (R1 & 7 != 0) goto cbbU; else goto cbbX;
       cbbX:
           call (I64[R1])(R1) returns to cbbU, args: 8, res: 8, upd: 8;
       cbbU:
           if (R1 & 7 != 1) goto cbc8; else goto cbc3;
       cbc8:
           I64[Sp - 24] = cbc6;
           R2 = P64[Sp + 40];
           I64[Sp - 48] = stg_ap_pp_info;
           _saAL::P64 = P64[R1 + 6];
           P64[Sp - 40] = _saAL::P64;
           P64[Sp - 32] = P64[Sp + 56];
           P64[Sp - 16] = P64[R1 + 14];
           P64[Sp - 8] = P64[R1 + 22];
           P64[Sp] = _saAL::P64;
           Sp = Sp - 48;
           call GHC.Classes.>_info(R2) returns to cbc6, args: 32, res: 8, upd: 8;
       cbc6:
           if (R1 & 7 != 1) goto cbcF; else goto cbcf;
       cbcF:
           _saAf::I64 = I64[Sp + 72];
           _saAg::I64 = I64[Sp + 56];
           _saAh::I64 = I64[Sp + 48];
           _saAi::P64 = P64[Sp + 40];
           _saAe::I64 = I64[Sp + 32] - 1;
           goto cbb1;
       cbcf:
           I64[Sp] = cbcc;
           R2 = P64[Sp + 64];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 24];
           P64[Sp - 8] = P64[Sp + 80];
           Sp = Sp - 24;
           call GHC.Classes.<_info(R2) returns to cbcc, args: 32, res: 8, upd: 8;
       cbcc:
           if (R1 & 7 != 1) goto cbcB; else goto cbct;
       cbcB:
           _saAY::P64 = P64[Sp + 16];
           _saAX::I64 = I64[Sp + 32];
           Sp = Sp + 56;
           goto cb92;
       cbct:
           I64[Sp + 80] = cbcj;
           R1 = P64[Sp + 8];
           Sp = Sp + 80;
           if (R1 & 7 != 0) goto cbcj; else goto cbck;
       cbck:
           call (I64[R1])(R1) returns to cbcj, args: 8, res: 8, upd: 8;
       cbcj:
           I64[Sp] = cbco;
           R1 = P64[R1 + 7];
           call stg_norec_readTVar#(R1) returns to cbco, args: 8, res: 8, upd: 8;
       cbco:
           Hp = Hp + 16;
           if (Hp > HpLim) goto cbcx; else goto cbcw;
       cbcx:
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to cbco, args: 8, res: 8, upd: 8;
       cbcw:
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
       cbc3:
           _saAf::I64 = I64[Sp + 48];
           _saAg::I64 = I64[Sp + 32];
           _saAh::I64 = I64[Sp + 24];
           _saAi::P64 = P64[Sp + 16];
           _saAe::I64 = I64[Sp + 8] - 1;
           Sp = Sp - 24;
           goto cbb1;
       cbbr:
           I64[Hp - 24] = GHC.Types.I#_con_info;
           I64[Hp - 16] = _saAg::I64;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saAf::I64;
           R4 = Hp - 23;
           R3 = Hp - 7;
           R2 = _saAe::I64;
           Sp = Sp + 88;
           call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
       cbbh:
           I64[Hp - 24] = GHC.Types.I#_con_info;
           I64[Hp - 16] = _saAg::I64;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saAf::I64;
           R4 = Hp - 23;
           R3 = Hp - 7;
           R2 = _saAe::I64;
           Sp = Sp + 88;
           call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
       cbcL:
           Hp = Hp - 32;
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 88;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
       cbaY:
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 32;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:45.955735 UTC

[section "data" {
     SkipList.$wa3_closure:
         const SkipList.$wa3_info;
         const 0;
 },
 SkipList.$wa3_entry() //  [R5, R4, R3, R2]
         { info_tbl: [(cb8N,
                       label: block_cb8N_info
                       rep:StackRep [False, False, False]),
                      (cb8P,
                       label: block_cb8P_info
                       rep:StackRep [False, False, False]),
                      (cb8S,
                       label: SkipList.$wa3_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} }),
                      (cb93,
                       label: block_cb93_info
                       rep:StackRep [False, False, True, False]),
                      (cb98,
                       label: block_cb98_info
                       rep:StackRep [False, True, False]),
                      (cb9d,
                       label: block_cb9d_info
                       rep:StackRep [True, False, False, False, True, False]),
                      (cb9i,
                       label: block_cb9i_info
                       rep:StackRep [True, True, False, False, False, True, False]),
                      (cba1,
                       label: block_cba1_info
                       rep:StackRep [True, True, False, True, False, True, False]),
                      (cba7,
                       label: block_cba7_info
                       rep:StackRep [True, True, False, True, False, True, False]),
                      (cba9,
                       label: block_cba9_info
                       rep:StackRep [True, True, False, True, False, True, False]),
                      (cbal,
                       label: block_cbal_info
                       rep:StackRep [False, False, False, True, True, False, True, False,
                                     True, False]),
                      (cbar,
                       label: block_cbar_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False]),
                      (cbay,
                       label: block_cbay_info
                       rep:StackRep []),
                      (cbaD,
                       label: block_cbaD_info
                       rep:StackRep []),
                      (cbb2,
                       label: block_cbb2_info
                       rep:StackRep [False, True, True, True, False, True, False]),
                      (cbbM,
                       label: block_cbbM_info
                       rep:StackRep [True, False, True, True, False, True, False]),
                      (cbbS,
                       label: block_cbbS_info
                       rep:StackRep [True, False, True, True, False, True, False]),
                      (cbbU,
                       label: block_cbbU_info
                       rep:StackRep [True, False, True, True, False, True, False]),
                      (cbc6,
                       label: block_cbc6_info
                       rep:StackRep [False, False, False, True, False, True, True, False,
                                     True, False]),
                      (cbcc,
                       label: block_cbcc_info
                       rep:StackRep [False, False, True, True, True, True, True, False,
                                     True, False]),
                      (cbcj,
                       label: block_cbcj_info
                       rep:StackRep []),
                      (cbco,
                       label: block_cbco_info
                       rep:StackRep [])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cb8S:
           _saA5::P64 = R5;
           _saA4::P64 = R4;
           _saA3::P64 = R3;
           _saA2::P64 = R2;
           if ((Sp + -112) < SpLim) goto cb8T; else goto cb8U;
       cb8U:
           if (HpLim == 0) goto cb8T; else goto cb8V;
       cb8T:
           R5 = _saA5::P64;
           R4 = _saA4::P64;
           R3 = _saA3::P64;
           R2 = _saA2::P64;
           R1 = SkipList.$wa3_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cb8V:
           I64[Sp - 32] = cb8N;
           R1 = _saA4::P64;
           P64[Sp - 24] = _saA2::P64;
           P64[Sp - 16] = _saA3::P64;
           P64[Sp - 8] = _saA5::P64;
           Sp = Sp - 32;
           call stg_norec_readTVar#(R1) returns to cb8N, args: 8, res: 8, upd: 8;
       cb8N:
           I64[Sp] = cb8P;
           R1 = R1;
           if (R1 & 7 != 0) goto cb8P; else goto cb8Q;
       cb8Q:
           call (I64[R1])(R1) returns to cb8P, args: 8, res: 8, upd: 8;
       cb8P:
           _saAY::P64 = P64[Sp + 16];
           _saAX::I64 = I64[R1 + 7];
           goto cb92;
       cb92:
           if (HpLim == 0) goto cb95; else goto cbaZ;
       cb95:
           I64[Sp - 8] = cb93;
           P64[Sp] = _saAY::P64;
           I64[Sp + 16] = _saAX::I64;
           Sp = Sp - 8;
           call stg_gc_noregs() returns to cb93, args: 8, res: 8, upd: 8;
       cb93:
           _saAX::I64 = I64[Sp + 24];
           _saAY::P64 = P64[Sp + 8];
           Sp = Sp + 8;
           goto cb92;
       cbaZ:
           if (_saAX::I64 != 0) goto cb9k; else goto cbaY;
       cb9k:
           I64[Sp] = cb98;
           R1 = _saAY::P64;
           I64[Sp + 16] = _saAX::I64;
           if (R1 & 7 != 0) goto cb98; else goto cb99;
       cb99:
           call (I64[R1])(R1) returns to cb98, args: 8, res: 8, upd: 8;
       cb98:
           I64[Sp - 24] = cb9d;
           _saB3::P64 = P64[R1 + 15];
           _saB5::P64 = P64[R1 + 23];
           _saB4::I64 = I64[R1 + 31];
           R1 = P64[R1 + 7];
           I64[Sp - 16] = _saB4::I64;
           P64[Sp - 8] = _saB5::P64;
           P64[Sp] = _saB3::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto cb9d; else goto cb9e;
       cb9e:
           call (I64[R1])(R1) returns to cb9d, args: 8, res: 8, upd: 8;
       cb9d:
           I64[Sp - 8] = cb9i;
           _saB6::P64 = R1;
           _saB7::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp] = _saB7::I64;
           P64[Sp + 24] = _saB6::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto cb9i; else goto cb9n;
       cb9n:
           call (I64[R1])(R1) returns to cb9i, args: 8, res: 8, upd: 8;
       cb9i:
           _saB0::I64 = I64[Sp + 48];
           _saB6::P64 = P64[Sp + 32];
           _saB7::I64 = I64[Sp + 8];
           _saB8::P64 = R1;
           if (%MO_S_Gt_W64(_saB7::I64,
                            _saB0::I64)) goto cb9F; else goto cbaX;
       cbaX:
           _saB9::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(_saB0::I64,
                            _saB9::I64)) goto cb9F; else goto cbaW;
       cb9F:
           R4 = _saB8::P64;
           R3 = _saB6::P64;
           R2 = _saB0::I64;
           Sp = Sp + 64;
           call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
       cbaW:
           _saB4::I64 = I64[Sp + 16];
           _saBg::I64 = _saB0::I64 - _saB7::I64;
           if (%MO_S_Gt_W64(0, _saBg::I64)) goto cb9Y; else goto cbaV;
       cbaV:
           if (%MO_S_Ge_W64(_saBg::I64,
                            _saB4::I64)) goto cb9Y; else goto cba2;
       cb9Y:
           R3 = _saBg::I64;
           R2 = _saB4::I64;
           Sp = Sp + 64;
           call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
       cba2:
           _saBo::P64 = P64[P64[Sp + 24] + ((_saBg::I64 << 3) + 24)];
           I64[Sp] = cba1;
           R1 = _saBo::P64;
           I64[Sp + 32] = _saB9::I64;
           if (R1 & 7 != 0) goto cba1; else goto cba3;
       cba3:
           call (I64[R1])(R1) returns to cba1, args: 8, res: 8, upd: 8;
       cba1:
           I64[Sp] = cba7;
           R1 = P64[R1 + 7];
           call stg_norec_readTVar#(R1) returns to cba7, args: 8, res: 8, upd: 8;
       cba7:
           I64[Sp] = cba9;
           R1 = R1;
           if (R1 & 7 != 0) goto cba9; else goto cbac;
       cbac:
           call (I64[R1])(R1) returns to cba9, args: 8, res: 8, upd: 8;
       cba9:
           if (R1 & 7 != 1) goto cban; else goto cbai;
       cban:
           I64[Sp - 24] = cbal;
           R2 = P64[Sp + 40];
           I64[Sp - 48] = stg_ap_pp_info;
           _saBw::P64 = P64[R1 + 6];
           P64[Sp - 40] = _saBw::P64;
           P64[Sp - 32] = P64[Sp + 56];
           P64[Sp - 16] = P64[R1 + 14];
           P64[Sp - 8] = P64[R1 + 22];
           P64[Sp] = _saBw::P64;
           Sp = Sp - 48;
           call GHC.Classes.>_info(R2) returns to cbal, args: 32, res: 8, upd: 8;
       cbal:
           if (R1 & 7 != 1) goto cbaU; else goto cbau;
       cbaU:
           _saAi::P64 = P64[Sp + 48];
           _saAh::I64 = I64[Sp + 40];
           _saAg::I64 = I64[Sp + 56];
           _saAf::I64 = I64[Sp + 32];
           _saAe::I64 = I64[Sp + 72] - 1;
           goto cbb1;
       cbau:
           I64[Sp] = cbar;
           R2 = P64[Sp + 64];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 24];
           P64[Sp - 8] = P64[Sp + 80];
           Sp = Sp - 24;
           call GHC.Classes.<_info(R2) returns to cbar, args: 32, res: 8, upd: 8;
       cbar:
           if (R1 & 7 != 1) goto cbaQ; else goto cbaI;
       cbaQ:
           _saAY::P64 = P64[Sp + 16];
           _saAX::I64 = I64[Sp + 72];
           Sp = Sp + 56;
           goto cb92;
       cbaI:
           I64[Sp + 80] = cbay;
           R1 = P64[Sp + 8];
           Sp = Sp + 80;
           if (R1 & 7 != 0) goto cbay; else goto cbaz;
       cbaz:
           call (I64[R1])(R1) returns to cbay, args: 8, res: 8, upd: 8;
       cbay:
           I64[Sp] = cbaD;
           R1 = P64[R1 + 7];
           call stg_norec_readTVar#(R1) returns to cbaD, args: 8, res: 8, upd: 8;
       cbaD:
           Hp = Hp + 16;
           if (Hp > HpLim) goto cbaM; else goto cbaL;
       cbaM:
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to cbaD, args: 8, res: 8, upd: 8;
       cbaL:
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
       cbai:
           _saAi::P64 = P64[Sp + 24];
           _saAh::I64 = I64[Sp + 16];
           _saAg::I64 = I64[Sp + 32];
           _saAf::I64 = I64[Sp + 8];
           _saAe::I64 = I64[Sp + 48] - 1;
           Sp = Sp - 24;
           goto cbb1;
       cbb1:
           Hp = Hp + 32;
           if (Hp > HpLim) goto cbb6; else goto cbb5;
       cbb6:
           HpAlloc = 32;
           I64[Sp + 24] = cbb2;
           P64[Sp + 32] = _saAi::P64;
           I64[Sp + 40] = _saAh::I64;
           I64[Sp + 48] = _saAg::I64;
           I64[Sp + 56] = _saAf::I64;
           I64[Sp + 72] = _saAe::I64;
           Sp = Sp + 24;
           call stg_gc_noregs() returns to cbb2, args: 8, res: 8, upd: 8;
       cbb2:
           _saAe::I64 = I64[Sp + 48];
           _saAf::I64 = I64[Sp + 32];
           _saAg::I64 = I64[Sp + 24];
           _saAh::I64 = I64[Sp + 16];
           _saAi::P64 = P64[Sp + 8];
           Sp = Sp - 24;
           goto cbb1;
       cbb5:
           if (_saAe::I64 != 0) goto cbcK; else goto cbcL;
       cbcK:
           if (%MO_S_Le_W64(_saAf::I64,
                            _saAe::I64)) goto cbcI; else goto cbbh;
       cbcI:
           if (%MO_S_Le_W64(_saAe::I64,
                            _saAg::I64)) goto cbcH; else goto cbbr;
       cbcH:
           _saAv::I64 = _saAe::I64 - _saAf::I64;
           if (%MO_S_Gt_W64(0, _saAv::I64)) goto cbbJ; else goto cbcG;
       cbcG:
           if (%MO_S_Ge_W64(_saAv::I64,
                            _saAh::I64)) goto cbbJ; else goto cbbN;
       cbbJ:
           Hp = Hp - 32;
           R3 = _saAv::I64;
           R2 = _saAh::I64;
           Sp = Sp + 88;
           call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
       cbbN:
           Hp = Hp - 32;
           _saAD::P64 = P64[(_saAi::P64 + 24) + (_saAv::I64 << 3)];
           I64[Sp + 24] = cbbM;
           R1 = _saAD::P64;
           I64[Sp + 32] = _saAe::I64;
           P64[Sp + 40] = _saAi::P64;
           I64[Sp + 48] = _saAh::I64;
           I64[Sp + 56] = _saAg::I64;
           I64[Sp + 72] = _saAf::I64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto cbbM; else goto cbbO;
       cbbO:
           call (I64[R1])(R1) returns to cbbM, args: 8, res: 8, upd: 8;
       cbbM:
           I64[Sp] = cbbS;
           R1 = P64[R1 + 7];
           call stg_norec_readTVar#(R1) returns to cbbS, args: 8, res: 8, upd: 8;
       cbbS:
           I64[Sp] = cbbU;
           R1 = R1;
           if (R1 & 7 != 0) goto cbbU; else goto cbbX;
       cbbX:
           call (I64[R1])(R1) returns to cbbU, args: 8, res: 8, upd: 8;
       cbbU:
           if (R1 & 7 != 1) goto cbc8; else goto cbc3;
       cbc8:
           I64[Sp - 24] = cbc6;
           R2 = P64[Sp + 40];
           I64[Sp - 48] = stg_ap_pp_info;
           _saAL::P64 = P64[R1 + 6];
           P64[Sp - 40] = _saAL::P64;
           P64[Sp - 32] = P64[Sp + 56];
           P64[Sp - 16] = P64[R1 + 14];
           P64[Sp - 8] = P64[R1 + 22];
           P64[Sp] = _saAL::P64;
           Sp = Sp - 48;
           call GHC.Classes.>_info(R2) returns to cbc6, args: 32, res: 8, upd: 8;
       cbc6:
           if (R1 & 7 != 1) goto cbcF; else goto cbcf;
       cbcF:
           _saAf::I64 = I64[Sp + 72];
           _saAg::I64 = I64[Sp + 56];
           _saAh::I64 = I64[Sp + 48];
           _saAi::P64 = P64[Sp + 40];
           _saAe::I64 = I64[Sp + 32] - 1;
           goto cbb1;
       cbcf:
           I64[Sp] = cbcc;
           R2 = P64[Sp + 64];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 24];
           P64[Sp - 8] = P64[Sp + 80];
           Sp = Sp - 24;
           call GHC.Classes.<_info(R2) returns to cbcc, args: 32, res: 8, upd: 8;
       cbcc:
           if (R1 & 7 != 1) goto cbcB; else goto cbct;
       cbcB:
           _saAY::P64 = P64[Sp + 16];
           _saAX::I64 = I64[Sp + 32];
           Sp = Sp + 56;
           goto cb92;
       cbct:
           I64[Sp + 80] = cbcj;
           R1 = P64[Sp + 8];
           Sp = Sp + 80;
           if (R1 & 7 != 0) goto cbcj; else goto cbck;
       cbck:
           call (I64[R1])(R1) returns to cbcj, args: 8, res: 8, upd: 8;
       cbcj:
           I64[Sp] = cbco;
           R1 = P64[R1 + 7];
           call stg_norec_readTVar#(R1) returns to cbco, args: 8, res: 8, upd: 8;
       cbco:
           Hp = Hp + 16;
           if (Hp > HpLim) goto cbcx; else goto cbcw;
       cbcx:
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to cbco, args: 8, res: 8, upd: 8;
       cbcw:
           I64[Hp - 8] = GHC.Base.Just_con_info;
           P64[Hp] = R1;
           R1 = Hp - 6;
           Sp = Sp + 8;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
       cbc3:
           _saAf::I64 = I64[Sp + 48];
           _saAg::I64 = I64[Sp + 32];
           _saAh::I64 = I64[Sp + 24];
           _saAi::P64 = P64[Sp + 16];
           _saAe::I64 = I64[Sp + 8] - 1;
           Sp = Sp - 24;
           goto cbb1;
       cbbr:
           I64[Hp - 24] = GHC.Types.I#_con_info;
           I64[Hp - 16] = _saAg::I64;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saAf::I64;
           R4 = Hp - 23;
           R3 = Hp - 7;
           R2 = _saAe::I64;
           Sp = Sp + 88;
           call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
       cbbh:
           I64[Hp - 24] = GHC.Types.I#_con_info;
           I64[Hp - 16] = _saAg::I64;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saAf::I64;
           R4 = Hp - 23;
           R3 = Hp - 7;
           R2 = _saAe::I64;
           Sp = Sp + 88;
           call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
       cbcL:
           Hp = Hp - 32;
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 88;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
       cbaY:
           R1 = GHC.Base.Nothing_closure+1;
           Sp = Sp + 32;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:46.009143 UTC

[section "data" {
     SkipList.get1_closure:
         const SkipList.get1_info;
         const 0;
 },
 SkipList.get1_entry() //  [R4, R3, R2]
         { info_tbl: [(cbdR,
                       label: SkipList.get1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbdR:
           _saBK::P64 = R4;
           _saBJ::P64 = R3;
           _saBI::P64 = R2;
           goto cbdM;
       cbdM:
           if ((old + 0) - <highSp> < SpLim) goto cbdV; else goto cbdW;
       cbdW:
           goto cbdL;
       cbdL:
           if (HpLim == 0) goto cbdV; else goto cbdX;
       cbdV:
           R4 = _saBK::P64;
           R3 = _saBJ::P64;
           R2 = _saBI::P64;
           R1 = SkipList.get1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbdX:
           I64[(young<cbdO> + 8)] = cbdO;
           R1 = _saBJ::P64;
           if (R1 & 7 != 0) goto cbdO; else goto cbdP;
       cbdP:
           call (I64[R1])(R1) returns to cbdO, args: 8, res: 8, upd: 8;
       cbdO:
           _saBM::P64 = R1;
           _saBN::P64 = P64[_saBM::P64 + 7];
           _saBO::P64 = P64[_saBM::P64 + 15];
           _saBP::P64 = P64[_saBM::P64 + 23];
           I64[(young<cbdU> + 8)] = cbdU;
           R1 = _saBO::P64;
           if (R1 & 7 != 0) goto cbdU; else goto cbdZ;
       cbdZ:
           call (I64[R1])(R1) returns to cbdU, args: 8, res: 8, upd: 8;
       cbdU:
           _saBQ::P64 = R1;
           _saBR::P64 = P64[_saBQ::P64 + 7];
           R5 = _saBK::P64;
           R4 = _saBR::P64;
           R3 = _saBN::P64;
           R2 = _saBI::P64;
           call SkipList.$wa3_info(R5, R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:46.012734 UTC

{offset
  cbdR:
      _saBK::P64 = R4;
      _saBJ::P64 = R3;
      _saBI::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cbdV; else goto cbdW;
  cbdW:
      if (HpLim == 0) goto cbdV; else goto cbdX;
  cbdV:
      R4 = _saBK::P64;
      R3 = _saBJ::P64;
      R2 = _saBI::P64;
      R1 = SkipList.get1_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  cbdX:
      I64[(young<cbdO> + 8)] = cbdO;
      R1 = _saBJ::P64;
      if (R1 & 7 != 0) goto cbdO; else goto cbdP;
  cbdP:
      call (I64[R1])(R1) returns to cbdO, args: 8, res: 8, upd: 8;
  cbdO:
      _saBM::P64 = R1;
      _saBN::P64 = P64[_saBM::P64 + 7];
      _saBO::P64 = P64[_saBM::P64 + 15];
      _saBP::P64 = P64[_saBM::P64 + 23];
      I64[(young<cbdU> + 8)] = cbdU;
      R1 = _saBO::P64;
      if (R1 & 7 != 0) goto cbdU; else goto cbdZ;
  cbdZ:
      call (I64[R1])(R1) returns to cbdU, args: 8, res: 8, upd: 8;
  cbdU:
      _saBQ::P64 = R1;
      _saBR::P64 = P64[_saBQ::P64 + 7];
      R5 = _saBK::P64;
      R4 = _saBR::P64;
      R3 = _saBN::P64;
      R2 = _saBI::P64;
      call SkipList.$wa3_info(R5, R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:46.014616 UTC

{offset
  cbdR:
      _saBK::P64 = R4;
      _saBJ::P64 = R3;
      _saBI::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cbdV; else goto cbdW;
  cbdW:
      if (HpLim == 0) goto cbdV; else goto cbdX;
  cbdV:
      R4 = _saBK::P64;
      R3 = _saBJ::P64;
      R2 = _saBI::P64;
      R1 = SkipList.get1_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  cbdX:
      I64[(young<cbdO> + 8)] = cbdO;
      R1 = _saBJ::P64;
      if (R1 & 7 != 0) goto cbdO; else goto cbdP;
  cbdP:
      call (I64[R1])(R1) returns to cbdO, args: 8, res: 8, upd: 8;
  cbdO:
      _saBM::P64 = R1;
      _saBN::P64 = P64[_saBM::P64 + 7];
      _saBO::P64 = P64[_saBM::P64 + 15];
      _saBP::P64 = P64[_saBM::P64 + 23];
      I64[(young<cbdU> + 8)] = cbdU;
      R1 = _saBO::P64;
      if (R1 & 7 != 0) goto cbdU; else goto cbdZ;
  cbdZ:
      call (I64[R1])(R1) returns to cbdU, args: 8, res: 8, upd: 8;
  cbdU:
      _saBQ::P64 = R1;
      _saBR::P64 = P64[_saBQ::P64 + 7];
      R5 = _saBK::P64;
      R4 = _saBR::P64;
      R3 = _saBN::P64;
      R2 = _saBI::P64;
      call SkipList.$wa3_info(R5, R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:46.016502 UTC

{offset
  cbdR:
      _saBK::P64 = R4;
      _saBJ::P64 = R3;
      _saBI::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cbdV; else goto cbdW;
  cbdW:
      if (HpLim == 0) goto cbdV; else goto cbdX;
  cbdV:
      R4 = _saBK::P64;
      R3 = _saBJ::P64;
      R2 = _saBI::P64;
      R1 = SkipList.get1_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  cbdX:
      I64[(young<cbdO> + 8)] = cbdO;
      R1 = _saBJ::P64;
      if (R1 & 7 != 0) goto cbdO; else goto cbdP;
  cbdP:
      call (I64[R1])(R1) returns to cbdO, args: 8, res: 8, upd: 8;
  cbdO:
      _saBM::P64 = R1;
      _saBN::P64 = P64[_saBM::P64 + 7];
      _saBO::P64 = P64[_saBM::P64 + 15];
      _saBP::P64 = P64[_saBM::P64 + 23];
      I64[(young<cbdU> + 8)] = cbdU;
      R1 = _saBO::P64;
      if (R1 & 7 != 0) goto cbdU; else goto cbdZ;
  cbdZ:
      call (I64[R1])(R1) returns to cbdU, args: 8, res: 8, upd: 8;
  cbdU:
      _saBQ::P64 = R1;
      _saBR::P64 = P64[_saBQ::P64 + 7];
      R5 = _saBK::P64;
      R4 = _saBR::P64;
      R3 = _saBN::P64;
      R2 = _saBI::P64;
      call SkipList.$wa3_info(R5, R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:46.018663 UTC

{offset
  cbdR:
      _saBK::P64 = R4;
      _saBJ::P64 = R3;
      _saBI::P64 = R2;
      if ((Sp + 8) - 40 < SpLim) goto cbdV; else goto cbdW;
  cbdW:
      if (HpLim == 0) goto cbdV; else goto cbdX;
  cbdV:
      R4 = _saBK::P64;
      R3 = _saBJ::P64;
      R2 = _saBI::P64;
      R1 = SkipList.get1_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  cbdX:
      I64[Sp - 24] = cbdO;
      R1 = _saBJ::P64;
      P64[Sp - 16] = _saBI::P64;
      P64[Sp - 8] = _saBK::P64;
      Sp = Sp - 24;
      if (R1 & 7 != 0) goto cbdO; else goto cbdP;
  cbdP:
      call (I64[R1])(R1) returns to cbdO, args: 8, res: 8, upd: 8;
  cbdO:
      _saBI::P64 = P64[Sp + 8];
      _saBK::P64 = P64[Sp + 16];
      _saBM::P64 = R1;
      _saBN::P64 = P64[_saBM::P64 + 7];
      _saBO::P64 = P64[_saBM::P64 + 15];
      _saBP::P64 = P64[_saBM::P64 + 23];
      I64[Sp - 8] = cbdU;
      R1 = _saBO::P64;
      P64[Sp] = _saBN::P64;
      Sp = Sp - 8;
      if (R1 & 7 != 0) goto cbdU; else goto cbdZ;
  cbdZ:
      call (I64[R1])(R1) returns to cbdU, args: 8, res: 8, upd: 8;
  cbdU:
      _saBI::P64 = P64[Sp + 16];
      _saBK::P64 = P64[Sp + 24];
      _saBN::P64 = P64[Sp + 8];
      _saBQ::P64 = R1;
      _saBR::P64 = P64[_saBQ::P64 + 7];
      R5 = _saBK::P64;
      R4 = _saBR::P64;
      R3 = _saBN::P64;
      R2 = _saBI::P64;
      Sp = Sp + 32;
      call SkipList.$wa3_info(R5, R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:46.021095 UTC

{offset
  cbdR:
      _saBK::P64 = R4;
      _saBJ::P64 = R3;
      _saBI::P64 = R2;
      if ((Sp + -32) < SpLim) goto cbdV; else goto cbdW;
  cbdW:
      if (HpLim == 0) goto cbdV; else goto cbdX;
  cbdV:
      R4 = _saBK::P64;
      R3 = _saBJ::P64;
      R2 = _saBI::P64;
      R1 = SkipList.get1_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  cbdX:
      I64[Sp - 24] = cbdO;
      R1 = _saBJ::P64;
      P64[Sp - 16] = _saBI::P64;
      P64[Sp - 8] = _saBK::P64;
      Sp = Sp - 24;
      if (R1 & 7 != 0) goto cbdO; else goto cbdP;
  cbdP:
      call (I64[R1])(R1) returns to cbdO, args: 8, res: 8, upd: 8;
  cbdO:
      I64[Sp - 8] = cbdU;
      _saBN::P64 = P64[R1 + 7];
      R1 = P64[R1 + 15];
      P64[Sp] = _saBN::P64;
      Sp = Sp - 8;
      if (R1 & 7 != 0) goto cbdU; else goto cbdZ;
  cbdZ:
      call (I64[R1])(R1) returns to cbdU, args: 8, res: 8, upd: 8;
  cbdU:
      R5 = P64[Sp + 24];
      R4 = P64[R1 + 7];
      R3 = P64[Sp + 8];
      R2 = P64[Sp + 16];
      Sp = Sp + 32;
      call SkipList.$wa3_info(R5, R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:46.023339 UTC

[(cbdO, {SkipList.$wa3_closure}), (cbdP, {SkipList.$wa3_closure}),
 (cbdR, {SkipList.get1_closure, SkipList.$wa3_closure}),
 (cbdU, {SkipList.$wa3_closure}), (cbdV, {SkipList.get1_closure}),
 (cbdW, {SkipList.get1_closure, SkipList.$wa3_closure}),
 (cbdX, {SkipList.$wa3_closure}), (cbdZ, {SkipList.$wa3_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:46.024065 UTC

SkipList.get1_entry() //  [R4, R3, R2]
        { info_tbl: [(cbdO,
                      label: block_cbdO_info
                      rep:StackRep [False, False]),
                     (cbdR,
                      label: SkipList.get1_info
                      rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} }),
                     (cbdU,
                      label: block_cbdU_info
                      rep:StackRep [False, False, False])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cbdR:
          _saBK::P64 = R4;
          _saBJ::P64 = R3;
          _saBI::P64 = R2;
          if ((Sp + -32) < SpLim) goto cbdV; else goto cbdW;
      cbdW:
          if (HpLim == 0) goto cbdV; else goto cbdX;
      cbdV:
          R4 = _saBK::P64;
          R3 = _saBJ::P64;
          R2 = _saBI::P64;
          R1 = SkipList.get1_closure;
          call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
      cbdX:
          I64[Sp - 24] = cbdO;
          R1 = _saBJ::P64;
          P64[Sp - 16] = _saBI::P64;
          P64[Sp - 8] = _saBK::P64;
          Sp = Sp - 24;
          if (R1 & 7 != 0) goto cbdO; else goto cbdP;
      cbdP:
          call (I64[R1])(R1) returns to cbdO, args: 8, res: 8, upd: 8;
      cbdO:
          I64[Sp - 8] = cbdU;
          _saBN::P64 = P64[R1 + 7];
          R1 = P64[R1 + 15];
          P64[Sp] = _saBN::P64;
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto cbdU; else goto cbdZ;
      cbdZ:
          call (I64[R1])(R1) returns to cbdU, args: 8, res: 8, upd: 8;
      cbdU:
          R5 = P64[Sp + 24];
          R4 = P64[R1 + 7];
          R3 = P64[Sp + 8];
          R2 = P64[Sp + 16];
          Sp = Sp + 32;
          call SkipList.$wa3_info(R5, R4, R3, R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:46.026595 UTC

SkipList.get1_entry() //  [R4, R3, R2]
        { info_tbl: [(cbdO,
                      label: block_cbdO_info
                      rep:StackRep [False, False]),
                     (cbdR,
                      label: SkipList.get1_info
                      rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} }),
                     (cbdU,
                      label: block_cbdU_info
                      rep:StackRep [False, False, False])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cbdR:
          _saBK::P64 = R4;
          _saBJ::P64 = R3;
          _saBI::P64 = R2;
          if ((Sp + -32) < SpLim) goto cbdV; else goto cbdW;
      cbdW:
          if (HpLim == 0) goto cbdV; else goto cbdX;
      cbdV:
          R4 = _saBK::P64;
          R3 = _saBJ::P64;
          R2 = _saBI::P64;
          R1 = SkipList.get1_closure;
          call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
      cbdX:
          I64[Sp - 24] = cbdO;
          R1 = _saBJ::P64;
          P64[Sp - 16] = _saBI::P64;
          P64[Sp - 8] = _saBK::P64;
          Sp = Sp - 24;
          if (R1 & 7 != 0) goto cbdO; else goto cbdP;
      cbdP:
          call (I64[R1])(R1) returns to cbdO, args: 8, res: 8, upd: 8;
      cbdO:
          I64[Sp - 8] = cbdU;
          _saBN::P64 = P64[R1 + 7];
          R1 = P64[R1 + 15];
          P64[Sp] = _saBN::P64;
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto cbdU; else goto cbdZ;
      cbdZ:
          call (I64[R1])(R1) returns to cbdU, args: 8, res: 8, upd: 8;
      cbdU:
          R5 = P64[Sp + 24];
          R4 = P64[R1 + 7];
          R3 = P64[Sp + 8];
          R2 = P64[Sp + 16];
          Sp = Sp + 32;
          call SkipList.$wa3_info(R5, R4, R3, R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:46.029661 UTC

[section "data" {
     SkipList.get1_closure:
         const SkipList.get1_info;
         const 0;
 },
 SkipList.get1_entry() //  [R4, R3, R2]
         { info_tbl: [(cbdO,
                       label: block_cbdO_info
                       rep:StackRep [False, False]),
                      (cbdR,
                       label: SkipList.get1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} }),
                      (cbdU,
                       label: block_cbdU_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbdR:
           _saBK::P64 = R4;
           _saBJ::P64 = R3;
           _saBI::P64 = R2;
           if ((Sp + -32) < SpLim) goto cbdV; else goto cbdW;
       cbdW:
           if (HpLim == 0) goto cbdV; else goto cbdX;
       cbdV:
           R4 = _saBK::P64;
           R3 = _saBJ::P64;
           R2 = _saBI::P64;
           R1 = SkipList.get1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbdX:
           I64[Sp - 24] = cbdO;
           R1 = _saBJ::P64;
           P64[Sp - 16] = _saBI::P64;
           P64[Sp - 8] = _saBK::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto cbdO; else goto cbdP;
       cbdP:
           call (I64[R1])(R1) returns to cbdO, args: 8, res: 8, upd: 8;
       cbdO:
           I64[Sp - 8] = cbdU;
           _saBN::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _saBN::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto cbdU; else goto cbdZ;
       cbdZ:
           call (I64[R1])(R1) returns to cbdU, args: 8, res: 8, upd: 8;
       cbdU:
           R5 = P64[Sp + 24];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call SkipList.$wa3_info(R5, R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:46.032447 UTC

[section "data" {
     SkipList.get1_closure:
         const SkipList.get1_info;
         const 0;
 },
 SkipList.get1_entry() //  [R4, R3, R2]
         { info_tbl: [(cbdO,
                       label: block_cbdO_info
                       rep:StackRep [False, False]),
                      (cbdR,
                       label: SkipList.get1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} }),
                      (cbdU,
                       label: block_cbdU_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbdR:
           _saBK::P64 = R4;
           _saBJ::P64 = R3;
           _saBI::P64 = R2;
           if ((Sp + -32) < SpLim) goto cbdV; else goto cbdW;
       cbdW:
           if (HpLim == 0) goto cbdV; else goto cbdX;
       cbdV:
           R4 = _saBK::P64;
           R3 = _saBJ::P64;
           R2 = _saBI::P64;
           R1 = SkipList.get1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbdX:
           I64[Sp - 24] = cbdO;
           R1 = _saBJ::P64;
           P64[Sp - 16] = _saBI::P64;
           P64[Sp - 8] = _saBK::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto cbdO; else goto cbdP;
       cbdP:
           call (I64[R1])(R1) returns to cbdO, args: 8, res: 8, upd: 8;
       cbdO:
           I64[Sp - 8] = cbdU;
           _saBN::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _saBN::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto cbdU; else goto cbdZ;
       cbdZ:
           call (I64[R1])(R1) returns to cbdU, args: 8, res: 8, upd: 8;
       cbdU:
           R5 = P64[Sp + 24];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call SkipList.$wa3_info(R5, R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:46.039348 UTC

[section "data" {
     SkipList.get_closure:
         const SkipList.get_info;
         const 0;
 },
 SkipList.get_entry() //  [R4, R3, R2]
         { info_tbl: [(cbed,
                       label: SkipList.get_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbed:
           _B2::P64 = R4;
           _B3::P64 = R3;
           _B4::P64 = R2;
           goto cbeb;
       cbeb:
           if ((old + 0) - <highSp> < SpLim) goto cbee; else goto cbef;
       cbef:
           goto cbea;
       cbea:
           if (HpLim == 0) goto cbee; else goto cbeg;
       cbee:
           R4 = _B2::P64;
           R3 = _B3::P64;
           R2 = _B4::P64;
           R1 = SkipList.get_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbeg:
           R4 = _B2::P64;
           R3 = _B3::P64;
           R2 = _B4::P64;
           call SkipList.get1_info(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:46.04122 UTC

{offset
  cbed:
      _B2::P64 = R4;
      _B3::P64 = R3;
      _B4::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cbee; else goto cbef;
  cbef:
      if (HpLim == 0) goto cbee; else goto cbeg;
  cbee:
      R4 = _B2::P64;
      R3 = _B3::P64;
      R2 = _B4::P64;
      R1 = SkipList.get_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  cbeg:
      R4 = _B2::P64;
      R3 = _B3::P64;
      R2 = _B4::P64;
      call SkipList.get1_info(R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:46.042167 UTC

{offset
  cbed:
      _B2::P64 = R4;
      _B3::P64 = R3;
      _B4::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cbee; else goto cbef;
  cbef:
      if (HpLim == 0) goto cbee; else goto cbeg;
  cbee:
      R4 = _B2::P64;
      R3 = _B3::P64;
      R2 = _B4::P64;
      R1 = SkipList.get_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  cbeg:
      R4 = _B2::P64;
      R3 = _B3::P64;
      R2 = _B4::P64;
      call SkipList.get1_info(R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:46.043166 UTC

{offset
  cbed:
      _B2::P64 = R4;
      _B3::P64 = R3;
      _B4::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cbee; else goto cbef;
  cbef:
      if (HpLim == 0) goto cbee; else goto cbeg;
  cbee:
      R4 = _B2::P64;
      R3 = _B3::P64;
      R2 = _B4::P64;
      R1 = SkipList.get_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  cbeg:
      R4 = _B2::P64;
      R3 = _B3::P64;
      R2 = _B4::P64;
      call SkipList.get1_info(R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:46.044156 UTC

{offset
  cbed:
      _B2::P64 = R4;
      _B3::P64 = R3;
      _B4::P64 = R2;
      goto cbef;
  cbef:
      if (HpLim == 0) goto cbee; else goto cbeg;
  cbee:
      R4 = _B2::P64;
      R3 = _B3::P64;
      R2 = _B4::P64;
      R1 = SkipList.get_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  cbeg:
      R4 = _B2::P64;
      R3 = _B3::P64;
      R2 = _B4::P64;
      call SkipList.get1_info(R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:46.045023 UTC

{offset
  cbed:
      goto cbef;
  cbef:
      if (HpLim == 0) goto cbee; else goto cbeg;
  cbee:
      R4 = R4;
      R3 = R3;
      R2 = R2;
      R1 = SkipList.get_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  cbeg:
      R4 = R4;
      R3 = R3;
      R2 = R2;
      call SkipList.get1_info(R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:46.045976 UTC

[(cbed, {SkipList.get1_closure, SkipList.get_closure}),
 (cbee, {SkipList.get_closure}),
 (cbef, {SkipList.get1_closure, SkipList.get_closure}),
 (cbeg, {SkipList.get1_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:46.04647 UTC

SkipList.get_entry() //  [R4, R3, R2]
        { info_tbl: [(cbed,
                      label: SkipList.get_info
                      rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cbed:
          goto cbef;
      cbef:
          if (HpLim == 0) goto cbee; else goto cbeg;
      cbee:
          R4 = R4;
          R3 = R3;
          R2 = R2;
          R1 = SkipList.get_closure;
          call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
      cbeg:
          R4 = R4;
          R3 = R3;
          R2 = R2;
          call SkipList.get1_info(R4, R3, R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:46.047494 UTC

SkipList.get_entry() //  [R4, R3, R2]
        { info_tbl: [(cbed,
                      label: SkipList.get_info
                      rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cbed:
          if (HpLim == 0) goto cbee; else goto cbeg;
      cbee:
          R4 = R4;
          R3 = R3;
          R2 = R2;
          R1 = SkipList.get_closure;
          call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
      cbeg:
          R4 = R4;
          R3 = R3;
          R2 = R2;
          call SkipList.get1_info(R4, R3, R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:46.048473 UTC

[section "data" {
     SkipList.get_closure:
         const SkipList.get_info;
         const 0;
 },
 SkipList.get_entry() //  [R4, R3, R2]
         { info_tbl: [(cbed,
                       label: SkipList.get_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbed:
           if (HpLim == 0) goto cbee; else goto cbeg;
       cbee:
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = SkipList.get_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbeg:
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call SkipList.get1_info(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:46.049694 UTC

[section "data" {
     SkipList.get_closure:
         const SkipList.get_info;
         const 0;
 },
 SkipList.get_entry() //  [R4, R3, R2]
         { info_tbl: [(cbed,
                       label: SkipList.get_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbed:
           if (HpLim == 0) goto cbee; else goto cbeg;
       cbee:
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = SkipList.get_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbeg:
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call SkipList.get1_info(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:46.052644 UTC

[section "data" {
     lvl30_rawo_closure:
         const lvl30_rawo_info;
         const 0;
 },
 lvl30_rawo_entry() //  [R4, R3, R2]
         { info_tbl: [(cbeq,
                       label: lvl30_rawo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbeq:
           _saBU::P64 = R4;
           _saBT::P64 = R3;
           _saBS::P64 = R2;
           goto cben;
       cben:
           if ((old + 0) - <highSp> < SpLim) goto cber; else goto cbes;
       cbes:
           goto cbem;
       cbem:
           Hp = Hp + 24;
           if (Hp > HpLim) goto cbeu; else goto cbet;
       cbeu:
           HpAlloc = 24;
           goto cber;
       cber:
           R4 = _saBU::P64;
           R3 = _saBT::P64;
           R2 = _saBS::P64;
           R1 = lvl30_rawo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbet:
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _saBT::P64;
           P64[Hp] = _saBU::P64;
           _cbep::P64 = Hp - 15;
           R5 = lvl19_rawd_closure;
           R4 = _saBS::P64;
           R3 = _cbep::P64;
           R2 = GHC.Show.$fShowInt_closure;
           call GHC.Arr.indexError_info(R5,
                                        R4,
                                        R3,
                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:46.055041 UTC

{offset
  cbeq:
      _saBU::P64 = R4;
      _saBT::P64 = R3;
      _saBS::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cber; else goto cbes;
  cbes:
      Hp = Hp + 24;
      if (Hp > HpLim) goto cbeu; else goto cbet;
  cbeu:
      HpAlloc = 24;
      goto cber;
  cber:
      R4 = _saBU::P64;
      R3 = _saBT::P64;
      R2 = _saBS::P64;
      R1 = lvl30_rawo_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  cbet:
      I64[Hp - 16] = (,)_con_info;
      P64[Hp - 8] = _saBT::P64;
      P64[Hp] = _saBU::P64;
      _cbep::P64 = Hp - 15;
      R5 = lvl19_rawd_closure;
      R4 = _saBS::P64;
      R3 = _cbep::P64;
      R2 = GHC.Show.$fShowInt_closure;
      call GHC.Arr.indexError_info(R5,
                                   R4,
                                   R3,
                                   R2) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:46.056364 UTC

{offset
  cbeq:
      _saBU::P64 = R4;
      _saBT::P64 = R3;
      _saBS::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cber; else goto cbes;
  cbes:
      Hp = Hp + 24;
      if (Hp > HpLim) goto cbeu; else goto cbet;
  cbeu:
      HpAlloc = 24;
      goto cber;
  cber:
      R4 = _saBU::P64;
      R3 = _saBT::P64;
      R2 = _saBS::P64;
      R1 = lvl30_rawo_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  cbet:
      I64[Hp - 16] = (,)_con_info;
      P64[Hp - 8] = _saBT::P64;
      P64[Hp] = _saBU::P64;
      _cbep::P64 = Hp - 15;
      R5 = lvl19_rawd_closure;
      R4 = _saBS::P64;
      R3 = _cbep::P64;
      R2 = GHC.Show.$fShowInt_closure;
      call GHC.Arr.indexError_info(R5,
                                   R4,
                                   R3,
                                   R2) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:46.057724 UTC

{offset
  cbeq:
      _saBU::P64 = R4;
      _saBT::P64 = R3;
      _saBS::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cber; else goto cbes;
  cbes:
      Hp = Hp + 24;
      if (Hp > HpLim) goto cbeu; else goto cbet;
  cbeu:
      HpAlloc = 24;
      goto cber;
  cber:
      R4 = _saBU::P64;
      R3 = _saBT::P64;
      R2 = _saBS::P64;
      R1 = lvl30_rawo_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  cbet:
      I64[Hp - 16] = (,)_con_info;
      P64[Hp - 8] = _saBT::P64;
      P64[Hp] = _saBU::P64;
      _cbep::P64 = Hp - 15;
      R5 = lvl19_rawd_closure;
      R4 = _saBS::P64;
      R3 = _cbep::P64;
      R2 = GHC.Show.$fShowInt_closure;
      call GHC.Arr.indexError_info(R5,
                                   R4,
                                   R3,
                                   R2) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:46.059097 UTC

{offset
  cbeq:
      _saBU::P64 = R4;
      _saBT::P64 = R3;
      _saBS::P64 = R2;
      goto cbes;
  cbes:
      Hp = Hp + 24;
      if (Hp > HpLim) goto cbeu; else goto cbet;
  cbeu:
      HpAlloc = 24;
      goto cber;
  cber:
      R4 = _saBU::P64;
      R3 = _saBT::P64;
      R2 = _saBS::P64;
      R1 = lvl30_rawo_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  cbet:
      I64[Hp - 16] = (,)_con_info;
      P64[Hp - 8] = _saBT::P64;
      P64[Hp] = _saBU::P64;
      _cbep::P64 = Hp - 15;
      R5 = lvl19_rawd_closure;
      R4 = _saBS::P64;
      R3 = _cbep::P64;
      R2 = GHC.Show.$fShowInt_closure;
      call GHC.Arr.indexError_info(R5,
                                   R4,
                                   R3,
                                   R2) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:46.06034 UTC

{offset
  cbeq:
      goto cbes;
  cbes:
      Hp = Hp + 24;
      if (Hp > HpLim) goto cbeu; else goto cbet;
  cbeu:
      HpAlloc = 24;
      goto cber;
  cber:
      R4 = R4;
      R3 = R3;
      R2 = R2;
      R1 = lvl30_rawo_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  cbet:
      I64[Hp - 16] = (,)_con_info;
      P64[Hp - 8] = R3;
      P64[Hp] = R4;
      R5 = lvl19_rawd_closure;
      R4 = R2;
      R3 = Hp - 15;
      R2 = GHC.Show.$fShowInt_closure;
      call GHC.Arr.indexError_info(R5,
                                   R4,
                                   R3,
                                   R2) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:46.06172 UTC

[(cbeq,
  {GHC.Arr.indexError_closure, lvl19_rawd_closure,
   lvl30_rawo_closure}),
 (cber, {lvl30_rawo_closure}),
 (cbes,
  {GHC.Arr.indexError_closure, lvl19_rawd_closure,
   lvl30_rawo_closure}),
 (cbet, {GHC.Arr.indexError_closure, lvl19_rawd_closure}),
 (cbeu, {lvl30_rawo_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:46.062416 UTC

lvl30_rawo_entry() //  [R4, R3, R2]
        { info_tbl: [(cbeq,
                      label: lvl30_rawo_info
                      rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cbeq:
          goto cbes;
      cbes:
          Hp = Hp + 24;
          if (Hp > HpLim) goto cbeu; else goto cbet;
      cbeu:
          HpAlloc = 24;
          goto cber;
      cber:
          R4 = R4;
          R3 = R3;
          R2 = R2;
          R1 = lvl30_rawo_closure;
          call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
      cbet:
          I64[Hp - 16] = (,)_con_info;
          P64[Hp - 8] = R3;
          P64[Hp] = R4;
          R5 = lvl19_rawd_closure;
          R4 = R2;
          R3 = Hp - 15;
          R2 = GHC.Show.$fShowInt_closure;
          call GHC.Arr.indexError_info(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:46.064396 UTC

lvl30_rawo_entry() //  [R4, R3, R2]
        { info_tbl: [(cbeq,
                      label: lvl30_rawo_info
                      rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cbeq:
          Hp = Hp + 24;
          if (Hp > HpLim) goto cbeu; else goto cbet;
      cbeu:
          HpAlloc = 24;
          R4 = R4;
          R3 = R3;
          R2 = R2;
          R1 = lvl30_rawo_closure;
          call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
      cbet:
          I64[Hp - 16] = (,)_con_info;
          P64[Hp - 8] = R3;
          P64[Hp] = R4;
          R5 = lvl19_rawd_closure;
          R4 = R2;
          R3 = Hp - 15;
          R2 = GHC.Show.$fShowInt_closure;
          call GHC.Arr.indexError_info(R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:46.065698 UTC

[section "data" {
     lvl30_rawo_closure:
         const lvl30_rawo_info;
         const 0;
 },
 lvl30_rawo_entry() //  [R4, R3, R2]
         { info_tbl: [(cbeq,
                       label: lvl30_rawo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbeq:
           Hp = Hp + 24;
           if (Hp > HpLim) goto cbeu; else goto cbet;
       cbeu:
           HpAlloc = 24;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = lvl30_rawo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbet:
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R5 = lvl19_rawd_closure;
           R4 = R2;
           R3 = Hp - 15;
           R2 = GHC.Show.$fShowInt_closure;
           call GHC.Arr.indexError_info(R5,
                                        R4,
                                        R3,
                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:46.06725 UTC

[section "data" {
     lvl30_rawo_closure:
         const lvl30_rawo_info;
         const 0;
 },
 lvl30_rawo_entry() //  [R4, R3, R2]
         { info_tbl: [(cbeq,
                       label: lvl30_rawo_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbeq:
           Hp = Hp + 24;
           if (Hp > HpLim) goto cbeu; else goto cbet;
       cbeu:
           HpAlloc = 24;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = lvl30_rawo_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbet:
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R5 = lvl19_rawd_closure;
           R4 = R2;
           R3 = Hp - 15;
           R2 = GHC.Show.$fShowInt_closure;
           call GHC.Arr.indexError_info(R5,
                                        R4,
                                        R3,
                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:46.072318 UTC

[section "data" {
     $s$wpoly_a_rawp_closure:
         const $s$wpoly_a_rawp_info;
         const 0;
 },
 $s$wpoly_a_rawp_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 48 updfr_space: Just 8
         }
     {offset
       cbg9:
           _rawp::P64 = R1;
           _saBW::I64 = I64[(old + 48)];
           _saBX::I64 = I64[(old + 40)];
           _saBY::I64 = I64[(old + 32)];
           _saBZ::I64 = I64[(old + 24)];
           _saC0::P64 = P64[(old + 16)];
           R6 = _saC0::P64;
           R5 = _saBZ::I64;
           R4 = _saBY::I64;
           R3 = _saBX::I64;
           R2 = _saBW::I64;
           R1 = _rawp::P64;
           call $s$wpoly_a_rawp_info(R6,
                                     R5,
                                     R4,
                                     R3,
                                     R2,
                                     R1) args: 8, res: 0, upd: 8;
     }
 },
 $s$wpoly_a_rawp_entry() //  [R6, R5, R4, R3, R2]
         { info_tbl: [(cbgh,
                       label: $s$wpoly_a_rawp_info
                       rep:HeapRep static {
                             Fun {arity: 7 fun_type: ArgGen [True, True, True, True, False]} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbgh:
           _saC0::P64 = R6;
           _saBZ::I64 = R5;
           _saBY::I64 = R4;
           _saBX::I64 = R3;
           _saBW::I64 = R2;
           goto cbgb;
       cbgb:
           if ((old + 0) - <highSp> < SpLim) goto cbgi; else goto cbgj;
       cbgj:
           goto cbga;
       cbga:
           Hp = Hp + 48;
           if (Hp > HpLim) goto cbgl; else goto cbgk;
       cbgl:
           HpAlloc = 48;
           goto cbgi;
       cbgi:
           R1 = $s$wpoly_a_rawp_closure;
           I64[(old + 48)] = _saBW::I64;
           I64[(old + 40)] = _saBX::I64;
           I64[(old + 32)] = _saBY::I64;
           I64[(old + 24)] = _saBZ::I64;
           P64[(old + 16)] = _saC0::P64;
           call (stg_gc_fun)(R1) args: 48, res: 0, upd: 8;
       cbgk:
           _saC2::I64 = _saBW::I64;
           switch [-9223372036854775808 .. 9223372036854775807] _saC2::I64 {
               case 0 : goto cbgg;
               default: goto cbgf;
           }
       cbgg:
           Hp = Hp - 48;
           R1 = GHC.Types.True_closure+2;
           call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
       cbgf:
           _cbgn::I64 = %MO_S_Le_W64(_saBX::I64, _saC2::I64);
           _saC3::I64 = _cbgn::I64;
           switch [0 .. 1] _saC3::I64 {
               case 0 : goto cbgw;
               case 1 : goto cbiD;
           }
       cbiD:
           _cbgy::I64 = %MO_S_Le_W64(_saC2::I64, _saBY::I64);
           _saC9::I64 = _cbgy::I64;
           switch [0 .. 1] _saC9::I64 {
               case 0 : goto cbgH;
               case 1 : goto cbiC;
           }
       cbiC:
           _cbgJ::I64 = _saC2::I64 - _saBX::I64;
           _saCf::I64 = _cbgJ::I64;
           _cbgM::I64 = %MO_S_Le_W64(0, _saCf::I64);
           _saCg::I64 = _cbgM::I64;
           switch [0 .. 1] _saCg::I64 {
               case 0 : goto cbgR;
               case 1 : goto cbiB;
           }
       cbiB:
           _cbgU::I64 = %MO_S_Lt_W64(_saCf::I64, _saBZ::I64);
           _saCj::I64 = _cbgU::I64;
           switch [0 .. 1] _saCj::I64 {
               case 0 : goto cbgZ;
               case 1 : goto cbh3;
           }
       cbh3:
           _saCn::P64 = P64[(_saC0::P64 + 24) + (_saCf::I64 << 3)];
           _saCn::P64 = _saCn::P64;
           Hp = Hp - 48;
           I64[(young<cbh2> + 8)] = cbh2;
           R1 = _saCn::P64;
           if (R1 & 7 != 0) goto cbh2; else goto cbh4;
       cbh4:
           call (I64[R1])(R1) returns to cbh2, args: 8, res: 8, upd: 8;
       cbh2:
           _saCo::P64 = R1;
           _saCp::P64 = P64[_saCo::P64 + 7];
           I64[(young<cbh8> + 8)] = cbh8;
           R1 = _saCp::P64;
           call stg_norec_readTVar#(R1) returns to cbh8, args: 8, res: 8, upd: 8;
       cbh8:
           _saCs::P64 = R1;
           I64[(young<cbha> + 8)] = cbha;
           R1 = _saCs::P64;
           if (R1 & 7 != 0) goto cbha; else goto cbhd;
       cbhd:
           call (I64[R1])(R1) returns to cbha, args: 8, res: 8, upd: 8;
       cbha:
           _saCt::P64 = R1;
           _cbiE::P64 = _saCt::P64 & 7;
           switch [1 .. 2] _cbiE::P64 {
               case 1 : goto cbhj;
               case 2 : goto cbhy;
           }
       cbhy:
           _saCv::P64 = P64[_saCt::P64 + 6];
           _saCw::P64 = P64[_saCt::P64 + 14];
           _saCx::P64 = P64[_saCt::P64 + 22];
           I64[(young<cbhm> + 8)] = cbhm;
           R1 = _saCx::P64;
           if (R1 & 7 != 0) goto cbhm; else goto cbhn;
       cbhn:
           call (I64[R1])(R1) returns to cbhm, args: 8, res: 8, upd: 8;
       cbhm:
           _saCy::P64 = R1;
           _saCz::P64 = P64[_saCy::P64 + 7];
           _saCA::P64 = P64[_saCy::P64 + 15];
           _saCC::P64 = P64[_saCy::P64 + 23];
           _saCB::I64 = I64[_saCy::P64 + 31];
           I64[(young<cbhr> + 8)] = cbhr;
           R1 = _saCz::P64;
           if (R1 & 7 != 0) goto cbhr; else goto cbhs;
       cbhs:
           call (I64[R1])(R1) returns to cbhr, args: 8, res: 8, upd: 8;
       cbhr:
           _saCD::P64 = R1;
           _saCE::I64 = I64[_saCD::P64 + 7];
           I64[(young<cbhw> + 8)] = cbhw;
           R1 = _saCA::P64;
           if (R1 & 7 != 0) goto cbhw; else goto cbhB;
       cbhB:
           call (I64[R1])(R1) returns to cbhw, args: 8, res: 8, upd: 8;
       cbhw:
           _saCF::P64 = R1;
           Hp = Hp + 16;
           if (Hp > HpLim) goto cbhH; else goto cbhG;
       cbhH:
           HpAlloc = 16;
           goto cbhF;
       cbhF:
           R1 = _saCF::P64;
           call stg_gc_unpt_r1(R1) returns to cbhw, args: 8, res: 8, upd: 8;
       cbhG:
           _saCG::I64 = I64[_saCF::P64 + 7];
           _cbhI::I64 = %MO_S_Le_W64(_saCE::I64, _saC2::I64);
           _saCH::I64 = _cbhI::I64;
           switch [0 .. 1] _saCH::I64 {
               case 0 : goto cbhP;
               case 1 : goto cbiA;
           }
       cbiA:
           _cbhR::I64 = %MO_S_Le_W64(_saC2::I64, _saCG::I64);
           _saCL::I64 = _cbhR::I64;
           switch [0 .. 1] _saCL::I64 {
               case 0 : goto cbhY;
               case 1 : goto cbiz;
           }
       cbiz:
           _cbi0::I64 = _saC2::I64 - _saCE::I64;
           _saCP::I64 = _cbi0::I64;
           _cbi3::I64 = %MO_S_Le_W64(0, _saCP::I64);
           _saCQ::I64 = _cbi3::I64;
           switch [0 .. 1] _saCQ::I64 {
               case 0 : goto cbi8;
               case 1 : goto cbiy;
           }
       cbiy:
           _cbib::I64 = %MO_S_Lt_W64(_saCP::I64, _saCB::I64);
           _saCT::I64 = _cbib::I64;
           switch [0 .. 1] _saCT::I64 {
               case 0 : goto cbig;
               case 1 : goto cbir;
           }
       cbir:
           _saCX::P64 = P64[(_saCC::P64 + 24) + (_saCP::I64 << 3)];
           _saCX::P64 = _saCX::P64;
           Hp = Hp - 16;
           I64[(young<cbij> + 8)] = cbij;
           R1 = _saCX::P64;
           if (R1 & 7 != 0) goto cbij; else goto cbik;
       cbik:
           call (I64[R1])(R1) returns to cbij, args: 8, res: 8, upd: 8;
       cbij:
           _saCY::P64 = R1;
           _saCZ::P64 = P64[_saCY::P64 + 7];
           I64[(young<cbio> + 8)] = cbio;
           R1 = _saCZ::P64;
           call stg_norec_readTVar#(R1) returns to cbio, args: 8, res: 8, upd: 8;
       cbio:
           _saD2::P64 = R1;
           I64[(young<cbiq> + 8)] = cbiq;
           R2 = _saD2::P64;
           R1 = _saCp::P64;
           call stg_norec_writeTVar#(R2,
                                     R1) returns to cbiq, args: 8, res: 8, upd: 8;
       cbiq:
           _cbiF::I64 = _saC2::I64 - 1;
           _saD4::I64 = _cbiF::I64;
           R6 = _saC0::P64;
           R5 = _saBZ::I64;
           R4 = _saBY::I64;
           R3 = _saBX::I64;
           R2 = _saD4::I64;
           call $s$wpoly_a_rawp_info(R6,
                                     R5,
                                     R4,
                                     R3,
                                     R2) args: 8, res: 0, upd: 8;
       cbig:
           Hp = Hp - 16;
           R3 = _saCP::I64;
           R2 = _saCB::I64;
           call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
       cbi8:
           Hp = Hp - 16;
           R3 = _saCP::I64;
           R2 = _saCB::I64;
           call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
       cbhY:
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saC2::I64;
           _cbhW::P64 = Hp - 7;
           R4 = _saCF::P64;
           R3 = _saCD::P64;
           R2 = _cbhW::P64;
           call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
       cbhP:
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saC2::I64;
           _cbhN::P64 = Hp - 7;
           R4 = _saCF::P64;
           R3 = _saCD::P64;
           R2 = _cbhN::P64;
           call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
       cbhj:
           R1 = SkipList._getNodes1_closure;
           call (I64[R1])(R1) args: 8, res: 0, upd: 8;
       cbgZ:
           Hp = Hp - 48;
           R3 = _saCf::I64;
           R2 = _saBZ::I64;
           call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
       cbgR:
           Hp = Hp - 48;
           R3 = _saCf::I64;
           R2 = _saBZ::I64;
           call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
       cbgH:
           I64[Hp - 40] = GHC.Types.I#_con_info;
           I64[Hp - 32] = _saBY::I64;
           _cbgD::P64 = Hp - 39;
           I64[Hp - 24] = GHC.Types.I#_con_info;
           I64[Hp - 16] = _saBX::I64;
           _cbgE::P64 = Hp - 23;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saC2::I64;
           _cbgF::P64 = Hp - 7;
           R4 = _cbgD::P64;
           R3 = _cbgE::P64;
           R2 = _cbgF::P64;
           call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
       cbgw:
           I64[Hp - 40] = GHC.Types.I#_con_info;
           I64[Hp - 32] = _saBY::I64;
           _cbgs::P64 = Hp - 39;
           I64[Hp - 24] = GHC.Types.I#_con_info;
           I64[Hp - 16] = _saBX::I64;
           _cbgt::P64 = Hp - 23;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saC2::I64;
           _cbgu::P64 = Hp - 7;
           R4 = _cbgs::P64;
           R3 = _cbgt::P64;
           R2 = _cbgu::P64;
           call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:46.091396 UTC

{offset
  cbg9:
      _rawp::P64 = R1;
      _saBW::I64 = I64[(old + 48)];
      _saBX::I64 = I64[(old + 40)];
      _saBY::I64 = I64[(old + 32)];
      _saBZ::I64 = I64[(old + 24)];
      _saC0::P64 = P64[(old + 16)];
      R6 = _saC0::P64;
      R5 = _saBZ::I64;
      R4 = _saBY::I64;
      R3 = _saBX::I64;
      R2 = _saBW::I64;
      R1 = _rawp::P64;
      call $s$wpoly_a_rawp_info(R6,
                                R5,
                                R4,
                                R3,
                                R2,
                                R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:46.092348 UTC

{offset
  cbg9:
      _rawp::P64 = R1;
      _saBW::I64 = I64[(old + 48)];
      _saBX::I64 = I64[(old + 40)];
      _saBY::I64 = I64[(old + 32)];
      _saBZ::I64 = I64[(old + 24)];
      _saC0::P64 = P64[(old + 16)];
      R6 = _saC0::P64;
      R5 = _saBZ::I64;
      R4 = _saBY::I64;
      R3 = _saBX::I64;
      R2 = _saBW::I64;
      R1 = _rawp::P64;
      call $s$wpoly_a_rawp_info(R6,
                                R5,
                                R4,
                                R3,
                                R2,
                                R1) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:46.093249 UTC

{offset
  cbg9:
      _rawp::P64 = R1;
      _saBW::I64 = I64[(old + 48)];
      _saBX::I64 = I64[(old + 40)];
      _saBY::I64 = I64[(old + 32)];
      _saBZ::I64 = I64[(old + 24)];
      _saC0::P64 = P64[(old + 16)];
      R6 = _saC0::P64;
      R5 = _saBZ::I64;
      R4 = _saBY::I64;
      R3 = _saBX::I64;
      R2 = _saBW::I64;
      R1 = _rawp::P64;
      call $s$wpoly_a_rawp_info(R6,
                                R5,
                                R4,
                                R3,
                                R2,
                                R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:46.094128 UTC

{offset
  cbg9:
      _rawp::P64 = R1;
      _saBW::I64 = I64[Sp];
      _saBX::I64 = I64[Sp + 8];
      _saBY::I64 = I64[Sp + 16];
      _saBZ::I64 = I64[Sp + 24];
      _saC0::P64 = P64[Sp + 32];
      R6 = _saC0::P64;
      R5 = _saBZ::I64;
      R4 = _saBY::I64;
      R3 = _saBX::I64;
      R2 = _saBW::I64;
      R1 = _rawp::P64;
      Sp = Sp + 40;
      call $s$wpoly_a_rawp_info(R6,
                                R5,
                                R4,
                                R3,
                                R2,
                                R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:46.095033 UTC

{offset
  cbg9:
      R6 = P64[Sp + 32];
      R5 = I64[Sp + 24];
      R4 = I64[Sp + 16];
      R3 = I64[Sp + 8];
      R2 = I64[Sp];
      R1 = R1;
      Sp = Sp + 40;
      call $s$wpoly_a_rawp_info(R6,
                                R5,
                                R4,
                                R3,
                                R2,
                                R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:46.095858 UTC

[(cbg9, {$s$wpoly_a_rawp_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:46.096132 UTC

$s$wpoly_a_rawp_slow() //  [R1]
        { info_tbl: []
          stack_info: arg_space: 48 updfr_space: Just 8
        }
    {offset
      cbg9:
          R6 = P64[Sp + 32];
          R5 = I64[Sp + 24];
          R4 = I64[Sp + 16];
          R3 = I64[Sp + 8];
          R2 = I64[Sp];
          R1 = R1;
          Sp = Sp + 40;
          call $s$wpoly_a_rawp_info(R6,
                                    R5,
                                    R4,
                                    R3,
                                    R2,
                                    R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:46.096926 UTC

$s$wpoly_a_rawp_slow() //  [R1]
        { info_tbl: []
          stack_info: arg_space: 48 updfr_space: Just 8
        }
    {offset
      cbg9:
          R6 = P64[Sp + 32];
          R5 = I64[Sp + 24];
          R4 = I64[Sp + 16];
          R3 = I64[Sp + 8];
          R2 = I64[Sp];
          R1 = R1;
          Sp = Sp + 40;
          call $s$wpoly_a_rawp_info(R6,
                                    R5,
                                    R4,
                                    R3,
                                    R2,
                                    R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:46.097756 UTC

{offset
  cbgh:
      _saC0::P64 = R6;
      _saBZ::I64 = R5;
      _saBY::I64 = R4;
      _saBX::I64 = R3;
      _saBW::I64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cbgi; else goto cbgj;
  cbgj:
      Hp = Hp + 48;
      if (Hp > HpLim) goto cbgl; else goto cbgk;
  cbgl:
      HpAlloc = 48;
      goto cbgi;
  cbgi:
      R1 = $s$wpoly_a_rawp_closure;
      I64[(old + 48)] = _saBW::I64;
      I64[(old + 40)] = _saBX::I64;
      I64[(old + 32)] = _saBY::I64;
      I64[(old + 24)] = _saBZ::I64;
      P64[(old + 16)] = _saC0::P64;
      call (stg_gc_fun)(R1) args: 48, res: 0, upd: 8;
  cbgk:
      _saC2::I64 = _saBW::I64;
      switch [-9223372036854775808 .. 9223372036854775807] _saC2::I64 {
          case 0 : goto cbgg;
          default: goto cbgf;
      }
  cbgg:
      Hp = Hp - 48;
      R1 = GHC.Types.True_closure+2;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
  cbgf:
      _cbgn::I64 = %MO_S_Le_W64(_saBX::I64, _saC2::I64);
      _saC3::I64 = _cbgn::I64;
      switch [0 .. 1] _saC3::I64 {
          case 0 : goto cbgw;
          case 1 : goto cbiD;
      }
  cbiD:
      _cbgy::I64 = %MO_S_Le_W64(_saC2::I64, _saBY::I64);
      _saC9::I64 = _cbgy::I64;
      switch [0 .. 1] _saC9::I64 {
          case 0 : goto cbgH;
          case 1 : goto cbiC;
      }
  cbiC:
      _cbgJ::I64 = _saC2::I64 - _saBX::I64;
      _saCf::I64 = _cbgJ::I64;
      _cbgM::I64 = %MO_S_Le_W64(0, _saCf::I64);
      _saCg::I64 = _cbgM::I64;
      switch [0 .. 1] _saCg::I64 {
          case 0 : goto cbgR;
          case 1 : goto cbiB;
      }
  cbiB:
      _cbgU::I64 = %MO_S_Lt_W64(_saCf::I64, _saBZ::I64);
      _saCj::I64 = _cbgU::I64;
      switch [0 .. 1] _saCj::I64 {
          case 0 : goto cbgZ;
          case 1 : goto cbh3;
      }
  cbh3:
      _saCn::P64 = P64[(_saC0::P64 + 24) + (_saCf::I64 << 3)];
      _saCn::P64 = _saCn::P64;
      Hp = Hp - 48;
      I64[(young<cbh2> + 8)] = cbh2;
      R1 = _saCn::P64;
      if (R1 & 7 != 0) goto cbh2; else goto cbh4;
  cbh4:
      call (I64[R1])(R1) returns to cbh2, args: 8, res: 8, upd: 8;
  cbh2:
      _saCo::P64 = R1;
      _saCp::P64 = P64[_saCo::P64 + 7];
      I64[(young<cbh8> + 8)] = cbh8;
      R1 = _saCp::P64;
      call stg_norec_readTVar#(R1) returns to cbh8, args: 8, res: 8, upd: 8;
  cbh8:
      _saCs::P64 = R1;
      I64[(young<cbha> + 8)] = cbha;
      R1 = _saCs::P64;
      if (R1 & 7 != 0) goto cbha; else goto cbhd;
  cbhd:
      call (I64[R1])(R1) returns to cbha, args: 8, res: 8, upd: 8;
  cbha:
      _saCt::P64 = R1;
      _cbiE::P64 = _saCt::P64 & 7;
      switch [1 .. 2] _cbiE::P64 {
          case 1 : goto cbhj;
          case 2 : goto cbhy;
      }
  cbhy:
      _saCv::P64 = P64[_saCt::P64 + 6];
      _saCw::P64 = P64[_saCt::P64 + 14];
      _saCx::P64 = P64[_saCt::P64 + 22];
      I64[(young<cbhm> + 8)] = cbhm;
      R1 = _saCx::P64;
      if (R1 & 7 != 0) goto cbhm; else goto cbhn;
  cbhn:
      call (I64[R1])(R1) returns to cbhm, args: 8, res: 8, upd: 8;
  cbhm:
      _saCy::P64 = R1;
      _saCz::P64 = P64[_saCy::P64 + 7];
      _saCA::P64 = P64[_saCy::P64 + 15];
      _saCC::P64 = P64[_saCy::P64 + 23];
      _saCB::I64 = I64[_saCy::P64 + 31];
      I64[(young<cbhr> + 8)] = cbhr;
      R1 = _saCz::P64;
      if (R1 & 7 != 0) goto cbhr; else goto cbhs;
  cbhs:
      call (I64[R1])(R1) returns to cbhr, args: 8, res: 8, upd: 8;
  cbhr:
      _saCD::P64 = R1;
      _saCE::I64 = I64[_saCD::P64 + 7];
      I64[(young<cbhw> + 8)] = cbhw;
      R1 = _saCA::P64;
      if (R1 & 7 != 0) goto cbhw; else goto cbhB;
  cbhB:
      call (I64[R1])(R1) returns to cbhw, args: 8, res: 8, upd: 8;
  cbhw:
      _saCF::P64 = R1;
      Hp = Hp + 16;
      if (Hp > HpLim) goto cbhH; else goto cbhG;
  cbhH:
      HpAlloc = 16;
      R1 = _saCF::P64;
      call stg_gc_unpt_r1(R1) returns to cbhw, args: 8, res: 8, upd: 8;
  cbhG:
      _saCG::I64 = I64[_saCF::P64 + 7];
      _cbhI::I64 = %MO_S_Le_W64(_saCE::I64, _saC2::I64);
      _saCH::I64 = _cbhI::I64;
      switch [0 .. 1] _saCH::I64 {
          case 0 : goto cbhP;
          case 1 : goto cbiA;
      }
  cbiA:
      _cbhR::I64 = %MO_S_Le_W64(_saC2::I64, _saCG::I64);
      _saCL::I64 = _cbhR::I64;
      switch [0 .. 1] _saCL::I64 {
          case 0 : goto cbhY;
          case 1 : goto cbiz;
      }
  cbiz:
      _cbi0::I64 = _saC2::I64 - _saCE::I64;
      _saCP::I64 = _cbi0::I64;
      _cbi3::I64 = %MO_S_Le_W64(0, _saCP::I64);
      _saCQ::I64 = _cbi3::I64;
      switch [0 .. 1] _saCQ::I64 {
          case 0 : goto cbi8;
          case 1 : goto cbiy;
      }
  cbiy:
      _cbib::I64 = %MO_S_Lt_W64(_saCP::I64, _saCB::I64);
      _saCT::I64 = _cbib::I64;
      switch [0 .. 1] _saCT::I64 {
          case 0 : goto cbig;
          case 1 : goto cbir;
      }
  cbir:
      _saCX::P64 = P64[(_saCC::P64 + 24) + (_saCP::I64 << 3)];
      _saCX::P64 = _saCX::P64;
      Hp = Hp - 16;
      I64[(young<cbij> + 8)] = cbij;
      R1 = _saCX::P64;
      if (R1 & 7 != 0) goto cbij; else goto cbik;
  cbik:
      call (I64[R1])(R1) returns to cbij, args: 8, res: 8, upd: 8;
  cbij:
      _saCY::P64 = R1;
      _saCZ::P64 = P64[_saCY::P64 + 7];
      I64[(young<cbio> + 8)] = cbio;
      R1 = _saCZ::P64;
      call stg_norec_readTVar#(R1) returns to cbio, args: 8, res: 8, upd: 8;
  cbio:
      _saD2::P64 = R1;
      I64[(young<cbiq> + 8)] = cbiq;
      R2 = _saD2::P64;
      R1 = _saCp::P64;
      call stg_norec_writeTVar#(R2,
                                R1) returns to cbiq, args: 8, res: 8, upd: 8;
  cbiq:
      _cbiF::I64 = _saC2::I64 - 1;
      _saD4::I64 = _cbiF::I64;
      R6 = _saC0::P64;
      R5 = _saBZ::I64;
      R4 = _saBY::I64;
      R3 = _saBX::I64;
      R2 = _saD4::I64;
      call $s$wpoly_a_rawp_info(R6,
                                R5,
                                R4,
                                R3,
                                R2) args: 8, res: 0, upd: 8;
  cbig:
      Hp = Hp - 16;
      R3 = _saCP::I64;
      R2 = _saCB::I64;
      call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
  cbi8:
      Hp = Hp - 16;
      R3 = _saCP::I64;
      R2 = _saCB::I64;
      call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
  cbhY:
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _saC2::I64;
      _cbhW::P64 = Hp - 7;
      R4 = _saCF::P64;
      R3 = _saCD::P64;
      R2 = _cbhW::P64;
      call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbhP:
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _saC2::I64;
      _cbhN::P64 = Hp - 7;
      R4 = _saCF::P64;
      R3 = _saCD::P64;
      R2 = _cbhN::P64;
      call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbhj:
      R1 = SkipList._getNodes1_closure;
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
  cbgZ:
      Hp = Hp - 48;
      R3 = _saCf::I64;
      R2 = _saBZ::I64;
      call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
  cbgR:
      Hp = Hp - 48;
      R3 = _saCf::I64;
      R2 = _saBZ::I64;
      call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
  cbgH:
      I64[Hp - 40] = GHC.Types.I#_con_info;
      I64[Hp - 32] = _saBY::I64;
      _cbgD::P64 = Hp - 39;
      I64[Hp - 24] = GHC.Types.I#_con_info;
      I64[Hp - 16] = _saBX::I64;
      _cbgE::P64 = Hp - 23;
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _saC2::I64;
      _cbgF::P64 = Hp - 7;
      R4 = _cbgD::P64;
      R3 = _cbgE::P64;
      R2 = _cbgF::P64;
      call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbgw:
      I64[Hp - 40] = GHC.Types.I#_con_info;
      I64[Hp - 32] = _saBY::I64;
      _cbgs::P64 = Hp - 39;
      I64[Hp - 24] = GHC.Types.I#_con_info;
      I64[Hp - 16] = _saBX::I64;
      _cbgt::P64 = Hp - 23;
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _saC2::I64;
      _cbgu::P64 = Hp - 7;
      R4 = _cbgs::P64;
      R3 = _cbgt::P64;
      R2 = _cbgu::P64;
      call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:46.10915 UTC

{offset
  cbgh:
      _saC0::P64 = R6;
      _saBZ::I64 = R5;
      _saBY::I64 = R4;
      _saBX::I64 = R3;
      _saBW::I64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cbgi; else goto cbgj;
  cbgj:
      Hp = Hp + 48;
      if (Hp > HpLim) goto cbgl; else goto cbgk;
  cbgl:
      HpAlloc = 48;
      goto cbgi;
  cbgi:
      R1 = $s$wpoly_a_rawp_closure;
      I64[(old + 48)] = _saBW::I64;
      I64[(old + 40)] = _saBX::I64;
      I64[(old + 32)] = _saBY::I64;
      I64[(old + 24)] = _saBZ::I64;
      P64[(old + 16)] = _saC0::P64;
      call (stg_gc_fun)(R1) args: 48, res: 0, upd: 8;
  cbgk:
      _saC2::I64 = _saBW::I64;
      switch [-9223372036854775808 .. 9223372036854775807] _saC2::I64 {
          case 0 : goto cbgg;
          default: goto cbgf;
      }
  cbgg:
      Hp = Hp - 48;
      R1 = GHC.Types.True_closure+2;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
  cbgf:
      _cbgn::I64 = %MO_S_Le_W64(_saBX::I64, _saC2::I64);
      _saC3::I64 = _cbgn::I64;
      switch [0 .. 1] _saC3::I64 {
          case 0 : goto cbgw;
          case 1 : goto cbiD;
      }
  cbiD:
      _cbgy::I64 = %MO_S_Le_W64(_saC2::I64, _saBY::I64);
      _saC9::I64 = _cbgy::I64;
      switch [0 .. 1] _saC9::I64 {
          case 0 : goto cbgH;
          case 1 : goto cbiC;
      }
  cbiC:
      _cbgJ::I64 = _saC2::I64 - _saBX::I64;
      _saCf::I64 = _cbgJ::I64;
      _cbgM::I64 = %MO_S_Le_W64(0, _saCf::I64);
      _saCg::I64 = _cbgM::I64;
      switch [0 .. 1] _saCg::I64 {
          case 0 : goto cbgZ;
          case 1 : goto cbiB;
      }
  cbiB:
      _cbgU::I64 = %MO_S_Lt_W64(_saCf::I64, _saBZ::I64);
      _saCj::I64 = _cbgU::I64;
      switch [0 .. 1] _saCj::I64 {
          case 0 : goto cbgZ;
          case 1 : goto cbh3;
      }
  cbh3:
      _saCn::P64 = P64[(_saC0::P64 + 24) + (_saCf::I64 << 3)];
      _saCn::P64 = _saCn::P64;
      Hp = Hp - 48;
      I64[(young<cbh2> + 8)] = cbh2;
      R1 = _saCn::P64;
      if (R1 & 7 != 0) goto cbh2; else goto cbh4;
  cbh4:
      call (I64[R1])(R1) returns to cbh2, args: 8, res: 8, upd: 8;
  cbh2:
      _saCo::P64 = R1;
      _saCp::P64 = P64[_saCo::P64 + 7];
      I64[(young<cbh8> + 8)] = cbh8;
      R1 = _saCp::P64;
      call stg_norec_readTVar#(R1) returns to cbh8, args: 8, res: 8, upd: 8;
  cbh8:
      _saCs::P64 = R1;
      I64[(young<cbha> + 8)] = cbha;
      R1 = _saCs::P64;
      if (R1 & 7 != 0) goto cbha; else goto cbhd;
  cbhd:
      call (I64[R1])(R1) returns to cbha, args: 8, res: 8, upd: 8;
  cbha:
      _saCt::P64 = R1;
      _cbiE::P64 = _saCt::P64 & 7;
      switch [1 .. 2] _cbiE::P64 {
          case 1 : goto cbhj;
          case 2 : goto cbhy;
      }
  cbhy:
      _saCv::P64 = P64[_saCt::P64 + 6];
      _saCw::P64 = P64[_saCt::P64 + 14];
      _saCx::P64 = P64[_saCt::P64 + 22];
      I64[(young<cbhm> + 8)] = cbhm;
      R1 = _saCx::P64;
      if (R1 & 7 != 0) goto cbhm; else goto cbhn;
  cbhn:
      call (I64[R1])(R1) returns to cbhm, args: 8, res: 8, upd: 8;
  cbhm:
      _saCy::P64 = R1;
      _saCz::P64 = P64[_saCy::P64 + 7];
      _saCA::P64 = P64[_saCy::P64 + 15];
      _saCC::P64 = P64[_saCy::P64 + 23];
      _saCB::I64 = I64[_saCy::P64 + 31];
      I64[(young<cbhr> + 8)] = cbhr;
      R1 = _saCz::P64;
      if (R1 & 7 != 0) goto cbhr; else goto cbhs;
  cbhs:
      call (I64[R1])(R1) returns to cbhr, args: 8, res: 8, upd: 8;
  cbhr:
      _saCD::P64 = R1;
      _saCE::I64 = I64[_saCD::P64 + 7];
      I64[(young<cbhw> + 8)] = cbhw;
      R1 = _saCA::P64;
      if (R1 & 7 != 0) goto cbhw; else goto cbhB;
  cbhB:
      call (I64[R1])(R1) returns to cbhw, args: 8, res: 8, upd: 8;
  cbhw:
      _saCF::P64 = R1;
      Hp = Hp + 16;
      if (Hp > HpLim) goto cbhH; else goto cbhG;
  cbhH:
      HpAlloc = 16;
      R1 = _saCF::P64;
      call stg_gc_unpt_r1(R1) returns to cbhw, args: 8, res: 8, upd: 8;
  cbhG:
      _saCG::I64 = I64[_saCF::P64 + 7];
      _cbhI::I64 = %MO_S_Le_W64(_saCE::I64, _saC2::I64);
      _saCH::I64 = _cbhI::I64;
      switch [0 .. 1] _saCH::I64 {
          case 0 : goto cbhP;
          case 1 : goto cbiA;
      }
  cbiA:
      _cbhR::I64 = %MO_S_Le_W64(_saC2::I64, _saCG::I64);
      _saCL::I64 = _cbhR::I64;
      switch [0 .. 1] _saCL::I64 {
          case 0 : goto cbhY;
          case 1 : goto cbiz;
      }
  cbiz:
      _cbi0::I64 = _saC2::I64 - _saCE::I64;
      _saCP::I64 = _cbi0::I64;
      _cbi3::I64 = %MO_S_Le_W64(0, _saCP::I64);
      _saCQ::I64 = _cbi3::I64;
      switch [0 .. 1] _saCQ::I64 {
          case 0 : goto cbig;
          case 1 : goto cbiy;
      }
  cbiy:
      _cbib::I64 = %MO_S_Lt_W64(_saCP::I64, _saCB::I64);
      _saCT::I64 = _cbib::I64;
      switch [0 .. 1] _saCT::I64 {
          case 0 : goto cbig;
          case 1 : goto cbir;
      }
  cbir:
      _saCX::P64 = P64[(_saCC::P64 + 24) + (_saCP::I64 << 3)];
      _saCX::P64 = _saCX::P64;
      Hp = Hp - 16;
      I64[(young<cbij> + 8)] = cbij;
      R1 = _saCX::P64;
      if (R1 & 7 != 0) goto cbij; else goto cbik;
  cbik:
      call (I64[R1])(R1) returns to cbij, args: 8, res: 8, upd: 8;
  cbij:
      _saCY::P64 = R1;
      _saCZ::P64 = P64[_saCY::P64 + 7];
      I64[(young<cbio> + 8)] = cbio;
      R1 = _saCZ::P64;
      call stg_norec_readTVar#(R1) returns to cbio, args: 8, res: 8, upd: 8;
  cbio:
      _saD2::P64 = R1;
      I64[(young<cbiq> + 8)] = cbiq;
      R2 = _saD2::P64;
      R1 = _saCp::P64;
      call stg_norec_writeTVar#(R2,
                                R1) returns to cbiq, args: 8, res: 8, upd: 8;
  cbiq:
      _cbiF::I64 = _saC2::I64 - 1;
      _saD4::I64 = _cbiF::I64;
      R6 = _saC0::P64;
      R5 = _saBZ::I64;
      R4 = _saBY::I64;
      R3 = _saBX::I64;
      R2 = _saD4::I64;
      call $s$wpoly_a_rawp_info(R6,
                                R5,
                                R4,
                                R3,
                                R2) args: 8, res: 0, upd: 8;
  cbig:
      Hp = Hp - 16;
      R3 = _saCP::I64;
      R2 = _saCB::I64;
      call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
  cbhY:
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _saC2::I64;
      _cbhW::P64 = Hp - 7;
      R4 = _saCF::P64;
      R3 = _saCD::P64;
      R2 = _cbhW::P64;
      call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbhP:
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _saC2::I64;
      _cbhN::P64 = Hp - 7;
      R4 = _saCF::P64;
      R3 = _saCD::P64;
      R2 = _cbhN::P64;
      call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbhj:
      R1 = SkipList._getNodes1_closure;
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
  cbgZ:
      Hp = Hp - 48;
      R3 = _saCf::I64;
      R2 = _saBZ::I64;
      call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
  cbgH:
      I64[Hp - 40] = GHC.Types.I#_con_info;
      I64[Hp - 32] = _saBY::I64;
      _cbgD::P64 = Hp - 39;
      I64[Hp - 24] = GHC.Types.I#_con_info;
      I64[Hp - 16] = _saBX::I64;
      _cbgE::P64 = Hp - 23;
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _saC2::I64;
      _cbgF::P64 = Hp - 7;
      R4 = _cbgD::P64;
      R3 = _cbgE::P64;
      R2 = _cbgF::P64;
      call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbgw:
      I64[Hp - 40] = GHC.Types.I#_con_info;
      I64[Hp - 32] = _saBY::I64;
      _cbgs::P64 = Hp - 39;
      I64[Hp - 24] = GHC.Types.I#_con_info;
      I64[Hp - 16] = _saBX::I64;
      _cbgt::P64 = Hp - 23;
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _saC2::I64;
      _cbgu::P64 = Hp - 7;
      R4 = _cbgs::P64;
      R3 = _cbgt::P64;
      R2 = _cbgu::P64;
      call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:46.120728 UTC

{offset
  cbgh:
      _saC0::P64 = R6;
      _saBZ::I64 = R5;
      _saBY::I64 = R4;
      _saBX::I64 = R3;
      _saBW::I64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cbgi; else goto cbgj;
  cbgj:
      Hp = Hp + 48;
      if (Hp > HpLim) goto cbgl; else goto cbgk;
  cbgl:
      HpAlloc = 48;
      goto cbgi;
  cbgi:
      R1 = $s$wpoly_a_rawp_closure;
      I64[(old + 48)] = _saBW::I64;
      I64[(old + 40)] = _saBX::I64;
      I64[(old + 32)] = _saBY::I64;
      I64[(old + 24)] = _saBZ::I64;
      P64[(old + 16)] = _saC0::P64;
      call (stg_gc_fun)(R1) args: 48, res: 0, upd: 8;
  cbgk:
      _saC2::I64 = _saBW::I64;
      if (_saC2::I64 != 0) goto cbgf; else goto cbgg;
  cbgf:
      _cbgn::I64 = %MO_S_Le_W64(_saBX::I64, _saC2::I64);
      _saC3::I64 = _cbgn::I64;
      if (_saC3::I64 != 0) goto cbiD; else goto cbgw;
  cbiD:
      _cbgy::I64 = %MO_S_Le_W64(_saC2::I64, _saBY::I64);
      _saC9::I64 = _cbgy::I64;
      if (_saC9::I64 != 0) goto cbiC; else goto cbgH;
  cbiC:
      _cbgJ::I64 = _saC2::I64 - _saBX::I64;
      _saCf::I64 = _cbgJ::I64;
      _cbgM::I64 = %MO_S_Le_W64(0, _saCf::I64);
      _saCg::I64 = _cbgM::I64;
      if (_saCg::I64 != 0) goto cbiB; else goto cbgZ;
  cbiB:
      _cbgU::I64 = %MO_S_Lt_W64(_saCf::I64, _saBZ::I64);
      _saCj::I64 = _cbgU::I64;
      if (_saCj::I64 != 0) goto cbh3; else goto cbgZ;
  cbh3:
      _saCn::P64 = P64[(_saC0::P64 + 24) + (_saCf::I64 << 3)];
      _saCn::P64 = _saCn::P64;
      Hp = Hp - 48;
      I64[(young<cbh2> + 8)] = cbh2;
      R1 = _saCn::P64;
      if (R1 & 7 != 0) goto cbh2; else goto cbh4;
  cbh4:
      call (I64[R1])(R1) returns to cbh2, args: 8, res: 8, upd: 8;
  cbh2:
      _saCo::P64 = R1;
      _saCp::P64 = P64[_saCo::P64 + 7];
      I64[(young<cbh8> + 8)] = cbh8;
      R1 = _saCp::P64;
      call stg_norec_readTVar#(R1) returns to cbh8, args: 8, res: 8, upd: 8;
  cbh8:
      _saCs::P64 = R1;
      I64[(young<cbha> + 8)] = cbha;
      R1 = _saCs::P64;
      if (R1 & 7 != 0) goto cbha; else goto cbhd;
  cbhd:
      call (I64[R1])(R1) returns to cbha, args: 8, res: 8, upd: 8;
  cbha:
      _saCt::P64 = R1;
      _cbiE::P64 = _saCt::P64 & 7;
      if (_cbiE::P64 != 1) goto cbhy; else goto cbhj;
  cbhy:
      _saCv::P64 = P64[_saCt::P64 + 6];
      _saCw::P64 = P64[_saCt::P64 + 14];
      _saCx::P64 = P64[_saCt::P64 + 22];
      I64[(young<cbhm> + 8)] = cbhm;
      R1 = _saCx::P64;
      if (R1 & 7 != 0) goto cbhm; else goto cbhn;
  cbhn:
      call (I64[R1])(R1) returns to cbhm, args: 8, res: 8, upd: 8;
  cbhm:
      _saCy::P64 = R1;
      _saCz::P64 = P64[_saCy::P64 + 7];
      _saCA::P64 = P64[_saCy::P64 + 15];
      _saCC::P64 = P64[_saCy::P64 + 23];
      _saCB::I64 = I64[_saCy::P64 + 31];
      I64[(young<cbhr> + 8)] = cbhr;
      R1 = _saCz::P64;
      if (R1 & 7 != 0) goto cbhr; else goto cbhs;
  cbhs:
      call (I64[R1])(R1) returns to cbhr, args: 8, res: 8, upd: 8;
  cbhr:
      _saCD::P64 = R1;
      _saCE::I64 = I64[_saCD::P64 + 7];
      I64[(young<cbhw> + 8)] = cbhw;
      R1 = _saCA::P64;
      if (R1 & 7 != 0) goto cbhw; else goto cbhB;
  cbhB:
      call (I64[R1])(R1) returns to cbhw, args: 8, res: 8, upd: 8;
  cbhw:
      _saCF::P64 = R1;
      Hp = Hp + 16;
      if (Hp > HpLim) goto cbhH; else goto cbhG;
  cbhH:
      HpAlloc = 16;
      R1 = _saCF::P64;
      call stg_gc_unpt_r1(R1) returns to cbhw, args: 8, res: 8, upd: 8;
  cbhG:
      _saCG::I64 = I64[_saCF::P64 + 7];
      _cbhI::I64 = %MO_S_Le_W64(_saCE::I64, _saC2::I64);
      _saCH::I64 = _cbhI::I64;
      if (_saCH::I64 != 0) goto cbiA; else goto cbhP;
  cbiA:
      _cbhR::I64 = %MO_S_Le_W64(_saC2::I64, _saCG::I64);
      _saCL::I64 = _cbhR::I64;
      if (_saCL::I64 != 0) goto cbiz; else goto cbhY;
  cbiz:
      _cbi0::I64 = _saC2::I64 - _saCE::I64;
      _saCP::I64 = _cbi0::I64;
      _cbi3::I64 = %MO_S_Le_W64(0, _saCP::I64);
      _saCQ::I64 = _cbi3::I64;
      if (_saCQ::I64 != 0) goto cbiy; else goto cbig;
  cbiy:
      _cbib::I64 = %MO_S_Lt_W64(_saCP::I64, _saCB::I64);
      _saCT::I64 = _cbib::I64;
      if (_saCT::I64 != 0) goto cbir; else goto cbig;
  cbir:
      _saCX::P64 = P64[(_saCC::P64 + 24) + (_saCP::I64 << 3)];
      _saCX::P64 = _saCX::P64;
      Hp = Hp - 16;
      I64[(young<cbij> + 8)] = cbij;
      R1 = _saCX::P64;
      if (R1 & 7 != 0) goto cbij; else goto cbik;
  cbik:
      call (I64[R1])(R1) returns to cbij, args: 8, res: 8, upd: 8;
  cbij:
      _saCY::P64 = R1;
      _saCZ::P64 = P64[_saCY::P64 + 7];
      I64[(young<cbio> + 8)] = cbio;
      R1 = _saCZ::P64;
      call stg_norec_readTVar#(R1) returns to cbio, args: 8, res: 8, upd: 8;
  cbio:
      _saD2::P64 = R1;
      I64[(young<cbiq> + 8)] = cbiq;
      R2 = _saD2::P64;
      R1 = _saCp::P64;
      call stg_norec_writeTVar#(R2,
                                R1) returns to cbiq, args: 8, res: 8, upd: 8;
  cbiq:
      _cbiF::I64 = _saC2::I64 - 1;
      _saD4::I64 = _cbiF::I64;
      R6 = _saC0::P64;
      R5 = _saBZ::I64;
      R4 = _saBY::I64;
      R3 = _saBX::I64;
      R2 = _saD4::I64;
      call $s$wpoly_a_rawp_info(R6,
                                R5,
                                R4,
                                R3,
                                R2) args: 8, res: 0, upd: 8;
  cbig:
      Hp = Hp - 16;
      R3 = _saCP::I64;
      R2 = _saCB::I64;
      call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
  cbhY:
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _saC2::I64;
      _cbhW::P64 = Hp - 7;
      R4 = _saCF::P64;
      R3 = _saCD::P64;
      R2 = _cbhW::P64;
      call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbhP:
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _saC2::I64;
      _cbhN::P64 = Hp - 7;
      R4 = _saCF::P64;
      R3 = _saCD::P64;
      R2 = _cbhN::P64;
      call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbhj:
      R1 = SkipList._getNodes1_closure;
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
  cbgZ:
      Hp = Hp - 48;
      R3 = _saCf::I64;
      R2 = _saBZ::I64;
      call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
  cbgH:
      I64[Hp - 40] = GHC.Types.I#_con_info;
      I64[Hp - 32] = _saBY::I64;
      _cbgD::P64 = Hp - 39;
      I64[Hp - 24] = GHC.Types.I#_con_info;
      I64[Hp - 16] = _saBX::I64;
      _cbgE::P64 = Hp - 23;
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _saC2::I64;
      _cbgF::P64 = Hp - 7;
      R4 = _cbgD::P64;
      R3 = _cbgE::P64;
      R2 = _cbgF::P64;
      call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbgw:
      I64[Hp - 40] = GHC.Types.I#_con_info;
      I64[Hp - 32] = _saBY::I64;
      _cbgs::P64 = Hp - 39;
      I64[Hp - 24] = GHC.Types.I#_con_info;
      I64[Hp - 16] = _saBX::I64;
      _cbgt::P64 = Hp - 23;
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _saC2::I64;
      _cbgu::P64 = Hp - 7;
      R4 = _cbgs::P64;
      R3 = _cbgt::P64;
      R2 = _cbgu::P64;
      call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbgg:
      Hp = Hp - 48;
      R1 = GHC.Types.True_closure+2;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:46.13397 UTC

{offset
  cbgh:
      _saC0::P64 = R6;
      _saBZ::I64 = R5;
      _saBY::I64 = R4;
      _saBX::I64 = R3;
      _saBW::I64 = R2;
      if ((Sp + 8) - 96 < SpLim) goto cbgi; else goto cbgj;
  cbgj:
      Hp = Hp + 48;
      if (Hp > HpLim) goto cbgl; else goto cbgk;
  cbgl:
      HpAlloc = 48;
      goto cbgi;
  cbgi:
      R1 = $s$wpoly_a_rawp_closure;
      I64[Sp - 40] = _saBW::I64;
      I64[Sp - 32] = _saBX::I64;
      I64[Sp - 24] = _saBY::I64;
      I64[Sp - 16] = _saBZ::I64;
      P64[Sp - 8] = _saC0::P64;
      Sp = Sp - 40;
      call (stg_gc_fun)(R1) args: 48, res: 0, upd: 8;
  cbgk:
      _saC2::I64 = _saBW::I64;
      if (_saC2::I64 != 0) goto cbgf; else goto cbgg;
  cbgf:
      _cbgn::I64 = %MO_S_Le_W64(_saBX::I64, _saC2::I64);
      _saC3::I64 = _cbgn::I64;
      if (_saC3::I64 != 0) goto cbiD; else goto cbgw;
  cbiD:
      _cbgy::I64 = %MO_S_Le_W64(_saC2::I64, _saBY::I64);
      _saC9::I64 = _cbgy::I64;
      if (_saC9::I64 != 0) goto cbiC; else goto cbgH;
  cbiC:
      _cbgJ::I64 = _saC2::I64 - _saBX::I64;
      _saCf::I64 = _cbgJ::I64;
      _cbgM::I64 = %MO_S_Le_W64(0, _saCf::I64);
      _saCg::I64 = _cbgM::I64;
      if (_saCg::I64 != 0) goto cbiB; else goto cbgZ;
  cbiB:
      _cbgU::I64 = %MO_S_Lt_W64(_saCf::I64, _saBZ::I64);
      _saCj::I64 = _cbgU::I64;
      if (_saCj::I64 != 0) goto cbh3; else goto cbgZ;
  cbh3:
      _saCn::P64 = P64[(_saC0::P64 + 24) + (_saCf::I64 << 3)];
      _saCn::P64 = _saCn::P64;
      Hp = Hp - 48;
      I64[Sp - 48] = cbh2;
      R1 = _saCn::P64;
      I64[Sp - 40] = _saBX::I64;
      I64[Sp - 32] = _saBY::I64;
      I64[Sp - 24] = _saBZ::I64;
      P64[Sp - 16] = _saC0::P64;
      I64[Sp - 8] = _saC2::I64;
      Sp = Sp - 48;
      if (R1 & 7 != 0) goto cbh2; else goto cbh4;
  cbh4:
      call (I64[R1])(R1) returns to cbh2, args: 8, res: 8, upd: 8;
  cbh2:
      _saBX::I64 = I64[Sp + 8];
      _saBY::I64 = I64[Sp + 16];
      _saBZ::I64 = I64[Sp + 24];
      _saC0::P64 = P64[Sp + 32];
      _saC2::I64 = I64[Sp + 40];
      _saCo::P64 = R1;
      _saCp::P64 = P64[_saCo::P64 + 7];
      I64[Sp - 8] = cbh8;
      R1 = _saCp::P64;
      P64[Sp] = _saCp::P64;
      Sp = Sp - 8;
      call stg_norec_readTVar#(R1) returns to cbh8, args: 8, res: 8, upd: 8;
  cbh8:
      _saBX::I64 = I64[Sp + 16];
      _saBY::I64 = I64[Sp + 24];
      _saBZ::I64 = I64[Sp + 32];
      _saC0::P64 = P64[Sp + 40];
      _saC2::I64 = I64[Sp + 48];
      _saCp::P64 = P64[Sp + 8];
      _saCs::P64 = R1;
      I64[Sp] = cbha;
      R1 = _saCs::P64;
      if (R1 & 7 != 0) goto cbha; else goto cbhd;
  cbhd:
      call (I64[R1])(R1) returns to cbha, args: 8, res: 8, upd: 8;
  cbha:
      _saBX::I64 = I64[Sp + 16];
      _saBY::I64 = I64[Sp + 24];
      _saBZ::I64 = I64[Sp + 32];
      _saC0::P64 = P64[Sp + 40];
      _saC2::I64 = I64[Sp + 48];
      _saCp::P64 = P64[Sp + 8];
      _saCt::P64 = R1;
      _cbiE::P64 = _saCt::P64 & 7;
      if (_cbiE::P64 != 1) goto cbhy; else goto cbhj;
  cbhy:
      _saCv::P64 = P64[_saCt::P64 + 6];
      _saCw::P64 = P64[_saCt::P64 + 14];
      _saCx::P64 = P64[_saCt::P64 + 22];
      I64[Sp] = cbhm;
      R1 = _saCx::P64;
      if (R1 & 7 != 0) goto cbhm; else goto cbhn;
  cbhn:
      call (I64[R1])(R1) returns to cbhm, args: 8, res: 8, upd: 8;
  cbhm:
      _saBX::I64 = I64[Sp + 16];
      _saBY::I64 = I64[Sp + 24];
      _saBZ::I64 = I64[Sp + 32];
      _saC0::P64 = P64[Sp + 40];
      _saC2::I64 = I64[Sp + 48];
      _saCp::P64 = P64[Sp + 8];
      _saCy::P64 = R1;
      _saCz::P64 = P64[_saCy::P64 + 7];
      _saCA::P64 = P64[_saCy::P64 + 15];
      _saCC::P64 = P64[_saCy::P64 + 23];
      _saCB::I64 = I64[_saCy::P64 + 31];
      I64[Sp - 24] = cbhr;
      R1 = _saCz::P64;
      I64[Sp - 16] = _saCB::I64;
      P64[Sp - 8] = _saCC::P64;
      P64[Sp] = _saCA::P64;
      Sp = Sp - 24;
      if (R1 & 7 != 0) goto cbhr; else goto cbhs;
  cbhs:
      call (I64[R1])(R1) returns to cbhr, args: 8, res: 8, upd: 8;
  cbhr:
      _saBX::I64 = I64[Sp + 40];
      _saBY::I64 = I64[Sp + 48];
      _saBZ::I64 = I64[Sp + 56];
      _saC0::P64 = P64[Sp + 64];
      _saC2::I64 = I64[Sp + 72];
      _saCp::P64 = P64[Sp + 32];
      _saCA::P64 = P64[Sp + 24];
      _saCB::I64 = I64[Sp + 8];
      _saCC::P64 = P64[Sp + 16];
      _saCD::P64 = R1;
      _saCE::I64 = I64[_saCD::P64 + 7];
      I64[Sp - 8] = cbhw;
      R1 = _saCA::P64;
      I64[Sp] = _saCE::I64;
      P64[Sp + 24] = _saCD::P64;
      Sp = Sp - 8;
      if (R1 & 7 != 0) goto cbhw; else goto cbhB;
  cbhB:
      call (I64[R1])(R1) returns to cbhw, args: 8, res: 8, upd: 8;
  cbhw:
      _saBX::I64 = I64[Sp + 48];
      _saBY::I64 = I64[Sp + 56];
      _saBZ::I64 = I64[Sp + 64];
      _saC0::P64 = P64[Sp + 72];
      _saC2::I64 = I64[Sp + 80];
      _saCp::P64 = P64[Sp + 40];
      _saCB::I64 = I64[Sp + 16];
      _saCC::P64 = P64[Sp + 24];
      _saCD::P64 = P64[Sp + 32];
      _saCE::I64 = I64[Sp + 8];
      _saCF::P64 = R1;
      Hp = Hp + 16;
      if (Hp > HpLim) goto cbhH; else goto cbhG;
  cbhH:
      HpAlloc = 16;
      R1 = _saCF::P64;
      call stg_gc_unpt_r1(R1) returns to cbhw, args: 8, res: 8, upd: 8;
  cbhG:
      _saCG::I64 = I64[_saCF::P64 + 7];
      _cbhI::I64 = %MO_S_Le_W64(_saCE::I64, _saC2::I64);
      _saCH::I64 = _cbhI::I64;
      if (_saCH::I64 != 0) goto cbiA; else goto cbhP;
  cbiA:
      _cbhR::I64 = %MO_S_Le_W64(_saC2::I64, _saCG::I64);
      _saCL::I64 = _cbhR::I64;
      if (_saCL::I64 != 0) goto cbiz; else goto cbhY;
  cbiz:
      _cbi0::I64 = _saC2::I64 - _saCE::I64;
      _saCP::I64 = _cbi0::I64;
      _cbi3::I64 = %MO_S_Le_W64(0, _saCP::I64);
      _saCQ::I64 = _cbi3::I64;
      if (_saCQ::I64 != 0) goto cbiy; else goto cbig;
  cbiy:
      _cbib::I64 = %MO_S_Lt_W64(_saCP::I64, _saCB::I64);
      _saCT::I64 = _cbib::I64;
      if (_saCT::I64 != 0) goto cbir; else goto cbig;
  cbir:
      _saCX::P64 = P64[(_saCC::P64 + 24) + (_saCP::I64 << 3)];
      _saCX::P64 = _saCX::P64;
      Hp = Hp - 16;
      I64[Sp + 32] = cbij;
      R1 = _saCX::P64;
      Sp = Sp + 32;
      if (R1 & 7 != 0) goto cbij; else goto cbik;
  cbik:
      call (I64[R1])(R1) returns to cbij, args: 8, res: 8, upd: 8;
  cbij:
      _saBX::I64 = I64[Sp + 16];
      _saBY::I64 = I64[Sp + 24];
      _saBZ::I64 = I64[Sp + 32];
      _saC0::P64 = P64[Sp + 40];
      _saC2::I64 = I64[Sp + 48];
      _saCp::P64 = P64[Sp + 8];
      _saCY::P64 = R1;
      _saCZ::P64 = P64[_saCY::P64 + 7];
      I64[Sp] = cbio;
      R1 = _saCZ::P64;
      call stg_norec_readTVar#(R1) returns to cbio, args: 8, res: 8, upd: 8;
  cbio:
      _saBX::I64 = I64[Sp + 16];
      _saBY::I64 = I64[Sp + 24];
      _saBZ::I64 = I64[Sp + 32];
      _saC0::P64 = P64[Sp + 40];
      _saC2::I64 = I64[Sp + 48];
      _saCp::P64 = P64[Sp + 8];
      _saD2::P64 = R1;
      I64[Sp + 8] = cbiq;
      R2 = _saD2::P64;
      R1 = _saCp::P64;
      Sp = Sp + 8;
      call stg_norec_writeTVar#(R2,
                                R1) returns to cbiq, args: 8, res: 8, upd: 8;
  cbiq:
      _saBX::I64 = I64[Sp + 8];
      _saBY::I64 = I64[Sp + 16];
      _saBZ::I64 = I64[Sp + 24];
      _saC0::P64 = P64[Sp + 32];
      _saC2::I64 = I64[Sp + 40];
      _cbiF::I64 = _saC2::I64 - 1;
      _saD4::I64 = _cbiF::I64;
      R6 = _saC0::P64;
      R5 = _saBZ::I64;
      R4 = _saBY::I64;
      R3 = _saBX::I64;
      R2 = _saD4::I64;
      Sp = Sp + 48;
      call $s$wpoly_a_rawp_info(R6,
                                R5,
                                R4,
                                R3,
                                R2) args: 8, res: 0, upd: 8;
  cbig:
      Hp = Hp - 16;
      R3 = _saCP::I64;
      R2 = _saCB::I64;
      Sp = Sp + 88;
      call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
  cbhY:
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _saC2::I64;
      _cbhW::P64 = Hp - 7;
      R4 = _saCF::P64;
      R3 = _saCD::P64;
      R2 = _cbhW::P64;
      Sp = Sp + 88;
      call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbhP:
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _saC2::I64;
      _cbhN::P64 = Hp - 7;
      R4 = _saCF::P64;
      R3 = _saCD::P64;
      R2 = _cbhN::P64;
      Sp = Sp + 88;
      call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbhj:
      R1 = SkipList._getNodes1_closure;
      Sp = Sp + 56;
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
  cbgZ:
      Hp = Hp - 48;
      R3 = _saCf::I64;
      R2 = _saBZ::I64;
      call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
  cbgH:
      I64[Hp - 40] = GHC.Types.I#_con_info;
      I64[Hp - 32] = _saBY::I64;
      _cbgD::P64 = Hp - 39;
      I64[Hp - 24] = GHC.Types.I#_con_info;
      I64[Hp - 16] = _saBX::I64;
      _cbgE::P64 = Hp - 23;
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _saC2::I64;
      _cbgF::P64 = Hp - 7;
      R4 = _cbgD::P64;
      R3 = _cbgE::P64;
      R2 = _cbgF::P64;
      call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbgw:
      I64[Hp - 40] = GHC.Types.I#_con_info;
      I64[Hp - 32] = _saBY::I64;
      _cbgs::P64 = Hp - 39;
      I64[Hp - 24] = GHC.Types.I#_con_info;
      I64[Hp - 16] = _saBX::I64;
      _cbgt::P64 = Hp - 23;
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _saC2::I64;
      _cbgu::P64 = Hp - 7;
      R4 = _cbgs::P64;
      R3 = _cbgt::P64;
      R2 = _cbgu::P64;
      call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbgg:
      Hp = Hp - 48;
      R1 = GHC.Types.True_closure+2;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:46.148715 UTC

{offset
  cbgh:
      _saC0::P64 = R6;
      _saBZ::I64 = R5;
      _saBY::I64 = R4;
      _saBX::I64 = R3;
      _saBW::I64 = R2;
      if ((Sp + -88) < SpLim) goto cbgi; else goto cbgj;
  cbgj:
      Hp = Hp + 48;
      if (Hp > HpLim) goto cbgl; else goto cbgk;
  cbgl:
      HpAlloc = 48;
      goto cbgi;
  cbgi:
      R1 = $s$wpoly_a_rawp_closure;
      I64[Sp - 40] = _saBW::I64;
      I64[Sp - 32] = _saBX::I64;
      I64[Sp - 24] = _saBY::I64;
      I64[Sp - 16] = _saBZ::I64;
      P64[Sp - 8] = _saC0::P64;
      Sp = Sp - 40;
      call (stg_gc_fun)(R1) args: 48, res: 0, upd: 8;
  cbgk:
      if (_saBW::I64 != 0) goto cbgf; else goto cbgg;
  cbgf:
      if (%MO_S_Le_W64(_saBX::I64,
                       _saBW::I64)) goto cbiD; else goto cbgw;
  cbiD:
      if (%MO_S_Le_W64(_saBW::I64,
                       _saBY::I64)) goto cbiC; else goto cbgH;
  cbiC:
      _saCf::I64 = _saBW::I64 - _saBX::I64;
      if (%MO_S_Le_W64(0, _saCf::I64)) goto cbiB; else goto cbgZ;
  cbiB:
      if (%MO_S_Lt_W64(_saCf::I64,
                       _saBZ::I64)) goto cbh3; else goto cbgZ;
  cbh3:
      Hp = Hp - 48;
      _saCn::P64 = P64[(_saC0::P64 + 24) + (_saCf::I64 << 3)];
      I64[Sp - 48] = cbh2;
      R1 = _saCn::P64;
      I64[Sp - 40] = _saBX::I64;
      I64[Sp - 32] = _saBY::I64;
      I64[Sp - 24] = _saBZ::I64;
      P64[Sp - 16] = _saC0::P64;
      I64[Sp - 8] = _saBW::I64;
      Sp = Sp - 48;
      if (R1 & 7 != 0) goto cbh2; else goto cbh4;
  cbh4:
      call (I64[R1])(R1) returns to cbh2, args: 8, res: 8, upd: 8;
  cbh2:
      I64[Sp - 8] = cbh8;
      _saCp::P64 = P64[R1 + 7];
      R1 = _saCp::P64;
      P64[Sp] = _saCp::P64;
      Sp = Sp - 8;
      call stg_norec_readTVar#(R1) returns to cbh8, args: 8, res: 8, upd: 8;
  cbh8:
      I64[Sp] = cbha;
      R1 = R1;
      if (R1 & 7 != 0) goto cbha; else goto cbhd;
  cbhd:
      call (I64[R1])(R1) returns to cbha, args: 8, res: 8, upd: 8;
  cbha:
      if (R1 & 7 != 1) goto cbhy; else goto cbhj;
  cbhy:
      I64[Sp] = cbhm;
      R1 = P64[R1 + 22];
      if (R1 & 7 != 0) goto cbhm; else goto cbhn;
  cbhn:
      call (I64[R1])(R1) returns to cbhm, args: 8, res: 8, upd: 8;
  cbhm:
      I64[Sp - 24] = cbhr;
      _saCA::P64 = P64[R1 + 15];
      _saCC::P64 = P64[R1 + 23];
      _saCB::I64 = I64[R1 + 31];
      R1 = P64[R1 + 7];
      I64[Sp - 16] = _saCB::I64;
      P64[Sp - 8] = _saCC::P64;
      P64[Sp] = _saCA::P64;
      Sp = Sp - 24;
      if (R1 & 7 != 0) goto cbhr; else goto cbhs;
  cbhs:
      call (I64[R1])(R1) returns to cbhr, args: 8, res: 8, upd: 8;
  cbhr:
      I64[Sp - 8] = cbhw;
      _saCD::P64 = R1;
      _saCE::I64 = I64[R1 + 7];
      R1 = P64[Sp + 24];
      I64[Sp] = _saCE::I64;
      P64[Sp + 24] = _saCD::P64;
      Sp = Sp - 8;
      if (R1 & 7 != 0) goto cbhw; else goto cbhB;
  cbhB:
      call (I64[R1])(R1) returns to cbhw, args: 8, res: 8, upd: 8;
  cbhw:
      Hp = Hp + 16;
      if (Hp > HpLim) goto cbhH; else goto cbhG;
  cbhH:
      HpAlloc = 16;
      R1 = R1;
      call stg_gc_unpt_r1(R1) returns to cbhw, args: 8, res: 8, upd: 8;
  cbhG:
      _saC2::I64 = I64[Sp + 80];
      _saCD::P64 = P64[Sp + 32];
      _saCE::I64 = I64[Sp + 8];
      if (%MO_S_Le_W64(_saCE::I64,
                       _saC2::I64)) goto cbiA; else goto cbhP;
  cbiA:
      if (%MO_S_Le_W64(_saC2::I64,
                       I64[R1 + 7])) goto cbiz; else goto cbhY;
  cbiz:
      _saCB::I64 = I64[Sp + 16];
      _saCP::I64 = _saC2::I64 - _saCE::I64;
      if (%MO_S_Le_W64(0, _saCP::I64)) goto cbiy; else goto cbig;
  cbiy:
      if (%MO_S_Lt_W64(_saCP::I64,
                       _saCB::I64)) goto cbir; else goto cbig;
  cbir:
      Hp = Hp - 16;
      _saCX::P64 = P64[P64[Sp + 24] + ((_saCP::I64 << 3) + 24)];
      I64[Sp + 32] = cbij;
      R1 = _saCX::P64;
      Sp = Sp + 32;
      if (R1 & 7 != 0) goto cbij; else goto cbik;
  cbik:
      call (I64[R1])(R1) returns to cbij, args: 8, res: 8, upd: 8;
  cbij:
      I64[Sp] = cbio;
      R1 = P64[R1 + 7];
      call stg_norec_readTVar#(R1) returns to cbio, args: 8, res: 8, upd: 8;
  cbio:
      _saCp::P64 = P64[Sp + 8];
      I64[Sp + 8] = cbiq;
      R2 = R1;
      R1 = _saCp::P64;
      Sp = Sp + 8;
      call stg_norec_writeTVar#(R2,
                                R1) returns to cbiq, args: 8, res: 8, upd: 8;
  cbiq:
      R6 = P64[Sp + 32];
      R5 = I64[Sp + 24];
      R4 = I64[Sp + 16];
      R3 = I64[Sp + 8];
      R2 = I64[Sp + 40] - 1;
      Sp = Sp + 48;
      call $s$wpoly_a_rawp_info(R6,
                                R5,
                                R4,
                                R3,
                                R2) args: 8, res: 0, upd: 8;
  cbig:
      Hp = Hp - 16;
      R3 = _saCP::I64;
      R2 = _saCB::I64;
      Sp = Sp + 88;
      call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
  cbhY:
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _saC2::I64;
      R4 = R1;
      R3 = _saCD::P64;
      R2 = Hp - 7;
      Sp = Sp + 88;
      call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbhP:
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _saC2::I64;
      R4 = R1;
      R3 = _saCD::P64;
      R2 = Hp - 7;
      Sp = Sp + 88;
      call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbhj:
      R1 = SkipList._getNodes1_closure;
      Sp = Sp + 56;
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
  cbgZ:
      Hp = Hp - 48;
      R3 = _saCf::I64;
      R2 = _saBZ::I64;
      call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
  cbgH:
      I64[Hp - 40] = GHC.Types.I#_con_info;
      I64[Hp - 32] = _saBY::I64;
      I64[Hp - 24] = GHC.Types.I#_con_info;
      I64[Hp - 16] = _saBX::I64;
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _saBW::I64;
      R4 = Hp - 39;
      R3 = Hp - 23;
      R2 = Hp - 7;
      call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbgw:
      I64[Hp - 40] = GHC.Types.I#_con_info;
      I64[Hp - 32] = _saBY::I64;
      I64[Hp - 24] = GHC.Types.I#_con_info;
      I64[Hp - 16] = _saBX::I64;
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _saBW::I64;
      R4 = Hp - 39;
      R3 = Hp - 23;
      R2 = Hp - 7;
      call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbgg:
      Hp = Hp - 48;
      R1 = GHC.Types.True_closure+2;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:46.160473 UTC

[(cbgf,
  {SkipList._getNodes1_closure, lvl29_rawn_closure,
   lvl30_rawo_closure, $s$wpoly_a_rawp_closure}),
 (cbgg, {}),
 (cbgh,
  {SkipList._getNodes1_closure, lvl29_rawn_closure,
   lvl30_rawo_closure, $s$wpoly_a_rawp_closure}),
 (cbgi, {$s$wpoly_a_rawp_closure}),
 (cbgj,
  {SkipList._getNodes1_closure, lvl29_rawn_closure,
   lvl30_rawo_closure, $s$wpoly_a_rawp_closure}),
 (cbgk,
  {SkipList._getNodes1_closure, lvl29_rawn_closure,
   lvl30_rawo_closure, $s$wpoly_a_rawp_closure}),
 (cbgl, {$s$wpoly_a_rawp_closure}), (cbgw, {lvl30_rawo_closure}),
 (cbgH, {lvl30_rawo_closure}), (cbgZ, {lvl29_rawn_closure}),
 (cbh2,
  {SkipList._getNodes1_closure, lvl29_rawn_closure,
   lvl30_rawo_closure, $s$wpoly_a_rawp_closure}),
 (cbh3,
  {SkipList._getNodes1_closure, lvl29_rawn_closure,
   lvl30_rawo_closure, $s$wpoly_a_rawp_closure}),
 (cbh4,
  {SkipList._getNodes1_closure, lvl29_rawn_closure,
   lvl30_rawo_closure, $s$wpoly_a_rawp_closure}),
 (cbh8,
  {SkipList._getNodes1_closure, lvl29_rawn_closure,
   lvl30_rawo_closure, $s$wpoly_a_rawp_closure}),
 (cbha,
  {SkipList._getNodes1_closure, lvl29_rawn_closure,
   lvl30_rawo_closure, $s$wpoly_a_rawp_closure}),
 (cbhd,
  {SkipList._getNodes1_closure, lvl29_rawn_closure,
   lvl30_rawo_closure, $s$wpoly_a_rawp_closure}),
 (cbhj, {SkipList._getNodes1_closure}),
 (cbhm,
  {lvl29_rawn_closure, lvl30_rawo_closure, $s$wpoly_a_rawp_closure}),
 (cbhn,
  {lvl29_rawn_closure, lvl30_rawo_closure, $s$wpoly_a_rawp_closure}),
 (cbhr,
  {lvl29_rawn_closure, lvl30_rawo_closure, $s$wpoly_a_rawp_closure}),
 (cbhs,
  {lvl29_rawn_closure, lvl30_rawo_closure, $s$wpoly_a_rawp_closure}),
 (cbhw,
  {lvl29_rawn_closure, lvl30_rawo_closure, $s$wpoly_a_rawp_closure}),
 (cbhy,
  {lvl29_rawn_closure, lvl30_rawo_closure, $s$wpoly_a_rawp_closure}),
 (cbhB,
  {lvl29_rawn_closure, lvl30_rawo_closure, $s$wpoly_a_rawp_closure}),
 (cbhG,
  {lvl29_rawn_closure, lvl30_rawo_closure, $s$wpoly_a_rawp_closure}),
 (cbhH,
  {lvl29_rawn_closure, lvl30_rawo_closure, $s$wpoly_a_rawp_closure}),
 (cbhP, {lvl30_rawo_closure}), (cbhY, {lvl30_rawo_closure}),
 (cbig, {lvl29_rawn_closure}), (cbij, {$s$wpoly_a_rawp_closure}),
 (cbik, {$s$wpoly_a_rawp_closure}),
 (cbio, {$s$wpoly_a_rawp_closure}),
 (cbiq, {$s$wpoly_a_rawp_closure}),
 (cbir, {$s$wpoly_a_rawp_closure}),
 (cbiy, {lvl29_rawn_closure, $s$wpoly_a_rawp_closure}),
 (cbiz, {lvl29_rawn_closure, $s$wpoly_a_rawp_closure}),
 (cbiA,
  {lvl29_rawn_closure, lvl30_rawo_closure, $s$wpoly_a_rawp_closure}),
 (cbiB,
  {SkipList._getNodes1_closure, lvl29_rawn_closure,
   lvl30_rawo_closure, $s$wpoly_a_rawp_closure}),
 (cbiC,
  {SkipList._getNodes1_closure, lvl29_rawn_closure,
   lvl30_rawo_closure, $s$wpoly_a_rawp_closure}),
 (cbiD,
  {SkipList._getNodes1_closure, lvl29_rawn_closure,
   lvl30_rawo_closure, $s$wpoly_a_rawp_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:46.165105 UTC

$s$wpoly_a_rawp_entry() //  [R6, R5, R4, R3, R2]
        { info_tbl: [(cbgh,
                      label: $s$wpoly_a_rawp_info
                      rep:HeapRep static {
                            Fun {arity: 7 fun_type: ArgGen [True, True, True, True, False]} }),
                     (cbh2,
                      label: block_cbh2_info
                      rep:StackRep [True, True, True, False, True]),
                     (cbh8,
                      label: block_cbh8_info
                      rep:StackRep [False, True, True, True, False, True]),
                     (cbha,
                      label: block_cbha_info
                      rep:StackRep [False, True, True, True, False, True]),
                     (cbhm,
                      label: block_cbhm_info
                      rep:StackRep [False, True, True, True, False, True]),
                     (cbhr,
                      label: block_cbhr_info
                      rep:StackRep [True, False, False, False, True, True, True, False,
                                    True]),
                     (cbhw,
                      label: block_cbhw_info
                      rep:StackRep [True, True, False, False, False, True, True, True,
                                    False, True]),
                     (cbij,
                      label: block_cbij_info
                      rep:StackRep [False, True, True, True, False, True]),
                     (cbio,
                      label: block_cbio_info
                      rep:StackRep [False, True, True, True, False, True]),
                     (cbiq,
                      label: block_cbiq_info
                      rep:StackRep [True, True, True, False, True])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cbgh:
          _saC0::P64 = R6;
          _saBZ::I64 = R5;
          _saBY::I64 = R4;
          _saBX::I64 = R3;
          _saBW::I64 = R2;
          if ((Sp + -88) < SpLim) goto cbgi; else goto cbgj;
      cbgj:
          Hp = Hp + 48;
          if (Hp > HpLim) goto cbgl; else goto cbgk;
      cbgl:
          HpAlloc = 48;
          goto cbgi;
      cbgi:
          R1 = $s$wpoly_a_rawp_closure;
          I64[Sp - 40] = _saBW::I64;
          I64[Sp - 32] = _saBX::I64;
          I64[Sp - 24] = _saBY::I64;
          I64[Sp - 16] = _saBZ::I64;
          P64[Sp - 8] = _saC0::P64;
          Sp = Sp - 40;
          call (stg_gc_fun)(R1) args: 48, res: 0, upd: 8;
      cbgk:
          if (_saBW::I64 != 0) goto cbgf; else goto cbgg;
      cbgf:
          if (%MO_S_Le_W64(_saBX::I64,
                           _saBW::I64)) goto cbiD; else goto cbgw;
      cbiD:
          if (%MO_S_Le_W64(_saBW::I64,
                           _saBY::I64)) goto cbiC; else goto cbgH;
      cbiC:
          _saCf::I64 = _saBW::I64 - _saBX::I64;
          if (%MO_S_Le_W64(0, _saCf::I64)) goto cbiB; else goto cbgZ;
      cbiB:
          if (%MO_S_Lt_W64(_saCf::I64,
                           _saBZ::I64)) goto cbh3; else goto cbgZ;
      cbh3:
          Hp = Hp - 48;
          _saCn::P64 = P64[(_saC0::P64 + 24) + (_saCf::I64 << 3)];
          I64[Sp - 48] = cbh2;
          R1 = _saCn::P64;
          I64[Sp - 40] = _saBX::I64;
          I64[Sp - 32] = _saBY::I64;
          I64[Sp - 24] = _saBZ::I64;
          P64[Sp - 16] = _saC0::P64;
          I64[Sp - 8] = _saBW::I64;
          Sp = Sp - 48;
          if (R1 & 7 != 0) goto cbh2; else goto cbh4;
      cbh4:
          call (I64[R1])(R1) returns to cbh2, args: 8, res: 8, upd: 8;
      cbh2:
          I64[Sp - 8] = cbh8;
          _saCp::P64 = P64[R1 + 7];
          R1 = _saCp::P64;
          P64[Sp] = _saCp::P64;
          Sp = Sp - 8;
          call stg_norec_readTVar#(R1) returns to cbh8, args: 8, res: 8, upd: 8;
      cbh8:
          I64[Sp] = cbha;
          R1 = R1;
          if (R1 & 7 != 0) goto cbha; else goto cbhd;
      cbhd:
          call (I64[R1])(R1) returns to cbha, args: 8, res: 8, upd: 8;
      cbha:
          if (R1 & 7 != 1) goto cbhy; else goto cbhj;
      cbhy:
          I64[Sp] = cbhm;
          R1 = P64[R1 + 22];
          if (R1 & 7 != 0) goto cbhm; else goto cbhn;
      cbhn:
          call (I64[R1])(R1) returns to cbhm, args: 8, res: 8, upd: 8;
      cbhm:
          I64[Sp - 24] = cbhr;
          _saCA::P64 = P64[R1 + 15];
          _saCC::P64 = P64[R1 + 23];
          _saCB::I64 = I64[R1 + 31];
          R1 = P64[R1 + 7];
          I64[Sp - 16] = _saCB::I64;
          P64[Sp - 8] = _saCC::P64;
          P64[Sp] = _saCA::P64;
          Sp = Sp - 24;
          if (R1 & 7 != 0) goto cbhr; else goto cbhs;
      cbhs:
          call (I64[R1])(R1) returns to cbhr, args: 8, res: 8, upd: 8;
      cbhr:
          I64[Sp - 8] = cbhw;
          _saCD::P64 = R1;
          _saCE::I64 = I64[R1 + 7];
          R1 = P64[Sp + 24];
          I64[Sp] = _saCE::I64;
          P64[Sp + 24] = _saCD::P64;
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto cbhw; else goto cbhB;
      cbhB:
          call (I64[R1])(R1) returns to cbhw, args: 8, res: 8, upd: 8;
      cbhw:
          Hp = Hp + 16;
          if (Hp > HpLim) goto cbhH; else goto cbhG;
      cbhH:
          HpAlloc = 16;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to cbhw, args: 8, res: 8, upd: 8;
      cbhG:
          _saC2::I64 = I64[Sp + 80];
          _saCD::P64 = P64[Sp + 32];
          _saCE::I64 = I64[Sp + 8];
          if (%MO_S_Le_W64(_saCE::I64,
                           _saC2::I64)) goto cbiA; else goto cbhP;
      cbiA:
          if (%MO_S_Le_W64(_saC2::I64,
                           I64[R1 + 7])) goto cbiz; else goto cbhY;
      cbiz:
          _saCB::I64 = I64[Sp + 16];
          _saCP::I64 = _saC2::I64 - _saCE::I64;
          if (%MO_S_Le_W64(0, _saCP::I64)) goto cbiy; else goto cbig;
      cbiy:
          if (%MO_S_Lt_W64(_saCP::I64,
                           _saCB::I64)) goto cbir; else goto cbig;
      cbir:
          Hp = Hp - 16;
          _saCX::P64 = P64[P64[Sp + 24] + ((_saCP::I64 << 3) + 24)];
          I64[Sp + 32] = cbij;
          R1 = _saCX::P64;
          Sp = Sp + 32;
          if (R1 & 7 != 0) goto cbij; else goto cbik;
      cbik:
          call (I64[R1])(R1) returns to cbij, args: 8, res: 8, upd: 8;
      cbij:
          I64[Sp] = cbio;
          R1 = P64[R1 + 7];
          call stg_norec_readTVar#(R1) returns to cbio, args: 8, res: 8, upd: 8;
      cbio:
          _saCp::P64 = P64[Sp + 8];
          I64[Sp + 8] = cbiq;
          R2 = R1;
          R1 = _saCp::P64;
          Sp = Sp + 8;
          call stg_norec_writeTVar#(R2,
                                    R1) returns to cbiq, args: 8, res: 8, upd: 8;
      cbiq:
          R6 = P64[Sp + 32];
          R5 = I64[Sp + 24];
          R4 = I64[Sp + 16];
          R3 = I64[Sp + 8];
          R2 = I64[Sp + 40] - 1;
          Sp = Sp + 48;
          call $s$wpoly_a_rawp_info(R6,
                                    R5,
                                    R4,
                                    R3,
                                    R2) args: 8, res: 0, upd: 8;
      cbig:
          Hp = Hp - 16;
          R3 = _saCP::I64;
          R2 = _saCB::I64;
          Sp = Sp + 88;
          call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
      cbhY:
          I64[Hp - 8] = GHC.Types.I#_con_info;
          I64[Hp] = _saC2::I64;
          R4 = R1;
          R3 = _saCD::P64;
          R2 = Hp - 7;
          Sp = Sp + 88;
          call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
      cbhP:
          I64[Hp - 8] = GHC.Types.I#_con_info;
          I64[Hp] = _saC2::I64;
          R4 = R1;
          R3 = _saCD::P64;
          R2 = Hp - 7;
          Sp = Sp + 88;
          call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
      cbhj:
          R1 = SkipList._getNodes1_closure;
          Sp = Sp + 56;
          call (I64[R1])(R1) args: 8, res: 0, upd: 8;
      cbgZ:
          Hp = Hp - 48;
          R3 = _saCf::I64;
          R2 = _saBZ::I64;
          call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
      cbgH:
          I64[Hp - 40] = GHC.Types.I#_con_info;
          I64[Hp - 32] = _saBY::I64;
          I64[Hp - 24] = GHC.Types.I#_con_info;
          I64[Hp - 16] = _saBX::I64;
          I64[Hp - 8] = GHC.Types.I#_con_info;
          I64[Hp] = _saBW::I64;
          R4 = Hp - 39;
          R3 = Hp - 23;
          R2 = Hp - 7;
          call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
      cbgw:
          I64[Hp - 40] = GHC.Types.I#_con_info;
          I64[Hp - 32] = _saBY::I64;
          I64[Hp - 24] = GHC.Types.I#_con_info;
          I64[Hp - 16] = _saBX::I64;
          I64[Hp - 8] = GHC.Types.I#_con_info;
          I64[Hp] = _saBW::I64;
          R4 = Hp - 39;
          R3 = Hp - 23;
          R2 = Hp - 7;
          call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
      cbgg:
          Hp = Hp - 48;
          R1 = GHC.Types.True_closure+2;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:46.177273 UTC

$s$wpoly_a_rawp_entry() //  [R6, R5, R4, R3, R2]
        { info_tbl: [(cbgh,
                      label: $s$wpoly_a_rawp_info
                      rep:HeapRep static {
                            Fun {arity: 7 fun_type: ArgGen [True, True, True, True, False]} }),
                     (cbh2,
                      label: block_cbh2_info
                      rep:StackRep [True, True, True, False, True]),
                     (cbh8,
                      label: block_cbh8_info
                      rep:StackRep [False, True, True, True, False, True]),
                     (cbha,
                      label: block_cbha_info
                      rep:StackRep [False, True, True, True, False, True]),
                     (cbhm,
                      label: block_cbhm_info
                      rep:StackRep [False, True, True, True, False, True]),
                     (cbhr,
                      label: block_cbhr_info
                      rep:StackRep [True, False, False, False, True, True, True, False,
                                    True]),
                     (cbhw,
                      label: block_cbhw_info
                      rep:StackRep [True, True, False, False, False, True, True, True,
                                    False, True]),
                     (cbij,
                      label: block_cbij_info
                      rep:StackRep [False, True, True, True, False, True]),
                     (cbio,
                      label: block_cbio_info
                      rep:StackRep [False, True, True, True, False, True]),
                     (cbiq,
                      label: block_cbiq_info
                      rep:StackRep [True, True, True, False, True])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cbgh:
          _saC0::P64 = R6;
          _saBZ::I64 = R5;
          _saBY::I64 = R4;
          _saBX::I64 = R3;
          _saBW::I64 = R2;
          if ((Sp + -88) < SpLim) goto cbgi; else goto cbgj;
      cbgj:
          Hp = Hp + 48;
          if (Hp > HpLim) goto cbgl; else goto cbgk;
      cbgl:
          HpAlloc = 48;
          goto cbgi;
      cbgi:
          R1 = $s$wpoly_a_rawp_closure;
          I64[Sp - 40] = _saBW::I64;
          I64[Sp - 32] = _saBX::I64;
          I64[Sp - 24] = _saBY::I64;
          I64[Sp - 16] = _saBZ::I64;
          P64[Sp - 8] = _saC0::P64;
          Sp = Sp - 40;
          call (stg_gc_fun)(R1) args: 48, res: 0, upd: 8;
      cbgk:
          if (_saBW::I64 != 0) goto cbgf; else goto cbgg;
      cbgf:
          if (%MO_S_Le_W64(_saBX::I64,
                           _saBW::I64)) goto cbiD; else goto cbgw;
      cbiD:
          if (%MO_S_Le_W64(_saBW::I64,
                           _saBY::I64)) goto cbiC; else goto cbgH;
      cbiC:
          _saCf::I64 = _saBW::I64 - _saBX::I64;
          if (%MO_S_Gt_W64(0, _saCf::I64)) goto cbgZ; else goto cbiB;
      cbiB:
          if (%MO_S_Ge_W64(_saCf::I64,
                           _saBZ::I64)) goto cbgZ; else goto cbh3;
      cbgZ:
          Hp = Hp - 48;
          R3 = _saCf::I64;
          R2 = _saBZ::I64;
          call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
      cbh3:
          Hp = Hp - 48;
          _saCn::P64 = P64[(_saC0::P64 + 24) + (_saCf::I64 << 3)];
          I64[Sp - 48] = cbh2;
          R1 = _saCn::P64;
          I64[Sp - 40] = _saBX::I64;
          I64[Sp - 32] = _saBY::I64;
          I64[Sp - 24] = _saBZ::I64;
          P64[Sp - 16] = _saC0::P64;
          I64[Sp - 8] = _saBW::I64;
          Sp = Sp - 48;
          if (R1 & 7 != 0) goto cbh2; else goto cbh4;
      cbh4:
          call (I64[R1])(R1) returns to cbh2, args: 8, res: 8, upd: 8;
      cbh2:
          I64[Sp - 8] = cbh8;
          _saCp::P64 = P64[R1 + 7];
          R1 = _saCp::P64;
          P64[Sp] = _saCp::P64;
          Sp = Sp - 8;
          call stg_norec_readTVar#(R1) returns to cbh8, args: 8, res: 8, upd: 8;
      cbh8:
          I64[Sp] = cbha;
          R1 = R1;
          if (R1 & 7 != 0) goto cbha; else goto cbhd;
      cbhd:
          call (I64[R1])(R1) returns to cbha, args: 8, res: 8, upd: 8;
      cbha:
          if (R1 & 7 != 1) goto cbhy; else goto cbhj;
      cbhy:
          I64[Sp] = cbhm;
          R1 = P64[R1 + 22];
          if (R1 & 7 != 0) goto cbhm; else goto cbhn;
      cbhn:
          call (I64[R1])(R1) returns to cbhm, args: 8, res: 8, upd: 8;
      cbhm:
          I64[Sp - 24] = cbhr;
          _saCA::P64 = P64[R1 + 15];
          _saCC::P64 = P64[R1 + 23];
          _saCB::I64 = I64[R1 + 31];
          R1 = P64[R1 + 7];
          I64[Sp - 16] = _saCB::I64;
          P64[Sp - 8] = _saCC::P64;
          P64[Sp] = _saCA::P64;
          Sp = Sp - 24;
          if (R1 & 7 != 0) goto cbhr; else goto cbhs;
      cbhs:
          call (I64[R1])(R1) returns to cbhr, args: 8, res: 8, upd: 8;
      cbhr:
          I64[Sp - 8] = cbhw;
          _saCD::P64 = R1;
          _saCE::I64 = I64[R1 + 7];
          R1 = P64[Sp + 24];
          I64[Sp] = _saCE::I64;
          P64[Sp + 24] = _saCD::P64;
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto cbhw; else goto cbhB;
      cbhB:
          call (I64[R1])(R1) returns to cbhw, args: 8, res: 8, upd: 8;
      cbhw:
          Hp = Hp + 16;
          if (Hp > HpLim) goto cbhH; else goto cbhG;
      cbhH:
          HpAlloc = 16;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to cbhw, args: 8, res: 8, upd: 8;
      cbhG:
          _saC2::I64 = I64[Sp + 80];
          _saCD::P64 = P64[Sp + 32];
          _saCE::I64 = I64[Sp + 8];
          if (%MO_S_Le_W64(_saCE::I64,
                           _saC2::I64)) goto cbiA; else goto cbhP;
      cbiA:
          if (%MO_S_Le_W64(_saC2::I64,
                           I64[R1 + 7])) goto cbiz; else goto cbhY;
      cbiz:
          _saCB::I64 = I64[Sp + 16];
          _saCP::I64 = _saC2::I64 - _saCE::I64;
          if (%MO_S_Gt_W64(0, _saCP::I64)) goto cbig; else goto cbiy;
      cbiy:
          if (%MO_S_Ge_W64(_saCP::I64,
                           _saCB::I64)) goto cbig; else goto cbir;
      cbig:
          Hp = Hp - 16;
          R3 = _saCP::I64;
          R2 = _saCB::I64;
          Sp = Sp + 88;
          call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
      cbir:
          Hp = Hp - 16;
          _saCX::P64 = P64[P64[Sp + 24] + ((_saCP::I64 << 3) + 24)];
          I64[Sp + 32] = cbij;
          R1 = _saCX::P64;
          Sp = Sp + 32;
          if (R1 & 7 != 0) goto cbij; else goto cbik;
      cbik:
          call (I64[R1])(R1) returns to cbij, args: 8, res: 8, upd: 8;
      cbij:
          I64[Sp] = cbio;
          R1 = P64[R1 + 7];
          call stg_norec_readTVar#(R1) returns to cbio, args: 8, res: 8, upd: 8;
      cbio:
          _saCp::P64 = P64[Sp + 8];
          I64[Sp + 8] = cbiq;
          R2 = R1;
          R1 = _saCp::P64;
          Sp = Sp + 8;
          call stg_norec_writeTVar#(R2,
                                    R1) returns to cbiq, args: 8, res: 8, upd: 8;
      cbiq:
          R6 = P64[Sp + 32];
          R5 = I64[Sp + 24];
          R4 = I64[Sp + 16];
          R3 = I64[Sp + 8];
          R2 = I64[Sp + 40] - 1;
          Sp = Sp + 48;
          call $s$wpoly_a_rawp_info(R6,
                                    R5,
                                    R4,
                                    R3,
                                    R2) args: 8, res: 0, upd: 8;
      cbhY:
          I64[Hp - 8] = GHC.Types.I#_con_info;
          I64[Hp] = _saC2::I64;
          R4 = R1;
          R3 = _saCD::P64;
          R2 = Hp - 7;
          Sp = Sp + 88;
          call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
      cbhP:
          I64[Hp - 8] = GHC.Types.I#_con_info;
          I64[Hp] = _saC2::I64;
          R4 = R1;
          R3 = _saCD::P64;
          R2 = Hp - 7;
          Sp = Sp + 88;
          call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
      cbhj:
          R1 = SkipList._getNodes1_closure;
          Sp = Sp + 56;
          call (I64[R1])(R1) args: 8, res: 0, upd: 8;
      cbgH:
          I64[Hp - 40] = GHC.Types.I#_con_info;
          I64[Hp - 32] = _saBY::I64;
          I64[Hp - 24] = GHC.Types.I#_con_info;
          I64[Hp - 16] = _saBX::I64;
          I64[Hp - 8] = GHC.Types.I#_con_info;
          I64[Hp] = _saBW::I64;
          R4 = Hp - 39;
          R3 = Hp - 23;
          R2 = Hp - 7;
          call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
      cbgw:
          I64[Hp - 40] = GHC.Types.I#_con_info;
          I64[Hp - 32] = _saBY::I64;
          I64[Hp - 24] = GHC.Types.I#_con_info;
          I64[Hp - 16] = _saBX::I64;
          I64[Hp - 8] = GHC.Types.I#_con_info;
          I64[Hp] = _saBW::I64;
          R4 = Hp - 39;
          R3 = Hp - 23;
          R2 = Hp - 7;
          call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
      cbgg:
          Hp = Hp - 48;
          R1 = GHC.Types.True_closure+2;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:46.190118 UTC

[section "data" {
     $s$wpoly_a_rawp_closure:
         const $s$wpoly_a_rawp_info;
         const 0;
 },
 $s$wpoly_a_rawp_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 48 updfr_space: Just 8
         }
     {offset
       cbg9:
           R6 = P64[Sp + 32];
           R5 = I64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call $s$wpoly_a_rawp_info(R6,
                                     R5,
                                     R4,
                                     R3,
                                     R2,
                                     R1) args: 8, res: 0, upd: 8;
     }
 },
 $s$wpoly_a_rawp_entry() //  [R6, R5, R4, R3, R2]
         { info_tbl: [(cbgh,
                       label: $s$wpoly_a_rawp_info
                       rep:HeapRep static {
                             Fun {arity: 7 fun_type: ArgGen [True, True, True, True, False]} }),
                      (cbh2,
                       label: block_cbh2_info
                       rep:StackRep [True, True, True, False, True]),
                      (cbh8,
                       label: block_cbh8_info
                       rep:StackRep [False, True, True, True, False, True]),
                      (cbha,
                       label: block_cbha_info
                       rep:StackRep [False, True, True, True, False, True]),
                      (cbhm,
                       label: block_cbhm_info
                       rep:StackRep [False, True, True, True, False, True]),
                      (cbhr,
                       label: block_cbhr_info
                       rep:StackRep [True, False, False, False, True, True, True, False,
                                     True]),
                      (cbhw,
                       label: block_cbhw_info
                       rep:StackRep [True, True, False, False, False, True, True, True,
                                     False, True]),
                      (cbij,
                       label: block_cbij_info
                       rep:StackRep [False, True, True, True, False, True]),
                      (cbio,
                       label: block_cbio_info
                       rep:StackRep [False, True, True, True, False, True]),
                      (cbiq,
                       label: block_cbiq_info
                       rep:StackRep [True, True, True, False, True])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbgh:
           _saC0::P64 = R6;
           _saBZ::I64 = R5;
           _saBY::I64 = R4;
           _saBX::I64 = R3;
           _saBW::I64 = R2;
           if ((Sp + -88) < SpLim) goto cbgi; else goto cbgj;
       cbgj:
           Hp = Hp + 48;
           if (Hp > HpLim) goto cbgl; else goto cbgk;
       cbgl:
           HpAlloc = 48;
           goto cbgi;
       cbgi:
           R1 = $s$wpoly_a_rawp_closure;
           I64[Sp - 40] = _saBW::I64;
           I64[Sp - 32] = _saBX::I64;
           I64[Sp - 24] = _saBY::I64;
           I64[Sp - 16] = _saBZ::I64;
           P64[Sp - 8] = _saC0::P64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 48, res: 0, upd: 8;
       cbgk:
           if (_saBW::I64 != 0) goto cbgf; else goto cbgg;
       cbgf:
           if (%MO_S_Le_W64(_saBX::I64,
                            _saBW::I64)) goto cbiD; else goto cbgw;
       cbiD:
           if (%MO_S_Le_W64(_saBW::I64,
                            _saBY::I64)) goto cbiC; else goto cbgH;
       cbiC:
           _saCf::I64 = _saBW::I64 - _saBX::I64;
           if (%MO_S_Gt_W64(0, _saCf::I64)) goto cbgZ; else goto cbiB;
       cbiB:
           if (%MO_S_Ge_W64(_saCf::I64,
                            _saBZ::I64)) goto cbgZ; else goto cbh3;
       cbgZ:
           Hp = Hp - 48;
           R3 = _saCf::I64;
           R2 = _saBZ::I64;
           call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
       cbh3:
           Hp = Hp - 48;
           _saCn::P64 = P64[(_saC0::P64 + 24) + (_saCf::I64 << 3)];
           I64[Sp - 48] = cbh2;
           R1 = _saCn::P64;
           I64[Sp - 40] = _saBX::I64;
           I64[Sp - 32] = _saBY::I64;
           I64[Sp - 24] = _saBZ::I64;
           P64[Sp - 16] = _saC0::P64;
           I64[Sp - 8] = _saBW::I64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto cbh2; else goto cbh4;
       cbh4:
           call (I64[R1])(R1) returns to cbh2, args: 8, res: 8, upd: 8;
       cbh2:
           I64[Sp - 8] = cbh8;
           _saCp::P64 = P64[R1 + 7];
           R1 = _saCp::P64;
           P64[Sp] = _saCp::P64;
           Sp = Sp - 8;
           call stg_norec_readTVar#(R1) returns to cbh8, args: 8, res: 8, upd: 8;
       cbh8:
           I64[Sp] = cbha;
           R1 = R1;
           if (R1 & 7 != 0) goto cbha; else goto cbhd;
       cbhd:
           call (I64[R1])(R1) returns to cbha, args: 8, res: 8, upd: 8;
       cbha:
           if (R1 & 7 != 1) goto cbhy; else goto cbhj;
       cbhy:
           I64[Sp] = cbhm;
           R1 = P64[R1 + 22];
           if (R1 & 7 != 0) goto cbhm; else goto cbhn;
       cbhn:
           call (I64[R1])(R1) returns to cbhm, args: 8, res: 8, upd: 8;
       cbhm:
           I64[Sp - 24] = cbhr;
           _saCA::P64 = P64[R1 + 15];
           _saCC::P64 = P64[R1 + 23];
           _saCB::I64 = I64[R1 + 31];
           R1 = P64[R1 + 7];
           I64[Sp - 16] = _saCB::I64;
           P64[Sp - 8] = _saCC::P64;
           P64[Sp] = _saCA::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto cbhr; else goto cbhs;
       cbhs:
           call (I64[R1])(R1) returns to cbhr, args: 8, res: 8, upd: 8;
       cbhr:
           I64[Sp - 8] = cbhw;
           _saCD::P64 = R1;
           _saCE::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp] = _saCE::I64;
           P64[Sp + 24] = _saCD::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto cbhw; else goto cbhB;
       cbhB:
           call (I64[R1])(R1) returns to cbhw, args: 8, res: 8, upd: 8;
       cbhw:
           Hp = Hp + 16;
           if (Hp > HpLim) goto cbhH; else goto cbhG;
       cbhH:
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to cbhw, args: 8, res: 8, upd: 8;
       cbhG:
           _saC2::I64 = I64[Sp + 80];
           _saCD::P64 = P64[Sp + 32];
           _saCE::I64 = I64[Sp + 8];
           if (%MO_S_Le_W64(_saCE::I64,
                            _saC2::I64)) goto cbiA; else goto cbhP;
       cbiA:
           if (%MO_S_Le_W64(_saC2::I64,
                            I64[R1 + 7])) goto cbiz; else goto cbhY;
       cbiz:
           _saCB::I64 = I64[Sp + 16];
           _saCP::I64 = _saC2::I64 - _saCE::I64;
           if (%MO_S_Gt_W64(0, _saCP::I64)) goto cbig; else goto cbiy;
       cbiy:
           if (%MO_S_Ge_W64(_saCP::I64,
                            _saCB::I64)) goto cbig; else goto cbir;
       cbig:
           Hp = Hp - 16;
           R3 = _saCP::I64;
           R2 = _saCB::I64;
           Sp = Sp + 88;
           call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
       cbir:
           Hp = Hp - 16;
           _saCX::P64 = P64[P64[Sp + 24] + ((_saCP::I64 << 3) + 24)];
           I64[Sp + 32] = cbij;
           R1 = _saCX::P64;
           Sp = Sp + 32;
           if (R1 & 7 != 0) goto cbij; else goto cbik;
       cbik:
           call (I64[R1])(R1) returns to cbij, args: 8, res: 8, upd: 8;
       cbij:
           I64[Sp] = cbio;
           R1 = P64[R1 + 7];
           call stg_norec_readTVar#(R1) returns to cbio, args: 8, res: 8, upd: 8;
       cbio:
           _saCp::P64 = P64[Sp + 8];
           I64[Sp + 8] = cbiq;
           R2 = R1;
           R1 = _saCp::P64;
           Sp = Sp + 8;
           call stg_norec_writeTVar#(R2,
                                     R1) returns to cbiq, args: 8, res: 8, upd: 8;
       cbiq:
           R6 = P64[Sp + 32];
           R5 = I64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = I64[Sp + 40] - 1;
           Sp = Sp + 48;
           call $s$wpoly_a_rawp_info(R6,
                                     R5,
                                     R4,
                                     R3,
                                     R2) args: 8, res: 0, upd: 8;
       cbhY:
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saC2::I64;
           R4 = R1;
           R3 = _saCD::P64;
           R2 = Hp - 7;
           Sp = Sp + 88;
           call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
       cbhP:
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saC2::I64;
           R4 = R1;
           R3 = _saCD::P64;
           R2 = Hp - 7;
           Sp = Sp + 88;
           call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
       cbhj:
           R1 = SkipList._getNodes1_closure;
           Sp = Sp + 56;
           call (I64[R1])(R1) args: 8, res: 0, upd: 8;
       cbgH:
           I64[Hp - 40] = GHC.Types.I#_con_info;
           I64[Hp - 32] = _saBY::I64;
           I64[Hp - 24] = GHC.Types.I#_con_info;
           I64[Hp - 16] = _saBX::I64;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saBW::I64;
           R4 = Hp - 39;
           R3 = Hp - 23;
           R2 = Hp - 7;
           call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
       cbgw:
           I64[Hp - 40] = GHC.Types.I#_con_info;
           I64[Hp - 32] = _saBY::I64;
           I64[Hp - 24] = GHC.Types.I#_con_info;
           I64[Hp - 16] = _saBX::I64;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saBW::I64;
           R4 = Hp - 39;
           R3 = Hp - 23;
           R2 = Hp - 7;
           call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
       cbgg:
           Hp = Hp - 48;
           R1 = GHC.Types.True_closure+2;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:46.203484 UTC

[section "data" {
     $s$wpoly_a_rawp_closure:
         const $s$wpoly_a_rawp_info;
         const 0;
 },
 $s$wpoly_a_rawp_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 48 updfr_space: Just 8
         }
     {offset
       cbg9:
           R6 = P64[Sp + 32];
           R5 = I64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call $s$wpoly_a_rawp_info(R6,
                                     R5,
                                     R4,
                                     R3,
                                     R2,
                                     R1) args: 8, res: 0, upd: 8;
     }
 },
 $s$wpoly_a_rawp_entry() //  [R6, R5, R4, R3, R2]
         { info_tbl: [(cbgh,
                       label: $s$wpoly_a_rawp_info
                       rep:HeapRep static {
                             Fun {arity: 7 fun_type: ArgGen [True, True, True, True, False]} }),
                      (cbh2,
                       label: block_cbh2_info
                       rep:StackRep [True, True, True, False, True]),
                      (cbh8,
                       label: block_cbh8_info
                       rep:StackRep [False, True, True, True, False, True]),
                      (cbha,
                       label: block_cbha_info
                       rep:StackRep [False, True, True, True, False, True]),
                      (cbhm,
                       label: block_cbhm_info
                       rep:StackRep [False, True, True, True, False, True]),
                      (cbhr,
                       label: block_cbhr_info
                       rep:StackRep [True, False, False, False, True, True, True, False,
                                     True]),
                      (cbhw,
                       label: block_cbhw_info
                       rep:StackRep [True, True, False, False, False, True, True, True,
                                     False, True]),
                      (cbij,
                       label: block_cbij_info
                       rep:StackRep [False, True, True, True, False, True]),
                      (cbio,
                       label: block_cbio_info
                       rep:StackRep [False, True, True, True, False, True]),
                      (cbiq,
                       label: block_cbiq_info
                       rep:StackRep [True, True, True, False, True])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbgh:
           _saC0::P64 = R6;
           _saBZ::I64 = R5;
           _saBY::I64 = R4;
           _saBX::I64 = R3;
           _saBW::I64 = R2;
           if ((Sp + -88) < SpLim) goto cbgi; else goto cbgj;
       cbgj:
           Hp = Hp + 48;
           if (Hp > HpLim) goto cbgl; else goto cbgk;
       cbgl:
           HpAlloc = 48;
           goto cbgi;
       cbgi:
           R1 = $s$wpoly_a_rawp_closure;
           I64[Sp - 40] = _saBW::I64;
           I64[Sp - 32] = _saBX::I64;
           I64[Sp - 24] = _saBY::I64;
           I64[Sp - 16] = _saBZ::I64;
           P64[Sp - 8] = _saC0::P64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 48, res: 0, upd: 8;
       cbgk:
           if (_saBW::I64 != 0) goto cbgf; else goto cbgg;
       cbgf:
           if (%MO_S_Le_W64(_saBX::I64,
                            _saBW::I64)) goto cbiD; else goto cbgw;
       cbiD:
           if (%MO_S_Le_W64(_saBW::I64,
                            _saBY::I64)) goto cbiC; else goto cbgH;
       cbiC:
           _saCf::I64 = _saBW::I64 - _saBX::I64;
           if (%MO_S_Gt_W64(0, _saCf::I64)) goto cbgZ; else goto cbiB;
       cbiB:
           if (%MO_S_Ge_W64(_saCf::I64,
                            _saBZ::I64)) goto cbgZ; else goto cbh3;
       cbgZ:
           Hp = Hp - 48;
           R3 = _saCf::I64;
           R2 = _saBZ::I64;
           call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
       cbh3:
           Hp = Hp - 48;
           _saCn::P64 = P64[(_saC0::P64 + 24) + (_saCf::I64 << 3)];
           I64[Sp - 48] = cbh2;
           R1 = _saCn::P64;
           I64[Sp - 40] = _saBX::I64;
           I64[Sp - 32] = _saBY::I64;
           I64[Sp - 24] = _saBZ::I64;
           P64[Sp - 16] = _saC0::P64;
           I64[Sp - 8] = _saBW::I64;
           Sp = Sp - 48;
           if (R1 & 7 != 0) goto cbh2; else goto cbh4;
       cbh4:
           call (I64[R1])(R1) returns to cbh2, args: 8, res: 8, upd: 8;
       cbh2:
           I64[Sp - 8] = cbh8;
           _saCp::P64 = P64[R1 + 7];
           R1 = _saCp::P64;
           P64[Sp] = _saCp::P64;
           Sp = Sp - 8;
           call stg_norec_readTVar#(R1) returns to cbh8, args: 8, res: 8, upd: 8;
       cbh8:
           I64[Sp] = cbha;
           R1 = R1;
           if (R1 & 7 != 0) goto cbha; else goto cbhd;
       cbhd:
           call (I64[R1])(R1) returns to cbha, args: 8, res: 8, upd: 8;
       cbha:
           if (R1 & 7 != 1) goto cbhy; else goto cbhj;
       cbhy:
           I64[Sp] = cbhm;
           R1 = P64[R1 + 22];
           if (R1 & 7 != 0) goto cbhm; else goto cbhn;
       cbhn:
           call (I64[R1])(R1) returns to cbhm, args: 8, res: 8, upd: 8;
       cbhm:
           I64[Sp - 24] = cbhr;
           _saCA::P64 = P64[R1 + 15];
           _saCC::P64 = P64[R1 + 23];
           _saCB::I64 = I64[R1 + 31];
           R1 = P64[R1 + 7];
           I64[Sp - 16] = _saCB::I64;
           P64[Sp - 8] = _saCC::P64;
           P64[Sp] = _saCA::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto cbhr; else goto cbhs;
       cbhs:
           call (I64[R1])(R1) returns to cbhr, args: 8, res: 8, upd: 8;
       cbhr:
           I64[Sp - 8] = cbhw;
           _saCD::P64 = R1;
           _saCE::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp] = _saCE::I64;
           P64[Sp + 24] = _saCD::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto cbhw; else goto cbhB;
       cbhB:
           call (I64[R1])(R1) returns to cbhw, args: 8, res: 8, upd: 8;
       cbhw:
           Hp = Hp + 16;
           if (Hp > HpLim) goto cbhH; else goto cbhG;
       cbhH:
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to cbhw, args: 8, res: 8, upd: 8;
       cbhG:
           _saC2::I64 = I64[Sp + 80];
           _saCD::P64 = P64[Sp + 32];
           _saCE::I64 = I64[Sp + 8];
           if (%MO_S_Le_W64(_saCE::I64,
                            _saC2::I64)) goto cbiA; else goto cbhP;
       cbiA:
           if (%MO_S_Le_W64(_saC2::I64,
                            I64[R1 + 7])) goto cbiz; else goto cbhY;
       cbiz:
           _saCB::I64 = I64[Sp + 16];
           _saCP::I64 = _saC2::I64 - _saCE::I64;
           if (%MO_S_Gt_W64(0, _saCP::I64)) goto cbig; else goto cbiy;
       cbiy:
           if (%MO_S_Ge_W64(_saCP::I64,
                            _saCB::I64)) goto cbig; else goto cbir;
       cbig:
           Hp = Hp - 16;
           R3 = _saCP::I64;
           R2 = _saCB::I64;
           Sp = Sp + 88;
           call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
       cbir:
           Hp = Hp - 16;
           _saCX::P64 = P64[P64[Sp + 24] + ((_saCP::I64 << 3) + 24)];
           I64[Sp + 32] = cbij;
           R1 = _saCX::P64;
           Sp = Sp + 32;
           if (R1 & 7 != 0) goto cbij; else goto cbik;
       cbik:
           call (I64[R1])(R1) returns to cbij, args: 8, res: 8, upd: 8;
       cbij:
           I64[Sp] = cbio;
           R1 = P64[R1 + 7];
           call stg_norec_readTVar#(R1) returns to cbio, args: 8, res: 8, upd: 8;
       cbio:
           _saCp::P64 = P64[Sp + 8];
           I64[Sp + 8] = cbiq;
           R2 = R1;
           R1 = _saCp::P64;
           Sp = Sp + 8;
           call stg_norec_writeTVar#(R2,
                                     R1) returns to cbiq, args: 8, res: 8, upd: 8;
       cbiq:
           R6 = P64[Sp + 32];
           R5 = I64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = I64[Sp + 40] - 1;
           Sp = Sp + 48;
           call $s$wpoly_a_rawp_info(R6,
                                     R5,
                                     R4,
                                     R3,
                                     R2) args: 8, res: 0, upd: 8;
       cbhY:
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saC2::I64;
           R4 = R1;
           R3 = _saCD::P64;
           R2 = Hp - 7;
           Sp = Sp + 88;
           call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
       cbhP:
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saC2::I64;
           R4 = R1;
           R3 = _saCD::P64;
           R2 = Hp - 7;
           Sp = Sp + 88;
           call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
       cbhj:
           R1 = SkipList._getNodes1_closure;
           Sp = Sp + 56;
           call (I64[R1])(R1) args: 8, res: 0, upd: 8;
       cbgH:
           I64[Hp - 40] = GHC.Types.I#_con_info;
           I64[Hp - 32] = _saBY::I64;
           I64[Hp - 24] = GHC.Types.I#_con_info;
           I64[Hp - 16] = _saBX::I64;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saBW::I64;
           R4 = Hp - 39;
           R3 = Hp - 23;
           R2 = Hp - 7;
           call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
       cbgw:
           I64[Hp - 40] = GHC.Types.I#_con_info;
           I64[Hp - 32] = _saBY::I64;
           I64[Hp - 24] = GHC.Types.I#_con_info;
           I64[Hp - 16] = _saBX::I64;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saBW::I64;
           R4 = Hp - 39;
           R3 = Hp - 23;
           R2 = Hp - 7;
           call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
       cbgg:
           Hp = Hp - 48;
           R1 = GHC.Types.True_closure+2;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:46.235705 UTC

[section "data" {
     SkipList.$wa2_closure:
         const SkipList.$wa2_info;
         const 0;
 },
 SkipList.$wa2_entry() //  [R5, R4, R3, R2]
         { info_tbl: [(cblb,
                       label: SkipList.$wa2_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cblb:
           _saD8::P64 = R5;
           _saD7::P64 = R4;
           _saD6::P64 = R3;
           _saD5::P64 = R2;
           goto cbl4;
       cbl4:
           if ((old + 0) - <highSp> < SpLim) goto cblc; else goto cbld;
       cbld:
           goto cbl3;
       cbl3:
           if (HpLim == 0) goto cblc; else goto cble;
       cblc:
           R5 = _saD8::P64;
           R4 = _saD7::P64;
           R3 = _saD6::P64;
           R2 = _saD5::P64;
           R1 = SkipList.$wa2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cble:
           I64[(young<cbl6> + 8)] = cbl6;
           R1 = _saD7::P64;
           call stg_norec_readTVar#(R1) returns to cbl6, args: 8, res: 8, upd: 8;
       cbl6:
           _saDc::P64 = R1;
           I64[(young<cbl8> + 8)] = cbl8;
           R1 = _saDc::P64;
           if (R1 & 7 != 0) goto cbl8; else goto cbl9;
       cbl9:
           call (I64[R1])(R1) returns to cbl8, args: 8, res: 8, upd: 8;
       cbl8:
           _saDd::P64 = R1;
           _saDe::I64 = I64[_saDd::P64 + 7];
           _saDV::P64 = _saD6::P64;
           _saDU::I64 = _saDe::I64;
           goto saDg;
       saDg:
           goto cbll;
       cbll:
           if (HpLim == 0) goto cblo; else goto cbn6;
       cblo:
           I64[(young<cblm> + 8)] = cblm;
           call stg_gc_noregs() returns to cblm, args: 8, res: 8, upd: 8;
       cblm:
           goto cbll;
       cbn6:
           _saDX::I64 = _saDU::I64;
           switch [-9223372036854775808 .. 9223372036854775807] _saDX::I64 {
               case 0 : goto cbn5;
               default: goto cblD;
           }
       cbn5:
           R1 = GHC.Types.False_closure+1;
           call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
       cblD:
           I64[(young<cblr> + 8)] = cblr;
           R1 = _saDV::P64;
           if (R1 & 7 != 0) goto cblr; else goto cbls;
       cbls:
           call (I64[R1])(R1) returns to cblr, args: 8, res: 8, upd: 8;
       cblr:
           _saDY::P64 = R1;
           _saDZ::P64 = P64[_saDY::P64 + 7];
           _saE0::P64 = P64[_saDY::P64 + 15];
           _saE2::P64 = P64[_saDY::P64 + 23];
           _saE1::I64 = I64[_saDY::P64 + 31];
           I64[(young<cblw> + 8)] = cblw;
           R1 = _saDZ::P64;
           if (R1 & 7 != 0) goto cblw; else goto cblx;
       cblx:
           call (I64[R1])(R1) returns to cblw, args: 8, res: 8, upd: 8;
       cblw:
           _saE3::P64 = R1;
           _saE4::I64 = I64[_saE3::P64 + 7];
           I64[(young<cblB> + 8)] = cblB;
           R1 = _saE0::P64;
           if (R1 & 7 != 0) goto cblB; else goto cblG;
       cblG:
           call (I64[R1])(R1) returns to cblB, args: 8, res: 8, upd: 8;
       cblB:
           _saE5::P64 = R1;
           _saE6::I64 = I64[_saE5::P64 + 7];
           _cblL::I64 = %MO_S_Le_W64(_saE4::I64, _saDX::I64);
           _saE7::I64 = _cblL::I64;
           switch [0 .. 1] _saE7::I64 {
               case 0 : goto cblQ;
               case 1 : goto cbn4;
           }
       cbn4:
           _cblT::I64 = %MO_S_Le_W64(_saDX::I64, _saE6::I64);
           _saEa::I64 = _cblT::I64;
           switch [0 .. 1] _saEa::I64 {
               case 0 : goto cblY;
               case 1 : goto cbn3;
           }
       cbn3:
           _cbm1::I64 = _saDX::I64 - _saE4::I64;
           _saEd::I64 = _cbm1::I64;
           _cbm4::I64 = %MO_S_Le_W64(0, _saEd::I64);
           _saEe::I64 = _cbm4::I64;
           switch [0 .. 1] _saEe::I64 {
               case 0 : goto cbm9;
               case 1 : goto cbn2;
           }
       cbn2:
           _cbmc::I64 = %MO_S_Lt_W64(_saEd::I64, _saE1::I64);
           _saEh::I64 = _cbmc::I64;
           switch [0 .. 1] _saEh::I64 {
               case 0 : goto cbmh;
               case 1 : goto cbml;
           }
       cbml:
           _saEl::P64 = P64[(_saE2::P64 + 24) + (_saEd::I64 << 3)];
           _saEl::P64 = _saEl::P64;
           I64[(young<cbmk> + 8)] = cbmk;
           R1 = _saEl::P64;
           if (R1 & 7 != 0) goto cbmk; else goto cbmm;
       cbmm:
           call (I64[R1])(R1) returns to cbmk, args: 8, res: 8, upd: 8;
       cbmk:
           _saEm::P64 = R1;
           _saEn::P64 = P64[_saEm::P64 + 7];
           I64[(young<cbmq> + 8)] = cbmq;
           R1 = _saEn::P64;
           call stg_norec_readTVar#(R1) returns to cbmq, args: 8, res: 8, upd: 8;
       cbmq:
           _saEq::P64 = R1;
           I64[(young<cbms> + 8)] = cbms;
           R1 = _saEq::P64;
           if (R1 & 7 != 0) goto cbms; else goto cbmv;
       cbmv:
           call (I64[R1])(R1) returns to cbms, args: 8, res: 8, upd: 8;
       cbms:
           _saEr::P64 = R1;
           _cboH::P64 = _saEr::P64 & 7;
           switch [1 .. 2] _cboH::P64 {
               case 1 : goto cbmB;
               case 2 : goto cbmG;
           }
       cbmG:
           _saEt::P64 = P64[_saEr::P64 + 6];
           _saEu::P64 = P64[_saEr::P64 + 14];
           _saEv::P64 = P64[_saEr::P64 + 22];
           I64[(young<cbmE> + 8)] = cbmE;
           R2 = _saD5::P64;
           I64[(young<cbmE> + 32)] = stg_ap_pp_info;
           P64[(young<cbmE> + 24)] = _saEt::P64;
           P64[(young<cbmE> + 16)] = _saD8::P64;
           call GHC.Classes.>_info(R2) returns to cbmE, args: 32, res: 8, upd: 8;
       cbmE:
           _saEw::P64 = R1;
           _cboI::P64 = _saEw::P64 & 7;
           switch [1 .. 2] _cboI::P64 {
               case 1 : goto cbmN;
               case 2 : goto cbn1;
           }
       cbn1:
           _cboJ::I64 = _saDX::I64 - 1;
           _saEy::I64 = _cboJ::I64;
           _saDl::P64 = _saE2::P64;
           _saDk::I64 = _saE1::I64;
           _saDj::I64 = _saE6::I64;
           _saDi::I64 = _saE4::I64;
           _saDh::I64 = _saEy::I64;
           goto saDf;
       cbmN:
           I64[(young<cbmK> + 8)] = cbmK;
           R2 = _saD5::P64;
           I64[(young<cbmK> + 32)] = stg_ap_pp_info;
           P64[(young<cbmK> + 24)] = _saEt::P64;
           P64[(young<cbmK> + 16)] = _saD8::P64;
           call GHC.Classes.<_info(R2) returns to cbmK, args: 32, res: 8, upd: 8;
       cbmK:
           _saEx::P64 = R1;
           _cboK::P64 = _saEx::P64 & 7;
           switch [1 .. 2] _cboK::P64 {
               case 1 : goto cbmT;
               case 2 : goto cbmX;
           }
       cbmX:
           _saDV::P64 = _saEv::P64;
           _saDU::I64 = _saDX::I64;
           goto saDg;
       cbmT:
           R6 = _saE2::P64;
           R5 = _saE1::I64;
           R4 = _saE6::I64;
           R3 = _saE4::I64;
           R2 = _saDX::I64;
           call $s$wpoly_a_rawp_info(R6,
                                     R5,
                                     R4,
                                     R3,
                                     R2) args: 8, res: 0, upd: 8;
       cbmB:
           _cboL::I64 = _saDX::I64 - 1;
           _saEs::I64 = _cboL::I64;
           _saDl::P64 = _saE2::P64;
           _saDk::I64 = _saE1::I64;
           _saDj::I64 = _saE6::I64;
           _saDi::I64 = _saE4::I64;
           _saDh::I64 = _saEs::I64;
           goto saDf;
       saDf:
           goto cbn8;
       cbn8:
           Hp = Hp + 32;
           if (Hp > HpLim) goto cbnd; else goto cbnc;
       cbnd:
           HpAlloc = 32;
           goto cbnb;
       cbnb:
           I64[(young<cbn9> + 8)] = cbn9;
           call stg_gc_noregs() returns to cbn9, args: 8, res: 8, upd: 8;
       cbn9:
           goto cbn8;
       cbnc:
           _saDn::I64 = _saDh::I64;
           switch [-9223372036854775808 .. 9223372036854775807] _saDn::I64 {
               case 0 : goto cboG;
               default: goto cboF;
           }
       cboG:
           Hp = Hp - 32;
           R1 = GHC.Types.False_closure+1;
           call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
       cboF:
           _cbng::I64 = %MO_S_Le_W64(_saDi::I64, _saDn::I64);
           _saDo::I64 = _cbng::I64;
           switch [0 .. 1] _saDo::I64 {
               case 0 : goto cbno;
               case 1 : goto cboD;
           }
       cboD:
           _cbnq::I64 = %MO_S_Le_W64(_saDn::I64, _saDj::I64);
           _saDt::I64 = _cbnq::I64;
           switch [0 .. 1] _saDt::I64 {
               case 0 : goto cbny;
               case 1 : goto cboC;
           }
       cboC:
           _cbnA::I64 = _saDn::I64 - _saDi::I64;
           _saDy::I64 = _cbnA::I64;
           _cbnD::I64 = %MO_S_Le_W64(0, _saDy::I64);
           _saDz::I64 = _cbnD::I64;
           switch [0 .. 1] _saDz::I64 {
               case 0 : goto cbnI;
               case 1 : goto cboB;
           }
       cboB:
           _cbnL::I64 = %MO_S_Lt_W64(_saDy::I64, _saDk::I64);
           _saDC::I64 = _cbnL::I64;
           switch [0 .. 1] _saDC::I64 {
               case 0 : goto cbnQ;
               case 1 : goto cbnU;
           }
       cbnU:
           _saDG::P64 = P64[(_saDl::P64 + 24) + (_saDy::I64 << 3)];
           _saDG::P64 = _saDG::P64;
           Hp = Hp - 32;
           I64[(young<cbnT> + 8)] = cbnT;
           R1 = _saDG::P64;
           if (R1 & 7 != 0) goto cbnT; else goto cbnV;
       cbnV:
           call (I64[R1])(R1) returns to cbnT, args: 8, res: 8, upd: 8;
       cbnT:
           _saDH::P64 = R1;
           _saDI::P64 = P64[_saDH::P64 + 7];
           I64[(young<cbnZ> + 8)] = cbnZ;
           R1 = _saDI::P64;
           call stg_norec_readTVar#(R1) returns to cbnZ, args: 8, res: 8, upd: 8;
       cbnZ:
           _saDL::P64 = R1;
           I64[(young<cbo1> + 8)] = cbo1;
           R1 = _saDL::P64;
           if (R1 & 7 != 0) goto cbo1; else goto cbo4;
       cbo4:
           call (I64[R1])(R1) returns to cbo1, args: 8, res: 8, upd: 8;
       cbo1:
           _saDM::P64 = R1;
           _cboM::P64 = _saDM::P64 & 7;
           switch [1 .. 2] _cboM::P64 {
               case 1 : goto cboa;
               case 2 : goto cbof;
           }
       cbof:
           _saDO::P64 = P64[_saDM::P64 + 6];
           _saDP::P64 = P64[_saDM::P64 + 14];
           _saDQ::P64 = P64[_saDM::P64 + 22];
           I64[(young<cbod> + 8)] = cbod;
           R2 = _saD5::P64;
           I64[(young<cbod> + 32)] = stg_ap_pp_info;
           P64[(young<cbod> + 24)] = _saDO::P64;
           P64[(young<cbod> + 16)] = _saD8::P64;
           call GHC.Classes.>_info(R2) returns to cbod, args: 32, res: 8, upd: 8;
       cbod:
           _saDR::P64 = R1;
           _cboN::P64 = _saDR::P64 & 7;
           switch [1 .. 2] _cboN::P64 {
               case 1 : goto cbom;
               case 2 : goto cboA;
           }
       cboA:
           _cboO::I64 = _saDn::I64 - 1;
           _saDT::I64 = _cboO::I64;
           _saDl::P64 = _saDl::P64;
           _saDk::I64 = _saDk::I64;
           _saDj::I64 = _saDj::I64;
           _saDi::I64 = _saDi::I64;
           _saDh::I64 = _saDT::I64;
           goto saDf;
       cbom:
           I64[(young<cboj> + 8)] = cboj;
           R2 = _saD5::P64;
           I64[(young<cboj> + 32)] = stg_ap_pp_info;
           P64[(young<cboj> + 24)] = _saDO::P64;
           P64[(young<cboj> + 16)] = _saD8::P64;
           call GHC.Classes.<_info(R2) returns to cboj, args: 32, res: 8, upd: 8;
       cboj:
           _saDS::P64 = R1;
           _cboP::P64 = _saDS::P64 & 7;
           switch [1 .. 2] _cboP::P64 {
               case 1 : goto cbos;
               case 2 : goto cbow;
           }
       cbow:
           _saDV::P64 = _saDQ::P64;
           _saDU::I64 = _saDn::I64;
           goto saDg;
       cbos:
           R6 = _saDl::P64;
           R5 = _saDk::I64;
           R4 = _saDj::I64;
           R3 = _saDi::I64;
           R2 = _saDn::I64;
           call $s$wpoly_a_rawp_info(R6,
                                     R5,
                                     R4,
                                     R3,
                                     R2) args: 8, res: 0, upd: 8;
       cboa:
           _cboQ::I64 = _saDn::I64 - 1;
           _saDN::I64 = _cboQ::I64;
           _saDl::P64 = _saDl::P64;
           _saDk::I64 = _saDk::I64;
           _saDj::I64 = _saDj::I64;
           _saDi::I64 = _saDi::I64;
           _saDh::I64 = _saDN::I64;
           goto saDf;
       cbnQ:
           Hp = Hp - 32;
           R3 = _saDy::I64;
           R2 = _saDk::I64;
           call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
       cbnI:
           Hp = Hp - 32;
           R3 = _saDy::I64;
           R2 = _saDk::I64;
           call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
       cbny:
           I64[Hp - 24] = GHC.Types.I#_con_info;
           I64[Hp - 16] = _saDj::I64;
           _cbnv::P64 = Hp - 23;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saDi::I64;
           _cbnw::P64 = Hp - 7;
           R4 = _cbnv::P64;
           R3 = _cbnw::P64;
           R2 = _saDn::I64;
           call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
       cbno:
           I64[Hp - 24] = GHC.Types.I#_con_info;
           I64[Hp - 16] = _saDj::I64;
           _cbnl::P64 = Hp - 23;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saDi::I64;
           _cbnm::P64 = Hp - 7;
           R4 = _cbnl::P64;
           R3 = _cbnm::P64;
           R2 = _saDn::I64;
           call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
       cbmh:
           R3 = _saEd::I64;
           R2 = _saE1::I64;
           call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
       cbm9:
           R3 = _saEd::I64;
           R2 = _saE1::I64;
           call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
       cblY:
           R4 = _saE5::P64;
           R3 = _saE3::P64;
           R2 = _saDX::I64;
           call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
       cblQ:
           R4 = _saE5::P64;
           R3 = _saE3::P64;
           R2 = _saDX::I64;
           call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:46.264056 UTC

{offset
  cblb:
      _saD8::P64 = R5;
      _saD7::P64 = R4;
      _saD6::P64 = R3;
      _saD5::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cblc; else goto cbld;
  cbld:
      if (HpLim == 0) goto cblc; else goto cble;
  cblc:
      R5 = _saD8::P64;
      R4 = _saD7::P64;
      R3 = _saD6::P64;
      R2 = _saD5::P64;
      R1 = SkipList.$wa2_closure;
      call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  cble:
      I64[(young<cbl6> + 8)] = cbl6;
      R1 = _saD7::P64;
      call stg_norec_readTVar#(R1) returns to cbl6, args: 8, res: 8, upd: 8;
  cbl6:
      _saDc::P64 = R1;
      I64[(young<cbl8> + 8)] = cbl8;
      R1 = _saDc::P64;
      if (R1 & 7 != 0) goto cbl8; else goto cbl9;
  cbl9:
      call (I64[R1])(R1) returns to cbl8, args: 8, res: 8, upd: 8;
  cbl8:
      _saDd::P64 = R1;
      _saDe::I64 = I64[_saDd::P64 + 7];
      _saDV::P64 = _saD6::P64;
      _saDU::I64 = _saDe::I64;
      goto cbll;
  cbll:
      if (HpLim == 0) goto cblo; else goto cbn6;
  cblo:
      I64[(young<cblm> + 8)] = cblm;
      call stg_gc_noregs() returns to cblm, args: 8, res: 8, upd: 8;
  cblm:
      goto cbll;
  cbn6:
      _saDX::I64 = _saDU::I64;
      switch [-9223372036854775808 .. 9223372036854775807] _saDX::I64 {
          case 0 : goto cbn5;
          default: goto cblD;
      }
  cbn5:
      R1 = GHC.Types.False_closure+1;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
  cblD:
      I64[(young<cblr> + 8)] = cblr;
      R1 = _saDV::P64;
      if (R1 & 7 != 0) goto cblr; else goto cbls;
  cbls:
      call (I64[R1])(R1) returns to cblr, args: 8, res: 8, upd: 8;
  cblr:
      _saDY::P64 = R1;
      _saDZ::P64 = P64[_saDY::P64 + 7];
      _saE0::P64 = P64[_saDY::P64 + 15];
      _saE2::P64 = P64[_saDY::P64 + 23];
      _saE1::I64 = I64[_saDY::P64 + 31];
      I64[(young<cblw> + 8)] = cblw;
      R1 = _saDZ::P64;
      if (R1 & 7 != 0) goto cblw; else goto cblx;
  cblx:
      call (I64[R1])(R1) returns to cblw, args: 8, res: 8, upd: 8;
  cblw:
      _saE3::P64 = R1;
      _saE4::I64 = I64[_saE3::P64 + 7];
      I64[(young<cblB> + 8)] = cblB;
      R1 = _saE0::P64;
      if (R1 & 7 != 0) goto cblB; else goto cblG;
  cblG:
      call (I64[R1])(R1) returns to cblB, args: 8, res: 8, upd: 8;
  cblB:
      _saE5::P64 = R1;
      _saE6::I64 = I64[_saE5::P64 + 7];
      _cblL::I64 = %MO_S_Le_W64(_saE4::I64, _saDX::I64);
      _saE7::I64 = _cblL::I64;
      switch [0 .. 1] _saE7::I64 {
          case 0 : goto cblQ;
          case 1 : goto cbn4;
      }
  cbn4:
      _cblT::I64 = %MO_S_Le_W64(_saDX::I64, _saE6::I64);
      _saEa::I64 = _cblT::I64;
      switch [0 .. 1] _saEa::I64 {
          case 0 : goto cblY;
          case 1 : goto cbn3;
      }
  cbn3:
      _cbm1::I64 = _saDX::I64 - _saE4::I64;
      _saEd::I64 = _cbm1::I64;
      _cbm4::I64 = %MO_S_Le_W64(0, _saEd::I64);
      _saEe::I64 = _cbm4::I64;
      switch [0 .. 1] _saEe::I64 {
          case 0 : goto cbm9;
          case 1 : goto cbn2;
      }
  cbn2:
      _cbmc::I64 = %MO_S_Lt_W64(_saEd::I64, _saE1::I64);
      _saEh::I64 = _cbmc::I64;
      switch [0 .. 1] _saEh::I64 {
          case 0 : goto cbmh;
          case 1 : goto cbml;
      }
  cbml:
      _saEl::P64 = P64[(_saE2::P64 + 24) + (_saEd::I64 << 3)];
      _saEl::P64 = _saEl::P64;
      I64[(young<cbmk> + 8)] = cbmk;
      R1 = _saEl::P64;
      if (R1 & 7 != 0) goto cbmk; else goto cbmm;
  cbmm:
      call (I64[R1])(R1) returns to cbmk, args: 8, res: 8, upd: 8;
  cbmk:
      _saEm::P64 = R1;
      _saEn::P64 = P64[_saEm::P64 + 7];
      I64[(young<cbmq> + 8)] = cbmq;
      R1 = _saEn::P64;
      call stg_norec_readTVar#(R1) returns to cbmq, args: 8, res: 8, upd: 8;
  cbmq:
      _saEq::P64 = R1;
      I64[(young<cbms> + 8)] = cbms;
      R1 = _saEq::P64;
      if (R1 & 7 != 0) goto cbms; else goto cbmv;
  cbmv:
      call (I64[R1])(R1) returns to cbms, args: 8, res: 8, upd: 8;
  cbms:
      _saEr::P64 = R1;
      _cboH::P64 = _saEr::P64 & 7;
      switch [1 .. 2] _cboH::P64 {
          case 1 : goto cbmB;
          case 2 : goto cbmG;
      }
  cbmG:
      _saEt::P64 = P64[_saEr::P64 + 6];
      _saEu::P64 = P64[_saEr::P64 + 14];
      _saEv::P64 = P64[_saEr::P64 + 22];
      I64[(young<cbmE> + 8)] = cbmE;
      R2 = _saD5::P64;
      I64[(young<cbmE> + 32)] = stg_ap_pp_info;
      P64[(young<cbmE> + 24)] = _saEt::P64;
      P64[(young<cbmE> + 16)] = _saD8::P64;
      call GHC.Classes.>_info(R2) returns to cbmE, args: 32, res: 8, upd: 8;
  cbmE:
      _saEw::P64 = R1;
      _cboI::P64 = _saEw::P64 & 7;
      switch [1 .. 2] _cboI::P64 {
          case 1 : goto cbmN;
          case 2 : goto cbn1;
      }
  cbn1:
      _cboJ::I64 = _saDX::I64 - 1;
      _saEy::I64 = _cboJ::I64;
      _saDl::P64 = _saE2::P64;
      _saDk::I64 = _saE1::I64;
      _saDj::I64 = _saE6::I64;
      _saDi::I64 = _saE4::I64;
      _saDh::I64 = _saEy::I64;
      goto cbn8;
  cbmN:
      I64[(young<cbmK> + 8)] = cbmK;
      R2 = _saD5::P64;
      I64[(young<cbmK> + 32)] = stg_ap_pp_info;
      P64[(young<cbmK> + 24)] = _saEt::P64;
      P64[(young<cbmK> + 16)] = _saD8::P64;
      call GHC.Classes.<_info(R2) returns to cbmK, args: 32, res: 8, upd: 8;
  cbmK:
      _saEx::P64 = R1;
      _cboK::P64 = _saEx::P64 & 7;
      switch [1 .. 2] _cboK::P64 {
          case 1 : goto cbmT;
          case 2 : goto cbmX;
      }
  cbmX:
      _saDV::P64 = _saEv::P64;
      _saDU::I64 = _saDX::I64;
      goto cbll;
  cbmT:
      R6 = _saE2::P64;
      R5 = _saE1::I64;
      R4 = _saE6::I64;
      R3 = _saE4::I64;
      R2 = _saDX::I64;
      call $s$wpoly_a_rawp_info(R6,
                                R5,
                                R4,
                                R3,
                                R2) args: 8, res: 0, upd: 8;
  cbmB:
      _cboL::I64 = _saDX::I64 - 1;
      _saEs::I64 = _cboL::I64;
      _saDl::P64 = _saE2::P64;
      _saDk::I64 = _saE1::I64;
      _saDj::I64 = _saE6::I64;
      _saDi::I64 = _saE4::I64;
      _saDh::I64 = _saEs::I64;
      goto cbn8;
  cbn8:
      Hp = Hp + 32;
      if (Hp > HpLim) goto cbnd; else goto cbnc;
  cbnd:
      HpAlloc = 32;
      I64[(young<cbn9> + 8)] = cbn9;
      call stg_gc_noregs() returns to cbn9, args: 8, res: 8, upd: 8;
  cbn9:
      goto cbn8;
  cbnc:
      _saDn::I64 = _saDh::I64;
      switch [-9223372036854775808 .. 9223372036854775807] _saDn::I64 {
          case 0 : goto cboG;
          default: goto cboF;
      }
  cboG:
      Hp = Hp - 32;
      R1 = GHC.Types.False_closure+1;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
  cboF:
      _cbng::I64 = %MO_S_Le_W64(_saDi::I64, _saDn::I64);
      _saDo::I64 = _cbng::I64;
      switch [0 .. 1] _saDo::I64 {
          case 0 : goto cbno;
          case 1 : goto cboD;
      }
  cboD:
      _cbnq::I64 = %MO_S_Le_W64(_saDn::I64, _saDj::I64);
      _saDt::I64 = _cbnq::I64;
      switch [0 .. 1] _saDt::I64 {
          case 0 : goto cbny;
          case 1 : goto cboC;
      }
  cboC:
      _cbnA::I64 = _saDn::I64 - _saDi::I64;
      _saDy::I64 = _cbnA::I64;
      _cbnD::I64 = %MO_S_Le_W64(0, _saDy::I64);
      _saDz::I64 = _cbnD::I64;
      switch [0 .. 1] _saDz::I64 {
          case 0 : goto cbnI;
          case 1 : goto cboB;
      }
  cboB:
      _cbnL::I64 = %MO_S_Lt_W64(_saDy::I64, _saDk::I64);
      _saDC::I64 = _cbnL::I64;
      switch [0 .. 1] _saDC::I64 {
          case 0 : goto cbnQ;
          case 1 : goto cbnU;
      }
  cbnU:
      _saDG::P64 = P64[(_saDl::P64 + 24) + (_saDy::I64 << 3)];
      _saDG::P64 = _saDG::P64;
      Hp = Hp - 32;
      I64[(young<cbnT> + 8)] = cbnT;
      R1 = _saDG::P64;
      if (R1 & 7 != 0) goto cbnT; else goto cbnV;
  cbnV:
      call (I64[R1])(R1) returns to cbnT, args: 8, res: 8, upd: 8;
  cbnT:
      _saDH::P64 = R1;
      _saDI::P64 = P64[_saDH::P64 + 7];
      I64[(young<cbnZ> + 8)] = cbnZ;
      R1 = _saDI::P64;
      call stg_norec_readTVar#(R1) returns to cbnZ, args: 8, res: 8, upd: 8;
  cbnZ:
      _saDL::P64 = R1;
      I64[(young<cbo1> + 8)] = cbo1;
      R1 = _saDL::P64;
      if (R1 & 7 != 0) goto cbo1; else goto cbo4;
  cbo4:
      call (I64[R1])(R1) returns to cbo1, args: 8, res: 8, upd: 8;
  cbo1:
      _saDM::P64 = R1;
      _cboM::P64 = _saDM::P64 & 7;
      switch [1 .. 2] _cboM::P64 {
          case 1 : goto cboa;
          case 2 : goto cbof;
      }
  cbof:
      _saDO::P64 = P64[_saDM::P64 + 6];
      _saDP::P64 = P64[_saDM::P64 + 14];
      _saDQ::P64 = P64[_saDM::P64 + 22];
      I64[(young<cbod> + 8)] = cbod;
      R2 = _saD5::P64;
      I64[(young<cbod> + 32)] = stg_ap_pp_info;
      P64[(young<cbod> + 24)] = _saDO::P64;
      P64[(young<cbod> + 16)] = _saD8::P64;
      call GHC.Classes.>_info(R2) returns to cbod, args: 32, res: 8, upd: 8;
  cbod:
      _saDR::P64 = R1;
      _cboN::P64 = _saDR::P64 & 7;
      switch [1 .. 2] _cboN::P64 {
          case 1 : goto cbom;
          case 2 : goto cboA;
      }
  cboA:
      _cboO::I64 = _saDn::I64 - 1;
      _saDT::I64 = _cboO::I64;
      _saDl::P64 = _saDl::P64;
      _saDk::I64 = _saDk::I64;
      _saDj::I64 = _saDj::I64;
      _saDi::I64 = _saDi::I64;
      _saDh::I64 = _saDT::I64;
      goto cbn8;
  cbom:
      I64[(young<cboj> + 8)] = cboj;
      R2 = _saD5::P64;
      I64[(young<cboj> + 32)] = stg_ap_pp_info;
      P64[(young<cboj> + 24)] = _saDO::P64;
      P64[(young<cboj> + 16)] = _saD8::P64;
      call GHC.Classes.<_info(R2) returns to cboj, args: 32, res: 8, upd: 8;
  cboj:
      _saDS::P64 = R1;
      _cboP::P64 = _saDS::P64 & 7;
      switch [1 .. 2] _cboP::P64 {
          case 1 : goto cbos;
          case 2 : goto cbow;
      }
  cbow:
      _saDV::P64 = _saDQ::P64;
      _saDU::I64 = _saDn::I64;
      goto cbll;
  cbos:
      R6 = _saDl::P64;
      R5 = _saDk::I64;
      R4 = _saDj::I64;
      R3 = _saDi::I64;
      R2 = _saDn::I64;
      call $s$wpoly_a_rawp_info(R6,
                                R5,
                                R4,
                                R3,
                                R2) args: 8, res: 0, upd: 8;
  cboa:
      _cboQ::I64 = _saDn::I64 - 1;
      _saDN::I64 = _cboQ::I64;
      _saDl::P64 = _saDl::P64;
      _saDk::I64 = _saDk::I64;
      _saDj::I64 = _saDj::I64;
      _saDi::I64 = _saDi::I64;
      _saDh::I64 = _saDN::I64;
      goto cbn8;
  cbnQ:
      Hp = Hp - 32;
      R3 = _saDy::I64;
      R2 = _saDk::I64;
      call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
  cbnI:
      Hp = Hp - 32;
      R3 = _saDy::I64;
      R2 = _saDk::I64;
      call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
  cbny:
      I64[Hp - 24] = GHC.Types.I#_con_info;
      I64[Hp - 16] = _saDj::I64;
      _cbnv::P64 = Hp - 23;
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _saDi::I64;
      _cbnw::P64 = Hp - 7;
      R4 = _cbnv::P64;
      R3 = _cbnw::P64;
      R2 = _saDn::I64;
      call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbno:
      I64[Hp - 24] = GHC.Types.I#_con_info;
      I64[Hp - 16] = _saDj::I64;
      _cbnl::P64 = Hp - 23;
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _saDi::I64;
      _cbnm::P64 = Hp - 7;
      R4 = _cbnl::P64;
      R3 = _cbnm::P64;
      R2 = _saDn::I64;
      call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbmh:
      R3 = _saEd::I64;
      R2 = _saE1::I64;
      call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
  cbm9:
      R3 = _saEd::I64;
      R2 = _saE1::I64;
      call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
  cblY:
      R4 = _saE5::P64;
      R3 = _saE3::P64;
      R2 = _saDX::I64;
      call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cblQ:
      R4 = _saE5::P64;
      R3 = _saE3::P64;
      R2 = _saDX::I64;
      call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:46.280345 UTC

{offset
  cblb:
      _saD8::P64 = R5;
      _saD7::P64 = R4;
      _saD6::P64 = R3;
      _saD5::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cblc; else goto cbld;
  cbld:
      if (HpLim == 0) goto cblc; else goto cble;
  cblc:
      R5 = _saD8::P64;
      R4 = _saD7::P64;
      R3 = _saD6::P64;
      R2 = _saD5::P64;
      R1 = SkipList.$wa2_closure;
      call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  cble:
      I64[(young<cbl6> + 8)] = cbl6;
      R1 = _saD7::P64;
      call stg_norec_readTVar#(R1) returns to cbl6, args: 8, res: 8, upd: 8;
  cbl6:
      _saDc::P64 = R1;
      I64[(young<cbl8> + 8)] = cbl8;
      R1 = _saDc::P64;
      if (R1 & 7 != 0) goto cbl8; else goto cbl9;
  cbl9:
      call (I64[R1])(R1) returns to cbl8, args: 8, res: 8, upd: 8;
  cbl8:
      _saDd::P64 = R1;
      _saDe::I64 = I64[_saDd::P64 + 7];
      _saDV::P64 = _saD6::P64;
      _saDU::I64 = _saDe::I64;
      goto cbll;
  cbll:
      if (HpLim == 0) goto cblo; else goto cbn6;
  cblo:
      I64[(young<cblm> + 8)] = cblm;
      call stg_gc_noregs() returns to cblm, args: 8, res: 8, upd: 8;
  cblm:
      goto cbll;
  cbn6:
      _saDX::I64 = _saDU::I64;
      switch [-9223372036854775808 .. 9223372036854775807] _saDX::I64 {
          case 0 : goto cbn5;
          default: goto cblD;
      }
  cbn5:
      R1 = GHC.Types.False_closure+1;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
  cblD:
      I64[(young<cblr> + 8)] = cblr;
      R1 = _saDV::P64;
      if (R1 & 7 != 0) goto cblr; else goto cbls;
  cbls:
      call (I64[R1])(R1) returns to cblr, args: 8, res: 8, upd: 8;
  cblr:
      _saDY::P64 = R1;
      _saDZ::P64 = P64[_saDY::P64 + 7];
      _saE0::P64 = P64[_saDY::P64 + 15];
      _saE2::P64 = P64[_saDY::P64 + 23];
      _saE1::I64 = I64[_saDY::P64 + 31];
      I64[(young<cblw> + 8)] = cblw;
      R1 = _saDZ::P64;
      if (R1 & 7 != 0) goto cblw; else goto cblx;
  cblx:
      call (I64[R1])(R1) returns to cblw, args: 8, res: 8, upd: 8;
  cblw:
      _saE3::P64 = R1;
      _saE4::I64 = I64[_saE3::P64 + 7];
      I64[(young<cblB> + 8)] = cblB;
      R1 = _saE0::P64;
      if (R1 & 7 != 0) goto cblB; else goto cblG;
  cblG:
      call (I64[R1])(R1) returns to cblB, args: 8, res: 8, upd: 8;
  cblB:
      _saE5::P64 = R1;
      _saE6::I64 = I64[_saE5::P64 + 7];
      _cblL::I64 = %MO_S_Le_W64(_saE4::I64, _saDX::I64);
      _saE7::I64 = _cblL::I64;
      switch [0 .. 1] _saE7::I64 {
          case 0 : goto cblY;
          case 1 : goto cbn4;
      }
  cbn4:
      _cblT::I64 = %MO_S_Le_W64(_saDX::I64, _saE6::I64);
      _saEa::I64 = _cblT::I64;
      switch [0 .. 1] _saEa::I64 {
          case 0 : goto cblY;
          case 1 : goto cbn3;
      }
  cbn3:
      _cbm1::I64 = _saDX::I64 - _saE4::I64;
      _saEd::I64 = _cbm1::I64;
      _cbm4::I64 = %MO_S_Le_W64(0, _saEd::I64);
      _saEe::I64 = _cbm4::I64;
      switch [0 .. 1] _saEe::I64 {
          case 0 : goto cbmh;
          case 1 : goto cbn2;
      }
  cbn2:
      _cbmc::I64 = %MO_S_Lt_W64(_saEd::I64, _saE1::I64);
      _saEh::I64 = _cbmc::I64;
      switch [0 .. 1] _saEh::I64 {
          case 0 : goto cbmh;
          case 1 : goto cbml;
      }
  cbml:
      _saEl::P64 = P64[(_saE2::P64 + 24) + (_saEd::I64 << 3)];
      _saEl::P64 = _saEl::P64;
      I64[(young<cbmk> + 8)] = cbmk;
      R1 = _saEl::P64;
      if (R1 & 7 != 0) goto cbmk; else goto cbmm;
  cbmm:
      call (I64[R1])(R1) returns to cbmk, args: 8, res: 8, upd: 8;
  cbmk:
      _saEm::P64 = R1;
      _saEn::P64 = P64[_saEm::P64 + 7];
      I64[(young<cbmq> + 8)] = cbmq;
      R1 = _saEn::P64;
      call stg_norec_readTVar#(R1) returns to cbmq, args: 8, res: 8, upd: 8;
  cbmq:
      _saEq::P64 = R1;
      I64[(young<cbms> + 8)] = cbms;
      R1 = _saEq::P64;
      if (R1 & 7 != 0) goto cbms; else goto cbmv;
  cbmv:
      call (I64[R1])(R1) returns to cbms, args: 8, res: 8, upd: 8;
  cbms:
      _saEr::P64 = R1;
      _cboH::P64 = _saEr::P64 & 7;
      switch [1 .. 2] _cboH::P64 {
          case 1 : goto cbmB;
          case 2 : goto cbmG;
      }
  cbmG:
      _saEt::P64 = P64[_saEr::P64 + 6];
      _saEu::P64 = P64[_saEr::P64 + 14];
      _saEv::P64 = P64[_saEr::P64 + 22];
      I64[(young<cbmE> + 8)] = cbmE;
      R2 = _saD5::P64;
      I64[(young<cbmE> + 32)] = stg_ap_pp_info;
      P64[(young<cbmE> + 24)] = _saEt::P64;
      P64[(young<cbmE> + 16)] = _saD8::P64;
      call GHC.Classes.>_info(R2) returns to cbmE, args: 32, res: 8, upd: 8;
  cbmE:
      _saEw::P64 = R1;
      _cboI::P64 = _saEw::P64 & 7;
      switch [1 .. 2] _cboI::P64 {
          case 1 : goto cbmN;
          case 2 : goto cbn1;
      }
  cbn1:
      _cboJ::I64 = _saDX::I64 - 1;
      _saEy::I64 = _cboJ::I64;
      _saDl::P64 = _saE2::P64;
      _saDk::I64 = _saE1::I64;
      _saDj::I64 = _saE6::I64;
      _saDi::I64 = _saE4::I64;
      _saDh::I64 = _saEy::I64;
      goto cbn8;
  cbmN:
      I64[(young<cbmK> + 8)] = cbmK;
      R2 = _saD5::P64;
      I64[(young<cbmK> + 32)] = stg_ap_pp_info;
      P64[(young<cbmK> + 24)] = _saEt::P64;
      P64[(young<cbmK> + 16)] = _saD8::P64;
      call GHC.Classes.<_info(R2) returns to cbmK, args: 32, res: 8, upd: 8;
  cbmK:
      _saEx::P64 = R1;
      _cboK::P64 = _saEx::P64 & 7;
      switch [1 .. 2] _cboK::P64 {
          case 1 : goto cbmT;
          case 2 : goto cbmX;
      }
  cbmX:
      _saDV::P64 = _saEv::P64;
      _saDU::I64 = _saDX::I64;
      goto cbll;
  cbmT:
      R6 = _saE2::P64;
      R5 = _saE1::I64;
      R4 = _saE6::I64;
      R3 = _saE4::I64;
      R2 = _saDX::I64;
      call $s$wpoly_a_rawp_info(R6,
                                R5,
                                R4,
                                R3,
                                R2) args: 8, res: 0, upd: 8;
  cbmB:
      _cboL::I64 = _saDX::I64 - 1;
      _saEs::I64 = _cboL::I64;
      _saDl::P64 = _saE2::P64;
      _saDk::I64 = _saE1::I64;
      _saDj::I64 = _saE6::I64;
      _saDi::I64 = _saE4::I64;
      _saDh::I64 = _saEs::I64;
      goto cbn8;
  cbn8:
      Hp = Hp + 32;
      if (Hp > HpLim) goto cbnd; else goto cbnc;
  cbnd:
      HpAlloc = 32;
      I64[(young<cbn9> + 8)] = cbn9;
      call stg_gc_noregs() returns to cbn9, args: 8, res: 8, upd: 8;
  cbn9:
      goto cbn8;
  cbnc:
      _saDn::I64 = _saDh::I64;
      switch [-9223372036854775808 .. 9223372036854775807] _saDn::I64 {
          case 0 : goto cboG;
          default: goto cboF;
      }
  cboG:
      Hp = Hp - 32;
      R1 = GHC.Types.False_closure+1;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
  cboF:
      _cbng::I64 = %MO_S_Le_W64(_saDi::I64, _saDn::I64);
      _saDo::I64 = _cbng::I64;
      switch [0 .. 1] _saDo::I64 {
          case 0 : goto cbno;
          case 1 : goto cboD;
      }
  cboD:
      _cbnq::I64 = %MO_S_Le_W64(_saDn::I64, _saDj::I64);
      _saDt::I64 = _cbnq::I64;
      switch [0 .. 1] _saDt::I64 {
          case 0 : goto cbny;
          case 1 : goto cboC;
      }
  cboC:
      _cbnA::I64 = _saDn::I64 - _saDi::I64;
      _saDy::I64 = _cbnA::I64;
      _cbnD::I64 = %MO_S_Le_W64(0, _saDy::I64);
      _saDz::I64 = _cbnD::I64;
      switch [0 .. 1] _saDz::I64 {
          case 0 : goto cbnQ;
          case 1 : goto cboB;
      }
  cboB:
      _cbnL::I64 = %MO_S_Lt_W64(_saDy::I64, _saDk::I64);
      _saDC::I64 = _cbnL::I64;
      switch [0 .. 1] _saDC::I64 {
          case 0 : goto cbnQ;
          case 1 : goto cbnU;
      }
  cbnU:
      _saDG::P64 = P64[(_saDl::P64 + 24) + (_saDy::I64 << 3)];
      _saDG::P64 = _saDG::P64;
      Hp = Hp - 32;
      I64[(young<cbnT> + 8)] = cbnT;
      R1 = _saDG::P64;
      if (R1 & 7 != 0) goto cbnT; else goto cbnV;
  cbnV:
      call (I64[R1])(R1) returns to cbnT, args: 8, res: 8, upd: 8;
  cbnT:
      _saDH::P64 = R1;
      _saDI::P64 = P64[_saDH::P64 + 7];
      I64[(young<cbnZ> + 8)] = cbnZ;
      R1 = _saDI::P64;
      call stg_norec_readTVar#(R1) returns to cbnZ, args: 8, res: 8, upd: 8;
  cbnZ:
      _saDL::P64 = R1;
      I64[(young<cbo1> + 8)] = cbo1;
      R1 = _saDL::P64;
      if (R1 & 7 != 0) goto cbo1; else goto cbo4;
  cbo4:
      call (I64[R1])(R1) returns to cbo1, args: 8, res: 8, upd: 8;
  cbo1:
      _saDM::P64 = R1;
      _cboM::P64 = _saDM::P64 & 7;
      switch [1 .. 2] _cboM::P64 {
          case 1 : goto cboa;
          case 2 : goto cbof;
      }
  cbof:
      _saDO::P64 = P64[_saDM::P64 + 6];
      _saDP::P64 = P64[_saDM::P64 + 14];
      _saDQ::P64 = P64[_saDM::P64 + 22];
      I64[(young<cbod> + 8)] = cbod;
      R2 = _saD5::P64;
      I64[(young<cbod> + 32)] = stg_ap_pp_info;
      P64[(young<cbod> + 24)] = _saDO::P64;
      P64[(young<cbod> + 16)] = _saD8::P64;
      call GHC.Classes.>_info(R2) returns to cbod, args: 32, res: 8, upd: 8;
  cbod:
      _saDR::P64 = R1;
      _cboN::P64 = _saDR::P64 & 7;
      switch [1 .. 2] _cboN::P64 {
          case 1 : goto cbom;
          case 2 : goto cboA;
      }
  cboA:
      _cboO::I64 = _saDn::I64 - 1;
      _saDT::I64 = _cboO::I64;
      _saDl::P64 = _saDl::P64;
      _saDk::I64 = _saDk::I64;
      _saDj::I64 = _saDj::I64;
      _saDi::I64 = _saDi::I64;
      _saDh::I64 = _saDT::I64;
      goto cbn8;
  cbom:
      I64[(young<cboj> + 8)] = cboj;
      R2 = _saD5::P64;
      I64[(young<cboj> + 32)] = stg_ap_pp_info;
      P64[(young<cboj> + 24)] = _saDO::P64;
      P64[(young<cboj> + 16)] = _saD8::P64;
      call GHC.Classes.<_info(R2) returns to cboj, args: 32, res: 8, upd: 8;
  cboj:
      _saDS::P64 = R1;
      _cboP::P64 = _saDS::P64 & 7;
      switch [1 .. 2] _cboP::P64 {
          case 1 : goto cbos;
          case 2 : goto cbow;
      }
  cbow:
      _saDV::P64 = _saDQ::P64;
      _saDU::I64 = _saDn::I64;
      goto cbll;
  cbos:
      R6 = _saDl::P64;
      R5 = _saDk::I64;
      R4 = _saDj::I64;
      R3 = _saDi::I64;
      R2 = _saDn::I64;
      call $s$wpoly_a_rawp_info(R6,
                                R5,
                                R4,
                                R3,
                                R2) args: 8, res: 0, upd: 8;
  cboa:
      _cboQ::I64 = _saDn::I64 - 1;
      _saDN::I64 = _cboQ::I64;
      _saDl::P64 = _saDl::P64;
      _saDk::I64 = _saDk::I64;
      _saDj::I64 = _saDj::I64;
      _saDi::I64 = _saDi::I64;
      _saDh::I64 = _saDN::I64;
      goto cbn8;
  cbnQ:
      Hp = Hp - 32;
      R3 = _saDy::I64;
      R2 = _saDk::I64;
      call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
  cbny:
      I64[Hp - 24] = GHC.Types.I#_con_info;
      I64[Hp - 16] = _saDj::I64;
      _cbnv::P64 = Hp - 23;
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _saDi::I64;
      _cbnw::P64 = Hp - 7;
      R4 = _cbnv::P64;
      R3 = _cbnw::P64;
      R2 = _saDn::I64;
      call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbno:
      I64[Hp - 24] = GHC.Types.I#_con_info;
      I64[Hp - 16] = _saDj::I64;
      _cbnl::P64 = Hp - 23;
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _saDi::I64;
      _cbnm::P64 = Hp - 7;
      R4 = _cbnl::P64;
      R3 = _cbnm::P64;
      R2 = _saDn::I64;
      call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbmh:
      R3 = _saEd::I64;
      R2 = _saE1::I64;
      call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
  cblY:
      R4 = _saE5::P64;
      R3 = _saE3::P64;
      R2 = _saDX::I64;
      call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:46.296984 UTC

{offset
  cblb:
      _saD8::P64 = R5;
      _saD7::P64 = R4;
      _saD6::P64 = R3;
      _saD5::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cblc; else goto cbld;
  cbld:
      if (HpLim == 0) goto cblc; else goto cble;
  cblc:
      R5 = _saD8::P64;
      R4 = _saD7::P64;
      R3 = _saD6::P64;
      R2 = _saD5::P64;
      R1 = SkipList.$wa2_closure;
      call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  cble:
      I64[(young<cbl6> + 8)] = cbl6;
      R1 = _saD7::P64;
      call stg_norec_readTVar#(R1) returns to cbl6, args: 8, res: 8, upd: 8;
  cbl6:
      _saDc::P64 = R1;
      I64[(young<cbl8> + 8)] = cbl8;
      R1 = _saDc::P64;
      if (R1 & 7 != 0) goto cbl8; else goto cbl9;
  cbl9:
      call (I64[R1])(R1) returns to cbl8, args: 8, res: 8, upd: 8;
  cbl8:
      _saDd::P64 = R1;
      _saDe::I64 = I64[_saDd::P64 + 7];
      _saDV::P64 = _saD6::P64;
      _saDU::I64 = _saDe::I64;
      goto cbll;
  cbll:
      if (HpLim == 0) goto cblo; else goto cbn6;
  cblo:
      I64[(young<cblm> + 8)] = cblm;
      call stg_gc_noregs() returns to cblm, args: 8, res: 8, upd: 8;
  cblm:
      goto cbll;
  cbn6:
      _saDX::I64 = _saDU::I64;
      if (_saDX::I64 != 0) goto cblD; else goto cbn5;
  cblD:
      I64[(young<cblr> + 8)] = cblr;
      R1 = _saDV::P64;
      if (R1 & 7 != 0) goto cblr; else goto cbls;
  cbls:
      call (I64[R1])(R1) returns to cblr, args: 8, res: 8, upd: 8;
  cblr:
      _saDY::P64 = R1;
      _saDZ::P64 = P64[_saDY::P64 + 7];
      _saE0::P64 = P64[_saDY::P64 + 15];
      _saE2::P64 = P64[_saDY::P64 + 23];
      _saE1::I64 = I64[_saDY::P64 + 31];
      I64[(young<cblw> + 8)] = cblw;
      R1 = _saDZ::P64;
      if (R1 & 7 != 0) goto cblw; else goto cblx;
  cblx:
      call (I64[R1])(R1) returns to cblw, args: 8, res: 8, upd: 8;
  cblw:
      _saE3::P64 = R1;
      _saE4::I64 = I64[_saE3::P64 + 7];
      I64[(young<cblB> + 8)] = cblB;
      R1 = _saE0::P64;
      if (R1 & 7 != 0) goto cblB; else goto cblG;
  cblG:
      call (I64[R1])(R1) returns to cblB, args: 8, res: 8, upd: 8;
  cblB:
      _saE5::P64 = R1;
      _saE6::I64 = I64[_saE5::P64 + 7];
      _cblL::I64 = %MO_S_Le_W64(_saE4::I64, _saDX::I64);
      _saE7::I64 = _cblL::I64;
      if (_saE7::I64 != 0) goto cbn4; else goto cblY;
  cbn4:
      _cblT::I64 = %MO_S_Le_W64(_saDX::I64, _saE6::I64);
      _saEa::I64 = _cblT::I64;
      if (_saEa::I64 != 0) goto cbn3; else goto cblY;
  cbn3:
      _cbm1::I64 = _saDX::I64 - _saE4::I64;
      _saEd::I64 = _cbm1::I64;
      _cbm4::I64 = %MO_S_Le_W64(0, _saEd::I64);
      _saEe::I64 = _cbm4::I64;
      if (_saEe::I64 != 0) goto cbn2; else goto cbmh;
  cbn2:
      _cbmc::I64 = %MO_S_Lt_W64(_saEd::I64, _saE1::I64);
      _saEh::I64 = _cbmc::I64;
      if (_saEh::I64 != 0) goto cbml; else goto cbmh;
  cbml:
      _saEl::P64 = P64[(_saE2::P64 + 24) + (_saEd::I64 << 3)];
      _saEl::P64 = _saEl::P64;
      I64[(young<cbmk> + 8)] = cbmk;
      R1 = _saEl::P64;
      if (R1 & 7 != 0) goto cbmk; else goto cbmm;
  cbmm:
      call (I64[R1])(R1) returns to cbmk, args: 8, res: 8, upd: 8;
  cbmk:
      _saEm::P64 = R1;
      _saEn::P64 = P64[_saEm::P64 + 7];
      I64[(young<cbmq> + 8)] = cbmq;
      R1 = _saEn::P64;
      call stg_norec_readTVar#(R1) returns to cbmq, args: 8, res: 8, upd: 8;
  cbmq:
      _saEq::P64 = R1;
      I64[(young<cbms> + 8)] = cbms;
      R1 = _saEq::P64;
      if (R1 & 7 != 0) goto cbms; else goto cbmv;
  cbmv:
      call (I64[R1])(R1) returns to cbms, args: 8, res: 8, upd: 8;
  cbms:
      _saEr::P64 = R1;
      _cboH::P64 = _saEr::P64 & 7;
      if (_cboH::P64 != 1) goto cbmG; else goto cbmB;
  cbmG:
      _saEt::P64 = P64[_saEr::P64 + 6];
      _saEu::P64 = P64[_saEr::P64 + 14];
      _saEv::P64 = P64[_saEr::P64 + 22];
      I64[(young<cbmE> + 8)] = cbmE;
      R2 = _saD5::P64;
      I64[(young<cbmE> + 32)] = stg_ap_pp_info;
      P64[(young<cbmE> + 24)] = _saEt::P64;
      P64[(young<cbmE> + 16)] = _saD8::P64;
      call GHC.Classes.>_info(R2) returns to cbmE, args: 32, res: 8, upd: 8;
  cbmE:
      _saEw::P64 = R1;
      _cboI::P64 = _saEw::P64 & 7;
      if (_cboI::P64 != 1) goto cbn1; else goto cbmN;
  cbn1:
      _cboJ::I64 = _saDX::I64 - 1;
      _saEy::I64 = _cboJ::I64;
      _saDl::P64 = _saE2::P64;
      _saDk::I64 = _saE1::I64;
      _saDj::I64 = _saE6::I64;
      _saDi::I64 = _saE4::I64;
      _saDh::I64 = _saEy::I64;
      goto cbn8;
  cbmN:
      I64[(young<cbmK> + 8)] = cbmK;
      R2 = _saD5::P64;
      I64[(young<cbmK> + 32)] = stg_ap_pp_info;
      P64[(young<cbmK> + 24)] = _saEt::P64;
      P64[(young<cbmK> + 16)] = _saD8::P64;
      call GHC.Classes.<_info(R2) returns to cbmK, args: 32, res: 8, upd: 8;
  cbmK:
      _saEx::P64 = R1;
      _cboK::P64 = _saEx::P64 & 7;
      if (_cboK::P64 != 1) goto cbmX; else goto cbmT;
  cbmX:
      _saDV::P64 = _saEv::P64;
      _saDU::I64 = _saDX::I64;
      goto cbll;
  cbmT:
      R6 = _saE2::P64;
      R5 = _saE1::I64;
      R4 = _saE6::I64;
      R3 = _saE4::I64;
      R2 = _saDX::I64;
      call $s$wpoly_a_rawp_info(R6,
                                R5,
                                R4,
                                R3,
                                R2) args: 8, res: 0, upd: 8;
  cbmB:
      _cboL::I64 = _saDX::I64 - 1;
      _saEs::I64 = _cboL::I64;
      _saDl::P64 = _saE2::P64;
      _saDk::I64 = _saE1::I64;
      _saDj::I64 = _saE6::I64;
      _saDi::I64 = _saE4::I64;
      _saDh::I64 = _saEs::I64;
      goto cbn8;
  cbn8:
      Hp = Hp + 32;
      if (Hp > HpLim) goto cbnd; else goto cbnc;
  cbnd:
      HpAlloc = 32;
      I64[(young<cbn9> + 8)] = cbn9;
      call stg_gc_noregs() returns to cbn9, args: 8, res: 8, upd: 8;
  cbn9:
      goto cbn8;
  cbnc:
      _saDn::I64 = _saDh::I64;
      if (_saDn::I64 != 0) goto cboF; else goto cboG;
  cboF:
      _cbng::I64 = %MO_S_Le_W64(_saDi::I64, _saDn::I64);
      _saDo::I64 = _cbng::I64;
      if (_saDo::I64 != 0) goto cboD; else goto cbno;
  cboD:
      _cbnq::I64 = %MO_S_Le_W64(_saDn::I64, _saDj::I64);
      _saDt::I64 = _cbnq::I64;
      if (_saDt::I64 != 0) goto cboC; else goto cbny;
  cboC:
      _cbnA::I64 = _saDn::I64 - _saDi::I64;
      _saDy::I64 = _cbnA::I64;
      _cbnD::I64 = %MO_S_Le_W64(0, _saDy::I64);
      _saDz::I64 = _cbnD::I64;
      if (_saDz::I64 != 0) goto cboB; else goto cbnQ;
  cboB:
      _cbnL::I64 = %MO_S_Lt_W64(_saDy::I64, _saDk::I64);
      _saDC::I64 = _cbnL::I64;
      if (_saDC::I64 != 0) goto cbnU; else goto cbnQ;
  cbnU:
      _saDG::P64 = P64[(_saDl::P64 + 24) + (_saDy::I64 << 3)];
      _saDG::P64 = _saDG::P64;
      Hp = Hp - 32;
      I64[(young<cbnT> + 8)] = cbnT;
      R1 = _saDG::P64;
      if (R1 & 7 != 0) goto cbnT; else goto cbnV;
  cbnV:
      call (I64[R1])(R1) returns to cbnT, args: 8, res: 8, upd: 8;
  cbnT:
      _saDH::P64 = R1;
      _saDI::P64 = P64[_saDH::P64 + 7];
      I64[(young<cbnZ> + 8)] = cbnZ;
      R1 = _saDI::P64;
      call stg_norec_readTVar#(R1) returns to cbnZ, args: 8, res: 8, upd: 8;
  cbnZ:
      _saDL::P64 = R1;
      I64[(young<cbo1> + 8)] = cbo1;
      R1 = _saDL::P64;
      if (R1 & 7 != 0) goto cbo1; else goto cbo4;
  cbo4:
      call (I64[R1])(R1) returns to cbo1, args: 8, res: 8, upd: 8;
  cbo1:
      _saDM::P64 = R1;
      _cboM::P64 = _saDM::P64 & 7;
      if (_cboM::P64 != 1) goto cbof; else goto cboa;
  cbof:
      _saDO::P64 = P64[_saDM::P64 + 6];
      _saDP::P64 = P64[_saDM::P64 + 14];
      _saDQ::P64 = P64[_saDM::P64 + 22];
      I64[(young<cbod> + 8)] = cbod;
      R2 = _saD5::P64;
      I64[(young<cbod> + 32)] = stg_ap_pp_info;
      P64[(young<cbod> + 24)] = _saDO::P64;
      P64[(young<cbod> + 16)] = _saD8::P64;
      call GHC.Classes.>_info(R2) returns to cbod, args: 32, res: 8, upd: 8;
  cbod:
      _saDR::P64 = R1;
      _cboN::P64 = _saDR::P64 & 7;
      if (_cboN::P64 != 1) goto cboA; else goto cbom;
  cboA:
      _cboO::I64 = _saDn::I64 - 1;
      _saDT::I64 = _cboO::I64;
      _saDl::P64 = _saDl::P64;
      _saDk::I64 = _saDk::I64;
      _saDj::I64 = _saDj::I64;
      _saDi::I64 = _saDi::I64;
      _saDh::I64 = _saDT::I64;
      goto cbn8;
  cbom:
      I64[(young<cboj> + 8)] = cboj;
      R2 = _saD5::P64;
      I64[(young<cboj> + 32)] = stg_ap_pp_info;
      P64[(young<cboj> + 24)] = _saDO::P64;
      P64[(young<cboj> + 16)] = _saD8::P64;
      call GHC.Classes.<_info(R2) returns to cboj, args: 32, res: 8, upd: 8;
  cboj:
      _saDS::P64 = R1;
      _cboP::P64 = _saDS::P64 & 7;
      if (_cboP::P64 != 1) goto cbow; else goto cbos;
  cbow:
      _saDV::P64 = _saDQ::P64;
      _saDU::I64 = _saDn::I64;
      goto cbll;
  cbos:
      R6 = _saDl::P64;
      R5 = _saDk::I64;
      R4 = _saDj::I64;
      R3 = _saDi::I64;
      R2 = _saDn::I64;
      call $s$wpoly_a_rawp_info(R6,
                                R5,
                                R4,
                                R3,
                                R2) args: 8, res: 0, upd: 8;
  cboa:
      _cboQ::I64 = _saDn::I64 - 1;
      _saDN::I64 = _cboQ::I64;
      _saDl::P64 = _saDl::P64;
      _saDk::I64 = _saDk::I64;
      _saDj::I64 = _saDj::I64;
      _saDi::I64 = _saDi::I64;
      _saDh::I64 = _saDN::I64;
      goto cbn8;
  cbnQ:
      Hp = Hp - 32;
      R3 = _saDy::I64;
      R2 = _saDk::I64;
      call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
  cbny:
      I64[Hp - 24] = GHC.Types.I#_con_info;
      I64[Hp - 16] = _saDj::I64;
      _cbnv::P64 = Hp - 23;
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _saDi::I64;
      _cbnw::P64 = Hp - 7;
      R4 = _cbnv::P64;
      R3 = _cbnw::P64;
      R2 = _saDn::I64;
      call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbno:
      I64[Hp - 24] = GHC.Types.I#_con_info;
      I64[Hp - 16] = _saDj::I64;
      _cbnl::P64 = Hp - 23;
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _saDi::I64;
      _cbnm::P64 = Hp - 7;
      R4 = _cbnl::P64;
      R3 = _cbnm::P64;
      R2 = _saDn::I64;
      call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cboG:
      Hp = Hp - 32;
      R1 = GHC.Types.False_closure+1;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
  cbmh:
      R3 = _saEd::I64;
      R2 = _saE1::I64;
      call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
  cblY:
      R4 = _saE5::P64;
      R3 = _saE3::P64;
      R2 = _saDX::I64;
      call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbn5:
      R1 = GHC.Types.False_closure+1;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:46.314932 UTC

{offset
  cblb:
      _saD8::P64 = R5;
      _saD7::P64 = R4;
      _saD6::P64 = R3;
      _saD5::P64 = R2;
      if ((Sp + 8) - 112 < SpLim) goto cblc; else goto cbld;
  cbld:
      if (HpLim == 0) goto cblc; else goto cble;
  cblc:
      R5 = _saD8::P64;
      R4 = _saD7::P64;
      R3 = _saD6::P64;
      R2 = _saD5::P64;
      R1 = SkipList.$wa2_closure;
      call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  cble:
      I64[Sp - 32] = cbl6;
      R1 = _saD7::P64;
      P64[Sp - 24] = _saD5::P64;
      P64[Sp - 16] = _saD6::P64;
      P64[Sp - 8] = _saD8::P64;
      Sp = Sp - 32;
      call stg_norec_readTVar#(R1) returns to cbl6, args: 8, res: 8, upd: 8;
  cbl6:
      _saD5::P64 = P64[Sp + 8];
      _saD6::P64 = P64[Sp + 16];
      _saD8::P64 = P64[Sp + 24];
      _saDc::P64 = R1;
      I64[Sp] = cbl8;
      R1 = _saDc::P64;
      if (R1 & 7 != 0) goto cbl8; else goto cbl9;
  cbl9:
      call (I64[R1])(R1) returns to cbl8, args: 8, res: 8, upd: 8;
  cbl8:
      _saD5::P64 = P64[Sp + 8];
      _saD6::P64 = P64[Sp + 16];
      _saD8::P64 = P64[Sp + 24];
      _saDd::P64 = R1;
      _saDe::I64 = I64[_saDd::P64 + 7];
      _saDV::P64 = _saD6::P64;
      _saDU::I64 = _saDe::I64;
      goto cbll;
  cbll:
      if (HpLim == 0) goto cblo; else goto cbn6;
  cblo:
      I64[Sp - 8] = cblm;
      P64[Sp] = _saDV::P64;
      I64[Sp + 16] = _saDU::I64;
      Sp = Sp - 8;
      call stg_gc_noregs() returns to cblm, args: 8, res: 8, upd: 8;
  cblm:
      _saD5::P64 = P64[Sp + 16];
      _saD8::P64 = P64[Sp + 32];
      _saDU::I64 = I64[Sp + 24];
      _saDV::P64 = P64[Sp + 8];
      goto uboR;
  uboR:
      Sp = Sp + 8;
      goto cbll;
  cbn6:
      _saDX::I64 = _saDU::I64;
      if (_saDX::I64 != 0) goto cblD; else goto cbn5;
  cblD:
      I64[Sp] = cblr;
      R1 = _saDV::P64;
      I64[Sp + 16] = _saDX::I64;
      if (R1 & 7 != 0) goto cblr; else goto cbls;
  cbls:
      call (I64[R1])(R1) returns to cblr, args: 8, res: 8, upd: 8;
  cblr:
      _saD5::P64 = P64[Sp + 8];
      _saD8::P64 = P64[Sp + 24];
      _saDX::I64 = I64[Sp + 16];
      _saDY::P64 = R1;
      _saDZ::P64 = P64[_saDY::P64 + 7];
      _saE0::P64 = P64[_saDY::P64 + 15];
      _saE2::P64 = P64[_saDY::P64 + 23];
      _saE1::I64 = I64[_saDY::P64 + 31];
      I64[Sp - 24] = cblw;
      R1 = _saDZ::P64;
      I64[Sp - 16] = _saE1::I64;
      P64[Sp - 8] = _saE2::P64;
      P64[Sp] = _saE0::P64;
      Sp = Sp - 24;
      if (R1 & 7 != 0) goto cblw; else goto cblx;
  cblx:
      call (I64[R1])(R1) returns to cblw, args: 8, res: 8, upd: 8;
  cblw:
      _saD5::P64 = P64[Sp + 32];
      _saD8::P64 = P64[Sp + 48];
      _saDX::I64 = I64[Sp + 40];
      _saE0::P64 = P64[Sp + 24];
      _saE1::I64 = I64[Sp + 8];
      _saE2::P64 = P64[Sp + 16];
      _saE3::P64 = R1;
      _saE4::I64 = I64[_saE3::P64 + 7];
      I64[Sp - 8] = cblB;
      R1 = _saE0::P64;
      I64[Sp] = _saE4::I64;
      P64[Sp + 24] = _saE3::P64;
      Sp = Sp - 8;
      if (R1 & 7 != 0) goto cblB; else goto cblG;
  cblG:
      call (I64[R1])(R1) returns to cblB, args: 8, res: 8, upd: 8;
  cblB:
      _saD5::P64 = P64[Sp + 40];
      _saD8::P64 = P64[Sp + 56];
      _saDX::I64 = I64[Sp + 48];
      _saE1::I64 = I64[Sp + 16];
      _saE2::P64 = P64[Sp + 24];
      _saE3::P64 = P64[Sp + 32];
      _saE4::I64 = I64[Sp + 8];
      _saE5::P64 = R1;
      _saE6::I64 = I64[_saE5::P64 + 7];
      _cblL::I64 = %MO_S_Le_W64(_saE4::I64, _saDX::I64);
      _saE7::I64 = _cblL::I64;
      if (_saE7::I64 != 0) goto cbn4; else goto cblY;
  cbn4:
      _cblT::I64 = %MO_S_Le_W64(_saDX::I64, _saE6::I64);
      _saEa::I64 = _cblT::I64;
      if (_saEa::I64 != 0) goto cbn3; else goto cblY;
  cbn3:
      _cbm1::I64 = _saDX::I64 - _saE4::I64;
      _saEd::I64 = _cbm1::I64;
      _cbm4::I64 = %MO_S_Le_W64(0, _saEd::I64);
      _saEe::I64 = _cbm4::I64;
      if (_saEe::I64 != 0) goto cbn2; else goto cbmh;
  cbn2:
      _cbmc::I64 = %MO_S_Lt_W64(_saEd::I64, _saE1::I64);
      _saEh::I64 = _cbmc::I64;
      if (_saEh::I64 != 0) goto cbml; else goto cbmh;
  cbml:
      _saEl::P64 = P64[(_saE2::P64 + 24) + (_saEd::I64 << 3)];
      _saEl::P64 = _saEl::P64;
      I64[Sp] = cbmk;
      R1 = _saEl::P64;
      I64[Sp + 32] = _saE6::I64;
      if (R1 & 7 != 0) goto cbmk; else goto cbmm;
  cbmm:
      call (I64[R1])(R1) returns to cbmk, args: 8, res: 8, upd: 8;
  cbmk:
      _saD5::P64 = P64[Sp + 40];
      _saD8::P64 = P64[Sp + 56];
      _saDX::I64 = I64[Sp + 48];
      _saE1::I64 = I64[Sp + 16];
      _saE2::P64 = P64[Sp + 24];
      _saE4::I64 = I64[Sp + 8];
      _saE6::I64 = I64[Sp + 32];
      _saEm::P64 = R1;
      _saEn::P64 = P64[_saEm::P64 + 7];
      I64[Sp] = cbmq;
      R1 = _saEn::P64;
      call stg_norec_readTVar#(R1) returns to cbmq, args: 8, res: 8, upd: 8;
  cbmq:
      _saD5::P64 = P64[Sp + 40];
      _saD8::P64 = P64[Sp + 56];
      _saDX::I64 = I64[Sp + 48];
      _saE1::I64 = I64[Sp + 16];
      _saE2::P64 = P64[Sp + 24];
      _saE4::I64 = I64[Sp + 8];
      _saE6::I64 = I64[Sp + 32];
      _saEq::P64 = R1;
      I64[Sp] = cbms;
      R1 = _saEq::P64;
      if (R1 & 7 != 0) goto cbms; else goto cbmv;
  cbmv:
      call (I64[R1])(R1) returns to cbms, args: 8, res: 8, upd: 8;
  cbms:
      _saD5::P64 = P64[Sp + 40];
      _saD8::P64 = P64[Sp + 56];
      _saDX::I64 = I64[Sp + 48];
      _saE1::I64 = I64[Sp + 16];
      _saE2::P64 = P64[Sp + 24];
      _saE4::I64 = I64[Sp + 8];
      _saE6::I64 = I64[Sp + 32];
      _saEr::P64 = R1;
      _cboH::P64 = _saEr::P64 & 7;
      if (_cboH::P64 != 1) goto cbmG; else goto cbmB;
  cbmG:
      _saEt::P64 = P64[_saEr::P64 + 6];
      _saEu::P64 = P64[_saEr::P64 + 14];
      _saEv::P64 = P64[_saEr::P64 + 22];
      I64[Sp - 16] = cbmE;
      R2 = _saD5::P64;
      I64[Sp - 40] = stg_ap_pp_info;
      P64[Sp - 32] = _saEt::P64;
      P64[Sp - 24] = _saD8::P64;
      P64[Sp - 8] = _saEv::P64;
      P64[Sp] = _saEt::P64;
      Sp = Sp - 40;
      call GHC.Classes.>_info(R2) returns to cbmE, args: 32, res: 8, upd: 8;
  cbmE:
      _saD5::P64 = P64[Sp + 56];
      _saD8::P64 = P64[Sp + 72];
      _saDX::I64 = I64[Sp + 64];
      _saE1::I64 = I64[Sp + 32];
      _saE2::P64 = P64[Sp + 40];
      _saE4::I64 = I64[Sp + 24];
      _saE6::I64 = I64[Sp + 48];
      _saEt::P64 = P64[Sp + 16];
      _saEv::P64 = P64[Sp + 8];
      _saEw::P64 = R1;
      _cboI::P64 = _saEw::P64 & 7;
      if (_cboI::P64 != 1) goto cbn1; else goto cbmN;
  cbn1:
      _cboJ::I64 = _saDX::I64 - 1;
      _saEy::I64 = _cboJ::I64;
      _saDl::P64 = _saE2::P64;
      _saDk::I64 = _saE1::I64;
      _saDj::I64 = _saE6::I64;
      _saDi::I64 = _saE4::I64;
      _saDh::I64 = _saEy::I64;
      goto cbn8;
  cbmN:
      I64[Sp] = cbmK;
      R2 = _saD5::P64;
      I64[Sp - 24] = stg_ap_pp_info;
      P64[Sp - 16] = _saEt::P64;
      P64[Sp - 8] = _saD8::P64;
      Sp = Sp - 24;
      call GHC.Classes.<_info(R2) returns to cbmK, args: 32, res: 8, upd: 8;
  cbmK:
      _saD5::P64 = P64[Sp + 56];
      _saD8::P64 = P64[Sp + 72];
      _saDX::I64 = I64[Sp + 64];
      _saE1::I64 = I64[Sp + 32];
      _saE2::P64 = P64[Sp + 40];
      _saE4::I64 = I64[Sp + 24];
      _saE6::I64 = I64[Sp + 48];
      _saEv::P64 = P64[Sp + 8];
      _saEx::P64 = R1;
      _cboK::P64 = _saEx::P64 & 7;
      if (_cboK::P64 != 1) goto cbmX; else goto cbmT;
  cbmX:
      _saDV::P64 = _saEv::P64;
      _saDU::I64 = _saDX::I64;
      goto uboS;
  uboS:
      Sp = Sp + 48;
      goto cbll;
  cbmT:
      R6 = _saE2::P64;
      R5 = _saE1::I64;
      R4 = _saE6::I64;
      R3 = _saE4::I64;
      R2 = _saDX::I64;
      Sp = Sp + 80;
      call $s$wpoly_a_rawp_info(R6,
                                R5,
                                R4,
                                R3,
                                R2) args: 8, res: 0, upd: 8;
  cbmB:
      _cboL::I64 = _saDX::I64 - 1;
      _saEs::I64 = _cboL::I64;
      _saDl::P64 = _saE2::P64;
      _saDk::I64 = _saE1::I64;
      _saDj::I64 = _saE6::I64;
      _saDi::I64 = _saE4::I64;
      _saDh::I64 = _saEs::I64;
      goto uboT;
  uboT:
      Sp = Sp - 16;
      goto cbn8;
  cbn8:
      Hp = Hp + 32;
      if (Hp > HpLim) goto cbnd; else goto cbnc;
  cbnd:
      HpAlloc = 32;
      I64[Sp + 16] = cbn9;
      P64[Sp + 24] = _saDl::P64;
      I64[Sp + 32] = _saDk::I64;
      I64[Sp + 40] = _saDj::I64;
      I64[Sp + 48] = _saDi::I64;
      I64[Sp + 64] = _saDh::I64;
      Sp = Sp + 16;
      call stg_gc_noregs() returns to cbn9, args: 8, res: 8, upd: 8;
  cbn9:
      _saD5::P64 = P64[Sp + 40];
      _saD8::P64 = P64[Sp + 56];
      _saDh::I64 = I64[Sp + 48];
      _saDi::I64 = I64[Sp + 32];
      _saDj::I64 = I64[Sp + 24];
      _saDk::I64 = I64[Sp + 16];
      _saDl::P64 = P64[Sp + 8];
      goto uboU;
  uboU:
      Sp = Sp - 16;
      goto cbn8;
  cbnc:
      _saDn::I64 = _saDh::I64;
      if (_saDn::I64 != 0) goto cboF; else goto cboG;
  cboF:
      _cbng::I64 = %MO_S_Le_W64(_saDi::I64, _saDn::I64);
      _saDo::I64 = _cbng::I64;
      if (_saDo::I64 != 0) goto cboD; else goto cbno;
  cboD:
      _cbnq::I64 = %MO_S_Le_W64(_saDn::I64, _saDj::I64);
      _saDt::I64 = _cbnq::I64;
      if (_saDt::I64 != 0) goto cboC; else goto cbny;
  cboC:
      _cbnA::I64 = _saDn::I64 - _saDi::I64;
      _saDy::I64 = _cbnA::I64;
      _cbnD::I64 = %MO_S_Le_W64(0, _saDy::I64);
      _saDz::I64 = _cbnD::I64;
      if (_saDz::I64 != 0) goto cboB; else goto cbnQ;
  cboB:
      _cbnL::I64 = %MO_S_Lt_W64(_saDy::I64, _saDk::I64);
      _saDC::I64 = _cbnL::I64;
      if (_saDC::I64 != 0) goto cbnU; else goto cbnQ;
  cbnU:
      _saDG::P64 = P64[(_saDl::P64 + 24) + (_saDy::I64 << 3)];
      _saDG::P64 = _saDG::P64;
      Hp = Hp - 32;
      I64[Sp + 16] = cbnT;
      R1 = _saDG::P64;
      I64[Sp + 24] = _saDn::I64;
      P64[Sp + 32] = _saDl::P64;
      I64[Sp + 40] = _saDk::I64;
      I64[Sp + 48] = _saDj::I64;
      I64[Sp + 64] = _saDi::I64;
      Sp = Sp + 16;
      if (R1 & 7 != 0) goto cbnT; else goto cbnV;
  cbnV:
      call (I64[R1])(R1) returns to cbnT, args: 8, res: 8, upd: 8;
  cbnT:
      _saD5::P64 = P64[Sp + 40];
      _saD8::P64 = P64[Sp + 56];
      _saDi::I64 = I64[Sp + 48];
      _saDj::I64 = I64[Sp + 32];
      _saDk::I64 = I64[Sp + 24];
      _saDl::P64 = P64[Sp + 16];
      _saDn::I64 = I64[Sp + 8];
      _saDH::P64 = R1;
      _saDI::P64 = P64[_saDH::P64 + 7];
      I64[Sp] = cbnZ;
      R1 = _saDI::P64;
      call stg_norec_readTVar#(R1) returns to cbnZ, args: 8, res: 8, upd: 8;
  cbnZ:
      _saD5::P64 = P64[Sp + 40];
      _saD8::P64 = P64[Sp + 56];
      _saDi::I64 = I64[Sp + 48];
      _saDj::I64 = I64[Sp + 32];
      _saDk::I64 = I64[Sp + 24];
      _saDl::P64 = P64[Sp + 16];
      _saDn::I64 = I64[Sp + 8];
      _saDL::P64 = R1;
      I64[Sp] = cbo1;
      R1 = _saDL::P64;
      if (R1 & 7 != 0) goto cbo1; else goto cbo4;
  cbo4:
      call (I64[R1])(R1) returns to cbo1, args: 8, res: 8, upd: 8;
  cbo1:
      _saD5::P64 = P64[Sp + 40];
      _saD8::P64 = P64[Sp + 56];
      _saDi::I64 = I64[Sp + 48];
      _saDj::I64 = I64[Sp + 32];
      _saDk::I64 = I64[Sp + 24];
      _saDl::P64 = P64[Sp + 16];
      _saDn::I64 = I64[Sp + 8];
      _saDM::P64 = R1;
      _cboM::P64 = _saDM::P64 & 7;
      if (_cboM::P64 != 1) goto cbof; else goto cboa;
  cbof:
      _saDO::P64 = P64[_saDM::P64 + 6];
      _saDP::P64 = P64[_saDM::P64 + 14];
      _saDQ::P64 = P64[_saDM::P64 + 22];
      I64[Sp - 16] = cbod;
      R2 = _saD5::P64;
      I64[Sp - 40] = stg_ap_pp_info;
      P64[Sp - 32] = _saDO::P64;
      P64[Sp - 24] = _saD8::P64;
      P64[Sp - 8] = _saDQ::P64;
      P64[Sp] = _saDO::P64;
      Sp = Sp - 40;
      call GHC.Classes.>_info(R2) returns to cbod, args: 32, res: 8, upd: 8;
  cbod:
      _saD5::P64 = P64[Sp + 56];
      _saD8::P64 = P64[Sp + 72];
      _saDi::I64 = I64[Sp + 64];
      _saDj::I64 = I64[Sp + 48];
      _saDk::I64 = I64[Sp + 40];
      _saDl::P64 = P64[Sp + 32];
      _saDn::I64 = I64[Sp + 24];
      _saDO::P64 = P64[Sp + 16];
      _saDQ::P64 = P64[Sp + 8];
      _saDR::P64 = R1;
      _cboN::P64 = _saDR::P64 & 7;
      if (_cboN::P64 != 1) goto cboA; else goto cbom;
  cboA:
      _cboO::I64 = _saDn::I64 - 1;
      _saDT::I64 = _cboO::I64;
      _saDl::P64 = _saDl::P64;
      _saDk::I64 = _saDk::I64;
      _saDj::I64 = _saDj::I64;
      _saDi::I64 = _saDi::I64;
      _saDh::I64 = _saDT::I64;
      goto cbn8;
  cbom:
      I64[Sp] = cboj;
      R2 = _saD5::P64;
      I64[Sp - 24] = stg_ap_pp_info;
      P64[Sp - 16] = _saDO::P64;
      P64[Sp - 8] = _saD8::P64;
      Sp = Sp - 24;
      call GHC.Classes.<_info(R2) returns to cboj, args: 32, res: 8, upd: 8;
  cboj:
      _saD5::P64 = P64[Sp + 56];
      _saD8::P64 = P64[Sp + 72];
      _saDi::I64 = I64[Sp + 64];
      _saDj::I64 = I64[Sp + 48];
      _saDk::I64 = I64[Sp + 40];
      _saDl::P64 = P64[Sp + 32];
      _saDn::I64 = I64[Sp + 24];
      _saDQ::P64 = P64[Sp + 8];
      _saDS::P64 = R1;
      _cboP::P64 = _saDS::P64 & 7;
      if (_cboP::P64 != 1) goto cbow; else goto cbos;
  cbow:
      _saDV::P64 = _saDQ::P64;
      _saDU::I64 = _saDn::I64;
      goto uboV;
  uboV:
      Sp = Sp + 48;
      goto cbll;
  cbos:
      R6 = _saDl::P64;
      R5 = _saDk::I64;
      R4 = _saDj::I64;
      R3 = _saDi::I64;
      R2 = _saDn::I64;
      Sp = Sp + 80;
      call $s$wpoly_a_rawp_info(R6,
                                R5,
                                R4,
                                R3,
                                R2) args: 8, res: 0, upd: 8;
  cboa:
      _cboQ::I64 = _saDn::I64 - 1;
      _saDN::I64 = _cboQ::I64;
      _saDl::P64 = _saDl::P64;
      _saDk::I64 = _saDk::I64;
      _saDj::I64 = _saDj::I64;
      _saDi::I64 = _saDi::I64;
      _saDh::I64 = _saDN::I64;
      goto uboW;
  uboW:
      Sp = Sp - 16;
      goto cbn8;
  cbnQ:
      Hp = Hp - 32;
      R3 = _saDy::I64;
      R2 = _saDk::I64;
      Sp = Sp + 80;
      call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
  cbny:
      I64[Hp - 24] = GHC.Types.I#_con_info;
      I64[Hp - 16] = _saDj::I64;
      _cbnv::P64 = Hp - 23;
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _saDi::I64;
      _cbnw::P64 = Hp - 7;
      R4 = _cbnv::P64;
      R3 = _cbnw::P64;
      R2 = _saDn::I64;
      Sp = Sp + 80;
      call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbno:
      I64[Hp - 24] = GHC.Types.I#_con_info;
      I64[Hp - 16] = _saDj::I64;
      _cbnl::P64 = Hp - 23;
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _saDi::I64;
      _cbnm::P64 = Hp - 7;
      R4 = _cbnl::P64;
      R3 = _cbnm::P64;
      R2 = _saDn::I64;
      Sp = Sp + 80;
      call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cboG:
      Hp = Hp - 32;
      R1 = GHC.Types.False_closure+1;
      Sp = Sp + 80;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
  cbmh:
      R3 = _saEd::I64;
      R2 = _saE1::I64;
      Sp = Sp + 64;
      call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
  cblY:
      R4 = _saE5::P64;
      R3 = _saE3::P64;
      R2 = _saDX::I64;
      Sp = Sp + 64;
      call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbn5:
      R1 = GHC.Types.False_closure+1;
      Sp = Sp + 32;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:46.338062 UTC

{offset
  cblb:
      _saD8::P64 = R5;
      _saD7::P64 = R4;
      _saD6::P64 = R3;
      _saD5::P64 = R2;
      if ((Sp + -104) < SpLim) goto cblc; else goto cbld;
  cbld:
      if (HpLim == 0) goto cblc; else goto cble;
  cblc:
      R5 = _saD8::P64;
      R4 = _saD7::P64;
      R3 = _saD6::P64;
      R2 = _saD5::P64;
      R1 = SkipList.$wa2_closure;
      call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  cble:
      I64[Sp - 32] = cbl6;
      R1 = _saD7::P64;
      P64[Sp - 24] = _saD5::P64;
      P64[Sp - 16] = _saD6::P64;
      P64[Sp - 8] = _saD8::P64;
      Sp = Sp - 32;
      call stg_norec_readTVar#(R1) returns to cbl6, args: 8, res: 8, upd: 8;
  cbl6:
      I64[Sp] = cbl8;
      R1 = R1;
      if (R1 & 7 != 0) goto cbl8; else goto cbl9;
  cbl9:
      call (I64[R1])(R1) returns to cbl8, args: 8, res: 8, upd: 8;
  cbl8:
      _saDV::P64 = P64[Sp + 16];
      _saDU::I64 = I64[R1 + 7];
      goto cbll;
  cbll:
      if (HpLim == 0) goto cblo; else goto cbn6;
  cblo:
      I64[Sp - 8] = cblm;
      P64[Sp] = _saDV::P64;
      I64[Sp + 16] = _saDU::I64;
      Sp = Sp - 8;
      call stg_gc_noregs() returns to cblm, args: 8, res: 8, upd: 8;
  cblm:
      goto uboR;
  uboR:
      _saDU::I64 = I64[Sp + 24];
      _saDV::P64 = P64[Sp + 8];
      Sp = Sp + 8;
      goto cbll;
  cbn6:
      if (_saDU::I64 != 0) goto cblD; else goto cbn5;
  cblD:
      I64[Sp] = cblr;
      R1 = _saDV::P64;
      I64[Sp + 16] = _saDU::I64;
      if (R1 & 7 != 0) goto cblr; else goto cbls;
  cbls:
      call (I64[R1])(R1) returns to cblr, args: 8, res: 8, upd: 8;
  cblr:
      I64[Sp - 24] = cblw;
      _saE0::P64 = P64[R1 + 15];
      _saE2::P64 = P64[R1 + 23];
      _saE1::I64 = I64[R1 + 31];
      R1 = P64[R1 + 7];
      I64[Sp - 16] = _saE1::I64;
      P64[Sp - 8] = _saE2::P64;
      P64[Sp] = _saE0::P64;
      Sp = Sp - 24;
      if (R1 & 7 != 0) goto cblw; else goto cblx;
  cblx:
      call (I64[R1])(R1) returns to cblw, args: 8, res: 8, upd: 8;
  cblw:
      I64[Sp - 8] = cblB;
      _saE3::P64 = R1;
      _saE4::I64 = I64[R1 + 7];
      R1 = P64[Sp + 24];
      I64[Sp] = _saE4::I64;
      P64[Sp + 24] = _saE3::P64;
      Sp = Sp - 8;
      if (R1 & 7 != 0) goto cblB; else goto cblG;
  cblG:
      call (I64[R1])(R1) returns to cblB, args: 8, res: 8, upd: 8;
  cblB:
      _saDX::I64 = I64[Sp + 48];
      _saE3::P64 = P64[Sp + 32];
      _saE4::I64 = I64[Sp + 8];
      _saE5::P64 = R1;
      if (%MO_S_Le_W64(_saE4::I64,
                       _saDX::I64)) goto cbn4; else goto cblY;
  cbn4:
      _saE6::I64 = I64[R1 + 7];
      if (%MO_S_Le_W64(_saDX::I64,
                       _saE6::I64)) goto cbn3; else goto cblY;
  cbn3:
      _saE1::I64 = I64[Sp + 16];
      _saEd::I64 = _saDX::I64 - _saE4::I64;
      if (%MO_S_Le_W64(0, _saEd::I64)) goto cbn2; else goto cbmh;
  cbn2:
      if (%MO_S_Lt_W64(_saEd::I64,
                       _saE1::I64)) goto cbml; else goto cbmh;
  cbml:
      _saEl::P64 = P64[P64[Sp + 24] + ((_saEd::I64 << 3) + 24)];
      I64[Sp] = cbmk;
      R1 = _saEl::P64;
      I64[Sp + 32] = _saE6::I64;
      if (R1 & 7 != 0) goto cbmk; else goto cbmm;
  cbmm:
      call (I64[R1])(R1) returns to cbmk, args: 8, res: 8, upd: 8;
  cbmk:
      I64[Sp] = cbmq;
      R1 = P64[R1 + 7];
      call stg_norec_readTVar#(R1) returns to cbmq, args: 8, res: 8, upd: 8;
  cbmq:
      I64[Sp] = cbms;
      R1 = R1;
      if (R1 & 7 != 0) goto cbms; else goto cbmv;
  cbmv:
      call (I64[R1])(R1) returns to cbms, args: 8, res: 8, upd: 8;
  cbms:
      if (R1 & 7 != 1) goto cbmG; else goto cbmB;
  cbmG:
      I64[Sp - 16] = cbmE;
      R2 = P64[Sp + 40];
      I64[Sp - 40] = stg_ap_pp_info;
      _saEt::P64 = P64[R1 + 6];
      P64[Sp - 32] = _saEt::P64;
      P64[Sp - 24] = P64[Sp + 56];
      P64[Sp - 8] = P64[R1 + 22];
      P64[Sp] = _saEt::P64;
      Sp = Sp - 40;
      call GHC.Classes.>_info(R2) returns to cbmE, args: 32, res: 8, upd: 8;
  cbmE:
      if (R1 & 7 != 1) goto cbn1; else goto cbmN;
  cbn1:
      _saDl::P64 = P64[Sp + 40];
      _saDk::I64 = I64[Sp + 32];
      _saDj::I64 = I64[Sp + 48];
      _saDi::I64 = I64[Sp + 24];
      _saDh::I64 = I64[Sp + 64] - 1;
      goto cbn8;
  cbmN:
      I64[Sp] = cbmK;
      R2 = P64[Sp + 56];
      I64[Sp - 24] = stg_ap_pp_info;
      P64[Sp - 16] = P64[Sp + 16];
      P64[Sp - 8] = P64[Sp + 72];
      Sp = Sp - 24;
      call GHC.Classes.<_info(R2) returns to cbmK, args: 32, res: 8, upd: 8;
  cbmK:
      _saDX::I64 = I64[Sp + 64];
      if (R1 & 7 != 1) goto cbmX; else goto cbmT;
  cbmX:
      goto uboS;
  uboS:
      _saDV::P64 = P64[Sp + 8];
      Sp = Sp + 48;
      _saDU::I64 = _saDX::I64;
      goto cbll;
  cbmT:
      R6 = P64[Sp + 40];
      R5 = I64[Sp + 32];
      R4 = I64[Sp + 48];
      R3 = I64[Sp + 24];
      R2 = _saDX::I64;
      Sp = Sp + 80;
      call $s$wpoly_a_rawp_info(R6,
                                R5,
                                R4,
                                R3,
                                R2) args: 8, res: 0, upd: 8;
  cbmB:
      goto uboT;
  uboT:
      _saDl::P64 = P64[Sp + 24];
      _saDk::I64 = I64[Sp + 16];
      _saDj::I64 = I64[Sp + 32];
      _saDi::I64 = I64[Sp + 8];
      _saDh::I64 = I64[Sp + 48] - 1;
      Sp = Sp - 16;
      goto cbn8;
  cbn8:
      Hp = Hp + 32;
      if (Hp > HpLim) goto cbnd; else goto cbnc;
  cbnd:
      HpAlloc = 32;
      I64[Sp + 16] = cbn9;
      P64[Sp + 24] = _saDl::P64;
      I64[Sp + 32] = _saDk::I64;
      I64[Sp + 40] = _saDj::I64;
      I64[Sp + 48] = _saDi::I64;
      I64[Sp + 64] = _saDh::I64;
      Sp = Sp + 16;
      call stg_gc_noregs() returns to cbn9, args: 8, res: 8, upd: 8;
  cbn9:
      goto uboU;
  uboU:
      _saDh::I64 = I64[Sp + 48];
      _saDi::I64 = I64[Sp + 32];
      _saDj::I64 = I64[Sp + 24];
      _saDk::I64 = I64[Sp + 16];
      _saDl::P64 = P64[Sp + 8];
      Sp = Sp - 16;
      goto cbn8;
  cbnc:
      if (_saDh::I64 != 0) goto cboF; else goto cboG;
  cboF:
      if (%MO_S_Le_W64(_saDi::I64,
                       _saDh::I64)) goto cboD; else goto cbno;
  cboD:
      if (%MO_S_Le_W64(_saDh::I64,
                       _saDj::I64)) goto cboC; else goto cbny;
  cboC:
      _saDy::I64 = _saDh::I64 - _saDi::I64;
      if (%MO_S_Le_W64(0, _saDy::I64)) goto cboB; else goto cbnQ;
  cboB:
      if (%MO_S_Lt_W64(_saDy::I64,
                       _saDk::I64)) goto cbnU; else goto cbnQ;
  cbnU:
      Hp = Hp - 32;
      _saDG::P64 = P64[(_saDl::P64 + 24) + (_saDy::I64 << 3)];
      I64[Sp + 16] = cbnT;
      R1 = _saDG::P64;
      I64[Sp + 24] = _saDh::I64;
      P64[Sp + 32] = _saDl::P64;
      I64[Sp + 40] = _saDk::I64;
      I64[Sp + 48] = _saDj::I64;
      I64[Sp + 64] = _saDi::I64;
      Sp = Sp + 16;
      if (R1 & 7 != 0) goto cbnT; else goto cbnV;
  cbnV:
      call (I64[R1])(R1) returns to cbnT, args: 8, res: 8, upd: 8;
  cbnT:
      I64[Sp] = cbnZ;
      R1 = P64[R1 + 7];
      call stg_norec_readTVar#(R1) returns to cbnZ, args: 8, res: 8, upd: 8;
  cbnZ:
      I64[Sp] = cbo1;
      R1 = R1;
      if (R1 & 7 != 0) goto cbo1; else goto cbo4;
  cbo4:
      call (I64[R1])(R1) returns to cbo1, args: 8, res: 8, upd: 8;
  cbo1:
      if (R1 & 7 != 1) goto cbof; else goto cboa;
  cbof:
      I64[Sp - 16] = cbod;
      R2 = P64[Sp + 40];
      I64[Sp - 40] = stg_ap_pp_info;
      _saDO::P64 = P64[R1 + 6];
      P64[Sp - 32] = _saDO::P64;
      P64[Sp - 24] = P64[Sp + 56];
      P64[Sp - 8] = P64[R1 + 22];
      P64[Sp] = _saDO::P64;
      Sp = Sp - 40;
      call GHC.Classes.>_info(R2) returns to cbod, args: 32, res: 8, upd: 8;
  cbod:
      if (R1 & 7 != 1) goto cboA; else goto cbom;
  cboA:
      _saDi::I64 = I64[Sp + 64];
      _saDj::I64 = I64[Sp + 48];
      _saDk::I64 = I64[Sp + 40];
      _saDl::P64 = P64[Sp + 32];
      _saDh::I64 = I64[Sp + 24] - 1;
      goto cbn8;
  cbom:
      I64[Sp] = cboj;
      R2 = P64[Sp + 56];
      I64[Sp - 24] = stg_ap_pp_info;
      P64[Sp - 16] = P64[Sp + 16];
      P64[Sp - 8] = P64[Sp + 72];
      Sp = Sp - 24;
      call GHC.Classes.<_info(R2) returns to cboj, args: 32, res: 8, upd: 8;
  cboj:
      _saDn::I64 = I64[Sp + 24];
      if (R1 & 7 != 1) goto cbow; else goto cbos;
  cbow:
      goto uboV;
  uboV:
      _saDV::P64 = P64[Sp + 8];
      Sp = Sp + 48;
      _saDU::I64 = _saDn::I64;
      goto cbll;
  cbos:
      R6 = P64[Sp + 32];
      R5 = I64[Sp + 40];
      R4 = I64[Sp + 48];
      R3 = I64[Sp + 64];
      R2 = _saDn::I64;
      Sp = Sp + 80;
      call $s$wpoly_a_rawp_info(R6,
                                R5,
                                R4,
                                R3,
                                R2) args: 8, res: 0, upd: 8;
  cboa:
      goto uboW;
  uboW:
      _saDi::I64 = I64[Sp + 48];
      _saDj::I64 = I64[Sp + 32];
      _saDk::I64 = I64[Sp + 24];
      _saDl::P64 = P64[Sp + 16];
      _saDh::I64 = I64[Sp + 8] - 1;
      Sp = Sp - 16;
      goto cbn8;
  cbnQ:
      Hp = Hp - 32;
      R3 = _saDy::I64;
      R2 = _saDk::I64;
      Sp = Sp + 80;
      call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
  cbny:
      I64[Hp - 24] = GHC.Types.I#_con_info;
      I64[Hp - 16] = _saDj::I64;
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _saDi::I64;
      R4 = Hp - 23;
      R3 = Hp - 7;
      R2 = _saDh::I64;
      Sp = Sp + 80;
      call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbno:
      I64[Hp - 24] = GHC.Types.I#_con_info;
      I64[Hp - 16] = _saDj::I64;
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _saDi::I64;
      R4 = Hp - 23;
      R3 = Hp - 7;
      R2 = _saDh::I64;
      Sp = Sp + 80;
      call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cboG:
      Hp = Hp - 32;
      R1 = GHC.Types.False_closure+1;
      Sp = Sp + 80;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
  cbmh:
      R3 = _saEd::I64;
      R2 = _saE1::I64;
      Sp = Sp + 64;
      call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
  cblY:
      R4 = _saE5::P64;
      R3 = _saE3::P64;
      R2 = _saDX::I64;
      Sp = Sp + 64;
      call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbn5:
      R1 = GHC.Types.False_closure+1;
      Sp = Sp + 32;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:46.358259 UTC

[(cbl6,
  {lvl20_rawe_closure, lvl29_rawn_closure, $s$wpoly_a_rawp_closure}),
 (cbl8,
  {lvl20_rawe_closure, lvl29_rawn_closure, $s$wpoly_a_rawp_closure}),
 (cbl9,
  {lvl20_rawe_closure, lvl29_rawn_closure, $s$wpoly_a_rawp_closure}),
 (cblb,
  {SkipList.$wa2_closure, lvl20_rawe_closure, lvl29_rawn_closure,
   $s$wpoly_a_rawp_closure}),
 (cblc, {SkipList.$wa2_closure}),
 (cbld,
  {SkipList.$wa2_closure, lvl20_rawe_closure, lvl29_rawn_closure,
   $s$wpoly_a_rawp_closure}),
 (cble,
  {lvl20_rawe_closure, lvl29_rawn_closure, $s$wpoly_a_rawp_closure}),
 (cbll,
  {lvl20_rawe_closure, lvl29_rawn_closure, $s$wpoly_a_rawp_closure}),
 (cblm,
  {lvl20_rawe_closure, lvl29_rawn_closure, $s$wpoly_a_rawp_closure}),
 (cblo,
  {lvl20_rawe_closure, lvl29_rawn_closure, $s$wpoly_a_rawp_closure}),
 (cblr,
  {lvl20_rawe_closure, lvl29_rawn_closure, $s$wpoly_a_rawp_closure}),
 (cbls,
  {lvl20_rawe_closure, lvl29_rawn_closure, $s$wpoly_a_rawp_closure}),
 (cblw,
  {lvl20_rawe_closure, lvl29_rawn_closure, $s$wpoly_a_rawp_closure}),
 (cblx,
  {lvl20_rawe_closure, lvl29_rawn_closure, $s$wpoly_a_rawp_closure}),
 (cblB,
  {lvl20_rawe_closure, lvl29_rawn_closure, $s$wpoly_a_rawp_closure}),
 (cblD,
  {lvl20_rawe_closure, lvl29_rawn_closure, $s$wpoly_a_rawp_closure}),
 (cblG,
  {lvl20_rawe_closure, lvl29_rawn_closure, $s$wpoly_a_rawp_closure}),
 (cblY, {lvl20_rawe_closure}), (cbmh, {lvl29_rawn_closure}),
 (cbmk,
  {lvl20_rawe_closure, lvl29_rawn_closure, $s$wpoly_a_rawp_closure}),
 (cbml,
  {lvl20_rawe_closure, lvl29_rawn_closure, $s$wpoly_a_rawp_closure}),
 (cbmm,
  {lvl20_rawe_closure, lvl29_rawn_closure, $s$wpoly_a_rawp_closure}),
 (cbmq,
  {lvl20_rawe_closure, lvl29_rawn_closure, $s$wpoly_a_rawp_closure}),
 (cbms,
  {lvl20_rawe_closure, lvl29_rawn_closure, $s$wpoly_a_rawp_closure}),
 (cbmv,
  {lvl20_rawe_closure, lvl29_rawn_closure, $s$wpoly_a_rawp_closure}),
 (cbmB,
  {lvl20_rawe_closure, lvl29_rawn_closure, $s$wpoly_a_rawp_closure}),
 (cbmE,
  {lvl20_rawe_closure, lvl29_rawn_closure, $s$wpoly_a_rawp_closure}),
 (cbmG,
  {lvl20_rawe_closure, lvl29_rawn_closure, $s$wpoly_a_rawp_closure}),
 (cbmK,
  {lvl20_rawe_closure, lvl29_rawn_closure, $s$wpoly_a_rawp_closure}),
 (cbmN,
  {lvl20_rawe_closure, lvl29_rawn_closure, $s$wpoly_a_rawp_closure}),
 (cbmT, {$s$wpoly_a_rawp_closure}),
 (cbmX,
  {lvl20_rawe_closure, lvl29_rawn_closure, $s$wpoly_a_rawp_closure}),
 (cbn1,
  {lvl20_rawe_closure, lvl29_rawn_closure, $s$wpoly_a_rawp_closure}),
 (cbn2,
  {lvl20_rawe_closure, lvl29_rawn_closure, $s$wpoly_a_rawp_closure}),
 (cbn3,
  {lvl20_rawe_closure, lvl29_rawn_closure, $s$wpoly_a_rawp_closure}),
 (cbn4,
  {lvl20_rawe_closure, lvl29_rawn_closure, $s$wpoly_a_rawp_closure}),
 (cbn5, {}),
 (cbn6,
  {lvl20_rawe_closure, lvl29_rawn_closure, $s$wpoly_a_rawp_closure}),
 (cbn8,
  {lvl20_rawe_closure, lvl29_rawn_closure, $s$wpoly_a_rawp_closure}),
 (cbn9,
  {lvl20_rawe_closure, lvl29_rawn_closure, $s$wpoly_a_rawp_closure}),
 (cbnc,
  {lvl20_rawe_closure, lvl29_rawn_closure, $s$wpoly_a_rawp_closure}),
 (cbnd,
  {lvl20_rawe_closure, lvl29_rawn_closure, $s$wpoly_a_rawp_closure}),
 (cbno, {lvl20_rawe_closure}), (cbny, {lvl20_rawe_closure}),
 (cbnQ, {lvl29_rawn_closure}),
 (cbnT,
  {lvl20_rawe_closure, lvl29_rawn_closure, $s$wpoly_a_rawp_closure}),
 (cbnU,
  {lvl20_rawe_closure, lvl29_rawn_closure, $s$wpoly_a_rawp_closure}),
 (cbnV,
  {lvl20_rawe_closure, lvl29_rawn_closure, $s$wpoly_a_rawp_closure}),
 (cbnZ,
  {lvl20_rawe_closure, lvl29_rawn_closure, $s$wpoly_a_rawp_closure}),
 (cbo1,
  {lvl20_rawe_closure, lvl29_rawn_closure, $s$wpoly_a_rawp_closure}),
 (cbo4,
  {lvl20_rawe_closure, lvl29_rawn_closure, $s$wpoly_a_rawp_closure}),
 (cboa,
  {lvl20_rawe_closure, lvl29_rawn_closure, $s$wpoly_a_rawp_closure}),
 (cbod,
  {lvl20_rawe_closure, lvl29_rawn_closure, $s$wpoly_a_rawp_closure}),
 (cbof,
  {lvl20_rawe_closure, lvl29_rawn_closure, $s$wpoly_a_rawp_closure}),
 (cboj,
  {lvl20_rawe_closure, lvl29_rawn_closure, $s$wpoly_a_rawp_closure}),
 (cbom,
  {lvl20_rawe_closure, lvl29_rawn_closure, $s$wpoly_a_rawp_closure}),
 (cbos, {$s$wpoly_a_rawp_closure}),
 (cbow,
  {lvl20_rawe_closure, lvl29_rawn_closure, $s$wpoly_a_rawp_closure}),
 (cboA,
  {lvl20_rawe_closure, lvl29_rawn_closure, $s$wpoly_a_rawp_closure}),
 (cboB,
  {lvl20_rawe_closure, lvl29_rawn_closure, $s$wpoly_a_rawp_closure}),
 (cboC,
  {lvl20_rawe_closure, lvl29_rawn_closure, $s$wpoly_a_rawp_closure}),
 (cboD,
  {lvl20_rawe_closure, lvl29_rawn_closure, $s$wpoly_a_rawp_closure}),
 (cboF,
  {lvl20_rawe_closure, lvl29_rawn_closure, $s$wpoly_a_rawp_closure}),
 (cboG, {}),
 (uboR,
  {lvl20_rawe_closure, lvl29_rawn_closure, $s$wpoly_a_rawp_closure}),
 (uboS,
  {lvl20_rawe_closure, lvl29_rawn_closure, $s$wpoly_a_rawp_closure}),
 (uboT,
  {lvl20_rawe_closure, lvl29_rawn_closure, $s$wpoly_a_rawp_closure}),
 (uboU,
  {lvl20_rawe_closure, lvl29_rawn_closure, $s$wpoly_a_rawp_closure}),
 (uboV,
  {lvl20_rawe_closure, lvl29_rawn_closure, $s$wpoly_a_rawp_closure}),
 (uboW,
  {lvl20_rawe_closure, lvl29_rawn_closure, $s$wpoly_a_rawp_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:46.367352 UTC

SkipList.$wa2_entry() //  [R5, R4, R3, R2]
        { info_tbl: [(cbl6,
                      label: block_cbl6_info
                      rep:StackRep [False, False, False]),
                     (cbl8,
                      label: block_cbl8_info
                      rep:StackRep [False, False, False]),
                     (cblb,
                      label: SkipList.$wa2_info
                      rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} }),
                     (cblm,
                      label: block_cblm_info
                      rep:StackRep [False, False, True, False]),
                     (cblr,
                      label: block_cblr_info
                      rep:StackRep [False, True, False]),
                     (cblw,
                      label: block_cblw_info
                      rep:StackRep [True, False, False, False, True, False]),
                     (cblB,
                      label: block_cblB_info
                      rep:StackRep [True, True, False, False, False, True, False]),
                     (cbmk,
                      label: block_cbmk_info
                      rep:StackRep [True, True, False, True, False, True, False]),
                     (cbmq,
                      label: block_cbmq_info
                      rep:StackRep [True, True, False, True, False, True, False]),
                     (cbms,
                      label: block_cbms_info
                      rep:StackRep [True, True, False, True, False, True, False]),
                     (cbmE,
                      label: block_cbmE_info
                      rep:StackRep [False, False, True, True, False, True, False, True,
                                    False]),
                     (cbmK,
                      label: block_cbmK_info
                      rep:StackRep [False, True, True, True, False, True, False, True,
                                    False]),
                     (cbn9,
                      label: block_cbn9_info
                      rep:StackRep [False, True, True, True, False, True, False]),
                     (cbnT,
                      label: block_cbnT_info
                      rep:StackRep [True, False, True, True, False, True, False]),
                     (cbnZ,
                      label: block_cbnZ_info
                      rep:StackRep [True, False, True, True, False, True, False]),
                     (cbo1,
                      label: block_cbo1_info
                      rep:StackRep [True, False, True, True, False, True, False]),
                     (cbod,
                      label: block_cbod_info
                      rep:StackRep [False, False, True, False, True, True, False, True,
                                    False]),
                     (cboj,
                      label: block_cboj_info
                      rep:StackRep [False, True, True, False, True, True, False, True,
                                    False])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cblb:
          _saD8::P64 = R5;
          _saD7::P64 = R4;
          _saD6::P64 = R3;
          _saD5::P64 = R2;
          if ((Sp + -104) < SpLim) goto cblc; else goto cbld;
      cbld:
          if (HpLim == 0) goto cblc; else goto cble;
      cblc:
          R5 = _saD8::P64;
          R4 = _saD7::P64;
          R3 = _saD6::P64;
          R2 = _saD5::P64;
          R1 = SkipList.$wa2_closure;
          call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
      cble:
          I64[Sp - 32] = cbl6;
          R1 = _saD7::P64;
          P64[Sp - 24] = _saD5::P64;
          P64[Sp - 16] = _saD6::P64;
          P64[Sp - 8] = _saD8::P64;
          Sp = Sp - 32;
          call stg_norec_readTVar#(R1) returns to cbl6, args: 8, res: 8, upd: 8;
      cbl6:
          I64[Sp] = cbl8;
          R1 = R1;
          if (R1 & 7 != 0) goto cbl8; else goto cbl9;
      cbl9:
          call (I64[R1])(R1) returns to cbl8, args: 8, res: 8, upd: 8;
      cbl8:
          _saDV::P64 = P64[Sp + 16];
          _saDU::I64 = I64[R1 + 7];
          goto cbll;
      cbll:
          if (HpLim == 0) goto cblo; else goto cbn6;
      cblo:
          I64[Sp - 8] = cblm;
          P64[Sp] = _saDV::P64;
          I64[Sp + 16] = _saDU::I64;
          Sp = Sp - 8;
          call stg_gc_noregs() returns to cblm, args: 8, res: 8, upd: 8;
      cblm:
          goto uboR;
      uboR:
          _saDU::I64 = I64[Sp + 24];
          _saDV::P64 = P64[Sp + 8];
          Sp = Sp + 8;
          goto cbll;
      cbn6:
          if (_saDU::I64 != 0) goto cblD; else goto cbn5;
      cblD:
          I64[Sp] = cblr;
          R1 = _saDV::P64;
          I64[Sp + 16] = _saDU::I64;
          if (R1 & 7 != 0) goto cblr; else goto cbls;
      cbls:
          call (I64[R1])(R1) returns to cblr, args: 8, res: 8, upd: 8;
      cblr:
          I64[Sp - 24] = cblw;
          _saE0::P64 = P64[R1 + 15];
          _saE2::P64 = P64[R1 + 23];
          _saE1::I64 = I64[R1 + 31];
          R1 = P64[R1 + 7];
          I64[Sp - 16] = _saE1::I64;
          P64[Sp - 8] = _saE2::P64;
          P64[Sp] = _saE0::P64;
          Sp = Sp - 24;
          if (R1 & 7 != 0) goto cblw; else goto cblx;
      cblx:
          call (I64[R1])(R1) returns to cblw, args: 8, res: 8, upd: 8;
      cblw:
          I64[Sp - 8] = cblB;
          _saE3::P64 = R1;
          _saE4::I64 = I64[R1 + 7];
          R1 = P64[Sp + 24];
          I64[Sp] = _saE4::I64;
          P64[Sp + 24] = _saE3::P64;
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto cblB; else goto cblG;
      cblG:
          call (I64[R1])(R1) returns to cblB, args: 8, res: 8, upd: 8;
      cblB:
          _saDX::I64 = I64[Sp + 48];
          _saE3::P64 = P64[Sp + 32];
          _saE4::I64 = I64[Sp + 8];
          _saE5::P64 = R1;
          if (%MO_S_Le_W64(_saE4::I64,
                           _saDX::I64)) goto cbn4; else goto cblY;
      cbn4:
          _saE6::I64 = I64[R1 + 7];
          if (%MO_S_Le_W64(_saDX::I64,
                           _saE6::I64)) goto cbn3; else goto cblY;
      cbn3:
          _saE1::I64 = I64[Sp + 16];
          _saEd::I64 = _saDX::I64 - _saE4::I64;
          if (%MO_S_Le_W64(0, _saEd::I64)) goto cbn2; else goto cbmh;
      cbn2:
          if (%MO_S_Lt_W64(_saEd::I64,
                           _saE1::I64)) goto cbml; else goto cbmh;
      cbml:
          _saEl::P64 = P64[P64[Sp + 24] + ((_saEd::I64 << 3) + 24)];
          I64[Sp] = cbmk;
          R1 = _saEl::P64;
          I64[Sp + 32] = _saE6::I64;
          if (R1 & 7 != 0) goto cbmk; else goto cbmm;
      cbmm:
          call (I64[R1])(R1) returns to cbmk, args: 8, res: 8, upd: 8;
      cbmk:
          I64[Sp] = cbmq;
          R1 = P64[R1 + 7];
          call stg_norec_readTVar#(R1) returns to cbmq, args: 8, res: 8, upd: 8;
      cbmq:
          I64[Sp] = cbms;
          R1 = R1;
          if (R1 & 7 != 0) goto cbms; else goto cbmv;
      cbmv:
          call (I64[R1])(R1) returns to cbms, args: 8, res: 8, upd: 8;
      cbms:
          if (R1 & 7 != 1) goto cbmG; else goto cbmB;
      cbmG:
          I64[Sp - 16] = cbmE;
          R2 = P64[Sp + 40];
          I64[Sp - 40] = stg_ap_pp_info;
          _saEt::P64 = P64[R1 + 6];
          P64[Sp - 32] = _saEt::P64;
          P64[Sp - 24] = P64[Sp + 56];
          P64[Sp - 8] = P64[R1 + 22];
          P64[Sp] = _saEt::P64;
          Sp = Sp - 40;
          call GHC.Classes.>_info(R2) returns to cbmE, args: 32, res: 8, upd: 8;
      cbmE:
          if (R1 & 7 != 1) goto cbn1; else goto cbmN;
      cbn1:
          _saDl::P64 = P64[Sp + 40];
          _saDk::I64 = I64[Sp + 32];
          _saDj::I64 = I64[Sp + 48];
          _saDi::I64 = I64[Sp + 24];
          _saDh::I64 = I64[Sp + 64] - 1;
          goto cbn8;
      cbmN:
          I64[Sp] = cbmK;
          R2 = P64[Sp + 56];
          I64[Sp - 24] = stg_ap_pp_info;
          P64[Sp - 16] = P64[Sp + 16];
          P64[Sp - 8] = P64[Sp + 72];
          Sp = Sp - 24;
          call GHC.Classes.<_info(R2) returns to cbmK, args: 32, res: 8, upd: 8;
      cbmK:
          _saDX::I64 = I64[Sp + 64];
          if (R1 & 7 != 1) goto cbmX; else goto cbmT;
      cbmX:
          goto uboS;
      uboS:
          _saDV::P64 = P64[Sp + 8];
          Sp = Sp + 48;
          _saDU::I64 = _saDX::I64;
          goto cbll;
      cbmT:
          R6 = P64[Sp + 40];
          R5 = I64[Sp + 32];
          R4 = I64[Sp + 48];
          R3 = I64[Sp + 24];
          R2 = _saDX::I64;
          Sp = Sp + 80;
          call $s$wpoly_a_rawp_info(R6,
                                    R5,
                                    R4,
                                    R3,
                                    R2) args: 8, res: 0, upd: 8;
      cbmB:
          goto uboT;
      uboT:
          _saDl::P64 = P64[Sp + 24];
          _saDk::I64 = I64[Sp + 16];
          _saDj::I64 = I64[Sp + 32];
          _saDi::I64 = I64[Sp + 8];
          _saDh::I64 = I64[Sp + 48] - 1;
          Sp = Sp - 16;
          goto cbn8;
      cbn8:
          Hp = Hp + 32;
          if (Hp > HpLim) goto cbnd; else goto cbnc;
      cbnd:
          HpAlloc = 32;
          I64[Sp + 16] = cbn9;
          P64[Sp + 24] = _saDl::P64;
          I64[Sp + 32] = _saDk::I64;
          I64[Sp + 40] = _saDj::I64;
          I64[Sp + 48] = _saDi::I64;
          I64[Sp + 64] = _saDh::I64;
          Sp = Sp + 16;
          call stg_gc_noregs() returns to cbn9, args: 8, res: 8, upd: 8;
      cbn9:
          goto uboU;
      uboU:
          _saDh::I64 = I64[Sp + 48];
          _saDi::I64 = I64[Sp + 32];
          _saDj::I64 = I64[Sp + 24];
          _saDk::I64 = I64[Sp + 16];
          _saDl::P64 = P64[Sp + 8];
          Sp = Sp - 16;
          goto cbn8;
      cbnc:
          if (_saDh::I64 != 0) goto cboF; else goto cboG;
      cboF:
          if (%MO_S_Le_W64(_saDi::I64,
                           _saDh::I64)) goto cboD; else goto cbno;
      cboD:
          if (%MO_S_Le_W64(_saDh::I64,
                           _saDj::I64)) goto cboC; else goto cbny;
      cboC:
          _saDy::I64 = _saDh::I64 - _saDi::I64;
          if (%MO_S_Le_W64(0, _saDy::I64)) goto cboB; else goto cbnQ;
      cboB:
          if (%MO_S_Lt_W64(_saDy::I64,
                           _saDk::I64)) goto cbnU; else goto cbnQ;
      cbnU:
          Hp = Hp - 32;
          _saDG::P64 = P64[(_saDl::P64 + 24) + (_saDy::I64 << 3)];
          I64[Sp + 16] = cbnT;
          R1 = _saDG::P64;
          I64[Sp + 24] = _saDh::I64;
          P64[Sp + 32] = _saDl::P64;
          I64[Sp + 40] = _saDk::I64;
          I64[Sp + 48] = _saDj::I64;
          I64[Sp + 64] = _saDi::I64;
          Sp = Sp + 16;
          if (R1 & 7 != 0) goto cbnT; else goto cbnV;
      cbnV:
          call (I64[R1])(R1) returns to cbnT, args: 8, res: 8, upd: 8;
      cbnT:
          I64[Sp] = cbnZ;
          R1 = P64[R1 + 7];
          call stg_norec_readTVar#(R1) returns to cbnZ, args: 8, res: 8, upd: 8;
      cbnZ:
          I64[Sp] = cbo1;
          R1 = R1;
          if (R1 & 7 != 0) goto cbo1; else goto cbo4;
      cbo4:
          call (I64[R1])(R1) returns to cbo1, args: 8, res: 8, upd: 8;
      cbo1:
          if (R1 & 7 != 1) goto cbof; else goto cboa;
      cbof:
          I64[Sp - 16] = cbod;
          R2 = P64[Sp + 40];
          I64[Sp - 40] = stg_ap_pp_info;
          _saDO::P64 = P64[R1 + 6];
          P64[Sp - 32] = _saDO::P64;
          P64[Sp - 24] = P64[Sp + 56];
          P64[Sp - 8] = P64[R1 + 22];
          P64[Sp] = _saDO::P64;
          Sp = Sp - 40;
          call GHC.Classes.>_info(R2) returns to cbod, args: 32, res: 8, upd: 8;
      cbod:
          if (R1 & 7 != 1) goto cboA; else goto cbom;
      cboA:
          _saDi::I64 = I64[Sp + 64];
          _saDj::I64 = I64[Sp + 48];
          _saDk::I64 = I64[Sp + 40];
          _saDl::P64 = P64[Sp + 32];
          _saDh::I64 = I64[Sp + 24] - 1;
          goto cbn8;
      cbom:
          I64[Sp] = cboj;
          R2 = P64[Sp + 56];
          I64[Sp - 24] = stg_ap_pp_info;
          P64[Sp - 16] = P64[Sp + 16];
          P64[Sp - 8] = P64[Sp + 72];
          Sp = Sp - 24;
          call GHC.Classes.<_info(R2) returns to cboj, args: 32, res: 8, upd: 8;
      cboj:
          _saDn::I64 = I64[Sp + 24];
          if (R1 & 7 != 1) goto cbow; else goto cbos;
      cbow:
          goto uboV;
      uboV:
          _saDV::P64 = P64[Sp + 8];
          Sp = Sp + 48;
          _saDU::I64 = _saDn::I64;
          goto cbll;
      cbos:
          R6 = P64[Sp + 32];
          R5 = I64[Sp + 40];
          R4 = I64[Sp + 48];
          R3 = I64[Sp + 64];
          R2 = _saDn::I64;
          Sp = Sp + 80;
          call $s$wpoly_a_rawp_info(R6,
                                    R5,
                                    R4,
                                    R3,
                                    R2) args: 8, res: 0, upd: 8;
      cboa:
          goto uboW;
      uboW:
          _saDi::I64 = I64[Sp + 48];
          _saDj::I64 = I64[Sp + 32];
          _saDk::I64 = I64[Sp + 24];
          _saDl::P64 = P64[Sp + 16];
          _saDh::I64 = I64[Sp + 8] - 1;
          Sp = Sp - 16;
          goto cbn8;
      cbnQ:
          Hp = Hp - 32;
          R3 = _saDy::I64;
          R2 = _saDk::I64;
          Sp = Sp + 80;
          call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
      cbny:
          I64[Hp - 24] = GHC.Types.I#_con_info;
          I64[Hp - 16] = _saDj::I64;
          I64[Hp - 8] = GHC.Types.I#_con_info;
          I64[Hp] = _saDi::I64;
          R4 = Hp - 23;
          R3 = Hp - 7;
          R2 = _saDh::I64;
          Sp = Sp + 80;
          call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
      cbno:
          I64[Hp - 24] = GHC.Types.I#_con_info;
          I64[Hp - 16] = _saDj::I64;
          I64[Hp - 8] = GHC.Types.I#_con_info;
          I64[Hp] = _saDi::I64;
          R4 = Hp - 23;
          R3 = Hp - 7;
          R2 = _saDh::I64;
          Sp = Sp + 80;
          call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
      cboG:
          Hp = Hp - 32;
          R1 = GHC.Types.False_closure+1;
          Sp = Sp + 80;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
      cbmh:
          R3 = _saEd::I64;
          R2 = _saE1::I64;
          Sp = Sp + 64;
          call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
      cblY:
          R4 = _saE5::P64;
          R3 = _saE3::P64;
          R2 = _saDX::I64;
          Sp = Sp + 64;
          call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
      cbn5:
          R1 = GHC.Types.False_closure+1;
          Sp = Sp + 32;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:46.386516 UTC

SkipList.$wa2_entry() //  [R5, R4, R3, R2]
        { info_tbl: [(cbl6,
                      label: block_cbl6_info
                      rep:StackRep [False, False, False]),
                     (cbl8,
                      label: block_cbl8_info
                      rep:StackRep [False, False, False]),
                     (cblb,
                      label: SkipList.$wa2_info
                      rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} }),
                     (cblm,
                      label: block_cblm_info
                      rep:StackRep [False, False, True, False]),
                     (cblr,
                      label: block_cblr_info
                      rep:StackRep [False, True, False]),
                     (cblw,
                      label: block_cblw_info
                      rep:StackRep [True, False, False, False, True, False]),
                     (cblB,
                      label: block_cblB_info
                      rep:StackRep [True, True, False, False, False, True, False]),
                     (cbmk,
                      label: block_cbmk_info
                      rep:StackRep [True, True, False, True, False, True, False]),
                     (cbmq,
                      label: block_cbmq_info
                      rep:StackRep [True, True, False, True, False, True, False]),
                     (cbms,
                      label: block_cbms_info
                      rep:StackRep [True, True, False, True, False, True, False]),
                     (cbmE,
                      label: block_cbmE_info
                      rep:StackRep [False, False, True, True, False, True, False, True,
                                    False]),
                     (cbmK,
                      label: block_cbmK_info
                      rep:StackRep [False, True, True, True, False, True, False, True,
                                    False]),
                     (cbn9,
                      label: block_cbn9_info
                      rep:StackRep [False, True, True, True, False, True, False]),
                     (cbnT,
                      label: block_cbnT_info
                      rep:StackRep [True, False, True, True, False, True, False]),
                     (cbnZ,
                      label: block_cbnZ_info
                      rep:StackRep [True, False, True, True, False, True, False]),
                     (cbo1,
                      label: block_cbo1_info
                      rep:StackRep [True, False, True, True, False, True, False]),
                     (cbod,
                      label: block_cbod_info
                      rep:StackRep [False, False, True, False, True, True, False, True,
                                    False]),
                     (cboj,
                      label: block_cboj_info
                      rep:StackRep [False, True, True, False, True, True, False, True,
                                    False])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cblb:
          _saD8::P64 = R5;
          _saD7::P64 = R4;
          _saD6::P64 = R3;
          _saD5::P64 = R2;
          if ((Sp + -104) < SpLim) goto cblc; else goto cbld;
      cbld:
          if (HpLim == 0) goto cblc; else goto cble;
      cblc:
          R5 = _saD8::P64;
          R4 = _saD7::P64;
          R3 = _saD6::P64;
          R2 = _saD5::P64;
          R1 = SkipList.$wa2_closure;
          call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
      cble:
          I64[Sp - 32] = cbl6;
          R1 = _saD7::P64;
          P64[Sp - 24] = _saD5::P64;
          P64[Sp - 16] = _saD6::P64;
          P64[Sp - 8] = _saD8::P64;
          Sp = Sp - 32;
          call stg_norec_readTVar#(R1) returns to cbl6, args: 8, res: 8, upd: 8;
      cbl6:
          I64[Sp] = cbl8;
          R1 = R1;
          if (R1 & 7 != 0) goto cbl8; else goto cbl9;
      cbl9:
          call (I64[R1])(R1) returns to cbl8, args: 8, res: 8, upd: 8;
      cbl8:
          _saDV::P64 = P64[Sp + 16];
          _saDU::I64 = I64[R1 + 7];
          goto cbll;
      cbll:
          if (HpLim == 0) goto cblo; else goto cbn6;
      cblo:
          I64[Sp - 8] = cblm;
          P64[Sp] = _saDV::P64;
          I64[Sp + 16] = _saDU::I64;
          Sp = Sp - 8;
          call stg_gc_noregs() returns to cblm, args: 8, res: 8, upd: 8;
      cblm:
          _saDU::I64 = I64[Sp + 24];
          _saDV::P64 = P64[Sp + 8];
          Sp = Sp + 8;
          goto cbll;
      cbn6:
          if (_saDU::I64 != 0) goto cblD; else goto cbn5;
      cblD:
          I64[Sp] = cblr;
          R1 = _saDV::P64;
          I64[Sp + 16] = _saDU::I64;
          if (R1 & 7 != 0) goto cblr; else goto cbls;
      cbls:
          call (I64[R1])(R1) returns to cblr, args: 8, res: 8, upd: 8;
      cblr:
          I64[Sp - 24] = cblw;
          _saE0::P64 = P64[R1 + 15];
          _saE2::P64 = P64[R1 + 23];
          _saE1::I64 = I64[R1 + 31];
          R1 = P64[R1 + 7];
          I64[Sp - 16] = _saE1::I64;
          P64[Sp - 8] = _saE2::P64;
          P64[Sp] = _saE0::P64;
          Sp = Sp - 24;
          if (R1 & 7 != 0) goto cblw; else goto cblx;
      cblx:
          call (I64[R1])(R1) returns to cblw, args: 8, res: 8, upd: 8;
      cblw:
          I64[Sp - 8] = cblB;
          _saE3::P64 = R1;
          _saE4::I64 = I64[R1 + 7];
          R1 = P64[Sp + 24];
          I64[Sp] = _saE4::I64;
          P64[Sp + 24] = _saE3::P64;
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto cblB; else goto cblG;
      cblG:
          call (I64[R1])(R1) returns to cblB, args: 8, res: 8, upd: 8;
      cblB:
          _saDX::I64 = I64[Sp + 48];
          _saE3::P64 = P64[Sp + 32];
          _saE4::I64 = I64[Sp + 8];
          _saE5::P64 = R1;
          if (%MO_S_Gt_W64(_saE4::I64,
                           _saDX::I64)) goto cblY; else goto cbn4;
      cbn4:
          _saE6::I64 = I64[R1 + 7];
          if (%MO_S_Gt_W64(_saDX::I64,
                           _saE6::I64)) goto cblY; else goto cbn3;
      cblY:
          R4 = _saE5::P64;
          R3 = _saE3::P64;
          R2 = _saDX::I64;
          Sp = Sp + 64;
          call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
      cbn3:
          _saE1::I64 = I64[Sp + 16];
          _saEd::I64 = _saDX::I64 - _saE4::I64;
          if (%MO_S_Gt_W64(0, _saEd::I64)) goto cbmh; else goto cbn2;
      cbn2:
          if (%MO_S_Ge_W64(_saEd::I64,
                           _saE1::I64)) goto cbmh; else goto cbml;
      cbmh:
          R3 = _saEd::I64;
          R2 = _saE1::I64;
          Sp = Sp + 64;
          call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
      cbml:
          _saEl::P64 = P64[P64[Sp + 24] + ((_saEd::I64 << 3) + 24)];
          I64[Sp] = cbmk;
          R1 = _saEl::P64;
          I64[Sp + 32] = _saE6::I64;
          if (R1 & 7 != 0) goto cbmk; else goto cbmm;
      cbmm:
          call (I64[R1])(R1) returns to cbmk, args: 8, res: 8, upd: 8;
      cbmk:
          I64[Sp] = cbmq;
          R1 = P64[R1 + 7];
          call stg_norec_readTVar#(R1) returns to cbmq, args: 8, res: 8, upd: 8;
      cbmq:
          I64[Sp] = cbms;
          R1 = R1;
          if (R1 & 7 != 0) goto cbms; else goto cbmv;
      cbmv:
          call (I64[R1])(R1) returns to cbms, args: 8, res: 8, upd: 8;
      cbms:
          if (R1 & 7 != 1) goto cbmG; else goto cbmB;
      cbmG:
          I64[Sp - 16] = cbmE;
          R2 = P64[Sp + 40];
          I64[Sp - 40] = stg_ap_pp_info;
          _saEt::P64 = P64[R1 + 6];
          P64[Sp - 32] = _saEt::P64;
          P64[Sp - 24] = P64[Sp + 56];
          P64[Sp - 8] = P64[R1 + 22];
          P64[Sp] = _saEt::P64;
          Sp = Sp - 40;
          call GHC.Classes.>_info(R2) returns to cbmE, args: 32, res: 8, upd: 8;
      cbmE:
          if (R1 & 7 != 1) goto cbn1; else goto cbmN;
      cbn1:
          _saDl::P64 = P64[Sp + 40];
          _saDk::I64 = I64[Sp + 32];
          _saDj::I64 = I64[Sp + 48];
          _saDi::I64 = I64[Sp + 24];
          _saDh::I64 = I64[Sp + 64] - 1;
          goto cbn8;
      cbmN:
          I64[Sp] = cbmK;
          R2 = P64[Sp + 56];
          I64[Sp - 24] = stg_ap_pp_info;
          P64[Sp - 16] = P64[Sp + 16];
          P64[Sp - 8] = P64[Sp + 72];
          Sp = Sp - 24;
          call GHC.Classes.<_info(R2) returns to cbmK, args: 32, res: 8, upd: 8;
      cbmK:
          _saDX::I64 = I64[Sp + 64];
          if (R1 & 7 != 1) goto cbmX; else goto cbmT;
      cbmX:
          _saDV::P64 = P64[Sp + 8];
          Sp = Sp + 48;
          _saDU::I64 = _saDX::I64;
          goto cbll;
      cbmT:
          R6 = P64[Sp + 40];
          R5 = I64[Sp + 32];
          R4 = I64[Sp + 48];
          R3 = I64[Sp + 24];
          R2 = _saDX::I64;
          Sp = Sp + 80;
          call $s$wpoly_a_rawp_info(R6,
                                    R5,
                                    R4,
                                    R3,
                                    R2) args: 8, res: 0, upd: 8;
      cbmB:
          _saDl::P64 = P64[Sp + 24];
          _saDk::I64 = I64[Sp + 16];
          _saDj::I64 = I64[Sp + 32];
          _saDi::I64 = I64[Sp + 8];
          _saDh::I64 = I64[Sp + 48] - 1;
          Sp = Sp - 16;
          goto cbn8;
      cbn8:
          Hp = Hp + 32;
          if (Hp > HpLim) goto cbnd; else goto cbnc;
      cbnd:
          HpAlloc = 32;
          I64[Sp + 16] = cbn9;
          P64[Sp + 24] = _saDl::P64;
          I64[Sp + 32] = _saDk::I64;
          I64[Sp + 40] = _saDj::I64;
          I64[Sp + 48] = _saDi::I64;
          I64[Sp + 64] = _saDh::I64;
          Sp = Sp + 16;
          call stg_gc_noregs() returns to cbn9, args: 8, res: 8, upd: 8;
      cbn9:
          _saDh::I64 = I64[Sp + 48];
          _saDi::I64 = I64[Sp + 32];
          _saDj::I64 = I64[Sp + 24];
          _saDk::I64 = I64[Sp + 16];
          _saDl::P64 = P64[Sp + 8];
          Sp = Sp - 16;
          goto cbn8;
      cbnc:
          if (_saDh::I64 != 0) goto cboF; else goto cboG;
      cboF:
          if (%MO_S_Le_W64(_saDi::I64,
                           _saDh::I64)) goto cboD; else goto cbno;
      cboD:
          if (%MO_S_Le_W64(_saDh::I64,
                           _saDj::I64)) goto cboC; else goto cbny;
      cboC:
          _saDy::I64 = _saDh::I64 - _saDi::I64;
          if (%MO_S_Gt_W64(0, _saDy::I64)) goto cbnQ; else goto cboB;
      cboB:
          if (%MO_S_Ge_W64(_saDy::I64,
                           _saDk::I64)) goto cbnQ; else goto cbnU;
      cbnQ:
          Hp = Hp - 32;
          R3 = _saDy::I64;
          R2 = _saDk::I64;
          Sp = Sp + 80;
          call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
      cbnU:
          Hp = Hp - 32;
          _saDG::P64 = P64[(_saDl::P64 + 24) + (_saDy::I64 << 3)];
          I64[Sp + 16] = cbnT;
          R1 = _saDG::P64;
          I64[Sp + 24] = _saDh::I64;
          P64[Sp + 32] = _saDl::P64;
          I64[Sp + 40] = _saDk::I64;
          I64[Sp + 48] = _saDj::I64;
          I64[Sp + 64] = _saDi::I64;
          Sp = Sp + 16;
          if (R1 & 7 != 0) goto cbnT; else goto cbnV;
      cbnV:
          call (I64[R1])(R1) returns to cbnT, args: 8, res: 8, upd: 8;
      cbnT:
          I64[Sp] = cbnZ;
          R1 = P64[R1 + 7];
          call stg_norec_readTVar#(R1) returns to cbnZ, args: 8, res: 8, upd: 8;
      cbnZ:
          I64[Sp] = cbo1;
          R1 = R1;
          if (R1 & 7 != 0) goto cbo1; else goto cbo4;
      cbo4:
          call (I64[R1])(R1) returns to cbo1, args: 8, res: 8, upd: 8;
      cbo1:
          if (R1 & 7 != 1) goto cbof; else goto cboa;
      cbof:
          I64[Sp - 16] = cbod;
          R2 = P64[Sp + 40];
          I64[Sp - 40] = stg_ap_pp_info;
          _saDO::P64 = P64[R1 + 6];
          P64[Sp - 32] = _saDO::P64;
          P64[Sp - 24] = P64[Sp + 56];
          P64[Sp - 8] = P64[R1 + 22];
          P64[Sp] = _saDO::P64;
          Sp = Sp - 40;
          call GHC.Classes.>_info(R2) returns to cbod, args: 32, res: 8, upd: 8;
      cbod:
          if (R1 & 7 != 1) goto cboA; else goto cbom;
      cboA:
          _saDi::I64 = I64[Sp + 64];
          _saDj::I64 = I64[Sp + 48];
          _saDk::I64 = I64[Sp + 40];
          _saDl::P64 = P64[Sp + 32];
          _saDh::I64 = I64[Sp + 24] - 1;
          goto cbn8;
      cbom:
          I64[Sp] = cboj;
          R2 = P64[Sp + 56];
          I64[Sp - 24] = stg_ap_pp_info;
          P64[Sp - 16] = P64[Sp + 16];
          P64[Sp - 8] = P64[Sp + 72];
          Sp = Sp - 24;
          call GHC.Classes.<_info(R2) returns to cboj, args: 32, res: 8, upd: 8;
      cboj:
          _saDn::I64 = I64[Sp + 24];
          if (R1 & 7 != 1) goto cbow; else goto cbos;
      cbow:
          _saDV::P64 = P64[Sp + 8];
          Sp = Sp + 48;
          _saDU::I64 = _saDn::I64;
          goto cbll;
      cbos:
          R6 = P64[Sp + 32];
          R5 = I64[Sp + 40];
          R4 = I64[Sp + 48];
          R3 = I64[Sp + 64];
          R2 = _saDn::I64;
          Sp = Sp + 80;
          call $s$wpoly_a_rawp_info(R6,
                                    R5,
                                    R4,
                                    R3,
                                    R2) args: 8, res: 0, upd: 8;
      cboa:
          _saDi::I64 = I64[Sp + 48];
          _saDj::I64 = I64[Sp + 32];
          _saDk::I64 = I64[Sp + 24];
          _saDl::P64 = P64[Sp + 16];
          _saDh::I64 = I64[Sp + 8] - 1;
          Sp = Sp - 16;
          goto cbn8;
      cbny:
          I64[Hp - 24] = GHC.Types.I#_con_info;
          I64[Hp - 16] = _saDj::I64;
          I64[Hp - 8] = GHC.Types.I#_con_info;
          I64[Hp] = _saDi::I64;
          R4 = Hp - 23;
          R3 = Hp - 7;
          R2 = _saDh::I64;
          Sp = Sp + 80;
          call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
      cbno:
          I64[Hp - 24] = GHC.Types.I#_con_info;
          I64[Hp - 16] = _saDj::I64;
          I64[Hp - 8] = GHC.Types.I#_con_info;
          I64[Hp] = _saDi::I64;
          R4 = Hp - 23;
          R3 = Hp - 7;
          R2 = _saDh::I64;
          Sp = Sp + 80;
          call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
      cboG:
          Hp = Hp - 32;
          R1 = GHC.Types.False_closure+1;
          Sp = Sp + 80;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
      cbn5:
          R1 = GHC.Types.False_closure+1;
          Sp = Sp + 32;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:46.405628 UTC

[section "data" {
     SkipList.$wa2_closure:
         const SkipList.$wa2_info;
         const 0;
 },
 SkipList.$wa2_entry() //  [R5, R4, R3, R2]
         { info_tbl: [(cbl6,
                       label: block_cbl6_info
                       rep:StackRep [False, False, False]),
                      (cbl8,
                       label: block_cbl8_info
                       rep:StackRep [False, False, False]),
                      (cblb,
                       label: SkipList.$wa2_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} }),
                      (cblm,
                       label: block_cblm_info
                       rep:StackRep [False, False, True, False]),
                      (cblr,
                       label: block_cblr_info
                       rep:StackRep [False, True, False]),
                      (cblw,
                       label: block_cblw_info
                       rep:StackRep [True, False, False, False, True, False]),
                      (cblB,
                       label: block_cblB_info
                       rep:StackRep [True, True, False, False, False, True, False]),
                      (cbmk,
                       label: block_cbmk_info
                       rep:StackRep [True, True, False, True, False, True, False]),
                      (cbmq,
                       label: block_cbmq_info
                       rep:StackRep [True, True, False, True, False, True, False]),
                      (cbms,
                       label: block_cbms_info
                       rep:StackRep [True, True, False, True, False, True, False]),
                      (cbmE,
                       label: block_cbmE_info
                       rep:StackRep [False, False, True, True, False, True, False, True,
                                     False]),
                      (cbmK,
                       label: block_cbmK_info
                       rep:StackRep [False, True, True, True, False, True, False, True,
                                     False]),
                      (cbn9,
                       label: block_cbn9_info
                       rep:StackRep [False, True, True, True, False, True, False]),
                      (cbnT,
                       label: block_cbnT_info
                       rep:StackRep [True, False, True, True, False, True, False]),
                      (cbnZ,
                       label: block_cbnZ_info
                       rep:StackRep [True, False, True, True, False, True, False]),
                      (cbo1,
                       label: block_cbo1_info
                       rep:StackRep [True, False, True, True, False, True, False]),
                      (cbod,
                       label: block_cbod_info
                       rep:StackRep [False, False, True, False, True, True, False, True,
                                     False]),
                      (cboj,
                       label: block_cboj_info
                       rep:StackRep [False, True, True, False, True, True, False, True,
                                     False])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cblb:
           _saD8::P64 = R5;
           _saD7::P64 = R4;
           _saD6::P64 = R3;
           _saD5::P64 = R2;
           if ((Sp + -104) < SpLim) goto cblc; else goto cbld;
       cbld:
           if (HpLim == 0) goto cblc; else goto cble;
       cblc:
           R5 = _saD8::P64;
           R4 = _saD7::P64;
           R3 = _saD6::P64;
           R2 = _saD5::P64;
           R1 = SkipList.$wa2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cble:
           I64[Sp - 32] = cbl6;
           R1 = _saD7::P64;
           P64[Sp - 24] = _saD5::P64;
           P64[Sp - 16] = _saD6::P64;
           P64[Sp - 8] = _saD8::P64;
           Sp = Sp - 32;
           call stg_norec_readTVar#(R1) returns to cbl6, args: 8, res: 8, upd: 8;
       cbl6:
           I64[Sp] = cbl8;
           R1 = R1;
           if (R1 & 7 != 0) goto cbl8; else goto cbl9;
       cbl9:
           call (I64[R1])(R1) returns to cbl8, args: 8, res: 8, upd: 8;
       cbl8:
           _saDV::P64 = P64[Sp + 16];
           _saDU::I64 = I64[R1 + 7];
           goto cbll;
       cbll:
           if (HpLim == 0) goto cblo; else goto cbn6;
       cblo:
           I64[Sp - 8] = cblm;
           P64[Sp] = _saDV::P64;
           I64[Sp + 16] = _saDU::I64;
           Sp = Sp - 8;
           call stg_gc_noregs() returns to cblm, args: 8, res: 8, upd: 8;
       cblm:
           _saDU::I64 = I64[Sp + 24];
           _saDV::P64 = P64[Sp + 8];
           Sp = Sp + 8;
           goto cbll;
       cbn6:
           if (_saDU::I64 != 0) goto cblD; else goto cbn5;
       cblD:
           I64[Sp] = cblr;
           R1 = _saDV::P64;
           I64[Sp + 16] = _saDU::I64;
           if (R1 & 7 != 0) goto cblr; else goto cbls;
       cbls:
           call (I64[R1])(R1) returns to cblr, args: 8, res: 8, upd: 8;
       cblr:
           I64[Sp - 24] = cblw;
           _saE0::P64 = P64[R1 + 15];
           _saE2::P64 = P64[R1 + 23];
           _saE1::I64 = I64[R1 + 31];
           R1 = P64[R1 + 7];
           I64[Sp - 16] = _saE1::I64;
           P64[Sp - 8] = _saE2::P64;
           P64[Sp] = _saE0::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto cblw; else goto cblx;
       cblx:
           call (I64[R1])(R1) returns to cblw, args: 8, res: 8, upd: 8;
       cblw:
           I64[Sp - 8] = cblB;
           _saE3::P64 = R1;
           _saE4::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp] = _saE4::I64;
           P64[Sp + 24] = _saE3::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto cblB; else goto cblG;
       cblG:
           call (I64[R1])(R1) returns to cblB, args: 8, res: 8, upd: 8;
       cblB:
           _saDX::I64 = I64[Sp + 48];
           _saE3::P64 = P64[Sp + 32];
           _saE4::I64 = I64[Sp + 8];
           _saE5::P64 = R1;
           if (%MO_S_Gt_W64(_saE4::I64,
                            _saDX::I64)) goto cblY; else goto cbn4;
       cbn4:
           _saE6::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(_saDX::I64,
                            _saE6::I64)) goto cblY; else goto cbn3;
       cblY:
           R4 = _saE5::P64;
           R3 = _saE3::P64;
           R2 = _saDX::I64;
           Sp = Sp + 64;
           call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
       cbn3:
           _saE1::I64 = I64[Sp + 16];
           _saEd::I64 = _saDX::I64 - _saE4::I64;
           if (%MO_S_Gt_W64(0, _saEd::I64)) goto cbmh; else goto cbn2;
       cbn2:
           if (%MO_S_Ge_W64(_saEd::I64,
                            _saE1::I64)) goto cbmh; else goto cbml;
       cbmh:
           R3 = _saEd::I64;
           R2 = _saE1::I64;
           Sp = Sp + 64;
           call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
       cbml:
           _saEl::P64 = P64[P64[Sp + 24] + ((_saEd::I64 << 3) + 24)];
           I64[Sp] = cbmk;
           R1 = _saEl::P64;
           I64[Sp + 32] = _saE6::I64;
           if (R1 & 7 != 0) goto cbmk; else goto cbmm;
       cbmm:
           call (I64[R1])(R1) returns to cbmk, args: 8, res: 8, upd: 8;
       cbmk:
           I64[Sp] = cbmq;
           R1 = P64[R1 + 7];
           call stg_norec_readTVar#(R1) returns to cbmq, args: 8, res: 8, upd: 8;
       cbmq:
           I64[Sp] = cbms;
           R1 = R1;
           if (R1 & 7 != 0) goto cbms; else goto cbmv;
       cbmv:
           call (I64[R1])(R1) returns to cbms, args: 8, res: 8, upd: 8;
       cbms:
           if (R1 & 7 != 1) goto cbmG; else goto cbmB;
       cbmG:
           I64[Sp - 16] = cbmE;
           R2 = P64[Sp + 40];
           I64[Sp - 40] = stg_ap_pp_info;
           _saEt::P64 = P64[R1 + 6];
           P64[Sp - 32] = _saEt::P64;
           P64[Sp - 24] = P64[Sp + 56];
           P64[Sp - 8] = P64[R1 + 22];
           P64[Sp] = _saEt::P64;
           Sp = Sp - 40;
           call GHC.Classes.>_info(R2) returns to cbmE, args: 32, res: 8, upd: 8;
       cbmE:
           if (R1 & 7 != 1) goto cbn1; else goto cbmN;
       cbn1:
           _saDl::P64 = P64[Sp + 40];
           _saDk::I64 = I64[Sp + 32];
           _saDj::I64 = I64[Sp + 48];
           _saDi::I64 = I64[Sp + 24];
           _saDh::I64 = I64[Sp + 64] - 1;
           goto cbn8;
       cbmN:
           I64[Sp] = cbmK;
           R2 = P64[Sp + 56];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 16];
           P64[Sp - 8] = P64[Sp + 72];
           Sp = Sp - 24;
           call GHC.Classes.<_info(R2) returns to cbmK, args: 32, res: 8, upd: 8;
       cbmK:
           _saDX::I64 = I64[Sp + 64];
           if (R1 & 7 != 1) goto cbmX; else goto cbmT;
       cbmX:
           _saDV::P64 = P64[Sp + 8];
           Sp = Sp + 48;
           _saDU::I64 = _saDX::I64;
           goto cbll;
       cbmT:
           R6 = P64[Sp + 40];
           R5 = I64[Sp + 32];
           R4 = I64[Sp + 48];
           R3 = I64[Sp + 24];
           R2 = _saDX::I64;
           Sp = Sp + 80;
           call $s$wpoly_a_rawp_info(R6,
                                     R5,
                                     R4,
                                     R3,
                                     R2) args: 8, res: 0, upd: 8;
       cbmB:
           _saDl::P64 = P64[Sp + 24];
           _saDk::I64 = I64[Sp + 16];
           _saDj::I64 = I64[Sp + 32];
           _saDi::I64 = I64[Sp + 8];
           _saDh::I64 = I64[Sp + 48] - 1;
           Sp = Sp - 16;
           goto cbn8;
       cbn8:
           Hp = Hp + 32;
           if (Hp > HpLim) goto cbnd; else goto cbnc;
       cbnd:
           HpAlloc = 32;
           I64[Sp + 16] = cbn9;
           P64[Sp + 24] = _saDl::P64;
           I64[Sp + 32] = _saDk::I64;
           I64[Sp + 40] = _saDj::I64;
           I64[Sp + 48] = _saDi::I64;
           I64[Sp + 64] = _saDh::I64;
           Sp = Sp + 16;
           call stg_gc_noregs() returns to cbn9, args: 8, res: 8, upd: 8;
       cbn9:
           _saDh::I64 = I64[Sp + 48];
           _saDi::I64 = I64[Sp + 32];
           _saDj::I64 = I64[Sp + 24];
           _saDk::I64 = I64[Sp + 16];
           _saDl::P64 = P64[Sp + 8];
           Sp = Sp - 16;
           goto cbn8;
       cbnc:
           if (_saDh::I64 != 0) goto cboF; else goto cboG;
       cboF:
           if (%MO_S_Le_W64(_saDi::I64,
                            _saDh::I64)) goto cboD; else goto cbno;
       cboD:
           if (%MO_S_Le_W64(_saDh::I64,
                            _saDj::I64)) goto cboC; else goto cbny;
       cboC:
           _saDy::I64 = _saDh::I64 - _saDi::I64;
           if (%MO_S_Gt_W64(0, _saDy::I64)) goto cbnQ; else goto cboB;
       cboB:
           if (%MO_S_Ge_W64(_saDy::I64,
                            _saDk::I64)) goto cbnQ; else goto cbnU;
       cbnQ:
           Hp = Hp - 32;
           R3 = _saDy::I64;
           R2 = _saDk::I64;
           Sp = Sp + 80;
           call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
       cbnU:
           Hp = Hp - 32;
           _saDG::P64 = P64[(_saDl::P64 + 24) + (_saDy::I64 << 3)];
           I64[Sp + 16] = cbnT;
           R1 = _saDG::P64;
           I64[Sp + 24] = _saDh::I64;
           P64[Sp + 32] = _saDl::P64;
           I64[Sp + 40] = _saDk::I64;
           I64[Sp + 48] = _saDj::I64;
           I64[Sp + 64] = _saDi::I64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto cbnT; else goto cbnV;
       cbnV:
           call (I64[R1])(R1) returns to cbnT, args: 8, res: 8, upd: 8;
       cbnT:
           I64[Sp] = cbnZ;
           R1 = P64[R1 + 7];
           call stg_norec_readTVar#(R1) returns to cbnZ, args: 8, res: 8, upd: 8;
       cbnZ:
           I64[Sp] = cbo1;
           R1 = R1;
           if (R1 & 7 != 0) goto cbo1; else goto cbo4;
       cbo4:
           call (I64[R1])(R1) returns to cbo1, args: 8, res: 8, upd: 8;
       cbo1:
           if (R1 & 7 != 1) goto cbof; else goto cboa;
       cbof:
           I64[Sp - 16] = cbod;
           R2 = P64[Sp + 40];
           I64[Sp - 40] = stg_ap_pp_info;
           _saDO::P64 = P64[R1 + 6];
           P64[Sp - 32] = _saDO::P64;
           P64[Sp - 24] = P64[Sp + 56];
           P64[Sp - 8] = P64[R1 + 22];
           P64[Sp] = _saDO::P64;
           Sp = Sp - 40;
           call GHC.Classes.>_info(R2) returns to cbod, args: 32, res: 8, upd: 8;
       cbod:
           if (R1 & 7 != 1) goto cboA; else goto cbom;
       cboA:
           _saDi::I64 = I64[Sp + 64];
           _saDj::I64 = I64[Sp + 48];
           _saDk::I64 = I64[Sp + 40];
           _saDl::P64 = P64[Sp + 32];
           _saDh::I64 = I64[Sp + 24] - 1;
           goto cbn8;
       cbom:
           I64[Sp] = cboj;
           R2 = P64[Sp + 56];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 16];
           P64[Sp - 8] = P64[Sp + 72];
           Sp = Sp - 24;
           call GHC.Classes.<_info(R2) returns to cboj, args: 32, res: 8, upd: 8;
       cboj:
           _saDn::I64 = I64[Sp + 24];
           if (R1 & 7 != 1) goto cbow; else goto cbos;
       cbow:
           _saDV::P64 = P64[Sp + 8];
           Sp = Sp + 48;
           _saDU::I64 = _saDn::I64;
           goto cbll;
       cbos:
           R6 = P64[Sp + 32];
           R5 = I64[Sp + 40];
           R4 = I64[Sp + 48];
           R3 = I64[Sp + 64];
           R2 = _saDn::I64;
           Sp = Sp + 80;
           call $s$wpoly_a_rawp_info(R6,
                                     R5,
                                     R4,
                                     R3,
                                     R2) args: 8, res: 0, upd: 8;
       cboa:
           _saDi::I64 = I64[Sp + 48];
           _saDj::I64 = I64[Sp + 32];
           _saDk::I64 = I64[Sp + 24];
           _saDl::P64 = P64[Sp + 16];
           _saDh::I64 = I64[Sp + 8] - 1;
           Sp = Sp - 16;
           goto cbn8;
       cbny:
           I64[Hp - 24] = GHC.Types.I#_con_info;
           I64[Hp - 16] = _saDj::I64;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saDi::I64;
           R4 = Hp - 23;
           R3 = Hp - 7;
           R2 = _saDh::I64;
           Sp = Sp + 80;
           call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
       cbno:
           I64[Hp - 24] = GHC.Types.I#_con_info;
           I64[Hp - 16] = _saDj::I64;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saDi::I64;
           R4 = Hp - 23;
           R3 = Hp - 7;
           R2 = _saDh::I64;
           Sp = Sp + 80;
           call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
       cboG:
           Hp = Hp - 32;
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 80;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
       cbn5:
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 32;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:46.426625 UTC

[section "data" {
     SkipList.$wa2_closure:
         const SkipList.$wa2_info;
         const 0;
 },
 SkipList.$wa2_entry() //  [R5, R4, R3, R2]
         { info_tbl: [(cbl6,
                       label: block_cbl6_info
                       rep:StackRep [False, False, False]),
                      (cbl8,
                       label: block_cbl8_info
                       rep:StackRep [False, False, False]),
                      (cblb,
                       label: SkipList.$wa2_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} }),
                      (cblm,
                       label: block_cblm_info
                       rep:StackRep [False, False, True, False]),
                      (cblr,
                       label: block_cblr_info
                       rep:StackRep [False, True, False]),
                      (cblw,
                       label: block_cblw_info
                       rep:StackRep [True, False, False, False, True, False]),
                      (cblB,
                       label: block_cblB_info
                       rep:StackRep [True, True, False, False, False, True, False]),
                      (cbmk,
                       label: block_cbmk_info
                       rep:StackRep [True, True, False, True, False, True, False]),
                      (cbmq,
                       label: block_cbmq_info
                       rep:StackRep [True, True, False, True, False, True, False]),
                      (cbms,
                       label: block_cbms_info
                       rep:StackRep [True, True, False, True, False, True, False]),
                      (cbmE,
                       label: block_cbmE_info
                       rep:StackRep [False, False, True, True, False, True, False, True,
                                     False]),
                      (cbmK,
                       label: block_cbmK_info
                       rep:StackRep [False, True, True, True, False, True, False, True,
                                     False]),
                      (cbn9,
                       label: block_cbn9_info
                       rep:StackRep [False, True, True, True, False, True, False]),
                      (cbnT,
                       label: block_cbnT_info
                       rep:StackRep [True, False, True, True, False, True, False]),
                      (cbnZ,
                       label: block_cbnZ_info
                       rep:StackRep [True, False, True, True, False, True, False]),
                      (cbo1,
                       label: block_cbo1_info
                       rep:StackRep [True, False, True, True, False, True, False]),
                      (cbod,
                       label: block_cbod_info
                       rep:StackRep [False, False, True, False, True, True, False, True,
                                     False]),
                      (cboj,
                       label: block_cboj_info
                       rep:StackRep [False, True, True, False, True, True, False, True,
                                     False])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cblb:
           _saD8::P64 = R5;
           _saD7::P64 = R4;
           _saD6::P64 = R3;
           _saD5::P64 = R2;
           if ((Sp + -104) < SpLim) goto cblc; else goto cbld;
       cbld:
           if (HpLim == 0) goto cblc; else goto cble;
       cblc:
           R5 = _saD8::P64;
           R4 = _saD7::P64;
           R3 = _saD6::P64;
           R2 = _saD5::P64;
           R1 = SkipList.$wa2_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cble:
           I64[Sp - 32] = cbl6;
           R1 = _saD7::P64;
           P64[Sp - 24] = _saD5::P64;
           P64[Sp - 16] = _saD6::P64;
           P64[Sp - 8] = _saD8::P64;
           Sp = Sp - 32;
           call stg_norec_readTVar#(R1) returns to cbl6, args: 8, res: 8, upd: 8;
       cbl6:
           I64[Sp] = cbl8;
           R1 = R1;
           if (R1 & 7 != 0) goto cbl8; else goto cbl9;
       cbl9:
           call (I64[R1])(R1) returns to cbl8, args: 8, res: 8, upd: 8;
       cbl8:
           _saDV::P64 = P64[Sp + 16];
           _saDU::I64 = I64[R1 + 7];
           goto cbll;
       cbll:
           if (HpLim == 0) goto cblo; else goto cbn6;
       cblo:
           I64[Sp - 8] = cblm;
           P64[Sp] = _saDV::P64;
           I64[Sp + 16] = _saDU::I64;
           Sp = Sp - 8;
           call stg_gc_noregs() returns to cblm, args: 8, res: 8, upd: 8;
       cblm:
           _saDU::I64 = I64[Sp + 24];
           _saDV::P64 = P64[Sp + 8];
           Sp = Sp + 8;
           goto cbll;
       cbn6:
           if (_saDU::I64 != 0) goto cblD; else goto cbn5;
       cblD:
           I64[Sp] = cblr;
           R1 = _saDV::P64;
           I64[Sp + 16] = _saDU::I64;
           if (R1 & 7 != 0) goto cblr; else goto cbls;
       cbls:
           call (I64[R1])(R1) returns to cblr, args: 8, res: 8, upd: 8;
       cblr:
           I64[Sp - 24] = cblw;
           _saE0::P64 = P64[R1 + 15];
           _saE2::P64 = P64[R1 + 23];
           _saE1::I64 = I64[R1 + 31];
           R1 = P64[R1 + 7];
           I64[Sp - 16] = _saE1::I64;
           P64[Sp - 8] = _saE2::P64;
           P64[Sp] = _saE0::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto cblw; else goto cblx;
       cblx:
           call (I64[R1])(R1) returns to cblw, args: 8, res: 8, upd: 8;
       cblw:
           I64[Sp - 8] = cblB;
           _saE3::P64 = R1;
           _saE4::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp] = _saE4::I64;
           P64[Sp + 24] = _saE3::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto cblB; else goto cblG;
       cblG:
           call (I64[R1])(R1) returns to cblB, args: 8, res: 8, upd: 8;
       cblB:
           _saDX::I64 = I64[Sp + 48];
           _saE3::P64 = P64[Sp + 32];
           _saE4::I64 = I64[Sp + 8];
           _saE5::P64 = R1;
           if (%MO_S_Gt_W64(_saE4::I64,
                            _saDX::I64)) goto cblY; else goto cbn4;
       cbn4:
           _saE6::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(_saDX::I64,
                            _saE6::I64)) goto cblY; else goto cbn3;
       cblY:
           R4 = _saE5::P64;
           R3 = _saE3::P64;
           R2 = _saDX::I64;
           Sp = Sp + 64;
           call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
       cbn3:
           _saE1::I64 = I64[Sp + 16];
           _saEd::I64 = _saDX::I64 - _saE4::I64;
           if (%MO_S_Gt_W64(0, _saEd::I64)) goto cbmh; else goto cbn2;
       cbn2:
           if (%MO_S_Ge_W64(_saEd::I64,
                            _saE1::I64)) goto cbmh; else goto cbml;
       cbmh:
           R3 = _saEd::I64;
           R2 = _saE1::I64;
           Sp = Sp + 64;
           call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
       cbml:
           _saEl::P64 = P64[P64[Sp + 24] + ((_saEd::I64 << 3) + 24)];
           I64[Sp] = cbmk;
           R1 = _saEl::P64;
           I64[Sp + 32] = _saE6::I64;
           if (R1 & 7 != 0) goto cbmk; else goto cbmm;
       cbmm:
           call (I64[R1])(R1) returns to cbmk, args: 8, res: 8, upd: 8;
       cbmk:
           I64[Sp] = cbmq;
           R1 = P64[R1 + 7];
           call stg_norec_readTVar#(R1) returns to cbmq, args: 8, res: 8, upd: 8;
       cbmq:
           I64[Sp] = cbms;
           R1 = R1;
           if (R1 & 7 != 0) goto cbms; else goto cbmv;
       cbmv:
           call (I64[R1])(R1) returns to cbms, args: 8, res: 8, upd: 8;
       cbms:
           if (R1 & 7 != 1) goto cbmG; else goto cbmB;
       cbmG:
           I64[Sp - 16] = cbmE;
           R2 = P64[Sp + 40];
           I64[Sp - 40] = stg_ap_pp_info;
           _saEt::P64 = P64[R1 + 6];
           P64[Sp - 32] = _saEt::P64;
           P64[Sp - 24] = P64[Sp + 56];
           P64[Sp - 8] = P64[R1 + 22];
           P64[Sp] = _saEt::P64;
           Sp = Sp - 40;
           call GHC.Classes.>_info(R2) returns to cbmE, args: 32, res: 8, upd: 8;
       cbmE:
           if (R1 & 7 != 1) goto cbn1; else goto cbmN;
       cbn1:
           _saDl::P64 = P64[Sp + 40];
           _saDk::I64 = I64[Sp + 32];
           _saDj::I64 = I64[Sp + 48];
           _saDi::I64 = I64[Sp + 24];
           _saDh::I64 = I64[Sp + 64] - 1;
           goto cbn8;
       cbmN:
           I64[Sp] = cbmK;
           R2 = P64[Sp + 56];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 16];
           P64[Sp - 8] = P64[Sp + 72];
           Sp = Sp - 24;
           call GHC.Classes.<_info(R2) returns to cbmK, args: 32, res: 8, upd: 8;
       cbmK:
           _saDX::I64 = I64[Sp + 64];
           if (R1 & 7 != 1) goto cbmX; else goto cbmT;
       cbmX:
           _saDV::P64 = P64[Sp + 8];
           Sp = Sp + 48;
           _saDU::I64 = _saDX::I64;
           goto cbll;
       cbmT:
           R6 = P64[Sp + 40];
           R5 = I64[Sp + 32];
           R4 = I64[Sp + 48];
           R3 = I64[Sp + 24];
           R2 = _saDX::I64;
           Sp = Sp + 80;
           call $s$wpoly_a_rawp_info(R6,
                                     R5,
                                     R4,
                                     R3,
                                     R2) args: 8, res: 0, upd: 8;
       cbmB:
           _saDl::P64 = P64[Sp + 24];
           _saDk::I64 = I64[Sp + 16];
           _saDj::I64 = I64[Sp + 32];
           _saDi::I64 = I64[Sp + 8];
           _saDh::I64 = I64[Sp + 48] - 1;
           Sp = Sp - 16;
           goto cbn8;
       cbn8:
           Hp = Hp + 32;
           if (Hp > HpLim) goto cbnd; else goto cbnc;
       cbnd:
           HpAlloc = 32;
           I64[Sp + 16] = cbn9;
           P64[Sp + 24] = _saDl::P64;
           I64[Sp + 32] = _saDk::I64;
           I64[Sp + 40] = _saDj::I64;
           I64[Sp + 48] = _saDi::I64;
           I64[Sp + 64] = _saDh::I64;
           Sp = Sp + 16;
           call stg_gc_noregs() returns to cbn9, args: 8, res: 8, upd: 8;
       cbn9:
           _saDh::I64 = I64[Sp + 48];
           _saDi::I64 = I64[Sp + 32];
           _saDj::I64 = I64[Sp + 24];
           _saDk::I64 = I64[Sp + 16];
           _saDl::P64 = P64[Sp + 8];
           Sp = Sp - 16;
           goto cbn8;
       cbnc:
           if (_saDh::I64 != 0) goto cboF; else goto cboG;
       cboF:
           if (%MO_S_Le_W64(_saDi::I64,
                            _saDh::I64)) goto cboD; else goto cbno;
       cboD:
           if (%MO_S_Le_W64(_saDh::I64,
                            _saDj::I64)) goto cboC; else goto cbny;
       cboC:
           _saDy::I64 = _saDh::I64 - _saDi::I64;
           if (%MO_S_Gt_W64(0, _saDy::I64)) goto cbnQ; else goto cboB;
       cboB:
           if (%MO_S_Ge_W64(_saDy::I64,
                            _saDk::I64)) goto cbnQ; else goto cbnU;
       cbnQ:
           Hp = Hp - 32;
           R3 = _saDy::I64;
           R2 = _saDk::I64;
           Sp = Sp + 80;
           call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
       cbnU:
           Hp = Hp - 32;
           _saDG::P64 = P64[(_saDl::P64 + 24) + (_saDy::I64 << 3)];
           I64[Sp + 16] = cbnT;
           R1 = _saDG::P64;
           I64[Sp + 24] = _saDh::I64;
           P64[Sp + 32] = _saDl::P64;
           I64[Sp + 40] = _saDk::I64;
           I64[Sp + 48] = _saDj::I64;
           I64[Sp + 64] = _saDi::I64;
           Sp = Sp + 16;
           if (R1 & 7 != 0) goto cbnT; else goto cbnV;
       cbnV:
           call (I64[R1])(R1) returns to cbnT, args: 8, res: 8, upd: 8;
       cbnT:
           I64[Sp] = cbnZ;
           R1 = P64[R1 + 7];
           call stg_norec_readTVar#(R1) returns to cbnZ, args: 8, res: 8, upd: 8;
       cbnZ:
           I64[Sp] = cbo1;
           R1 = R1;
           if (R1 & 7 != 0) goto cbo1; else goto cbo4;
       cbo4:
           call (I64[R1])(R1) returns to cbo1, args: 8, res: 8, upd: 8;
       cbo1:
           if (R1 & 7 != 1) goto cbof; else goto cboa;
       cbof:
           I64[Sp - 16] = cbod;
           R2 = P64[Sp + 40];
           I64[Sp - 40] = stg_ap_pp_info;
           _saDO::P64 = P64[R1 + 6];
           P64[Sp - 32] = _saDO::P64;
           P64[Sp - 24] = P64[Sp + 56];
           P64[Sp - 8] = P64[R1 + 22];
           P64[Sp] = _saDO::P64;
           Sp = Sp - 40;
           call GHC.Classes.>_info(R2) returns to cbod, args: 32, res: 8, upd: 8;
       cbod:
           if (R1 & 7 != 1) goto cboA; else goto cbom;
       cboA:
           _saDi::I64 = I64[Sp + 64];
           _saDj::I64 = I64[Sp + 48];
           _saDk::I64 = I64[Sp + 40];
           _saDl::P64 = P64[Sp + 32];
           _saDh::I64 = I64[Sp + 24] - 1;
           goto cbn8;
       cbom:
           I64[Sp] = cboj;
           R2 = P64[Sp + 56];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[Sp + 16];
           P64[Sp - 8] = P64[Sp + 72];
           Sp = Sp - 24;
           call GHC.Classes.<_info(R2) returns to cboj, args: 32, res: 8, upd: 8;
       cboj:
           _saDn::I64 = I64[Sp + 24];
           if (R1 & 7 != 1) goto cbow; else goto cbos;
       cbow:
           _saDV::P64 = P64[Sp + 8];
           Sp = Sp + 48;
           _saDU::I64 = _saDn::I64;
           goto cbll;
       cbos:
           R6 = P64[Sp + 32];
           R5 = I64[Sp + 40];
           R4 = I64[Sp + 48];
           R3 = I64[Sp + 64];
           R2 = _saDn::I64;
           Sp = Sp + 80;
           call $s$wpoly_a_rawp_info(R6,
                                     R5,
                                     R4,
                                     R3,
                                     R2) args: 8, res: 0, upd: 8;
       cboa:
           _saDi::I64 = I64[Sp + 48];
           _saDj::I64 = I64[Sp + 32];
           _saDk::I64 = I64[Sp + 24];
           _saDl::P64 = P64[Sp + 16];
           _saDh::I64 = I64[Sp + 8] - 1;
           Sp = Sp - 16;
           goto cbn8;
       cbny:
           I64[Hp - 24] = GHC.Types.I#_con_info;
           I64[Hp - 16] = _saDj::I64;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saDi::I64;
           R4 = Hp - 23;
           R3 = Hp - 7;
           R2 = _saDh::I64;
           Sp = Sp + 80;
           call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
       cbno:
           I64[Hp - 24] = GHC.Types.I#_con_info;
           I64[Hp - 16] = _saDj::I64;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saDi::I64;
           R4 = Hp - 23;
           R3 = Hp - 7;
           R2 = _saDh::I64;
           Sp = Sp + 80;
           call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
       cboG:
           Hp = Hp - 32;
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 80;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
       cbn5:
           R1 = GHC.Types.False_closure+1;
           Sp = Sp + 32;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:46.475988 UTC

[section "data" {
     SkipList.delete1_closure:
         const SkipList.delete1_info;
         const 0;
 },
 SkipList.delete1_entry() //  [R4, R3, R2]
         { info_tbl: [(cbpM,
                       label: SkipList.delete1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbpM:
           _saEB::P64 = R4;
           _saEA::P64 = R3;
           _saEz::P64 = R2;
           goto cbpH;
       cbpH:
           if ((old + 0) - <highSp> < SpLim) goto cbpQ; else goto cbpR;
       cbpR:
           goto cbpG;
       cbpG:
           if (HpLim == 0) goto cbpQ; else goto cbpS;
       cbpQ:
           R4 = _saEB::P64;
           R3 = _saEA::P64;
           R2 = _saEz::P64;
           R1 = SkipList.delete1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbpS:
           I64[(young<cbpJ> + 8)] = cbpJ;
           R1 = _saEA::P64;
           if (R1 & 7 != 0) goto cbpJ; else goto cbpK;
       cbpK:
           call (I64[R1])(R1) returns to cbpJ, args: 8, res: 8, upd: 8;
       cbpJ:
           _saED::P64 = R1;
           _saEE::P64 = P64[_saED::P64 + 7];
           _saEF::P64 = P64[_saED::P64 + 15];
           _saEG::P64 = P64[_saED::P64 + 23];
           I64[(young<cbpP> + 8)] = cbpP;
           R1 = _saEF::P64;
           if (R1 & 7 != 0) goto cbpP; else goto cbpU;
       cbpU:
           call (I64[R1])(R1) returns to cbpP, args: 8, res: 8, upd: 8;
       cbpP:
           _saEH::P64 = R1;
           _saEI::P64 = P64[_saEH::P64 + 7];
           R5 = _saEB::P64;
           R4 = _saEI::P64;
           R3 = _saEE::P64;
           R2 = _saEz::P64;
           call SkipList.$wa2_info(R5, R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:46.479605 UTC

{offset
  cbpM:
      _saEB::P64 = R4;
      _saEA::P64 = R3;
      _saEz::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cbpQ; else goto cbpR;
  cbpR:
      if (HpLim == 0) goto cbpQ; else goto cbpS;
  cbpQ:
      R4 = _saEB::P64;
      R3 = _saEA::P64;
      R2 = _saEz::P64;
      R1 = SkipList.delete1_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  cbpS:
      I64[(young<cbpJ> + 8)] = cbpJ;
      R1 = _saEA::P64;
      if (R1 & 7 != 0) goto cbpJ; else goto cbpK;
  cbpK:
      call (I64[R1])(R1) returns to cbpJ, args: 8, res: 8, upd: 8;
  cbpJ:
      _saED::P64 = R1;
      _saEE::P64 = P64[_saED::P64 + 7];
      _saEF::P64 = P64[_saED::P64 + 15];
      _saEG::P64 = P64[_saED::P64 + 23];
      I64[(young<cbpP> + 8)] = cbpP;
      R1 = _saEF::P64;
      if (R1 & 7 != 0) goto cbpP; else goto cbpU;
  cbpU:
      call (I64[R1])(R1) returns to cbpP, args: 8, res: 8, upd: 8;
  cbpP:
      _saEH::P64 = R1;
      _saEI::P64 = P64[_saEH::P64 + 7];
      R5 = _saEB::P64;
      R4 = _saEI::P64;
      R3 = _saEE::P64;
      R2 = _saEz::P64;
      call SkipList.$wa2_info(R5, R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:46.481468 UTC

{offset
  cbpM:
      _saEB::P64 = R4;
      _saEA::P64 = R3;
      _saEz::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cbpQ; else goto cbpR;
  cbpR:
      if (HpLim == 0) goto cbpQ; else goto cbpS;
  cbpQ:
      R4 = _saEB::P64;
      R3 = _saEA::P64;
      R2 = _saEz::P64;
      R1 = SkipList.delete1_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  cbpS:
      I64[(young<cbpJ> + 8)] = cbpJ;
      R1 = _saEA::P64;
      if (R1 & 7 != 0) goto cbpJ; else goto cbpK;
  cbpK:
      call (I64[R1])(R1) returns to cbpJ, args: 8, res: 8, upd: 8;
  cbpJ:
      _saED::P64 = R1;
      _saEE::P64 = P64[_saED::P64 + 7];
      _saEF::P64 = P64[_saED::P64 + 15];
      _saEG::P64 = P64[_saED::P64 + 23];
      I64[(young<cbpP> + 8)] = cbpP;
      R1 = _saEF::P64;
      if (R1 & 7 != 0) goto cbpP; else goto cbpU;
  cbpU:
      call (I64[R1])(R1) returns to cbpP, args: 8, res: 8, upd: 8;
  cbpP:
      _saEH::P64 = R1;
      _saEI::P64 = P64[_saEH::P64 + 7];
      R5 = _saEB::P64;
      R4 = _saEI::P64;
      R3 = _saEE::P64;
      R2 = _saEz::P64;
      call SkipList.$wa2_info(R5, R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:46.483414 UTC

{offset
  cbpM:
      _saEB::P64 = R4;
      _saEA::P64 = R3;
      _saEz::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cbpQ; else goto cbpR;
  cbpR:
      if (HpLim == 0) goto cbpQ; else goto cbpS;
  cbpQ:
      R4 = _saEB::P64;
      R3 = _saEA::P64;
      R2 = _saEz::P64;
      R1 = SkipList.delete1_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  cbpS:
      I64[(young<cbpJ> + 8)] = cbpJ;
      R1 = _saEA::P64;
      if (R1 & 7 != 0) goto cbpJ; else goto cbpK;
  cbpK:
      call (I64[R1])(R1) returns to cbpJ, args: 8, res: 8, upd: 8;
  cbpJ:
      _saED::P64 = R1;
      _saEE::P64 = P64[_saED::P64 + 7];
      _saEF::P64 = P64[_saED::P64 + 15];
      _saEG::P64 = P64[_saED::P64 + 23];
      I64[(young<cbpP> + 8)] = cbpP;
      R1 = _saEF::P64;
      if (R1 & 7 != 0) goto cbpP; else goto cbpU;
  cbpU:
      call (I64[R1])(R1) returns to cbpP, args: 8, res: 8, upd: 8;
  cbpP:
      _saEH::P64 = R1;
      _saEI::P64 = P64[_saEH::P64 + 7];
      R5 = _saEB::P64;
      R4 = _saEI::P64;
      R3 = _saEE::P64;
      R2 = _saEz::P64;
      call SkipList.$wa2_info(R5, R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:46.486096 UTC

{offset
  cbpM:
      _saEB::P64 = R4;
      _saEA::P64 = R3;
      _saEz::P64 = R2;
      if ((Sp + 8) - 40 < SpLim) goto cbpQ; else goto cbpR;
  cbpR:
      if (HpLim == 0) goto cbpQ; else goto cbpS;
  cbpQ:
      R4 = _saEB::P64;
      R3 = _saEA::P64;
      R2 = _saEz::P64;
      R1 = SkipList.delete1_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  cbpS:
      I64[Sp - 24] = cbpJ;
      R1 = _saEA::P64;
      P64[Sp - 16] = _saEz::P64;
      P64[Sp - 8] = _saEB::P64;
      Sp = Sp - 24;
      if (R1 & 7 != 0) goto cbpJ; else goto cbpK;
  cbpK:
      call (I64[R1])(R1) returns to cbpJ, args: 8, res: 8, upd: 8;
  cbpJ:
      _saEz::P64 = P64[Sp + 8];
      _saEB::P64 = P64[Sp + 16];
      _saED::P64 = R1;
      _saEE::P64 = P64[_saED::P64 + 7];
      _saEF::P64 = P64[_saED::P64 + 15];
      _saEG::P64 = P64[_saED::P64 + 23];
      I64[Sp - 8] = cbpP;
      R1 = _saEF::P64;
      P64[Sp] = _saEE::P64;
      Sp = Sp - 8;
      if (R1 & 7 != 0) goto cbpP; else goto cbpU;
  cbpU:
      call (I64[R1])(R1) returns to cbpP, args: 8, res: 8, upd: 8;
  cbpP:
      _saEz::P64 = P64[Sp + 16];
      _saEB::P64 = P64[Sp + 24];
      _saEE::P64 = P64[Sp + 8];
      _saEH::P64 = R1;
      _saEI::P64 = P64[_saEH::P64 + 7];
      R5 = _saEB::P64;
      R4 = _saEI::P64;
      R3 = _saEE::P64;
      R2 = _saEz::P64;
      Sp = Sp + 32;
      call SkipList.$wa2_info(R5, R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:46.488526 UTC

{offset
  cbpM:
      _saEB::P64 = R4;
      _saEA::P64 = R3;
      _saEz::P64 = R2;
      if ((Sp + -32) < SpLim) goto cbpQ; else goto cbpR;
  cbpR:
      if (HpLim == 0) goto cbpQ; else goto cbpS;
  cbpQ:
      R4 = _saEB::P64;
      R3 = _saEA::P64;
      R2 = _saEz::P64;
      R1 = SkipList.delete1_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  cbpS:
      I64[Sp - 24] = cbpJ;
      R1 = _saEA::P64;
      P64[Sp - 16] = _saEz::P64;
      P64[Sp - 8] = _saEB::P64;
      Sp = Sp - 24;
      if (R1 & 7 != 0) goto cbpJ; else goto cbpK;
  cbpK:
      call (I64[R1])(R1) returns to cbpJ, args: 8, res: 8, upd: 8;
  cbpJ:
      I64[Sp - 8] = cbpP;
      _saEE::P64 = P64[R1 + 7];
      R1 = P64[R1 + 15];
      P64[Sp] = _saEE::P64;
      Sp = Sp - 8;
      if (R1 & 7 != 0) goto cbpP; else goto cbpU;
  cbpU:
      call (I64[R1])(R1) returns to cbpP, args: 8, res: 8, upd: 8;
  cbpP:
      R5 = P64[Sp + 24];
      R4 = P64[R1 + 7];
      R3 = P64[Sp + 8];
      R2 = P64[Sp + 16];
      Sp = Sp + 32;
      call SkipList.$wa2_info(R5, R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:46.490734 UTC

[(cbpJ, {SkipList.$wa2_closure}), (cbpK, {SkipList.$wa2_closure}),
 (cbpM, {SkipList.$wa2_closure, SkipList.delete1_closure}),
 (cbpP, {SkipList.$wa2_closure}),
 (cbpQ, {SkipList.delete1_closure}),
 (cbpR, {SkipList.$wa2_closure, SkipList.delete1_closure}),
 (cbpS, {SkipList.$wa2_closure}), (cbpU, {SkipList.$wa2_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:46.4915 UTC

SkipList.delete1_entry() //  [R4, R3, R2]
        { info_tbl: [(cbpJ,
                      label: block_cbpJ_info
                      rep:StackRep [False, False]),
                     (cbpM,
                      label: SkipList.delete1_info
                      rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} }),
                     (cbpP,
                      label: block_cbpP_info
                      rep:StackRep [False, False, False])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cbpM:
          _saEB::P64 = R4;
          _saEA::P64 = R3;
          _saEz::P64 = R2;
          if ((Sp + -32) < SpLim) goto cbpQ; else goto cbpR;
      cbpR:
          if (HpLim == 0) goto cbpQ; else goto cbpS;
      cbpQ:
          R4 = _saEB::P64;
          R3 = _saEA::P64;
          R2 = _saEz::P64;
          R1 = SkipList.delete1_closure;
          call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
      cbpS:
          I64[Sp - 24] = cbpJ;
          R1 = _saEA::P64;
          P64[Sp - 16] = _saEz::P64;
          P64[Sp - 8] = _saEB::P64;
          Sp = Sp - 24;
          if (R1 & 7 != 0) goto cbpJ; else goto cbpK;
      cbpK:
          call (I64[R1])(R1) returns to cbpJ, args: 8, res: 8, upd: 8;
      cbpJ:
          I64[Sp - 8] = cbpP;
          _saEE::P64 = P64[R1 + 7];
          R1 = P64[R1 + 15];
          P64[Sp] = _saEE::P64;
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto cbpP; else goto cbpU;
      cbpU:
          call (I64[R1])(R1) returns to cbpP, args: 8, res: 8, upd: 8;
      cbpP:
          R5 = P64[Sp + 24];
          R4 = P64[R1 + 7];
          R3 = P64[Sp + 8];
          R2 = P64[Sp + 16];
          Sp = Sp + 32;
          call SkipList.$wa2_info(R5, R4, R3, R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:46.49404 UTC

SkipList.delete1_entry() //  [R4, R3, R2]
        { info_tbl: [(cbpJ,
                      label: block_cbpJ_info
                      rep:StackRep [False, False]),
                     (cbpM,
                      label: SkipList.delete1_info
                      rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} }),
                     (cbpP,
                      label: block_cbpP_info
                      rep:StackRep [False, False, False])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cbpM:
          _saEB::P64 = R4;
          _saEA::P64 = R3;
          _saEz::P64 = R2;
          if ((Sp + -32) < SpLim) goto cbpQ; else goto cbpR;
      cbpR:
          if (HpLim == 0) goto cbpQ; else goto cbpS;
      cbpQ:
          R4 = _saEB::P64;
          R3 = _saEA::P64;
          R2 = _saEz::P64;
          R1 = SkipList.delete1_closure;
          call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
      cbpS:
          I64[Sp - 24] = cbpJ;
          R1 = _saEA::P64;
          P64[Sp - 16] = _saEz::P64;
          P64[Sp - 8] = _saEB::P64;
          Sp = Sp - 24;
          if (R1 & 7 != 0) goto cbpJ; else goto cbpK;
      cbpK:
          call (I64[R1])(R1) returns to cbpJ, args: 8, res: 8, upd: 8;
      cbpJ:
          I64[Sp - 8] = cbpP;
          _saEE::P64 = P64[R1 + 7];
          R1 = P64[R1 + 15];
          P64[Sp] = _saEE::P64;
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto cbpP; else goto cbpU;
      cbpU:
          call (I64[R1])(R1) returns to cbpP, args: 8, res: 8, upd: 8;
      cbpP:
          R5 = P64[Sp + 24];
          R4 = P64[R1 + 7];
          R3 = P64[Sp + 8];
          R2 = P64[Sp + 16];
          Sp = Sp + 32;
          call SkipList.$wa2_info(R5, R4, R3, R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:46.496521 UTC

[section "data" {
     SkipList.delete1_closure:
         const SkipList.delete1_info;
         const 0;
 },
 SkipList.delete1_entry() //  [R4, R3, R2]
         { info_tbl: [(cbpJ,
                       label: block_cbpJ_info
                       rep:StackRep [False, False]),
                      (cbpM,
                       label: SkipList.delete1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} }),
                      (cbpP,
                       label: block_cbpP_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbpM:
           _saEB::P64 = R4;
           _saEA::P64 = R3;
           _saEz::P64 = R2;
           if ((Sp + -32) < SpLim) goto cbpQ; else goto cbpR;
       cbpR:
           if (HpLim == 0) goto cbpQ; else goto cbpS;
       cbpQ:
           R4 = _saEB::P64;
           R3 = _saEA::P64;
           R2 = _saEz::P64;
           R1 = SkipList.delete1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbpS:
           I64[Sp - 24] = cbpJ;
           R1 = _saEA::P64;
           P64[Sp - 16] = _saEz::P64;
           P64[Sp - 8] = _saEB::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto cbpJ; else goto cbpK;
       cbpK:
           call (I64[R1])(R1) returns to cbpJ, args: 8, res: 8, upd: 8;
       cbpJ:
           I64[Sp - 8] = cbpP;
           _saEE::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _saEE::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto cbpP; else goto cbpU;
       cbpU:
           call (I64[R1])(R1) returns to cbpP, args: 8, res: 8, upd: 8;
       cbpP:
           R5 = P64[Sp + 24];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call SkipList.$wa2_info(R5, R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:46.499348 UTC

[section "data" {
     SkipList.delete1_closure:
         const SkipList.delete1_info;
         const 0;
 },
 SkipList.delete1_entry() //  [R4, R3, R2]
         { info_tbl: [(cbpJ,
                       label: block_cbpJ_info
                       rep:StackRep [False, False]),
                      (cbpM,
                       label: SkipList.delete1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} }),
                      (cbpP,
                       label: block_cbpP_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbpM:
           _saEB::P64 = R4;
           _saEA::P64 = R3;
           _saEz::P64 = R2;
           if ((Sp + -32) < SpLim) goto cbpQ; else goto cbpR;
       cbpR:
           if (HpLim == 0) goto cbpQ; else goto cbpS;
       cbpQ:
           R4 = _saEB::P64;
           R3 = _saEA::P64;
           R2 = _saEz::P64;
           R1 = SkipList.delete1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbpS:
           I64[Sp - 24] = cbpJ;
           R1 = _saEA::P64;
           P64[Sp - 16] = _saEz::P64;
           P64[Sp - 8] = _saEB::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto cbpJ; else goto cbpK;
       cbpK:
           call (I64[R1])(R1) returns to cbpJ, args: 8, res: 8, upd: 8;
       cbpJ:
           I64[Sp - 8] = cbpP;
           _saEE::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _saEE::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto cbpP; else goto cbpU;
       cbpU:
           call (I64[R1])(R1) returns to cbpP, args: 8, res: 8, upd: 8;
       cbpP:
           R5 = P64[Sp + 24];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 8];
           R2 = P64[Sp + 16];
           Sp = Sp + 32;
           call SkipList.$wa2_info(R5, R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:46.506189 UTC

[section "data" {
     SkipList.delete_closure:
         const SkipList.delete_info;
         const 0;
 },
 SkipList.delete_entry() //  [R4, R3, R2]
         { info_tbl: [(cbq8,
                       label: SkipList.delete_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbq8:
           _B2::P64 = R4;
           _B3::P64 = R3;
           _B4::P64 = R2;
           goto cbq6;
       cbq6:
           if ((old + 0) - <highSp> < SpLim) goto cbq9; else goto cbqa;
       cbqa:
           goto cbq5;
       cbq5:
           if (HpLim == 0) goto cbq9; else goto cbqb;
       cbq9:
           R4 = _B2::P64;
           R3 = _B3::P64;
           R2 = _B4::P64;
           R1 = SkipList.delete_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbqb:
           R4 = _B2::P64;
           R3 = _B3::P64;
           R2 = _B4::P64;
           call SkipList.delete1_info(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:46.508068 UTC

{offset
  cbq8:
      _B2::P64 = R4;
      _B3::P64 = R3;
      _B4::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cbq9; else goto cbqa;
  cbqa:
      if (HpLim == 0) goto cbq9; else goto cbqb;
  cbq9:
      R4 = _B2::P64;
      R3 = _B3::P64;
      R2 = _B4::P64;
      R1 = SkipList.delete_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  cbqb:
      R4 = _B2::P64;
      R3 = _B3::P64;
      R2 = _B4::P64;
      call SkipList.delete1_info(R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:46.509023 UTC

{offset
  cbq8:
      _B2::P64 = R4;
      _B3::P64 = R3;
      _B4::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cbq9; else goto cbqa;
  cbqa:
      if (HpLim == 0) goto cbq9; else goto cbqb;
  cbq9:
      R4 = _B2::P64;
      R3 = _B3::P64;
      R2 = _B4::P64;
      R1 = SkipList.delete_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  cbqb:
      R4 = _B2::P64;
      R3 = _B3::P64;
      R2 = _B4::P64;
      call SkipList.delete1_info(R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:46.509979 UTC

{offset
  cbq8:
      _B2::P64 = R4;
      _B3::P64 = R3;
      _B4::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cbq9; else goto cbqa;
  cbqa:
      if (HpLim == 0) goto cbq9; else goto cbqb;
  cbq9:
      R4 = _B2::P64;
      R3 = _B3::P64;
      R2 = _B4::P64;
      R1 = SkipList.delete_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  cbqb:
      R4 = _B2::P64;
      R3 = _B3::P64;
      R2 = _B4::P64;
      call SkipList.delete1_info(R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:46.510979 UTC

{offset
  cbq8:
      _B2::P64 = R4;
      _B3::P64 = R3;
      _B4::P64 = R2;
      goto cbqa;
  cbqa:
      if (HpLim == 0) goto cbq9; else goto cbqb;
  cbq9:
      R4 = _B2::P64;
      R3 = _B3::P64;
      R2 = _B4::P64;
      R1 = SkipList.delete_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  cbqb:
      R4 = _B2::P64;
      R3 = _B3::P64;
      R2 = _B4::P64;
      call SkipList.delete1_info(R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:46.511844 UTC

{offset
  cbq8:
      goto cbqa;
  cbqa:
      if (HpLim == 0) goto cbq9; else goto cbqb;
  cbq9:
      R4 = R4;
      R3 = R3;
      R2 = R2;
      R1 = SkipList.delete_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  cbqb:
      R4 = R4;
      R3 = R3;
      R2 = R2;
      call SkipList.delete1_info(R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:46.512851 UTC

[(cbq8, {SkipList.delete1_closure, SkipList.delete_closure}),
 (cbq9, {SkipList.delete_closure}),
 (cbqa, {SkipList.delete1_closure, SkipList.delete_closure}),
 (cbqb, {SkipList.delete1_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:46.513348 UTC

SkipList.delete_entry() //  [R4, R3, R2]
        { info_tbl: [(cbq8,
                      label: SkipList.delete_info
                      rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cbq8:
          goto cbqa;
      cbqa:
          if (HpLim == 0) goto cbq9; else goto cbqb;
      cbq9:
          R4 = R4;
          R3 = R3;
          R2 = R2;
          R1 = SkipList.delete_closure;
          call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
      cbqb:
          R4 = R4;
          R3 = R3;
          R2 = R2;
          call SkipList.delete1_info(R4, R3, R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:46.514356 UTC

SkipList.delete_entry() //  [R4, R3, R2]
        { info_tbl: [(cbq8,
                      label: SkipList.delete_info
                      rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cbq8:
          if (HpLim == 0) goto cbq9; else goto cbqb;
      cbq9:
          R4 = R4;
          R3 = R3;
          R2 = R2;
          R1 = SkipList.delete_closure;
          call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
      cbqb:
          R4 = R4;
          R3 = R3;
          R2 = R2;
          call SkipList.delete1_info(R4, R3, R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:46.515319 UTC

[section "data" {
     SkipList.delete_closure:
         const SkipList.delete_info;
         const 0;
 },
 SkipList.delete_entry() //  [R4, R3, R2]
         { info_tbl: [(cbq8,
                       label: SkipList.delete_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbq8:
           if (HpLim == 0) goto cbq9; else goto cbqb;
       cbq9:
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = SkipList.delete_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbqb:
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call SkipList.delete1_info(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:46.516529 UTC

[section "data" {
     SkipList.delete_closure:
         const SkipList.delete_info;
         const 0;
 },
 SkipList.delete_entry() //  [R4, R3, R2]
         { info_tbl: [(cbq8,
                       label: SkipList.delete_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbq8:
           if (HpLim == 0) goto cbq9; else goto cbqb;
       cbq9:
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = SkipList.delete_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbqb:
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call SkipList.delete1_info(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:46.519371 UTC

[section "data" {
     SkipList.newSL_height_closure:
         const GHC.Types.I#_static_info;
         const 16;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:46.519737 UTC

[section "data" {
     SkipList.newSL_height_closure:
         const GHC.Types.I#_static_info;
         const 16;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:46.520049 UTC

[section "data" {
     SkipList.newSL_height_closure:
         const GHC.Types.I#_static_info;
         const 16;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:46.521297 UTC

[section "data" {
     SkipList.newSL5_closure:
         const SkipList.newSL5_info;
         const 0;
 },
 SkipList.newSL5_entry() //  [R3, R2]
         { info_tbl: [(cbqr,
                       label: SkipList.newSL5_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbqr:
           _saEK::I64 = R3;
           _saEJ::I64 = R2;
           goto cbqn;
       cbqn:
           if ((old + 0) - <highSp> < SpLim) goto cbqs; else goto cbqt;
       cbqt:
           goto cbqm;
       cbqm:
           if (HpLim == 0) goto cbqs; else goto cbqu;
       cbqs:
           R3 = _saEK::I64;
           R2 = _saEJ::I64;
           R1 = SkipList.newSL5_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbqu:
           I64[(young<cbqp> + 8)] = cbqp;
           R3 = _saEK::I64;
           R2 = _saEJ::I64;
           call Data.Vector.Internal.Check.checkIndex_msg#_info(R3,
                                                                R2) returns to cbqp, args: 8, res: 8, upd: 8;
       cbqp:
           _saEL::P64 = R1;
           R6 = _saEL::P64;
           R5 = lvl2_ravN_closure;
           R4 = Data.Vector.Internal.Check.Bounds_closure+1;
           R3 = lvl3_ravO_closure+1;
           R2 = SkipList.newSL8_closure;
           call Data.Vector.Internal.Check.checkError_info(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:46.523831 UTC

{offset
  cbqr:
      _saEK::I64 = R3;
      _saEJ::I64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cbqs; else goto cbqt;
  cbqt:
      if (HpLim == 0) goto cbqs; else goto cbqu;
  cbqs:
      R3 = _saEK::I64;
      R2 = _saEJ::I64;
      R1 = SkipList.newSL5_closure;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  cbqu:
      I64[(young<cbqp> + 8)] = cbqp;
      R3 = _saEK::I64;
      R2 = _saEJ::I64;
      call Data.Vector.Internal.Check.checkIndex_msg#_info(R3,
                                                           R2) returns to cbqp, args: 8, res: 8, upd: 8;
  cbqp:
      _saEL::P64 = R1;
      R6 = _saEL::P64;
      R5 = lvl2_ravN_closure;
      R4 = Data.Vector.Internal.Check.Bounds_closure+1;
      R3 = lvl3_ravO_closure+1;
      R2 = SkipList.newSL8_closure;
      call Data.Vector.Internal.Check.checkError_info(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:46.525148 UTC

{offset
  cbqr:
      _saEK::I64 = R3;
      _saEJ::I64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cbqs; else goto cbqt;
  cbqt:
      if (HpLim == 0) goto cbqs; else goto cbqu;
  cbqs:
      R3 = _saEK::I64;
      R2 = _saEJ::I64;
      R1 = SkipList.newSL5_closure;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  cbqu:
      I64[(young<cbqp> + 8)] = cbqp;
      R3 = _saEK::I64;
      R2 = _saEJ::I64;
      call Data.Vector.Internal.Check.checkIndex_msg#_info(R3,
                                                           R2) returns to cbqp, args: 8, res: 8, upd: 8;
  cbqp:
      _saEL::P64 = R1;
      R6 = _saEL::P64;
      R5 = lvl2_ravN_closure;
      R4 = Data.Vector.Internal.Check.Bounds_closure+1;
      R3 = lvl3_ravO_closure+1;
      R2 = SkipList.newSL8_closure;
      call Data.Vector.Internal.Check.checkError_info(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:46.526493 UTC

{offset
  cbqr:
      _saEK::I64 = R3;
      _saEJ::I64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cbqs; else goto cbqt;
  cbqt:
      if (HpLim == 0) goto cbqs; else goto cbqu;
  cbqs:
      R3 = _saEK::I64;
      R2 = _saEJ::I64;
      R1 = SkipList.newSL5_closure;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  cbqu:
      I64[(young<cbqp> + 8)] = cbqp;
      R3 = _saEK::I64;
      R2 = _saEJ::I64;
      call Data.Vector.Internal.Check.checkIndex_msg#_info(R3,
                                                           R2) returns to cbqp, args: 8, res: 8, upd: 8;
  cbqp:
      _saEL::P64 = R1;
      R6 = _saEL::P64;
      R5 = lvl2_ravN_closure;
      R4 = Data.Vector.Internal.Check.Bounds_closure+1;
      R3 = lvl3_ravO_closure+1;
      R2 = SkipList.newSL8_closure;
      call Data.Vector.Internal.Check.checkError_info(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:46.528031 UTC

{offset
  cbqr:
      _saEK::I64 = R3;
      _saEJ::I64 = R2;
      if ((Sp + 8) - 16 < SpLim) goto cbqs; else goto cbqt;
  cbqt:
      if (HpLim == 0) goto cbqs; else goto cbqu;
  cbqs:
      R3 = _saEK::I64;
      R2 = _saEJ::I64;
      R1 = SkipList.newSL5_closure;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  cbqu:
      I64[Sp - 8] = cbqp;
      R3 = _saEK::I64;
      R2 = _saEJ::I64;
      Sp = Sp - 8;
      call Data.Vector.Internal.Check.checkIndex_msg#_info(R3,
                                                           R2) returns to cbqp, args: 8, res: 8, upd: 8;
  cbqp:
      _saEL::P64 = R1;
      R6 = _saEL::P64;
      R5 = lvl2_ravN_closure;
      R4 = Data.Vector.Internal.Check.Bounds_closure+1;
      R3 = lvl3_ravO_closure+1;
      R2 = SkipList.newSL8_closure;
      Sp = Sp + 8;
      call Data.Vector.Internal.Check.checkError_info(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:46.529421 UTC

{offset
  cbqr:
      _saEK::I64 = R3;
      _saEJ::I64 = R2;
      if ((Sp + -8) < SpLim) goto cbqs; else goto cbqt;
  cbqt:
      if (HpLim == 0) goto cbqs; else goto cbqu;
  cbqs:
      R3 = _saEK::I64;
      R2 = _saEJ::I64;
      R1 = SkipList.newSL5_closure;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  cbqu:
      I64[Sp - 8] = cbqp;
      R3 = _saEK::I64;
      R2 = _saEJ::I64;
      Sp = Sp - 8;
      call Data.Vector.Internal.Check.checkIndex_msg#_info(R3,
                                                           R2) returns to cbqp, args: 8, res: 8, upd: 8;
  cbqp:
      R6 = R1;
      R5 = lvl2_ravN_closure;
      R4 = Data.Vector.Internal.Check.Bounds_closure+1;
      R3 = lvl3_ravO_closure+1;
      R2 = SkipList.newSL8_closure;
      Sp = Sp + 8;
      call Data.Vector.Internal.Check.checkError_info(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:46.530914 UTC

[(cbqp,
  {Data.Vector.Internal.Check.checkError_closure,
   SkipList.newSL8_closure, lvl2_ravN_closure}),
 (cbqr,
  {SkipList.newSL5_closure,
   Data.Vector.Internal.Check.checkError_closure,
   SkipList.newSL8_closure,
   Data.Vector.Internal.Check.checkIndex_msg#_closure,
   lvl2_ravN_closure}),
 (cbqs, {SkipList.newSL5_closure}),
 (cbqt,
  {SkipList.newSL5_closure,
   Data.Vector.Internal.Check.checkError_closure,
   SkipList.newSL8_closure,
   Data.Vector.Internal.Check.checkIndex_msg#_closure,
   lvl2_ravN_closure}),
 (cbqu,
  {Data.Vector.Internal.Check.checkError_closure,
   SkipList.newSL8_closure,
   Data.Vector.Internal.Check.checkIndex_msg#_closure,
   lvl2_ravN_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:46.531986 UTC

SkipList.newSL5_entry() //  [R3, R2]
        { info_tbl: [(cbqp,
                      label: block_cbqp_info
                      rep:StackRep []),
                     (cbqr,
                      label: SkipList.newSL5_info
                      rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cbqr:
          _saEK::I64 = R3;
          _saEJ::I64 = R2;
          if ((Sp + -8) < SpLim) goto cbqs; else goto cbqt;
      cbqt:
          if (HpLim == 0) goto cbqs; else goto cbqu;
      cbqs:
          R3 = _saEK::I64;
          R2 = _saEJ::I64;
          R1 = SkipList.newSL5_closure;
          call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
      cbqu:
          I64[Sp - 8] = cbqp;
          R3 = _saEK::I64;
          R2 = _saEJ::I64;
          Sp = Sp - 8;
          call Data.Vector.Internal.Check.checkIndex_msg#_info(R3,
                                                               R2) returns to cbqp, args: 8, res: 8, upd: 8;
      cbqp:
          R6 = R1;
          R5 = lvl2_ravN_closure;
          R4 = Data.Vector.Internal.Check.Bounds_closure+1;
          R3 = lvl3_ravO_closure+1;
          R2 = SkipList.newSL8_closure;
          Sp = Sp + 8;
          call Data.Vector.Internal.Check.checkError_info(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:46.533802 UTC

SkipList.newSL5_entry() //  [R3, R2]
        { info_tbl: [(cbqp,
                      label: block_cbqp_info
                      rep:StackRep []),
                     (cbqr,
                      label: SkipList.newSL5_info
                      rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cbqr:
          _saEK::I64 = R3;
          _saEJ::I64 = R2;
          if ((Sp + -8) < SpLim) goto cbqs; else goto cbqt;
      cbqt:
          if (HpLim == 0) goto cbqs; else goto cbqu;
      cbqs:
          R3 = _saEK::I64;
          R2 = _saEJ::I64;
          R1 = SkipList.newSL5_closure;
          call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
      cbqu:
          I64[Sp - 8] = cbqp;
          R3 = _saEK::I64;
          R2 = _saEJ::I64;
          Sp = Sp - 8;
          call Data.Vector.Internal.Check.checkIndex_msg#_info(R3,
                                                               R2) returns to cbqp, args: 8, res: 8, upd: 8;
      cbqp:
          R6 = R1;
          R5 = lvl2_ravN_closure;
          R4 = Data.Vector.Internal.Check.Bounds_closure+1;
          R3 = lvl3_ravO_closure+1;
          R2 = SkipList.newSL8_closure;
          Sp = Sp + 8;
          call Data.Vector.Internal.Check.checkError_info(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:46.535539 UTC

[section "data" {
     SkipList.newSL5_closure:
         const SkipList.newSL5_info;
         const 0;
 },
 section "relreadonly" {
     ubqy_srtd:
         const SaM6_srt+24;
         const 40;
         const 1030792151041;
 },
 SkipList.newSL5_entry() //  [R3, R2]
         { info_tbl: [(cbqp,
                       label: block_cbqp_info
                       rep:StackRep []),
                      (cbqr,
                       label: SkipList.newSL5_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbqr:
           _saEK::I64 = R3;
           _saEJ::I64 = R2;
           if ((Sp + -8) < SpLim) goto cbqs; else goto cbqt;
       cbqt:
           if (HpLim == 0) goto cbqs; else goto cbqu;
       cbqs:
           R3 = _saEK::I64;
           R2 = _saEJ::I64;
           R1 = SkipList.newSL5_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbqu:
           I64[Sp - 8] = cbqp;
           R3 = _saEK::I64;
           R2 = _saEJ::I64;
           Sp = Sp - 8;
           call Data.Vector.Internal.Check.checkIndex_msg#_info(R3,
                                                                R2) returns to cbqp, args: 8, res: 8, upd: 8;
       cbqp:
           R6 = R1;
           R5 = lvl2_ravN_closure;
           R4 = Data.Vector.Internal.Check.Bounds_closure+1;
           R3 = lvl3_ravO_closure+1;
           R2 = SkipList.newSL8_closure;
           Sp = Sp + 8;
           call Data.Vector.Internal.Check.checkError_info(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:46.537815 UTC

[section "data" {
     SkipList.newSL5_closure:
         const SkipList.newSL5_info;
         const 0;
 },
 section "relreadonly" {
     ubqy_srtd:
         const SaM6_srt+24;
         const 40;
         const 1030792151041;
 },
 SkipList.newSL5_entry() //  [R3, R2]
         { info_tbl: [(cbqp,
                       label: block_cbqp_info
                       rep:StackRep []),
                      (cbqr,
                       label: SkipList.newSL5_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 12} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbqr:
           _saEK::I64 = R3;
           _saEJ::I64 = R2;
           if ((Sp + -8) < SpLim) goto cbqs; else goto cbqt;
       cbqt:
           if (HpLim == 0) goto cbqs; else goto cbqu;
       cbqs:
           R3 = _saEK::I64;
           R2 = _saEJ::I64;
           R1 = SkipList.newSL5_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cbqu:
           I64[Sp - 8] = cbqp;
           R3 = _saEK::I64;
           R2 = _saEJ::I64;
           Sp = Sp - 8;
           call Data.Vector.Internal.Check.checkIndex_msg#_info(R3,
                                                                R2) returns to cbqp, args: 8, res: 8, upd: 8;
       cbqp:
           R6 = R1;
           R5 = lvl2_ravN_closure;
           R4 = Data.Vector.Internal.Check.Bounds_closure+1;
           R3 = lvl3_ravO_closure+1;
           R2 = SkipList.newSL8_closure;
           Sp = Sp + 8;
           call Data.Vector.Internal.Check.checkError_info(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:46.544154 UTC

[section "data" {
     SkipList.newSL4_closure:
         const SkipList.newSL4_info;
         const 0;
 },
 a7_saF2_entry() //  [R2, R1]
         { info_tbl: [(cbsh,
                       label: a7_saF2_info
                       rep:HeapRep 1 ptrs 2 nonptrs {
                             Fun {arity: 2 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbsh:
           _saF3::I64 = R2;
           _saF2::P64 = R1;
           goto cbsb;
       cbsb:
           if ((old + 0) - <highSp> < SpLim) goto cbsi; else goto cbsj;
       cbsj:
           goto cbsa;
       cbsa:
           if (HpLim == 0) goto cbsi; else goto cbsk;
       cbsi:
           R2 = _saF3::I64;
           R1 = _saF2::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbsk:
           _saEY::P64 = P64[_saF2::P64 + 6];
           _saEQ::I64 = I64[_saF2::P64 + 14];
           _saEZ::I64 = I64[_saF2::P64 + 22];
           I64[(young<cbsd> + 8)] = cbsd;
           R2 = System.Random.PCG.Class.sysRandom2_closure+2;
           R1 = System.Random.PCG.Class.sysRandom10_closure+1;
           call stg_catch#(R2, R1) returns to cbsd, args: 8, res: 8, upd: 8;
       cbsd:
           _saF7::P64 = R1;
           _cbsf::I64 = _saF3::I64 * 8;
           _saF8::I64 = _cbsf::I64;
           _cbsn::I64 = %MO_S_Ge_W64(_saF8::I64, 0);
           _saF9::I64 = _cbsn::I64;
           switch [0 .. 1] _saF9::I64 {
               case 0 : goto cbss;
               case 1 : goto cbsT;
           }
       cbsT:
           _cbsv::I64 = %MO_S_Lt_W64(_saF8::I64, _saEQ::I64);
           _saFc::I64 = _cbsv::I64;
           switch [0 .. 1] _saFc::I64 {
               case 0 : goto cbsA;
               case 1 : goto cbsE;
           }
       cbsE:
           I64[(young<cbsD> + 8)] = cbsD;
           R1 = _saF7::P64;
           if (R1 & 7 != 0) goto cbsD; else goto cbsF;
       cbsF:
           call (I64[R1])(R1) returns to cbsD, args: 8, res: 8, upd: 8;
       cbsD:
           _saFf::P64 = R1;
           _saFg::I64 = I64[_saFf::P64 + 7];
           I64[(_saEY::P64 + 16) + (_saF8::I64 << 3)] = _saFg::I64;
           _cbsM::I64 = _saF3::I64 == _saEZ::I64;
           _saFi::I64 = _cbsM::I64;
           switch [0 .. 1] _saFi::I64 {
               case 0 : goto cbsR;
               case 1 : goto cbsS;
           }
       cbsS:
           R1 = GHC.Tuple.()_closure+1;
           call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
       cbsR:
           _cbsV::I64 = _saF3::I64 + 1;
           _saFk::I64 = _cbsV::I64;
           R2 = _saFk::I64;
           R1 = _saF2::P64;
           call a7_saF2_info(R2, R1) args: 8, res: 0, upd: 8;
       cbsA:
           R3 = _saEQ::I64;
           R2 = _saF8::I64;
           call SkipList.newSL5_info(R3, R2) args: 8, res: 0, upd: 8;
       cbss:
           R3 = _saEQ::I64;
           R2 = _saF8::I64;
           call SkipList.newSL5_info(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 SkipList.newSL4_entry() //  []
         { info_tbl: [(cbsW,
                       label: SkipList.newSL4_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbsW:
           goto cbrK;
       cbrK:
           if ((old + 0) - <highSp> < SpLim) goto cbsX; else goto cbsY;
       cbsY:
           goto cbrJ;
       cbrJ:
           if (HpLim == 0) goto cbsX; else goto cbtl;
       cbsX:
           R1 = SkipList.newSL4_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbtl:
           _saEP::I64 = %MO_SS_Conv_W32_W64(I32[enabled_capabilities]);
           _saEP::I64 = _saEP::I64;
           _cbrM::I64 = _saEP::I64 * 8;
           _saEQ::I64 = _cbrM::I64;
           _cbrP::I64 = %MO_S_Ge_W64(_saEQ::I64, 0);
           _saER::I64 = _cbrP::I64;
           switch [0 .. 1] _saER::I64 {
               case 0 : goto cbt1;
               case 1 : goto cbt6;
           }
       cbt6:
           _cbrV::I64 = _saEQ::I64 * 8;
           _saEV::I64 = _cbrV::I64;
           I64[(young<cbrY> + 8)] = cbrY;
           R1 = _saEV::I64;
           call stg_newByteArray#(R1) returns to cbrY, args: 8, res: 8, upd: 8;
       cbrY:
           _saEY::P64 = R1;
           Hp = Hp + 32;
           if (Hp > HpLim) goto cbt9; else goto cbt8;
       cbt9:
           HpAlloc = 32;
           goto cbt7;
       cbt7:
           R1 = _saEY::P64;
           call stg_gc_unpt_r1(R1) returns to cbrY, args: 8, res: 8, upd: 8;
       cbt8:
           _cbs0::I64 = _saEP::I64 - 1;
           _saEZ::I64 = _cbs0::I64;
           _cbs3::I64 = %MO_S_Gt_W64(0, _saEZ::I64);
           _saF0::I64 = _cbs3::I64;
           switch [0 .. 1] _saF0::I64 {
               case 0 : goto cbte;
               case 1 : goto cbtk;
           }
       cbtk:
           I64[Hp - 24] = Data.Vector.Primitive.Mutable.MVector_con_info;
           P64[Hp - 16] = _saEY::P64;
           I64[Hp - 8] = 0;
           I64[Hp] = _saEQ::I64;
           _cbtj::P64 = Hp - 23;
           R1 = _cbtj::P64;
           call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
       cbte:
           _cbs8::P64 = Hp - 22;
           I64[Hp - 24] = a7_saF2_info;
           P64[Hp - 16] = _saEY::P64;
           I64[Hp - 8] = _saEQ::I64;
           I64[Hp] = _saEZ::I64;
           I64[(young<cbta> + 8)] = cbta;
           R2 = 0;
           R1 = _cbs8::P64;
           call a7_saF2_info(R2, R1) returns to cbta, args: 8, res: 8, upd: 8;
       cbta:
           _saFn::P64 = R1;
           Hp = Hp + 32;
           if (Hp > HpLim) goto cbth; else goto cbtg;
       cbth:
           HpAlloc = 32;
           goto cbtf;
       cbtf:
           R1 = _saFn::P64;
           call stg_gc_unpt_r1(R1) returns to cbta, args: 8, res: 8, upd: 8;
       cbtg:
           I64[Hp - 24] = Data.Vector.Primitive.Mutable.MVector_con_info;
           P64[Hp - 16] = _saEY::P64;
           I64[Hp - 8] = 0;
           I64[Hp] = _saEQ::I64;
           _cbtc::P64 = Hp - 23;
           R1 = _cbtc::P64;
           call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
       cbt1:
           I64[(young<cbsZ> + 8)] = cbsZ;
           R2 = _saEQ::I64;
           call Data.Vector.Internal.Check.checkLength_msg#_info(R2) returns to cbsZ, args: 8, res: 8, upd: 8;
       cbsZ:
           _saET::P64 = R1;
           R6 = _saET::P64;
           R5 = SkipList.newSL6_closure;
           R4 = Data.Vector.Internal.Check.Bounds_closure+1;
           R3 = SkipList.newSL7_closure+1;
           R2 = SkipList.newSL8_closure;
           call Data.Vector.Internal.Check.checkError_info(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:46.556397 UTC

{offset
  cbsh:
      _saF3::I64 = R2;
      _saF2::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cbsi; else goto cbsj;
  cbsj:
      if (HpLim == 0) goto cbsi; else goto cbsk;
  cbsi:
      R2 = _saF3::I64;
      R1 = _saF2::P64;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  cbsk:
      _saEY::P64 = P64[_saF2::P64 + 6];
      _saEQ::I64 = I64[_saF2::P64 + 14];
      _saEZ::I64 = I64[_saF2::P64 + 22];
      I64[(young<cbsd> + 8)] = cbsd;
      R2 = System.Random.PCG.Class.sysRandom2_closure+2;
      R1 = System.Random.PCG.Class.sysRandom10_closure+1;
      call stg_catch#(R2, R1) returns to cbsd, args: 8, res: 8, upd: 8;
  cbsd:
      _saF7::P64 = R1;
      _cbsf::I64 = _saF3::I64 * 8;
      _saF8::I64 = _cbsf::I64;
      _cbsn::I64 = %MO_S_Ge_W64(_saF8::I64, 0);
      _saF9::I64 = _cbsn::I64;
      switch [0 .. 1] _saF9::I64 {
          case 0 : goto cbss;
          case 1 : goto cbsT;
      }
  cbsT:
      _cbsv::I64 = %MO_S_Lt_W64(_saF8::I64, _saEQ::I64);
      _saFc::I64 = _cbsv::I64;
      switch [0 .. 1] _saFc::I64 {
          case 0 : goto cbsA;
          case 1 : goto cbsE;
      }
  cbsE:
      I64[(young<cbsD> + 8)] = cbsD;
      R1 = _saF7::P64;
      if (R1 & 7 != 0) goto cbsD; else goto cbsF;
  cbsF:
      call (I64[R1])(R1) returns to cbsD, args: 8, res: 8, upd: 8;
  cbsD:
      _saFf::P64 = R1;
      _saFg::I64 = I64[_saFf::P64 + 7];
      I64[(_saEY::P64 + 16) + (_saF8::I64 << 3)] = _saFg::I64;
      _cbsM::I64 = _saF3::I64 == _saEZ::I64;
      _saFi::I64 = _cbsM::I64;
      switch [0 .. 1] _saFi::I64 {
          case 0 : goto cbsR;
          case 1 : goto cbsS;
      }
  cbsS:
      R1 = GHC.Tuple.()_closure+1;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
  cbsR:
      _cbsV::I64 = _saF3::I64 + 1;
      _saFk::I64 = _cbsV::I64;
      R2 = _saFk::I64;
      R1 = _saF2::P64;
      call a7_saF2_info(R2, R1) args: 8, res: 0, upd: 8;
  cbsA:
      R3 = _saEQ::I64;
      R2 = _saF8::I64;
      call SkipList.newSL5_info(R3, R2) args: 8, res: 0, upd: 8;
  cbss:
      R3 = _saEQ::I64;
      R2 = _saF8::I64;
      call SkipList.newSL5_info(R3, R2) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:46.559773 UTC

{offset
  cbsh:
      _saF3::I64 = R2;
      _saF2::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cbsi; else goto cbsj;
  cbsj:
      if (HpLim == 0) goto cbsi; else goto cbsk;
  cbsi:
      R2 = _saF3::I64;
      R1 = _saF2::P64;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  cbsk:
      _saEY::P64 = P64[_saF2::P64 + 6];
      _saEQ::I64 = I64[_saF2::P64 + 14];
      _saEZ::I64 = I64[_saF2::P64 + 22];
      I64[(young<cbsd> + 8)] = cbsd;
      R2 = System.Random.PCG.Class.sysRandom2_closure+2;
      R1 = System.Random.PCG.Class.sysRandom10_closure+1;
      call stg_catch#(R2, R1) returns to cbsd, args: 8, res: 8, upd: 8;
  cbsd:
      _saF7::P64 = R1;
      _cbsf::I64 = _saF3::I64 * 8;
      _saF8::I64 = _cbsf::I64;
      _cbsn::I64 = %MO_S_Ge_W64(_saF8::I64, 0);
      _saF9::I64 = _cbsn::I64;
      switch [0 .. 1] _saF9::I64 {
          case 0 : goto cbsA;
          case 1 : goto cbsT;
      }
  cbsT:
      _cbsv::I64 = %MO_S_Lt_W64(_saF8::I64, _saEQ::I64);
      _saFc::I64 = _cbsv::I64;
      switch [0 .. 1] _saFc::I64 {
          case 0 : goto cbsA;
          case 1 : goto cbsE;
      }
  cbsE:
      I64[(young<cbsD> + 8)] = cbsD;
      R1 = _saF7::P64;
      if (R1 & 7 != 0) goto cbsD; else goto cbsF;
  cbsF:
      call (I64[R1])(R1) returns to cbsD, args: 8, res: 8, upd: 8;
  cbsD:
      _saFf::P64 = R1;
      _saFg::I64 = I64[_saFf::P64 + 7];
      I64[(_saEY::P64 + 16) + (_saF8::I64 << 3)] = _saFg::I64;
      _cbsM::I64 = _saF3::I64 == _saEZ::I64;
      _saFi::I64 = _cbsM::I64;
      switch [0 .. 1] _saFi::I64 {
          case 0 : goto cbsR;
          case 1 : goto cbsS;
      }
  cbsS:
      R1 = GHC.Tuple.()_closure+1;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
  cbsR:
      _cbsV::I64 = _saF3::I64 + 1;
      _saFk::I64 = _cbsV::I64;
      R2 = _saFk::I64;
      R1 = _saF2::P64;
      call a7_saF2_info(R2, R1) args: 8, res: 0, upd: 8;
  cbsA:
      R3 = _saEQ::I64;
      R2 = _saF8::I64;
      call SkipList.newSL5_info(R3, R2) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:46.563032 UTC

{offset
  cbsh:
      _saF3::I64 = R2;
      _saF2::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cbsi; else goto cbsj;
  cbsj:
      if (HpLim == 0) goto cbsi; else goto cbsk;
  cbsi:
      R2 = _saF3::I64;
      R1 = _saF2::P64;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  cbsk:
      _saEY::P64 = P64[_saF2::P64 + 6];
      _saEQ::I64 = I64[_saF2::P64 + 14];
      _saEZ::I64 = I64[_saF2::P64 + 22];
      I64[(young<cbsd> + 8)] = cbsd;
      R2 = System.Random.PCG.Class.sysRandom2_closure+2;
      R1 = System.Random.PCG.Class.sysRandom10_closure+1;
      call stg_catch#(R2, R1) returns to cbsd, args: 8, res: 8, upd: 8;
  cbsd:
      _saF7::P64 = R1;
      _cbsf::I64 = _saF3::I64 * 8;
      _saF8::I64 = _cbsf::I64;
      _cbsn::I64 = %MO_S_Ge_W64(_saF8::I64, 0);
      _saF9::I64 = _cbsn::I64;
      if (_saF9::I64 != 0) goto cbsT; else goto cbsA;
  cbsT:
      _cbsv::I64 = %MO_S_Lt_W64(_saF8::I64, _saEQ::I64);
      _saFc::I64 = _cbsv::I64;
      if (_saFc::I64 != 0) goto cbsE; else goto cbsA;
  cbsE:
      I64[(young<cbsD> + 8)] = cbsD;
      R1 = _saF7::P64;
      if (R1 & 7 != 0) goto cbsD; else goto cbsF;
  cbsF:
      call (I64[R1])(R1) returns to cbsD, args: 8, res: 8, upd: 8;
  cbsD:
      _saFf::P64 = R1;
      _saFg::I64 = I64[_saFf::P64 + 7];
      I64[(_saEY::P64 + 16) + (_saF8::I64 << 3)] = _saFg::I64;
      _cbsM::I64 = _saF3::I64 == _saEZ::I64;
      _saFi::I64 = _cbsM::I64;
      if (_saFi::I64 != 0) goto cbsS; else goto cbsR;
  cbsS:
      R1 = GHC.Tuple.()_closure+1;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
  cbsR:
      _cbsV::I64 = _saF3::I64 + 1;
      _saFk::I64 = _cbsV::I64;
      R2 = _saFk::I64;
      R1 = _saF2::P64;
      call a7_saF2_info(R2, R1) args: 8, res: 0, upd: 8;
  cbsA:
      R3 = _saEQ::I64;
      R2 = _saF8::I64;
      call SkipList.newSL5_info(R3, R2) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:46.566311 UTC

{offset
  cbsh:
      _saF3::I64 = R2;
      _saF2::P64 = R1;
      if ((Sp + 8) - 56 < SpLim) goto cbsi; else goto cbsj;
  cbsj:
      if (HpLim == 0) goto cbsi; else goto cbsk;
  cbsi:
      R2 = _saF3::I64;
      R1 = _saF2::P64;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  cbsk:
      _saEY::P64 = P64[_saF2::P64 + 6];
      _saEQ::I64 = I64[_saF2::P64 + 14];
      _saEZ::I64 = I64[_saF2::P64 + 22];
      I64[Sp - 48] = cbsd;
      R2 = System.Random.PCG.Class.sysRandom2_closure+2;
      R1 = System.Random.PCG.Class.sysRandom10_closure+1;
      I64[Sp - 40] = _saEQ::I64;
      P64[Sp - 32] = _saEY::P64;
      I64[Sp - 24] = _saEZ::I64;
      P64[Sp - 16] = _saF2::P64;
      I64[Sp - 8] = _saF3::I64;
      Sp = Sp - 48;
      call stg_catch#(R2, R1) returns to cbsd, args: 8, res: 8, upd: 8;
  cbsd:
      _saEQ::I64 = I64[Sp + 8];
      _saEY::P64 = P64[Sp + 16];
      _saEZ::I64 = I64[Sp + 24];
      _saF2::P64 = P64[Sp + 32];
      _saF3::I64 = I64[Sp + 40];
      _saF7::P64 = R1;
      _cbsf::I64 = _saF3::I64 * 8;
      _saF8::I64 = _cbsf::I64;
      _cbsn::I64 = %MO_S_Ge_W64(_saF8::I64, 0);
      _saF9::I64 = _cbsn::I64;
      if (_saF9::I64 != 0) goto cbsT; else goto cbsA;
  cbsT:
      _cbsv::I64 = %MO_S_Lt_W64(_saF8::I64, _saEQ::I64);
      _saFc::I64 = _cbsv::I64;
      if (_saFc::I64 != 0) goto cbsE; else goto cbsA;
  cbsE:
      I64[Sp] = cbsD;
      R1 = _saF7::P64;
      I64[Sp + 8] = _saF8::I64;
      if (R1 & 7 != 0) goto cbsD; else goto cbsF;
  cbsF:
      call (I64[R1])(R1) returns to cbsD, args: 8, res: 8, upd: 8;
  cbsD:
      _saEY::P64 = P64[Sp + 16];
      _saEZ::I64 = I64[Sp + 24];
      _saF2::P64 = P64[Sp + 32];
      _saF3::I64 = I64[Sp + 40];
      _saF8::I64 = I64[Sp + 8];
      _saFf::P64 = R1;
      _saFg::I64 = I64[_saFf::P64 + 7];
      I64[(_saEY::P64 + 16) + (_saF8::I64 << 3)] = _saFg::I64;
      _cbsM::I64 = _saF3::I64 == _saEZ::I64;
      _saFi::I64 = _cbsM::I64;
      if (_saFi::I64 != 0) goto cbsS; else goto cbsR;
  cbsS:
      R1 = GHC.Tuple.()_closure+1;
      Sp = Sp + 48;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
  cbsR:
      _cbsV::I64 = _saF3::I64 + 1;
      _saFk::I64 = _cbsV::I64;
      R2 = _saFk::I64;
      R1 = _saF2::P64;
      Sp = Sp + 48;
      call a7_saF2_info(R2, R1) args: 8, res: 0, upd: 8;
  cbsA:
      R3 = _saEQ::I64;
      R2 = _saF8::I64;
      Sp = Sp + 48;
      call SkipList.newSL5_info(R3, R2) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:46.57022 UTC

{offset
  cbsh:
      _saF3::I64 = R2;
      _saF2::P64 = R1;
      if ((Sp + -48) < SpLim) goto cbsi; else goto cbsj;
  cbsj:
      if (HpLim == 0) goto cbsi; else goto cbsk;
  cbsi:
      R2 = _saF3::I64;
      R1 = _saF2::P64;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  cbsk:
      I64[Sp - 48] = cbsd;
      R2 = System.Random.PCG.Class.sysRandom2_closure+2;
      R1 = System.Random.PCG.Class.sysRandom10_closure+1;
      I64[Sp - 40] = I64[_saF2::P64 + 14];
      P64[Sp - 32] = P64[_saF2::P64 + 6];
      I64[Sp - 24] = I64[_saF2::P64 + 22];
      P64[Sp - 16] = _saF2::P64;
      I64[Sp - 8] = _saF3::I64;
      Sp = Sp - 48;
      call stg_catch#(R2, R1) returns to cbsd, args: 8, res: 8, upd: 8;
  cbsd:
      _saEQ::I64 = I64[Sp + 8];
      _saF8::I64 = I64[Sp + 40] << 3;
      if (%MO_S_Ge_W64(_saF8::I64, 0)) goto cbsT; else goto cbsA;
  cbsT:
      if (%MO_S_Lt_W64(_saF8::I64,
                       _saEQ::I64)) goto cbsE; else goto cbsA;
  cbsE:
      I64[Sp] = cbsD;
      R1 = R1;
      I64[Sp + 8] = _saF8::I64;
      if (R1 & 7 != 0) goto cbsD; else goto cbsF;
  cbsF:
      call (I64[R1])(R1) returns to cbsD, args: 8, res: 8, upd: 8;
  cbsD:
      _saEZ::I64 = I64[Sp + 24];
      _saF2::P64 = P64[Sp + 32];
      _saF3::I64 = I64[Sp + 40];
      I64[P64[Sp + 16] + ((I64[Sp + 8] << 3) + 16)] = I64[R1 + 7];
      if (_saF3::I64 == _saEZ::I64) goto cbsS; else goto cbsR;
  cbsS:
      R1 = GHC.Tuple.()_closure+1;
      Sp = Sp + 48;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
  cbsR:
      R2 = _saF3::I64 + 1;
      R1 = _saF2::P64;
      Sp = Sp + 48;
      call a7_saF2_info(R2, R1) args: 8, res: 0, upd: 8;
  cbsA:
      R3 = _saEQ::I64;
      R2 = _saF8::I64;
      Sp = Sp + 48;
      call SkipList.newSL5_info(R3, R2) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:46.573831 UTC

[(cbsd, {SkipList.newSL5_closure, a7_saF2_closure}),
 (cbsh,
  {System.Random.PCG.Class.sysRandom2_closure,
   System.Random.PCG.Class.sysRandom10_closure,
   SkipList.newSL5_closure, a7_saF2_closure}),
 (cbsi, {}),
 (cbsj,
  {System.Random.PCG.Class.sysRandom2_closure,
   System.Random.PCG.Class.sysRandom10_closure,
   SkipList.newSL5_closure, a7_saF2_closure}),
 (cbsk,
  {System.Random.PCG.Class.sysRandom2_closure,
   System.Random.PCG.Class.sysRandom10_closure,
   SkipList.newSL5_closure, a7_saF2_closure}),
 (cbsA, {SkipList.newSL5_closure}), (cbsD, {a7_saF2_closure}),
 (cbsE, {a7_saF2_closure}), (cbsF, {a7_saF2_closure}),
 (cbsR, {a7_saF2_closure}), (cbsS, {}),
 (cbsT, {SkipList.newSL5_closure, a7_saF2_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:46.575066 UTC

a7_saF2_entry() //  [R2, R1]
        { info_tbl: [(cbsd,
                      label: block_cbsd_info
                      rep:StackRep [True, False, True, False, True]),
                     (cbsh,
                      label: a7_saF2_info
                      rep:HeapRep 1 ptrs 2 nonptrs {
                            Fun {arity: 2 fun_type: ArgSpec 4} }),
                     (cbsD,
                      label: block_cbsD_info
                      rep:StackRep [True, False, True, False, True])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cbsh:
          _saF3::I64 = R2;
          _saF2::P64 = R1;
          if ((Sp + -48) < SpLim) goto cbsi; else goto cbsj;
      cbsj:
          if (HpLim == 0) goto cbsi; else goto cbsk;
      cbsi:
          R2 = _saF3::I64;
          R1 = _saF2::P64;
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
      cbsk:
          I64[Sp - 48] = cbsd;
          R2 = System.Random.PCG.Class.sysRandom2_closure+2;
          R1 = System.Random.PCG.Class.sysRandom10_closure+1;
          I64[Sp - 40] = I64[_saF2::P64 + 14];
          P64[Sp - 32] = P64[_saF2::P64 + 6];
          I64[Sp - 24] = I64[_saF2::P64 + 22];
          P64[Sp - 16] = _saF2::P64;
          I64[Sp - 8] = _saF3::I64;
          Sp = Sp - 48;
          call stg_catch#(R2, R1) returns to cbsd, args: 8, res: 8, upd: 8;
      cbsd:
          _saEQ::I64 = I64[Sp + 8];
          _saF8::I64 = I64[Sp + 40] << 3;
          if (%MO_S_Ge_W64(_saF8::I64, 0)) goto cbsT; else goto cbsA;
      cbsT:
          if (%MO_S_Lt_W64(_saF8::I64,
                           _saEQ::I64)) goto cbsE; else goto cbsA;
      cbsE:
          I64[Sp] = cbsD;
          R1 = R1;
          I64[Sp + 8] = _saF8::I64;
          if (R1 & 7 != 0) goto cbsD; else goto cbsF;
      cbsF:
          call (I64[R1])(R1) returns to cbsD, args: 8, res: 8, upd: 8;
      cbsD:
          _saEZ::I64 = I64[Sp + 24];
          _saF2::P64 = P64[Sp + 32];
          _saF3::I64 = I64[Sp + 40];
          I64[P64[Sp + 16] + ((I64[Sp + 8] << 3) + 16)] = I64[R1 + 7];
          if (_saF3::I64 == _saEZ::I64) goto cbsS; else goto cbsR;
      cbsS:
          R1 = GHC.Tuple.()_closure+1;
          Sp = Sp + 48;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
      cbsR:
          R2 = _saF3::I64 + 1;
          R1 = _saF2::P64;
          Sp = Sp + 48;
          call a7_saF2_info(R2, R1) args: 8, res: 0, upd: 8;
      cbsA:
          R3 = _saEQ::I64;
          R2 = _saF8::I64;
          Sp = Sp + 48;
          call SkipList.newSL5_info(R3, R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:46.578772 UTC

a7_saF2_entry() //  [R2, R1]
        { info_tbl: [(cbsd,
                      label: block_cbsd_info
                      rep:StackRep [True, False, True, False, True]),
                     (cbsh,
                      label: a7_saF2_info
                      rep:HeapRep 1 ptrs 2 nonptrs {
                            Fun {arity: 2 fun_type: ArgSpec 4} }),
                     (cbsD,
                      label: block_cbsD_info
                      rep:StackRep [True, False, True, False, True])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cbsh:
          _saF3::I64 = R2;
          _saF2::P64 = R1;
          if ((Sp + -48) < SpLim) goto cbsi; else goto cbsj;
      cbsj:
          if (HpLim == 0) goto cbsi; else goto cbsk;
      cbsi:
          R2 = _saF3::I64;
          R1 = _saF2::P64;
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
      cbsk:
          I64[Sp - 48] = cbsd;
          R2 = System.Random.PCG.Class.sysRandom2_closure+2;
          R1 = System.Random.PCG.Class.sysRandom10_closure+1;
          I64[Sp - 40] = I64[_saF2::P64 + 14];
          P64[Sp - 32] = P64[_saF2::P64 + 6];
          I64[Sp - 24] = I64[_saF2::P64 + 22];
          P64[Sp - 16] = _saF2::P64;
          I64[Sp - 8] = _saF3::I64;
          Sp = Sp - 48;
          call stg_catch#(R2, R1) returns to cbsd, args: 8, res: 8, upd: 8;
      cbsd:
          _saEQ::I64 = I64[Sp + 8];
          _saF8::I64 = I64[Sp + 40] << 3;
          if (%MO_S_Lt_W64(_saF8::I64, 0)) goto cbsA; else goto cbsT;
      cbsT:
          if (%MO_S_Ge_W64(_saF8::I64,
                           _saEQ::I64)) goto cbsA; else goto cbsE;
      cbsA:
          R3 = _saEQ::I64;
          R2 = _saF8::I64;
          Sp = Sp + 48;
          call SkipList.newSL5_info(R3, R2) args: 8, res: 0, upd: 8;
      cbsE:
          I64[Sp] = cbsD;
          R1 = R1;
          I64[Sp + 8] = _saF8::I64;
          if (R1 & 7 != 0) goto cbsD; else goto cbsF;
      cbsF:
          call (I64[R1])(R1) returns to cbsD, args: 8, res: 8, upd: 8;
      cbsD:
          _saEZ::I64 = I64[Sp + 24];
          _saF2::P64 = P64[Sp + 32];
          _saF3::I64 = I64[Sp + 40];
          I64[P64[Sp + 16] + ((I64[Sp + 8] << 3) + 16)] = I64[R1 + 7];
          if (_saF3::I64 == _saEZ::I64) goto cbsS; else goto cbsR;
      cbsS:
          R1 = GHC.Tuple.()_closure+1;
          Sp = Sp + 48;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
      cbsR:
          R2 = _saF3::I64 + 1;
          R1 = _saF2::P64;
          Sp = Sp + 48;
          call a7_saF2_info(R2, R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:46.582483 UTC

{offset
  cbsW:
      if ((old + 0) - <highSp> < SpLim) goto cbsX; else goto cbsY;
  cbsY:
      if (HpLim == 0) goto cbsX; else goto cbtl;
  cbsX:
      R1 = SkipList.newSL4_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  cbtl:
      _saEP::I64 = %MO_SS_Conv_W32_W64(I32[enabled_capabilities]);
      _saEP::I64 = _saEP::I64;
      _cbrM::I64 = _saEP::I64 * 8;
      _saEQ::I64 = _cbrM::I64;
      _cbrP::I64 = %MO_S_Ge_W64(_saEQ::I64, 0);
      _saER::I64 = _cbrP::I64;
      switch [0 .. 1] _saER::I64 {
          case 0 : goto cbt1;
          case 1 : goto cbt6;
      }
  cbt6:
      _cbrV::I64 = _saEQ::I64 * 8;
      _saEV::I64 = _cbrV::I64;
      I64[(young<cbrY> + 8)] = cbrY;
      R1 = _saEV::I64;
      call stg_newByteArray#(R1) returns to cbrY, args: 8, res: 8, upd: 8;
  cbrY:
      _saEY::P64 = R1;
      Hp = Hp + 32;
      if (Hp > HpLim) goto cbt9; else goto cbt8;
  cbt9:
      HpAlloc = 32;
      R1 = _saEY::P64;
      call stg_gc_unpt_r1(R1) returns to cbrY, args: 8, res: 8, upd: 8;
  cbt8:
      _cbs0::I64 = _saEP::I64 - 1;
      _saEZ::I64 = _cbs0::I64;
      _cbs3::I64 = %MO_S_Gt_W64(0, _saEZ::I64);
      _saF0::I64 = _cbs3::I64;
      switch [0 .. 1] _saF0::I64 {
          case 0 : goto cbte;
          case 1 : goto cbtk;
      }
  cbtk:
      I64[Hp - 24] = Data.Vector.Primitive.Mutable.MVector_con_info;
      P64[Hp - 16] = _saEY::P64;
      I64[Hp - 8] = 0;
      I64[Hp] = _saEQ::I64;
      _cbtj::P64 = Hp - 23;
      R1 = _cbtj::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
  cbte:
      _cbs8::P64 = Hp - 22;
      I64[Hp - 24] = a7_saF2_info;
      P64[Hp - 16] = _saEY::P64;
      I64[Hp - 8] = _saEQ::I64;
      I64[Hp] = _saEZ::I64;
      I64[(young<cbta> + 8)] = cbta;
      R2 = 0;
      R1 = _cbs8::P64;
      call a7_saF2_info(R2, R1) returns to cbta, args: 8, res: 8, upd: 8;
  cbta:
      _saFn::P64 = R1;
      Hp = Hp + 32;
      if (Hp > HpLim) goto cbth; else goto cbtg;
  cbth:
      HpAlloc = 32;
      R1 = _saFn::P64;
      call stg_gc_unpt_r1(R1) returns to cbta, args: 8, res: 8, upd: 8;
  cbtg:
      I64[Hp - 24] = Data.Vector.Primitive.Mutable.MVector_con_info;
      P64[Hp - 16] = _saEY::P64;
      I64[Hp - 8] = 0;
      I64[Hp] = _saEQ::I64;
      _cbtc::P64 = Hp - 23;
      R1 = _cbtc::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
  cbt1:
      I64[(young<cbsZ> + 8)] = cbsZ;
      R2 = _saEQ::I64;
      call Data.Vector.Internal.Check.checkLength_msg#_info(R2) returns to cbsZ, args: 8, res: 8, upd: 8;
  cbsZ:
      _saET::P64 = R1;
      R6 = _saET::P64;
      R5 = SkipList.newSL6_closure;
      R4 = Data.Vector.Internal.Check.Bounds_closure+1;
      R3 = SkipList.newSL7_closure+1;
      R2 = SkipList.newSL8_closure;
      call Data.Vector.Internal.Check.checkError_info(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:46.587857 UTC

{offset
  cbsW:
      if ((old + 0) - <highSp> < SpLim) goto cbsX; else goto cbsY;
  cbsY:
      if (HpLim == 0) goto cbsX; else goto cbtl;
  cbsX:
      R1 = SkipList.newSL4_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  cbtl:
      _saEP::I64 = %MO_SS_Conv_W32_W64(I32[enabled_capabilities]);
      _saEP::I64 = _saEP::I64;
      _cbrM::I64 = _saEP::I64 * 8;
      _saEQ::I64 = _cbrM::I64;
      _cbrP::I64 = %MO_S_Ge_W64(_saEQ::I64, 0);
      _saER::I64 = _cbrP::I64;
      switch [0 .. 1] _saER::I64 {
          case 0 : goto cbt1;
          case 1 : goto cbt6;
      }
  cbt6:
      _cbrV::I64 = _saEQ::I64 * 8;
      _saEV::I64 = _cbrV::I64;
      I64[(young<cbrY> + 8)] = cbrY;
      R1 = _saEV::I64;
      call stg_newByteArray#(R1) returns to cbrY, args: 8, res: 8, upd: 8;
  cbrY:
      _saEY::P64 = R1;
      Hp = Hp + 32;
      if (Hp > HpLim) goto cbt9; else goto cbt8;
  cbt9:
      HpAlloc = 32;
      R1 = _saEY::P64;
      call stg_gc_unpt_r1(R1) returns to cbrY, args: 8, res: 8, upd: 8;
  cbt8:
      _cbs0::I64 = _saEP::I64 - 1;
      _saEZ::I64 = _cbs0::I64;
      _cbs3::I64 = %MO_S_Gt_W64(0, _saEZ::I64);
      _saF0::I64 = _cbs3::I64;
      switch [0 .. 1] _saF0::I64 {
          case 0 : goto cbte;
          case 1 : goto cbtk;
      }
  cbtk:
      I64[Hp - 24] = Data.Vector.Primitive.Mutable.MVector_con_info;
      P64[Hp - 16] = _saEY::P64;
      I64[Hp - 8] = 0;
      I64[Hp] = _saEQ::I64;
      _cbtj::P64 = Hp - 23;
      R1 = _cbtj::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
  cbte:
      _cbs8::P64 = Hp - 22;
      I64[Hp - 24] = a7_saF2_info;
      P64[Hp - 16] = _saEY::P64;
      I64[Hp - 8] = _saEQ::I64;
      I64[Hp] = _saEZ::I64;
      I64[(young<cbta> + 8)] = cbta;
      R2 = 0;
      R1 = _cbs8::P64;
      call a7_saF2_info(R2, R1) returns to cbta, args: 8, res: 8, upd: 8;
  cbta:
      _saFn::P64 = R1;
      Hp = Hp + 32;
      if (Hp > HpLim) goto cbth; else goto cbtg;
  cbth:
      HpAlloc = 32;
      R1 = _saFn::P64;
      call stg_gc_unpt_r1(R1) returns to cbta, args: 8, res: 8, upd: 8;
  cbtg:
      I64[Hp - 24] = Data.Vector.Primitive.Mutable.MVector_con_info;
      P64[Hp - 16] = _saEY::P64;
      I64[Hp - 8] = 0;
      I64[Hp] = _saEQ::I64;
      _cbtc::P64 = Hp - 23;
      R1 = _cbtc::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
  cbt1:
      I64[(young<cbsZ> + 8)] = cbsZ;
      R2 = _saEQ::I64;
      call Data.Vector.Internal.Check.checkLength_msg#_info(R2) returns to cbsZ, args: 8, res: 8, upd: 8;
  cbsZ:
      _saET::P64 = R1;
      R6 = _saET::P64;
      R5 = SkipList.newSL6_closure;
      R4 = Data.Vector.Internal.Check.Bounds_closure+1;
      R3 = SkipList.newSL7_closure+1;
      R2 = SkipList.newSL8_closure;
      call Data.Vector.Internal.Check.checkError_info(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:46.591951 UTC

{offset
  cbsW:
      if ((old + 0) - <highSp> < SpLim) goto cbsX; else goto cbsY;
  cbsY:
      if (HpLim == 0) goto cbsX; else goto cbtl;
  cbsX:
      R1 = SkipList.newSL4_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  cbtl:
      _saEP::I64 = %MO_SS_Conv_W32_W64(I32[enabled_capabilities]);
      _saEP::I64 = _saEP::I64;
      _cbrM::I64 = _saEP::I64 * 8;
      _saEQ::I64 = _cbrM::I64;
      _cbrP::I64 = %MO_S_Ge_W64(_saEQ::I64, 0);
      _saER::I64 = _cbrP::I64;
      if (_saER::I64 != 0) goto cbt6; else goto cbt1;
  cbt6:
      _cbrV::I64 = _saEQ::I64 * 8;
      _saEV::I64 = _cbrV::I64;
      I64[(young<cbrY> + 8)] = cbrY;
      R1 = _saEV::I64;
      call stg_newByteArray#(R1) returns to cbrY, args: 8, res: 8, upd: 8;
  cbrY:
      _saEY::P64 = R1;
      Hp = Hp + 32;
      if (Hp > HpLim) goto cbt9; else goto cbt8;
  cbt9:
      HpAlloc = 32;
      R1 = _saEY::P64;
      call stg_gc_unpt_r1(R1) returns to cbrY, args: 8, res: 8, upd: 8;
  cbt8:
      _cbs0::I64 = _saEP::I64 - 1;
      _saEZ::I64 = _cbs0::I64;
      _cbs3::I64 = %MO_S_Gt_W64(0, _saEZ::I64);
      _saF0::I64 = _cbs3::I64;
      if (_saF0::I64 != 0) goto cbtk; else goto cbte;
  cbtk:
      I64[Hp - 24] = Data.Vector.Primitive.Mutable.MVector_con_info;
      P64[Hp - 16] = _saEY::P64;
      I64[Hp - 8] = 0;
      I64[Hp] = _saEQ::I64;
      _cbtj::P64 = Hp - 23;
      R1 = _cbtj::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
  cbte:
      _cbs8::P64 = Hp - 22;
      I64[Hp - 24] = a7_saF2_info;
      P64[Hp - 16] = _saEY::P64;
      I64[Hp - 8] = _saEQ::I64;
      I64[Hp] = _saEZ::I64;
      I64[(young<cbta> + 8)] = cbta;
      R2 = 0;
      R1 = _cbs8::P64;
      call a7_saF2_info(R2, R1) returns to cbta, args: 8, res: 8, upd: 8;
  cbta:
      _saFn::P64 = R1;
      Hp = Hp + 32;
      if (Hp > HpLim) goto cbth; else goto cbtg;
  cbth:
      HpAlloc = 32;
      R1 = _saFn::P64;
      call stg_gc_unpt_r1(R1) returns to cbta, args: 8, res: 8, upd: 8;
  cbtg:
      I64[Hp - 24] = Data.Vector.Primitive.Mutable.MVector_con_info;
      P64[Hp - 16] = _saEY::P64;
      I64[Hp - 8] = 0;
      I64[Hp] = _saEQ::I64;
      _cbtc::P64 = Hp - 23;
      R1 = _cbtc::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
  cbt1:
      I64[(young<cbsZ> + 8)] = cbsZ;
      R2 = _saEQ::I64;
      call Data.Vector.Internal.Check.checkLength_msg#_info(R2) returns to cbsZ, args: 8, res: 8, upd: 8;
  cbsZ:
      _saET::P64 = R1;
      R6 = _saET::P64;
      R5 = SkipList.newSL6_closure;
      R4 = Data.Vector.Internal.Check.Bounds_closure+1;
      R3 = SkipList.newSL7_closure+1;
      R2 = SkipList.newSL8_closure;
      call Data.Vector.Internal.Check.checkError_info(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:46.596313 UTC

{offset
  cbsW:
      if ((Sp + 8) - 32 < SpLim) goto cbsX; else goto cbsY;
  cbsY:
      if (HpLim == 0) goto cbsX; else goto cbtl;
  cbsX:
      R1 = SkipList.newSL4_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  cbtl:
      _saEP::I64 = %MO_SS_Conv_W32_W64(I32[enabled_capabilities]);
      _saEP::I64 = _saEP::I64;
      _cbrM::I64 = _saEP::I64 * 8;
      _saEQ::I64 = _cbrM::I64;
      _cbrP::I64 = %MO_S_Ge_W64(_saEQ::I64, 0);
      _saER::I64 = _cbrP::I64;
      if (_saER::I64 != 0) goto cbt6; else goto cbt1;
  cbt6:
      _cbrV::I64 = _saEQ::I64 * 8;
      _saEV::I64 = _cbrV::I64;
      I64[Sp - 24] = cbrY;
      R1 = _saEV::I64;
      I64[Sp - 16] = _saEP::I64;
      I64[Sp - 8] = _saEQ::I64;
      Sp = Sp - 24;
      call stg_newByteArray#(R1) returns to cbrY, args: 8, res: 8, upd: 8;
  cbrY:
      _saEP::I64 = I64[Sp + 8];
      _saEQ::I64 = I64[Sp + 16];
      _saEY::P64 = R1;
      Hp = Hp + 32;
      if (Hp > HpLim) goto cbt9; else goto cbt8;
  cbt9:
      HpAlloc = 32;
      R1 = _saEY::P64;
      call stg_gc_unpt_r1(R1) returns to cbrY, args: 8, res: 8, upd: 8;
  cbt8:
      _cbs0::I64 = _saEP::I64 - 1;
      _saEZ::I64 = _cbs0::I64;
      _cbs3::I64 = %MO_S_Gt_W64(0, _saEZ::I64);
      _saF0::I64 = _cbs3::I64;
      if (_saF0::I64 != 0) goto cbtk; else goto cbte;
  cbtk:
      I64[Hp - 24] = Data.Vector.Primitive.Mutable.MVector_con_info;
      P64[Hp - 16] = _saEY::P64;
      I64[Hp - 8] = 0;
      I64[Hp] = _saEQ::I64;
      _cbtj::P64 = Hp - 23;
      R1 = _cbtj::P64;
      Sp = Sp + 24;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
  cbte:
      _cbs8::P64 = Hp - 22;
      I64[Hp - 24] = a7_saF2_info;
      P64[Hp - 16] = _saEY::P64;
      I64[Hp - 8] = _saEQ::I64;
      I64[Hp] = _saEZ::I64;
      I64[Sp] = cbta;
      R2 = 0;
      R1 = _cbs8::P64;
      P64[Sp + 8] = _saEY::P64;
      call a7_saF2_info(R2, R1) returns to cbta, args: 8, res: 8, upd: 8;
  cbta:
      _saEQ::I64 = I64[Sp + 16];
      _saEY::P64 = P64[Sp + 8];
      _saFn::P64 = R1;
      Hp = Hp + 32;
      if (Hp > HpLim) goto cbth; else goto cbtg;
  cbth:
      HpAlloc = 32;
      R1 = _saFn::P64;
      call stg_gc_unpt_r1(R1) returns to cbta, args: 8, res: 8, upd: 8;
  cbtg:
      I64[Hp - 24] = Data.Vector.Primitive.Mutable.MVector_con_info;
      P64[Hp - 16] = _saEY::P64;
      I64[Hp - 8] = 0;
      I64[Hp] = _saEQ::I64;
      _cbtc::P64 = Hp - 23;
      R1 = _cbtc::P64;
      Sp = Sp + 24;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
  cbt1:
      I64[Sp - 8] = cbsZ;
      R2 = _saEQ::I64;
      Sp = Sp - 8;
      call Data.Vector.Internal.Check.checkLength_msg#_info(R2) returns to cbsZ, args: 8, res: 8, upd: 8;
  cbsZ:
      _saET::P64 = R1;
      R6 = _saET::P64;
      R5 = SkipList.newSL6_closure;
      R4 = Data.Vector.Internal.Check.Bounds_closure+1;
      R3 = SkipList.newSL7_closure+1;
      R2 = SkipList.newSL8_closure;
      Sp = Sp + 8;
      call Data.Vector.Internal.Check.checkError_info(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:46.600893 UTC

{offset
  cbsW:
      if ((Sp + -24) < SpLim) goto cbsX; else goto cbsY;
  cbsY:
      if (HpLim == 0) goto cbsX; else goto cbtl;
  cbsX:
      R1 = SkipList.newSL4_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  cbtl:
      _saEP::I64 = %MO_SS_Conv_W32_W64(I32[enabled_capabilities]);
      _saEQ::I64 = _saEP::I64 << 3;
      if (%MO_S_Ge_W64(_saEQ::I64, 0)) goto cbt6; else goto cbt1;
  cbt6:
      I64[Sp - 24] = cbrY;
      R1 = _saEQ::I64 << 3;
      I64[Sp - 16] = _saEP::I64;
      I64[Sp - 8] = _saEQ::I64;
      Sp = Sp - 24;
      call stg_newByteArray#(R1) returns to cbrY, args: 8, res: 8, upd: 8;
  cbrY:
      Hp = Hp + 32;
      if (Hp > HpLim) goto cbt9; else goto cbt8;
  cbt9:
      HpAlloc = 32;
      R1 = R1;
      call stg_gc_unpt_r1(R1) returns to cbrY, args: 8, res: 8, upd: 8;
  cbt8:
      _saEQ::I64 = I64[Sp + 16];
      _saEZ::I64 = I64[Sp + 8] - 1;
      if (%MO_S_Gt_W64(0, _saEZ::I64)) goto cbtk; else goto cbte;
  cbtk:
      I64[Hp - 24] = Data.Vector.Primitive.Mutable.MVector_con_info;
      P64[Hp - 16] = R1;
      I64[Hp - 8] = 0;
      I64[Hp] = _saEQ::I64;
      R1 = Hp - 23;
      Sp = Sp + 24;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
  cbte:
      I64[Hp - 24] = a7_saF2_info;
      P64[Hp - 16] = R1;
      I64[Hp - 8] = _saEQ::I64;
      I64[Hp] = _saEZ::I64;
      I64[Sp] = cbta;
      R2 = 0;
      _saEY::P64 = R1;
      R1 = Hp - 22;
      P64[Sp + 8] = _saEY::P64;
      call a7_saF2_info(R2, R1) returns to cbta, args: 8, res: 8, upd: 8;
  cbta:
      Hp = Hp + 32;
      if (Hp > HpLim) goto cbth; else goto cbtg;
  cbth:
      HpAlloc = 32;
      R1 = R1;
      call stg_gc_unpt_r1(R1) returns to cbta, args: 8, res: 8, upd: 8;
  cbtg:
      I64[Hp - 24] = Data.Vector.Primitive.Mutable.MVector_con_info;
      P64[Hp - 16] = P64[Sp + 8];
      I64[Hp - 8] = 0;
      I64[Hp] = I64[Sp + 16];
      R1 = Hp - 23;
      Sp = Sp + 24;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
  cbt1:
      I64[Sp - 8] = cbsZ;
      R2 = _saEQ::I64;
      Sp = Sp - 8;
      call Data.Vector.Internal.Check.checkLength_msg#_info(R2) returns to cbsZ, args: 8, res: 8, upd: 8;
  cbsZ:
      R6 = R1;
      R5 = SkipList.newSL6_closure;
      R4 = Data.Vector.Internal.Check.Bounds_closure+1;
      R3 = SkipList.newSL7_closure+1;
      R2 = SkipList.newSL8_closure;
      Sp = Sp + 8;
      call Data.Vector.Internal.Check.checkError_info(R6,
                                                      R5,
                                                      R4,
                                                      R3,
                                                      R2) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:46.605281 UTC

[(cbrY, {a7_saF2_closure}),
 (cbsW,
  {SkipList.newSL4_closure, SkipList.newSL6_closure,
   Data.Vector.Internal.Check.checkError_closure,
   SkipList.newSL8_closure, a7_saF2_closure}),
 (cbsX, {SkipList.newSL4_closure}),
 (cbsY,
  {SkipList.newSL4_closure, SkipList.newSL6_closure,
   Data.Vector.Internal.Check.checkError_closure,
   SkipList.newSL8_closure, a7_saF2_closure}),
 (cbsZ,
  {SkipList.newSL6_closure,
   Data.Vector.Internal.Check.checkError_closure,
   SkipList.newSL8_closure}),
 (cbt1,
  {SkipList.newSL6_closure,
   Data.Vector.Internal.Check.checkError_closure,
   SkipList.newSL8_closure}),
 (cbt6, {a7_saF2_closure}), (cbt8, {a7_saF2_closure}),
 (cbt9, {a7_saF2_closure}), (cbta, {}), (cbte, {a7_saF2_closure}),
 (cbtg, {}), (cbth, {}), (cbtk, {}),
 (cbtl,
  {SkipList.newSL6_closure,
   Data.Vector.Internal.Check.checkError_closure,
   SkipList.newSL8_closure, a7_saF2_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:46.606806 UTC

SkipList.newSL4_entry() //  []
        { info_tbl: [(cbrY,
                      label: block_cbrY_info
                      rep:StackRep [True, True]),
                     (cbsW,
                      label: SkipList.newSL4_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} }),
                     (cbsZ,
                      label: block_cbsZ_info
                      rep:StackRep []),
                     (cbta,
                      label: block_cbta_info
                      rep:StackRep [False, True])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cbsW:
          if ((Sp + -24) < SpLim) goto cbsX; else goto cbsY;
      cbsY:
          if (HpLim == 0) goto cbsX; else goto cbtl;
      cbsX:
          R1 = SkipList.newSL4_closure;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
      cbtl:
          _saEP::I64 = %MO_SS_Conv_W32_W64(I32[enabled_capabilities]);
          _saEQ::I64 = _saEP::I64 << 3;
          if (%MO_S_Ge_W64(_saEQ::I64, 0)) goto cbt6; else goto cbt1;
      cbt6:
          I64[Sp - 24] = cbrY;
          R1 = _saEQ::I64 << 3;
          I64[Sp - 16] = _saEP::I64;
          I64[Sp - 8] = _saEQ::I64;
          Sp = Sp - 24;
          call stg_newByteArray#(R1) returns to cbrY, args: 8, res: 8, upd: 8;
      cbrY:
          Hp = Hp + 32;
          if (Hp > HpLim) goto cbt9; else goto cbt8;
      cbt9:
          HpAlloc = 32;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to cbrY, args: 8, res: 8, upd: 8;
      cbt8:
          _saEQ::I64 = I64[Sp + 16];
          _saEZ::I64 = I64[Sp + 8] - 1;
          if (%MO_S_Gt_W64(0, _saEZ::I64)) goto cbtk; else goto cbte;
      cbtk:
          I64[Hp - 24] = Data.Vector.Primitive.Mutable.MVector_con_info;
          P64[Hp - 16] = R1;
          I64[Hp - 8] = 0;
          I64[Hp] = _saEQ::I64;
          R1 = Hp - 23;
          Sp = Sp + 24;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
      cbte:
          I64[Hp - 24] = a7_saF2_info;
          P64[Hp - 16] = R1;
          I64[Hp - 8] = _saEQ::I64;
          I64[Hp] = _saEZ::I64;
          I64[Sp] = cbta;
          R2 = 0;
          _saEY::P64 = R1;
          R1 = Hp - 22;
          P64[Sp + 8] = _saEY::P64;
          call a7_saF2_info(R2, R1) returns to cbta, args: 8, res: 8, upd: 8;
      cbta:
          Hp = Hp + 32;
          if (Hp > HpLim) goto cbth; else goto cbtg;
      cbth:
          HpAlloc = 32;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to cbta, args: 8, res: 8, upd: 8;
      cbtg:
          I64[Hp - 24] = Data.Vector.Primitive.Mutable.MVector_con_info;
          P64[Hp - 16] = P64[Sp + 8];
          I64[Hp - 8] = 0;
          I64[Hp] = I64[Sp + 16];
          R1 = Hp - 23;
          Sp = Sp + 24;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
      cbt1:
          I64[Sp - 8] = cbsZ;
          R2 = _saEQ::I64;
          Sp = Sp - 8;
          call Data.Vector.Internal.Check.checkLength_msg#_info(R2) returns to cbsZ, args: 8, res: 8, upd: 8;
      cbsZ:
          R6 = R1;
          R5 = SkipList.newSL6_closure;
          R4 = Data.Vector.Internal.Check.Bounds_closure+1;
          R3 = SkipList.newSL7_closure+1;
          R2 = SkipList.newSL8_closure;
          Sp = Sp + 8;
          call Data.Vector.Internal.Check.checkError_info(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:46.611303 UTC

SkipList.newSL4_entry() //  []
        { info_tbl: [(cbrY,
                      label: block_cbrY_info
                      rep:StackRep [True, True]),
                     (cbsW,
                      label: SkipList.newSL4_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} }),
                     (cbsZ,
                      label: block_cbsZ_info
                      rep:StackRep []),
                     (cbta,
                      label: block_cbta_info
                      rep:StackRep [False, True])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cbsW:
          if ((Sp + -24) < SpLim) goto cbsX; else goto cbsY;
      cbsY:
          if (HpLim == 0) goto cbsX; else goto cbtl;
      cbsX:
          R1 = SkipList.newSL4_closure;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
      cbtl:
          _saEP::I64 = %MO_SS_Conv_W32_W64(I32[enabled_capabilities]);
          _saEQ::I64 = _saEP::I64 << 3;
          if (%MO_S_Ge_W64(_saEQ::I64, 0)) goto cbt6; else goto cbt1;
      cbt6:
          I64[Sp - 24] = cbrY;
          R1 = _saEQ::I64 << 3;
          I64[Sp - 16] = _saEP::I64;
          I64[Sp - 8] = _saEQ::I64;
          Sp = Sp - 24;
          call stg_newByteArray#(R1) returns to cbrY, args: 8, res: 8, upd: 8;
      cbrY:
          Hp = Hp + 32;
          if (Hp > HpLim) goto cbt9; else goto cbt8;
      cbt9:
          HpAlloc = 32;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to cbrY, args: 8, res: 8, upd: 8;
      cbt8:
          _saEQ::I64 = I64[Sp + 16];
          _saEZ::I64 = I64[Sp + 8] - 1;
          if (%MO_S_Gt_W64(0, _saEZ::I64)) goto cbtk; else goto cbte;
      cbtk:
          I64[Hp - 24] = Data.Vector.Primitive.Mutable.MVector_con_info;
          P64[Hp - 16] = R1;
          I64[Hp - 8] = 0;
          I64[Hp] = _saEQ::I64;
          R1 = Hp - 23;
          Sp = Sp + 24;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
      cbte:
          I64[Hp - 24] = a7_saF2_info;
          P64[Hp - 16] = R1;
          I64[Hp - 8] = _saEQ::I64;
          I64[Hp] = _saEZ::I64;
          I64[Sp] = cbta;
          R2 = 0;
          _saEY::P64 = R1;
          R1 = Hp - 22;
          P64[Sp + 8] = _saEY::P64;
          call a7_saF2_info(R2, R1) returns to cbta, args: 8, res: 8, upd: 8;
      cbta:
          Hp = Hp + 32;
          if (Hp > HpLim) goto cbth; else goto cbtg;
      cbth:
          HpAlloc = 32;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to cbta, args: 8, res: 8, upd: 8;
      cbtg:
          I64[Hp - 24] = Data.Vector.Primitive.Mutable.MVector_con_info;
          P64[Hp - 16] = P64[Sp + 8];
          I64[Hp - 8] = 0;
          I64[Hp] = I64[Sp + 16];
          R1 = Hp - 23;
          Sp = Sp + 24;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
      cbt1:
          I64[Sp - 8] = cbsZ;
          R2 = _saEQ::I64;
          Sp = Sp - 8;
          call Data.Vector.Internal.Check.checkLength_msg#_info(R2) returns to cbsZ, args: 8, res: 8, upd: 8;
      cbsZ:
          R6 = R1;
          R5 = SkipList.newSL6_closure;
          R4 = Data.Vector.Internal.Check.Bounds_closure+1;
          R3 = SkipList.newSL7_closure+1;
          R2 = SkipList.newSL8_closure;
          Sp = Sp + 8;
          call Data.Vector.Internal.Check.checkError_info(R6,
                                                          R5,
                                                          R4,
                                                          R3,
                                                          R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:46.615809 UTC

[section "data" {
     SkipList.newSL4_closure:
         const SkipList.newSL4_info;
         const 0;
 },
 a7_saF2_entry() //  [R2, R1]
         { info_tbl: [(cbsd,
                       label: block_cbsd_info
                       rep:StackRep [True, False, True, False, True]),
                      (cbsh,
                       label: a7_saF2_info
                       rep:HeapRep 1 ptrs 2 nonptrs {
                             Fun {arity: 2 fun_type: ArgSpec 4} }),
                      (cbsD,
                       label: block_cbsD_info
                       rep:StackRep [True, False, True, False, True])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbsh:
           _saF3::I64 = R2;
           _saF2::P64 = R1;
           if ((Sp + -48) < SpLim) goto cbsi; else goto cbsj;
       cbsj:
           if (HpLim == 0) goto cbsi; else goto cbsk;
       cbsi:
           R2 = _saF3::I64;
           R1 = _saF2::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbsk:
           I64[Sp - 48] = cbsd;
           R2 = System.Random.PCG.Class.sysRandom2_closure+2;
           R1 = System.Random.PCG.Class.sysRandom10_closure+1;
           I64[Sp - 40] = I64[_saF2::P64 + 14];
           P64[Sp - 32] = P64[_saF2::P64 + 6];
           I64[Sp - 24] = I64[_saF2::P64 + 22];
           P64[Sp - 16] = _saF2::P64;
           I64[Sp - 8] = _saF3::I64;
           Sp = Sp - 48;
           call stg_catch#(R2, R1) returns to cbsd, args: 8, res: 8, upd: 8;
       cbsd:
           _saEQ::I64 = I64[Sp + 8];
           _saF8::I64 = I64[Sp + 40] << 3;
           if (%MO_S_Lt_W64(_saF8::I64, 0)) goto cbsA; else goto cbsT;
       cbsT:
           if (%MO_S_Ge_W64(_saF8::I64,
                            _saEQ::I64)) goto cbsA; else goto cbsE;
       cbsA:
           R3 = _saEQ::I64;
           R2 = _saF8::I64;
           Sp = Sp + 48;
           call SkipList.newSL5_info(R3, R2) args: 8, res: 0, upd: 8;
       cbsE:
           I64[Sp] = cbsD;
           R1 = R1;
           I64[Sp + 8] = _saF8::I64;
           if (R1 & 7 != 0) goto cbsD; else goto cbsF;
       cbsF:
           call (I64[R1])(R1) returns to cbsD, args: 8, res: 8, upd: 8;
       cbsD:
           _saEZ::I64 = I64[Sp + 24];
           _saF2::P64 = P64[Sp + 32];
           _saF3::I64 = I64[Sp + 40];
           I64[P64[Sp + 16] + ((I64[Sp + 8] << 3) + 16)] = I64[R1 + 7];
           if (_saF3::I64 == _saEZ::I64) goto cbsS; else goto cbsR;
       cbsS:
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 48;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
       cbsR:
           R2 = _saF3::I64 + 1;
           R1 = _saF2::P64;
           Sp = Sp + 48;
           call a7_saF2_info(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 SkipList.newSL4_entry() //  []
         { info_tbl: [(cbrY,
                       label: block_cbrY_info
                       rep:StackRep [True, True]),
                      (cbsW,
                       label: SkipList.newSL4_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} }),
                      (cbsZ,
                       label: block_cbsZ_info
                       rep:StackRep []),
                      (cbta,
                       label: block_cbta_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbsW:
           if ((Sp + -24) < SpLim) goto cbsX; else goto cbsY;
       cbsY:
           if (HpLim == 0) goto cbsX; else goto cbtl;
       cbsX:
           R1 = SkipList.newSL4_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbtl:
           _saEP::I64 = %MO_SS_Conv_W32_W64(I32[enabled_capabilities]);
           _saEQ::I64 = _saEP::I64 << 3;
           if (%MO_S_Ge_W64(_saEQ::I64, 0)) goto cbt6; else goto cbt1;
       cbt6:
           I64[Sp - 24] = cbrY;
           R1 = _saEQ::I64 << 3;
           I64[Sp - 16] = _saEP::I64;
           I64[Sp - 8] = _saEQ::I64;
           Sp = Sp - 24;
           call stg_newByteArray#(R1) returns to cbrY, args: 8, res: 8, upd: 8;
       cbrY:
           Hp = Hp + 32;
           if (Hp > HpLim) goto cbt9; else goto cbt8;
       cbt9:
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to cbrY, args: 8, res: 8, upd: 8;
       cbt8:
           _saEQ::I64 = I64[Sp + 16];
           _saEZ::I64 = I64[Sp + 8] - 1;
           if (%MO_S_Gt_W64(0, _saEZ::I64)) goto cbtk; else goto cbte;
       cbtk:
           I64[Hp - 24] = Data.Vector.Primitive.Mutable.MVector_con_info;
           P64[Hp - 16] = R1;
           I64[Hp - 8] = 0;
           I64[Hp] = _saEQ::I64;
           R1 = Hp - 23;
           Sp = Sp + 24;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
       cbte:
           I64[Hp - 24] = a7_saF2_info;
           P64[Hp - 16] = R1;
           I64[Hp - 8] = _saEQ::I64;
           I64[Hp] = _saEZ::I64;
           I64[Sp] = cbta;
           R2 = 0;
           _saEY::P64 = R1;
           R1 = Hp - 22;
           P64[Sp + 8] = _saEY::P64;
           call a7_saF2_info(R2, R1) returns to cbta, args: 8, res: 8, upd: 8;
       cbta:
           Hp = Hp + 32;
           if (Hp > HpLim) goto cbth; else goto cbtg;
       cbth:
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to cbta, args: 8, res: 8, upd: 8;
       cbtg:
           I64[Hp - 24] = Data.Vector.Primitive.Mutable.MVector_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           I64[Hp - 8] = 0;
           I64[Hp] = I64[Sp + 16];
           R1 = Hp - 23;
           Sp = Sp + 24;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
       cbt1:
           I64[Sp - 8] = cbsZ;
           R2 = _saEQ::I64;
           Sp = Sp - 8;
           call Data.Vector.Internal.Check.checkLength_msg#_info(R2) returns to cbsZ, args: 8, res: 8, upd: 8;
       cbsZ:
           R6 = R1;
           R5 = SkipList.newSL6_closure;
           R4 = Data.Vector.Internal.Check.Bounds_closure+1;
           R3 = SkipList.newSL7_closure+1;
           R2 = SkipList.newSL8_closure;
           Sp = Sp + 8;
           call Data.Vector.Internal.Check.checkError_info(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:46.624422 UTC

[section "data" {
     SkipList.newSL4_closure:
         const SkipList.newSL4_info;
         const 0;
 },
 a7_saF2_entry() //  [R2, R1]
         { info_tbl: [(cbsd,
                       label: block_cbsd_info
                       rep:StackRep [True, False, True, False, True]),
                      (cbsh,
                       label: a7_saF2_info
                       rep:HeapRep 1 ptrs 2 nonptrs {
                             Fun {arity: 2 fun_type: ArgSpec 4} }),
                      (cbsD,
                       label: block_cbsD_info
                       rep:StackRep [True, False, True, False, True])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbsh:
           _saF3::I64 = R2;
           _saF2::P64 = R1;
           if ((Sp + -48) < SpLim) goto cbsi; else goto cbsj;
       cbsj:
           if (HpLim == 0) goto cbsi; else goto cbsk;
       cbsi:
           R2 = _saF3::I64;
           R1 = _saF2::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbsk:
           I64[Sp - 48] = cbsd;
           R2 = System.Random.PCG.Class.sysRandom2_closure+2;
           R1 = System.Random.PCG.Class.sysRandom10_closure+1;
           I64[Sp - 40] = I64[_saF2::P64 + 14];
           P64[Sp - 32] = P64[_saF2::P64 + 6];
           I64[Sp - 24] = I64[_saF2::P64 + 22];
           P64[Sp - 16] = _saF2::P64;
           I64[Sp - 8] = _saF3::I64;
           Sp = Sp - 48;
           call stg_catch#(R2, R1) returns to cbsd, args: 8, res: 8, upd: 8;
       cbsd:
           _saEQ::I64 = I64[Sp + 8];
           _saF8::I64 = I64[Sp + 40] << 3;
           if (%MO_S_Lt_W64(_saF8::I64, 0)) goto cbsA; else goto cbsT;
       cbsT:
           if (%MO_S_Ge_W64(_saF8::I64,
                            _saEQ::I64)) goto cbsA; else goto cbsE;
       cbsA:
           R3 = _saEQ::I64;
           R2 = _saF8::I64;
           Sp = Sp + 48;
           call SkipList.newSL5_info(R3, R2) args: 8, res: 0, upd: 8;
       cbsE:
           I64[Sp] = cbsD;
           R1 = R1;
           I64[Sp + 8] = _saF8::I64;
           if (R1 & 7 != 0) goto cbsD; else goto cbsF;
       cbsF:
           call (I64[R1])(R1) returns to cbsD, args: 8, res: 8, upd: 8;
       cbsD:
           _saEZ::I64 = I64[Sp + 24];
           _saF2::P64 = P64[Sp + 32];
           _saF3::I64 = I64[Sp + 40];
           I64[P64[Sp + 16] + ((I64[Sp + 8] << 3) + 16)] = I64[R1 + 7];
           if (_saF3::I64 == _saEZ::I64) goto cbsS; else goto cbsR;
       cbsS:
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 48;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
       cbsR:
           R2 = _saF3::I64 + 1;
           R1 = _saF2::P64;
           Sp = Sp + 48;
           call a7_saF2_info(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 SkipList.newSL4_entry() //  []
         { info_tbl: [(cbrY,
                       label: block_cbrY_info
                       rep:StackRep [True, True]),
                      (cbsW,
                       label: SkipList.newSL4_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} }),
                      (cbsZ,
                       label: block_cbsZ_info
                       rep:StackRep []),
                      (cbta,
                       label: block_cbta_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbsW:
           if ((Sp + -24) < SpLim) goto cbsX; else goto cbsY;
       cbsY:
           if (HpLim == 0) goto cbsX; else goto cbtl;
       cbsX:
           R1 = SkipList.newSL4_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbtl:
           _saEP::I64 = %MO_SS_Conv_W32_W64(I32[enabled_capabilities]);
           _saEQ::I64 = _saEP::I64 << 3;
           if (%MO_S_Ge_W64(_saEQ::I64, 0)) goto cbt6; else goto cbt1;
       cbt6:
           I64[Sp - 24] = cbrY;
           R1 = _saEQ::I64 << 3;
           I64[Sp - 16] = _saEP::I64;
           I64[Sp - 8] = _saEQ::I64;
           Sp = Sp - 24;
           call stg_newByteArray#(R1) returns to cbrY, args: 8, res: 8, upd: 8;
       cbrY:
           Hp = Hp + 32;
           if (Hp > HpLim) goto cbt9; else goto cbt8;
       cbt9:
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to cbrY, args: 8, res: 8, upd: 8;
       cbt8:
           _saEQ::I64 = I64[Sp + 16];
           _saEZ::I64 = I64[Sp + 8] - 1;
           if (%MO_S_Gt_W64(0, _saEZ::I64)) goto cbtk; else goto cbte;
       cbtk:
           I64[Hp - 24] = Data.Vector.Primitive.Mutable.MVector_con_info;
           P64[Hp - 16] = R1;
           I64[Hp - 8] = 0;
           I64[Hp] = _saEQ::I64;
           R1 = Hp - 23;
           Sp = Sp + 24;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
       cbte:
           I64[Hp - 24] = a7_saF2_info;
           P64[Hp - 16] = R1;
           I64[Hp - 8] = _saEQ::I64;
           I64[Hp] = _saEZ::I64;
           I64[Sp] = cbta;
           R2 = 0;
           _saEY::P64 = R1;
           R1 = Hp - 22;
           P64[Sp + 8] = _saEY::P64;
           call a7_saF2_info(R2, R1) returns to cbta, args: 8, res: 8, upd: 8;
       cbta:
           Hp = Hp + 32;
           if (Hp > HpLim) goto cbth; else goto cbtg;
       cbth:
           HpAlloc = 32;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to cbta, args: 8, res: 8, upd: 8;
       cbtg:
           I64[Hp - 24] = Data.Vector.Primitive.Mutable.MVector_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           I64[Hp - 8] = 0;
           I64[Hp] = I64[Sp + 16];
           R1 = Hp - 23;
           Sp = Sp + 24;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
       cbt1:
           I64[Sp - 8] = cbsZ;
           R2 = _saEQ::I64;
           Sp = Sp - 8;
           call Data.Vector.Internal.Check.checkLength_msg#_info(R2) returns to cbsZ, args: 8, res: 8, upd: 8;
       cbsZ:
           R6 = R1;
           R5 = SkipList.newSL6_closure;
           R4 = Data.Vector.Internal.Check.Bounds_closure+1;
           R3 = SkipList.newSL7_closure+1;
           R2 = SkipList.newSL8_closure;
           Sp = Sp + 8;
           call Data.Vector.Internal.Check.checkError_info(R6,
                                                           R5,
                                                           R4,
                                                           R3,
                                                           R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:46.644907 UTC

[section "data" {
     SkipList.newSL3_closure:
         const SkipList.newSL3_info;
         const 0;
         const 0;
         const 0;
 },
 SkipList.newSL3_entry() //  [R1]
         { info_tbl: [(cbtJ,
                       label: SkipList.newSL3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbtJ:
           _ri::P64 = R1;
           goto cbtE;
       cbtE:
           if ((old + 0) - <highSp> < SpLim) goto cbtK; else goto cbtL;
       cbtL:
           if (HpLim == 0) goto cbtK; else goto cbtM;
       cbtK:
           R1 = _ri::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbtM:
           (_cbtG::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _ri::P64);
           if (_cbtG::I64 == 0) goto cbtI; else goto cbtH;
       cbtI:
           call (I64[_ri::P64])() args: 8, res: 0, upd: 8;
       cbtH:
           I64[(old + 24)] = stg_bh_upd_frame_info;
           I64[(old + 16)] = _cbtG::I64;
           R2 = SkipList.newSL4_closure+1;
           call GHC.IO.unsafeDupablePerformIO_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:46.647615 UTC

{offset
  cbtJ:
      _ri::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cbtK; else goto cbtL;
  cbtL:
      if (HpLim == 0) goto cbtK; else goto cbtM;
  cbtK:
      R1 = _ri::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cbtM:
      (_cbtG::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _ri::P64);
      if (_cbtG::I64 == 0) goto cbtI; else goto cbtH;
  cbtI:
      call (I64[_ri::P64])() args: 8, res: 0, upd: 8;
  cbtH:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _cbtG::I64;
      R2 = SkipList.newSL4_closure+1;
      call GHC.IO.unsafeDupablePerformIO_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:46.648723 UTC

{offset
  cbtJ:
      _ri::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cbtK; else goto cbtL;
  cbtL:
      if (HpLim == 0) goto cbtK; else goto cbtM;
  cbtK:
      R1 = _ri::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cbtM:
      (_cbtG::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _ri::P64);
      if (_cbtG::I64 == 0) goto cbtI; else goto cbtH;
  cbtI:
      call (I64[_ri::P64])() args: 8, res: 0, upd: 8;
  cbtH:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _cbtG::I64;
      R2 = SkipList.newSL4_closure+1;
      call GHC.IO.unsafeDupablePerformIO_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:46.649855 UTC

{offset
  cbtJ:
      _ri::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cbtK; else goto cbtL;
  cbtL:
      if (HpLim == 0) goto cbtK; else goto cbtM;
  cbtK:
      R1 = _ri::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cbtM:
      (_cbtG::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _ri::P64);
      if (_cbtG::I64 == 0) goto cbtI; else goto cbtH;
  cbtI:
      call (I64[_ri::P64])() args: 8, res: 0, upd: 8;
  cbtH:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _cbtG::I64;
      R2 = SkipList.newSL4_closure+1;
      call GHC.IO.unsafeDupablePerformIO_info(R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:46.651024 UTC

{offset
  cbtJ:
      _ri::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto cbtK; else goto cbtL;
  cbtL:
      if (HpLim == 0) goto cbtK; else goto cbtM;
  cbtK:
      R1 = _ri::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cbtM:
      (_cbtG::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _ri::P64);
      if (_cbtG::I64 == 0) goto cbtI; else goto cbtH;
  cbtI:
      call (I64[_ri::P64])() args: 8, res: 0, upd: 8;
  cbtH:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _cbtG::I64;
      R2 = SkipList.newSL4_closure+1;
      Sp = Sp - 16;
      call GHC.IO.unsafeDupablePerformIO_info(R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:46.652178 UTC

{offset
  cbtJ:
      _ri::P64 = R1;
      if ((Sp + -16) < SpLim) goto cbtK; else goto cbtL;
  cbtL:
      if (HpLim == 0) goto cbtK; else goto cbtM;
  cbtK:
      R1 = _ri::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cbtM:
      (_cbtG::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _ri::P64);
      if (_cbtG::I64 == 0) goto cbtI; else goto cbtH;
  cbtI:
      call (I64[_ri::P64])() args: 8, res: 0, upd: 8;
  cbtH:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _cbtG::I64;
      R2 = SkipList.newSL4_closure+1;
      Sp = Sp - 16;
      call GHC.IO.unsafeDupablePerformIO_info(R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:46.653557 UTC

[(cbtH, {SkipList.newSL4_closure}), (cbtI, {}),
 (cbtJ, {SkipList.newSL4_closure}), (cbtK, {}),
 (cbtL, {SkipList.newSL4_closure}),
 (cbtM, {SkipList.newSL4_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:46.654063 UTC

SkipList.newSL3_entry() //  [R1]
        { info_tbl: [(cbtJ,
                      label: SkipList.newSL3_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cbtJ:
          _ri::P64 = R1;
          if ((Sp + -16) < SpLim) goto cbtK; else goto cbtL;
      cbtL:
          if (HpLim == 0) goto cbtK; else goto cbtM;
      cbtK:
          R1 = _ri::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      cbtM:
          (_cbtG::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _ri::P64);
          if (_cbtG::I64 == 0) goto cbtI; else goto cbtH;
      cbtI:
          call (I64[_ri::P64])() args: 8, res: 0, upd: 8;
      cbtH:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _cbtG::I64;
          R2 = SkipList.newSL4_closure+1;
          Sp = Sp - 16;
          call GHC.IO.unsafeDupablePerformIO_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:46.655421 UTC

SkipList.newSL3_entry() //  [R1]
        { info_tbl: [(cbtJ,
                      label: SkipList.newSL3_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cbtJ:
          _ri::P64 = R1;
          if ((Sp + -16) < SpLim) goto cbtK; else goto cbtL;
      cbtL:
          if (HpLim == 0) goto cbtK; else goto cbtM;
      cbtK:
          R1 = _ri::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      cbtM:
          (_cbtG::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _ri::P64);
          if (_cbtG::I64 == 0) goto cbtI; else goto cbtH;
      cbtI:
          call (I64[_ri::P64])() args: 8, res: 0, upd: 8;
      cbtH:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _cbtG::I64;
          R2 = SkipList.newSL4_closure+1;
          Sp = Sp - 16;
          call GHC.IO.unsafeDupablePerformIO_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:46.656793 UTC

[section "data" {
     SkipList.newSL3_closure:
         const SkipList.newSL3_info;
         const 0;
         const 0;
         const 0;
 },
 SkipList.newSL3_entry() //  [R1]
         { info_tbl: [(cbtJ,
                       label: SkipList.newSL3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbtJ:
           _ri::P64 = R1;
           if ((Sp + -16) < SpLim) goto cbtK; else goto cbtL;
       cbtL:
           if (HpLim == 0) goto cbtK; else goto cbtM;
       cbtK:
           R1 = _ri::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbtM:
           (_cbtG::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _ri::P64);
           if (_cbtG::I64 == 0) goto cbtI; else goto cbtH;
       cbtI:
           call (I64[_ri::P64])() args: 8, res: 0, upd: 8;
       cbtH:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbtG::I64;
           R2 = SkipList.newSL4_closure+1;
           Sp = Sp - 16;
           call GHC.IO.unsafeDupablePerformIO_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:46.658492 UTC

[section "data" {
     SkipList.newSL3_closure:
         const SkipList.newSL3_info;
         const 0;
         const 0;
         const 0;
 },
 SkipList.newSL3_entry() //  [R1]
         { info_tbl: [(cbtJ,
                       label: SkipList.newSL3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbtJ:
           _ri::P64 = R1;
           if ((Sp + -16) < SpLim) goto cbtK; else goto cbtL;
       cbtL:
           if (HpLim == 0) goto cbtK; else goto cbtM;
       cbtK:
           R1 = _ri::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbtM:
           (_cbtG::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _ri::P64);
           if (_cbtG::I64 == 0) goto cbtI; else goto cbtH;
       cbtI:
           call (I64[_ri::P64])() args: 8, res: 0, upd: 8;
       cbtH:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbtG::I64;
           R2 = SkipList.newSL4_closure+1;
           Sp = Sp - 16;
           call GHC.IO.unsafeDupablePerformIO_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:46.663015 UTC

[section "data" {
     SkipList.newSL10_closure:
         const GHC.Types.I#_static_info;
         const 1;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:46.663395 UTC

[section "data" {
     SkipList.newSL10_closure:
         const GHC.Types.I#_static_info;
         const 1;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:46.6637 UTC

[section "data" {
     SkipList.newSL10_closure:
         const GHC.Types.I#_static_info;
         const 1;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:46.664362 UTC

[section "data" {
     SkipList.newSL9_closure:
         const (,)_static_info;
         const SkipList.newSL10_closure+1;
         const SkipList.newSL_height_closure+1;
         const 3;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:46.664785 UTC

[section "data" {
     SkipList.newSL9_closure:
         const (,)_static_info;
         const SkipList.newSL10_closure+1;
         const SkipList.newSL_height_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:46.66516 UTC

[section "data" {
     SkipList.newSL9_closure:
         const (,)_static_info;
         const SkipList.newSL10_closure+1;
         const SkipList.newSL_height_closure+1;
         const 3;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:46.666156 UTC

[section "data" {
     SkipList.newSL2_closure:
         const SkipList.newSL2_info;
         const 0;
 },
 SkipList.newSL2_entry() //  []
         { info_tbl: [(cbu6,
                       label: SkipList.newSL2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbu6:
           goto cbtY;
       cbtY:
           if ((old + 0) - <highSp> < SpLim) goto cbu7; else goto cbu8;
       cbu8:
           goto cbtX;
       cbtX:
           if (HpLim == 0) goto cbu7; else goto cbu9;
       cbu7:
           R1 = SkipList.newSL2_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbu9:
           I64[(young<cbu0> + 8)] = cbu0;
           R4 = SkipList.Nil_closure+1;
           R3 = SkipList.newSL9_closure+1;
           R2 = GHC.Arr.$fIxInt_closure;
           call SkipList.$fMArrayTArrayeSTM4_info(R4,
                                                  R3,
                                                  R2) returns to cbu0, args: 8, res: 8, upd: 8;
       cbu0:
           _saFt::P64 = R1;
           I64[(young<cbu2> + 8)] = cbu2;
           R1 = SkipList.newSL_height_closure+1;
           call stg_newNOrecTVar#(R1) returns to cbu2, args: 8, res: 8, upd: 8;
       cbu2:
           _saFw::P64 = R1;
           Hp = Hp + 48;
           if (Hp > HpLim) goto cbud; else goto cbuc;
       cbud:
           HpAlloc = 48;
           goto cbub;
       cbub:
           R1 = _saFw::P64;
           call stg_gc_unpt_r1(R1) returns to cbu2, args: 8, res: 8, upd: 8;
       cbuc:
           I64[Hp - 40] = GHC.Conc.Sync.TVar_con_info;
           P64[Hp - 32] = _saFw::P64;
           _cbu4::P64 = Hp - 39;
           I64[Hp - 24] = SkipList.PQ_con_info;
           P64[Hp - 16] = _saFt::P64;
           P64[Hp - 8] = _cbu4::P64;
           P64[Hp] = SkipList.newSL3_closure;
           _cbu5::P64 = Hp - 23;
           R1 = _cbu5::P64;
           call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:46.669754 UTC

{offset
  cbu6:
      if ((old + 0) - <highSp> < SpLim) goto cbu7; else goto cbu8;
  cbu8:
      if (HpLim == 0) goto cbu7; else goto cbu9;
  cbu7:
      R1 = SkipList.newSL2_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  cbu9:
      I64[(young<cbu0> + 8)] = cbu0;
      R4 = SkipList.Nil_closure+1;
      R3 = SkipList.newSL9_closure+1;
      R2 = GHC.Arr.$fIxInt_closure;
      call SkipList.$fMArrayTArrayeSTM4_info(R4,
                                             R3,
                                             R2) returns to cbu0, args: 8, res: 8, upd: 8;
  cbu0:
      _saFt::P64 = R1;
      I64[(young<cbu2> + 8)] = cbu2;
      R1 = SkipList.newSL_height_closure+1;
      call stg_newNOrecTVar#(R1) returns to cbu2, args: 8, res: 8, upd: 8;
  cbu2:
      _saFw::P64 = R1;
      Hp = Hp + 48;
      if (Hp > HpLim) goto cbud; else goto cbuc;
  cbud:
      HpAlloc = 48;
      R1 = _saFw::P64;
      call stg_gc_unpt_r1(R1) returns to cbu2, args: 8, res: 8, upd: 8;
  cbuc:
      I64[Hp - 40] = GHC.Conc.Sync.TVar_con_info;
      P64[Hp - 32] = _saFw::P64;
      _cbu4::P64 = Hp - 39;
      I64[Hp - 24] = SkipList.PQ_con_info;
      P64[Hp - 16] = _saFt::P64;
      P64[Hp - 8] = _cbu4::P64;
      P64[Hp] = SkipList.newSL3_closure;
      _cbu5::P64 = Hp - 23;
      R1 = _cbu5::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:46.671669 UTC

{offset
  cbu6:
      if ((old + 0) - <highSp> < SpLim) goto cbu7; else goto cbu8;
  cbu8:
      if (HpLim == 0) goto cbu7; else goto cbu9;
  cbu7:
      R1 = SkipList.newSL2_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  cbu9:
      I64[(young<cbu0> + 8)] = cbu0;
      R4 = SkipList.Nil_closure+1;
      R3 = SkipList.newSL9_closure+1;
      R2 = GHC.Arr.$fIxInt_closure;
      call SkipList.$fMArrayTArrayeSTM4_info(R4,
                                             R3,
                                             R2) returns to cbu0, args: 8, res: 8, upd: 8;
  cbu0:
      _saFt::P64 = R1;
      I64[(young<cbu2> + 8)] = cbu2;
      R1 = SkipList.newSL_height_closure+1;
      call stg_newNOrecTVar#(R1) returns to cbu2, args: 8, res: 8, upd: 8;
  cbu2:
      _saFw::P64 = R1;
      Hp = Hp + 48;
      if (Hp > HpLim) goto cbud; else goto cbuc;
  cbud:
      HpAlloc = 48;
      R1 = _saFw::P64;
      call stg_gc_unpt_r1(R1) returns to cbu2, args: 8, res: 8, upd: 8;
  cbuc:
      I64[Hp - 40] = GHC.Conc.Sync.TVar_con_info;
      P64[Hp - 32] = _saFw::P64;
      _cbu4::P64 = Hp - 39;
      I64[Hp - 24] = SkipList.PQ_con_info;
      P64[Hp - 16] = _saFt::P64;
      P64[Hp - 8] = _cbu4::P64;
      P64[Hp] = SkipList.newSL3_closure;
      _cbu5::P64 = Hp - 23;
      R1 = _cbu5::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:46.673639 UTC

{offset
  cbu6:
      if ((old + 0) - <highSp> < SpLim) goto cbu7; else goto cbu8;
  cbu8:
      if (HpLim == 0) goto cbu7; else goto cbu9;
  cbu7:
      R1 = SkipList.newSL2_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  cbu9:
      I64[(young<cbu0> + 8)] = cbu0;
      R4 = SkipList.Nil_closure+1;
      R3 = SkipList.newSL9_closure+1;
      R2 = GHC.Arr.$fIxInt_closure;
      call SkipList.$fMArrayTArrayeSTM4_info(R4,
                                             R3,
                                             R2) returns to cbu0, args: 8, res: 8, upd: 8;
  cbu0:
      _saFt::P64 = R1;
      I64[(young<cbu2> + 8)] = cbu2;
      R1 = SkipList.newSL_height_closure+1;
      call stg_newNOrecTVar#(R1) returns to cbu2, args: 8, res: 8, upd: 8;
  cbu2:
      _saFw::P64 = R1;
      Hp = Hp + 48;
      if (Hp > HpLim) goto cbud; else goto cbuc;
  cbud:
      HpAlloc = 48;
      R1 = _saFw::P64;
      call stg_gc_unpt_r1(R1) returns to cbu2, args: 8, res: 8, upd: 8;
  cbuc:
      I64[Hp - 40] = GHC.Conc.Sync.TVar_con_info;
      P64[Hp - 32] = _saFw::P64;
      _cbu4::P64 = Hp - 39;
      I64[Hp - 24] = SkipList.PQ_con_info;
      P64[Hp - 16] = _saFt::P64;
      P64[Hp - 8] = _cbu4::P64;
      P64[Hp] = SkipList.newSL3_closure;
      _cbu5::P64 = Hp - 23;
      R1 = _cbu5::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:46.675795 UTC

{offset
  cbu6:
      if ((Sp + 8) - 24 < SpLim) goto cbu7; else goto cbu8;
  cbu8:
      if (HpLim == 0) goto cbu7; else goto cbu9;
  cbu7:
      R1 = SkipList.newSL2_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  cbu9:
      I64[Sp - 8] = cbu0;
      R4 = SkipList.Nil_closure+1;
      R3 = SkipList.newSL9_closure+1;
      R2 = GHC.Arr.$fIxInt_closure;
      Sp = Sp - 8;
      call SkipList.$fMArrayTArrayeSTM4_info(R4,
                                             R3,
                                             R2) returns to cbu0, args: 8, res: 8, upd: 8;
  cbu0:
      _saFt::P64 = R1;
      I64[Sp - 8] = cbu2;
      R1 = SkipList.newSL_height_closure+1;
      P64[Sp] = _saFt::P64;
      Sp = Sp - 8;
      call stg_newNOrecTVar#(R1) returns to cbu2, args: 8, res: 8, upd: 8;
  cbu2:
      _saFt::P64 = P64[Sp + 8];
      _saFw::P64 = R1;
      Hp = Hp + 48;
      if (Hp > HpLim) goto cbud; else goto cbuc;
  cbud:
      HpAlloc = 48;
      R1 = _saFw::P64;
      call stg_gc_unpt_r1(R1) returns to cbu2, args: 8, res: 8, upd: 8;
  cbuc:
      I64[Hp - 40] = GHC.Conc.Sync.TVar_con_info;
      P64[Hp - 32] = _saFw::P64;
      _cbu4::P64 = Hp - 39;
      I64[Hp - 24] = SkipList.PQ_con_info;
      P64[Hp - 16] = _saFt::P64;
      P64[Hp - 8] = _cbu4::P64;
      P64[Hp] = SkipList.newSL3_closure;
      _cbu5::P64 = Hp - 23;
      R1 = _cbu5::P64;
      Sp = Sp + 16;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:46.678641 UTC

{offset
  cbu6:
      if ((Sp + -16) < SpLim) goto cbu7; else goto cbu8;
  cbu8:
      if (HpLim == 0) goto cbu7; else goto cbu9;
  cbu7:
      R1 = SkipList.newSL2_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  cbu9:
      I64[Sp - 8] = cbu0;
      R4 = SkipList.Nil_closure+1;
      R3 = SkipList.newSL9_closure+1;
      R2 = GHC.Arr.$fIxInt_closure;
      Sp = Sp - 8;
      call SkipList.$fMArrayTArrayeSTM4_info(R4,
                                             R3,
                                             R2) returns to cbu0, args: 8, res: 8, upd: 8;
  cbu0:
      I64[Sp - 8] = cbu2;
      _saFt::P64 = R1;
      R1 = SkipList.newSL_height_closure+1;
      P64[Sp] = _saFt::P64;
      Sp = Sp - 8;
      call stg_newNOrecTVar#(R1) returns to cbu2, args: 8, res: 8, upd: 8;
  cbu2:
      Hp = Hp + 48;
      if (Hp > HpLim) goto cbud; else goto cbuc;
  cbud:
      HpAlloc = 48;
      R1 = R1;
      call stg_gc_unpt_r1(R1) returns to cbu2, args: 8, res: 8, upd: 8;
  cbuc:
      I64[Hp - 40] = GHC.Conc.Sync.TVar_con_info;
      P64[Hp - 32] = R1;
      I64[Hp - 24] = SkipList.PQ_con_info;
      P64[Hp - 16] = P64[Sp + 8];
      P64[Hp - 8] = Hp - 39;
      P64[Hp] = SkipList.newSL3_closure;
      R1 = Hp - 23;
      Sp = Sp + 16;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:46.680868 UTC

[(cbu0, {SkipList.newSL3_closure}),
 (cbu2, {SkipList.newSL3_closure}),
 (cbu6,
  {SkipList.newSL3_closure, SkipList.newSL2_closure,
   GHC.Arr.$fIxInt_closure, SkipList.$fMArrayTArrayeSTM4_closure}),
 (cbu7, {SkipList.newSL2_closure}),
 (cbu8,
  {SkipList.newSL3_closure, SkipList.newSL2_closure,
   GHC.Arr.$fIxInt_closure, SkipList.$fMArrayTArrayeSTM4_closure}),
 (cbu9,
  {SkipList.newSL3_closure, GHC.Arr.$fIxInt_closure,
   SkipList.$fMArrayTArrayeSTM4_closure}),
 (cbuc, {SkipList.newSL3_closure}),
 (cbud, {SkipList.newSL3_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:46.681863 UTC

SkipList.newSL2_entry() //  []
        { info_tbl: [(cbu0,
                      label: block_cbu0_info
                      rep:StackRep []),
                     (cbu2,
                      label: block_cbu2_info
                      rep:StackRep [False]),
                     (cbu6,
                      label: SkipList.newSL2_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cbu6:
          if ((Sp + -16) < SpLim) goto cbu7; else goto cbu8;
      cbu8:
          if (HpLim == 0) goto cbu7; else goto cbu9;
      cbu7:
          R1 = SkipList.newSL2_closure;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
      cbu9:
          I64[Sp - 8] = cbu0;
          R4 = SkipList.Nil_closure+1;
          R3 = SkipList.newSL9_closure+1;
          R2 = GHC.Arr.$fIxInt_closure;
          Sp = Sp - 8;
          call SkipList.$fMArrayTArrayeSTM4_info(R4,
                                                 R3,
                                                 R2) returns to cbu0, args: 8, res: 8, upd: 8;
      cbu0:
          I64[Sp - 8] = cbu2;
          _saFt::P64 = R1;
          R1 = SkipList.newSL_height_closure+1;
          P64[Sp] = _saFt::P64;
          Sp = Sp - 8;
          call stg_newNOrecTVar#(R1) returns to cbu2, args: 8, res: 8, upd: 8;
      cbu2:
          Hp = Hp + 48;
          if (Hp > HpLim) goto cbud; else goto cbuc;
      cbud:
          HpAlloc = 48;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to cbu2, args: 8, res: 8, upd: 8;
      cbuc:
          I64[Hp - 40] = GHC.Conc.Sync.TVar_con_info;
          P64[Hp - 32] = R1;
          I64[Hp - 24] = SkipList.PQ_con_info;
          P64[Hp - 16] = P64[Sp + 8];
          P64[Hp - 8] = Hp - 39;
          P64[Hp] = SkipList.newSL3_closure;
          R1 = Hp - 23;
          Sp = Sp + 16;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:46.684319 UTC

SkipList.newSL2_entry() //  []
        { info_tbl: [(cbu0,
                      label: block_cbu0_info
                      rep:StackRep []),
                     (cbu2,
                      label: block_cbu2_info
                      rep:StackRep [False]),
                     (cbu6,
                      label: SkipList.newSL2_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cbu6:
          if ((Sp + -16) < SpLim) goto cbu7; else goto cbu8;
      cbu8:
          if (HpLim == 0) goto cbu7; else goto cbu9;
      cbu7:
          R1 = SkipList.newSL2_closure;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
      cbu9:
          I64[Sp - 8] = cbu0;
          R4 = SkipList.Nil_closure+1;
          R3 = SkipList.newSL9_closure+1;
          R2 = GHC.Arr.$fIxInt_closure;
          Sp = Sp - 8;
          call SkipList.$fMArrayTArrayeSTM4_info(R4,
                                                 R3,
                                                 R2) returns to cbu0, args: 8, res: 8, upd: 8;
      cbu0:
          I64[Sp - 8] = cbu2;
          _saFt::P64 = R1;
          R1 = SkipList.newSL_height_closure+1;
          P64[Sp] = _saFt::P64;
          Sp = Sp - 8;
          call stg_newNOrecTVar#(R1) returns to cbu2, args: 8, res: 8, upd: 8;
      cbu2:
          Hp = Hp + 48;
          if (Hp > HpLim) goto cbud; else goto cbuc;
      cbud:
          HpAlloc = 48;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to cbu2, args: 8, res: 8, upd: 8;
      cbuc:
          I64[Hp - 40] = GHC.Conc.Sync.TVar_con_info;
          P64[Hp - 32] = R1;
          I64[Hp - 24] = SkipList.PQ_con_info;
          P64[Hp - 16] = P64[Sp + 8];
          P64[Hp - 8] = Hp - 39;
          P64[Hp] = SkipList.newSL3_closure;
          R1 = Hp - 23;
          Sp = Sp + 16;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:46.686784 UTC

[section "data" {
     SkipList.newSL2_closure:
         const SkipList.newSL2_info;
         const 0;
 },
 SkipList.newSL2_entry() //  []
         { info_tbl: [(cbu0,
                       label: block_cbu0_info
                       rep:StackRep []),
                      (cbu2,
                       label: block_cbu2_info
                       rep:StackRep [False]),
                      (cbu6,
                       label: SkipList.newSL2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbu6:
           if ((Sp + -16) < SpLim) goto cbu7; else goto cbu8;
       cbu8:
           if (HpLim == 0) goto cbu7; else goto cbu9;
       cbu7:
           R1 = SkipList.newSL2_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbu9:
           I64[Sp - 8] = cbu0;
           R4 = SkipList.Nil_closure+1;
           R3 = SkipList.newSL9_closure+1;
           R2 = GHC.Arr.$fIxInt_closure;
           Sp = Sp - 8;
           call SkipList.$fMArrayTArrayeSTM4_info(R4,
                                                  R3,
                                                  R2) returns to cbu0, args: 8, res: 8, upd: 8;
       cbu0:
           I64[Sp - 8] = cbu2;
           _saFt::P64 = R1;
           R1 = SkipList.newSL_height_closure+1;
           P64[Sp] = _saFt::P64;
           Sp = Sp - 8;
           call stg_newNOrecTVar#(R1) returns to cbu2, args: 8, res: 8, upd: 8;
       cbu2:
           Hp = Hp + 48;
           if (Hp > HpLim) goto cbud; else goto cbuc;
       cbud:
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to cbu2, args: 8, res: 8, upd: 8;
       cbuc:
           I64[Hp - 40] = GHC.Conc.Sync.TVar_con_info;
           P64[Hp - 32] = R1;
           I64[Hp - 24] = SkipList.PQ_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = SkipList.newSL3_closure;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:46.689665 UTC

[section "data" {
     SkipList.newSL2_closure:
         const SkipList.newSL2_info;
         const 0;
 },
 SkipList.newSL2_entry() //  []
         { info_tbl: [(cbu0,
                       label: block_cbu0_info
                       rep:StackRep []),
                      (cbu2,
                       label: block_cbu2_info
                       rep:StackRep [False]),
                      (cbu6,
                       label: SkipList.newSL2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbu6:
           if ((Sp + -16) < SpLim) goto cbu7; else goto cbu8;
       cbu8:
           if (HpLim == 0) goto cbu7; else goto cbu9;
       cbu7:
           R1 = SkipList.newSL2_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbu9:
           I64[Sp - 8] = cbu0;
           R4 = SkipList.Nil_closure+1;
           R3 = SkipList.newSL9_closure+1;
           R2 = GHC.Arr.$fIxInt_closure;
           Sp = Sp - 8;
           call SkipList.$fMArrayTArrayeSTM4_info(R4,
                                                  R3,
                                                  R2) returns to cbu0, args: 8, res: 8, upd: 8;
       cbu0:
           I64[Sp - 8] = cbu2;
           _saFt::P64 = R1;
           R1 = SkipList.newSL_height_closure+1;
           P64[Sp] = _saFt::P64;
           Sp = Sp - 8;
           call stg_newNOrecTVar#(R1) returns to cbu2, args: 8, res: 8, upd: 8;
       cbu2:
           Hp = Hp + 48;
           if (Hp > HpLim) goto cbud; else goto cbuc;
       cbud:
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to cbu2, args: 8, res: 8, upd: 8;
       cbuc:
           I64[Hp - 40] = GHC.Conc.Sync.TVar_con_info;
           P64[Hp - 32] = R1;
           I64[Hp - 24] = SkipList.PQ_con_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = SkipList.newSL3_closure;
           R1 = Hp - 23;
           Sp = Sp + 16;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:46.696995 UTC

[section "data" {
     SkipList.newSL1_closure:
         const SkipList.newSL1_info;
         const 0;
 },
 SkipList.newSL1_entry() //  [R2]
         { info_tbl: [(cbup,
                       label: SkipList.newSL1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbup:
           _saFz::P64 = R2;
           goto cbun;
       cbun:
           if ((old + 0) - <highSp> < SpLim) goto cbuq; else goto cbur;
       cbur:
           goto cbum;
       cbum:
           if (HpLim == 0) goto cbuq; else goto cbus;
       cbuq:
           R2 = _saFz::P64;
           R1 = SkipList.newSL1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbus:
           call SkipList.newSL2_info() args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:46.698526 UTC

{offset
  cbup:
      _saFz::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cbuq; else goto cbur;
  cbur:
      if (HpLim == 0) goto cbuq; else goto cbus;
  cbuq:
      R2 = _saFz::P64;
      R1 = SkipList.newSL1_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  cbus:
      call SkipList.newSL2_info() args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:46.699237 UTC

{offset
  cbup:
      _saFz::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cbuq; else goto cbur;
  cbur:
      if (HpLim == 0) goto cbuq; else goto cbus;
  cbuq:
      R2 = _saFz::P64;
      R1 = SkipList.newSL1_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  cbus:
      call SkipList.newSL2_info() args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:46.699959 UTC

{offset
  cbup:
      _saFz::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cbuq; else goto cbur;
  cbur:
      if (HpLim == 0) goto cbuq; else goto cbus;
  cbuq:
      R2 = _saFz::P64;
      R1 = SkipList.newSL1_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  cbus:
      call SkipList.newSL2_info() args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:46.700721 UTC

{offset
  cbup:
      _saFz::P64 = R2;
      goto cbur;
  cbur:
      if (HpLim == 0) goto cbuq; else goto cbus;
  cbuq:
      R2 = _saFz::P64;
      R1 = SkipList.newSL1_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  cbus:
      call SkipList.newSL2_info() args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:46.701347 UTC

{offset
  cbup:
      goto cbur;
  cbur:
      if (HpLim == 0) goto cbuq; else goto cbus;
  cbuq:
      R2 = R2;
      R1 = SkipList.newSL1_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  cbus:
      call SkipList.newSL2_info() args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:46.702063 UTC

[(cbup, {SkipList.newSL2_closure, SkipList.newSL1_closure}),
 (cbuq, {SkipList.newSL1_closure}),
 (cbur, {SkipList.newSL2_closure, SkipList.newSL1_closure}),
 (cbus, {SkipList.newSL2_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:46.70259 UTC

SkipList.newSL1_entry() //  [R2]
        { info_tbl: [(cbup,
                      label: SkipList.newSL1_info
                      rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cbup:
          goto cbur;
      cbur:
          if (HpLim == 0) goto cbuq; else goto cbus;
      cbuq:
          R2 = R2;
          R1 = SkipList.newSL1_closure;
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
      cbus:
          call SkipList.newSL2_info() args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:46.703421 UTC

SkipList.newSL1_entry() //  [R2]
        { info_tbl: [(cbup,
                      label: SkipList.newSL1_info
                      rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cbup:
          if (HpLim == 0) goto cbuq; else goto cbus;
      cbuq:
          R2 = R2;
          R1 = SkipList.newSL1_closure;
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
      cbus:
          call SkipList.newSL2_info() args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:46.70424 UTC

[section "data" {
     SkipList.newSL1_closure:
         const SkipList.newSL1_info;
         const 0;
 },
 SkipList.newSL1_entry() //  [R2]
         { info_tbl: [(cbup,
                       label: SkipList.newSL1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbup:
           if (HpLim == 0) goto cbuq; else goto cbus;
       cbuq:
           R2 = R2;
           R1 = SkipList.newSL1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbus:
           call SkipList.newSL2_info() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:46.705257 UTC

[section "data" {
     SkipList.newSL1_closure:
         const SkipList.newSL1_info;
         const 0;
 },
 SkipList.newSL1_entry() //  [R2]
         { info_tbl: [(cbup,
                       label: SkipList.newSL1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbup:
           if (HpLim == 0) goto cbuq; else goto cbus;
       cbuq:
           R2 = R2;
           R1 = SkipList.newSL1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbus:
           call SkipList.newSL2_info() args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:46.707855 UTC

[section "data" {
     SkipList.newSL_closure:
         const SkipList.newSL_info;
         const 0;
 },
 SkipList.newSL_entry() //  [R2]
         { info_tbl: [(cbuB,
                       label: SkipList.newSL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbuB:
           _B2::P64 = R2;
           goto cbuz;
       cbuz:
           if ((old + 0) - <highSp> < SpLim) goto cbuC; else goto cbuD;
       cbuD:
           goto cbuy;
       cbuy:
           if (HpLim == 0) goto cbuC; else goto cbuE;
       cbuC:
           R2 = _B2::P64;
           R1 = SkipList.newSL_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbuE:
           R2 = _B2::P64;
           call SkipList.newSL1_info(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:46.709357 UTC

{offset
  cbuB:
      _B2::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cbuC; else goto cbuD;
  cbuD:
      if (HpLim == 0) goto cbuC; else goto cbuE;
  cbuC:
      R2 = _B2::P64;
      R1 = SkipList.newSL_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  cbuE:
      R2 = _B2::P64;
      call SkipList.newSL1_info(R2) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:46.710096 UTC

{offset
  cbuB:
      _B2::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cbuC; else goto cbuD;
  cbuD:
      if (HpLim == 0) goto cbuC; else goto cbuE;
  cbuC:
      R2 = _B2::P64;
      R1 = SkipList.newSL_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  cbuE:
      R2 = _B2::P64;
      call SkipList.newSL1_info(R2) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:46.710836 UTC

{offset
  cbuB:
      _B2::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cbuC; else goto cbuD;
  cbuD:
      if (HpLim == 0) goto cbuC; else goto cbuE;
  cbuC:
      R2 = _B2::P64;
      R1 = SkipList.newSL_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  cbuE:
      R2 = _B2::P64;
      call SkipList.newSL1_info(R2) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:46.711615 UTC

{offset
  cbuB:
      _B2::P64 = R2;
      goto cbuD;
  cbuD:
      if (HpLim == 0) goto cbuC; else goto cbuE;
  cbuC:
      R2 = _B2::P64;
      R1 = SkipList.newSL_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  cbuE:
      R2 = _B2::P64;
      call SkipList.newSL1_info(R2) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:46.712951 UTC

{offset
  cbuB:
      goto cbuD;
  cbuD:
      if (HpLim == 0) goto cbuC; else goto cbuE;
  cbuC:
      R2 = R2;
      R1 = SkipList.newSL_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  cbuE:
      R2 = R2;
      call SkipList.newSL1_info(R2) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:46.713695 UTC

[(cbuB, {SkipList.newSL1_closure, SkipList.newSL_closure}),
 (cbuC, {SkipList.newSL_closure}),
 (cbuD, {SkipList.newSL1_closure, SkipList.newSL_closure}),
 (cbuE, {SkipList.newSL1_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:46.714185 UTC

SkipList.newSL_entry() //  [R2]
        { info_tbl: [(cbuB,
                      label: SkipList.newSL_info
                      rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cbuB:
          goto cbuD;
      cbuD:
          if (HpLim == 0) goto cbuC; else goto cbuE;
      cbuC:
          R2 = R2;
          R1 = SkipList.newSL_closure;
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
      cbuE:
          R2 = R2;
          call SkipList.newSL1_info(R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:46.715045 UTC

SkipList.newSL_entry() //  [R2]
        { info_tbl: [(cbuB,
                      label: SkipList.newSL_info
                      rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cbuB:
          if (HpLim == 0) goto cbuC; else goto cbuE;
      cbuC:
          R2 = R2;
          R1 = SkipList.newSL_closure;
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
      cbuE:
          R2 = R2;
          call SkipList.newSL1_info(R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:46.715871 UTC

[section "data" {
     SkipList.newSL_closure:
         const SkipList.newSL_info;
         const 0;
 },
 SkipList.newSL_entry() //  [R2]
         { info_tbl: [(cbuB,
                       label: SkipList.newSL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbuB:
           if (HpLim == 0) goto cbuC; else goto cbuE;
       cbuC:
           R2 = R2;
           R1 = SkipList.newSL_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbuE:
           R2 = R2;
           call SkipList.newSL1_info(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:46.716889 UTC

[section "data" {
     SkipList.newSL_closure:
         const SkipList.newSL_info;
         const 0;
 },
 SkipList.newSL_entry() //  [R2]
         { info_tbl: [(cbuB,
                       label: SkipList.newSL_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbuB:
           if (HpLim == 0) goto cbuC; else goto cbuE;
       cbuC:
           R2 = R2;
           R1 = SkipList.newSL_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cbuE:
           R2 = R2;
           call SkipList.newSL1_info(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:46.719442 UTC

[section "data" {
     logHalf_r2BC_closure:
         const logHalf_r2BC_info;
         const 0;
         const 0;
         const 0;
 },
 logHalf_r2BC_entry() //  [R1]
         { info_tbl: [(cbuV,
                       label: logHalf_r2BC_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbuV:
           _r2BC::P64 = R1;
           goto cbuN;
       cbuN:
           if ((old + 0) - <highSp> < SpLim) goto cbuY; else goto cbuZ;
       cbuZ:
           Hp = Hp + 16;
           if (Hp > HpLim) goto cbv1; else goto cbv0;
       cbv1:
           HpAlloc = 16;
           goto cbuY;
       cbuY:
           R1 = _r2BC::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbv0:
           (_cbuP::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _r2BC::P64);
           if (_cbuP::I64 == 0) goto cbuR; else goto cbuQ;
       cbuR:
           call (I64[_r2BC::P64])() args: 8, res: 0, upd: 8;
       cbuQ:
           I64[(old + 24)] = stg_bh_upd_frame_info;
           I64[(old + 16)] = _cbuP::I64;
           _cbuT::F32 = 0.5 :: W32;
           (_cbuS::F32) = call MO_F32_Log(_cbuT::F32);
           _saFA::F32 = _cbuS::F32;
           I64[Hp - 8] = GHC.Types.F#_con_info;
           F32[Hp] = _saFA::F32;
           _cbuX::P64 = Hp - 7;
           R1 = _cbuX::P64;
           call (P64[(old + 24)])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:46.722211 UTC

{offset
  cbuV:
      _r2BC::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cbuY; else goto cbuZ;
  cbuZ:
      Hp = Hp + 16;
      if (Hp > HpLim) goto cbv1; else goto cbv0;
  cbv1:
      HpAlloc = 16;
      goto cbuY;
  cbuY:
      R1 = _r2BC::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cbv0:
      (_cbuP::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _r2BC::P64);
      if (_cbuP::I64 == 0) goto cbuR; else goto cbuQ;
  cbuR:
      call (I64[_r2BC::P64])() args: 8, res: 0, upd: 8;
  cbuQ:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _cbuP::I64;
      _cbuT::F32 = 0.5 :: W32;
      (_cbuS::F32) = call MO_F32_Log(_cbuT::F32);
      _saFA::F32 = _cbuS::F32;
      I64[Hp - 8] = GHC.Types.F#_con_info;
      F32[Hp] = _saFA::F32;
      _cbuX::P64 = Hp - 7;
      R1 = _cbuX::P64;
      call (P64[(old + 24)])(R1) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:46.723752 UTC

{offset
  cbuV:
      _r2BC::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cbuY; else goto cbuZ;
  cbuZ:
      Hp = Hp + 16;
      if (Hp > HpLim) goto cbv1; else goto cbv0;
  cbv1:
      HpAlloc = 16;
      goto cbuY;
  cbuY:
      R1 = _r2BC::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cbv0:
      (_cbuP::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _r2BC::P64);
      if (_cbuP::I64 == 0) goto cbuR; else goto cbuQ;
  cbuR:
      call (I64[_r2BC::P64])() args: 8, res: 0, upd: 8;
  cbuQ:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _cbuP::I64;
      _cbuT::F32 = 0.5 :: W32;
      (_cbuS::F32) = call MO_F32_Log(_cbuT::F32);
      _saFA::F32 = _cbuS::F32;
      I64[Hp - 8] = GHC.Types.F#_con_info;
      F32[Hp] = _saFA::F32;
      _cbuX::P64 = Hp - 7;
      R1 = _cbuX::P64;
      call (P64[(old + 24)])(R1) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:46.725264 UTC

{offset
  cbuV:
      _r2BC::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cbuY; else goto cbuZ;
  cbuZ:
      Hp = Hp + 16;
      if (Hp > HpLim) goto cbv1; else goto cbv0;
  cbv1:
      HpAlloc = 16;
      goto cbuY;
  cbuY:
      R1 = _r2BC::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cbv0:
      (_cbuP::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _r2BC::P64);
      if (_cbuP::I64 == 0) goto cbuR; else goto cbuQ;
  cbuR:
      call (I64[_r2BC::P64])() args: 8, res: 0, upd: 8;
  cbuQ:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _cbuP::I64;
      _cbuT::F32 = 0.5 :: W32;
      (_cbuS::F32) = call MO_F32_Log(_cbuT::F32);
      _saFA::F32 = _cbuS::F32;
      I64[Hp - 8] = GHC.Types.F#_con_info;
      F32[Hp] = _saFA::F32;
      _cbuX::P64 = Hp - 7;
      R1 = _cbuX::P64;
      call (P64[(old + 24)])(R1) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:46.726828 UTC

{offset
  cbuV:
      _r2BC::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto cbuY; else goto cbuZ;
  cbuZ:
      Hp = Hp + 16;
      if (Hp > HpLim) goto cbv1; else goto cbv0;
  cbv1:
      HpAlloc = 16;
      goto cbuY;
  cbuY:
      R1 = _r2BC::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cbv0:
      (_cbuP::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _r2BC::P64);
      if (_cbuP::I64 == 0) goto cbuR; else goto cbuQ;
  cbuR:
      call (I64[_r2BC::P64])() args: 8, res: 0, upd: 8;
  cbuQ:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _cbuP::I64;
      _cbuT::F32 = 0.5 :: W32;
      (_cbuS::F32) = call MO_F32_Log(_cbuT::F32);
      _saFA::F32 = _cbuS::F32;
      I64[Hp - 8] = GHC.Types.F#_con_info;
      F32[Hp] = _saFA::F32;
      _cbuX::P64 = Hp - 7;
      R1 = _cbuX::P64;
      Sp = Sp - 16;
      call (P64[Sp])(R1) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:46.728381 UTC

{offset
  cbuV:
      _r2BC::P64 = R1;
      if ((Sp + -16) < SpLim) goto cbuY; else goto cbuZ;
  cbuZ:
      Hp = Hp + 16;
      if (Hp > HpLim) goto cbv1; else goto cbv0;
  cbv1:
      HpAlloc = 16;
      goto cbuY;
  cbuY:
      R1 = _r2BC::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cbv0:
      (_cbuP::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _r2BC::P64);
      if (_cbuP::I64 == 0) goto cbuR; else goto cbuQ;
  cbuR:
      call (I64[_r2BC::P64])() args: 8, res: 0, upd: 8;
  cbuQ:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _cbuP::I64;
      (_cbuS::F32) = call MO_F32_Log(0.5 :: W32);
      I64[Hp - 8] = GHC.Types.F#_con_info;
      F32[Hp] = _cbuS::F32;
      R1 = Hp - 7;
      Sp = Sp - 16;
      call (P64[Sp])(R1) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:46.73001 UTC

[(cbuQ, {}), (cbuR, {}), (cbuV, {}), (cbuY, {}), (cbuZ, {}),
 (cbv0, {}), (cbv1, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:46.730414 UTC

logHalf_r2BC_entry() //  [R1]
        { info_tbl: [(cbuV,
                      label: logHalf_r2BC_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cbuV:
          _r2BC::P64 = R1;
          if ((Sp + -16) < SpLim) goto cbuY; else goto cbuZ;
      cbuZ:
          Hp = Hp + 16;
          if (Hp > HpLim) goto cbv1; else goto cbv0;
      cbv1:
          HpAlloc = 16;
          goto cbuY;
      cbuY:
          R1 = _r2BC::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      cbv0:
          (_cbuP::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _r2BC::P64);
          if (_cbuP::I64 == 0) goto cbuR; else goto cbuQ;
      cbuR:
          call (I64[_r2BC::P64])() args: 8, res: 0, upd: 8;
      cbuQ:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _cbuP::I64;
          (_cbuS::F32) = call MO_F32_Log(0.5 :: W32);
          I64[Hp - 8] = GHC.Types.F#_con_info;
          F32[Hp] = _cbuS::F32;
          R1 = Hp - 7;
          Sp = Sp - 16;
          call (P64[Sp])(R1) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:46.732105 UTC

logHalf_r2BC_entry() //  [R1]
        { info_tbl: [(cbuV,
                      label: logHalf_r2BC_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cbuV:
          _r2BC::P64 = R1;
          if ((Sp + -16) < SpLim) goto cbuY; else goto cbuZ;
      cbuZ:
          Hp = Hp + 16;
          if (Hp > HpLim) goto cbv1; else goto cbv0;
      cbv1:
          HpAlloc = 16;
          goto cbuY;
      cbuY:
          R1 = _r2BC::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      cbv0:
          (_cbuP::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _r2BC::P64);
          if (_cbuP::I64 == 0) goto cbuR; else goto cbuQ;
      cbuR:
          call (I64[_r2BC::P64])() args: 8, res: 0, upd: 8;
      cbuQ:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _cbuP::I64;
          (_cbuS::F32) = call MO_F32_Log(0.5 :: W32);
          I64[Hp - 8] = GHC.Types.F#_con_info;
          F32[Hp] = _cbuS::F32;
          R1 = Hp - 7;
          Sp = Sp - 16;
          call (P64[Sp])(R1) args: 24, res: 0, upd: 24;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:46.73384 UTC

[section "data" {
     logHalf_r2BC_closure:
         const logHalf_r2BC_info;
         const 0;
         const 0;
         const 0;
 },
 logHalf_r2BC_entry() //  [R1]
         { info_tbl: [(cbuV,
                       label: logHalf_r2BC_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbuV:
           _r2BC::P64 = R1;
           if ((Sp + -16) < SpLim) goto cbuY; else goto cbuZ;
       cbuZ:
           Hp = Hp + 16;
           if (Hp > HpLim) goto cbv1; else goto cbv0;
       cbv1:
           HpAlloc = 16;
           goto cbuY;
       cbuY:
           R1 = _r2BC::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbv0:
           (_cbuP::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _r2BC::P64);
           if (_cbuP::I64 == 0) goto cbuR; else goto cbuQ;
       cbuR:
           call (I64[_r2BC::P64])() args: 8, res: 0, upd: 8;
       cbuQ:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbuP::I64;
           (_cbuS::F32) = call MO_F32_Log(0.5 :: W32);
           I64[Hp - 8] = GHC.Types.F#_con_info;
           F32[Hp] = _cbuS::F32;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (P64[Sp])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:46.735797 UTC

[section "data" {
     logHalf_r2BC_closure:
         const logHalf_r2BC_info;
         const 0;
         const 0;
         const 0;
 },
 logHalf_r2BC_entry() //  [R1]
         { info_tbl: [(cbuV,
                       label: logHalf_r2BC_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbuV:
           _r2BC::P64 = R1;
           if ((Sp + -16) < SpLim) goto cbuY; else goto cbuZ;
       cbuZ:
           Hp = Hp + 16;
           if (Hp > HpLim) goto cbv1; else goto cbv0;
       cbv1:
           HpAlloc = 16;
           goto cbuY;
       cbuY:
           R1 = _r2BC::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbv0:
           (_cbuP::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _r2BC::P64);
           if (_cbuP::I64 == 0) goto cbuR; else goto cbuQ;
       cbuR:
           call (I64[_r2BC::P64])() args: 8, res: 0, upd: 8;
       cbuQ:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbuP::I64;
           (_cbuS::F32) = call MO_F32_Log(0.5 :: W32);
           I64[Hp - 8] = GHC.Types.F#_con_info;
           F32[Hp] = _cbuS::F32;
           R1 = Hp - 7;
           Sp = Sp - 16;
           call (P64[Sp])(R1) args: 24, res: 0, upd: 24;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:46.741342 UTC

[section "data" {
     lvl31_rawq_closure:
         const lvl31_rawq_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     cbve_str:
         I8[] [109,97,105,110]
 },
 lvl31_rawq_entry() //  [R1]
         { info_tbl: [(cbvf,
                       label: lvl31_rawq_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbvf:
           _rawq::P64 = R1;
           goto cbv9;
       cbv9:
           if ((old + 0) - <highSp> < SpLim) goto cbvg; else goto cbvh;
       cbvh:
           if (HpLim == 0) goto cbvg; else goto cbvi;
       cbvg:
           R1 = _rawq::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbvi:
           (_cbvb::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rawq::P64);
           if (_cbvb::I64 == 0) goto cbvd; else goto cbvc;
       cbvd:
           call (I64[_rawq::P64])() args: 8, res: 0, upd: 8;
       cbvc:
           I64[(old + 24)] = stg_bh_upd_frame_info;
           I64[(old + 16)] = _cbvb::I64;
           R2 = cbve_str;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:46.743495 UTC

{offset
  cbvf:
      _rawq::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cbvg; else goto cbvh;
  cbvh:
      if (HpLim == 0) goto cbvg; else goto cbvi;
  cbvg:
      R1 = _rawq::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cbvi:
      (_cbvb::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rawq::P64);
      if (_cbvb::I64 == 0) goto cbvd; else goto cbvc;
  cbvd:
      call (I64[_rawq::P64])() args: 8, res: 0, upd: 8;
  cbvc:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _cbvb::I64;
      R2 = cbve_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:46.744595 UTC

{offset
  cbvf:
      _rawq::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cbvg; else goto cbvh;
  cbvh:
      if (HpLim == 0) goto cbvg; else goto cbvi;
  cbvg:
      R1 = _rawq::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cbvi:
      (_cbvb::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rawq::P64);
      if (_cbvb::I64 == 0) goto cbvd; else goto cbvc;
  cbvd:
      call (I64[_rawq::P64])() args: 8, res: 0, upd: 8;
  cbvc:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _cbvb::I64;
      R2 = cbve_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:46.745707 UTC

{offset
  cbvf:
      _rawq::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cbvg; else goto cbvh;
  cbvh:
      if (HpLim == 0) goto cbvg; else goto cbvi;
  cbvg:
      R1 = _rawq::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cbvi:
      (_cbvb::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rawq::P64);
      if (_cbvb::I64 == 0) goto cbvd; else goto cbvc;
  cbvd:
      call (I64[_rawq::P64])() args: 8, res: 0, upd: 8;
  cbvc:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _cbvb::I64;
      R2 = cbve_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:46.747436 UTC

{offset
  cbvf:
      _rawq::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto cbvg; else goto cbvh;
  cbvh:
      if (HpLim == 0) goto cbvg; else goto cbvi;
  cbvg:
      R1 = _rawq::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cbvi:
      (_cbvb::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rawq::P64);
      if (_cbvb::I64 == 0) goto cbvd; else goto cbvc;
  cbvd:
      call (I64[_rawq::P64])() args: 8, res: 0, upd: 8;
  cbvc:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _cbvb::I64;
      R2 = cbve_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:46.748589 UTC

{offset
  cbvf:
      _rawq::P64 = R1;
      if ((Sp + -16) < SpLim) goto cbvg; else goto cbvh;
  cbvh:
      if (HpLim == 0) goto cbvg; else goto cbvi;
  cbvg:
      R1 = _rawq::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cbvi:
      (_cbvb::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rawq::P64);
      if (_cbvb::I64 == 0) goto cbvd; else goto cbvc;
  cbvd:
      call (I64[_rawq::P64])() args: 8, res: 0, upd: 8;
  cbvc:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _cbvb::I64;
      R2 = cbve_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:46.749862 UTC

[(cbvc, {}), (cbvd, {}), (cbvf, {}), (cbvg, {}), (cbvh, {}),
 (cbvi, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:46.750245 UTC

lvl31_rawq_entry() //  [R1]
        { info_tbl: [(cbvf,
                      label: lvl31_rawq_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cbvf:
          _rawq::P64 = R1;
          if ((Sp + -16) < SpLim) goto cbvg; else goto cbvh;
      cbvh:
          if (HpLim == 0) goto cbvg; else goto cbvi;
      cbvg:
          R1 = _rawq::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      cbvi:
          (_cbvb::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rawq::P64);
          if (_cbvb::I64 == 0) goto cbvd; else goto cbvc;
      cbvd:
          call (I64[_rawq::P64])() args: 8, res: 0, upd: 8;
      cbvc:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _cbvb::I64;
          R2 = cbve_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:46.751602 UTC

lvl31_rawq_entry() //  [R1]
        { info_tbl: [(cbvf,
                      label: lvl31_rawq_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cbvf:
          _rawq::P64 = R1;
          if ((Sp + -16) < SpLim) goto cbvg; else goto cbvh;
      cbvh:
          if (HpLim == 0) goto cbvg; else goto cbvi;
      cbvg:
          R1 = _rawq::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      cbvi:
          (_cbvb::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rawq::P64);
          if (_cbvb::I64 == 0) goto cbvd; else goto cbvc;
      cbvd:
          call (I64[_rawq::P64])() args: 8, res: 0, upd: 8;
      cbvc:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _cbvb::I64;
          R2 = cbve_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:46.753077 UTC

[section "data" {
     lvl31_rawq_closure:
         const lvl31_rawq_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     cbve_str:
         I8[] [109,97,105,110]
 },
 lvl31_rawq_entry() //  [R1]
         { info_tbl: [(cbvf,
                       label: lvl31_rawq_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbvf:
           _rawq::P64 = R1;
           if ((Sp + -16) < SpLim) goto cbvg; else goto cbvh;
       cbvh:
           if (HpLim == 0) goto cbvg; else goto cbvi;
       cbvg:
           R1 = _rawq::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbvi:
           (_cbvb::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rawq::P64);
           if (_cbvb::I64 == 0) goto cbvd; else goto cbvc;
       cbvd:
           call (I64[_rawq::P64])() args: 8, res: 0, upd: 8;
       cbvc:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbvb::I64;
           R2 = cbve_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:46.754783 UTC

[section "data" {
     lvl31_rawq_closure:
         const lvl31_rawq_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     cbve_str:
         I8[] [109,97,105,110]
 },
 lvl31_rawq_entry() //  [R1]
         { info_tbl: [(cbvf,
                       label: lvl31_rawq_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbvf:
           _rawq::P64 = R1;
           if ((Sp + -16) < SpLim) goto cbvg; else goto cbvh;
       cbvh:
           if (HpLim == 0) goto cbvg; else goto cbvi;
       cbvg:
           R1 = _rawq::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbvi:
           (_cbvb::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rawq::P64);
           if (_cbvb::I64 == 0) goto cbvd; else goto cbvc;
       cbvd:
           call (I64[_rawq::P64])() args: 8, res: 0, upd: 8;
       cbvc:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbvb::I64;
           R2 = cbve_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:46.759313 UTC

[section "data" {
     lvl32_rawr_closure:
         const lvl32_rawr_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     cbvv_str:
         I8[] [83,107,105,112,76,105,115,116]
 },
 lvl32_rawr_entry() //  [R1]
         { info_tbl: [(cbvw,
                       label: lvl32_rawr_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbvw:
           _rawr::P64 = R1;
           goto cbvq;
       cbvq:
           if ((old + 0) - <highSp> < SpLim) goto cbvx; else goto cbvy;
       cbvy:
           if (HpLim == 0) goto cbvx; else goto cbvz;
       cbvx:
           R1 = _rawr::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbvz:
           (_cbvs::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rawr::P64);
           if (_cbvs::I64 == 0) goto cbvu; else goto cbvt;
       cbvu:
           call (I64[_rawr::P64])() args: 8, res: 0, upd: 8;
       cbvt:
           I64[(old + 24)] = stg_bh_upd_frame_info;
           I64[(old + 16)] = _cbvs::I64;
           R2 = cbvv_str;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:46.761398 UTC

{offset
  cbvw:
      _rawr::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cbvx; else goto cbvy;
  cbvy:
      if (HpLim == 0) goto cbvx; else goto cbvz;
  cbvx:
      R1 = _rawr::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cbvz:
      (_cbvs::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rawr::P64);
      if (_cbvs::I64 == 0) goto cbvu; else goto cbvt;
  cbvu:
      call (I64[_rawr::P64])() args: 8, res: 0, upd: 8;
  cbvt:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _cbvs::I64;
      R2 = cbvv_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:46.762532 UTC

{offset
  cbvw:
      _rawr::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cbvx; else goto cbvy;
  cbvy:
      if (HpLim == 0) goto cbvx; else goto cbvz;
  cbvx:
      R1 = _rawr::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cbvz:
      (_cbvs::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rawr::P64);
      if (_cbvs::I64 == 0) goto cbvu; else goto cbvt;
  cbvu:
      call (I64[_rawr::P64])() args: 8, res: 0, upd: 8;
  cbvt:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _cbvs::I64;
      R2 = cbvv_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:46.763662 UTC

{offset
  cbvw:
      _rawr::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cbvx; else goto cbvy;
  cbvy:
      if (HpLim == 0) goto cbvx; else goto cbvz;
  cbvx:
      R1 = _rawr::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cbvz:
      (_cbvs::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rawr::P64);
      if (_cbvs::I64 == 0) goto cbvu; else goto cbvt;
  cbvu:
      call (I64[_rawr::P64])() args: 8, res: 0, upd: 8;
  cbvt:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _cbvs::I64;
      R2 = cbvv_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:46.764821 UTC

{offset
  cbvw:
      _rawr::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto cbvx; else goto cbvy;
  cbvy:
      if (HpLim == 0) goto cbvx; else goto cbvz;
  cbvx:
      R1 = _rawr::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cbvz:
      (_cbvs::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rawr::P64);
      if (_cbvs::I64 == 0) goto cbvu; else goto cbvt;
  cbvu:
      call (I64[_rawr::P64])() args: 8, res: 0, upd: 8;
  cbvt:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _cbvs::I64;
      R2 = cbvv_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:46.765961 UTC

{offset
  cbvw:
      _rawr::P64 = R1;
      if ((Sp + -16) < SpLim) goto cbvx; else goto cbvy;
  cbvy:
      if (HpLim == 0) goto cbvx; else goto cbvz;
  cbvx:
      R1 = _rawr::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cbvz:
      (_cbvs::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rawr::P64);
      if (_cbvs::I64 == 0) goto cbvu; else goto cbvt;
  cbvu:
      call (I64[_rawr::P64])() args: 8, res: 0, upd: 8;
  cbvt:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _cbvs::I64;
      R2 = cbvv_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:46.76725 UTC

[(cbvt, {}), (cbvu, {}), (cbvw, {}), (cbvx, {}), (cbvy, {}),
 (cbvz, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:46.767629 UTC

lvl32_rawr_entry() //  [R1]
        { info_tbl: [(cbvw,
                      label: lvl32_rawr_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cbvw:
          _rawr::P64 = R1;
          if ((Sp + -16) < SpLim) goto cbvx; else goto cbvy;
      cbvy:
          if (HpLim == 0) goto cbvx; else goto cbvz;
      cbvx:
          R1 = _rawr::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      cbvz:
          (_cbvs::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rawr::P64);
          if (_cbvs::I64 == 0) goto cbvu; else goto cbvt;
      cbvu:
          call (I64[_rawr::P64])() args: 8, res: 0, upd: 8;
      cbvt:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _cbvs::I64;
          R2 = cbvv_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:46.769006 UTC

lvl32_rawr_entry() //  [R1]
        { info_tbl: [(cbvw,
                      label: lvl32_rawr_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cbvw:
          _rawr::P64 = R1;
          if ((Sp + -16) < SpLim) goto cbvx; else goto cbvy;
      cbvy:
          if (HpLim == 0) goto cbvx; else goto cbvz;
      cbvx:
          R1 = _rawr::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      cbvz:
          (_cbvs::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rawr::P64);
          if (_cbvs::I64 == 0) goto cbvu; else goto cbvt;
      cbvu:
          call (I64[_rawr::P64])() args: 8, res: 0, upd: 8;
      cbvt:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _cbvs::I64;
          R2 = cbvv_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:46.7704 UTC

[section "data" {
     lvl32_rawr_closure:
         const lvl32_rawr_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     cbvv_str:
         I8[] [83,107,105,112,76,105,115,116]
 },
 lvl32_rawr_entry() //  [R1]
         { info_tbl: [(cbvw,
                       label: lvl32_rawr_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbvw:
           _rawr::P64 = R1;
           if ((Sp + -16) < SpLim) goto cbvx; else goto cbvy;
       cbvy:
           if (HpLim == 0) goto cbvx; else goto cbvz;
       cbvx:
           R1 = _rawr::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbvz:
           (_cbvs::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rawr::P64);
           if (_cbvs::I64 == 0) goto cbvu; else goto cbvt;
       cbvu:
           call (I64[_rawr::P64])() args: 8, res: 0, upd: 8;
       cbvt:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbvs::I64;
           R2 = cbvv_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:46.772109 UTC

[section "data" {
     lvl32_rawr_closure:
         const lvl32_rawr_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     cbvv_str:
         I8[] [83,107,105,112,76,105,115,116]
 },
 lvl32_rawr_entry() //  [R1]
         { info_tbl: [(cbvw,
                       label: lvl32_rawr_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbvw:
           _rawr::P64 = R1;
           if ((Sp + -16) < SpLim) goto cbvx; else goto cbvy;
       cbvy:
           if (HpLim == 0) goto cbvx; else goto cbvz;
       cbvx:
           R1 = _rawr::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbvz:
           (_cbvs::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rawr::P64);
           if (_cbvs::I64 == 0) goto cbvu; else goto cbvt;
       cbvu:
           call (I64[_rawr::P64])() args: 8, res: 0, upd: 8;
       cbvt:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbvs::I64;
           R2 = cbvv_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:46.776691 UTC

[section "data" {
     lvl33_raws_closure:
         const lvl33_raws_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     cbvM_str:
         I8[] [46,47,83,107,105,112,76,105,115,116,46,104,115]
 },
 lvl33_raws_entry() //  [R1]
         { info_tbl: [(cbvN,
                       label: lvl33_raws_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbvN:
           _raws::P64 = R1;
           goto cbvH;
       cbvH:
           if ((old + 0) - <highSp> < SpLim) goto cbvO; else goto cbvP;
       cbvP:
           if (HpLim == 0) goto cbvO; else goto cbvQ;
       cbvO:
           R1 = _raws::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbvQ:
           (_cbvJ::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _raws::P64);
           if (_cbvJ::I64 == 0) goto cbvL; else goto cbvK;
       cbvL:
           call (I64[_raws::P64])() args: 8, res: 0, upd: 8;
       cbvK:
           I64[(old + 24)] = stg_bh_upd_frame_info;
           I64[(old + 16)] = _cbvJ::I64;
           R2 = cbvM_str;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:46.778819 UTC

{offset
  cbvN:
      _raws::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cbvO; else goto cbvP;
  cbvP:
      if (HpLim == 0) goto cbvO; else goto cbvQ;
  cbvO:
      R1 = _raws::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cbvQ:
      (_cbvJ::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _raws::P64);
      if (_cbvJ::I64 == 0) goto cbvL; else goto cbvK;
  cbvL:
      call (I64[_raws::P64])() args: 8, res: 0, upd: 8;
  cbvK:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _cbvJ::I64;
      R2 = cbvM_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:46.779914 UTC

{offset
  cbvN:
      _raws::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cbvO; else goto cbvP;
  cbvP:
      if (HpLim == 0) goto cbvO; else goto cbvQ;
  cbvO:
      R1 = _raws::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cbvQ:
      (_cbvJ::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _raws::P64);
      if (_cbvJ::I64 == 0) goto cbvL; else goto cbvK;
  cbvL:
      call (I64[_raws::P64])() args: 8, res: 0, upd: 8;
  cbvK:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _cbvJ::I64;
      R2 = cbvM_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:46.781027 UTC

{offset
  cbvN:
      _raws::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cbvO; else goto cbvP;
  cbvP:
      if (HpLim == 0) goto cbvO; else goto cbvQ;
  cbvO:
      R1 = _raws::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cbvQ:
      (_cbvJ::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _raws::P64);
      if (_cbvJ::I64 == 0) goto cbvL; else goto cbvK;
  cbvL:
      call (I64[_raws::P64])() args: 8, res: 0, upd: 8;
  cbvK:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _cbvJ::I64;
      R2 = cbvM_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:46.782734 UTC

{offset
  cbvN:
      _raws::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto cbvO; else goto cbvP;
  cbvP:
      if (HpLim == 0) goto cbvO; else goto cbvQ;
  cbvO:
      R1 = _raws::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cbvQ:
      (_cbvJ::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _raws::P64);
      if (_cbvJ::I64 == 0) goto cbvL; else goto cbvK;
  cbvL:
      call (I64[_raws::P64])() args: 8, res: 0, upd: 8;
  cbvK:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _cbvJ::I64;
      R2 = cbvM_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:46.783882 UTC

{offset
  cbvN:
      _raws::P64 = R1;
      if ((Sp + -16) < SpLim) goto cbvO; else goto cbvP;
  cbvP:
      if (HpLim == 0) goto cbvO; else goto cbvQ;
  cbvO:
      R1 = _raws::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cbvQ:
      (_cbvJ::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _raws::P64);
      if (_cbvJ::I64 == 0) goto cbvL; else goto cbvK;
  cbvL:
      call (I64[_raws::P64])() args: 8, res: 0, upd: 8;
  cbvK:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _cbvJ::I64;
      R2 = cbvM_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:46.785154 UTC

[(cbvK, {}), (cbvL, {}), (cbvN, {}), (cbvO, {}), (cbvP, {}),
 (cbvQ, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:46.785534 UTC

lvl33_raws_entry() //  [R1]
        { info_tbl: [(cbvN,
                      label: lvl33_raws_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cbvN:
          _raws::P64 = R1;
          if ((Sp + -16) < SpLim) goto cbvO; else goto cbvP;
      cbvP:
          if (HpLim == 0) goto cbvO; else goto cbvQ;
      cbvO:
          R1 = _raws::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      cbvQ:
          (_cbvJ::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _raws::P64);
          if (_cbvJ::I64 == 0) goto cbvL; else goto cbvK;
      cbvL:
          call (I64[_raws::P64])() args: 8, res: 0, upd: 8;
      cbvK:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _cbvJ::I64;
          R2 = cbvM_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:46.786885 UTC

lvl33_raws_entry() //  [R1]
        { info_tbl: [(cbvN,
                      label: lvl33_raws_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cbvN:
          _raws::P64 = R1;
          if ((Sp + -16) < SpLim) goto cbvO; else goto cbvP;
      cbvP:
          if (HpLim == 0) goto cbvO; else goto cbvQ;
      cbvO:
          R1 = _raws::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      cbvQ:
          (_cbvJ::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _raws::P64);
          if (_cbvJ::I64 == 0) goto cbvL; else goto cbvK;
      cbvL:
          call (I64[_raws::P64])() args: 8, res: 0, upd: 8;
      cbvK:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _cbvJ::I64;
          R2 = cbvM_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:46.788287 UTC

[section "data" {
     lvl33_raws_closure:
         const lvl33_raws_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     cbvM_str:
         I8[] [46,47,83,107,105,112,76,105,115,116,46,104,115]
 },
 lvl33_raws_entry() //  [R1]
         { info_tbl: [(cbvN,
                       label: lvl33_raws_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbvN:
           _raws::P64 = R1;
           if ((Sp + -16) < SpLim) goto cbvO; else goto cbvP;
       cbvP:
           if (HpLim == 0) goto cbvO; else goto cbvQ;
       cbvO:
           R1 = _raws::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbvQ:
           (_cbvJ::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _raws::P64);
           if (_cbvJ::I64 == 0) goto cbvL; else goto cbvK;
       cbvL:
           call (I64[_raws::P64])() args: 8, res: 0, upd: 8;
       cbvK:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbvJ::I64;
           R2 = cbvM_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:46.790025 UTC

[section "data" {
     lvl33_raws_closure:
         const lvl33_raws_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     cbvM_str:
         I8[] [46,47,83,107,105,112,76,105,115,116,46,104,115]
 },
 lvl33_raws_entry() //  [R1]
         { info_tbl: [(cbvN,
                       label: lvl33_raws_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbvN:
           _raws::P64 = R1;
           if ((Sp + -16) < SpLim) goto cbvO; else goto cbvP;
       cbvP:
           if (HpLim == 0) goto cbvO; else goto cbvQ;
       cbvO:
           R1 = _raws::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbvQ:
           (_cbvJ::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _raws::P64);
           if (_cbvJ::I64 == 0) goto cbvL; else goto cbvK;
       cbvL:
           call (I64[_raws::P64])() args: 8, res: 0, upd: 8;
       cbvK:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbvJ::I64;
           R2 = cbvM_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:46.794715 UTC

[section "data" {
     lvl34_rawt_closure:
         const GHC.Types.I#_static_info;
         const 170;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:46.795095 UTC

[section "data" {
     lvl34_rawt_closure:
         const GHC.Types.I#_static_info;
         const 170;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:46.795414 UTC

[section "data" {
     lvl34_rawt_closure:
         const GHC.Types.I#_static_info;
         const 170;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:46.796062 UTC

[section "data" {
     lvl35_rawu_closure:
         const GHC.Stack.Types.SrcLoc_static_info;
         const lvl31_rawq_closure;
         const lvl32_rawr_closure;
         const lvl33_raws_closure;
         const lvl34_rawt_closure+1;
         const lvl22_rawg_closure+1;
         const lvl34_rawt_closure+1;
         const lvl23_rawh_closure+1;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:46.796669 UTC

[section "data" {
     lvl35_rawu_closure:
         const GHC.Stack.Types.SrcLoc_static_info;
         const lvl31_rawq_closure;
         const lvl32_rawr_closure;
         const lvl33_raws_closure;
         const lvl34_rawt_closure+1;
         const lvl22_rawg_closure+1;
         const lvl34_rawt_closure+1;
         const lvl23_rawh_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:46.797253 UTC

[section "data" {
     lvl35_rawu_closure:
         const GHC.Stack.Types.SrcLoc_static_info;
         const lvl31_rawq_closure;
         const lvl32_rawr_closure;
         const lvl33_raws_closure;
         const lvl34_rawt_closure+1;
         const lvl22_rawg_closure+1;
         const lvl34_rawt_closure+1;
         const lvl23_rawh_closure+1;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:46.798278 UTC

[section "data" {
     lvl36_rawv_closure:
         const (,)_static_info;
         const lvl7_raw1_closure;
         const lvl35_rawu_closure+1;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:46.798702 UTC

[section "data" {
     lvl36_rawv_closure:
         const (,)_static_info;
         const lvl7_raw1_closure;
         const lvl35_rawu_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:46.799073 UTC

[section "data" {
     lvl36_rawv_closure:
         const (,)_static_info;
         const lvl7_raw1_closure;
         const lvl35_rawu_closure+1;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:46.79977 UTC

[section "data" {
     lvl37_raww_closure:
         const :_static_info;
         const lvl36_rawv_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:46.800189 UTC

[section "data" {
     lvl37_raww_closure:
         const :_static_info;
         const lvl36_rawv_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:46.800568 UTC

[section "data" {
     lvl37_raww_closure:
         const :_static_info;
         const lvl36_rawv_closure+1;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:46.801262 UTC

[section "data" {
     lvl38_rawx_closure:
         const GHC.Stack.Types.CallStack_static_info;
         const lvl37_raww_closure+2;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:46.80165 UTC

[section "data" {
     lvl38_rawx_closure:
         const GHC.Stack.Types.CallStack_static_info;
         const lvl37_raww_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:46.802483 UTC

[section "data" {
     lvl38_rawx_closure:
         const GHC.Stack.Types.CallStack_static_info;
         const lvl37_raww_closure+2;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:46.803117 UTC

[section "data" {
     lvl39_rawy_closure:
         const lvl39_rawy_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     cbwd_str:
         I8[] [80,84,83,84,65,83,76,80,81,58,32,109,97,105,110,32,108,97,121,111,117,116,32,109,117,115,116,32,98,101,32,110,111,116,32,108,111,119,101,114,32,116,104,97,110,32,110,101,119,32,111,110,101]
 },
 lvl39_rawy_entry() //  [R1]
         { info_tbl: [(cbwe,
                       label: lvl39_rawy_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbwe:
           _rawy::P64 = R1;
           goto cbw8;
       cbw8:
           if ((old + 0) - <highSp> < SpLim) goto cbwf; else goto cbwg;
       cbwg:
           if (HpLim == 0) goto cbwf; else goto cbwh;
       cbwf:
           R1 = _rawy::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbwh:
           (_cbwa::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rawy::P64);
           if (_cbwa::I64 == 0) goto cbwc; else goto cbwb;
       cbwc:
           call (I64[_rawy::P64])() args: 8, res: 0, upd: 8;
       cbwb:
           I64[(old + 24)] = stg_bh_upd_frame_info;
           I64[(old + 16)] = _cbwa::I64;
           R2 = cbwd_str;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:46.805264 UTC

{offset
  cbwe:
      _rawy::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cbwf; else goto cbwg;
  cbwg:
      if (HpLim == 0) goto cbwf; else goto cbwh;
  cbwf:
      R1 = _rawy::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cbwh:
      (_cbwa::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rawy::P64);
      if (_cbwa::I64 == 0) goto cbwc; else goto cbwb;
  cbwc:
      call (I64[_rawy::P64])() args: 8, res: 0, upd: 8;
  cbwb:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _cbwa::I64;
      R2 = cbwd_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:46.806372 UTC

{offset
  cbwe:
      _rawy::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cbwf; else goto cbwg;
  cbwg:
      if (HpLim == 0) goto cbwf; else goto cbwh;
  cbwf:
      R1 = _rawy::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cbwh:
      (_cbwa::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rawy::P64);
      if (_cbwa::I64 == 0) goto cbwc; else goto cbwb;
  cbwc:
      call (I64[_rawy::P64])() args: 8, res: 0, upd: 8;
  cbwb:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _cbwa::I64;
      R2 = cbwd_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:46.80751 UTC

{offset
  cbwe:
      _rawy::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cbwf; else goto cbwg;
  cbwg:
      if (HpLim == 0) goto cbwf; else goto cbwh;
  cbwf:
      R1 = _rawy::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cbwh:
      (_cbwa::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rawy::P64);
      if (_cbwa::I64 == 0) goto cbwc; else goto cbwb;
  cbwc:
      call (I64[_rawy::P64])() args: 8, res: 0, upd: 8;
  cbwb:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _cbwa::I64;
      R2 = cbwd_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:46.808665 UTC

{offset
  cbwe:
      _rawy::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto cbwf; else goto cbwg;
  cbwg:
      if (HpLim == 0) goto cbwf; else goto cbwh;
  cbwf:
      R1 = _rawy::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cbwh:
      (_cbwa::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rawy::P64);
      if (_cbwa::I64 == 0) goto cbwc; else goto cbwb;
  cbwc:
      call (I64[_rawy::P64])() args: 8, res: 0, upd: 8;
  cbwb:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _cbwa::I64;
      R2 = cbwd_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:46.809815 UTC

{offset
  cbwe:
      _rawy::P64 = R1;
      if ((Sp + -16) < SpLim) goto cbwf; else goto cbwg;
  cbwg:
      if (HpLim == 0) goto cbwf; else goto cbwh;
  cbwf:
      R1 = _rawy::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cbwh:
      (_cbwa::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rawy::P64);
      if (_cbwa::I64 == 0) goto cbwc; else goto cbwb;
  cbwc:
      call (I64[_rawy::P64])() args: 8, res: 0, upd: 8;
  cbwb:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _cbwa::I64;
      R2 = cbwd_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:46.811109 UTC

[(cbwb, {}), (cbwc, {}), (cbwe, {}), (cbwf, {}), (cbwg, {}),
 (cbwh, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:46.811493 UTC

lvl39_rawy_entry() //  [R1]
        { info_tbl: [(cbwe,
                      label: lvl39_rawy_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cbwe:
          _rawy::P64 = R1;
          if ((Sp + -16) < SpLim) goto cbwf; else goto cbwg;
      cbwg:
          if (HpLim == 0) goto cbwf; else goto cbwh;
      cbwf:
          R1 = _rawy::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      cbwh:
          (_cbwa::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rawy::P64);
          if (_cbwa::I64 == 0) goto cbwc; else goto cbwb;
      cbwc:
          call (I64[_rawy::P64])() args: 8, res: 0, upd: 8;
      cbwb:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _cbwa::I64;
          R2 = cbwd_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:46.812984 UTC

lvl39_rawy_entry() //  [R1]
        { info_tbl: [(cbwe,
                      label: lvl39_rawy_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cbwe:
          _rawy::P64 = R1;
          if ((Sp + -16) < SpLim) goto cbwf; else goto cbwg;
      cbwg:
          if (HpLim == 0) goto cbwf; else goto cbwh;
      cbwf:
          R1 = _rawy::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      cbwh:
          (_cbwa::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rawy::P64);
          if (_cbwa::I64 == 0) goto cbwc; else goto cbwb;
      cbwc:
          call (I64[_rawy::P64])() args: 8, res: 0, upd: 8;
      cbwb:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _cbwa::I64;
          R2 = cbwd_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:46.814337 UTC

[section "data" {
     lvl39_rawy_closure:
         const lvl39_rawy_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     cbwd_str:
         I8[] [80,84,83,84,65,83,76,80,81,58,32,109,97,105,110,32,108,97,121,111,117,116,32,109,117,115,116,32,98,101,32,110,111,116,32,108,111,119,101,114,32,116,104,97,110,32,110,101,119,32,111,110,101]
 },
 lvl39_rawy_entry() //  [R1]
         { info_tbl: [(cbwe,
                       label: lvl39_rawy_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbwe:
           _rawy::P64 = R1;
           if ((Sp + -16) < SpLim) goto cbwf; else goto cbwg;
       cbwg:
           if (HpLim == 0) goto cbwf; else goto cbwh;
       cbwf:
           R1 = _rawy::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbwh:
           (_cbwa::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rawy::P64);
           if (_cbwa::I64 == 0) goto cbwc; else goto cbwb;
       cbwc:
           call (I64[_rawy::P64])() args: 8, res: 0, upd: 8;
       cbwb:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbwa::I64;
           R2 = cbwd_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:46.81605 UTC

[section "data" {
     lvl39_rawy_closure:
         const lvl39_rawy_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     cbwd_str:
         I8[] [80,84,83,84,65,83,76,80,81,58,32,109,97,105,110,32,108,97,121,111,117,116,32,109,117,115,116,32,98,101,32,110,111,116,32,108,111,119,101,114,32,116,104,97,110,32,110,101,119,32,111,110,101]
 },
 lvl39_rawy_entry() //  [R1]
         { info_tbl: [(cbwe,
                       label: lvl39_rawy_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbwe:
           _rawy::P64 = R1;
           if ((Sp + -16) < SpLim) goto cbwf; else goto cbwg;
       cbwg:
           if (HpLim == 0) goto cbwf; else goto cbwh;
       cbwf:
           R1 = _rawy::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbwh:
           (_cbwa::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rawy::P64);
           if (_cbwa::I64 == 0) goto cbwc; else goto cbwb;
       cbwc:
           call (I64[_rawy::P64])() args: 8, res: 0, upd: 8;
       cbwb:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbwa::I64;
           R2 = cbwd_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:46.821021 UTC

[section "data" {
     lvl40_rawz_closure:
         const lvl40_rawz_info;
         const 0;
         const 0;
         const 0;
 },
 lvl40_rawz_entry() //  [R1]
         { info_tbl: [(cbwu,
                       label: lvl40_rawz_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbwu:
           _rawz::P64 = R1;
           goto cbwp;
       cbwp:
           if ((old + 0) - <highSp> < SpLim) goto cbwv; else goto cbww;
       cbww:
           if (HpLim == 0) goto cbwv; else goto cbwx;
       cbwv:
           R1 = _rawz::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbwx:
           (_cbwr::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rawz::P64);
           if (_cbwr::I64 == 0) goto cbwt; else goto cbws;
       cbwt:
           call (I64[_rawz::P64])() args: 8, res: 0, upd: 8;
       cbws:
           I64[(old + 24)] = stg_bh_upd_frame_info;
           I64[(old + 16)] = _cbwr::I64;
           R3 = lvl39_rawy_closure;
           R2 = lvl38_rawx_closure+1;
           call GHC.Err.error_info(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:46.823211 UTC

{offset
  cbwu:
      _rawz::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cbwv; else goto cbww;
  cbww:
      if (HpLim == 0) goto cbwv; else goto cbwx;
  cbwv:
      R1 = _rawz::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cbwx:
      (_cbwr::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rawz::P64);
      if (_cbwr::I64 == 0) goto cbwt; else goto cbws;
  cbwt:
      call (I64[_rawz::P64])() args: 8, res: 0, upd: 8;
  cbws:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _cbwr::I64;
      R3 = lvl39_rawy_closure;
      R2 = lvl38_rawx_closure+1;
      call GHC.Err.error_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:46.824363 UTC

{offset
  cbwu:
      _rawz::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cbwv; else goto cbww;
  cbww:
      if (HpLim == 0) goto cbwv; else goto cbwx;
  cbwv:
      R1 = _rawz::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cbwx:
      (_cbwr::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rawz::P64);
      if (_cbwr::I64 == 0) goto cbwt; else goto cbws;
  cbwt:
      call (I64[_rawz::P64])() args: 8, res: 0, upd: 8;
  cbws:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _cbwr::I64;
      R3 = lvl39_rawy_closure;
      R2 = lvl38_rawx_closure+1;
      call GHC.Err.error_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:46.825553 UTC

{offset
  cbwu:
      _rawz::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cbwv; else goto cbww;
  cbww:
      if (HpLim == 0) goto cbwv; else goto cbwx;
  cbwv:
      R1 = _rawz::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cbwx:
      (_cbwr::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rawz::P64);
      if (_cbwr::I64 == 0) goto cbwt; else goto cbws;
  cbwt:
      call (I64[_rawz::P64])() args: 8, res: 0, upd: 8;
  cbws:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _cbwr::I64;
      R3 = lvl39_rawy_closure;
      R2 = lvl38_rawx_closure+1;
      call GHC.Err.error_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:46.826763 UTC

{offset
  cbwu:
      _rawz::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto cbwv; else goto cbww;
  cbww:
      if (HpLim == 0) goto cbwv; else goto cbwx;
  cbwv:
      R1 = _rawz::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cbwx:
      (_cbwr::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rawz::P64);
      if (_cbwr::I64 == 0) goto cbwt; else goto cbws;
  cbwt:
      call (I64[_rawz::P64])() args: 8, res: 0, upd: 8;
  cbws:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _cbwr::I64;
      R3 = lvl39_rawy_closure;
      R2 = lvl38_rawx_closure+1;
      Sp = Sp - 16;
      call GHC.Err.error_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:46.827966 UTC

{offset
  cbwu:
      _rawz::P64 = R1;
      if ((Sp + -16) < SpLim) goto cbwv; else goto cbww;
  cbww:
      if (HpLim == 0) goto cbwv; else goto cbwx;
  cbwv:
      R1 = _rawz::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cbwx:
      (_cbwr::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rawz::P64);
      if (_cbwr::I64 == 0) goto cbwt; else goto cbws;
  cbwt:
      call (I64[_rawz::P64])() args: 8, res: 0, upd: 8;
  cbws:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _cbwr::I64;
      R3 = lvl39_rawy_closure;
      R2 = lvl38_rawx_closure+1;
      Sp = Sp - 16;
      call GHC.Err.error_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:46.829317 UTC

[(cbws,
  {GHC.Err.error_closure, lvl38_rawx_closure, lvl39_rawy_closure}),
 (cbwt, {}),
 (cbwu,
  {GHC.Err.error_closure, lvl38_rawx_closure, lvl39_rawy_closure}),
 (cbwv, {}),
 (cbww,
  {GHC.Err.error_closure, lvl38_rawx_closure, lvl39_rawy_closure}),
 (cbwx,
  {GHC.Err.error_closure, lvl38_rawx_closure, lvl39_rawy_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:46.830116 UTC

lvl40_rawz_entry() //  [R1]
        { info_tbl: [(cbwu,
                      label: lvl40_rawz_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cbwu:
          _rawz::P64 = R1;
          if ((Sp + -16) < SpLim) goto cbwv; else goto cbww;
      cbww:
          if (HpLim == 0) goto cbwv; else goto cbwx;
      cbwv:
          R1 = _rawz::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      cbwx:
          (_cbwr::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rawz::P64);
          if (_cbwr::I64 == 0) goto cbwt; else goto cbws;
      cbwt:
          call (I64[_rawz::P64])() args: 8, res: 0, upd: 8;
      cbws:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _cbwr::I64;
          R3 = lvl39_rawy_closure;
          R2 = lvl38_rawx_closure+1;
          Sp = Sp - 16;
          call GHC.Err.error_info(R3, R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:46.831567 UTC

lvl40_rawz_entry() //  [R1]
        { info_tbl: [(cbwu,
                      label: lvl40_rawz_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cbwu:
          _rawz::P64 = R1;
          if ((Sp + -16) < SpLim) goto cbwv; else goto cbww;
      cbww:
          if (HpLim == 0) goto cbwv; else goto cbwx;
      cbwv:
          R1 = _rawz::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      cbwx:
          (_cbwr::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rawz::P64);
          if (_cbwr::I64 == 0) goto cbwt; else goto cbws;
      cbwt:
          call (I64[_rawz::P64])() args: 8, res: 0, upd: 8;
      cbws:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _cbwr::I64;
          R3 = lvl39_rawy_closure;
          R2 = lvl38_rawx_closure+1;
          Sp = Sp - 16;
          call GHC.Err.error_info(R3, R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:46.833038 UTC

[section "data" {
     lvl40_rawz_closure:
         const lvl40_rawz_info;
         const 0;
         const 0;
         const 0;
 },
 lvl40_rawz_entry() //  [R1]
         { info_tbl: [(cbwu,
                       label: lvl40_rawz_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbwu:
           _rawz::P64 = R1;
           if ((Sp + -16) < SpLim) goto cbwv; else goto cbww;
       cbww:
           if (HpLim == 0) goto cbwv; else goto cbwx;
       cbwv:
           R1 = _rawz::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbwx:
           (_cbwr::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rawz::P64);
           if (_cbwr::I64 == 0) goto cbwt; else goto cbws;
       cbwt:
           call (I64[_rawz::P64])() args: 8, res: 0, upd: 8;
       cbws:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbwr::I64;
           R3 = lvl39_rawy_closure;
           R2 = lvl38_rawx_closure+1;
           Sp = Sp - 16;
           call GHC.Err.error_info(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:46.835322 UTC

[section "data" {
     lvl40_rawz_closure:
         const lvl40_rawz_info;
         const 0;
         const 0;
         const 0;
 },
 lvl40_rawz_entry() //  [R1]
         { info_tbl: [(cbwu,
                       label: lvl40_rawz_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbwu:
           _rawz::P64 = R1;
           if ((Sp + -16) < SpLim) goto cbwv; else goto cbww;
       cbww:
           if (HpLim == 0) goto cbwv; else goto cbwx;
       cbwv:
           R1 = _rawz::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbwx:
           (_cbwr::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rawz::P64);
           if (_cbwr::I64 == 0) goto cbwt; else goto cbws;
       cbwt:
           call (I64[_rawz::P64])() args: 8, res: 0, upd: 8;
       cbws:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cbwr::I64;
           R3 = lvl39_rawy_closure;
           R2 = lvl38_rawx_closure+1;
           Sp = Sp - 16;
           call GHC.Err.error_info(R3, R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:46.846015 UTC

[section "data" {
     SkipList.$wa4_closure:
         const SkipList.$wa4_info;
         const 0;
 },
 $wa8_saFO_entry() //  [R4, R3, R2, R1]
         { info_tbl: [(cbDh,
                       label: $wa8_saFO_info
                       rep:HeapRep 3 ptrs { Fun {arity: 4 fun_type: ArgSpec 21} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbDh:
           _saGC::P64 = R4;
           _saGB::I64 = R3;
           _saGA::P64 = R2;
           _saFO::P64 = R1;
           goto cbDb;
       cbDb:
           if ((old + 0) - <highSp> < SpLim) goto cbDi; else goto cbDj;
       cbDj:
           goto cbDa;
       cbDa:
           if (HpLim == 0) goto cbDi; else goto cbES;
       cbDi:
           R4 = _saGC::P64;
           R3 = _saGB::I64;
           R2 = _saGA::P64;
           R1 = _saFO::P64;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbES:
           _saFB::P64 = P64[_saFO::P64 + 4];
           _saFF::P64 = P64[_saFO::P64 + 12];
           _saFN::P64 = P64[_saFO::P64 + 20];
           _saGE::I64 = _saGB::I64;
           switch [-9223372036854775808 .. 9223372036854775807] _saGE::I64 {
               case 0 : goto cbDg;
               default: goto cbDf;
           }
       cbDg:
           R1 = _saGC::P64;
           call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
       cbDf:
           I64[(young<cbDl> + 8)] = cbDl;
           R1 = _saGA::P64;
           if (R1 & 7 != 0) goto cbDl; else goto cbDm;
       cbDm:
           call (I64[R1])(R1) returns to cbDl, args: 8, res: 8, upd: 8;
       cbDl:
           _saGF::P64 = R1;
           _saGG::P64 = P64[_saGF::P64 + 7];
           _saGH::P64 = P64[_saGF::P64 + 15];
           _saGJ::P64 = P64[_saGF::P64 + 23];
           _saGI::I64 = I64[_saGF::P64 + 31];
           I64[(young<cbDq> + 8)] = cbDq;
           R1 = _saGG::P64;
           if (R1 & 7 != 0) goto cbDq; else goto cbDr;
       cbDr:
           call (I64[R1])(R1) returns to cbDq, args: 8, res: 8, upd: 8;
       cbDq:
           _saGK::P64 = R1;
           _saGL::I64 = I64[_saGK::P64 + 7];
           I64[(young<cbDv> + 8)] = cbDv;
           R1 = _saGH::P64;
           if (R1 & 7 != 0) goto cbDv; else goto cbDy;
       cbDy:
           call (I64[R1])(R1) returns to cbDv, args: 8, res: 8, upd: 8;
       cbDv:
           _saGM::P64 = R1;
           _saGN::I64 = I64[_saGM::P64 + 7];
           _cbDD::I64 = %MO_S_Le_W64(_saGL::I64, _saGE::I64);
           _saGO::I64 = _cbDD::I64;
           switch [0 .. 1] _saGO::I64 {
               case 0 : goto cbDI;
               case 1 : goto cbER;
           }
       cbER:
           _cbDL::I64 = %MO_S_Le_W64(_saGE::I64, _saGN::I64);
           _saGR::I64 = _cbDL::I64;
           switch [0 .. 1] _saGR::I64 {
               case 0 : goto cbDQ;
               case 1 : goto cbEQ;
           }
       cbEQ:
           _cbDT::I64 = _saGE::I64 - _saGL::I64;
           _saGU::I64 = _cbDT::I64;
           _cbDW::I64 = %MO_S_Le_W64(0, _saGU::I64);
           _saGV::I64 = _cbDW::I64;
           switch [0 .. 1] _saGV::I64 {
               case 0 : goto cbE1;
               case 1 : goto cbEP;
           }
       cbEP:
           _cbE4::I64 = %MO_S_Lt_W64(_saGU::I64, _saGI::I64);
           _saGY::I64 = _cbE4::I64;
           switch [0 .. 1] _saGY::I64 {
               case 0 : goto cbE9;
               case 1 : goto cbEd;
           }
       cbEd:
           _saH2::P64 = P64[(_saGJ::P64 + 24) + (_saGU::I64 << 3)];
           _saH2::P64 = _saH2::P64;
           I64[(young<cbEc> + 8)] = cbEc;
           R1 = _saH2::P64;
           if (R1 & 7 != 0) goto cbEc; else goto cbEe;
       cbEe:
           call (I64[R1])(R1) returns to cbEc, args: 8, res: 8, upd: 8;
       cbEc:
           _saH3::P64 = R1;
           _saH4::P64 = P64[_saH3::P64 + 7];
           I64[(young<cbEi> + 8)] = cbEi;
           R1 = _saH4::P64;
           call stg_norec_readTVar#(R1) returns to cbEi, args: 8, res: 8, upd: 8;
       cbEi:
           _saH7::P64 = R1;
           I64[(young<cbEk> + 8)] = cbEk;
           R1 = _saH7::P64;
           if (R1 & 7 != 0) goto cbEk; else goto cbEn;
       cbEn:
           call (I64[R1])(R1) returns to cbEk, args: 8, res: 8, upd: 8;
       cbEk:
           _saH8::P64 = R1;
           _cbET::P64 = _saH8::P64 & 7;
           switch [1 .. 2] _cbET::P64 {
               case 1 : goto cbEt;
               case 2 : goto cbEB;
           }
       cbEB:
           _saHb::P64 = P64[_saH8::P64 + 6];
           _saHc::P64 = P64[_saH8::P64 + 14];
           _saHd::P64 = P64[_saH8::P64 + 22];
           I64[(young<cbEz> + 8)] = cbEz;
           R2 = _saFB::P64;
           I64[(young<cbEz> + 32)] = stg_ap_pp_info;
           P64[(young<cbEz> + 24)] = _saHb::P64;
           P64[(young<cbEz> + 16)] = _saFF::P64;
           call GHC.Classes.>_info(R2) returns to cbEz, args: 32, res: 8, upd: 8;
       cbEz:
           _saHe::P64 = R1;
           _cbEU::P64 = _saHe::P64 & 7;
           switch [1 .. 2] _cbEU::P64 {
               case 1 : goto cbEH;
               case 2 : goto cbEL;
           }
       cbEL:
           Hp = Hp + 24;
           if (Hp > HpLim) goto cbEO; else goto cbEN;
       cbEO:
           HpAlloc = 24;
           goto cbEM;
       cbEM:
           R1 = _saHe::P64;
           call stg_gc_unpt_r1(R1) returns to cbEz, args: 8, res: 8, upd: 8;
       cbEN:
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _saGF::P64;
           P64[Hp] = _saGC::P64;
           _cbEK::P64 = Hp - 14;
           _cbEV::I64 = _saGE::I64 - 1;
           _saHf::I64 = _cbEV::I64;
           R6 = _saHf::I64;
           R5 = _saGJ::P64;
           R4 = _saGI::I64;
           R3 = _saGN::I64;
           R2 = _saGL::I64;
           R1 = _saFN::P64;
           P64[(old + 16)] = _cbEK::P64;
           call $s$wa_saFN_info(R6,
                                R5,
                                R4,
                                R3,
                                R2,
                                R1) args: 16, res: 0, upd: 8;
       cbEH:
           R4 = _saGC::P64;
           R3 = _saGE::I64;
           R2 = _saHd::P64;
           R1 = _saFO::P64;
           call $wa8_saFO_info(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbEt:
           Hp = Hp + 24;
           if (Hp > HpLim) goto cbEw; else goto cbEv;
       cbEw:
           HpAlloc = 24;
           goto cbEu;
       cbEu:
           R1 = _saH8::P64;
           call stg_gc_unpt_r1(R1) returns to cbEk, args: 8, res: 8, upd: 8;
       cbEv:
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _saGF::P64;
           P64[Hp] = _saGC::P64;
           _cbEr::P64 = Hp - 14;
           _cbEW::I64 = _saGE::I64 - 1;
           _saH9::I64 = _cbEW::I64;
           R6 = _saH9::I64;
           R5 = _saGJ::P64;
           R4 = _saGI::I64;
           R3 = _saGN::I64;
           R2 = _saGL::I64;
           R1 = _saFN::P64;
           P64[(old + 16)] = _cbEr::P64;
           call $s$wa_saFN_info(R6,
                                R5,
                                R4,
                                R3,
                                R2,
                                R1) args: 16, res: 0, upd: 8;
       cbE9:
           R3 = _saGU::I64;
           R2 = _saGI::I64;
           call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
       cbE1:
           R3 = _saGU::I64;
           R2 = _saGI::I64;
           call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
       cbDQ:
           R4 = _saGM::P64;
           R3 = _saGK::P64;
           R2 = _saGE::I64;
           call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
       cbDI:
           R4 = _saGM::P64;
           R3 = _saGK::P64;
           R2 = _saGE::I64;
           call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 $s$wa_saFN_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 56 updfr_space: Just 8
         }
     {offset
       cbEY:
           _saFN::P64 = R1;
           _saFP::I64 = I64[(old + 56)];
           _saFQ::I64 = I64[(old + 48)];
           _saFR::I64 = I64[(old + 40)];
           _saFS::P64 = P64[(old + 32)];
           _saFT::I64 = I64[(old + 24)];
           _saFU::P64 = P64[(old + 16)];
           R6 = _saFT::I64;
           R5 = _saFS::P64;
           R4 = _saFR::I64;
           R3 = _saFQ::I64;
           R2 = _saFP::I64;
           R1 = _saFN::P64;
           P64[(old + 16)] = _saFU::P64;
           call $s$wa_saFN_info(R6,
                                R5,
                                R4,
                                R3,
                                R2,
                                R1) args: 16, res: 0, upd: 8;
     }
 },
 $s$wa_saFN_entry() //  [R6, R5, R4, R3, R2, R1]
         { info_tbl: [(cbG1,
                       label: $s$wa_saFN_info
                       rep:HeapRep 3 ptrs {
                             Fun {arity: 8
                                  fun_type: ArgGen [True, True, True, False, True, False]} })]
           stack_info: arg_space: 16 updfr_space: Just 8
         }
     {offset
       cbG1:
           _saFT::I64 = R6;
           _saFS::P64 = R5;
           _saFR::I64 = R4;
           _saFQ::I64 = R3;
           _saFP::I64 = R2;
           _saFN::P64 = R1;
           _saFU::P64 = P64[(old + 16)];
           goto cbFV;
       cbFV:
           if ((old + 0) - <highSp> < SpLim) goto cbG2; else goto cbG3;
       cbG3:
           goto cbFU;
       cbFU:
           Hp = Hp + 32;
           if (Hp > HpLim) goto cbG5; else goto cbG4;
       cbG5:
           HpAlloc = 32;
           goto cbG2;
       cbG2:
           R1 = _saFN::P64;
           I64[(old + 56)] = _saFP::I64;
           I64[(old + 48)] = _saFQ::I64;
           I64[(old + 40)] = _saFR::I64;
           P64[(old + 32)] = _saFS::P64;
           I64[(old + 24)] = _saFT::I64;
           P64[(old + 16)] = _saFU::P64;
           call (stg_gc_fun)(R1) args: 56, res: 0, upd: 8;
       cbG4:
           _saFB::P64 = P64[_saFN::P64 + 8];
           _saFF::P64 = P64[_saFN::P64 + 16];
           _saFO::P64 = P64[_saFN::P64 + 24];
           _saFW::I64 = _saFT::I64;
           switch [-9223372036854775808 .. 9223372036854775807] _saFW::I64 {
               case 0 : goto cbG0;
               default: goto cbFZ;
           }
       cbG0:
           Hp = Hp - 32;
           R1 = _saFU::P64;
           call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
       cbFZ:
           _cbG7::I64 = %MO_S_Le_W64(_saFP::I64, _saFW::I64);
           _saFX::I64 = _cbG7::I64;
           switch [0 .. 1] _saFX::I64 {
               case 0 : goto cbGf;
               case 1 : goto cbHv;
           }
       cbHv:
           _cbGh::I64 = %MO_S_Le_W64(_saFW::I64, _saFQ::I64);
           _saG2::I64 = _cbGh::I64;
           switch [0 .. 1] _saG2::I64 {
               case 0 : goto cbGp;
               case 1 : goto cbHu;
           }
       cbHu:
           _cbGr::I64 = _saFW::I64 - _saFP::I64;
           _saG7::I64 = _cbGr::I64;
           _cbGu::I64 = %MO_S_Le_W64(0, _saG7::I64);
           _saG8::I64 = _cbGu::I64;
           switch [0 .. 1] _saG8::I64 {
               case 0 : goto cbGz;
               case 1 : goto cbHt;
           }
       cbHt:
           _cbGC::I64 = %MO_S_Lt_W64(_saG7::I64, _saFR::I64);
           _saGb::I64 = _cbGC::I64;
           switch [0 .. 1] _saGb::I64 {
               case 0 : goto cbGH;
               case 1 : goto cbGL;
           }
       cbGL:
           _saGf::P64 = P64[(_saFS::P64 + 24) + (_saG7::I64 << 3)];
           _saGf::P64 = _saGf::P64;
           Hp = Hp - 32;
           I64[(young<cbGK> + 8)] = cbGK;
           R1 = _saGf::P64;
           if (R1 & 7 != 0) goto cbGK; else goto cbGM;
       cbGM:
           call (I64[R1])(R1) returns to cbGK, args: 8, res: 8, upd: 8;
       cbGK:
           _saGg::P64 = R1;
           _saGh::P64 = P64[_saGg::P64 + 7];
           I64[(young<cbGQ> + 8)] = cbGQ;
           R1 = _saGh::P64;
           call stg_norec_readTVar#(R1) returns to cbGQ, args: 8, res: 8, upd: 8;
       cbGQ:
           _saGk::P64 = R1;
           I64[(young<cbGS> + 8)] = cbGS;
           R1 = _saGk::P64;
           if (R1 & 7 != 0) goto cbGS; else goto cbGV;
       cbGV:
           call (I64[R1])(R1) returns to cbGS, args: 8, res: 8, upd: 8;
       cbGS:
           _saGl::P64 = R1;
           _cbHw::P64 = _saGl::P64 & 7;
           switch [1 .. 2] _cbHw::P64 {
               case 1 : goto cbH4;
               case 2 : goto cbHc;
           }
       cbHc:
           _saGr::P64 = P64[_saGl::P64 + 6];
           _saGs::P64 = P64[_saGl::P64 + 14];
           _saGt::P64 = P64[_saGl::P64 + 22];
           I64[(young<cbHa> + 8)] = cbHa;
           R2 = _saFB::P64;
           I64[(young<cbHa> + 32)] = stg_ap_pp_info;
           P64[(young<cbHa> + 24)] = _saGr::P64;
           P64[(young<cbHa> + 16)] = _saFF::P64;
           call GHC.Classes.>_info(R2) returns to cbHa, args: 32, res: 8, upd: 8;
       cbHa:
           _saGu::P64 = R1;
           _cbHx::P64 = _saGu::P64 & 7;
           switch [1 .. 2] _cbHx::P64 {
               case 1 : goto cbHi;
               case 2 : goto cbHp;
           }
       cbHp:
           Hp = Hp + 96;
           if (Hp > HpLim) goto cbHs; else goto cbHr;
       cbHs:
           HpAlloc = 96;
           goto cbHq;
       cbHq:
           R1 = _saGu::P64;
           call stg_gc_unpt_r1(R1) returns to cbHa, args: 8, res: 8, upd: 8;
       cbHr:
           I64[Hp - 88] = GHC.Types.I#_con_info;
           I64[Hp - 80] = _saFQ::I64;
           _cbHl::P64 = Hp - 87;
           I64[Hp - 72] = GHC.Types.I#_con_info;
           I64[Hp - 64] = _saFP::I64;
           _cbHm::P64 = Hp - 71;
           I64[Hp - 56] = GHC.Arr.Array_con_info;
           P64[Hp - 48] = _cbHm::P64;
           P64[Hp - 40] = _cbHl::P64;
           P64[Hp - 32] = _saFS::P64;
           I64[Hp - 24] = _saFR::I64;
           _cbHn::P64 = Hp - 55;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _cbHn::P64;
           P64[Hp] = _saFU::P64;
           _cbHo::P64 = Hp - 14;
           _cbHy::I64 = _saFW::I64 - 1;
           _saGv::I64 = _cbHy::I64;
           R6 = _saGv::I64;
           R5 = _saFS::P64;
           R4 = _saFR::I64;
           R3 = _saFQ::I64;
           R2 = _saFP::I64;
           R1 = _saFN::P64;
           P64[(old + 16)] = _cbHo::P64;
           call $s$wa_saFN_info(R6,
                                R5,
                                R4,
                                R3,
                                R2,
                                R1) args: 16, res: 0, upd: 8;
       cbHi:
           R4 = _saFU::P64;
           R3 = _saFW::I64;
           R2 = _saGt::P64;
           R1 = _saFO::P64;
           call $wa8_saFO_info(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbH4:
           Hp = Hp + 96;
           if (Hp > HpLim) goto cbH7; else goto cbH6;
       cbH7:
           HpAlloc = 96;
           goto cbH5;
       cbH5:
           R1 = _saGl::P64;
           call stg_gc_unpt_r1(R1) returns to cbGS, args: 8, res: 8, upd: 8;
       cbH6:
           I64[Hp - 88] = GHC.Types.I#_con_info;
           I64[Hp - 80] = _saFQ::I64;
           _cbGZ::P64 = Hp - 87;
           I64[Hp - 72] = GHC.Types.I#_con_info;
           I64[Hp - 64] = _saFP::I64;
           _cbH0::P64 = Hp - 71;
           I64[Hp - 56] = GHC.Arr.Array_con_info;
           P64[Hp - 48] = _cbH0::P64;
           P64[Hp - 40] = _cbGZ::P64;
           P64[Hp - 32] = _saFS::P64;
           I64[Hp - 24] = _saFR::I64;
           _cbH1::P64 = Hp - 55;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _cbH1::P64;
           P64[Hp] = _saFU::P64;
           _cbH2::P64 = Hp - 14;
           _cbHz::I64 = _saFW::I64 - 1;
           _saGm::I64 = _cbHz::I64;
           R6 = _saGm::I64;
           R5 = _saFS::P64;
           R4 = _saFR::I64;
           R3 = _saFQ::I64;
           R2 = _saFP::I64;
           R1 = _saFN::P64;
           P64[(old + 16)] = _cbH2::P64;
           call $s$wa_saFN_info(R6,
                                R5,
                                R4,
                                R3,
                                R2,
                                R1) args: 16, res: 0, upd: 8;
       cbGH:
           Hp = Hp - 32;
           R3 = _saG7::I64;
           R2 = _saFR::I64;
           call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
       cbGz:
           Hp = Hp - 32;
           R3 = _saG7::I64;
           R2 = _saFR::I64;
           call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
       cbGp:
           I64[Hp - 24] = GHC.Types.I#_con_info;
           I64[Hp - 16] = _saFQ::I64;
           _cbGm::P64 = Hp - 23;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saFP::I64;
           _cbGn::P64 = Hp - 7;
           R4 = _cbGm::P64;
           R3 = _cbGn::P64;
           R2 = _saFW::I64;
           call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
       cbGf:
           I64[Hp - 24] = GHC.Types.I#_con_info;
           I64[Hp - 16] = _saFQ::I64;
           _cbGc::P64 = Hp - 23;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saFP::I64;
           _cbGd::P64 = Hp - 7;
           R4 = _cbGc::P64;
           R3 = _cbGd::P64;
           R2 = _saFW::I64;
           call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_saHY_entry() //  [R1]
         { info_tbl: [(cbHT,
                       label: sat_saHY_info
                       rep:HeapRep 1 ptrs 1 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbHT:
           _saHY::P64 = R1;
           goto cbHP;
       cbHP:
           if ((old + 0) - <highSp> < SpLim) goto cbHU; else goto cbHV;
       cbHV:
           goto cbHO;
       cbHO:
           if (HpLim == 0) goto cbHU; else goto cbIY;
       cbHU:
           R1 = _saHY::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbIY:
           _saFE::P64 = P64[_saHY::P64 + 7];
           _saHq::I64 = I64[_saHY::P64 + 15];
           _cbHR::I64 = _saHq::I64 * 8;
           _saHu::I64 = _cbHR::I64;
           _cbHX::I64 = %MO_S_Ge_W64(_saHu::I64, 0);
           _saHv::I64 = _cbHX::I64;
           switch [0 .. 1] _saHv::I64 {
               case 0 : goto cbI4;
               case 1 : goto cbIb;
           }
       cbIb:
           I64[(young<cbIa> + 8)] = cbIa;
           R1 = _saFE::P64;
           call stg_ap_0_fast(R1) returns to cbIa, args: 8, res: 8, upd: 8;
       cbIa:
           _saHC::P64 = R1;
           Hp = Hp + 16;
           if (Hp > HpLim) goto cbIh; else goto cbIg;
       cbIh:
           HpAlloc = 16;
           goto cbIf;
       cbIf:
           R1 = _saHC::P64;
           call stg_gc_unpt_r1(R1) returns to cbIa, args: 8, res: 8, upd: 8;
       cbIg:
           _saHF::P64 = P64[_saHC::P64 + 7];
           _saHD::I64 = I64[_saHC::P64 + 15];
           _saHE::I64 = I64[_saHC::P64 + 23];
           _cbIi::I64 = %MO_S_Lt_W64(_saHu::I64, _saHE::I64);
           _saHG::I64 = _cbIi::I64;
           switch [0 .. 1] _saHG::I64 {
               case 0 : goto cbIn;
               case 1 : goto cbIX;
           }
       cbIX:
           _cbIq::I64 = _saHD::I64 + _saHu::I64;
           _saHJ::I64 = _cbIq::I64;
           _saHM::I64 = I64[(_saHF::P64 + 16) + (_saHJ::I64 << 3)];
           _saHM::I64 = _saHM::I64;
           _cbIt::I64 = _saHM::I64 * 6364136223846793005;
           _saHO::I64 = _cbIt::I64;
           _cbIw::I64 = _saHD::I64 + _saHu::I64;
           _saHN::I64 = _cbIw::I64;
           I64[(_saHF::P64 + 16) + (_saHN::I64 << 3)] = _saHO::I64;
           _cbIB::I64 = _saHM::I64 >> 61;
           _saHS::I64 = _cbIB::I64;
           _cbIE::I64 = _saHS::I64;
           _saHT::I64 = _cbIE::I64;
           _cbIH::I64 = _saHT::I64 + 22;
           _saHU::I64 = _cbIH::I64;
           _cbIK::I64 = _saHM::I64 >> 22;
           _saHQ::I64 = _cbIK::I64;
           _cbIN::I64 = _saHQ::I64 ^ _saHM::I64;
           _saHR::I64 = _cbIN::I64;
           _cbIQ::I64 = _saHR::I64 >> _saHU::I64;
           _saHV::I64 = _cbIQ::I64;
           _cbIT::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_saHV::I64));
           _saHW::I64 = _cbIT::I64;
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = _saHW::I64;
           _cbIW::P64 = Hp - 7;
           R1 = _cbIW::P64;
           call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
       cbIn:
           Hp = Hp - 16;
           R3 = _saHu::I64;
           R2 = _saHE::I64;
           call lvl5_ravU_info(R3, R2) args: 8, res: 0, upd: 8;
       cbI4:
           I64[(young<cbI2> + 8)] = cbI2;
           R1 = _saFE::P64;
           call stg_ap_0_fast(R1) returns to cbI2, args: 8, res: 8, upd: 8;
       cbI2:
           _saHx::P64 = R1;
           _saHA::P64 = P64[_saHx::P64 + 7];
           _saHy::I64 = I64[_saHx::P64 + 15];
           _saHz::I64 = I64[_saHx::P64 + 23];
           R3 = _saHu::I64;
           R2 = _saHz::I64;
           call lvl5_ravU_info(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 nodesHeight_saHs_entry() //  [R1]
         { info_tbl: [(cbJ1,
                       label: nodesHeight_saHs_info
                       rep:HeapRep 2 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbJ1:
           _saHs::P64 = R1;
           goto cbHK;
       cbHK:
           if ((old + 0) - <highSp> < SpLim) goto cbJ5; else goto cbJ6;
       cbJ6:
           Hp = Hp + 24;
           if (Hp > HpLim) goto cbJ8; else goto cbJ7;
       cbJ8:
           HpAlloc = 24;
           goto cbJ5;
       cbJ5:
           R1 = _saHs::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJ7:
           I64[(old + 24)] = stg_upd_frame_info;
           P64[(old + 16)] = _saHs::P64;
           _saFE::P64 = P64[_saHs::P64 + 16];
           _saFL::P64 = P64[_saHs::P64 + 24];
           _saFM::I64 = I64[_saHs::P64 + 32];
           _saHq::I64 = I64[_saHs::P64 + 40];
           I64[Hp - 16] = sat_saHY_info;
           P64[Hp - 8] = _saFE::P64;
           I64[Hp] = _saHq::I64;
           _cbHM::P64 = Hp - 15;
           I64[(young<cbIZ> + 8)] = cbIZ;
           R2 = _cbHM::P64;
           call GHC.IO.unsafeDupablePerformIO_info(R2) returns to cbIZ, args: 8, res: 8, upd: 24;
       cbIZ:
           _saHZ::P64 = R1;
           _saI0::I64 = I64[_saHZ::P64 + 7];
           I64[(young<cbJ4> + 8)] = cbJ4;
           R1 = logHalf_r2BC_closure;
           if (R1 & 7 != 0) goto cbJ4; else goto cbJa;
       cbJa:
           call (I64[R1])(R1) returns to cbJ4, args: 8, res: 8, upd: 24;
       cbJ4:
           _saI1::P64 = R1;
           Hp = Hp + 16;
           if (Hp > HpLim) goto cbJg; else goto cbJf;
       cbJg:
           HpAlloc = 16;
           goto cbJe;
       cbJe:
           R1 = _saI1::P64;
           call stg_gc_unpt_r1(R1) returns to cbJ4, args: 8, res: 8, upd: 24;
       cbJf:
           _saI2::F32 = F32[_saI1::P64 + 7];
           _cbJi::I64 = 4294967295;
           (_cbJh::F32) = call MO_UF_Conv W32(_cbJi::I64);
           _saI4::F32 = _cbJh::F32;
           _cbJm::I64 = _saI0::I64;
           (_cbJl::F32) = call MO_UF_Conv W32(_cbJm::I64);
           _saI3::F32 = _cbJl::F32;
           _cbJp::F32 = %MO_F_Quot_W32(_saI3::F32, _saI4::F32);
           _saI5::F32 = _cbJp::F32;
           _cbJt::F32 = _saI5::F32;
           (_cbJs::F32) = call MO_F32_Log(_cbJt::F32);
           _saI6::F32 = _cbJs::F32;
           _cbJw::F32 = %MO_F_Quot_W32(_saI6::F32, _saI2::F32);
           _saI7::F32 = _cbJw::F32;
           _cbJz::I64 = %MO_FS_Conv_W32_W64(_saI7::F32);
           _saI9::I64 = _cbJz::I64;
           _cbJC::I64 = _saI9::I64 + 1;
           _saI8::I64 = _cbJC::I64;
           _cbJF::I64 = %MO_S_Le_W64(_saFM::I64, _saI8::I64);
           _saIa::I64 = _cbJF::I64;
           switch [0 .. 1] _saIa::I64 {
               case 0 : goto cbJM;
               case 1 : goto cbJN;
           }
       cbJN:
           Hp = Hp - 16;
           R1 = _saFL::P64 & (-8);
           call (I64[R1])(R1) args: 24, res: 0, upd: 24;
       cbJM:
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saI8::I64;
           _cbJK::P64 = Hp - 7;
           R1 = _cbJK::P64;
           call (P64[(old + 24)])(R1) args: 24, res: 0, upd: 24;
     }
 },
 SkipList.$wa4_entry() //  [R6, R5, R4, R3, R2]
         { info_tbl: [(cbJO,
                       label: SkipList.$wa4_info
                       rep:HeapRep static { Fun {arity: 7 fun_type: ArgSpec 26} })]
           stack_info: arg_space: 16 updfr_space: Just 8
         }
     {offset
       cbJO:
           _saFF::P64 = R6;
           _saFE::P64 = R5;
           _saFD::P64 = R4;
           _saFC::P64 = R3;
           _saFB::P64 = R2;
           _saFG::P64 = P64[(old + 16)];
           goto cbCY;
       cbCY:
           if ((old + 0) - <highSp> < SpLim) goto cbJX; else goto cbJY;
       cbJY:
           goto cbCX;
       cbCX:
           if (HpLim == 0) goto cbJX; else goto cbJZ;
       cbJX:
           R6 = _saFF::P64;
           R5 = _saFE::P64;
           R4 = _saFD::P64;
           R3 = _saFC::P64;
           R2 = _saFB::P64;
           R1 = SkipList.$wa4_closure;
           P64[(old + 16)] = _saFG::P64;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cbJZ:
           I64[(young<cbD0> + 8)] = cbD0;
           R1 = _saFD::P64;
           call stg_norec_readTVar#(R1) returns to cbD0, args: 8, res: 8, upd: 8;
       cbD0:
           _saFK::P64 = R1;
           I64[(young<cbD2> + 8)] = cbD2;
           R1 = _saFK::P64;
           if (R1 & 7 != 0) goto cbD2; else goto cbD3;
       cbD3:
           call (I64[R1])(R1) returns to cbD2, args: 8, res: 8, upd: 8;
       cbD2:
           _saFL::P64 = R1;
           Hp = Hp + 64;
           if (Hp > HpLim) goto cbK3; else goto cbK2;
       cbK3:
           HpAlloc = 64;
           goto cbK1;
       cbK1:
           R1 = _saFL::P64;
           call stg_gc_unpt_r1(R1) returns to cbD2, args: 8, res: 8, upd: 8;
       cbK2:
           _saFM::I64 = I64[_saFL::P64 + 7];
           _cbD7::P64 = Hp - 52;
           _cbD8::P64 = Hp - 24;
           I64[Hp - 56] = $wa8_saFO_info;
           P64[Hp - 48] = _saFB::P64;
           P64[Hp - 40] = _saFF::P64;
           P64[Hp - 32] = _cbD8::P64;
           I64[Hp - 24] = $s$wa_saFN_info;
           P64[Hp - 16] = _saFB::P64;
           P64[Hp - 8] = _saFF::P64;
           P64[Hp] = _cbD7::P64;
           I64[(young<cbHA> + 8)] = cbHA;
           R4 = GHC.Types.[]_closure+1;
           R3 = _saFM::I64;
           R2 = _saFC::P64;
           R1 = _cbD7::P64;
           call $wa8_saFO_info(R4,
                               R3,
                               R2,
                               R1) returns to cbHA, args: 8, res: 8, upd: 8;
       cbHA:
           _saHj::P64 = R1;
           I64[(young<cbHC> + 8)] = cbHC;
           call stg_myThreadId#() returns to cbHC, args: 8, res: 8, upd: 8;
       cbHC:
           _saHm::P64 = R1;
           I64[(young<cbHE> + 8)] = cbHE;
           R1 = _saHm::P64;
           call stg_threadStatus#(R1) returns to cbHE, args: 8, res: 8, upd: 8;
       cbHE:
           _saHr::I64 = R3;
           _saHq::I64 = R2;
           _saHp::I64 = R1;
           goto cbHF;
       cbHF:
           Hp = Hp + 72;
           if (Hp > HpLim) goto cbK8; else goto cbK7;
       cbK8:
           HpAlloc = 72;
           goto cbK6;
       cbK6:
           I64[(young<cbHG> + 8)] = cbHG;
           call stg_gc_noregs() returns to cbHG, args: 8, res: 8, upd: 8;
       cbHG:
           goto cbHF;
       cbK7:
           I64[Hp - 64] = nodesHeight_saHs_info;
           P64[Hp - 48] = _saFE::P64;
           P64[Hp - 40] = _saFL::P64;
           I64[Hp - 32] = _saFM::I64;
           I64[Hp - 24] = _saHq::I64;
           _cbHI::P64 = Hp - 64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = SkipList.newSL10_closure+1;
           P64[Hp] = _cbHI::P64;
           _cbJP::P64 = Hp - 15;
           I64[(young<cbJQ> + 8)] = cbJQ;
           R3 = _cbJP::P64;
           R2 = GHC.Arr.$fIxInt_closure;
           call SkipList.$fMArrayTArrayeSTM8_info(R3,
                                                  R2) returns to cbJQ, args: 8, res: 8, upd: 8;
       cbJQ:
           _saIf::P64 = R1;
           I64[(young<cbJS> + 8)] = cbJS;
           R1 = _saFG::P64;
           call stg_newNOrecTVar#(R1) returns to cbJS, args: 8, res: 8, upd: 8;
       cbJS:
           _saIi::P64 = R1;
           Hp = Hp + 48;
           if (Hp > HpLim) goto cbKc; else goto cbKb;
       cbKc:
           HpAlloc = 48;
           goto cbKa;
       cbKa:
           R1 = _saIi::P64;
           call stg_gc_unpt_r1(R1) returns to cbJS, args: 8, res: 8, upd: 8;
       cbKb:
           I64[Hp - 40] = GHC.Conc.Sync.TVar_con_info;
           P64[Hp - 32] = _saIi::P64;
           _cbJU::P64 = Hp - 39;
           I64[Hp - 24] = SkipList.Node_con_info;
           P64[Hp - 16] = _saFF::P64;
           P64[Hp - 8] = _cbJU::P64;
           P64[Hp] = _saIf::P64;
           _cbJV::P64 = Hp - 22;
           I64[(young<cbJW> + 8)] = cbJW;
           R1 = _cbHI::P64;
           if (R1 & 7 != 0) goto cbJW; else goto cbKd;
       cbKd:
           call (I64[R1])(R1) returns to cbJW, args: 8, res: 8, upd: 8;
       cbJW:
           _saIl::P64 = R1;
           _saIm::I64 = I64[_saIl::P64 + 7];
           _cbKi::I64 = %MO_S_Gt_W64(1, _saIm::I64);
           _saIn::I64 = _cbKi::I64;
           switch [0 .. 1] _saIn::I64 {
               case 0 : goto cbKp;
               case 1 : goto cbPm;
           }
       cbPm:
           R1 = GHC.Tuple.()_closure+1;
           call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
       cbKp:
           I64[(young<cbKn> + 8)] = cbKn;
           R1 = _saHj::P64;
           if (R1 & 7 != 0) goto cbKn; else goto cbKq;
       cbKq:
           call (I64[R1])(R1) returns to cbKn, args: 8, res: 8, upd: 8;
       cbKn:
           _saIp::P64 = R1;
           _cbPn::P64 = _saIp::P64 & 7;
           switch [1 .. 2] _cbPn::P64 {
               case 1 : goto cbKw;
               case 2 : goto cbKL;
           }
       cbKL:
           _saIr::P64 = P64[_saIp::P64 + 6];
           _saIs::P64 = P64[_saIp::P64 + 14];
           I64[(young<cbKz> + 8)] = cbKz;
           R1 = _saIr::P64;
           if (R1 & 7 != 0) goto cbKz; else goto cbKA;
       cbKA:
           call (I64[R1])(R1) returns to cbKz, args: 8, res: 8, upd: 8;
       cbKz:
           _saIt::P64 = R1;
           _saIu::P64 = P64[_saIt::P64 + 7];
           _saIv::P64 = P64[_saIt::P64 + 15];
           _saIx::P64 = P64[_saIt::P64 + 23];
           _saIw::I64 = I64[_saIt::P64 + 31];
           I64[(young<cbKE> + 8)] = cbKE;
           R1 = _saIu::P64;
           if (R1 & 7 != 0) goto cbKE; else goto cbKF;
       cbKF:
           call (I64[R1])(R1) returns to cbKE, args: 8, res: 8, upd: 8;
       cbKE:
           _saIy::P64 = R1;
           _saIz::I64 = I64[_saIy::P64 + 7];
           I64[(young<cbKJ> + 8)] = cbKJ;
           R1 = _saIv::P64;
           if (R1 & 7 != 0) goto cbKJ; else goto cbKO;
       cbKO:
           call (I64[R1])(R1) returns to cbKJ, args: 8, res: 8, upd: 8;
       cbKJ:
           _saIA::P64 = R1;
           _saIB::I64 = I64[_saIA::P64 + 7];
           _cbKT::I64 = %MO_S_Le_W64(_saIz::I64, 1);
           _saIC::I64 = _cbKT::I64;
           switch [0 .. 1] _saIC::I64 {
               case 0 : goto cbKY;
               case 1 : goto cbPl;
           }
       cbPl:
           _cbL1::I64 = %MO_S_Le_W64(1, _saIB::I64);
           _saIG::I64 = _cbL1::I64;
           switch [0 .. 1] _saIG::I64 {
               case 0 : goto cbL6;
               case 1 : goto cbPk;
           }
       cbPk:
           _cbL9::I64 = 1 - _saIz::I64;
           _saIK::I64 = _cbL9::I64;
           _cbLc::I64 = %MO_S_Le_W64(0, _saIK::I64);
           _saIL::I64 = _cbLc::I64;
           switch [0 .. 1] _saIL::I64 {
               case 0 : goto cbLh;
               case 1 : goto cbPj;
           }
       cbPj:
           _cbLk::I64 = %MO_S_Lt_W64(_saIK::I64, _saIw::I64);
           _saIO::I64 = _cbLk::I64;
           switch [0 .. 1] _saIO::I64 {
               case 0 : goto cbLp;
               case 1 : goto cbLO;
           }
       cbLO:
           _saIS::P64 = P64[(_saIx::P64 + 24) + (_saIK::I64 << 3)];
           _saIS::P64 = _saIS::P64;
           I64[(young<cbLs> + 8)] = cbLs;
           R1 = _saIS::P64;
           if (R1 & 7 != 0) goto cbLs; else goto cbLt;
       cbLt:
           call (I64[R1])(R1) returns to cbLs, args: 8, res: 8, upd: 8;
       cbLs:
           _saIT::P64 = R1;
           _saIU::P64 = P64[_saIT::P64 + 7];
           I64[(young<cbLx> + 8)] = cbLx;
           R1 = _saIU::P64;
           call stg_norec_readTVar#(R1) returns to cbLx, args: 8, res: 8, upd: 8;
       cbLx:
           _saIX::P64 = R1;
           I64[(young<cbLz> + 8)] = cbLz;
           R2 = _cbJV::P64;
           R1 = _saIU::P64;
           call stg_norec_writeTVar#(R2,
                                     R1) returns to cbLz, args: 8, res: 8, upd: 8;
       cbLz:
           I64[(young<cbLD> + 8)] = cbLD;
           R1 = _saIf::P64;
           if (R1 & 7 != 0) goto cbLD; else goto cbLE;
       cbLE:
           call (I64[R1])(R1) returns to cbLD, args: 8, res: 8, upd: 8;
       cbLD:
           _saIZ::P64 = R1;
           _saJ0::P64 = P64[_saIZ::P64 + 7];
           _saJ1::P64 = P64[_saIZ::P64 + 15];
           _saJ3::P64 = P64[_saIZ::P64 + 23];
           _saJ2::I64 = I64[_saIZ::P64 + 31];
           I64[(young<cbLI> + 8)] = cbLI;
           R1 = _saJ0::P64;
           if (R1 & 7 != 0) goto cbLI; else goto cbLJ;
       cbLJ:
           call (I64[R1])(R1) returns to cbLI, args: 8, res: 8, upd: 8;
       cbLI:
           _saJ4::P64 = R1;
           _saJ5::I64 = I64[_saJ4::P64 + 7];
           I64[(young<cbLN> + 8)] = cbLN;
           R1 = _saJ1::P64;
           if (R1 & 7 != 0) goto cbLN; else goto cbLU;
       cbLU:
           call (I64[R1])(R1) returns to cbLN, args: 8, res: 8, upd: 8;
       cbLN:
           _saJ6::P64 = R1;
           _saJ7::I64 = I64[_saJ6::P64 + 7];
           _cbLZ::I64 = %MO_S_Le_W64(_saJ5::I64, 1);
           _saJ8::I64 = _cbLZ::I64;
           switch [0 .. 1] _saJ8::I64 {
               case 0 : goto cbM4;
               case 1 : goto cbPi;
           }
       cbPi:
           _cbM7::I64 = %MO_S_Le_W64(1, _saJ7::I64);
           _saJc::I64 = _cbM7::I64;
           switch [0 .. 1] _saJc::I64 {
               case 0 : goto cbMc;
               case 1 : goto cbPh;
           }
       cbPh:
           _cbMf::I64 = 1 - _saJ5::I64;
           _saJg::I64 = _cbMf::I64;
           _cbMi::I64 = %MO_S_Le_W64(0, _saJg::I64);
           _saJh::I64 = _cbMi::I64;
           switch [0 .. 1] _saJh::I64 {
               case 0 : goto cbMn;
               case 1 : goto cbPg;
           }
       cbPg:
           _cbMq::I64 = %MO_S_Lt_W64(_saJg::I64, _saJ2::I64);
           _saJk::I64 = _cbMq::I64;
           switch [0 .. 1] _saJk::I64 {
               case 0 : goto cbMv;
               case 1 : goto cbME;
           }
       cbME:
           _saJo::P64 = P64[(_saJ3::P64 + 24) + (_saJg::I64 << 3)];
           _saJo::P64 = _saJo::P64;
           I64[(young<cbMy> + 8)] = cbMy;
           R1 = _saJo::P64;
           if (R1 & 7 != 0) goto cbMy; else goto cbMz;
       cbMz:
           call (I64[R1])(R1) returns to cbMy, args: 8, res: 8, upd: 8;
       cbMy:
           _saJp::P64 = R1;
           _saJq::P64 = P64[_saJp::P64 + 7];
           I64[(young<cbMD> + 8)] = cbMD;
           R2 = _saIX::P64;
           R1 = _saJq::P64;
           call stg_norec_writeTVar#(R2,
                                     R1) returns to cbMD, args: 8, res: 8, upd: 8;
       cbMD:
           _saJu::P64 = _saIs::P64;
           _saJt::I64 = 2;
           goto saJs;
       saJs:
           goto cbMM;
       cbMM:
           if (HpLim == 0) goto cbMP; else goto cbPf;
       cbMP:
           I64[(young<cbMN> + 8)] = cbMN;
           call stg_gc_noregs() returns to cbMN, args: 8, res: 8, upd: 8;
       cbMN:
           goto cbMM;
       cbPf:
           _cbMQ::I64 = %MO_S_Gt_W64(_saJt::I64, _saIm::I64);
           _saJw::I64 = _cbMQ::I64;
           switch [0 .. 1] _saJw::I64 {
               case 0 : goto cbMX;
               case 1 : goto cbPe;
           }
       cbPe:
           R1 = GHC.Tuple.()_closure+1;
           call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
       cbMX:
           I64[(young<cbMV> + 8)] = cbMV;
           R1 = _saJu::P64;
           if (R1 & 7 != 0) goto cbMV; else goto cbMY;
       cbMY:
           call (I64[R1])(R1) returns to cbMV, args: 8, res: 8, upd: 8;
       cbMV:
           _saJy::P64 = R1;
           _cbPo::P64 = _saJy::P64 & 7;
           switch [1 .. 2] _cbPo::P64 {
               case 1 : goto cbN4;
               case 2 : goto cbNj;
           }
       cbNj:
           _saJA::P64 = P64[_saJy::P64 + 6];
           _saJB::P64 = P64[_saJy::P64 + 14];
           I64[(young<cbN7> + 8)] = cbN7;
           R1 = _saJA::P64;
           if (R1 & 7 != 0) goto cbN7; else goto cbN8;
       cbN8:
           call (I64[R1])(R1) returns to cbN7, args: 8, res: 8, upd: 8;
       cbN7:
           _saJC::P64 = R1;
           _saJD::P64 = P64[_saJC::P64 + 7];
           _saJE::P64 = P64[_saJC::P64 + 15];
           _saJG::P64 = P64[_saJC::P64 + 23];
           _saJF::I64 = I64[_saJC::P64 + 31];
           I64[(young<cbNc> + 8)] = cbNc;
           R1 = _saJD::P64;
           if (R1 & 7 != 0) goto cbNc; else goto cbNd;
       cbNd:
           call (I64[R1])(R1) returns to cbNc, args: 8, res: 8, upd: 8;
       cbNc:
           _saJH::P64 = R1;
           _saJI::I64 = I64[_saJH::P64 + 7];
           I64[(young<cbNh> + 8)] = cbNh;
           R1 = _saJE::P64;
           if (R1 & 7 != 0) goto cbNh; else goto cbNm;
       cbNm:
           call (I64[R1])(R1) returns to cbNh, args: 8, res: 8, upd: 8;
       cbNh:
           _saJJ::P64 = R1;
           Hp = Hp + 16;
           if (Hp > HpLim) goto cbNs; else goto cbNr;
       cbNs:
           HpAlloc = 16;
           goto cbNq;
       cbNq:
           R1 = _saJJ::P64;
           call stg_gc_unpt_r1(R1) returns to cbNh, args: 8, res: 8, upd: 8;
       cbNr:
           _saJK::I64 = I64[_saJJ::P64 + 7];
           _cbNt::I64 = %MO_S_Le_W64(_saJI::I64, _saJt::I64);
           _saJL::I64 = _cbNt::I64;
           switch [0 .. 1] _saJL::I64 {
               case 0 : goto cbNA;
               case 1 : goto cbPd;
           }
       cbPd:
           _cbNC::I64 = %MO_S_Le_W64(_saJt::I64, _saJK::I64);
           _saJP::I64 = _cbNC::I64;
           switch [0 .. 1] _saJP::I64 {
               case 0 : goto cbNJ;
               case 1 : goto cbPc;
           }
       cbPc:
           _cbNL::I64 = _saJt::I64 - _saJI::I64;
           _saJT::I64 = _cbNL::I64;
           _cbNO::I64 = %MO_S_Le_W64(0, _saJT::I64);
           _saJU::I64 = _cbNO::I64;
           switch [0 .. 1] _saJU::I64 {
               case 0 : goto cbNT;
               case 1 : goto cbPb;
           }
       cbPb:
           _cbNW::I64 = %MO_S_Lt_W64(_saJT::I64, _saJF::I64);
           _saJX::I64 = _cbNW::I64;
           switch [0 .. 1] _saJX::I64 {
               case 0 : goto cbO1;
               case 1 : goto cbOc;
           }
       cbOc:
           _saK1::P64 = P64[(_saJG::P64 + 24) + (_saJT::I64 << 3)];
           _saK1::P64 = _saK1::P64;
           Hp = Hp - 16;
           I64[(young<cbO4> + 8)] = cbO4;
           R1 = _saK1::P64;
           if (R1 & 7 != 0) goto cbO4; else goto cbO5;
       cbO5:
           call (I64[R1])(R1) returns to cbO4, args: 8, res: 8, upd: 8;
       cbO4:
           _saK2::P64 = R1;
           _saK3::P64 = P64[_saK2::P64 + 7];
           I64[(young<cbO9> + 8)] = cbO9;
           R1 = _saK3::P64;
           call stg_norec_readTVar#(R1) returns to cbO9, args: 8, res: 8, upd: 8;
       cbO9:
           _saK6::P64 = R1;
           I64[(young<cbOb> + 8)] = cbOb;
           R2 = _cbJV::P64;
           R1 = _saK3::P64;
           call stg_norec_writeTVar#(R2,
                                     R1) returns to cbOb, args: 8, res: 8, upd: 8;
       cbOb:
           Hp = Hp + 16;
           if (Hp > HpLim) goto cbOk; else goto cbOj;
       cbOk:
           HpAlloc = 16;
           goto cbOi;
       cbOi:
           call stg_gc_noregs() returns to cbOb, args: 8, res: 8, upd: 8;
       cbOj:
           _cbOl::I64 = %MO_S_Le_W64(_saJ5::I64, _saJt::I64);
           _saK8::I64 = _cbOl::I64;
           switch [0 .. 1] _saK8::I64 {
               case 0 : goto cbOs;
               case 1 : goto cbPa;
           }
       cbPa:
           _cbOu::I64 = %MO_S_Le_W64(_saJt::I64, _saJ7::I64);
           _saKc::I64 = _cbOu::I64;
           switch [0 .. 1] _saKc::I64 {
               case 0 : goto cbOB;
               case 1 : goto cbP9;
           }
       cbP9:
           _cbOD::I64 = _saJt::I64 - _saJ5::I64;
           _saKg::I64 = _cbOD::I64;
           _cbOG::I64 = %MO_S_Le_W64(0, _saKg::I64);
           _saKh::I64 = _cbOG::I64;
           switch [0 .. 1] _saKh::I64 {
               case 0 : goto cbOL;
               case 1 : goto cbP8;
           }
       cbP8:
           _cbOO::I64 = %MO_S_Lt_W64(_saKg::I64, _saJ2::I64);
           _saKk::I64 = _cbOO::I64;
           switch [0 .. 1] _saKk::I64 {
               case 0 : goto cbOT;
               case 1 : goto cbP2;
           }
       cbP2:
           _saKo::P64 = P64[(_saJ3::P64 + 24) + (_saKg::I64 << 3)];
           _saKo::P64 = _saKo::P64;
           Hp = Hp - 16;
           I64[(young<cbOW> + 8)] = cbOW;
           R1 = _saKo::P64;
           if (R1 & 7 != 0) goto cbOW; else goto cbOX;
       cbOX:
           call (I64[R1])(R1) returns to cbOW, args: 8, res: 8, upd: 8;
       cbOW:
           _saKp::P64 = R1;
           _saKq::P64 = P64[_saKp::P64 + 7];
           I64[(young<cbP1> + 8)] = cbP1;
           R2 = _saK6::P64;
           R1 = _saKq::P64;
           call stg_norec_writeTVar#(R2,
                                     R1) returns to cbP1, args: 8, res: 8, upd: 8;
       cbP1:
           _cbPp::I64 = _saJt::I64 + 1;
           _saKs::I64 = _cbPp::I64;
           _saJu::P64 = _saJB::P64;
           _saJt::I64 = _saKs::I64;
           goto saJs;
       cbOT:
           Hp = Hp - 16;
           R3 = _saKg::I64;
           R2 = _saJ2::I64;
           call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
       cbOL:
           Hp = Hp - 16;
           R3 = _saKg::I64;
           R2 = _saJ2::I64;
           call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
       cbOB:
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saJt::I64;
           _cbOz::P64 = Hp - 7;
           R4 = _saJ6::P64;
           R3 = _saJ4::P64;
           R2 = _cbOz::P64;
           call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
       cbOs:
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saJt::I64;
           _cbOq::P64 = Hp - 7;
           R4 = _saJ6::P64;
           R3 = _saJ4::P64;
           R2 = _cbOq::P64;
           call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
       cbO1:
           Hp = Hp - 16;
           R3 = _saJT::I64;
           R2 = _saJF::I64;
           call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
       cbNT:
           Hp = Hp - 16;
           R3 = _saJT::I64;
           R2 = _saJF::I64;
           call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
       cbNJ:
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saJt::I64;
           _cbNH::P64 = Hp - 7;
           R4 = _saJJ::P64;
           R3 = _saJH::P64;
           R2 = _cbNH::P64;
           call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
       cbNA:
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saJt::I64;
           _cbNy::P64 = Hp - 7;
           R4 = _saJJ::P64;
           R3 = _saJH::P64;
           R2 = _cbNy::P64;
           call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
       cbN4:
           R1 = lvl40_rawz_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
       cbMv:
           R3 = _saJg::I64;
           R2 = _saJ2::I64;
           call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
       cbMn:
           R3 = _saJg::I64;
           R2 = _saJ2::I64;
           call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
       cbMc:
           R4 = _saJ6::P64;
           R3 = _saJ4::P64;
           R2 = stg_INTLIKE_closure+273;
           call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
       cbM4:
           R4 = _saJ6::P64;
           R3 = _saJ4::P64;
           R2 = stg_INTLIKE_closure+273;
           call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
       cbLp:
           R3 = _saIK::I64;
           R2 = _saIw::I64;
           call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
       cbLh:
           R3 = _saIK::I64;
           R2 = _saIw::I64;
           call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
       cbL6:
           R4 = _saIA::P64;
           R3 = _saIy::P64;
           R2 = stg_INTLIKE_closure+273;
           call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
       cbKY:
           R4 = _saIA::P64;
           R3 = _saIy::P64;
           R2 = stg_INTLIKE_closure+273;
           call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
       cbKw:
           R1 = lvl40_rawz_closure;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:46.935184 UTC

{offset
  cbDh:
      _saGC::P64 = R4;
      _saGB::I64 = R3;
      _saGA::P64 = R2;
      _saFO::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cbDi; else goto cbDj;
  cbDj:
      if (HpLim == 0) goto cbDi; else goto cbES;
  cbDi:
      R4 = _saGC::P64;
      R3 = _saGB::I64;
      R2 = _saGA::P64;
      R1 = _saFO::P64;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  cbES:
      _saFB::P64 = P64[_saFO::P64 + 4];
      _saFF::P64 = P64[_saFO::P64 + 12];
      _saFN::P64 = P64[_saFO::P64 + 20];
      _saGE::I64 = _saGB::I64;
      switch [-9223372036854775808 .. 9223372036854775807] _saGE::I64 {
          case 0 : goto cbDg;
          default: goto cbDf;
      }
  cbDg:
      R1 = _saGC::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
  cbDf:
      I64[(young<cbDl> + 8)] = cbDl;
      R1 = _saGA::P64;
      if (R1 & 7 != 0) goto cbDl; else goto cbDm;
  cbDm:
      call (I64[R1])(R1) returns to cbDl, args: 8, res: 8, upd: 8;
  cbDl:
      _saGF::P64 = R1;
      _saGG::P64 = P64[_saGF::P64 + 7];
      _saGH::P64 = P64[_saGF::P64 + 15];
      _saGJ::P64 = P64[_saGF::P64 + 23];
      _saGI::I64 = I64[_saGF::P64 + 31];
      I64[(young<cbDq> + 8)] = cbDq;
      R1 = _saGG::P64;
      if (R1 & 7 != 0) goto cbDq; else goto cbDr;
  cbDr:
      call (I64[R1])(R1) returns to cbDq, args: 8, res: 8, upd: 8;
  cbDq:
      _saGK::P64 = R1;
      _saGL::I64 = I64[_saGK::P64 + 7];
      I64[(young<cbDv> + 8)] = cbDv;
      R1 = _saGH::P64;
      if (R1 & 7 != 0) goto cbDv; else goto cbDy;
  cbDy:
      call (I64[R1])(R1) returns to cbDv, args: 8, res: 8, upd: 8;
  cbDv:
      _saGM::P64 = R1;
      _saGN::I64 = I64[_saGM::P64 + 7];
      _cbDD::I64 = %MO_S_Le_W64(_saGL::I64, _saGE::I64);
      _saGO::I64 = _cbDD::I64;
      switch [0 .. 1] _saGO::I64 {
          case 0 : goto cbDI;
          case 1 : goto cbER;
      }
  cbER:
      _cbDL::I64 = %MO_S_Le_W64(_saGE::I64, _saGN::I64);
      _saGR::I64 = _cbDL::I64;
      switch [0 .. 1] _saGR::I64 {
          case 0 : goto cbDQ;
          case 1 : goto cbEQ;
      }
  cbEQ:
      _cbDT::I64 = _saGE::I64 - _saGL::I64;
      _saGU::I64 = _cbDT::I64;
      _cbDW::I64 = %MO_S_Le_W64(0, _saGU::I64);
      _saGV::I64 = _cbDW::I64;
      switch [0 .. 1] _saGV::I64 {
          case 0 : goto cbE1;
          case 1 : goto cbEP;
      }
  cbEP:
      _cbE4::I64 = %MO_S_Lt_W64(_saGU::I64, _saGI::I64);
      _saGY::I64 = _cbE4::I64;
      switch [0 .. 1] _saGY::I64 {
          case 0 : goto cbE9;
          case 1 : goto cbEd;
      }
  cbEd:
      _saH2::P64 = P64[(_saGJ::P64 + 24) + (_saGU::I64 << 3)];
      _saH2::P64 = _saH2::P64;
      I64[(young<cbEc> + 8)] = cbEc;
      R1 = _saH2::P64;
      if (R1 & 7 != 0) goto cbEc; else goto cbEe;
  cbEe:
      call (I64[R1])(R1) returns to cbEc, args: 8, res: 8, upd: 8;
  cbEc:
      _saH3::P64 = R1;
      _saH4::P64 = P64[_saH3::P64 + 7];
      I64[(young<cbEi> + 8)] = cbEi;
      R1 = _saH4::P64;
      call stg_norec_readTVar#(R1) returns to cbEi, args: 8, res: 8, upd: 8;
  cbEi:
      _saH7::P64 = R1;
      I64[(young<cbEk> + 8)] = cbEk;
      R1 = _saH7::P64;
      if (R1 & 7 != 0) goto cbEk; else goto cbEn;
  cbEn:
      call (I64[R1])(R1) returns to cbEk, args: 8, res: 8, upd: 8;
  cbEk:
      _saH8::P64 = R1;
      _cbET::P64 = _saH8::P64 & 7;
      switch [1 .. 2] _cbET::P64 {
          case 1 : goto cbEt;
          case 2 : goto cbEB;
      }
  cbEB:
      _saHb::P64 = P64[_saH8::P64 + 6];
      _saHc::P64 = P64[_saH8::P64 + 14];
      _saHd::P64 = P64[_saH8::P64 + 22];
      I64[(young<cbEz> + 8)] = cbEz;
      R2 = _saFB::P64;
      I64[(young<cbEz> + 32)] = stg_ap_pp_info;
      P64[(young<cbEz> + 24)] = _saHb::P64;
      P64[(young<cbEz> + 16)] = _saFF::P64;
      call GHC.Classes.>_info(R2) returns to cbEz, args: 32, res: 8, upd: 8;
  cbEz:
      _saHe::P64 = R1;
      _cbEU::P64 = _saHe::P64 & 7;
      switch [1 .. 2] _cbEU::P64 {
          case 1 : goto cbEH;
          case 2 : goto cbEL;
      }
  cbEL:
      Hp = Hp + 24;
      if (Hp > HpLim) goto cbEO; else goto cbEN;
  cbEO:
      HpAlloc = 24;
      R1 = _saHe::P64;
      call stg_gc_unpt_r1(R1) returns to cbEz, args: 8, res: 8, upd: 8;
  cbEN:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _saGF::P64;
      P64[Hp] = _saGC::P64;
      _cbEK::P64 = Hp - 14;
      _cbEV::I64 = _saGE::I64 - 1;
      _saHf::I64 = _cbEV::I64;
      R6 = _saHf::I64;
      R5 = _saGJ::P64;
      R4 = _saGI::I64;
      R3 = _saGN::I64;
      R2 = _saGL::I64;
      R1 = _saFN::P64;
      P64[(old + 16)] = _cbEK::P64;
      call $s$wa_saFN_info(R6,
                           R5,
                           R4,
                           R3,
                           R2,
                           R1) args: 16, res: 0, upd: 8;
  cbEH:
      R4 = _saGC::P64;
      R3 = _saGE::I64;
      R2 = _saHd::P64;
      R1 = _saFO::P64;
      call $wa8_saFO_info(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  cbEt:
      Hp = Hp + 24;
      if (Hp > HpLim) goto cbEw; else goto cbEv;
  cbEw:
      HpAlloc = 24;
      R1 = _saH8::P64;
      call stg_gc_unpt_r1(R1) returns to cbEk, args: 8, res: 8, upd: 8;
  cbEv:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _saGF::P64;
      P64[Hp] = _saGC::P64;
      _cbEr::P64 = Hp - 14;
      _cbEW::I64 = _saGE::I64 - 1;
      _saH9::I64 = _cbEW::I64;
      R6 = _saH9::I64;
      R5 = _saGJ::P64;
      R4 = _saGI::I64;
      R3 = _saGN::I64;
      R2 = _saGL::I64;
      R1 = _saFN::P64;
      P64[(old + 16)] = _cbEr::P64;
      call $s$wa_saFN_info(R6,
                           R5,
                           R4,
                           R3,
                           R2,
                           R1) args: 16, res: 0, upd: 8;
  cbE9:
      R3 = _saGU::I64;
      R2 = _saGI::I64;
      call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
  cbE1:
      R3 = _saGU::I64;
      R2 = _saGI::I64;
      call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
  cbDQ:
      R4 = _saGM::P64;
      R3 = _saGK::P64;
      R2 = _saGE::I64;
      call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbDI:
      R4 = _saGM::P64;
      R3 = _saGK::P64;
      R2 = _saGE::I64;
      call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:46.944092 UTC

{offset
  cbDh:
      _saGC::P64 = R4;
      _saGB::I64 = R3;
      _saGA::P64 = R2;
      _saFO::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cbDi; else goto cbDj;
  cbDj:
      if (HpLim == 0) goto cbDi; else goto cbES;
  cbDi:
      R4 = _saGC::P64;
      R3 = _saGB::I64;
      R2 = _saGA::P64;
      R1 = _saFO::P64;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  cbES:
      _saFB::P64 = P64[_saFO::P64 + 4];
      _saFF::P64 = P64[_saFO::P64 + 12];
      _saFN::P64 = P64[_saFO::P64 + 20];
      _saGE::I64 = _saGB::I64;
      switch [-9223372036854775808 .. 9223372036854775807] _saGE::I64 {
          case 0 : goto cbDg;
          default: goto cbDf;
      }
  cbDg:
      R1 = _saGC::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
  cbDf:
      I64[(young<cbDl> + 8)] = cbDl;
      R1 = _saGA::P64;
      if (R1 & 7 != 0) goto cbDl; else goto cbDm;
  cbDm:
      call (I64[R1])(R1) returns to cbDl, args: 8, res: 8, upd: 8;
  cbDl:
      _saGF::P64 = R1;
      _saGG::P64 = P64[_saGF::P64 + 7];
      _saGH::P64 = P64[_saGF::P64 + 15];
      _saGJ::P64 = P64[_saGF::P64 + 23];
      _saGI::I64 = I64[_saGF::P64 + 31];
      I64[(young<cbDq> + 8)] = cbDq;
      R1 = _saGG::P64;
      if (R1 & 7 != 0) goto cbDq; else goto cbDr;
  cbDr:
      call (I64[R1])(R1) returns to cbDq, args: 8, res: 8, upd: 8;
  cbDq:
      _saGK::P64 = R1;
      _saGL::I64 = I64[_saGK::P64 + 7];
      I64[(young<cbDv> + 8)] = cbDv;
      R1 = _saGH::P64;
      if (R1 & 7 != 0) goto cbDv; else goto cbDy;
  cbDy:
      call (I64[R1])(R1) returns to cbDv, args: 8, res: 8, upd: 8;
  cbDv:
      _saGM::P64 = R1;
      _saGN::I64 = I64[_saGM::P64 + 7];
      _cbDD::I64 = %MO_S_Le_W64(_saGL::I64, _saGE::I64);
      _saGO::I64 = _cbDD::I64;
      switch [0 .. 1] _saGO::I64 {
          case 0 : goto cbDQ;
          case 1 : goto cbER;
      }
  cbER:
      _cbDL::I64 = %MO_S_Le_W64(_saGE::I64, _saGN::I64);
      _saGR::I64 = _cbDL::I64;
      switch [0 .. 1] _saGR::I64 {
          case 0 : goto cbDQ;
          case 1 : goto cbEQ;
      }
  cbEQ:
      _cbDT::I64 = _saGE::I64 - _saGL::I64;
      _saGU::I64 = _cbDT::I64;
      _cbDW::I64 = %MO_S_Le_W64(0, _saGU::I64);
      _saGV::I64 = _cbDW::I64;
      switch [0 .. 1] _saGV::I64 {
          case 0 : goto cbE9;
          case 1 : goto cbEP;
      }
  cbEP:
      _cbE4::I64 = %MO_S_Lt_W64(_saGU::I64, _saGI::I64);
      _saGY::I64 = _cbE4::I64;
      switch [0 .. 1] _saGY::I64 {
          case 0 : goto cbE9;
          case 1 : goto cbEd;
      }
  cbEd:
      _saH2::P64 = P64[(_saGJ::P64 + 24) + (_saGU::I64 << 3)];
      _saH2::P64 = _saH2::P64;
      I64[(young<cbEc> + 8)] = cbEc;
      R1 = _saH2::P64;
      if (R1 & 7 != 0) goto cbEc; else goto cbEe;
  cbEe:
      call (I64[R1])(R1) returns to cbEc, args: 8, res: 8, upd: 8;
  cbEc:
      _saH3::P64 = R1;
      _saH4::P64 = P64[_saH3::P64 + 7];
      I64[(young<cbEi> + 8)] = cbEi;
      R1 = _saH4::P64;
      call stg_norec_readTVar#(R1) returns to cbEi, args: 8, res: 8, upd: 8;
  cbEi:
      _saH7::P64 = R1;
      I64[(young<cbEk> + 8)] = cbEk;
      R1 = _saH7::P64;
      if (R1 & 7 != 0) goto cbEk; else goto cbEn;
  cbEn:
      call (I64[R1])(R1) returns to cbEk, args: 8, res: 8, upd: 8;
  cbEk:
      _saH8::P64 = R1;
      _cbET::P64 = _saH8::P64 & 7;
      switch [1 .. 2] _cbET::P64 {
          case 1 : goto cbEt;
          case 2 : goto cbEB;
      }
  cbEB:
      _saHb::P64 = P64[_saH8::P64 + 6];
      _saHc::P64 = P64[_saH8::P64 + 14];
      _saHd::P64 = P64[_saH8::P64 + 22];
      I64[(young<cbEz> + 8)] = cbEz;
      R2 = _saFB::P64;
      I64[(young<cbEz> + 32)] = stg_ap_pp_info;
      P64[(young<cbEz> + 24)] = _saHb::P64;
      P64[(young<cbEz> + 16)] = _saFF::P64;
      call GHC.Classes.>_info(R2) returns to cbEz, args: 32, res: 8, upd: 8;
  cbEz:
      _saHe::P64 = R1;
      _cbEU::P64 = _saHe::P64 & 7;
      switch [1 .. 2] _cbEU::P64 {
          case 1 : goto cbEH;
          case 2 : goto cbEL;
      }
  cbEL:
      Hp = Hp + 24;
      if (Hp > HpLim) goto cbEO; else goto cbEN;
  cbEO:
      HpAlloc = 24;
      R1 = _saHe::P64;
      call stg_gc_unpt_r1(R1) returns to cbEz, args: 8, res: 8, upd: 8;
  cbEN:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _saGF::P64;
      P64[Hp] = _saGC::P64;
      _cbEK::P64 = Hp - 14;
      _cbEV::I64 = _saGE::I64 - 1;
      _saHf::I64 = _cbEV::I64;
      R6 = _saHf::I64;
      R5 = _saGJ::P64;
      R4 = _saGI::I64;
      R3 = _saGN::I64;
      R2 = _saGL::I64;
      R1 = _saFN::P64;
      P64[(old + 16)] = _cbEK::P64;
      call $s$wa_saFN_info(R6,
                           R5,
                           R4,
                           R3,
                           R2,
                           R1) args: 16, res: 0, upd: 8;
  cbEH:
      R4 = _saGC::P64;
      R3 = _saGE::I64;
      R2 = _saHd::P64;
      R1 = _saFO::P64;
      call $wa8_saFO_info(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  cbEt:
      Hp = Hp + 24;
      if (Hp > HpLim) goto cbEw; else goto cbEv;
  cbEw:
      HpAlloc = 24;
      R1 = _saH8::P64;
      call stg_gc_unpt_r1(R1) returns to cbEk, args: 8, res: 8, upd: 8;
  cbEv:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _saGF::P64;
      P64[Hp] = _saGC::P64;
      _cbEr::P64 = Hp - 14;
      _cbEW::I64 = _saGE::I64 - 1;
      _saH9::I64 = _cbEW::I64;
      R6 = _saH9::I64;
      R5 = _saGJ::P64;
      R4 = _saGI::I64;
      R3 = _saGN::I64;
      R2 = _saGL::I64;
      R1 = _saFN::P64;
      P64[(old + 16)] = _cbEr::P64;
      call $s$wa_saFN_info(R6,
                           R5,
                           R4,
                           R3,
                           R2,
                           R1) args: 16, res: 0, upd: 8;
  cbE9:
      R3 = _saGU::I64;
      R2 = _saGI::I64;
      call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
  cbDQ:
      R4 = _saGM::P64;
      R3 = _saGK::P64;
      R2 = _saGE::I64;
      call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:46.95306 UTC

{offset
  cbDh:
      _saGC::P64 = R4;
      _saGB::I64 = R3;
      _saGA::P64 = R2;
      _saFO::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cbDi; else goto cbDj;
  cbDj:
      if (HpLim == 0) goto cbDi; else goto cbES;
  cbDi:
      R4 = _saGC::P64;
      R3 = _saGB::I64;
      R2 = _saGA::P64;
      R1 = _saFO::P64;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  cbES:
      _saFB::P64 = P64[_saFO::P64 + 4];
      _saFF::P64 = P64[_saFO::P64 + 12];
      _saFN::P64 = P64[_saFO::P64 + 20];
      _saGE::I64 = _saGB::I64;
      if (_saGE::I64 != 0) goto cbDf; else goto cbDg;
  cbDf:
      I64[(young<cbDl> + 8)] = cbDl;
      R1 = _saGA::P64;
      if (R1 & 7 != 0) goto cbDl; else goto cbDm;
  cbDm:
      call (I64[R1])(R1) returns to cbDl, args: 8, res: 8, upd: 8;
  cbDl:
      _saGF::P64 = R1;
      _saGG::P64 = P64[_saGF::P64 + 7];
      _saGH::P64 = P64[_saGF::P64 + 15];
      _saGJ::P64 = P64[_saGF::P64 + 23];
      _saGI::I64 = I64[_saGF::P64 + 31];
      I64[(young<cbDq> + 8)] = cbDq;
      R1 = _saGG::P64;
      if (R1 & 7 != 0) goto cbDq; else goto cbDr;
  cbDr:
      call (I64[R1])(R1) returns to cbDq, args: 8, res: 8, upd: 8;
  cbDq:
      _saGK::P64 = R1;
      _saGL::I64 = I64[_saGK::P64 + 7];
      I64[(young<cbDv> + 8)] = cbDv;
      R1 = _saGH::P64;
      if (R1 & 7 != 0) goto cbDv; else goto cbDy;
  cbDy:
      call (I64[R1])(R1) returns to cbDv, args: 8, res: 8, upd: 8;
  cbDv:
      _saGM::P64 = R1;
      _saGN::I64 = I64[_saGM::P64 + 7];
      _cbDD::I64 = %MO_S_Le_W64(_saGL::I64, _saGE::I64);
      _saGO::I64 = _cbDD::I64;
      if (_saGO::I64 != 0) goto cbER; else goto cbDQ;
  cbER:
      _cbDL::I64 = %MO_S_Le_W64(_saGE::I64, _saGN::I64);
      _saGR::I64 = _cbDL::I64;
      if (_saGR::I64 != 0) goto cbEQ; else goto cbDQ;
  cbEQ:
      _cbDT::I64 = _saGE::I64 - _saGL::I64;
      _saGU::I64 = _cbDT::I64;
      _cbDW::I64 = %MO_S_Le_W64(0, _saGU::I64);
      _saGV::I64 = _cbDW::I64;
      if (_saGV::I64 != 0) goto cbEP; else goto cbE9;
  cbEP:
      _cbE4::I64 = %MO_S_Lt_W64(_saGU::I64, _saGI::I64);
      _saGY::I64 = _cbE4::I64;
      if (_saGY::I64 != 0) goto cbEd; else goto cbE9;
  cbEd:
      _saH2::P64 = P64[(_saGJ::P64 + 24) + (_saGU::I64 << 3)];
      _saH2::P64 = _saH2::P64;
      I64[(young<cbEc> + 8)] = cbEc;
      R1 = _saH2::P64;
      if (R1 & 7 != 0) goto cbEc; else goto cbEe;
  cbEe:
      call (I64[R1])(R1) returns to cbEc, args: 8, res: 8, upd: 8;
  cbEc:
      _saH3::P64 = R1;
      _saH4::P64 = P64[_saH3::P64 + 7];
      I64[(young<cbEi> + 8)] = cbEi;
      R1 = _saH4::P64;
      call stg_norec_readTVar#(R1) returns to cbEi, args: 8, res: 8, upd: 8;
  cbEi:
      _saH7::P64 = R1;
      I64[(young<cbEk> + 8)] = cbEk;
      R1 = _saH7::P64;
      if (R1 & 7 != 0) goto cbEk; else goto cbEn;
  cbEn:
      call (I64[R1])(R1) returns to cbEk, args: 8, res: 8, upd: 8;
  cbEk:
      _saH8::P64 = R1;
      _cbET::P64 = _saH8::P64 & 7;
      if (_cbET::P64 != 1) goto cbEB; else goto cbEt;
  cbEB:
      _saHb::P64 = P64[_saH8::P64 + 6];
      _saHc::P64 = P64[_saH8::P64 + 14];
      _saHd::P64 = P64[_saH8::P64 + 22];
      I64[(young<cbEz> + 8)] = cbEz;
      R2 = _saFB::P64;
      I64[(young<cbEz> + 32)] = stg_ap_pp_info;
      P64[(young<cbEz> + 24)] = _saHb::P64;
      P64[(young<cbEz> + 16)] = _saFF::P64;
      call GHC.Classes.>_info(R2) returns to cbEz, args: 32, res: 8, upd: 8;
  cbEz:
      _saHe::P64 = R1;
      _cbEU::P64 = _saHe::P64 & 7;
      if (_cbEU::P64 != 1) goto cbEL; else goto cbEH;
  cbEL:
      Hp = Hp + 24;
      if (Hp > HpLim) goto cbEO; else goto cbEN;
  cbEO:
      HpAlloc = 24;
      R1 = _saHe::P64;
      call stg_gc_unpt_r1(R1) returns to cbEz, args: 8, res: 8, upd: 8;
  cbEN:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _saGF::P64;
      P64[Hp] = _saGC::P64;
      _cbEK::P64 = Hp - 14;
      _cbEV::I64 = _saGE::I64 - 1;
      _saHf::I64 = _cbEV::I64;
      R6 = _saHf::I64;
      R5 = _saGJ::P64;
      R4 = _saGI::I64;
      R3 = _saGN::I64;
      R2 = _saGL::I64;
      R1 = _saFN::P64;
      P64[(old + 16)] = _cbEK::P64;
      call $s$wa_saFN_info(R6,
                           R5,
                           R4,
                           R3,
                           R2,
                           R1) args: 16, res: 0, upd: 8;
  cbEH:
      R4 = _saGC::P64;
      R3 = _saGE::I64;
      R2 = _saHd::P64;
      R1 = _saFO::P64;
      call $wa8_saFO_info(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  cbEt:
      Hp = Hp + 24;
      if (Hp > HpLim) goto cbEw; else goto cbEv;
  cbEw:
      HpAlloc = 24;
      R1 = _saH8::P64;
      call stg_gc_unpt_r1(R1) returns to cbEk, args: 8, res: 8, upd: 8;
  cbEv:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _saGF::P64;
      P64[Hp] = _saGC::P64;
      _cbEr::P64 = Hp - 14;
      _cbEW::I64 = _saGE::I64 - 1;
      _saH9::I64 = _cbEW::I64;
      R6 = _saH9::I64;
      R5 = _saGJ::P64;
      R4 = _saGI::I64;
      R3 = _saGN::I64;
      R2 = _saGL::I64;
      R1 = _saFN::P64;
      P64[(old + 16)] = _cbEr::P64;
      call $s$wa_saFN_info(R6,
                           R5,
                           R4,
                           R3,
                           R2,
                           R1) args: 16, res: 0, upd: 8;
  cbE9:
      R3 = _saGU::I64;
      R2 = _saGI::I64;
      call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
  cbDQ:
      R4 = _saGM::P64;
      R3 = _saGK::P64;
      R2 = _saGE::I64;
      call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbDg:
      R1 = _saGC::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:46.963767 UTC

{offset
  cbDh:
      _saGC::P64 = R4;
      _saGB::I64 = R3;
      _saGA::P64 = R2;
      _saFO::P64 = R1;
      if ((Sp + 8) - 128 < SpLim) goto cbDi; else goto cbDj;
  cbDj:
      if (HpLim == 0) goto cbDi; else goto cbES;
  cbDi:
      R4 = _saGC::P64;
      R3 = _saGB::I64;
      R2 = _saGA::P64;
      R1 = _saFO::P64;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  cbES:
      _saFB::P64 = P64[_saFO::P64 + 4];
      _saFF::P64 = P64[_saFO::P64 + 12];
      _saFN::P64 = P64[_saFO::P64 + 20];
      _saGE::I64 = _saGB::I64;
      if (_saGE::I64 != 0) goto cbDf; else goto cbDg;
  cbDf:
      I64[Sp - 56] = cbDl;
      R1 = _saGA::P64;
      P64[Sp - 48] = _saFB::P64;
      P64[Sp - 40] = _saFF::P64;
      P64[Sp - 32] = _saFN::P64;
      P64[Sp - 24] = _saFO::P64;
      P64[Sp - 16] = _saGC::P64;
      I64[Sp - 8] = _saGE::I64;
      Sp = Sp - 56;
      if (R1 & 7 != 0) goto cbDl; else goto cbDm;
  cbDm:
      call (I64[R1])(R1) returns to cbDl, args: 8, res: 8, upd: 8;
  cbDl:
      _saFB::P64 = P64[Sp + 8];
      _saFF::P64 = P64[Sp + 16];
      _saFN::P64 = P64[Sp + 24];
      _saFO::P64 = P64[Sp + 32];
      _saGC::P64 = P64[Sp + 40];
      _saGE::I64 = I64[Sp + 48];
      _saGF::P64 = R1;
      _saGG::P64 = P64[_saGF::P64 + 7];
      _saGH::P64 = P64[_saGF::P64 + 15];
      _saGJ::P64 = P64[_saGF::P64 + 23];
      _saGI::I64 = I64[_saGF::P64 + 31];
      I64[Sp - 32] = cbDq;
      R1 = _saGG::P64;
      P64[Sp - 24] = _saGH::P64;
      I64[Sp - 16] = _saGI::I64;
      P64[Sp - 8] = _saGJ::P64;
      P64[Sp] = _saGF::P64;
      Sp = Sp - 32;
      if (R1 & 7 != 0) goto cbDq; else goto cbDr;
  cbDr:
      call (I64[R1])(R1) returns to cbDq, args: 8, res: 8, upd: 8;
  cbDq:
      _saFB::P64 = P64[Sp + 40];
      _saFF::P64 = P64[Sp + 48];
      _saFN::P64 = P64[Sp + 56];
      _saFO::P64 = P64[Sp + 64];
      _saGC::P64 = P64[Sp + 72];
      _saGE::I64 = I64[Sp + 80];
      _saGF::P64 = P64[Sp + 32];
      _saGH::P64 = P64[Sp + 8];
      _saGI::I64 = I64[Sp + 16];
      _saGJ::P64 = P64[Sp + 24];
      _saGK::P64 = R1;
      _saGL::I64 = I64[_saGK::P64 + 7];
      I64[Sp - 8] = cbDv;
      R1 = _saGH::P64;
      I64[Sp] = _saGL::I64;
      P64[Sp + 8] = _saGK::P64;
      Sp = Sp - 8;
      if (R1 & 7 != 0) goto cbDv; else goto cbDy;
  cbDy:
      call (I64[R1])(R1) returns to cbDv, args: 8, res: 8, upd: 8;
  cbDv:
      _saFB::P64 = P64[Sp + 48];
      _saFF::P64 = P64[Sp + 56];
      _saFN::P64 = P64[Sp + 64];
      _saFO::P64 = P64[Sp + 72];
      _saGC::P64 = P64[Sp + 80];
      _saGE::I64 = I64[Sp + 88];
      _saGF::P64 = P64[Sp + 40];
      _saGI::I64 = I64[Sp + 24];
      _saGJ::P64 = P64[Sp + 32];
      _saGK::P64 = P64[Sp + 16];
      _saGL::I64 = I64[Sp + 8];
      _saGM::P64 = R1;
      _saGN::I64 = I64[_saGM::P64 + 7];
      _cbDD::I64 = %MO_S_Le_W64(_saGL::I64, _saGE::I64);
      _saGO::I64 = _cbDD::I64;
      if (_saGO::I64 != 0) goto cbER; else goto cbDQ;
  cbER:
      _cbDL::I64 = %MO_S_Le_W64(_saGE::I64, _saGN::I64);
      _saGR::I64 = _cbDL::I64;
      if (_saGR::I64 != 0) goto cbEQ; else goto cbDQ;
  cbEQ:
      _cbDT::I64 = _saGE::I64 - _saGL::I64;
      _saGU::I64 = _cbDT::I64;
      _cbDW::I64 = %MO_S_Le_W64(0, _saGU::I64);
      _saGV::I64 = _cbDW::I64;
      if (_saGV::I64 != 0) goto cbEP; else goto cbE9;
  cbEP:
      _cbE4::I64 = %MO_S_Lt_W64(_saGU::I64, _saGI::I64);
      _saGY::I64 = _cbE4::I64;
      if (_saGY::I64 != 0) goto cbEd; else goto cbE9;
  cbEd:
      _saH2::P64 = P64[(_saGJ::P64 + 24) + (_saGU::I64 << 3)];
      _saH2::P64 = _saH2::P64;
      I64[Sp] = cbEc;
      R1 = _saH2::P64;
      I64[Sp + 16] = _saGN::I64;
      if (R1 & 7 != 0) goto cbEc; else goto cbEe;
  cbEe:
      call (I64[R1])(R1) returns to cbEc, args: 8, res: 8, upd: 8;
  cbEc:
      _saFB::P64 = P64[Sp + 48];
      _saFF::P64 = P64[Sp + 56];
      _saFN::P64 = P64[Sp + 64];
      _saFO::P64 = P64[Sp + 72];
      _saGC::P64 = P64[Sp + 80];
      _saGE::I64 = I64[Sp + 88];
      _saGF::P64 = P64[Sp + 40];
      _saGI::I64 = I64[Sp + 24];
      _saGJ::P64 = P64[Sp + 32];
      _saGL::I64 = I64[Sp + 8];
      _saGN::I64 = I64[Sp + 16];
      _saH3::P64 = R1;
      _saH4::P64 = P64[_saH3::P64 + 7];
      I64[Sp] = cbEi;
      R1 = _saH4::P64;
      call stg_norec_readTVar#(R1) returns to cbEi, args: 8, res: 8, upd: 8;
  cbEi:
      _saFB::P64 = P64[Sp + 48];
      _saFF::P64 = P64[Sp + 56];
      _saFN::P64 = P64[Sp + 64];
      _saFO::P64 = P64[Sp + 72];
      _saGC::P64 = P64[Sp + 80];
      _saGE::I64 = I64[Sp + 88];
      _saGF::P64 = P64[Sp + 40];
      _saGI::I64 = I64[Sp + 24];
      _saGJ::P64 = P64[Sp + 32];
      _saGL::I64 = I64[Sp + 8];
      _saGN::I64 = I64[Sp + 16];
      _saH7::P64 = R1;
      I64[Sp] = cbEk;
      R1 = _saH7::P64;
      if (R1 & 7 != 0) goto cbEk; else goto cbEn;
  cbEn:
      call (I64[R1])(R1) returns to cbEk, args: 8, res: 8, upd: 8;
  cbEk:
      _saFB::P64 = P64[Sp + 48];
      _saFF::P64 = P64[Sp + 56];
      _saFN::P64 = P64[Sp + 64];
      _saFO::P64 = P64[Sp + 72];
      _saGC::P64 = P64[Sp + 80];
      _saGE::I64 = I64[Sp + 88];
      _saGF::P64 = P64[Sp + 40];
      _saGI::I64 = I64[Sp + 24];
      _saGJ::P64 = P64[Sp + 32];
      _saGL::I64 = I64[Sp + 8];
      _saGN::I64 = I64[Sp + 16];
      _saH8::P64 = R1;
      _cbET::P64 = _saH8::P64 & 7;
      if (_cbET::P64 != 1) goto cbEB; else goto cbEt;
  cbEB:
      _saHb::P64 = P64[_saH8::P64 + 6];
      _saHc::P64 = P64[_saH8::P64 + 14];
      _saHd::P64 = P64[_saH8::P64 + 22];
      I64[Sp] = cbEz;
      R2 = _saFB::P64;
      I64[Sp - 24] = stg_ap_pp_info;
      P64[Sp - 16] = _saHb::P64;
      P64[Sp - 8] = _saFF::P64;
      P64[Sp + 56] = _saHd::P64;
      Sp = Sp - 24;
      call GHC.Classes.>_info(R2) returns to cbEz, args: 32, res: 8, upd: 8;
  cbEz:
      _saFN::P64 = P64[Sp + 64];
      _saFO::P64 = P64[Sp + 72];
      _saGC::P64 = P64[Sp + 80];
      _saGE::I64 = I64[Sp + 88];
      _saGF::P64 = P64[Sp + 40];
      _saGI::I64 = I64[Sp + 24];
      _saGJ::P64 = P64[Sp + 32];
      _saGL::I64 = I64[Sp + 8];
      _saGN::I64 = I64[Sp + 16];
      _saHd::P64 = P64[Sp + 56];
      _saHe::P64 = R1;
      _cbEU::P64 = _saHe::P64 & 7;
      if (_cbEU::P64 != 1) goto cbEL; else goto cbEH;
  cbEL:
      Hp = Hp + 24;
      if (Hp > HpLim) goto cbEO; else goto cbEN;
  cbEO:
      HpAlloc = 24;
      R1 = _saHe::P64;
      call stg_gc_unpt_r1(R1) returns to cbEz, args: 8, res: 8, upd: 8;
  cbEN:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _saGF::P64;
      P64[Hp] = _saGC::P64;
      _cbEK::P64 = Hp - 14;
      _cbEV::I64 = _saGE::I64 - 1;
      _saHf::I64 = _cbEV::I64;
      R6 = _saHf::I64;
      R5 = _saGJ::P64;
      R4 = _saGI::I64;
      R3 = _saGN::I64;
      R2 = _saGL::I64;
      R1 = _saFN::P64;
      P64[Sp + 88] = _cbEK::P64;
      Sp = Sp + 88;
      call $s$wa_saFN_info(R6,
                           R5,
                           R4,
                           R3,
                           R2,
                           R1) args: 16, res: 0, upd: 8;
  cbEH:
      R4 = _saGC::P64;
      R3 = _saGE::I64;
      R2 = _saHd::P64;
      R1 = _saFO::P64;
      Sp = Sp + 96;
      call $wa8_saFO_info(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  cbEt:
      Hp = Hp + 24;
      if (Hp > HpLim) goto cbEw; else goto cbEv;
  cbEw:
      HpAlloc = 24;
      R1 = _saH8::P64;
      call stg_gc_unpt_r1(R1) returns to cbEk, args: 8, res: 8, upd: 8;
  cbEv:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _saGF::P64;
      P64[Hp] = _saGC::P64;
      _cbEr::P64 = Hp - 14;
      _cbEW::I64 = _saGE::I64 - 1;
      _saH9::I64 = _cbEW::I64;
      R6 = _saH9::I64;
      R5 = _saGJ::P64;
      R4 = _saGI::I64;
      R3 = _saGN::I64;
      R2 = _saGL::I64;
      R1 = _saFN::P64;
      P64[Sp + 88] = _cbEr::P64;
      Sp = Sp + 88;
      call $s$wa_saFN_info(R6,
                           R5,
                           R4,
                           R3,
                           R2,
                           R1) args: 16, res: 0, upd: 8;
  cbE9:
      R3 = _saGU::I64;
      R2 = _saGI::I64;
      Sp = Sp + 96;
      call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
  cbDQ:
      R4 = _saGM::P64;
      R3 = _saGK::P64;
      R2 = _saGE::I64;
      Sp = Sp + 96;
      call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbDg:
      R1 = _saGC::P64;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:46.976701 UTC

{offset
  cbDh:
      _saGC::P64 = R4;
      _saGB::I64 = R3;
      _saGA::P64 = R2;
      _saFO::P64 = R1;
      if ((Sp + -120) < SpLim) goto cbDi; else goto cbDj;
  cbDj:
      if (HpLim == 0) goto cbDi; else goto cbES;
  cbDi:
      R4 = _saGC::P64;
      R3 = _saGB::I64;
      R2 = _saGA::P64;
      R1 = _saFO::P64;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  cbES:
      if (_saGB::I64 != 0) goto cbDf; else goto cbDg;
  cbDf:
      I64[Sp - 56] = cbDl;
      R1 = _saGA::P64;
      P64[Sp - 48] = P64[_saFO::P64 + 4];
      P64[Sp - 40] = P64[_saFO::P64 + 12];
      P64[Sp - 32] = P64[_saFO::P64 + 20];
      P64[Sp - 24] = _saFO::P64;
      P64[Sp - 16] = _saGC::P64;
      I64[Sp - 8] = _saGB::I64;
      Sp = Sp - 56;
      if (R1 & 7 != 0) goto cbDl; else goto cbDm;
  cbDm:
      call (I64[R1])(R1) returns to cbDl, args: 8, res: 8, upd: 8;
  cbDl:
      I64[Sp - 32] = cbDq;
      _saGF::P64 = R1;
      _saGH::P64 = P64[R1 + 15];
      _saGJ::P64 = P64[R1 + 23];
      _saGI::I64 = I64[R1 + 31];
      R1 = P64[R1 + 7];
      P64[Sp - 24] = _saGH::P64;
      I64[Sp - 16] = _saGI::I64;
      P64[Sp - 8] = _saGJ::P64;
      P64[Sp] = _saGF::P64;
      Sp = Sp - 32;
      if (R1 & 7 != 0) goto cbDq; else goto cbDr;
  cbDr:
      call (I64[R1])(R1) returns to cbDq, args: 8, res: 8, upd: 8;
  cbDq:
      I64[Sp - 8] = cbDv;
      _saGK::P64 = R1;
      _saGL::I64 = I64[R1 + 7];
      R1 = P64[Sp + 8];
      I64[Sp] = _saGL::I64;
      P64[Sp + 8] = _saGK::P64;
      Sp = Sp - 8;
      if (R1 & 7 != 0) goto cbDv; else goto cbDy;
  cbDy:
      call (I64[R1])(R1) returns to cbDv, args: 8, res: 8, upd: 8;
  cbDv:
      _saGE::I64 = I64[Sp + 88];
      _saGK::P64 = P64[Sp + 16];
      _saGL::I64 = I64[Sp + 8];
      _saGM::P64 = R1;
      if (%MO_S_Le_W64(_saGL::I64,
                       _saGE::I64)) goto cbER; else goto cbDQ;
  cbER:
      _saGN::I64 = I64[R1 + 7];
      if (%MO_S_Le_W64(_saGE::I64,
                       _saGN::I64)) goto cbEQ; else goto cbDQ;
  cbEQ:
      _saGI::I64 = I64[Sp + 24];
      _saGU::I64 = _saGE::I64 - _saGL::I64;
      if (%MO_S_Le_W64(0, _saGU::I64)) goto cbEP; else goto cbE9;
  cbEP:
      if (%MO_S_Lt_W64(_saGU::I64,
                       _saGI::I64)) goto cbEd; else goto cbE9;
  cbEd:
      _saH2::P64 = P64[P64[Sp + 32] + ((_saGU::I64 << 3) + 24)];
      I64[Sp] = cbEc;
      R1 = _saH2::P64;
      I64[Sp + 16] = _saGN::I64;
      if (R1 & 7 != 0) goto cbEc; else goto cbEe;
  cbEe:
      call (I64[R1])(R1) returns to cbEc, args: 8, res: 8, upd: 8;
  cbEc:
      I64[Sp] = cbEi;
      R1 = P64[R1 + 7];
      call stg_norec_readTVar#(R1) returns to cbEi, args: 8, res: 8, upd: 8;
  cbEi:
      I64[Sp] = cbEk;
      R1 = R1;
      if (R1 & 7 != 0) goto cbEk; else goto cbEn;
  cbEn:
      call (I64[R1])(R1) returns to cbEk, args: 8, res: 8, upd: 8;
  cbEk:
      if (R1 & 7 != 1) goto cbEB; else goto cbEt;
  cbEB:
      I64[Sp] = cbEz;
      R2 = P64[Sp + 48];
      I64[Sp - 24] = stg_ap_pp_info;
      P64[Sp - 16] = P64[R1 + 6];
      P64[Sp - 8] = P64[Sp + 56];
      P64[Sp + 56] = P64[R1 + 22];
      Sp = Sp - 24;
      call GHC.Classes.>_info(R2) returns to cbEz, args: 32, res: 8, upd: 8;
  cbEz:
      _saGC::P64 = P64[Sp + 80];
      _saGE::I64 = I64[Sp + 88];
      if (R1 & 7 != 1) goto cbEL; else goto cbEH;
  cbEL:
      Hp = Hp + 24;
      if (Hp > HpLim) goto cbEO; else goto cbEN;
  cbEO:
      HpAlloc = 24;
      R1 = R1;
      call stg_gc_unpt_r1(R1) returns to cbEz, args: 8, res: 8, upd: 8;
  cbEN:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = P64[Sp + 40];
      P64[Hp] = _saGC::P64;
      R6 = _saGE::I64 - 1;
      R5 = P64[Sp + 32];
      R4 = I64[Sp + 24];
      R3 = I64[Sp + 16];
      R2 = I64[Sp + 8];
      R1 = P64[Sp + 64];
      P64[Sp + 88] = Hp - 14;
      Sp = Sp + 88;
      call $s$wa_saFN_info(R6,
                           R5,
                           R4,
                           R3,
                           R2,
                           R1) args: 16, res: 0, upd: 8;
  cbEH:
      R4 = _saGC::P64;
      R3 = _saGE::I64;
      R2 = P64[Sp + 56];
      R1 = P64[Sp + 72];
      Sp = Sp + 96;
      call $wa8_saFO_info(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  cbEt:
      Hp = Hp + 24;
      if (Hp > HpLim) goto cbEw; else goto cbEv;
  cbEw:
      HpAlloc = 24;
      R1 = R1;
      call stg_gc_unpt_r1(R1) returns to cbEk, args: 8, res: 8, upd: 8;
  cbEv:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = P64[Sp + 40];
      P64[Hp] = P64[Sp + 80];
      R6 = I64[Sp + 88] - 1;
      R5 = P64[Sp + 32];
      R4 = I64[Sp + 24];
      R3 = I64[Sp + 16];
      R2 = I64[Sp + 8];
      R1 = P64[Sp + 64];
      P64[Sp + 88] = Hp - 14;
      Sp = Sp + 88;
      call $s$wa_saFN_info(R6,
                           R5,
                           R4,
                           R3,
                           R2,
                           R1) args: 16, res: 0, upd: 8;
  cbE9:
      R3 = _saGU::I64;
      R2 = _saGI::I64;
      Sp = Sp + 96;
      call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
  cbDQ:
      R4 = _saGM::P64;
      R3 = _saGK::P64;
      R2 = _saGE::I64;
      Sp = Sp + 96;
      call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbDg:
      R1 = _saGC::P64;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:46.98755 UTC

[(cbDf,
  {lvl20_rawe_closure, lvl29_rawn_closure, $s$wa_saFN_closure,
   $wa8_saFO_closure}),
 (cbDg, {}),
 (cbDh,
  {lvl20_rawe_closure, lvl29_rawn_closure, $s$wa_saFN_closure,
   $wa8_saFO_closure}),
 (cbDi, {}),
 (cbDj,
  {lvl20_rawe_closure, lvl29_rawn_closure, $s$wa_saFN_closure,
   $wa8_saFO_closure}),
 (cbDl,
  {lvl20_rawe_closure, lvl29_rawn_closure, $s$wa_saFN_closure,
   $wa8_saFO_closure}),
 (cbDm,
  {lvl20_rawe_closure, lvl29_rawn_closure, $s$wa_saFN_closure,
   $wa8_saFO_closure}),
 (cbDq,
  {lvl20_rawe_closure, lvl29_rawn_closure, $s$wa_saFN_closure,
   $wa8_saFO_closure}),
 (cbDr,
  {lvl20_rawe_closure, lvl29_rawn_closure, $s$wa_saFN_closure,
   $wa8_saFO_closure}),
 (cbDv,
  {lvl20_rawe_closure, lvl29_rawn_closure, $s$wa_saFN_closure,
   $wa8_saFO_closure}),
 (cbDy,
  {lvl20_rawe_closure, lvl29_rawn_closure, $s$wa_saFN_closure,
   $wa8_saFO_closure}),
 (cbDQ, {lvl20_rawe_closure}), (cbE9, {lvl29_rawn_closure}),
 (cbEc, {$s$wa_saFN_closure, $wa8_saFO_closure}),
 (cbEd, {$s$wa_saFN_closure, $wa8_saFO_closure}),
 (cbEe, {$s$wa_saFN_closure, $wa8_saFO_closure}),
 (cbEi, {$s$wa_saFN_closure, $wa8_saFO_closure}),
 (cbEk, {$s$wa_saFN_closure, $wa8_saFO_closure}),
 (cbEn, {$s$wa_saFN_closure, $wa8_saFO_closure}),
 (cbEt, {$s$wa_saFN_closure, $wa8_saFO_closure}),
 (cbEv, {$s$wa_saFN_closure}),
 (cbEw, {$s$wa_saFN_closure, $wa8_saFO_closure}),
 (cbEz, {$s$wa_saFN_closure, $wa8_saFO_closure}),
 (cbEB, {$s$wa_saFN_closure, $wa8_saFO_closure}),
 (cbEH, {$wa8_saFO_closure}),
 (cbEL, {$s$wa_saFN_closure, $wa8_saFO_closure}),
 (cbEN, {$s$wa_saFN_closure}),
 (cbEO, {$s$wa_saFN_closure, $wa8_saFO_closure}),
 (cbEP,
  {lvl29_rawn_closure, $s$wa_saFN_closure, $wa8_saFO_closure}),
 (cbEQ,
  {lvl29_rawn_closure, $s$wa_saFN_closure, $wa8_saFO_closure}),
 (cbER,
  {lvl20_rawe_closure, lvl29_rawn_closure, $s$wa_saFN_closure,
   $wa8_saFO_closure}),
 (cbES,
  {lvl20_rawe_closure, lvl29_rawn_closure, $s$wa_saFN_closure,
   $wa8_saFO_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:46.991239 UTC

$wa8_saFO_entry() //  [R4, R3, R2, R1]
        { info_tbl: [(cbDh,
                      label: $wa8_saFO_info
                      rep:HeapRep 3 ptrs { Fun {arity: 4 fun_type: ArgSpec 21} }),
                     (cbDl,
                      label: block_cbDl_info
                      rep:StackRep [False, False, False, False, False, True]),
                     (cbDq,
                      label: block_cbDq_info
                      rep:StackRep [False, True, False, False, False, False, False,
                                    False, False, True]),
                     (cbDv,
                      label: block_cbDv_info
                      rep:StackRep [True, False, True, False, False, False, False, False,
                                    False, False, True]),
                     (cbEc,
                      label: block_cbEc_info
                      rep:StackRep [True, True, True, False, False, False, False, False,
                                    False, False, True]),
                     (cbEi,
                      label: block_cbEi_info
                      rep:StackRep [True, True, True, False, False, False, False, False,
                                    False, False, True]),
                     (cbEk,
                      label: block_cbEk_info
                      rep:StackRep [True, True, True, False, False, False, False, False,
                                    False, False, True]),
                     (cbEz,
                      label: block_cbEz_info
                      rep:StackRep [True, True, True, False, False, True, False, False,
                                    False, False, True])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cbDh:
          _saGC::P64 = R4;
          _saGB::I64 = R3;
          _saGA::P64 = R2;
          _saFO::P64 = R1;
          if ((Sp + -120) < SpLim) goto cbDi; else goto cbDj;
      cbDj:
          if (HpLim == 0) goto cbDi; else goto cbES;
      cbDi:
          R4 = _saGC::P64;
          R3 = _saGB::I64;
          R2 = _saGA::P64;
          R1 = _saFO::P64;
          call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
      cbES:
          if (_saGB::I64 != 0) goto cbDf; else goto cbDg;
      cbDf:
          I64[Sp - 56] = cbDl;
          R1 = _saGA::P64;
          P64[Sp - 48] = P64[_saFO::P64 + 4];
          P64[Sp - 40] = P64[_saFO::P64 + 12];
          P64[Sp - 32] = P64[_saFO::P64 + 20];
          P64[Sp - 24] = _saFO::P64;
          P64[Sp - 16] = _saGC::P64;
          I64[Sp - 8] = _saGB::I64;
          Sp = Sp - 56;
          if (R1 & 7 != 0) goto cbDl; else goto cbDm;
      cbDm:
          call (I64[R1])(R1) returns to cbDl, args: 8, res: 8, upd: 8;
      cbDl:
          I64[Sp - 32] = cbDq;
          _saGF::P64 = R1;
          _saGH::P64 = P64[R1 + 15];
          _saGJ::P64 = P64[R1 + 23];
          _saGI::I64 = I64[R1 + 31];
          R1 = P64[R1 + 7];
          P64[Sp - 24] = _saGH::P64;
          I64[Sp - 16] = _saGI::I64;
          P64[Sp - 8] = _saGJ::P64;
          P64[Sp] = _saGF::P64;
          Sp = Sp - 32;
          if (R1 & 7 != 0) goto cbDq; else goto cbDr;
      cbDr:
          call (I64[R1])(R1) returns to cbDq, args: 8, res: 8, upd: 8;
      cbDq:
          I64[Sp - 8] = cbDv;
          _saGK::P64 = R1;
          _saGL::I64 = I64[R1 + 7];
          R1 = P64[Sp + 8];
          I64[Sp] = _saGL::I64;
          P64[Sp + 8] = _saGK::P64;
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto cbDv; else goto cbDy;
      cbDy:
          call (I64[R1])(R1) returns to cbDv, args: 8, res: 8, upd: 8;
      cbDv:
          _saGE::I64 = I64[Sp + 88];
          _saGK::P64 = P64[Sp + 16];
          _saGL::I64 = I64[Sp + 8];
          _saGM::P64 = R1;
          if (%MO_S_Le_W64(_saGL::I64,
                           _saGE::I64)) goto cbER; else goto cbDQ;
      cbER:
          _saGN::I64 = I64[R1 + 7];
          if (%MO_S_Le_W64(_saGE::I64,
                           _saGN::I64)) goto cbEQ; else goto cbDQ;
      cbEQ:
          _saGI::I64 = I64[Sp + 24];
          _saGU::I64 = _saGE::I64 - _saGL::I64;
          if (%MO_S_Le_W64(0, _saGU::I64)) goto cbEP; else goto cbE9;
      cbEP:
          if (%MO_S_Lt_W64(_saGU::I64,
                           _saGI::I64)) goto cbEd; else goto cbE9;
      cbEd:
          _saH2::P64 = P64[P64[Sp + 32] + ((_saGU::I64 << 3) + 24)];
          I64[Sp] = cbEc;
          R1 = _saH2::P64;
          I64[Sp + 16] = _saGN::I64;
          if (R1 & 7 != 0) goto cbEc; else goto cbEe;
      cbEe:
          call (I64[R1])(R1) returns to cbEc, args: 8, res: 8, upd: 8;
      cbEc:
          I64[Sp] = cbEi;
          R1 = P64[R1 + 7];
          call stg_norec_readTVar#(R1) returns to cbEi, args: 8, res: 8, upd: 8;
      cbEi:
          I64[Sp] = cbEk;
          R1 = R1;
          if (R1 & 7 != 0) goto cbEk; else goto cbEn;
      cbEn:
          call (I64[R1])(R1) returns to cbEk, args: 8, res: 8, upd: 8;
      cbEk:
          if (R1 & 7 != 1) goto cbEB; else goto cbEt;
      cbEB:
          I64[Sp] = cbEz;
          R2 = P64[Sp + 48];
          I64[Sp - 24] = stg_ap_pp_info;
          P64[Sp - 16] = P64[R1 + 6];
          P64[Sp - 8] = P64[Sp + 56];
          P64[Sp + 56] = P64[R1 + 22];
          Sp = Sp - 24;
          call GHC.Classes.>_info(R2) returns to cbEz, args: 32, res: 8, upd: 8;
      cbEz:
          _saGC::P64 = P64[Sp + 80];
          _saGE::I64 = I64[Sp + 88];
          if (R1 & 7 != 1) goto cbEL; else goto cbEH;
      cbEL:
          Hp = Hp + 24;
          if (Hp > HpLim) goto cbEO; else goto cbEN;
      cbEO:
          HpAlloc = 24;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to cbEz, args: 8, res: 8, upd: 8;
      cbEN:
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = P64[Sp + 40];
          P64[Hp] = _saGC::P64;
          R6 = _saGE::I64 - 1;
          R5 = P64[Sp + 32];
          R4 = I64[Sp + 24];
          R3 = I64[Sp + 16];
          R2 = I64[Sp + 8];
          R1 = P64[Sp + 64];
          P64[Sp + 88] = Hp - 14;
          Sp = Sp + 88;
          call $s$wa_saFN_info(R6,
                               R5,
                               R4,
                               R3,
                               R2,
                               R1) args: 16, res: 0, upd: 8;
      cbEH:
          R4 = _saGC::P64;
          R3 = _saGE::I64;
          R2 = P64[Sp + 56];
          R1 = P64[Sp + 72];
          Sp = Sp + 96;
          call $wa8_saFO_info(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
      cbEt:
          Hp = Hp + 24;
          if (Hp > HpLim) goto cbEw; else goto cbEv;
      cbEw:
          HpAlloc = 24;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to cbEk, args: 8, res: 8, upd: 8;
      cbEv:
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = P64[Sp + 40];
          P64[Hp] = P64[Sp + 80];
          R6 = I64[Sp + 88] - 1;
          R5 = P64[Sp + 32];
          R4 = I64[Sp + 24];
          R3 = I64[Sp + 16];
          R2 = I64[Sp + 8];
          R1 = P64[Sp + 64];
          P64[Sp + 88] = Hp - 14;
          Sp = Sp + 88;
          call $s$wa_saFN_info(R6,
                               R5,
                               R4,
                               R3,
                               R2,
                               R1) args: 16, res: 0, upd: 8;
      cbE9:
          R3 = _saGU::I64;
          R2 = _saGI::I64;
          Sp = Sp + 96;
          call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
      cbDQ:
          R4 = _saGM::P64;
          R3 = _saGK::P64;
          R2 = _saGE::I64;
          Sp = Sp + 96;
          call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
      cbDg:
          R1 = _saGC::P64;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:47.001704 UTC

$wa8_saFO_entry() //  [R4, R3, R2, R1]
        { info_tbl: [(cbDh,
                      label: $wa8_saFO_info
                      rep:HeapRep 3 ptrs { Fun {arity: 4 fun_type: ArgSpec 21} }),
                     (cbDl,
                      label: block_cbDl_info
                      rep:StackRep [False, False, False, False, False, True]),
                     (cbDq,
                      label: block_cbDq_info
                      rep:StackRep [False, True, False, False, False, False, False,
                                    False, False, True]),
                     (cbDv,
                      label: block_cbDv_info
                      rep:StackRep [True, False, True, False, False, False, False, False,
                                    False, False, True]),
                     (cbEc,
                      label: block_cbEc_info
                      rep:StackRep [True, True, True, False, False, False, False, False,
                                    False, False, True]),
                     (cbEi,
                      label: block_cbEi_info
                      rep:StackRep [True, True, True, False, False, False, False, False,
                                    False, False, True]),
                     (cbEk,
                      label: block_cbEk_info
                      rep:StackRep [True, True, True, False, False, False, False, False,
                                    False, False, True]),
                     (cbEz,
                      label: block_cbEz_info
                      rep:StackRep [True, True, True, False, False, True, False, False,
                                    False, False, True])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cbDh:
          _saGC::P64 = R4;
          _saGB::I64 = R3;
          _saGA::P64 = R2;
          _saFO::P64 = R1;
          if ((Sp + -120) < SpLim) goto cbDi; else goto cbDj;
      cbDj:
          if (HpLim == 0) goto cbDi; else goto cbES;
      cbDi:
          R4 = _saGC::P64;
          R3 = _saGB::I64;
          R2 = _saGA::P64;
          R1 = _saFO::P64;
          call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
      cbES:
          if (_saGB::I64 != 0) goto cbDf; else goto cbDg;
      cbDf:
          I64[Sp - 56] = cbDl;
          R1 = _saGA::P64;
          P64[Sp - 48] = P64[_saFO::P64 + 4];
          P64[Sp - 40] = P64[_saFO::P64 + 12];
          P64[Sp - 32] = P64[_saFO::P64 + 20];
          P64[Sp - 24] = _saFO::P64;
          P64[Sp - 16] = _saGC::P64;
          I64[Sp - 8] = _saGB::I64;
          Sp = Sp - 56;
          if (R1 & 7 != 0) goto cbDl; else goto cbDm;
      cbDm:
          call (I64[R1])(R1) returns to cbDl, args: 8, res: 8, upd: 8;
      cbDl:
          I64[Sp - 32] = cbDq;
          _saGF::P64 = R1;
          _saGH::P64 = P64[R1 + 15];
          _saGJ::P64 = P64[R1 + 23];
          _saGI::I64 = I64[R1 + 31];
          R1 = P64[R1 + 7];
          P64[Sp - 24] = _saGH::P64;
          I64[Sp - 16] = _saGI::I64;
          P64[Sp - 8] = _saGJ::P64;
          P64[Sp] = _saGF::P64;
          Sp = Sp - 32;
          if (R1 & 7 != 0) goto cbDq; else goto cbDr;
      cbDr:
          call (I64[R1])(R1) returns to cbDq, args: 8, res: 8, upd: 8;
      cbDq:
          I64[Sp - 8] = cbDv;
          _saGK::P64 = R1;
          _saGL::I64 = I64[R1 + 7];
          R1 = P64[Sp + 8];
          I64[Sp] = _saGL::I64;
          P64[Sp + 8] = _saGK::P64;
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto cbDv; else goto cbDy;
      cbDy:
          call (I64[R1])(R1) returns to cbDv, args: 8, res: 8, upd: 8;
      cbDv:
          _saGE::I64 = I64[Sp + 88];
          _saGK::P64 = P64[Sp + 16];
          _saGL::I64 = I64[Sp + 8];
          _saGM::P64 = R1;
          if (%MO_S_Gt_W64(_saGL::I64,
                           _saGE::I64)) goto cbDQ; else goto cbER;
      cbER:
          _saGN::I64 = I64[R1 + 7];
          if (%MO_S_Gt_W64(_saGE::I64,
                           _saGN::I64)) goto cbDQ; else goto cbEQ;
      cbDQ:
          R4 = _saGM::P64;
          R3 = _saGK::P64;
          R2 = _saGE::I64;
          Sp = Sp + 96;
          call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
      cbEQ:
          _saGI::I64 = I64[Sp + 24];
          _saGU::I64 = _saGE::I64 - _saGL::I64;
          if (%MO_S_Gt_W64(0, _saGU::I64)) goto cbE9; else goto cbEP;
      cbEP:
          if (%MO_S_Ge_W64(_saGU::I64,
                           _saGI::I64)) goto cbE9; else goto cbEd;
      cbE9:
          R3 = _saGU::I64;
          R2 = _saGI::I64;
          Sp = Sp + 96;
          call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
      cbEd:
          _saH2::P64 = P64[P64[Sp + 32] + ((_saGU::I64 << 3) + 24)];
          I64[Sp] = cbEc;
          R1 = _saH2::P64;
          I64[Sp + 16] = _saGN::I64;
          if (R1 & 7 != 0) goto cbEc; else goto cbEe;
      cbEe:
          call (I64[R1])(R1) returns to cbEc, args: 8, res: 8, upd: 8;
      cbEc:
          I64[Sp] = cbEi;
          R1 = P64[R1 + 7];
          call stg_norec_readTVar#(R1) returns to cbEi, args: 8, res: 8, upd: 8;
      cbEi:
          I64[Sp] = cbEk;
          R1 = R1;
          if (R1 & 7 != 0) goto cbEk; else goto cbEn;
      cbEn:
          call (I64[R1])(R1) returns to cbEk, args: 8, res: 8, upd: 8;
      cbEk:
          if (R1 & 7 != 1) goto cbEB; else goto cbEt;
      cbEB:
          I64[Sp] = cbEz;
          R2 = P64[Sp + 48];
          I64[Sp - 24] = stg_ap_pp_info;
          P64[Sp - 16] = P64[R1 + 6];
          P64[Sp - 8] = P64[Sp + 56];
          P64[Sp + 56] = P64[R1 + 22];
          Sp = Sp - 24;
          call GHC.Classes.>_info(R2) returns to cbEz, args: 32, res: 8, upd: 8;
      cbEz:
          _saGC::P64 = P64[Sp + 80];
          _saGE::I64 = I64[Sp + 88];
          if (R1 & 7 != 1) goto cbEL; else goto cbEH;
      cbEL:
          Hp = Hp + 24;
          if (Hp > HpLim) goto cbEO; else goto cbEN;
      cbEO:
          HpAlloc = 24;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to cbEz, args: 8, res: 8, upd: 8;
      cbEN:
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = P64[Sp + 40];
          P64[Hp] = _saGC::P64;
          R6 = _saGE::I64 - 1;
          R5 = P64[Sp + 32];
          R4 = I64[Sp + 24];
          R3 = I64[Sp + 16];
          R2 = I64[Sp + 8];
          R1 = P64[Sp + 64];
          P64[Sp + 88] = Hp - 14;
          Sp = Sp + 88;
          call $s$wa_saFN_info(R6,
                               R5,
                               R4,
                               R3,
                               R2,
                               R1) args: 16, res: 0, upd: 8;
      cbEH:
          R4 = _saGC::P64;
          R3 = _saGE::I64;
          R2 = P64[Sp + 56];
          R1 = P64[Sp + 72];
          Sp = Sp + 96;
          call $wa8_saFO_info(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
      cbEt:
          Hp = Hp + 24;
          if (Hp > HpLim) goto cbEw; else goto cbEv;
      cbEw:
          HpAlloc = 24;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to cbEk, args: 8, res: 8, upd: 8;
      cbEv:
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = P64[Sp + 40];
          P64[Hp] = P64[Sp + 80];
          R6 = I64[Sp + 88] - 1;
          R5 = P64[Sp + 32];
          R4 = I64[Sp + 24];
          R3 = I64[Sp + 16];
          R2 = I64[Sp + 8];
          R1 = P64[Sp + 64];
          P64[Sp + 88] = Hp - 14;
          Sp = Sp + 88;
          call $s$wa_saFN_info(R6,
                               R5,
                               R4,
                               R3,
                               R2,
                               R1) args: 16, res: 0, upd: 8;
      cbDg:
          R1 = _saGC::P64;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:47.012802 UTC

{offset
  cbEY:
      _saFN::P64 = R1;
      _saFP::I64 = I64[(old + 56)];
      _saFQ::I64 = I64[(old + 48)];
      _saFR::I64 = I64[(old + 40)];
      _saFS::P64 = P64[(old + 32)];
      _saFT::I64 = I64[(old + 24)];
      _saFU::P64 = P64[(old + 16)];
      R6 = _saFT::I64;
      R5 = _saFS::P64;
      R4 = _saFR::I64;
      R3 = _saFQ::I64;
      R2 = _saFP::I64;
      R1 = _saFN::P64;
      P64[(old + 16)] = _saFU::P64;
      call $s$wa_saFN_info(R6,
                           R5,
                           R4,
                           R3,
                           R2,
                           R1) args: 16, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:47.013801 UTC

{offset
  cbEY:
      _saFN::P64 = R1;
      _saFP::I64 = I64[(old + 56)];
      _saFQ::I64 = I64[(old + 48)];
      _saFR::I64 = I64[(old + 40)];
      _saFS::P64 = P64[(old + 32)];
      _saFT::I64 = I64[(old + 24)];
      _saFU::P64 = P64[(old + 16)];
      R6 = _saFT::I64;
      R5 = _saFS::P64;
      R4 = _saFR::I64;
      R3 = _saFQ::I64;
      R2 = _saFP::I64;
      R1 = _saFN::P64;
      P64[(old + 16)] = _saFU::P64;
      call $s$wa_saFN_info(R6,
                           R5,
                           R4,
                           R3,
                           R2,
                           R1) args: 16, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:47.014765 UTC

{offset
  cbEY:
      _saFN::P64 = R1;
      _saFP::I64 = I64[(old + 56)];
      _saFQ::I64 = I64[(old + 48)];
      _saFR::I64 = I64[(old + 40)];
      _saFS::P64 = P64[(old + 32)];
      _saFT::I64 = I64[(old + 24)];
      _saFU::P64 = P64[(old + 16)];
      R6 = _saFT::I64;
      R5 = _saFS::P64;
      R4 = _saFR::I64;
      R3 = _saFQ::I64;
      R2 = _saFP::I64;
      R1 = _saFN::P64;
      P64[(old + 16)] = _saFU::P64;
      call $s$wa_saFN_info(R6,
                           R5,
                           R4,
                           R3,
                           R2,
                           R1) args: 16, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:47.015721 UTC

{offset
  cbEY:
      _saFN::P64 = R1;
      _saFP::I64 = I64[Sp];
      _saFQ::I64 = I64[Sp + 8];
      _saFR::I64 = I64[Sp + 16];
      _saFS::P64 = P64[Sp + 24];
      _saFT::I64 = I64[Sp + 32];
      _saFU::P64 = P64[Sp + 40];
      R6 = _saFT::I64;
      R5 = _saFS::P64;
      R4 = _saFR::I64;
      R3 = _saFQ::I64;
      R2 = _saFP::I64;
      R1 = _saFN::P64;
      Sp = Sp + 40;
      call $s$wa_saFN_info(R6,
                           R5,
                           R4,
                           R3,
                           R2,
                           R1) args: 16, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:47.016685 UTC

{offset
  cbEY:
      R6 = I64[Sp + 32];
      R5 = P64[Sp + 24];
      R4 = I64[Sp + 16];
      R3 = I64[Sp + 8];
      R2 = I64[Sp];
      R1 = R1;
      Sp = Sp + 40;
      call $s$wa_saFN_info(R6,
                           R5,
                           R4,
                           R3,
                           R2,
                           R1) args: 16, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:47.01752 UTC

[(cbEY, {$s$wa_saFN_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:47.017792 UTC

$s$wa_saFN_slow() //  [R1]
        { info_tbl: []
          stack_info: arg_space: 56 updfr_space: Just 8
        }
    {offset
      cbEY:
          R6 = I64[Sp + 32];
          R5 = P64[Sp + 24];
          R4 = I64[Sp + 16];
          R3 = I64[Sp + 8];
          R2 = I64[Sp];
          R1 = R1;
          Sp = Sp + 40;
          call $s$wa_saFN_info(R6,
                               R5,
                               R4,
                               R3,
                               R2,
                               R1) args: 16, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:47.018566 UTC

$s$wa_saFN_slow() //  [R1]
        { info_tbl: []
          stack_info: arg_space: 56 updfr_space: Just 8
        }
    {offset
      cbEY:
          R6 = I64[Sp + 32];
          R5 = P64[Sp + 24];
          R4 = I64[Sp + 16];
          R3 = I64[Sp + 8];
          R2 = I64[Sp];
          R1 = R1;
          Sp = Sp + 40;
          call $s$wa_saFN_info(R6,
                               R5,
                               R4,
                               R3,
                               R2,
                               R1) args: 16, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:47.019352 UTC

{offset
  cbG1:
      _saFT::I64 = R6;
      _saFS::P64 = R5;
      _saFR::I64 = R4;
      _saFQ::I64 = R3;
      _saFP::I64 = R2;
      _saFN::P64 = R1;
      _saFU::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto cbG2; else goto cbG3;
  cbG3:
      Hp = Hp + 32;
      if (Hp > HpLim) goto cbG5; else goto cbG4;
  cbG5:
      HpAlloc = 32;
      goto cbG2;
  cbG2:
      R1 = _saFN::P64;
      I64[(old + 56)] = _saFP::I64;
      I64[(old + 48)] = _saFQ::I64;
      I64[(old + 40)] = _saFR::I64;
      P64[(old + 32)] = _saFS::P64;
      I64[(old + 24)] = _saFT::I64;
      P64[(old + 16)] = _saFU::P64;
      call (stg_gc_fun)(R1) args: 56, res: 0, upd: 8;
  cbG4:
      _saFB::P64 = P64[_saFN::P64 + 8];
      _saFF::P64 = P64[_saFN::P64 + 16];
      _saFO::P64 = P64[_saFN::P64 + 24];
      _saFW::I64 = _saFT::I64;
      switch [-9223372036854775808 .. 9223372036854775807] _saFW::I64 {
          case 0 : goto cbG0;
          default: goto cbFZ;
      }
  cbG0:
      Hp = Hp - 32;
      R1 = _saFU::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
  cbFZ:
      _cbG7::I64 = %MO_S_Le_W64(_saFP::I64, _saFW::I64);
      _saFX::I64 = _cbG7::I64;
      switch [0 .. 1] _saFX::I64 {
          case 0 : goto cbGf;
          case 1 : goto cbHv;
      }
  cbHv:
      _cbGh::I64 = %MO_S_Le_W64(_saFW::I64, _saFQ::I64);
      _saG2::I64 = _cbGh::I64;
      switch [0 .. 1] _saG2::I64 {
          case 0 : goto cbGp;
          case 1 : goto cbHu;
      }
  cbHu:
      _cbGr::I64 = _saFW::I64 - _saFP::I64;
      _saG7::I64 = _cbGr::I64;
      _cbGu::I64 = %MO_S_Le_W64(0, _saG7::I64);
      _saG8::I64 = _cbGu::I64;
      switch [0 .. 1] _saG8::I64 {
          case 0 : goto cbGz;
          case 1 : goto cbHt;
      }
  cbHt:
      _cbGC::I64 = %MO_S_Lt_W64(_saG7::I64, _saFR::I64);
      _saGb::I64 = _cbGC::I64;
      switch [0 .. 1] _saGb::I64 {
          case 0 : goto cbGH;
          case 1 : goto cbGL;
      }
  cbGL:
      _saGf::P64 = P64[(_saFS::P64 + 24) + (_saG7::I64 << 3)];
      _saGf::P64 = _saGf::P64;
      Hp = Hp - 32;
      I64[(young<cbGK> + 8)] = cbGK;
      R1 = _saGf::P64;
      if (R1 & 7 != 0) goto cbGK; else goto cbGM;
  cbGM:
      call (I64[R1])(R1) returns to cbGK, args: 8, res: 8, upd: 8;
  cbGK:
      _saGg::P64 = R1;
      _saGh::P64 = P64[_saGg::P64 + 7];
      I64[(young<cbGQ> + 8)] = cbGQ;
      R1 = _saGh::P64;
      call stg_norec_readTVar#(R1) returns to cbGQ, args: 8, res: 8, upd: 8;
  cbGQ:
      _saGk::P64 = R1;
      I64[(young<cbGS> + 8)] = cbGS;
      R1 = _saGk::P64;
      if (R1 & 7 != 0) goto cbGS; else goto cbGV;
  cbGV:
      call (I64[R1])(R1) returns to cbGS, args: 8, res: 8, upd: 8;
  cbGS:
      _saGl::P64 = R1;
      _cbHw::P64 = _saGl::P64 & 7;
      switch [1 .. 2] _cbHw::P64 {
          case 1 : goto cbH4;
          case 2 : goto cbHc;
      }
  cbHc:
      _saGr::P64 = P64[_saGl::P64 + 6];
      _saGs::P64 = P64[_saGl::P64 + 14];
      _saGt::P64 = P64[_saGl::P64 + 22];
      I64[(young<cbHa> + 8)] = cbHa;
      R2 = _saFB::P64;
      I64[(young<cbHa> + 32)] = stg_ap_pp_info;
      P64[(young<cbHa> + 24)] = _saGr::P64;
      P64[(young<cbHa> + 16)] = _saFF::P64;
      call GHC.Classes.>_info(R2) returns to cbHa, args: 32, res: 8, upd: 8;
  cbHa:
      _saGu::P64 = R1;
      _cbHx::P64 = _saGu::P64 & 7;
      switch [1 .. 2] _cbHx::P64 {
          case 1 : goto cbHi;
          case 2 : goto cbHp;
      }
  cbHp:
      Hp = Hp + 96;
      if (Hp > HpLim) goto cbHs; else goto cbHr;
  cbHs:
      HpAlloc = 96;
      R1 = _saGu::P64;
      call stg_gc_unpt_r1(R1) returns to cbHa, args: 8, res: 8, upd: 8;
  cbHr:
      I64[Hp - 88] = GHC.Types.I#_con_info;
      I64[Hp - 80] = _saFQ::I64;
      _cbHl::P64 = Hp - 87;
      I64[Hp - 72] = GHC.Types.I#_con_info;
      I64[Hp - 64] = _saFP::I64;
      _cbHm::P64 = Hp - 71;
      I64[Hp - 56] = GHC.Arr.Array_con_info;
      P64[Hp - 48] = _cbHm::P64;
      P64[Hp - 40] = _cbHl::P64;
      P64[Hp - 32] = _saFS::P64;
      I64[Hp - 24] = _saFR::I64;
      _cbHn::P64 = Hp - 55;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _cbHn::P64;
      P64[Hp] = _saFU::P64;
      _cbHo::P64 = Hp - 14;
      _cbHy::I64 = _saFW::I64 - 1;
      _saGv::I64 = _cbHy::I64;
      R6 = _saGv::I64;
      R5 = _saFS::P64;
      R4 = _saFR::I64;
      R3 = _saFQ::I64;
      R2 = _saFP::I64;
      R1 = _saFN::P64;
      P64[(old + 16)] = _cbHo::P64;
      call $s$wa_saFN_info(R6,
                           R5,
                           R4,
                           R3,
                           R2,
                           R1) args: 16, res: 0, upd: 8;
  cbHi:
      R4 = _saFU::P64;
      R3 = _saFW::I64;
      R2 = _saGt::P64;
      R1 = _saFO::P64;
      call $wa8_saFO_info(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  cbH4:
      Hp = Hp + 96;
      if (Hp > HpLim) goto cbH7; else goto cbH6;
  cbH7:
      HpAlloc = 96;
      R1 = _saGl::P64;
      call stg_gc_unpt_r1(R1) returns to cbGS, args: 8, res: 8, upd: 8;
  cbH6:
      I64[Hp - 88] = GHC.Types.I#_con_info;
      I64[Hp - 80] = _saFQ::I64;
      _cbGZ::P64 = Hp - 87;
      I64[Hp - 72] = GHC.Types.I#_con_info;
      I64[Hp - 64] = _saFP::I64;
      _cbH0::P64 = Hp - 71;
      I64[Hp - 56] = GHC.Arr.Array_con_info;
      P64[Hp - 48] = _cbH0::P64;
      P64[Hp - 40] = _cbGZ::P64;
      P64[Hp - 32] = _saFS::P64;
      I64[Hp - 24] = _saFR::I64;
      _cbH1::P64 = Hp - 55;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _cbH1::P64;
      P64[Hp] = _saFU::P64;
      _cbH2::P64 = Hp - 14;
      _cbHz::I64 = _saFW::I64 - 1;
      _saGm::I64 = _cbHz::I64;
      R6 = _saGm::I64;
      R5 = _saFS::P64;
      R4 = _saFR::I64;
      R3 = _saFQ::I64;
      R2 = _saFP::I64;
      R1 = _saFN::P64;
      P64[(old + 16)] = _cbH2::P64;
      call $s$wa_saFN_info(R6,
                           R5,
                           R4,
                           R3,
                           R2,
                           R1) args: 16, res: 0, upd: 8;
  cbGH:
      Hp = Hp - 32;
      R3 = _saG7::I64;
      R2 = _saFR::I64;
      call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
  cbGz:
      Hp = Hp - 32;
      R3 = _saG7::I64;
      R2 = _saFR::I64;
      call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
  cbGp:
      I64[Hp - 24] = GHC.Types.I#_con_info;
      I64[Hp - 16] = _saFQ::I64;
      _cbGm::P64 = Hp - 23;
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _saFP::I64;
      _cbGn::P64 = Hp - 7;
      R4 = _cbGm::P64;
      R3 = _cbGn::P64;
      R2 = _saFW::I64;
      call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbGf:
      I64[Hp - 24] = GHC.Types.I#_con_info;
      I64[Hp - 16] = _saFQ::I64;
      _cbGc::P64 = Hp - 23;
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _saFP::I64;
      _cbGd::P64 = Hp - 7;
      R4 = _cbGc::P64;
      R3 = _cbGd::P64;
      R2 = _saFW::I64;
      call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:47.028963 UTC

{offset
  cbG1:
      _saFT::I64 = R6;
      _saFS::P64 = R5;
      _saFR::I64 = R4;
      _saFQ::I64 = R3;
      _saFP::I64 = R2;
      _saFN::P64 = R1;
      _saFU::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto cbG2; else goto cbG3;
  cbG3:
      Hp = Hp + 32;
      if (Hp > HpLim) goto cbG5; else goto cbG4;
  cbG5:
      HpAlloc = 32;
      goto cbG2;
  cbG2:
      R1 = _saFN::P64;
      I64[(old + 56)] = _saFP::I64;
      I64[(old + 48)] = _saFQ::I64;
      I64[(old + 40)] = _saFR::I64;
      P64[(old + 32)] = _saFS::P64;
      I64[(old + 24)] = _saFT::I64;
      P64[(old + 16)] = _saFU::P64;
      call (stg_gc_fun)(R1) args: 56, res: 0, upd: 8;
  cbG4:
      _saFB::P64 = P64[_saFN::P64 + 8];
      _saFF::P64 = P64[_saFN::P64 + 16];
      _saFO::P64 = P64[_saFN::P64 + 24];
      _saFW::I64 = _saFT::I64;
      switch [-9223372036854775808 .. 9223372036854775807] _saFW::I64 {
          case 0 : goto cbG0;
          default: goto cbFZ;
      }
  cbG0:
      Hp = Hp - 32;
      R1 = _saFU::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
  cbFZ:
      _cbG7::I64 = %MO_S_Le_W64(_saFP::I64, _saFW::I64);
      _saFX::I64 = _cbG7::I64;
      switch [0 .. 1] _saFX::I64 {
          case 0 : goto cbGf;
          case 1 : goto cbHv;
      }
  cbHv:
      _cbGh::I64 = %MO_S_Le_W64(_saFW::I64, _saFQ::I64);
      _saG2::I64 = _cbGh::I64;
      switch [0 .. 1] _saG2::I64 {
          case 0 : goto cbGp;
          case 1 : goto cbHu;
      }
  cbHu:
      _cbGr::I64 = _saFW::I64 - _saFP::I64;
      _saG7::I64 = _cbGr::I64;
      _cbGu::I64 = %MO_S_Le_W64(0, _saG7::I64);
      _saG8::I64 = _cbGu::I64;
      switch [0 .. 1] _saG8::I64 {
          case 0 : goto cbGH;
          case 1 : goto cbHt;
      }
  cbHt:
      _cbGC::I64 = %MO_S_Lt_W64(_saG7::I64, _saFR::I64);
      _saGb::I64 = _cbGC::I64;
      switch [0 .. 1] _saGb::I64 {
          case 0 : goto cbGH;
          case 1 : goto cbGL;
      }
  cbGL:
      _saGf::P64 = P64[(_saFS::P64 + 24) + (_saG7::I64 << 3)];
      _saGf::P64 = _saGf::P64;
      Hp = Hp - 32;
      I64[(young<cbGK> + 8)] = cbGK;
      R1 = _saGf::P64;
      if (R1 & 7 != 0) goto cbGK; else goto cbGM;
  cbGM:
      call (I64[R1])(R1) returns to cbGK, args: 8, res: 8, upd: 8;
  cbGK:
      _saGg::P64 = R1;
      _saGh::P64 = P64[_saGg::P64 + 7];
      I64[(young<cbGQ> + 8)] = cbGQ;
      R1 = _saGh::P64;
      call stg_norec_readTVar#(R1) returns to cbGQ, args: 8, res: 8, upd: 8;
  cbGQ:
      _saGk::P64 = R1;
      I64[(young<cbGS> + 8)] = cbGS;
      R1 = _saGk::P64;
      if (R1 & 7 != 0) goto cbGS; else goto cbGV;
  cbGV:
      call (I64[R1])(R1) returns to cbGS, args: 8, res: 8, upd: 8;
  cbGS:
      _saGl::P64 = R1;
      _cbHw::P64 = _saGl::P64 & 7;
      switch [1 .. 2] _cbHw::P64 {
          case 1 : goto cbH4;
          case 2 : goto cbHc;
      }
  cbHc:
      _saGr::P64 = P64[_saGl::P64 + 6];
      _saGs::P64 = P64[_saGl::P64 + 14];
      _saGt::P64 = P64[_saGl::P64 + 22];
      I64[(young<cbHa> + 8)] = cbHa;
      R2 = _saFB::P64;
      I64[(young<cbHa> + 32)] = stg_ap_pp_info;
      P64[(young<cbHa> + 24)] = _saGr::P64;
      P64[(young<cbHa> + 16)] = _saFF::P64;
      call GHC.Classes.>_info(R2) returns to cbHa, args: 32, res: 8, upd: 8;
  cbHa:
      _saGu::P64 = R1;
      _cbHx::P64 = _saGu::P64 & 7;
      switch [1 .. 2] _cbHx::P64 {
          case 1 : goto cbHi;
          case 2 : goto cbHp;
      }
  cbHp:
      Hp = Hp + 96;
      if (Hp > HpLim) goto cbHs; else goto cbHr;
  cbHs:
      HpAlloc = 96;
      R1 = _saGu::P64;
      call stg_gc_unpt_r1(R1) returns to cbHa, args: 8, res: 8, upd: 8;
  cbHr:
      I64[Hp - 88] = GHC.Types.I#_con_info;
      I64[Hp - 80] = _saFQ::I64;
      _cbHl::P64 = Hp - 87;
      I64[Hp - 72] = GHC.Types.I#_con_info;
      I64[Hp - 64] = _saFP::I64;
      _cbHm::P64 = Hp - 71;
      I64[Hp - 56] = GHC.Arr.Array_con_info;
      P64[Hp - 48] = _cbHm::P64;
      P64[Hp - 40] = _cbHl::P64;
      P64[Hp - 32] = _saFS::P64;
      I64[Hp - 24] = _saFR::I64;
      _cbHn::P64 = Hp - 55;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _cbHn::P64;
      P64[Hp] = _saFU::P64;
      _cbHo::P64 = Hp - 14;
      _cbHy::I64 = _saFW::I64 - 1;
      _saGv::I64 = _cbHy::I64;
      R6 = _saGv::I64;
      R5 = _saFS::P64;
      R4 = _saFR::I64;
      R3 = _saFQ::I64;
      R2 = _saFP::I64;
      R1 = _saFN::P64;
      P64[(old + 16)] = _cbHo::P64;
      call $s$wa_saFN_info(R6,
                           R5,
                           R4,
                           R3,
                           R2,
                           R1) args: 16, res: 0, upd: 8;
  cbHi:
      R4 = _saFU::P64;
      R3 = _saFW::I64;
      R2 = _saGt::P64;
      R1 = _saFO::P64;
      call $wa8_saFO_info(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  cbH4:
      Hp = Hp + 96;
      if (Hp > HpLim) goto cbH7; else goto cbH6;
  cbH7:
      HpAlloc = 96;
      R1 = _saGl::P64;
      call stg_gc_unpt_r1(R1) returns to cbGS, args: 8, res: 8, upd: 8;
  cbH6:
      I64[Hp - 88] = GHC.Types.I#_con_info;
      I64[Hp - 80] = _saFQ::I64;
      _cbGZ::P64 = Hp - 87;
      I64[Hp - 72] = GHC.Types.I#_con_info;
      I64[Hp - 64] = _saFP::I64;
      _cbH0::P64 = Hp - 71;
      I64[Hp - 56] = GHC.Arr.Array_con_info;
      P64[Hp - 48] = _cbH0::P64;
      P64[Hp - 40] = _cbGZ::P64;
      P64[Hp - 32] = _saFS::P64;
      I64[Hp - 24] = _saFR::I64;
      _cbH1::P64 = Hp - 55;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _cbH1::P64;
      P64[Hp] = _saFU::P64;
      _cbH2::P64 = Hp - 14;
      _cbHz::I64 = _saFW::I64 - 1;
      _saGm::I64 = _cbHz::I64;
      R6 = _saGm::I64;
      R5 = _saFS::P64;
      R4 = _saFR::I64;
      R3 = _saFQ::I64;
      R2 = _saFP::I64;
      R1 = _saFN::P64;
      P64[(old + 16)] = _cbH2::P64;
      call $s$wa_saFN_info(R6,
                           R5,
                           R4,
                           R3,
                           R2,
                           R1) args: 16, res: 0, upd: 8;
  cbGH:
      Hp = Hp - 32;
      R3 = _saG7::I64;
      R2 = _saFR::I64;
      call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
  cbGp:
      I64[Hp - 24] = GHC.Types.I#_con_info;
      I64[Hp - 16] = _saFQ::I64;
      _cbGm::P64 = Hp - 23;
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _saFP::I64;
      _cbGn::P64 = Hp - 7;
      R4 = _cbGm::P64;
      R3 = _cbGn::P64;
      R2 = _saFW::I64;
      call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbGf:
      I64[Hp - 24] = GHC.Types.I#_con_info;
      I64[Hp - 16] = _saFQ::I64;
      _cbGc::P64 = Hp - 23;
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _saFP::I64;
      _cbGd::P64 = Hp - 7;
      R4 = _cbGc::P64;
      R3 = _cbGd::P64;
      R2 = _saFW::I64;
      call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:47.038922 UTC

{offset
  cbG1:
      _saFT::I64 = R6;
      _saFS::P64 = R5;
      _saFR::I64 = R4;
      _saFQ::I64 = R3;
      _saFP::I64 = R2;
      _saFN::P64 = R1;
      _saFU::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto cbG2; else goto cbG3;
  cbG3:
      Hp = Hp + 32;
      if (Hp > HpLim) goto cbG5; else goto cbG4;
  cbG5:
      HpAlloc = 32;
      goto cbG2;
  cbG2:
      R1 = _saFN::P64;
      I64[(old + 56)] = _saFP::I64;
      I64[(old + 48)] = _saFQ::I64;
      I64[(old + 40)] = _saFR::I64;
      P64[(old + 32)] = _saFS::P64;
      I64[(old + 24)] = _saFT::I64;
      P64[(old + 16)] = _saFU::P64;
      call (stg_gc_fun)(R1) args: 56, res: 0, upd: 8;
  cbG4:
      _saFB::P64 = P64[_saFN::P64 + 8];
      _saFF::P64 = P64[_saFN::P64 + 16];
      _saFO::P64 = P64[_saFN::P64 + 24];
      _saFW::I64 = _saFT::I64;
      if (_saFW::I64 != 0) goto cbFZ; else goto cbG0;
  cbFZ:
      _cbG7::I64 = %MO_S_Le_W64(_saFP::I64, _saFW::I64);
      _saFX::I64 = _cbG7::I64;
      if (_saFX::I64 != 0) goto cbHv; else goto cbGf;
  cbHv:
      _cbGh::I64 = %MO_S_Le_W64(_saFW::I64, _saFQ::I64);
      _saG2::I64 = _cbGh::I64;
      if (_saG2::I64 != 0) goto cbHu; else goto cbGp;
  cbHu:
      _cbGr::I64 = _saFW::I64 - _saFP::I64;
      _saG7::I64 = _cbGr::I64;
      _cbGu::I64 = %MO_S_Le_W64(0, _saG7::I64);
      _saG8::I64 = _cbGu::I64;
      if (_saG8::I64 != 0) goto cbHt; else goto cbGH;
  cbHt:
      _cbGC::I64 = %MO_S_Lt_W64(_saG7::I64, _saFR::I64);
      _saGb::I64 = _cbGC::I64;
      if (_saGb::I64 != 0) goto cbGL; else goto cbGH;
  cbGL:
      _saGf::P64 = P64[(_saFS::P64 + 24) + (_saG7::I64 << 3)];
      _saGf::P64 = _saGf::P64;
      Hp = Hp - 32;
      I64[(young<cbGK> + 8)] = cbGK;
      R1 = _saGf::P64;
      if (R1 & 7 != 0) goto cbGK; else goto cbGM;
  cbGM:
      call (I64[R1])(R1) returns to cbGK, args: 8, res: 8, upd: 8;
  cbGK:
      _saGg::P64 = R1;
      _saGh::P64 = P64[_saGg::P64 + 7];
      I64[(young<cbGQ> + 8)] = cbGQ;
      R1 = _saGh::P64;
      call stg_norec_readTVar#(R1) returns to cbGQ, args: 8, res: 8, upd: 8;
  cbGQ:
      _saGk::P64 = R1;
      I64[(young<cbGS> + 8)] = cbGS;
      R1 = _saGk::P64;
      if (R1 & 7 != 0) goto cbGS; else goto cbGV;
  cbGV:
      call (I64[R1])(R1) returns to cbGS, args: 8, res: 8, upd: 8;
  cbGS:
      _saGl::P64 = R1;
      _cbHw::P64 = _saGl::P64 & 7;
      if (_cbHw::P64 != 1) goto cbHc; else goto cbH4;
  cbHc:
      _saGr::P64 = P64[_saGl::P64 + 6];
      _saGs::P64 = P64[_saGl::P64 + 14];
      _saGt::P64 = P64[_saGl::P64 + 22];
      I64[(young<cbHa> + 8)] = cbHa;
      R2 = _saFB::P64;
      I64[(young<cbHa> + 32)] = stg_ap_pp_info;
      P64[(young<cbHa> + 24)] = _saGr::P64;
      P64[(young<cbHa> + 16)] = _saFF::P64;
      call GHC.Classes.>_info(R2) returns to cbHa, args: 32, res: 8, upd: 8;
  cbHa:
      _saGu::P64 = R1;
      _cbHx::P64 = _saGu::P64 & 7;
      if (_cbHx::P64 != 1) goto cbHp; else goto cbHi;
  cbHp:
      Hp = Hp + 96;
      if (Hp > HpLim) goto cbHs; else goto cbHr;
  cbHs:
      HpAlloc = 96;
      R1 = _saGu::P64;
      call stg_gc_unpt_r1(R1) returns to cbHa, args: 8, res: 8, upd: 8;
  cbHr:
      I64[Hp - 88] = GHC.Types.I#_con_info;
      I64[Hp - 80] = _saFQ::I64;
      _cbHl::P64 = Hp - 87;
      I64[Hp - 72] = GHC.Types.I#_con_info;
      I64[Hp - 64] = _saFP::I64;
      _cbHm::P64 = Hp - 71;
      I64[Hp - 56] = GHC.Arr.Array_con_info;
      P64[Hp - 48] = _cbHm::P64;
      P64[Hp - 40] = _cbHl::P64;
      P64[Hp - 32] = _saFS::P64;
      I64[Hp - 24] = _saFR::I64;
      _cbHn::P64 = Hp - 55;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _cbHn::P64;
      P64[Hp] = _saFU::P64;
      _cbHo::P64 = Hp - 14;
      _cbHy::I64 = _saFW::I64 - 1;
      _saGv::I64 = _cbHy::I64;
      R6 = _saGv::I64;
      R5 = _saFS::P64;
      R4 = _saFR::I64;
      R3 = _saFQ::I64;
      R2 = _saFP::I64;
      R1 = _saFN::P64;
      P64[(old + 16)] = _cbHo::P64;
      call $s$wa_saFN_info(R6,
                           R5,
                           R4,
                           R3,
                           R2,
                           R1) args: 16, res: 0, upd: 8;
  cbHi:
      R4 = _saFU::P64;
      R3 = _saFW::I64;
      R2 = _saGt::P64;
      R1 = _saFO::P64;
      call $wa8_saFO_info(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  cbH4:
      Hp = Hp + 96;
      if (Hp > HpLim) goto cbH7; else goto cbH6;
  cbH7:
      HpAlloc = 96;
      R1 = _saGl::P64;
      call stg_gc_unpt_r1(R1) returns to cbGS, args: 8, res: 8, upd: 8;
  cbH6:
      I64[Hp - 88] = GHC.Types.I#_con_info;
      I64[Hp - 80] = _saFQ::I64;
      _cbGZ::P64 = Hp - 87;
      I64[Hp - 72] = GHC.Types.I#_con_info;
      I64[Hp - 64] = _saFP::I64;
      _cbH0::P64 = Hp - 71;
      I64[Hp - 56] = GHC.Arr.Array_con_info;
      P64[Hp - 48] = _cbH0::P64;
      P64[Hp - 40] = _cbGZ::P64;
      P64[Hp - 32] = _saFS::P64;
      I64[Hp - 24] = _saFR::I64;
      _cbH1::P64 = Hp - 55;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _cbH1::P64;
      P64[Hp] = _saFU::P64;
      _cbH2::P64 = Hp - 14;
      _cbHz::I64 = _saFW::I64 - 1;
      _saGm::I64 = _cbHz::I64;
      R6 = _saGm::I64;
      R5 = _saFS::P64;
      R4 = _saFR::I64;
      R3 = _saFQ::I64;
      R2 = _saFP::I64;
      R1 = _saFN::P64;
      P64[(old + 16)] = _cbH2::P64;
      call $s$wa_saFN_info(R6,
                           R5,
                           R4,
                           R3,
                           R2,
                           R1) args: 16, res: 0, upd: 8;
  cbGH:
      Hp = Hp - 32;
      R3 = _saG7::I64;
      R2 = _saFR::I64;
      call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
  cbGp:
      I64[Hp - 24] = GHC.Types.I#_con_info;
      I64[Hp - 16] = _saFQ::I64;
      _cbGm::P64 = Hp - 23;
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _saFP::I64;
      _cbGn::P64 = Hp - 7;
      R4 = _cbGm::P64;
      R3 = _cbGn::P64;
      R2 = _saFW::I64;
      call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbGf:
      I64[Hp - 24] = GHC.Types.I#_con_info;
      I64[Hp - 16] = _saFQ::I64;
      _cbGc::P64 = Hp - 23;
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _saFP::I64;
      _cbGd::P64 = Hp - 7;
      R4 = _cbGc::P64;
      R3 = _cbGd::P64;
      R2 = _saFW::I64;
      call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbG0:
      Hp = Hp - 32;
      R1 = _saFU::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:47.049146 UTC

{offset
  cbG1:
      _saFT::I64 = R6;
      _saFS::P64 = R5;
      _saFR::I64 = R4;
      _saFQ::I64 = R3;
      _saFP::I64 = R2;
      _saFN::P64 = R1;
      _saFU::P64 = P64[Sp];
      if ((Sp + 16) - 112 < SpLim) goto cbG2; else goto cbG3;
  cbG3:
      Hp = Hp + 32;
      if (Hp > HpLim) goto cbG5; else goto cbG4;
  cbG5:
      HpAlloc = 32;
      goto cbG2;
  cbG2:
      R1 = _saFN::P64;
      I64[Sp - 40] = _saFP::I64;
      I64[Sp - 32] = _saFQ::I64;
      I64[Sp - 24] = _saFR::I64;
      P64[Sp - 16] = _saFS::P64;
      I64[Sp - 8] = _saFT::I64;
      Sp = Sp - 40;
      call (stg_gc_fun)(R1) args: 56, res: 0, upd: 8;
  cbG4:
      _saFB::P64 = P64[_saFN::P64 + 8];
      _saFF::P64 = P64[_saFN::P64 + 16];
      _saFO::P64 = P64[_saFN::P64 + 24];
      _saFW::I64 = _saFT::I64;
      if (_saFW::I64 != 0) goto cbFZ; else goto cbG0;
  cbFZ:
      _cbG7::I64 = %MO_S_Le_W64(_saFP::I64, _saFW::I64);
      _saFX::I64 = _cbG7::I64;
      if (_saFX::I64 != 0) goto cbHv; else goto cbGf;
  cbHv:
      _cbGh::I64 = %MO_S_Le_W64(_saFW::I64, _saFQ::I64);
      _saG2::I64 = _cbGh::I64;
      if (_saG2::I64 != 0) goto cbHu; else goto cbGp;
  cbHu:
      _cbGr::I64 = _saFW::I64 - _saFP::I64;
      _saG7::I64 = _cbGr::I64;
      _cbGu::I64 = %MO_S_Le_W64(0, _saG7::I64);
      _saG8::I64 = _cbGu::I64;
      if (_saG8::I64 != 0) goto cbHt; else goto cbGH;
  cbHt:
      _cbGC::I64 = %MO_S_Lt_W64(_saG7::I64, _saFR::I64);
      _saGb::I64 = _cbGC::I64;
      if (_saGb::I64 != 0) goto cbGL; else goto cbGH;
  cbGL:
      _saGf::P64 = P64[(_saFS::P64 + 24) + (_saG7::I64 << 3)];
      _saGf::P64 = _saGf::P64;
      Hp = Hp - 32;
      I64[Sp - 80] = cbGK;
      R1 = _saGf::P64;
      P64[Sp - 72] = _saFB::P64;
      P64[Sp - 64] = _saFF::P64;
      P64[Sp - 56] = _saFN::P64;
      P64[Sp - 48] = _saFO::P64;
      I64[Sp - 40] = _saFP::I64;
      I64[Sp - 32] = _saFQ::I64;
      I64[Sp - 24] = _saFR::I64;
      P64[Sp - 16] = _saFS::P64;
      I64[Sp - 8] = _saFW::I64;
      Sp = Sp - 80;
      if (R1 & 7 != 0) goto cbGK; else goto cbGM;
  cbGM:
      call (I64[R1])(R1) returns to cbGK, args: 8, res: 8, upd: 8;
  cbGK:
      _saFB::P64 = P64[Sp + 8];
      _saFF::P64 = P64[Sp + 16];
      _saFN::P64 = P64[Sp + 24];
      _saFO::P64 = P64[Sp + 32];
      _saFP::I64 = I64[Sp + 40];
      _saFQ::I64 = I64[Sp + 48];
      _saFR::I64 = I64[Sp + 56];
      _saFS::P64 = P64[Sp + 64];
      _saFU::P64 = P64[Sp + 80];
      _saFW::I64 = I64[Sp + 72];
      _saGg::P64 = R1;
      _saGh::P64 = P64[_saGg::P64 + 7];
      I64[Sp] = cbGQ;
      R1 = _saGh::P64;
      call stg_norec_readTVar#(R1) returns to cbGQ, args: 8, res: 8, upd: 8;
  cbGQ:
      _saFB::P64 = P64[Sp + 8];
      _saFF::P64 = P64[Sp + 16];
      _saFN::P64 = P64[Sp + 24];
      _saFO::P64 = P64[Sp + 32];
      _saFP::I64 = I64[Sp + 40];
      _saFQ::I64 = I64[Sp + 48];
      _saFR::I64 = I64[Sp + 56];
      _saFS::P64 = P64[Sp + 64];
      _saFU::P64 = P64[Sp + 80];
      _saFW::I64 = I64[Sp + 72];
      _saGk::P64 = R1;
      I64[Sp] = cbGS;
      R1 = _saGk::P64;
      if (R1 & 7 != 0) goto cbGS; else goto cbGV;
  cbGV:
      call (I64[R1])(R1) returns to cbGS, args: 8, res: 8, upd: 8;
  cbGS:
      _saFB::P64 = P64[Sp + 8];
      _saFF::P64 = P64[Sp + 16];
      _saFN::P64 = P64[Sp + 24];
      _saFO::P64 = P64[Sp + 32];
      _saFP::I64 = I64[Sp + 40];
      _saFQ::I64 = I64[Sp + 48];
      _saFR::I64 = I64[Sp + 56];
      _saFS::P64 = P64[Sp + 64];
      _saFU::P64 = P64[Sp + 80];
      _saFW::I64 = I64[Sp + 72];
      _saGl::P64 = R1;
      _cbHw::P64 = _saGl::P64 & 7;
      if (_cbHw::P64 != 1) goto cbHc; else goto cbH4;
  cbHc:
      _saGr::P64 = P64[_saGl::P64 + 6];
      _saGs::P64 = P64[_saGl::P64 + 14];
      _saGt::P64 = P64[_saGl::P64 + 22];
      I64[Sp + 8] = cbHa;
      R2 = _saFB::P64;
      I64[Sp - 16] = stg_ap_pp_info;
      P64[Sp - 8] = _saGr::P64;
      P64[Sp] = _saFF::P64;
      P64[Sp + 16] = _saGt::P64;
      Sp = Sp - 16;
      call GHC.Classes.>_info(R2) returns to cbHa, args: 32, res: 8, upd: 8;
  cbHa:
      _saFN::P64 = P64[Sp + 16];
      _saFO::P64 = P64[Sp + 24];
      _saFP::I64 = I64[Sp + 32];
      _saFQ::I64 = I64[Sp + 40];
      _saFR::I64 = I64[Sp + 48];
      _saFS::P64 = P64[Sp + 56];
      _saFU::P64 = P64[Sp + 72];
      _saFW::I64 = I64[Sp + 64];
      _saGt::P64 = P64[Sp + 8];
      _saGu::P64 = R1;
      _cbHx::P64 = _saGu::P64 & 7;
      if (_cbHx::P64 != 1) goto cbHp; else goto cbHi;
  cbHp:
      Hp = Hp + 96;
      if (Hp > HpLim) goto cbHs; else goto cbHr;
  cbHs:
      HpAlloc = 96;
      R1 = _saGu::P64;
      call stg_gc_unpt_r1(R1) returns to cbHa, args: 8, res: 8, upd: 8;
  cbHr:
      I64[Hp - 88] = GHC.Types.I#_con_info;
      I64[Hp - 80] = _saFQ::I64;
      _cbHl::P64 = Hp - 87;
      I64[Hp - 72] = GHC.Types.I#_con_info;
      I64[Hp - 64] = _saFP::I64;
      _cbHm::P64 = Hp - 71;
      I64[Hp - 56] = GHC.Arr.Array_con_info;
      P64[Hp - 48] = _cbHm::P64;
      P64[Hp - 40] = _cbHl::P64;
      P64[Hp - 32] = _saFS::P64;
      I64[Hp - 24] = _saFR::I64;
      _cbHn::P64 = Hp - 55;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _cbHn::P64;
      P64[Hp] = _saFU::P64;
      _cbHo::P64 = Hp - 14;
      _cbHy::I64 = _saFW::I64 - 1;
      _saGv::I64 = _cbHy::I64;
      R6 = _saGv::I64;
      R5 = _saFS::P64;
      R4 = _saFR::I64;
      R3 = _saFQ::I64;
      R2 = _saFP::I64;
      R1 = _saFN::P64;
      P64[Sp + 72] = _cbHo::P64;
      Sp = Sp + 72;
      call $s$wa_saFN_info(R6,
                           R5,
                           R4,
                           R3,
                           R2,
                           R1) args: 16, res: 0, upd: 8;
  cbHi:
      R4 = _saFU::P64;
      R3 = _saFW::I64;
      R2 = _saGt::P64;
      R1 = _saFO::P64;
      Sp = Sp + 80;
      call $wa8_saFO_info(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  cbH4:
      Hp = Hp + 96;
      if (Hp > HpLim) goto cbH7; else goto cbH6;
  cbH7:
      HpAlloc = 96;
      R1 = _saGl::P64;
      call stg_gc_unpt_r1(R1) returns to cbGS, args: 8, res: 8, upd: 8;
  cbH6:
      I64[Hp - 88] = GHC.Types.I#_con_info;
      I64[Hp - 80] = _saFQ::I64;
      _cbGZ::P64 = Hp - 87;
      I64[Hp - 72] = GHC.Types.I#_con_info;
      I64[Hp - 64] = _saFP::I64;
      _cbH0::P64 = Hp - 71;
      I64[Hp - 56] = GHC.Arr.Array_con_info;
      P64[Hp - 48] = _cbH0::P64;
      P64[Hp - 40] = _cbGZ::P64;
      P64[Hp - 32] = _saFS::P64;
      I64[Hp - 24] = _saFR::I64;
      _cbH1::P64 = Hp - 55;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _cbH1::P64;
      P64[Hp] = _saFU::P64;
      _cbH2::P64 = Hp - 14;
      _cbHz::I64 = _saFW::I64 - 1;
      _saGm::I64 = _cbHz::I64;
      R6 = _saGm::I64;
      R5 = _saFS::P64;
      R4 = _saFR::I64;
      R3 = _saFQ::I64;
      R2 = _saFP::I64;
      R1 = _saFN::P64;
      P64[Sp + 80] = _cbH2::P64;
      Sp = Sp + 80;
      call $s$wa_saFN_info(R6,
                           R5,
                           R4,
                           R3,
                           R2,
                           R1) args: 16, res: 0, upd: 8;
  cbGH:
      Hp = Hp - 32;
      R3 = _saG7::I64;
      R2 = _saFR::I64;
      Sp = Sp + 8;
      call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
  cbGp:
      I64[Hp - 24] = GHC.Types.I#_con_info;
      I64[Hp - 16] = _saFQ::I64;
      _cbGm::P64 = Hp - 23;
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _saFP::I64;
      _cbGn::P64 = Hp - 7;
      R4 = _cbGm::P64;
      R3 = _cbGn::P64;
      R2 = _saFW::I64;
      Sp = Sp + 8;
      call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbGf:
      I64[Hp - 24] = GHC.Types.I#_con_info;
      I64[Hp - 16] = _saFQ::I64;
      _cbGc::P64 = Hp - 23;
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _saFP::I64;
      _cbGd::P64 = Hp - 7;
      R4 = _cbGc::P64;
      R3 = _cbGd::P64;
      R2 = _saFW::I64;
      Sp = Sp + 8;
      call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbG0:
      Hp = Hp - 32;
      R1 = _saFU::P64;
      Sp = Sp + 8;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:47.061546 UTC

{offset
  cbG1:
      _saFT::I64 = R6;
      _saFS::P64 = R5;
      _saFR::I64 = R4;
      _saFQ::I64 = R3;
      _saFP::I64 = R2;
      _saFN::P64 = R1;
      if ((Sp + -96) < SpLim) goto cbG2; else goto cbG3;
  cbG3:
      Hp = Hp + 32;
      if (Hp > HpLim) goto cbG5; else goto cbG4;
  cbG5:
      HpAlloc = 32;
      goto cbG2;
  cbG2:
      R1 = _saFN::P64;
      I64[Sp - 40] = _saFP::I64;
      I64[Sp - 32] = _saFQ::I64;
      I64[Sp - 24] = _saFR::I64;
      P64[Sp - 16] = _saFS::P64;
      I64[Sp - 8] = _saFT::I64;
      Sp = Sp - 40;
      call (stg_gc_fun)(R1) args: 56, res: 0, upd: 8;
  cbG4:
      if (_saFT::I64 != 0) goto cbFZ; else goto cbG0;
  cbFZ:
      if (%MO_S_Le_W64(_saFP::I64,
                       _saFT::I64)) goto cbHv; else goto cbGf;
  cbHv:
      if (%MO_S_Le_W64(_saFT::I64,
                       _saFQ::I64)) goto cbHu; else goto cbGp;
  cbHu:
      _saG7::I64 = _saFT::I64 - _saFP::I64;
      if (%MO_S_Le_W64(0, _saG7::I64)) goto cbHt; else goto cbGH;
  cbHt:
      if (%MO_S_Lt_W64(_saG7::I64,
                       _saFR::I64)) goto cbGL; else goto cbGH;
  cbGL:
      _saFB::P64 = P64[_saFN::P64 + 8];
      _saFF::P64 = P64[_saFN::P64 + 16];
      _saFO::P64 = P64[_saFN::P64 + 24];
      Hp = Hp - 32;
      _saGf::P64 = P64[(_saFS::P64 + 24) + (_saG7::I64 << 3)];
      I64[Sp - 80] = cbGK;
      R1 = _saGf::P64;
      P64[Sp - 72] = _saFB::P64;
      P64[Sp - 64] = _saFF::P64;
      P64[Sp - 56] = _saFN::P64;
      P64[Sp - 48] = _saFO::P64;
      I64[Sp - 40] = _saFP::I64;
      I64[Sp - 32] = _saFQ::I64;
      I64[Sp - 24] = _saFR::I64;
      P64[Sp - 16] = _saFS::P64;
      I64[Sp - 8] = _saFT::I64;
      Sp = Sp - 80;
      if (R1 & 7 != 0) goto cbGK; else goto cbGM;
  cbGM:
      call (I64[R1])(R1) returns to cbGK, args: 8, res: 8, upd: 8;
  cbGK:
      I64[Sp] = cbGQ;
      R1 = P64[R1 + 7];
      call stg_norec_readTVar#(R1) returns to cbGQ, args: 8, res: 8, upd: 8;
  cbGQ:
      I64[Sp] = cbGS;
      R1 = R1;
      if (R1 & 7 != 0) goto cbGS; else goto cbGV;
  cbGV:
      call (I64[R1])(R1) returns to cbGS, args: 8, res: 8, upd: 8;
  cbGS:
      if (R1 & 7 != 1) goto cbHc; else goto cbH4;
  cbHc:
      _saFB::P64 = P64[Sp + 8];
      I64[Sp + 8] = cbHa;
      R2 = _saFB::P64;
      I64[Sp - 16] = stg_ap_pp_info;
      P64[Sp - 8] = P64[R1 + 6];
      P64[Sp] = P64[Sp + 16];
      P64[Sp + 16] = P64[R1 + 22];
      Sp = Sp - 16;
      call GHC.Classes.>_info(R2) returns to cbHa, args: 32, res: 8, upd: 8;
  cbHa:
      _saFU::P64 = P64[Sp + 72];
      _saFW::I64 = I64[Sp + 64];
      if (R1 & 7 != 1) goto cbHp; else goto cbHi;
  cbHp:
      Hp = Hp + 96;
      if (Hp > HpLim) goto cbHs; else goto cbHr;
  cbHs:
      HpAlloc = 96;
      R1 = R1;
      call stg_gc_unpt_r1(R1) returns to cbHa, args: 8, res: 8, upd: 8;
  cbHr:
      I64[Hp - 88] = GHC.Types.I#_con_info;
      _saFQ::I64 = I64[Sp + 40];
      I64[Hp - 80] = _saFQ::I64;
      I64[Hp - 72] = GHC.Types.I#_con_info;
      _saFP::I64 = I64[Sp + 32];
      I64[Hp - 64] = _saFP::I64;
      I64[Hp - 56] = GHC.Arr.Array_con_info;
      P64[Hp - 48] = Hp - 71;
      P64[Hp - 40] = Hp - 87;
      _saFS::P64 = P64[Sp + 56];
      P64[Hp - 32] = _saFS::P64;
      _saFR::I64 = I64[Sp + 48];
      I64[Hp - 24] = _saFR::I64;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = Hp - 55;
      P64[Hp] = _saFU::P64;
      R6 = _saFW::I64 - 1;
      R5 = _saFS::P64;
      R4 = _saFR::I64;
      R3 = _saFQ::I64;
      R2 = _saFP::I64;
      R1 = P64[Sp + 16];
      P64[Sp + 72] = Hp - 14;
      Sp = Sp + 72;
      call $s$wa_saFN_info(R6,
                           R5,
                           R4,
                           R3,
                           R2,
                           R1) args: 16, res: 0, upd: 8;
  cbHi:
      R4 = _saFU::P64;
      R3 = _saFW::I64;
      R2 = P64[Sp + 8];
      R1 = P64[Sp + 24];
      Sp = Sp + 80;
      call $wa8_saFO_info(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  cbH4:
      Hp = Hp + 96;
      if (Hp > HpLim) goto cbH7; else goto cbH6;
  cbH7:
      HpAlloc = 96;
      R1 = R1;
      call stg_gc_unpt_r1(R1) returns to cbGS, args: 8, res: 8, upd: 8;
  cbH6:
      I64[Hp - 88] = GHC.Types.I#_con_info;
      _saFQ::I64 = I64[Sp + 48];
      I64[Hp - 80] = _saFQ::I64;
      I64[Hp - 72] = GHC.Types.I#_con_info;
      _saFP::I64 = I64[Sp + 40];
      I64[Hp - 64] = _saFP::I64;
      I64[Hp - 56] = GHC.Arr.Array_con_info;
      P64[Hp - 48] = Hp - 71;
      P64[Hp - 40] = Hp - 87;
      _saFS::P64 = P64[Sp + 64];
      P64[Hp - 32] = _saFS::P64;
      _saFR::I64 = I64[Sp + 56];
      I64[Hp - 24] = _saFR::I64;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = Hp - 55;
      P64[Hp] = P64[Sp + 80];
      R6 = I64[Sp + 72] - 1;
      R5 = _saFS::P64;
      R4 = _saFR::I64;
      R3 = _saFQ::I64;
      R2 = _saFP::I64;
      R1 = P64[Sp + 24];
      P64[Sp + 80] = Hp - 14;
      Sp = Sp + 80;
      call $s$wa_saFN_info(R6,
                           R5,
                           R4,
                           R3,
                           R2,
                           R1) args: 16, res: 0, upd: 8;
  cbGH:
      Hp = Hp - 32;
      R3 = _saG7::I64;
      R2 = _saFR::I64;
      Sp = Sp + 8;
      call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
  cbGp:
      I64[Hp - 24] = GHC.Types.I#_con_info;
      I64[Hp - 16] = _saFQ::I64;
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _saFP::I64;
      R4 = Hp - 23;
      R3 = Hp - 7;
      R2 = _saFT::I64;
      Sp = Sp + 8;
      call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbGf:
      I64[Hp - 24] = GHC.Types.I#_con_info;
      I64[Hp - 16] = _saFQ::I64;
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _saFP::I64;
      R4 = Hp - 23;
      R3 = Hp - 7;
      R2 = _saFT::I64;
      Sp = Sp + 8;
      call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbG0:
      Hp = Hp - 32;
      R1 = P64[Sp];
      Sp = Sp + 8;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:47.074127 UTC

[(cbFZ,
  {lvl20_rawe_closure, lvl29_rawn_closure, $s$wa_saFN_closure,
   $wa8_saFO_closure}),
 (cbG0, {}),
 (cbG1,
  {lvl20_rawe_closure, lvl29_rawn_closure, $s$wa_saFN_closure,
   $wa8_saFO_closure}),
 (cbG2, {}),
 (cbG3,
  {lvl20_rawe_closure, lvl29_rawn_closure, $s$wa_saFN_closure,
   $wa8_saFO_closure}),
 (cbG4,
  {lvl20_rawe_closure, lvl29_rawn_closure, $s$wa_saFN_closure,
   $wa8_saFO_closure}),
 (cbG5, {}), (cbGf, {lvl20_rawe_closure}),
 (cbGp, {lvl20_rawe_closure}), (cbGH, {lvl29_rawn_closure}),
 (cbGK, {$s$wa_saFN_closure, $wa8_saFO_closure}),
 (cbGL, {$s$wa_saFN_closure, $wa8_saFO_closure}),
 (cbGM, {$s$wa_saFN_closure, $wa8_saFO_closure}),
 (cbGQ, {$s$wa_saFN_closure, $wa8_saFO_closure}),
 (cbGS, {$s$wa_saFN_closure, $wa8_saFO_closure}),
 (cbGV, {$s$wa_saFN_closure, $wa8_saFO_closure}),
 (cbH4, {$s$wa_saFN_closure, $wa8_saFO_closure}),
 (cbH6, {$s$wa_saFN_closure}),
 (cbH7, {$s$wa_saFN_closure, $wa8_saFO_closure}),
 (cbHa, {$s$wa_saFN_closure, $wa8_saFO_closure}),
 (cbHc, {$s$wa_saFN_closure, $wa8_saFO_closure}),
 (cbHi, {$wa8_saFO_closure}),
 (cbHp, {$s$wa_saFN_closure, $wa8_saFO_closure}),
 (cbHr, {$s$wa_saFN_closure}),
 (cbHs, {$s$wa_saFN_closure, $wa8_saFO_closure}),
 (cbHt,
  {lvl29_rawn_closure, $s$wa_saFN_closure, $wa8_saFO_closure}),
 (cbHu,
  {lvl29_rawn_closure, $s$wa_saFN_closure, $wa8_saFO_closure}),
 (cbHv,
  {lvl20_rawe_closure, lvl29_rawn_closure, $s$wa_saFN_closure,
   $wa8_saFO_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:47.076878 UTC

$s$wa_saFN_entry() //  [R6, R5, R4, R3, R2, R1]
        { info_tbl: [(cbG1,
                      label: $s$wa_saFN_info
                      rep:HeapRep 3 ptrs {
                            Fun {arity: 8
                                 fun_type: ArgGen [True, True, True, False, True, False]} }),
                     (cbGK,
                      label: block_cbGK_info
                      rep:StackRep [False, False, False, False, True, True, True, False,
                                    True, False]),
                     (cbGQ,
                      label: block_cbGQ_info
                      rep:StackRep [False, False, False, False, True, True, True, False,
                                    True, False]),
                     (cbGS,
                      label: block_cbGS_info
                      rep:StackRep [False, False, False, False, True, True, True, False,
                                    True, False]),
                     (cbHa,
                      label: block_cbHa_info
                      rep:StackRep [False, False, False, True, True, True, False, True,
                                    False])]
          stack_info: arg_space: 16 updfr_space: Just 8
        }
    {offset
      cbG1:
          _saFT::I64 = R6;
          _saFS::P64 = R5;
          _saFR::I64 = R4;
          _saFQ::I64 = R3;
          _saFP::I64 = R2;
          _saFN::P64 = R1;
          if ((Sp + -96) < SpLim) goto cbG2; else goto cbG3;
      cbG3:
          Hp = Hp + 32;
          if (Hp > HpLim) goto cbG5; else goto cbG4;
      cbG5:
          HpAlloc = 32;
          goto cbG2;
      cbG2:
          R1 = _saFN::P64;
          I64[Sp - 40] = _saFP::I64;
          I64[Sp - 32] = _saFQ::I64;
          I64[Sp - 24] = _saFR::I64;
          P64[Sp - 16] = _saFS::P64;
          I64[Sp - 8] = _saFT::I64;
          Sp = Sp - 40;
          call (stg_gc_fun)(R1) args: 56, res: 0, upd: 8;
      cbG4:
          if (_saFT::I64 != 0) goto cbFZ; else goto cbG0;
      cbFZ:
          if (%MO_S_Le_W64(_saFP::I64,
                           _saFT::I64)) goto cbHv; else goto cbGf;
      cbHv:
          if (%MO_S_Le_W64(_saFT::I64,
                           _saFQ::I64)) goto cbHu; else goto cbGp;
      cbHu:
          _saG7::I64 = _saFT::I64 - _saFP::I64;
          if (%MO_S_Le_W64(0, _saG7::I64)) goto cbHt; else goto cbGH;
      cbHt:
          if (%MO_S_Lt_W64(_saG7::I64,
                           _saFR::I64)) goto cbGL; else goto cbGH;
      cbGL:
          _saFB::P64 = P64[_saFN::P64 + 8];
          _saFF::P64 = P64[_saFN::P64 + 16];
          _saFO::P64 = P64[_saFN::P64 + 24];
          Hp = Hp - 32;
          _saGf::P64 = P64[(_saFS::P64 + 24) + (_saG7::I64 << 3)];
          I64[Sp - 80] = cbGK;
          R1 = _saGf::P64;
          P64[Sp - 72] = _saFB::P64;
          P64[Sp - 64] = _saFF::P64;
          P64[Sp - 56] = _saFN::P64;
          P64[Sp - 48] = _saFO::P64;
          I64[Sp - 40] = _saFP::I64;
          I64[Sp - 32] = _saFQ::I64;
          I64[Sp - 24] = _saFR::I64;
          P64[Sp - 16] = _saFS::P64;
          I64[Sp - 8] = _saFT::I64;
          Sp = Sp - 80;
          if (R1 & 7 != 0) goto cbGK; else goto cbGM;
      cbGM:
          call (I64[R1])(R1) returns to cbGK, args: 8, res: 8, upd: 8;
      cbGK:
          I64[Sp] = cbGQ;
          R1 = P64[R1 + 7];
          call stg_norec_readTVar#(R1) returns to cbGQ, args: 8, res: 8, upd: 8;
      cbGQ:
          I64[Sp] = cbGS;
          R1 = R1;
          if (R1 & 7 != 0) goto cbGS; else goto cbGV;
      cbGV:
          call (I64[R1])(R1) returns to cbGS, args: 8, res: 8, upd: 8;
      cbGS:
          if (R1 & 7 != 1) goto cbHc; else goto cbH4;
      cbHc:
          _saFB::P64 = P64[Sp + 8];
          I64[Sp + 8] = cbHa;
          R2 = _saFB::P64;
          I64[Sp - 16] = stg_ap_pp_info;
          P64[Sp - 8] = P64[R1 + 6];
          P64[Sp] = P64[Sp + 16];
          P64[Sp + 16] = P64[R1 + 22];
          Sp = Sp - 16;
          call GHC.Classes.>_info(R2) returns to cbHa, args: 32, res: 8, upd: 8;
      cbHa:
          _saFU::P64 = P64[Sp + 72];
          _saFW::I64 = I64[Sp + 64];
          if (R1 & 7 != 1) goto cbHp; else goto cbHi;
      cbHp:
          Hp = Hp + 96;
          if (Hp > HpLim) goto cbHs; else goto cbHr;
      cbHs:
          HpAlloc = 96;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to cbHa, args: 8, res: 8, upd: 8;
      cbHr:
          I64[Hp - 88] = GHC.Types.I#_con_info;
          _saFQ::I64 = I64[Sp + 40];
          I64[Hp - 80] = _saFQ::I64;
          I64[Hp - 72] = GHC.Types.I#_con_info;
          _saFP::I64 = I64[Sp + 32];
          I64[Hp - 64] = _saFP::I64;
          I64[Hp - 56] = GHC.Arr.Array_con_info;
          P64[Hp - 48] = Hp - 71;
          P64[Hp - 40] = Hp - 87;
          _saFS::P64 = P64[Sp + 56];
          P64[Hp - 32] = _saFS::P64;
          _saFR::I64 = I64[Sp + 48];
          I64[Hp - 24] = _saFR::I64;
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = Hp - 55;
          P64[Hp] = _saFU::P64;
          R6 = _saFW::I64 - 1;
          R5 = _saFS::P64;
          R4 = _saFR::I64;
          R3 = _saFQ::I64;
          R2 = _saFP::I64;
          R1 = P64[Sp + 16];
          P64[Sp + 72] = Hp - 14;
          Sp = Sp + 72;
          call $s$wa_saFN_info(R6,
                               R5,
                               R4,
                               R3,
                               R2,
                               R1) args: 16, res: 0, upd: 8;
      cbHi:
          R4 = _saFU::P64;
          R3 = _saFW::I64;
          R2 = P64[Sp + 8];
          R1 = P64[Sp + 24];
          Sp = Sp + 80;
          call $wa8_saFO_info(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
      cbH4:
          Hp = Hp + 96;
          if (Hp > HpLim) goto cbH7; else goto cbH6;
      cbH7:
          HpAlloc = 96;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to cbGS, args: 8, res: 8, upd: 8;
      cbH6:
          I64[Hp - 88] = GHC.Types.I#_con_info;
          _saFQ::I64 = I64[Sp + 48];
          I64[Hp - 80] = _saFQ::I64;
          I64[Hp - 72] = GHC.Types.I#_con_info;
          _saFP::I64 = I64[Sp + 40];
          I64[Hp - 64] = _saFP::I64;
          I64[Hp - 56] = GHC.Arr.Array_con_info;
          P64[Hp - 48] = Hp - 71;
          P64[Hp - 40] = Hp - 87;
          _saFS::P64 = P64[Sp + 64];
          P64[Hp - 32] = _saFS::P64;
          _saFR::I64 = I64[Sp + 56];
          I64[Hp - 24] = _saFR::I64;
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = Hp - 55;
          P64[Hp] = P64[Sp + 80];
          R6 = I64[Sp + 72] - 1;
          R5 = _saFS::P64;
          R4 = _saFR::I64;
          R3 = _saFQ::I64;
          R2 = _saFP::I64;
          R1 = P64[Sp + 24];
          P64[Sp + 80] = Hp - 14;
          Sp = Sp + 80;
          call $s$wa_saFN_info(R6,
                               R5,
                               R4,
                               R3,
                               R2,
                               R1) args: 16, res: 0, upd: 8;
      cbGH:
          Hp = Hp - 32;
          R3 = _saG7::I64;
          R2 = _saFR::I64;
          Sp = Sp + 8;
          call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
      cbGp:
          I64[Hp - 24] = GHC.Types.I#_con_info;
          I64[Hp - 16] = _saFQ::I64;
          I64[Hp - 8] = GHC.Types.I#_con_info;
          I64[Hp] = _saFP::I64;
          R4 = Hp - 23;
          R3 = Hp - 7;
          R2 = _saFT::I64;
          Sp = Sp + 8;
          call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
      cbGf:
          I64[Hp - 24] = GHC.Types.I#_con_info;
          I64[Hp - 16] = _saFQ::I64;
          I64[Hp - 8] = GHC.Types.I#_con_info;
          I64[Hp] = _saFP::I64;
          R4 = Hp - 23;
          R3 = Hp - 7;
          R2 = _saFT::I64;
          Sp = Sp + 8;
          call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
      cbG0:
          Hp = Hp - 32;
          R1 = P64[Sp];
          Sp = Sp + 8;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:47.087507 UTC

$s$wa_saFN_entry() //  [R6, R5, R4, R3, R2, R1]
        { info_tbl: [(cbG1,
                      label: $s$wa_saFN_info
                      rep:HeapRep 3 ptrs {
                            Fun {arity: 8
                                 fun_type: ArgGen [True, True, True, False, True, False]} }),
                     (cbGK,
                      label: block_cbGK_info
                      rep:StackRep [False, False, False, False, True, True, True, False,
                                    True, False]),
                     (cbGQ,
                      label: block_cbGQ_info
                      rep:StackRep [False, False, False, False, True, True, True, False,
                                    True, False]),
                     (cbGS,
                      label: block_cbGS_info
                      rep:StackRep [False, False, False, False, True, True, True, False,
                                    True, False]),
                     (cbHa,
                      label: block_cbHa_info
                      rep:StackRep [False, False, False, True, True, True, False, True,
                                    False])]
          stack_info: arg_space: 16 updfr_space: Just 8
        }
    {offset
      cbG1:
          _saFT::I64 = R6;
          _saFS::P64 = R5;
          _saFR::I64 = R4;
          _saFQ::I64 = R3;
          _saFP::I64 = R2;
          _saFN::P64 = R1;
          if ((Sp + -96) < SpLim) goto cbG2; else goto cbG3;
      cbG3:
          Hp = Hp + 32;
          if (Hp > HpLim) goto cbG5; else goto cbG4;
      cbG5:
          HpAlloc = 32;
          goto cbG2;
      cbG2:
          R1 = _saFN::P64;
          I64[Sp - 40] = _saFP::I64;
          I64[Sp - 32] = _saFQ::I64;
          I64[Sp - 24] = _saFR::I64;
          P64[Sp - 16] = _saFS::P64;
          I64[Sp - 8] = _saFT::I64;
          Sp = Sp - 40;
          call (stg_gc_fun)(R1) args: 56, res: 0, upd: 8;
      cbG4:
          if (_saFT::I64 != 0) goto cbFZ; else goto cbG0;
      cbFZ:
          if (%MO_S_Le_W64(_saFP::I64,
                           _saFT::I64)) goto cbHv; else goto cbGf;
      cbHv:
          if (%MO_S_Le_W64(_saFT::I64,
                           _saFQ::I64)) goto cbHu; else goto cbGp;
      cbHu:
          _saG7::I64 = _saFT::I64 - _saFP::I64;
          if (%MO_S_Gt_W64(0, _saG7::I64)) goto cbGH; else goto cbHt;
      cbHt:
          if (%MO_S_Ge_W64(_saG7::I64,
                           _saFR::I64)) goto cbGH; else goto cbGL;
      cbGH:
          Hp = Hp - 32;
          R3 = _saG7::I64;
          R2 = _saFR::I64;
          Sp = Sp + 8;
          call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
      cbGL:
          _saFB::P64 = P64[_saFN::P64 + 8];
          _saFF::P64 = P64[_saFN::P64 + 16];
          _saFO::P64 = P64[_saFN::P64 + 24];
          Hp = Hp - 32;
          _saGf::P64 = P64[(_saFS::P64 + 24) + (_saG7::I64 << 3)];
          I64[Sp - 80] = cbGK;
          R1 = _saGf::P64;
          P64[Sp - 72] = _saFB::P64;
          P64[Sp - 64] = _saFF::P64;
          P64[Sp - 56] = _saFN::P64;
          P64[Sp - 48] = _saFO::P64;
          I64[Sp - 40] = _saFP::I64;
          I64[Sp - 32] = _saFQ::I64;
          I64[Sp - 24] = _saFR::I64;
          P64[Sp - 16] = _saFS::P64;
          I64[Sp - 8] = _saFT::I64;
          Sp = Sp - 80;
          if (R1 & 7 != 0) goto cbGK; else goto cbGM;
      cbGM:
          call (I64[R1])(R1) returns to cbGK, args: 8, res: 8, upd: 8;
      cbGK:
          I64[Sp] = cbGQ;
          R1 = P64[R1 + 7];
          call stg_norec_readTVar#(R1) returns to cbGQ, args: 8, res: 8, upd: 8;
      cbGQ:
          I64[Sp] = cbGS;
          R1 = R1;
          if (R1 & 7 != 0) goto cbGS; else goto cbGV;
      cbGV:
          call (I64[R1])(R1) returns to cbGS, args: 8, res: 8, upd: 8;
      cbGS:
          if (R1 & 7 != 1) goto cbHc; else goto cbH4;
      cbHc:
          _saFB::P64 = P64[Sp + 8];
          I64[Sp + 8] = cbHa;
          R2 = _saFB::P64;
          I64[Sp - 16] = stg_ap_pp_info;
          P64[Sp - 8] = P64[R1 + 6];
          P64[Sp] = P64[Sp + 16];
          P64[Sp + 16] = P64[R1 + 22];
          Sp = Sp - 16;
          call GHC.Classes.>_info(R2) returns to cbHa, args: 32, res: 8, upd: 8;
      cbHa:
          _saFU::P64 = P64[Sp + 72];
          _saFW::I64 = I64[Sp + 64];
          if (R1 & 7 != 1) goto cbHp; else goto cbHi;
      cbHp:
          Hp = Hp + 96;
          if (Hp > HpLim) goto cbHs; else goto cbHr;
      cbHs:
          HpAlloc = 96;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to cbHa, args: 8, res: 8, upd: 8;
      cbHr:
          I64[Hp - 88] = GHC.Types.I#_con_info;
          _saFQ::I64 = I64[Sp + 40];
          I64[Hp - 80] = _saFQ::I64;
          I64[Hp - 72] = GHC.Types.I#_con_info;
          _saFP::I64 = I64[Sp + 32];
          I64[Hp - 64] = _saFP::I64;
          I64[Hp - 56] = GHC.Arr.Array_con_info;
          P64[Hp - 48] = Hp - 71;
          P64[Hp - 40] = Hp - 87;
          _saFS::P64 = P64[Sp + 56];
          P64[Hp - 32] = _saFS::P64;
          _saFR::I64 = I64[Sp + 48];
          I64[Hp - 24] = _saFR::I64;
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = Hp - 55;
          P64[Hp] = _saFU::P64;
          R6 = _saFW::I64 - 1;
          R5 = _saFS::P64;
          R4 = _saFR::I64;
          R3 = _saFQ::I64;
          R2 = _saFP::I64;
          R1 = P64[Sp + 16];
          P64[Sp + 72] = Hp - 14;
          Sp = Sp + 72;
          call $s$wa_saFN_info(R6,
                               R5,
                               R4,
                               R3,
                               R2,
                               R1) args: 16, res: 0, upd: 8;
      cbHi:
          R4 = _saFU::P64;
          R3 = _saFW::I64;
          R2 = P64[Sp + 8];
          R1 = P64[Sp + 24];
          Sp = Sp + 80;
          call $wa8_saFO_info(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
      cbH4:
          Hp = Hp + 96;
          if (Hp > HpLim) goto cbH7; else goto cbH6;
      cbH7:
          HpAlloc = 96;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to cbGS, args: 8, res: 8, upd: 8;
      cbH6:
          I64[Hp - 88] = GHC.Types.I#_con_info;
          _saFQ::I64 = I64[Sp + 48];
          I64[Hp - 80] = _saFQ::I64;
          I64[Hp - 72] = GHC.Types.I#_con_info;
          _saFP::I64 = I64[Sp + 40];
          I64[Hp - 64] = _saFP::I64;
          I64[Hp - 56] = GHC.Arr.Array_con_info;
          P64[Hp - 48] = Hp - 71;
          P64[Hp - 40] = Hp - 87;
          _saFS::P64 = P64[Sp + 64];
          P64[Hp - 32] = _saFS::P64;
          _saFR::I64 = I64[Sp + 56];
          I64[Hp - 24] = _saFR::I64;
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = Hp - 55;
          P64[Hp] = P64[Sp + 80];
          R6 = I64[Sp + 72] - 1;
          R5 = _saFS::P64;
          R4 = _saFR::I64;
          R3 = _saFQ::I64;
          R2 = _saFP::I64;
          R1 = P64[Sp + 24];
          P64[Sp + 80] = Hp - 14;
          Sp = Sp + 80;
          call $s$wa_saFN_info(R6,
                               R5,
                               R4,
                               R3,
                               R2,
                               R1) args: 16, res: 0, upd: 8;
      cbGp:
          I64[Hp - 24] = GHC.Types.I#_con_info;
          I64[Hp - 16] = _saFQ::I64;
          I64[Hp - 8] = GHC.Types.I#_con_info;
          I64[Hp] = _saFP::I64;
          R4 = Hp - 23;
          R3 = Hp - 7;
          R2 = _saFT::I64;
          Sp = Sp + 8;
          call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
      cbGf:
          I64[Hp - 24] = GHC.Types.I#_con_info;
          I64[Hp - 16] = _saFQ::I64;
          I64[Hp - 8] = GHC.Types.I#_con_info;
          I64[Hp] = _saFP::I64;
          R4 = Hp - 23;
          R3 = Hp - 7;
          R2 = _saFT::I64;
          Sp = Sp + 8;
          call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
      cbG0:
          Hp = Hp - 32;
          R1 = P64[Sp];
          Sp = Sp + 8;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:47.09827 UTC

{offset
  cbHT:
      _saHY::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cbHU; else goto cbHV;
  cbHV:
      if (HpLim == 0) goto cbHU; else goto cbIY;
  cbHU:
      R1 = _saHY::P64;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  cbIY:
      _saFE::P64 = P64[_saHY::P64 + 7];
      _saHq::I64 = I64[_saHY::P64 + 15];
      _cbHR::I64 = _saHq::I64 * 8;
      _saHu::I64 = _cbHR::I64;
      _cbHX::I64 = %MO_S_Ge_W64(_saHu::I64, 0);
      _saHv::I64 = _cbHX::I64;
      switch [0 .. 1] _saHv::I64 {
          case 0 : goto cbI4;
          case 1 : goto cbIb;
      }
  cbIb:
      I64[(young<cbIa> + 8)] = cbIa;
      R1 = _saFE::P64;
      call stg_ap_0_fast(R1) returns to cbIa, args: 8, res: 8, upd: 8;
  cbIa:
      _saHC::P64 = R1;
      Hp = Hp + 16;
      if (Hp > HpLim) goto cbIh; else goto cbIg;
  cbIh:
      HpAlloc = 16;
      R1 = _saHC::P64;
      call stg_gc_unpt_r1(R1) returns to cbIa, args: 8, res: 8, upd: 8;
  cbIg:
      _saHF::P64 = P64[_saHC::P64 + 7];
      _saHD::I64 = I64[_saHC::P64 + 15];
      _saHE::I64 = I64[_saHC::P64 + 23];
      _cbIi::I64 = %MO_S_Lt_W64(_saHu::I64, _saHE::I64);
      _saHG::I64 = _cbIi::I64;
      switch [0 .. 1] _saHG::I64 {
          case 0 : goto cbIn;
          case 1 : goto cbIX;
      }
  cbIX:
      _cbIq::I64 = _saHD::I64 + _saHu::I64;
      _saHJ::I64 = _cbIq::I64;
      _saHM::I64 = I64[(_saHF::P64 + 16) + (_saHJ::I64 << 3)];
      _saHM::I64 = _saHM::I64;
      _cbIt::I64 = _saHM::I64 * 6364136223846793005;
      _saHO::I64 = _cbIt::I64;
      _cbIw::I64 = _saHD::I64 + _saHu::I64;
      _saHN::I64 = _cbIw::I64;
      I64[(_saHF::P64 + 16) + (_saHN::I64 << 3)] = _saHO::I64;
      _cbIB::I64 = _saHM::I64 >> 61;
      _saHS::I64 = _cbIB::I64;
      _cbIE::I64 = _saHS::I64;
      _saHT::I64 = _cbIE::I64;
      _cbIH::I64 = _saHT::I64 + 22;
      _saHU::I64 = _cbIH::I64;
      _cbIK::I64 = _saHM::I64 >> 22;
      _saHQ::I64 = _cbIK::I64;
      _cbIN::I64 = _saHQ::I64 ^ _saHM::I64;
      _saHR::I64 = _cbIN::I64;
      _cbIQ::I64 = _saHR::I64 >> _saHU::I64;
      _saHV::I64 = _cbIQ::I64;
      _cbIT::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_saHV::I64));
      _saHW::I64 = _cbIT::I64;
      I64[Hp - 8] = GHC.Word.W32#_con_info;
      I64[Hp] = _saHW::I64;
      _cbIW::P64 = Hp - 7;
      R1 = _cbIW::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
  cbIn:
      Hp = Hp - 16;
      R3 = _saHu::I64;
      R2 = _saHE::I64;
      call lvl5_ravU_info(R3, R2) args: 8, res: 0, upd: 8;
  cbI4:
      I64[(young<cbI2> + 8)] = cbI2;
      R1 = _saFE::P64;
      call stg_ap_0_fast(R1) returns to cbI2, args: 8, res: 8, upd: 8;
  cbI2:
      _saHx::P64 = R1;
      _saHA::P64 = P64[_saHx::P64 + 7];
      _saHy::I64 = I64[_saHx::P64 + 15];
      _saHz::I64 = I64[_saHx::P64 + 23];
      R3 = _saHu::I64;
      R2 = _saHz::I64;
      call lvl5_ravU_info(R3, R2) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:47.102666 UTC

{offset
  cbHT:
      _saHY::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cbHU; else goto cbHV;
  cbHV:
      if (HpLim == 0) goto cbHU; else goto cbIY;
  cbHU:
      R1 = _saHY::P64;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  cbIY:
      _saFE::P64 = P64[_saHY::P64 + 7];
      _saHq::I64 = I64[_saHY::P64 + 15];
      _cbHR::I64 = _saHq::I64 * 8;
      _saHu::I64 = _cbHR::I64;
      _cbHX::I64 = %MO_S_Ge_W64(_saHu::I64, 0);
      _saHv::I64 = _cbHX::I64;
      switch [0 .. 1] _saHv::I64 {
          case 0 : goto cbI4;
          case 1 : goto cbIb;
      }
  cbIb:
      I64[(young<cbIa> + 8)] = cbIa;
      R1 = _saFE::P64;
      call stg_ap_0_fast(R1) returns to cbIa, args: 8, res: 8, upd: 8;
  cbIa:
      _saHC::P64 = R1;
      Hp = Hp + 16;
      if (Hp > HpLim) goto cbIh; else goto cbIg;
  cbIh:
      HpAlloc = 16;
      R1 = _saHC::P64;
      call stg_gc_unpt_r1(R1) returns to cbIa, args: 8, res: 8, upd: 8;
  cbIg:
      _saHF::P64 = P64[_saHC::P64 + 7];
      _saHD::I64 = I64[_saHC::P64 + 15];
      _saHE::I64 = I64[_saHC::P64 + 23];
      _cbIi::I64 = %MO_S_Lt_W64(_saHu::I64, _saHE::I64);
      _saHG::I64 = _cbIi::I64;
      switch [0 .. 1] _saHG::I64 {
          case 0 : goto cbIn;
          case 1 : goto cbIX;
      }
  cbIX:
      _cbIq::I64 = _saHD::I64 + _saHu::I64;
      _saHJ::I64 = _cbIq::I64;
      _saHM::I64 = I64[(_saHF::P64 + 16) + (_saHJ::I64 << 3)];
      _saHM::I64 = _saHM::I64;
      _cbIt::I64 = _saHM::I64 * 6364136223846793005;
      _saHO::I64 = _cbIt::I64;
      _cbIw::I64 = _saHD::I64 + _saHu::I64;
      _saHN::I64 = _cbIw::I64;
      I64[(_saHF::P64 + 16) + (_saHN::I64 << 3)] = _saHO::I64;
      _cbIB::I64 = _saHM::I64 >> 61;
      _saHS::I64 = _cbIB::I64;
      _cbIE::I64 = _saHS::I64;
      _saHT::I64 = _cbIE::I64;
      _cbIH::I64 = _saHT::I64 + 22;
      _saHU::I64 = _cbIH::I64;
      _cbIK::I64 = _saHM::I64 >> 22;
      _saHQ::I64 = _cbIK::I64;
      _cbIN::I64 = _saHQ::I64 ^ _saHM::I64;
      _saHR::I64 = _cbIN::I64;
      _cbIQ::I64 = _saHR::I64 >> _saHU::I64;
      _saHV::I64 = _cbIQ::I64;
      _cbIT::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_saHV::I64));
      _saHW::I64 = _cbIT::I64;
      I64[Hp - 8] = GHC.Word.W32#_con_info;
      I64[Hp] = _saHW::I64;
      _cbIW::P64 = Hp - 7;
      R1 = _cbIW::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
  cbIn:
      Hp = Hp - 16;
      R3 = _saHu::I64;
      R2 = _saHE::I64;
      call lvl5_ravU_info(R3, R2) args: 8, res: 0, upd: 8;
  cbI4:
      I64[(young<cbI2> + 8)] = cbI2;
      R1 = _saFE::P64;
      call stg_ap_0_fast(R1) returns to cbI2, args: 8, res: 8, upd: 8;
  cbI2:
      _saHx::P64 = R1;
      _saHA::P64 = P64[_saHx::P64 + 7];
      _saHy::I64 = I64[_saHx::P64 + 15];
      _saHz::I64 = I64[_saHx::P64 + 23];
      R3 = _saHu::I64;
      R2 = _saHz::I64;
      call lvl5_ravU_info(R3, R2) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:47.106938 UTC

{offset
  cbHT:
      _saHY::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cbHU; else goto cbHV;
  cbHV:
      if (HpLim == 0) goto cbHU; else goto cbIY;
  cbHU:
      R1 = _saHY::P64;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  cbIY:
      _saFE::P64 = P64[_saHY::P64 + 7];
      _saHq::I64 = I64[_saHY::P64 + 15];
      _cbHR::I64 = _saHq::I64 * 8;
      _saHu::I64 = _cbHR::I64;
      _cbHX::I64 = %MO_S_Ge_W64(_saHu::I64, 0);
      _saHv::I64 = _cbHX::I64;
      if (_saHv::I64 != 0) goto cbIb; else goto cbI4;
  cbIb:
      I64[(young<cbIa> + 8)] = cbIa;
      R1 = _saFE::P64;
      call stg_ap_0_fast(R1) returns to cbIa, args: 8, res: 8, upd: 8;
  cbIa:
      _saHC::P64 = R1;
      Hp = Hp + 16;
      if (Hp > HpLim) goto cbIh; else goto cbIg;
  cbIh:
      HpAlloc = 16;
      R1 = _saHC::P64;
      call stg_gc_unpt_r1(R1) returns to cbIa, args: 8, res: 8, upd: 8;
  cbIg:
      _saHF::P64 = P64[_saHC::P64 + 7];
      _saHD::I64 = I64[_saHC::P64 + 15];
      _saHE::I64 = I64[_saHC::P64 + 23];
      _cbIi::I64 = %MO_S_Lt_W64(_saHu::I64, _saHE::I64);
      _saHG::I64 = _cbIi::I64;
      if (_saHG::I64 != 0) goto cbIX; else goto cbIn;
  cbIX:
      _cbIq::I64 = _saHD::I64 + _saHu::I64;
      _saHJ::I64 = _cbIq::I64;
      _saHM::I64 = I64[(_saHF::P64 + 16) + (_saHJ::I64 << 3)];
      _saHM::I64 = _saHM::I64;
      _cbIt::I64 = _saHM::I64 * 6364136223846793005;
      _saHO::I64 = _cbIt::I64;
      _cbIw::I64 = _saHD::I64 + _saHu::I64;
      _saHN::I64 = _cbIw::I64;
      I64[(_saHF::P64 + 16) + (_saHN::I64 << 3)] = _saHO::I64;
      _cbIB::I64 = _saHM::I64 >> 61;
      _saHS::I64 = _cbIB::I64;
      _cbIE::I64 = _saHS::I64;
      _saHT::I64 = _cbIE::I64;
      _cbIH::I64 = _saHT::I64 + 22;
      _saHU::I64 = _cbIH::I64;
      _cbIK::I64 = _saHM::I64 >> 22;
      _saHQ::I64 = _cbIK::I64;
      _cbIN::I64 = _saHQ::I64 ^ _saHM::I64;
      _saHR::I64 = _cbIN::I64;
      _cbIQ::I64 = _saHR::I64 >> _saHU::I64;
      _saHV::I64 = _cbIQ::I64;
      _cbIT::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_saHV::I64));
      _saHW::I64 = _cbIT::I64;
      I64[Hp - 8] = GHC.Word.W32#_con_info;
      I64[Hp] = _saHW::I64;
      _cbIW::P64 = Hp - 7;
      R1 = _cbIW::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
  cbIn:
      Hp = Hp - 16;
      R3 = _saHu::I64;
      R2 = _saHE::I64;
      call lvl5_ravU_info(R3, R2) args: 8, res: 0, upd: 8;
  cbI4:
      I64[(young<cbI2> + 8)] = cbI2;
      R1 = _saFE::P64;
      call stg_ap_0_fast(R1) returns to cbI2, args: 8, res: 8, upd: 8;
  cbI2:
      _saHx::P64 = R1;
      _saHA::P64 = P64[_saHx::P64 + 7];
      _saHy::I64 = I64[_saHx::P64 + 15];
      _saHz::I64 = I64[_saHx::P64 + 23];
      R3 = _saHu::I64;
      R2 = _saHz::I64;
      call lvl5_ravU_info(R3, R2) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:47.111364 UTC

{offset
  cbHT:
      _saHY::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto cbHU; else goto cbHV;
  cbHV:
      if (HpLim == 0) goto cbHU; else goto cbIY;
  cbHU:
      R1 = _saHY::P64;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  cbIY:
      _saFE::P64 = P64[_saHY::P64 + 7];
      _saHq::I64 = I64[_saHY::P64 + 15];
      _cbHR::I64 = _saHq::I64 * 8;
      _saHu::I64 = _cbHR::I64;
      _cbHX::I64 = %MO_S_Ge_W64(_saHu::I64, 0);
      _saHv::I64 = _cbHX::I64;
      if (_saHv::I64 != 0) goto cbIb; else goto cbI4;
  cbIb:
      I64[Sp - 16] = cbIa;
      R1 = _saFE::P64;
      I64[Sp - 8] = _saHu::I64;
      Sp = Sp - 16;
      call stg_ap_0_fast(R1) returns to cbIa, args: 8, res: 8, upd: 8;
  cbIa:
      _saHu::I64 = I64[Sp + 8];
      _saHC::P64 = R1;
      Hp = Hp + 16;
      if (Hp > HpLim) goto cbIh; else goto cbIg;
  cbIh:
      HpAlloc = 16;
      R1 = _saHC::P64;
      call stg_gc_unpt_r1(R1) returns to cbIa, args: 8, res: 8, upd: 8;
  cbIg:
      _saHF::P64 = P64[_saHC::P64 + 7];
      _saHD::I64 = I64[_saHC::P64 + 15];
      _saHE::I64 = I64[_saHC::P64 + 23];
      _cbIi::I64 = %MO_S_Lt_W64(_saHu::I64, _saHE::I64);
      _saHG::I64 = _cbIi::I64;
      if (_saHG::I64 != 0) goto cbIX; else goto cbIn;
  cbIX:
      _cbIq::I64 = _saHD::I64 + _saHu::I64;
      _saHJ::I64 = _cbIq::I64;
      _saHM::I64 = I64[(_saHF::P64 + 16) + (_saHJ::I64 << 3)];
      _saHM::I64 = _saHM::I64;
      _cbIt::I64 = _saHM::I64 * 6364136223846793005;
      _saHO::I64 = _cbIt::I64;
      _cbIw::I64 = _saHD::I64 + _saHu::I64;
      _saHN::I64 = _cbIw::I64;
      I64[(_saHF::P64 + 16) + (_saHN::I64 << 3)] = _saHO::I64;
      _cbIB::I64 = _saHM::I64 >> 61;
      _saHS::I64 = _cbIB::I64;
      _cbIE::I64 = _saHS::I64;
      _saHT::I64 = _cbIE::I64;
      _cbIH::I64 = _saHT::I64 + 22;
      _saHU::I64 = _cbIH::I64;
      _cbIK::I64 = _saHM::I64 >> 22;
      _saHQ::I64 = _cbIK::I64;
      _cbIN::I64 = _saHQ::I64 ^ _saHM::I64;
      _saHR::I64 = _cbIN::I64;
      _cbIQ::I64 = _saHR::I64 >> _saHU::I64;
      _saHV::I64 = _cbIQ::I64;
      _cbIT::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_saHV::I64));
      _saHW::I64 = _cbIT::I64;
      I64[Hp - 8] = GHC.Word.W32#_con_info;
      I64[Hp] = _saHW::I64;
      _cbIW::P64 = Hp - 7;
      R1 = _cbIW::P64;
      Sp = Sp + 16;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
  cbIn:
      Hp = Hp - 16;
      R3 = _saHu::I64;
      R2 = _saHE::I64;
      Sp = Sp + 16;
      call lvl5_ravU_info(R3, R2) args: 8, res: 0, upd: 8;
  cbI4:
      I64[Sp - 16] = cbI2;
      R1 = _saFE::P64;
      I64[Sp - 8] = _saHu::I64;
      Sp = Sp - 16;
      call stg_ap_0_fast(R1) returns to cbI2, args: 8, res: 8, upd: 8;
  cbI2:
      _saHu::I64 = I64[Sp + 8];
      _saHx::P64 = R1;
      _saHA::P64 = P64[_saHx::P64 + 7];
      _saHy::I64 = I64[_saHx::P64 + 15];
      _saHz::I64 = I64[_saHx::P64 + 23];
      R3 = _saHu::I64;
      R2 = _saHz::I64;
      Sp = Sp + 16;
      call lvl5_ravU_info(R3, R2) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:47.11596 UTC

{offset
  cbHT:
      _saHY::P64 = R1;
      if ((Sp + -16) < SpLim) goto cbHU; else goto cbHV;
  cbHV:
      if (HpLim == 0) goto cbHU; else goto cbIY;
  cbHU:
      R1 = _saHY::P64;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  cbIY:
      _saFE::P64 = P64[_saHY::P64 + 7];
      _saHu::I64 = I64[_saHY::P64 + 15] << 3;
      if (%MO_S_Ge_W64(_saHu::I64, 0)) goto cbIb; else goto cbI4;
  cbIb:
      I64[Sp - 16] = cbIa;
      R1 = _saFE::P64;
      I64[Sp - 8] = _saHu::I64;
      Sp = Sp - 16;
      call stg_ap_0_fast(R1) returns to cbIa, args: 8, res: 8, upd: 8;
  cbIa:
      Hp = Hp + 16;
      if (Hp > HpLim) goto cbIh; else goto cbIg;
  cbIh:
      HpAlloc = 16;
      R1 = R1;
      call stg_gc_unpt_r1(R1) returns to cbIa, args: 8, res: 8, upd: 8;
  cbIg:
      _saHu::I64 = I64[Sp + 8];
      _saHE::I64 = I64[R1 + 23];
      if (%MO_S_Lt_W64(_saHu::I64,
                       _saHE::I64)) goto cbIX; else goto cbIn;
  cbIX:
      _saHF::P64 = P64[R1 + 7];
      _saHD::I64 = I64[R1 + 15];
      _saHM::I64 = I64[(_saHF::P64 + 16) + (_saHD::I64 + _saHu::I64 << 3)];
      I64[(_saHF::P64 + 16) + (_saHD::I64 + _saHu::I64 << 3)] = _saHM::I64 * 6364136223846793005;
      I64[Hp - 8] = GHC.Word.W32#_con_info;
      I64[Hp] = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32((_saHM::I64 >> 22) ^ _saHM::I64 >> (_saHM::I64 >> 61) + 22));
      R1 = Hp - 7;
      Sp = Sp + 16;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
  cbIn:
      Hp = Hp - 16;
      R3 = _saHu::I64;
      R2 = _saHE::I64;
      Sp = Sp + 16;
      call lvl5_ravU_info(R3, R2) args: 8, res: 0, upd: 8;
  cbI4:
      I64[Sp - 16] = cbI2;
      R1 = _saFE::P64;
      I64[Sp - 8] = _saHu::I64;
      Sp = Sp - 16;
      call stg_ap_0_fast(R1) returns to cbI2, args: 8, res: 8, upd: 8;
  cbI2:
      R3 = I64[Sp + 8];
      R2 = I64[R1 + 23];
      Sp = Sp + 16;
      call lvl5_ravU_info(R3, R2) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:47.119828 UTC

[(cbHT, {lvl5_ravU_closure}), (cbHU, {}),
 (cbHV, {lvl5_ravU_closure}), (cbI2, {lvl5_ravU_closure}),
 (cbI4, {lvl5_ravU_closure}), (cbIa, {lvl5_ravU_closure}),
 (cbIb, {lvl5_ravU_closure}), (cbIg, {lvl5_ravU_closure}),
 (cbIh, {lvl5_ravU_closure}), (cbIn, {lvl5_ravU_closure}),
 (cbIX, {}), (cbIY, {lvl5_ravU_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:47.120673 UTC

sat_saHY_entry() //  [R1]
        { info_tbl: [(cbHT,
                      label: sat_saHY_info
                      rep:HeapRep 1 ptrs 1 nonptrs {
                            Fun {arity: 1 fun_type: ArgSpec 3} }),
                     (cbI2,
                      label: block_cbI2_info
                      rep:StackRep [True]),
                     (cbIa,
                      label: block_cbIa_info
                      rep:StackRep [True])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cbHT:
          _saHY::P64 = R1;
          if ((Sp + -16) < SpLim) goto cbHU; else goto cbHV;
      cbHV:
          if (HpLim == 0) goto cbHU; else goto cbIY;
      cbHU:
          R1 = _saHY::P64;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
      cbIY:
          _saFE::P64 = P64[_saHY::P64 + 7];
          _saHu::I64 = I64[_saHY::P64 + 15] << 3;
          if (%MO_S_Ge_W64(_saHu::I64, 0)) goto cbIb; else goto cbI4;
      cbIb:
          I64[Sp - 16] = cbIa;
          R1 = _saFE::P64;
          I64[Sp - 8] = _saHu::I64;
          Sp = Sp - 16;
          call stg_ap_0_fast(R1) returns to cbIa, args: 8, res: 8, upd: 8;
      cbIa:
          Hp = Hp + 16;
          if (Hp > HpLim) goto cbIh; else goto cbIg;
      cbIh:
          HpAlloc = 16;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to cbIa, args: 8, res: 8, upd: 8;
      cbIg:
          _saHu::I64 = I64[Sp + 8];
          _saHE::I64 = I64[R1 + 23];
          if (%MO_S_Lt_W64(_saHu::I64,
                           _saHE::I64)) goto cbIX; else goto cbIn;
      cbIX:
          _saHF::P64 = P64[R1 + 7];
          _saHD::I64 = I64[R1 + 15];
          _saHM::I64 = I64[(_saHF::P64 + 16) + (_saHD::I64 + _saHu::I64 << 3)];
          I64[(_saHF::P64 + 16) + (_saHD::I64 + _saHu::I64 << 3)] = _saHM::I64 * 6364136223846793005;
          I64[Hp - 8] = GHC.Word.W32#_con_info;
          I64[Hp] = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32((_saHM::I64 >> 22) ^ _saHM::I64 >> (_saHM::I64 >> 61) + 22));
          R1 = Hp - 7;
          Sp = Sp + 16;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
      cbIn:
          Hp = Hp - 16;
          R3 = _saHu::I64;
          R2 = _saHE::I64;
          Sp = Sp + 16;
          call lvl5_ravU_info(R3, R2) args: 8, res: 0, upd: 8;
      cbI4:
          I64[Sp - 16] = cbI2;
          R1 = _saFE::P64;
          I64[Sp - 8] = _saHu::I64;
          Sp = Sp - 16;
          call stg_ap_0_fast(R1) returns to cbI2, args: 8, res: 8, upd: 8;
      cbI2:
          R3 = I64[Sp + 8];
          R2 = I64[R1 + 23];
          Sp = Sp + 16;
          call lvl5_ravU_info(R3, R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:47.124422 UTC

sat_saHY_entry() //  [R1]
        { info_tbl: [(cbHT,
                      label: sat_saHY_info
                      rep:HeapRep 1 ptrs 1 nonptrs {
                            Fun {arity: 1 fun_type: ArgSpec 3} }),
                     (cbI2,
                      label: block_cbI2_info
                      rep:StackRep [True]),
                     (cbIa,
                      label: block_cbIa_info
                      rep:StackRep [True])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cbHT:
          _saHY::P64 = R1;
          if ((Sp + -16) < SpLim) goto cbHU; else goto cbHV;
      cbHV:
          if (HpLim == 0) goto cbHU; else goto cbIY;
      cbHU:
          R1 = _saHY::P64;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
      cbIY:
          _saFE::P64 = P64[_saHY::P64 + 7];
          _saHu::I64 = I64[_saHY::P64 + 15] << 3;
          if (%MO_S_Ge_W64(_saHu::I64, 0)) goto cbIb; else goto cbI4;
      cbIb:
          I64[Sp - 16] = cbIa;
          R1 = _saFE::P64;
          I64[Sp - 8] = _saHu::I64;
          Sp = Sp - 16;
          call stg_ap_0_fast(R1) returns to cbIa, args: 8, res: 8, upd: 8;
      cbIa:
          Hp = Hp + 16;
          if (Hp > HpLim) goto cbIh; else goto cbIg;
      cbIh:
          HpAlloc = 16;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to cbIa, args: 8, res: 8, upd: 8;
      cbIg:
          _saHu::I64 = I64[Sp + 8];
          _saHE::I64 = I64[R1 + 23];
          if (%MO_S_Lt_W64(_saHu::I64,
                           _saHE::I64)) goto cbIX; else goto cbIn;
      cbIX:
          _saHF::P64 = P64[R1 + 7];
          _saHD::I64 = I64[R1 + 15];
          _saHM::I64 = I64[(_saHF::P64 + 16) + (_saHD::I64 + _saHu::I64 << 3)];
          I64[(_saHF::P64 + 16) + (_saHD::I64 + _saHu::I64 << 3)] = _saHM::I64 * 6364136223846793005;
          I64[Hp - 8] = GHC.Word.W32#_con_info;
          I64[Hp] = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32((_saHM::I64 >> 22) ^ _saHM::I64 >> (_saHM::I64 >> 61) + 22));
          R1 = Hp - 7;
          Sp = Sp + 16;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
      cbIn:
          Hp = Hp - 16;
          R3 = _saHu::I64;
          R2 = _saHE::I64;
          Sp = Sp + 16;
          call lvl5_ravU_info(R3, R2) args: 8, res: 0, upd: 8;
      cbI4:
          I64[Sp - 16] = cbI2;
          R1 = _saFE::P64;
          I64[Sp - 8] = _saHu::I64;
          Sp = Sp - 16;
          call stg_ap_0_fast(R1) returns to cbI2, args: 8, res: 8, upd: 8;
      cbI2:
          R3 = I64[Sp + 8];
          R2 = I64[R1 + 23];
          Sp = Sp + 16;
          call lvl5_ravU_info(R3, R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:47.12861 UTC

{offset
  cbJ1:
      _saHs::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cbJ5; else goto cbJ6;
  cbJ6:
      Hp = Hp + 24;
      if (Hp > HpLim) goto cbJ8; else goto cbJ7;
  cbJ8:
      HpAlloc = 24;
      goto cbJ5;
  cbJ5:
      R1 = _saHs::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cbJ7:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _saHs::P64;
      _saFE::P64 = P64[_saHs::P64 + 16];
      _saFL::P64 = P64[_saHs::P64 + 24];
      _saFM::I64 = I64[_saHs::P64 + 32];
      _saHq::I64 = I64[_saHs::P64 + 40];
      I64[Hp - 16] = sat_saHY_info;
      P64[Hp - 8] = _saFE::P64;
      I64[Hp] = _saHq::I64;
      _cbHM::P64 = Hp - 15;
      I64[(young<cbIZ> + 8)] = cbIZ;
      R2 = _cbHM::P64;
      call GHC.IO.unsafeDupablePerformIO_info(R2) returns to cbIZ, args: 8, res: 8, upd: 24;
  cbIZ:
      _saHZ::P64 = R1;
      _saI0::I64 = I64[_saHZ::P64 + 7];
      I64[(young<cbJ4> + 8)] = cbJ4;
      R1 = logHalf_r2BC_closure;
      if (R1 & 7 != 0) goto cbJ4; else goto cbJa;
  cbJa:
      call (I64[R1])(R1) returns to cbJ4, args: 8, res: 8, upd: 24;
  cbJ4:
      _saI1::P64 = R1;
      Hp = Hp + 16;
      if (Hp > HpLim) goto cbJg; else goto cbJf;
  cbJg:
      HpAlloc = 16;
      R1 = _saI1::P64;
      call stg_gc_unpt_r1(R1) returns to cbJ4, args: 8, res: 8, upd: 24;
  cbJf:
      _saI2::F32 = F32[_saI1::P64 + 7];
      _cbJi::I64 = 4294967295;
      (_cbJh::F32) = call MO_UF_Conv W32(_cbJi::I64);
      _saI4::F32 = _cbJh::F32;
      _cbJm::I64 = _saI0::I64;
      (_cbJl::F32) = call MO_UF_Conv W32(_cbJm::I64);
      _saI3::F32 = _cbJl::F32;
      _cbJp::F32 = %MO_F_Quot_W32(_saI3::F32, _saI4::F32);
      _saI5::F32 = _cbJp::F32;
      _cbJt::F32 = _saI5::F32;
      (_cbJs::F32) = call MO_F32_Log(_cbJt::F32);
      _saI6::F32 = _cbJs::F32;
      _cbJw::F32 = %MO_F_Quot_W32(_saI6::F32, _saI2::F32);
      _saI7::F32 = _cbJw::F32;
      _cbJz::I64 = %MO_FS_Conv_W32_W64(_saI7::F32);
      _saI9::I64 = _cbJz::I64;
      _cbJC::I64 = _saI9::I64 + 1;
      _saI8::I64 = _cbJC::I64;
      _cbJF::I64 = %MO_S_Le_W64(_saFM::I64, _saI8::I64);
      _saIa::I64 = _cbJF::I64;
      switch [0 .. 1] _saIa::I64 {
          case 0 : goto cbJM;
          case 1 : goto cbJN;
      }
  cbJN:
      Hp = Hp - 16;
      R1 = _saFL::P64 & (-8);
      call (I64[R1])(R1) args: 24, res: 0, upd: 24;
  cbJM:
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _saI8::I64;
      _cbJK::P64 = Hp - 7;
      R1 = _cbJK::P64;
      call (P64[(old + 24)])(R1) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:47.13238 UTC

{offset
  cbJ1:
      _saHs::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cbJ5; else goto cbJ6;
  cbJ6:
      Hp = Hp + 24;
      if (Hp > HpLim) goto cbJ8; else goto cbJ7;
  cbJ8:
      HpAlloc = 24;
      goto cbJ5;
  cbJ5:
      R1 = _saHs::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cbJ7:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _saHs::P64;
      _saFE::P64 = P64[_saHs::P64 + 16];
      _saFL::P64 = P64[_saHs::P64 + 24];
      _saFM::I64 = I64[_saHs::P64 + 32];
      _saHq::I64 = I64[_saHs::P64 + 40];
      I64[Hp - 16] = sat_saHY_info;
      P64[Hp - 8] = _saFE::P64;
      I64[Hp] = _saHq::I64;
      _cbHM::P64 = Hp - 15;
      I64[(young<cbIZ> + 8)] = cbIZ;
      R2 = _cbHM::P64;
      call GHC.IO.unsafeDupablePerformIO_info(R2) returns to cbIZ, args: 8, res: 8, upd: 24;
  cbIZ:
      _saHZ::P64 = R1;
      _saI0::I64 = I64[_saHZ::P64 + 7];
      I64[(young<cbJ4> + 8)] = cbJ4;
      R1 = logHalf_r2BC_closure;
      if (R1 & 7 != 0) goto cbJ4; else goto cbJa;
  cbJa:
      call (I64[R1])(R1) returns to cbJ4, args: 8, res: 8, upd: 24;
  cbJ4:
      _saI1::P64 = R1;
      Hp = Hp + 16;
      if (Hp > HpLim) goto cbJg; else goto cbJf;
  cbJg:
      HpAlloc = 16;
      R1 = _saI1::P64;
      call stg_gc_unpt_r1(R1) returns to cbJ4, args: 8, res: 8, upd: 24;
  cbJf:
      _saI2::F32 = F32[_saI1::P64 + 7];
      _cbJi::I64 = 4294967295;
      (_cbJh::F32) = call MO_UF_Conv W32(_cbJi::I64);
      _saI4::F32 = _cbJh::F32;
      _cbJm::I64 = _saI0::I64;
      (_cbJl::F32) = call MO_UF_Conv W32(_cbJm::I64);
      _saI3::F32 = _cbJl::F32;
      _cbJp::F32 = %MO_F_Quot_W32(_saI3::F32, _saI4::F32);
      _saI5::F32 = _cbJp::F32;
      _cbJt::F32 = _saI5::F32;
      (_cbJs::F32) = call MO_F32_Log(_cbJt::F32);
      _saI6::F32 = _cbJs::F32;
      _cbJw::F32 = %MO_F_Quot_W32(_saI6::F32, _saI2::F32);
      _saI7::F32 = _cbJw::F32;
      _cbJz::I64 = %MO_FS_Conv_W32_W64(_saI7::F32);
      _saI9::I64 = _cbJz::I64;
      _cbJC::I64 = _saI9::I64 + 1;
      _saI8::I64 = _cbJC::I64;
      _cbJF::I64 = %MO_S_Le_W64(_saFM::I64, _saI8::I64);
      _saIa::I64 = _cbJF::I64;
      switch [0 .. 1] _saIa::I64 {
          case 0 : goto cbJM;
          case 1 : goto cbJN;
      }
  cbJN:
      Hp = Hp - 16;
      R1 = _saFL::P64 & (-8);
      call (I64[R1])(R1) args: 24, res: 0, upd: 24;
  cbJM:
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _saI8::I64;
      _cbJK::P64 = Hp - 7;
      R1 = _cbJK::P64;
      call (P64[(old + 24)])(R1) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:47.136174 UTC

{offset
  cbJ1:
      _saHs::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cbJ5; else goto cbJ6;
  cbJ6:
      Hp = Hp + 24;
      if (Hp > HpLim) goto cbJ8; else goto cbJ7;
  cbJ8:
      HpAlloc = 24;
      goto cbJ5;
  cbJ5:
      R1 = _saHs::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cbJ7:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _saHs::P64;
      _saFE::P64 = P64[_saHs::P64 + 16];
      _saFL::P64 = P64[_saHs::P64 + 24];
      _saFM::I64 = I64[_saHs::P64 + 32];
      _saHq::I64 = I64[_saHs::P64 + 40];
      I64[Hp - 16] = sat_saHY_info;
      P64[Hp - 8] = _saFE::P64;
      I64[Hp] = _saHq::I64;
      _cbHM::P64 = Hp - 15;
      I64[(young<cbIZ> + 8)] = cbIZ;
      R2 = _cbHM::P64;
      call GHC.IO.unsafeDupablePerformIO_info(R2) returns to cbIZ, args: 8, res: 8, upd: 24;
  cbIZ:
      _saHZ::P64 = R1;
      _saI0::I64 = I64[_saHZ::P64 + 7];
      I64[(young<cbJ4> + 8)] = cbJ4;
      R1 = logHalf_r2BC_closure;
      if (R1 & 7 != 0) goto cbJ4; else goto cbJa;
  cbJa:
      call (I64[R1])(R1) returns to cbJ4, args: 8, res: 8, upd: 24;
  cbJ4:
      _saI1::P64 = R1;
      Hp = Hp + 16;
      if (Hp > HpLim) goto cbJg; else goto cbJf;
  cbJg:
      HpAlloc = 16;
      R1 = _saI1::P64;
      call stg_gc_unpt_r1(R1) returns to cbJ4, args: 8, res: 8, upd: 24;
  cbJf:
      _saI2::F32 = F32[_saI1::P64 + 7];
      _cbJi::I64 = 4294967295;
      (_cbJh::F32) = call MO_UF_Conv W32(_cbJi::I64);
      _saI4::F32 = _cbJh::F32;
      _cbJm::I64 = _saI0::I64;
      (_cbJl::F32) = call MO_UF_Conv W32(_cbJm::I64);
      _saI3::F32 = _cbJl::F32;
      _cbJp::F32 = %MO_F_Quot_W32(_saI3::F32, _saI4::F32);
      _saI5::F32 = _cbJp::F32;
      _cbJt::F32 = _saI5::F32;
      (_cbJs::F32) = call MO_F32_Log(_cbJt::F32);
      _saI6::F32 = _cbJs::F32;
      _cbJw::F32 = %MO_F_Quot_W32(_saI6::F32, _saI2::F32);
      _saI7::F32 = _cbJw::F32;
      _cbJz::I64 = %MO_FS_Conv_W32_W64(_saI7::F32);
      _saI9::I64 = _cbJz::I64;
      _cbJC::I64 = _saI9::I64 + 1;
      _saI8::I64 = _cbJC::I64;
      _cbJF::I64 = %MO_S_Le_W64(_saFM::I64, _saI8::I64);
      _saIa::I64 = _cbJF::I64;
      if (_saIa::I64 != 0) goto cbJN; else goto cbJM;
  cbJN:
      Hp = Hp - 16;
      R1 = _saFL::P64 & (-8);
      call (I64[R1])(R1) args: 24, res: 0, upd: 24;
  cbJM:
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _saI8::I64;
      _cbJK::P64 = Hp - 7;
      R1 = _cbJK::P64;
      call (P64[(old + 24)])(R1) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:47.14019 UTC

{offset
  cbJ1:
      _saHs::P64 = R1;
      if ((Sp + 8) - 56 < SpLim) goto cbJ5; else goto cbJ6;
  cbJ6:
      Hp = Hp + 24;
      if (Hp > HpLim) goto cbJ8; else goto cbJ7;
  cbJ8:
      HpAlloc = 24;
      goto cbJ5;
  cbJ5:
      R1 = _saHs::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cbJ7:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _saHs::P64;
      _saFE::P64 = P64[_saHs::P64 + 16];
      _saFL::P64 = P64[_saHs::P64 + 24];
      _saFM::I64 = I64[_saHs::P64 + 32];
      _saHq::I64 = I64[_saHs::P64 + 40];
      I64[Hp - 16] = sat_saHY_info;
      P64[Hp - 8] = _saFE::P64;
      I64[Hp] = _saHq::I64;
      _cbHM::P64 = Hp - 15;
      I64[Sp - 40] = cbIZ;
      R2 = _cbHM::P64;
      P64[Sp - 32] = _saFL::P64;
      I64[Sp - 24] = _saFM::I64;
      Sp = Sp - 40;
      call GHC.IO.unsafeDupablePerformIO_info(R2) returns to cbIZ, args: 8, res: 8, upd: 24;
  cbIZ:
      _saFL::P64 = P64[Sp + 8];
      _saFM::I64 = I64[Sp + 16];
      _saHZ::P64 = R1;
      _saI0::I64 = I64[_saHZ::P64 + 7];
      I64[Sp - 8] = cbJ4;
      R1 = logHalf_r2BC_closure;
      I64[Sp] = _saI0::I64;
      Sp = Sp - 8;
      if (R1 & 7 != 0) goto cbJ4; else goto cbJa;
  cbJa:
      call (I64[R1])(R1) returns to cbJ4, args: 8, res: 8, upd: 24;
  cbJ4:
      _saFL::P64 = P64[Sp + 16];
      _saFM::I64 = I64[Sp + 24];
      _saI0::I64 = I64[Sp + 8];
      _saI1::P64 = R1;
      Hp = Hp + 16;
      if (Hp > HpLim) goto cbJg; else goto cbJf;
  cbJg:
      HpAlloc = 16;
      R1 = _saI1::P64;
      call stg_gc_unpt_r1(R1) returns to cbJ4, args: 8, res: 8, upd: 24;
  cbJf:
      _saI2::F32 = F32[_saI1::P64 + 7];
      _cbJi::I64 = 4294967295;
      (_cbJh::F32) = call MO_UF_Conv W32(_cbJi::I64);
      _saI4::F32 = _cbJh::F32;
      _cbJm::I64 = _saI0::I64;
      (_cbJl::F32) = call MO_UF_Conv W32(_cbJm::I64);
      _saI3::F32 = _cbJl::F32;
      _cbJp::F32 = %MO_F_Quot_W32(_saI3::F32, _saI4::F32);
      _saI5::F32 = _cbJp::F32;
      _cbJt::F32 = _saI5::F32;
      (_cbJs::F32) = call MO_F32_Log(_cbJt::F32);
      _saI6::F32 = _cbJs::F32;
      _cbJw::F32 = %MO_F_Quot_W32(_saI6::F32, _saI2::F32);
      _saI7::F32 = _cbJw::F32;
      _cbJz::I64 = %MO_FS_Conv_W32_W64(_saI7::F32);
      _saI9::I64 = _cbJz::I64;
      _cbJC::I64 = _saI9::I64 + 1;
      _saI8::I64 = _cbJC::I64;
      _cbJF::I64 = %MO_S_Le_W64(_saFM::I64, _saI8::I64);
      _saIa::I64 = _cbJF::I64;
      if (_saIa::I64 != 0) goto cbJN; else goto cbJM;
  cbJN:
      Hp = Hp - 16;
      R1 = _saFL::P64 & (-8);
      Sp = Sp + 32;
      call (I64[R1])(R1) args: 24, res: 0, upd: 24;
  cbJM:
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _saI8::I64;
      _cbJK::P64 = Hp - 7;
      R1 = _cbJK::P64;
      Sp = Sp + 32;
      call (P64[Sp])(R1) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:47.144506 UTC

{offset
  cbJ1:
      _saHs::P64 = R1;
      if ((Sp + -48) < SpLim) goto cbJ5; else goto cbJ6;
  cbJ6:
      Hp = Hp + 24;
      if (Hp > HpLim) goto cbJ8; else goto cbJ7;
  cbJ8:
      HpAlloc = 24;
      goto cbJ5;
  cbJ5:
      R1 = _saHs::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cbJ7:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _saHs::P64;
      _saFE::P64 = P64[_saHs::P64 + 16];
      _saFL::P64 = P64[_saHs::P64 + 24];
      _saFM::I64 = I64[_saHs::P64 + 32];
      _saHq::I64 = I64[_saHs::P64 + 40];
      I64[Hp - 16] = sat_saHY_info;
      P64[Hp - 8] = _saFE::P64;
      I64[Hp] = _saHq::I64;
      I64[Sp - 40] = cbIZ;
      R2 = Hp - 15;
      P64[Sp - 32] = _saFL::P64;
      I64[Sp - 24] = _saFM::I64;
      Sp = Sp - 40;
      call GHC.IO.unsafeDupablePerformIO_info(R2) returns to cbIZ, args: 8, res: 8, upd: 24;
  cbIZ:
      I64[Sp - 8] = cbJ4;
      _saI0::I64 = I64[R1 + 7];
      R1 = logHalf_r2BC_closure;
      I64[Sp] = _saI0::I64;
      Sp = Sp - 8;
      if (R1 & 7 != 0) goto cbJ4; else goto cbJa;
  cbJa:
      call (I64[R1])(R1) returns to cbJ4, args: 8, res: 8, upd: 24;
  cbJ4:
      Hp = Hp + 16;
      if (Hp > HpLim) goto cbJg; else goto cbJf;
  cbJg:
      HpAlloc = 16;
      R1 = R1;
      call stg_gc_unpt_r1(R1) returns to cbJ4, args: 8, res: 8, upd: 24;
  cbJf:
      _saFL::P64 = P64[Sp + 16];
      _saFM::I64 = I64[Sp + 24];
      _saI0::I64 = I64[Sp + 8];
      _saI2::F32 = F32[R1 + 7];
      (_cbJh::F32) = call MO_UF_Conv W32(4294967295);
      (_cbJl::F32) = call MO_UF_Conv W32(_saI0::I64);
      (_cbJs::F32) = call MO_F32_Log(%MO_F_Quot_W32(_cbJl::F32,
                                                    _cbJh::F32));
      _saI8::I64 = %MO_FS_Conv_W32_W64(%MO_F_Quot_W32(_cbJs::F32,
                                                      _saI2::F32)) + 1;
      if (%MO_S_Le_W64(_saFM::I64,
                       _saI8::I64)) goto cbJN; else goto cbJM;
  cbJN:
      Hp = Hp - 16;
      R1 = _saFL::P64 & (-8);
      Sp = Sp + 32;
      call (I64[R1])(R1) args: 24, res: 0, upd: 24;
  cbJM:
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _saI8::I64;
      R1 = Hp - 7;
      Sp = Sp + 32;
      call (P64[Sp])(R1) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:47.148627 UTC

[(cbIZ, {logHalf_r2BC_closure}),
 (cbJ1, {logHalf_r2BC_closure, sat_saHY_closure}), (cbJ4, {}),
 (cbJ5, {}), (cbJ6, {logHalf_r2BC_closure, sat_saHY_closure}),
 (cbJ7, {logHalf_r2BC_closure, sat_saHY_closure}), (cbJ8, {}),
 (cbJa, {}), (cbJf, {}), (cbJg, {}), (cbJM, {}), (cbJN, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:47.149402 UTC

nodesHeight_saHs_entry() //  [R1]
        { info_tbl: [(cbIZ,
                      label: block_cbIZ_info
                      rep:StackRep [False, True]),
                     (cbJ1,
                      label: nodesHeight_saHs_info
                      rep:HeapRep 2 ptrs 2 nonptrs { Thunk }),
                     (cbJ4,
                      label: block_cbJ4_info
                      rep:StackRep [True, False, True])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cbJ1:
          _saHs::P64 = R1;
          if ((Sp + -48) < SpLim) goto cbJ5; else goto cbJ6;
      cbJ6:
          Hp = Hp + 24;
          if (Hp > HpLim) goto cbJ8; else goto cbJ7;
      cbJ8:
          HpAlloc = 24;
          goto cbJ5;
      cbJ5:
          R1 = _saHs::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      cbJ7:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _saHs::P64;
          _saFE::P64 = P64[_saHs::P64 + 16];
          _saFL::P64 = P64[_saHs::P64 + 24];
          _saFM::I64 = I64[_saHs::P64 + 32];
          _saHq::I64 = I64[_saHs::P64 + 40];
          I64[Hp - 16] = sat_saHY_info;
          P64[Hp - 8] = _saFE::P64;
          I64[Hp] = _saHq::I64;
          I64[Sp - 40] = cbIZ;
          R2 = Hp - 15;
          P64[Sp - 32] = _saFL::P64;
          I64[Sp - 24] = _saFM::I64;
          Sp = Sp - 40;
          call GHC.IO.unsafeDupablePerformIO_info(R2) returns to cbIZ, args: 8, res: 8, upd: 24;
      cbIZ:
          I64[Sp - 8] = cbJ4;
          _saI0::I64 = I64[R1 + 7];
          R1 = logHalf_r2BC_closure;
          I64[Sp] = _saI0::I64;
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto cbJ4; else goto cbJa;
      cbJa:
          call (I64[R1])(R1) returns to cbJ4, args: 8, res: 8, upd: 24;
      cbJ4:
          Hp = Hp + 16;
          if (Hp > HpLim) goto cbJg; else goto cbJf;
      cbJg:
          HpAlloc = 16;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to cbJ4, args: 8, res: 8, upd: 24;
      cbJf:
          _saFL::P64 = P64[Sp + 16];
          _saFM::I64 = I64[Sp + 24];
          _saI0::I64 = I64[Sp + 8];
          _saI2::F32 = F32[R1 + 7];
          (_cbJh::F32) = call MO_UF_Conv W32(4294967295);
          (_cbJl::F32) = call MO_UF_Conv W32(_saI0::I64);
          (_cbJs::F32) = call MO_F32_Log(%MO_F_Quot_W32(_cbJl::F32,
                                                        _cbJh::F32));
          _saI8::I64 = %MO_FS_Conv_W32_W64(%MO_F_Quot_W32(_cbJs::F32,
                                                          _saI2::F32)) + 1;
          if (%MO_S_Le_W64(_saFM::I64,
                           _saI8::I64)) goto cbJN; else goto cbJM;
      cbJN:
          Hp = Hp - 16;
          R1 = _saFL::P64 & (-8);
          Sp = Sp + 32;
          call (I64[R1])(R1) args: 24, res: 0, upd: 24;
      cbJM:
          I64[Hp - 8] = GHC.Types.I#_con_info;
          I64[Hp] = _saI8::I64;
          R1 = Hp - 7;
          Sp = Sp + 32;
          call (P64[Sp])(R1) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:47.153471 UTC

nodesHeight_saHs_entry() //  [R1]
        { info_tbl: [(cbIZ,
                      label: block_cbIZ_info
                      rep:StackRep [False, True]),
                     (cbJ1,
                      label: nodesHeight_saHs_info
                      rep:HeapRep 2 ptrs 2 nonptrs { Thunk }),
                     (cbJ4,
                      label: block_cbJ4_info
                      rep:StackRep [True, False, True])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cbJ1:
          _saHs::P64 = R1;
          if ((Sp + -48) < SpLim) goto cbJ5; else goto cbJ6;
      cbJ6:
          Hp = Hp + 24;
          if (Hp > HpLim) goto cbJ8; else goto cbJ7;
      cbJ8:
          HpAlloc = 24;
          goto cbJ5;
      cbJ5:
          R1 = _saHs::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      cbJ7:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _saHs::P64;
          _saFE::P64 = P64[_saHs::P64 + 16];
          _saFL::P64 = P64[_saHs::P64 + 24];
          _saFM::I64 = I64[_saHs::P64 + 32];
          _saHq::I64 = I64[_saHs::P64 + 40];
          I64[Hp - 16] = sat_saHY_info;
          P64[Hp - 8] = _saFE::P64;
          I64[Hp] = _saHq::I64;
          I64[Sp - 40] = cbIZ;
          R2 = Hp - 15;
          P64[Sp - 32] = _saFL::P64;
          I64[Sp - 24] = _saFM::I64;
          Sp = Sp - 40;
          call GHC.IO.unsafeDupablePerformIO_info(R2) returns to cbIZ, args: 8, res: 8, upd: 24;
      cbIZ:
          I64[Sp - 8] = cbJ4;
          _saI0::I64 = I64[R1 + 7];
          R1 = logHalf_r2BC_closure;
          I64[Sp] = _saI0::I64;
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto cbJ4; else goto cbJa;
      cbJa:
          call (I64[R1])(R1) returns to cbJ4, args: 8, res: 8, upd: 24;
      cbJ4:
          Hp = Hp + 16;
          if (Hp > HpLim) goto cbJg; else goto cbJf;
      cbJg:
          HpAlloc = 16;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to cbJ4, args: 8, res: 8, upd: 24;
      cbJf:
          _saFL::P64 = P64[Sp + 16];
          _saFM::I64 = I64[Sp + 24];
          _saI0::I64 = I64[Sp + 8];
          _saI2::F32 = F32[R1 + 7];
          (_cbJh::F32) = call MO_UF_Conv W32(4294967295);
          (_cbJl::F32) = call MO_UF_Conv W32(_saI0::I64);
          (_cbJs::F32) = call MO_F32_Log(%MO_F_Quot_W32(_cbJl::F32,
                                                        _cbJh::F32));
          _saI8::I64 = %MO_FS_Conv_W32_W64(%MO_F_Quot_W32(_cbJs::F32,
                                                          _saI2::F32)) + 1;
          if (%MO_S_Le_W64(_saFM::I64,
                           _saI8::I64)) goto cbJN; else goto cbJM;
      cbJN:
          Hp = Hp - 16;
          R1 = _saFL::P64 & (-8);
          Sp = Sp + 32;
          call (I64[R1])(R1) args: 24, res: 0, upd: 24;
      cbJM:
          I64[Hp - 8] = GHC.Types.I#_con_info;
          I64[Hp] = _saI8::I64;
          R1 = Hp - 7;
          Sp = Sp + 32;
          call (P64[Sp])(R1) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:47.157539 UTC

{offset
  cbJO:
      _saFF::P64 = R6;
      _saFE::P64 = R5;
      _saFD::P64 = R4;
      _saFC::P64 = R3;
      _saFB::P64 = R2;
      _saFG::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto cbJX; else goto cbJY;
  cbJY:
      if (HpLim == 0) goto cbJX; else goto cbJZ;
  cbJX:
      R6 = _saFF::P64;
      R5 = _saFE::P64;
      R4 = _saFD::P64;
      R3 = _saFC::P64;
      R2 = _saFB::P64;
      R1 = SkipList.$wa4_closure;
      P64[(old + 16)] = _saFG::P64;
      call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
  cbJZ:
      I64[(young<cbD0> + 8)] = cbD0;
      R1 = _saFD::P64;
      call stg_norec_readTVar#(R1) returns to cbD0, args: 8, res: 8, upd: 8;
  cbD0:
      _saFK::P64 = R1;
      I64[(young<cbD2> + 8)] = cbD2;
      R1 = _saFK::P64;
      if (R1 & 7 != 0) goto cbD2; else goto cbD3;
  cbD3:
      call (I64[R1])(R1) returns to cbD2, args: 8, res: 8, upd: 8;
  cbD2:
      _saFL::P64 = R1;
      Hp = Hp + 64;
      if (Hp > HpLim) goto cbK3; else goto cbK2;
  cbK3:
      HpAlloc = 64;
      R1 = _saFL::P64;
      call stg_gc_unpt_r1(R1) returns to cbD2, args: 8, res: 8, upd: 8;
  cbK2:
      _saFM::I64 = I64[_saFL::P64 + 7];
      _cbD7::P64 = Hp - 52;
      _cbD8::P64 = Hp - 24;
      I64[Hp - 56] = $wa8_saFO_info;
      P64[Hp - 48] = _saFB::P64;
      P64[Hp - 40] = _saFF::P64;
      P64[Hp - 32] = _cbD8::P64;
      I64[Hp - 24] = $s$wa_saFN_info;
      P64[Hp - 16] = _saFB::P64;
      P64[Hp - 8] = _saFF::P64;
      P64[Hp] = _cbD7::P64;
      I64[(young<cbHA> + 8)] = cbHA;
      R4 = GHC.Types.[]_closure+1;
      R3 = _saFM::I64;
      R2 = _saFC::P64;
      R1 = _cbD7::P64;
      call $wa8_saFO_info(R4,
                          R3,
                          R2,
                          R1) returns to cbHA, args: 8, res: 8, upd: 8;
  cbHA:
      _saHj::P64 = R1;
      I64[(young<cbHC> + 8)] = cbHC;
      call stg_myThreadId#() returns to cbHC, args: 8, res: 8, upd: 8;
  cbHC:
      _saHm::P64 = R1;
      I64[(young<cbHE> + 8)] = cbHE;
      R1 = _saHm::P64;
      call stg_threadStatus#(R1) returns to cbHE, args: 8, res: 8, upd: 8;
  cbHE:
      _saHr::I64 = R3;
      _saHq::I64 = R2;
      _saHp::I64 = R1;
      goto cbHF;
  cbHF:
      Hp = Hp + 72;
      if (Hp > HpLim) goto cbK8; else goto cbK7;
  cbK8:
      HpAlloc = 72;
      I64[(young<cbHG> + 8)] = cbHG;
      call stg_gc_noregs() returns to cbHG, args: 8, res: 8, upd: 8;
  cbHG:
      goto cbHF;
  cbK7:
      I64[Hp - 64] = nodesHeight_saHs_info;
      P64[Hp - 48] = _saFE::P64;
      P64[Hp - 40] = _saFL::P64;
      I64[Hp - 32] = _saFM::I64;
      I64[Hp - 24] = _saHq::I64;
      _cbHI::P64 = Hp - 64;
      I64[Hp - 16] = (,)_con_info;
      P64[Hp - 8] = SkipList.newSL10_closure+1;
      P64[Hp] = _cbHI::P64;
      _cbJP::P64 = Hp - 15;
      I64[(young<cbJQ> + 8)] = cbJQ;
      R3 = _cbJP::P64;
      R2 = GHC.Arr.$fIxInt_closure;
      call SkipList.$fMArrayTArrayeSTM8_info(R3,
                                             R2) returns to cbJQ, args: 8, res: 8, upd: 8;
  cbJQ:
      _saIf::P64 = R1;
      I64[(young<cbJS> + 8)] = cbJS;
      R1 = _saFG::P64;
      call stg_newNOrecTVar#(R1) returns to cbJS, args: 8, res: 8, upd: 8;
  cbJS:
      _saIi::P64 = R1;
      Hp = Hp + 48;
      if (Hp > HpLim) goto cbKc; else goto cbKb;
  cbKc:
      HpAlloc = 48;
      R1 = _saIi::P64;
      call stg_gc_unpt_r1(R1) returns to cbJS, args: 8, res: 8, upd: 8;
  cbKb:
      I64[Hp - 40] = GHC.Conc.Sync.TVar_con_info;
      P64[Hp - 32] = _saIi::P64;
      _cbJU::P64 = Hp - 39;
      I64[Hp - 24] = SkipList.Node_con_info;
      P64[Hp - 16] = _saFF::P64;
      P64[Hp - 8] = _cbJU::P64;
      P64[Hp] = _saIf::P64;
      _cbJV::P64 = Hp - 22;
      I64[(young<cbJW> + 8)] = cbJW;
      R1 = _cbHI::P64;
      if (R1 & 7 != 0) goto cbJW; else goto cbKd;
  cbKd:
      call (I64[R1])(R1) returns to cbJW, args: 8, res: 8, upd: 8;
  cbJW:
      _saIl::P64 = R1;
      _saIm::I64 = I64[_saIl::P64 + 7];
      _cbKi::I64 = %MO_S_Gt_W64(1, _saIm::I64);
      _saIn::I64 = _cbKi::I64;
      switch [0 .. 1] _saIn::I64 {
          case 0 : goto cbKp;
          case 1 : goto cbPm;
      }
  cbPm:
      R1 = GHC.Tuple.()_closure+1;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
  cbKp:
      I64[(young<cbKn> + 8)] = cbKn;
      R1 = _saHj::P64;
      if (R1 & 7 != 0) goto cbKn; else goto cbKq;
  cbKq:
      call (I64[R1])(R1) returns to cbKn, args: 8, res: 8, upd: 8;
  cbKn:
      _saIp::P64 = R1;
      _cbPn::P64 = _saIp::P64 & 7;
      switch [1 .. 2] _cbPn::P64 {
          case 1 : goto cbKw;
          case 2 : goto cbKL;
      }
  cbKL:
      _saIr::P64 = P64[_saIp::P64 + 6];
      _saIs::P64 = P64[_saIp::P64 + 14];
      I64[(young<cbKz> + 8)] = cbKz;
      R1 = _saIr::P64;
      if (R1 & 7 != 0) goto cbKz; else goto cbKA;
  cbKA:
      call (I64[R1])(R1) returns to cbKz, args: 8, res: 8, upd: 8;
  cbKz:
      _saIt::P64 = R1;
      _saIu::P64 = P64[_saIt::P64 + 7];
      _saIv::P64 = P64[_saIt::P64 + 15];
      _saIx::P64 = P64[_saIt::P64 + 23];
      _saIw::I64 = I64[_saIt::P64 + 31];
      I64[(young<cbKE> + 8)] = cbKE;
      R1 = _saIu::P64;
      if (R1 & 7 != 0) goto cbKE; else goto cbKF;
  cbKF:
      call (I64[R1])(R1) returns to cbKE, args: 8, res: 8, upd: 8;
  cbKE:
      _saIy::P64 = R1;
      _saIz::I64 = I64[_saIy::P64 + 7];
      I64[(young<cbKJ> + 8)] = cbKJ;
      R1 = _saIv::P64;
      if (R1 & 7 != 0) goto cbKJ; else goto cbKO;
  cbKO:
      call (I64[R1])(R1) returns to cbKJ, args: 8, res: 8, upd: 8;
  cbKJ:
      _saIA::P64 = R1;
      _saIB::I64 = I64[_saIA::P64 + 7];
      _cbKT::I64 = %MO_S_Le_W64(_saIz::I64, 1);
      _saIC::I64 = _cbKT::I64;
      switch [0 .. 1] _saIC::I64 {
          case 0 : goto cbKY;
          case 1 : goto cbPl;
      }
  cbPl:
      _cbL1::I64 = %MO_S_Le_W64(1, _saIB::I64);
      _saIG::I64 = _cbL1::I64;
      switch [0 .. 1] _saIG::I64 {
          case 0 : goto cbL6;
          case 1 : goto cbPk;
      }
  cbPk:
      _cbL9::I64 = 1 - _saIz::I64;
      _saIK::I64 = _cbL9::I64;
      _cbLc::I64 = %MO_S_Le_W64(0, _saIK::I64);
      _saIL::I64 = _cbLc::I64;
      switch [0 .. 1] _saIL::I64 {
          case 0 : goto cbLh;
          case 1 : goto cbPj;
      }
  cbPj:
      _cbLk::I64 = %MO_S_Lt_W64(_saIK::I64, _saIw::I64);
      _saIO::I64 = _cbLk::I64;
      switch [0 .. 1] _saIO::I64 {
          case 0 : goto cbLp;
          case 1 : goto cbLO;
      }
  cbLO:
      _saIS::P64 = P64[(_saIx::P64 + 24) + (_saIK::I64 << 3)];
      _saIS::P64 = _saIS::P64;
      I64[(young<cbLs> + 8)] = cbLs;
      R1 = _saIS::P64;
      if (R1 & 7 != 0) goto cbLs; else goto cbLt;
  cbLt:
      call (I64[R1])(R1) returns to cbLs, args: 8, res: 8, upd: 8;
  cbLs:
      _saIT::P64 = R1;
      _saIU::P64 = P64[_saIT::P64 + 7];
      I64[(young<cbLx> + 8)] = cbLx;
      R1 = _saIU::P64;
      call stg_norec_readTVar#(R1) returns to cbLx, args: 8, res: 8, upd: 8;
  cbLx:
      _saIX::P64 = R1;
      I64[(young<cbLz> + 8)] = cbLz;
      R2 = _cbJV::P64;
      R1 = _saIU::P64;
      call stg_norec_writeTVar#(R2,
                                R1) returns to cbLz, args: 8, res: 8, upd: 8;
  cbLz:
      I64[(young<cbLD> + 8)] = cbLD;
      R1 = _saIf::P64;
      if (R1 & 7 != 0) goto cbLD; else goto cbLE;
  cbLE:
      call (I64[R1])(R1) returns to cbLD, args: 8, res: 8, upd: 8;
  cbLD:
      _saIZ::P64 = R1;
      _saJ0::P64 = P64[_saIZ::P64 + 7];
      _saJ1::P64 = P64[_saIZ::P64 + 15];
      _saJ3::P64 = P64[_saIZ::P64 + 23];
      _saJ2::I64 = I64[_saIZ::P64 + 31];
      I64[(young<cbLI> + 8)] = cbLI;
      R1 = _saJ0::P64;
      if (R1 & 7 != 0) goto cbLI; else goto cbLJ;
  cbLJ:
      call (I64[R1])(R1) returns to cbLI, args: 8, res: 8, upd: 8;
  cbLI:
      _saJ4::P64 = R1;
      _saJ5::I64 = I64[_saJ4::P64 + 7];
      I64[(young<cbLN> + 8)] = cbLN;
      R1 = _saJ1::P64;
      if (R1 & 7 != 0) goto cbLN; else goto cbLU;
  cbLU:
      call (I64[R1])(R1) returns to cbLN, args: 8, res: 8, upd: 8;
  cbLN:
      _saJ6::P64 = R1;
      _saJ7::I64 = I64[_saJ6::P64 + 7];
      _cbLZ::I64 = %MO_S_Le_W64(_saJ5::I64, 1);
      _saJ8::I64 = _cbLZ::I64;
      switch [0 .. 1] _saJ8::I64 {
          case 0 : goto cbM4;
          case 1 : goto cbPi;
      }
  cbPi:
      _cbM7::I64 = %MO_S_Le_W64(1, _saJ7::I64);
      _saJc::I64 = _cbM7::I64;
      switch [0 .. 1] _saJc::I64 {
          case 0 : goto cbMc;
          case 1 : goto cbPh;
      }
  cbPh:
      _cbMf::I64 = 1 - _saJ5::I64;
      _saJg::I64 = _cbMf::I64;
      _cbMi::I64 = %MO_S_Le_W64(0, _saJg::I64);
      _saJh::I64 = _cbMi::I64;
      switch [0 .. 1] _saJh::I64 {
          case 0 : goto cbMn;
          case 1 : goto cbPg;
      }
  cbPg:
      _cbMq::I64 = %MO_S_Lt_W64(_saJg::I64, _saJ2::I64);
      _saJk::I64 = _cbMq::I64;
      switch [0 .. 1] _saJk::I64 {
          case 0 : goto cbMv;
          case 1 : goto cbME;
      }
  cbME:
      _saJo::P64 = P64[(_saJ3::P64 + 24) + (_saJg::I64 << 3)];
      _saJo::P64 = _saJo::P64;
      I64[(young<cbMy> + 8)] = cbMy;
      R1 = _saJo::P64;
      if (R1 & 7 != 0) goto cbMy; else goto cbMz;
  cbMz:
      call (I64[R1])(R1) returns to cbMy, args: 8, res: 8, upd: 8;
  cbMy:
      _saJp::P64 = R1;
      _saJq::P64 = P64[_saJp::P64 + 7];
      I64[(young<cbMD> + 8)] = cbMD;
      R2 = _saIX::P64;
      R1 = _saJq::P64;
      call stg_norec_writeTVar#(R2,
                                R1) returns to cbMD, args: 8, res: 8, upd: 8;
  cbMD:
      _saJu::P64 = _saIs::P64;
      _saJt::I64 = 2;
      goto cbMM;
  cbMM:
      if (HpLim == 0) goto cbMP; else goto cbPf;
  cbMP:
      I64[(young<cbMN> + 8)] = cbMN;
      call stg_gc_noregs() returns to cbMN, args: 8, res: 8, upd: 8;
  cbMN:
      goto cbMM;
  cbPf:
      _cbMQ::I64 = %MO_S_Gt_W64(_saJt::I64, _saIm::I64);
      _saJw::I64 = _cbMQ::I64;
      switch [0 .. 1] _saJw::I64 {
          case 0 : goto cbMX;
          case 1 : goto cbPe;
      }
  cbPe:
      R1 = GHC.Tuple.()_closure+1;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
  cbMX:
      I64[(young<cbMV> + 8)] = cbMV;
      R1 = _saJu::P64;
      if (R1 & 7 != 0) goto cbMV; else goto cbMY;
  cbMY:
      call (I64[R1])(R1) returns to cbMV, args: 8, res: 8, upd: 8;
  cbMV:
      _saJy::P64 = R1;
      _cbPo::P64 = _saJy::P64 & 7;
      switch [1 .. 2] _cbPo::P64 {
          case 1 : goto cbN4;
          case 2 : goto cbNj;
      }
  cbNj:
      _saJA::P64 = P64[_saJy::P64 + 6];
      _saJB::P64 = P64[_saJy::P64 + 14];
      I64[(young<cbN7> + 8)] = cbN7;
      R1 = _saJA::P64;
      if (R1 & 7 != 0) goto cbN7; else goto cbN8;
  cbN8:
      call (I64[R1])(R1) returns to cbN7, args: 8, res: 8, upd: 8;
  cbN7:
      _saJC::P64 = R1;
      _saJD::P64 = P64[_saJC::P64 + 7];
      _saJE::P64 = P64[_saJC::P64 + 15];
      _saJG::P64 = P64[_saJC::P64 + 23];
      _saJF::I64 = I64[_saJC::P64 + 31];
      I64[(young<cbNc> + 8)] = cbNc;
      R1 = _saJD::P64;
      if (R1 & 7 != 0) goto cbNc; else goto cbNd;
  cbNd:
      call (I64[R1])(R1) returns to cbNc, args: 8, res: 8, upd: 8;
  cbNc:
      _saJH::P64 = R1;
      _saJI::I64 = I64[_saJH::P64 + 7];
      I64[(young<cbNh> + 8)] = cbNh;
      R1 = _saJE::P64;
      if (R1 & 7 != 0) goto cbNh; else goto cbNm;
  cbNm:
      call (I64[R1])(R1) returns to cbNh, args: 8, res: 8, upd: 8;
  cbNh:
      _saJJ::P64 = R1;
      Hp = Hp + 16;
      if (Hp > HpLim) goto cbNs; else goto cbNr;
  cbNs:
      HpAlloc = 16;
      R1 = _saJJ::P64;
      call stg_gc_unpt_r1(R1) returns to cbNh, args: 8, res: 8, upd: 8;
  cbNr:
      _saJK::I64 = I64[_saJJ::P64 + 7];
      _cbNt::I64 = %MO_S_Le_W64(_saJI::I64, _saJt::I64);
      _saJL::I64 = _cbNt::I64;
      switch [0 .. 1] _saJL::I64 {
          case 0 : goto cbNA;
          case 1 : goto cbPd;
      }
  cbPd:
      _cbNC::I64 = %MO_S_Le_W64(_saJt::I64, _saJK::I64);
      _saJP::I64 = _cbNC::I64;
      switch [0 .. 1] _saJP::I64 {
          case 0 : goto cbNJ;
          case 1 : goto cbPc;
      }
  cbPc:
      _cbNL::I64 = _saJt::I64 - _saJI::I64;
      _saJT::I64 = _cbNL::I64;
      _cbNO::I64 = %MO_S_Le_W64(0, _saJT::I64);
      _saJU::I64 = _cbNO::I64;
      switch [0 .. 1] _saJU::I64 {
          case 0 : goto cbNT;
          case 1 : goto cbPb;
      }
  cbPb:
      _cbNW::I64 = %MO_S_Lt_W64(_saJT::I64, _saJF::I64);
      _saJX::I64 = _cbNW::I64;
      switch [0 .. 1] _saJX::I64 {
          case 0 : goto cbO1;
          case 1 : goto cbOc;
      }
  cbOc:
      _saK1::P64 = P64[(_saJG::P64 + 24) + (_saJT::I64 << 3)];
      _saK1::P64 = _saK1::P64;
      Hp = Hp - 16;
      I64[(young<cbO4> + 8)] = cbO4;
      R1 = _saK1::P64;
      if (R1 & 7 != 0) goto cbO4; else goto cbO5;
  cbO5:
      call (I64[R1])(R1) returns to cbO4, args: 8, res: 8, upd: 8;
  cbO4:
      _saK2::P64 = R1;
      _saK3::P64 = P64[_saK2::P64 + 7];
      I64[(young<cbO9> + 8)] = cbO9;
      R1 = _saK3::P64;
      call stg_norec_readTVar#(R1) returns to cbO9, args: 8, res: 8, upd: 8;
  cbO9:
      _saK6::P64 = R1;
      I64[(young<cbOb> + 8)] = cbOb;
      R2 = _cbJV::P64;
      R1 = _saK3::P64;
      call stg_norec_writeTVar#(R2,
                                R1) returns to cbOb, args: 8, res: 8, upd: 8;
  cbOb:
      Hp = Hp + 16;
      if (Hp > HpLim) goto cbOk; else goto cbOj;
  cbOk:
      HpAlloc = 16;
      call stg_gc_noregs() returns to cbOb, args: 8, res: 8, upd: 8;
  cbOj:
      _cbOl::I64 = %MO_S_Le_W64(_saJ5::I64, _saJt::I64);
      _saK8::I64 = _cbOl::I64;
      switch [0 .. 1] _saK8::I64 {
          case 0 : goto cbOs;
          case 1 : goto cbPa;
      }
  cbPa:
      _cbOu::I64 = %MO_S_Le_W64(_saJt::I64, _saJ7::I64);
      _saKc::I64 = _cbOu::I64;
      switch [0 .. 1] _saKc::I64 {
          case 0 : goto cbOB;
          case 1 : goto cbP9;
      }
  cbP9:
      _cbOD::I64 = _saJt::I64 - _saJ5::I64;
      _saKg::I64 = _cbOD::I64;
      _cbOG::I64 = %MO_S_Le_W64(0, _saKg::I64);
      _saKh::I64 = _cbOG::I64;
      switch [0 .. 1] _saKh::I64 {
          case 0 : goto cbOL;
          case 1 : goto cbP8;
      }
  cbP8:
      _cbOO::I64 = %MO_S_Lt_W64(_saKg::I64, _saJ2::I64);
      _saKk::I64 = _cbOO::I64;
      switch [0 .. 1] _saKk::I64 {
          case 0 : goto cbOT;
          case 1 : goto cbP2;
      }
  cbP2:
      _saKo::P64 = P64[(_saJ3::P64 + 24) + (_saKg::I64 << 3)];
      _saKo::P64 = _saKo::P64;
      Hp = Hp - 16;
      I64[(young<cbOW> + 8)] = cbOW;
      R1 = _saKo::P64;
      if (R1 & 7 != 0) goto cbOW; else goto cbOX;
  cbOX:
      call (I64[R1])(R1) returns to cbOW, args: 8, res: 8, upd: 8;
  cbOW:
      _saKp::P64 = R1;
      _saKq::P64 = P64[_saKp::P64 + 7];
      I64[(young<cbP1> + 8)] = cbP1;
      R2 = _saK6::P64;
      R1 = _saKq::P64;
      call stg_norec_writeTVar#(R2,
                                R1) returns to cbP1, args: 8, res: 8, upd: 8;
  cbP1:
      _cbPp::I64 = _saJt::I64 + 1;
      _saKs::I64 = _cbPp::I64;
      _saJu::P64 = _saJB::P64;
      _saJt::I64 = _saKs::I64;
      goto cbMM;
  cbOT:
      Hp = Hp - 16;
      R3 = _saKg::I64;
      R2 = _saJ2::I64;
      call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
  cbOL:
      Hp = Hp - 16;
      R3 = _saKg::I64;
      R2 = _saJ2::I64;
      call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
  cbOB:
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _saJt::I64;
      _cbOz::P64 = Hp - 7;
      R4 = _saJ6::P64;
      R3 = _saJ4::P64;
      R2 = _cbOz::P64;
      call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbOs:
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _saJt::I64;
      _cbOq::P64 = Hp - 7;
      R4 = _saJ6::P64;
      R3 = _saJ4::P64;
      R2 = _cbOq::P64;
      call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbO1:
      Hp = Hp - 16;
      R3 = _saJT::I64;
      R2 = _saJF::I64;
      call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
  cbNT:
      Hp = Hp - 16;
      R3 = _saJT::I64;
      R2 = _saJF::I64;
      call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
  cbNJ:
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _saJt::I64;
      _cbNH::P64 = Hp - 7;
      R4 = _saJJ::P64;
      R3 = _saJH::P64;
      R2 = _cbNH::P64;
      call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbNA:
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _saJt::I64;
      _cbNy::P64 = Hp - 7;
      R4 = _saJJ::P64;
      R3 = _saJH::P64;
      R2 = _cbNy::P64;
      call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbN4:
      R1 = lvl40_rawz_closure;
      call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
  cbMv:
      R3 = _saJg::I64;
      R2 = _saJ2::I64;
      call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
  cbMn:
      R3 = _saJg::I64;
      R2 = _saJ2::I64;
      call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
  cbMc:
      R4 = _saJ6::P64;
      R3 = _saJ4::P64;
      R2 = stg_INTLIKE_closure+273;
      call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbM4:
      R4 = _saJ6::P64;
      R3 = _saJ4::P64;
      R2 = stg_INTLIKE_closure+273;
      call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbLp:
      R3 = _saIK::I64;
      R2 = _saIw::I64;
      call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
  cbLh:
      R3 = _saIK::I64;
      R2 = _saIw::I64;
      call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
  cbL6:
      R4 = _saIA::P64;
      R3 = _saIy::P64;
      R2 = stg_INTLIKE_closure+273;
      call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbKY:
      R4 = _saIA::P64;
      R3 = _saIy::P64;
      R2 = stg_INTLIKE_closure+273;
      call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbKw:
      R1 = lvl40_rawz_closure;
      call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:47.183419 UTC

{offset
  cbJO:
      _saFF::P64 = R6;
      _saFE::P64 = R5;
      _saFD::P64 = R4;
      _saFC::P64 = R3;
      _saFB::P64 = R2;
      _saFG::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto cbJX; else goto cbJY;
  cbJY:
      if (HpLim == 0) goto cbJX; else goto cbJZ;
  cbJX:
      R6 = _saFF::P64;
      R5 = _saFE::P64;
      R4 = _saFD::P64;
      R3 = _saFC::P64;
      R2 = _saFB::P64;
      R1 = SkipList.$wa4_closure;
      P64[(old + 16)] = _saFG::P64;
      call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
  cbJZ:
      I64[(young<cbD0> + 8)] = cbD0;
      R1 = _saFD::P64;
      call stg_norec_readTVar#(R1) returns to cbD0, args: 8, res: 8, upd: 8;
  cbD0:
      _saFK::P64 = R1;
      I64[(young<cbD2> + 8)] = cbD2;
      R1 = _saFK::P64;
      if (R1 & 7 != 0) goto cbD2; else goto cbD3;
  cbD3:
      call (I64[R1])(R1) returns to cbD2, args: 8, res: 8, upd: 8;
  cbD2:
      _saFL::P64 = R1;
      Hp = Hp + 64;
      if (Hp > HpLim) goto cbK3; else goto cbK2;
  cbK3:
      HpAlloc = 64;
      R1 = _saFL::P64;
      call stg_gc_unpt_r1(R1) returns to cbD2, args: 8, res: 8, upd: 8;
  cbK2:
      _saFM::I64 = I64[_saFL::P64 + 7];
      _cbD7::P64 = Hp - 52;
      _cbD8::P64 = Hp - 24;
      I64[Hp - 56] = $wa8_saFO_info;
      P64[Hp - 48] = _saFB::P64;
      P64[Hp - 40] = _saFF::P64;
      P64[Hp - 32] = _cbD8::P64;
      I64[Hp - 24] = $s$wa_saFN_info;
      P64[Hp - 16] = _saFB::P64;
      P64[Hp - 8] = _saFF::P64;
      P64[Hp] = _cbD7::P64;
      I64[(young<cbHA> + 8)] = cbHA;
      R4 = GHC.Types.[]_closure+1;
      R3 = _saFM::I64;
      R2 = _saFC::P64;
      R1 = _cbD7::P64;
      call $wa8_saFO_info(R4,
                          R3,
                          R2,
                          R1) returns to cbHA, args: 8, res: 8, upd: 8;
  cbHA:
      _saHj::P64 = R1;
      I64[(young<cbHC> + 8)] = cbHC;
      call stg_myThreadId#() returns to cbHC, args: 8, res: 8, upd: 8;
  cbHC:
      _saHm::P64 = R1;
      I64[(young<cbHE> + 8)] = cbHE;
      R1 = _saHm::P64;
      call stg_threadStatus#(R1) returns to cbHE, args: 8, res: 8, upd: 8;
  cbHE:
      _saHr::I64 = R3;
      _saHq::I64 = R2;
      _saHp::I64 = R1;
      goto cbHF;
  cbHF:
      Hp = Hp + 72;
      if (Hp > HpLim) goto cbK8; else goto cbK7;
  cbK8:
      HpAlloc = 72;
      I64[(young<cbHG> + 8)] = cbHG;
      call stg_gc_noregs() returns to cbHG, args: 8, res: 8, upd: 8;
  cbHG:
      goto cbHF;
  cbK7:
      I64[Hp - 64] = nodesHeight_saHs_info;
      P64[Hp - 48] = _saFE::P64;
      P64[Hp - 40] = _saFL::P64;
      I64[Hp - 32] = _saFM::I64;
      I64[Hp - 24] = _saHq::I64;
      _cbHI::P64 = Hp - 64;
      I64[Hp - 16] = (,)_con_info;
      P64[Hp - 8] = SkipList.newSL10_closure+1;
      P64[Hp] = _cbHI::P64;
      _cbJP::P64 = Hp - 15;
      I64[(young<cbJQ> + 8)] = cbJQ;
      R3 = _cbJP::P64;
      R2 = GHC.Arr.$fIxInt_closure;
      call SkipList.$fMArrayTArrayeSTM8_info(R3,
                                             R2) returns to cbJQ, args: 8, res: 8, upd: 8;
  cbJQ:
      _saIf::P64 = R1;
      I64[(young<cbJS> + 8)] = cbJS;
      R1 = _saFG::P64;
      call stg_newNOrecTVar#(R1) returns to cbJS, args: 8, res: 8, upd: 8;
  cbJS:
      _saIi::P64 = R1;
      Hp = Hp + 48;
      if (Hp > HpLim) goto cbKc; else goto cbKb;
  cbKc:
      HpAlloc = 48;
      R1 = _saIi::P64;
      call stg_gc_unpt_r1(R1) returns to cbJS, args: 8, res: 8, upd: 8;
  cbKb:
      I64[Hp - 40] = GHC.Conc.Sync.TVar_con_info;
      P64[Hp - 32] = _saIi::P64;
      _cbJU::P64 = Hp - 39;
      I64[Hp - 24] = SkipList.Node_con_info;
      P64[Hp - 16] = _saFF::P64;
      P64[Hp - 8] = _cbJU::P64;
      P64[Hp] = _saIf::P64;
      _cbJV::P64 = Hp - 22;
      I64[(young<cbJW> + 8)] = cbJW;
      R1 = _cbHI::P64;
      if (R1 & 7 != 0) goto cbJW; else goto cbKd;
  cbKd:
      call (I64[R1])(R1) returns to cbJW, args: 8, res: 8, upd: 8;
  cbJW:
      _saIl::P64 = R1;
      _saIm::I64 = I64[_saIl::P64 + 7];
      _cbKi::I64 = %MO_S_Gt_W64(1, _saIm::I64);
      _saIn::I64 = _cbKi::I64;
      switch [0 .. 1] _saIn::I64 {
          case 0 : goto cbKp;
          case 1 : goto cbPm;
      }
  cbKp:
      I64[(young<cbKn> + 8)] = cbKn;
      R1 = _saHj::P64;
      if (R1 & 7 != 0) goto cbKn; else goto cbKq;
  cbKq:
      call (I64[R1])(R1) returns to cbKn, args: 8, res: 8, upd: 8;
  cbKn:
      _saIp::P64 = R1;
      _cbPn::P64 = _saIp::P64 & 7;
      switch [1 .. 2] _cbPn::P64 {
          case 1 : goto cbN4;
          case 2 : goto cbKL;
      }
  cbKL:
      _saIr::P64 = P64[_saIp::P64 + 6];
      _saIs::P64 = P64[_saIp::P64 + 14];
      I64[(young<cbKz> + 8)] = cbKz;
      R1 = _saIr::P64;
      if (R1 & 7 != 0) goto cbKz; else goto cbKA;
  cbKA:
      call (I64[R1])(R1) returns to cbKz, args: 8, res: 8, upd: 8;
  cbKz:
      _saIt::P64 = R1;
      _saIu::P64 = P64[_saIt::P64 + 7];
      _saIv::P64 = P64[_saIt::P64 + 15];
      _saIx::P64 = P64[_saIt::P64 + 23];
      _saIw::I64 = I64[_saIt::P64 + 31];
      I64[(young<cbKE> + 8)] = cbKE;
      R1 = _saIu::P64;
      if (R1 & 7 != 0) goto cbKE; else goto cbKF;
  cbKF:
      call (I64[R1])(R1) returns to cbKE, args: 8, res: 8, upd: 8;
  cbKE:
      _saIy::P64 = R1;
      _saIz::I64 = I64[_saIy::P64 + 7];
      I64[(young<cbKJ> + 8)] = cbKJ;
      R1 = _saIv::P64;
      if (R1 & 7 != 0) goto cbKJ; else goto cbKO;
  cbKO:
      call (I64[R1])(R1) returns to cbKJ, args: 8, res: 8, upd: 8;
  cbKJ:
      _saIA::P64 = R1;
      _saIB::I64 = I64[_saIA::P64 + 7];
      _cbKT::I64 = %MO_S_Le_W64(_saIz::I64, 1);
      _saIC::I64 = _cbKT::I64;
      switch [0 .. 1] _saIC::I64 {
          case 0 : goto cbL6;
          case 1 : goto cbPl;
      }
  cbPl:
      _cbL1::I64 = %MO_S_Le_W64(1, _saIB::I64);
      _saIG::I64 = _cbL1::I64;
      switch [0 .. 1] _saIG::I64 {
          case 0 : goto cbL6;
          case 1 : goto cbPk;
      }
  cbPk:
      _cbL9::I64 = 1 - _saIz::I64;
      _saIK::I64 = _cbL9::I64;
      _cbLc::I64 = %MO_S_Le_W64(0, _saIK::I64);
      _saIL::I64 = _cbLc::I64;
      switch [0 .. 1] _saIL::I64 {
          case 0 : goto cbLp;
          case 1 : goto cbPj;
      }
  cbPj:
      _cbLk::I64 = %MO_S_Lt_W64(_saIK::I64, _saIw::I64);
      _saIO::I64 = _cbLk::I64;
      switch [0 .. 1] _saIO::I64 {
          case 0 : goto cbLp;
          case 1 : goto cbLO;
      }
  cbLO:
      _saIS::P64 = P64[(_saIx::P64 + 24) + (_saIK::I64 << 3)];
      _saIS::P64 = _saIS::P64;
      I64[(young<cbLs> + 8)] = cbLs;
      R1 = _saIS::P64;
      if (R1 & 7 != 0) goto cbLs; else goto cbLt;
  cbLt:
      call (I64[R1])(R1) returns to cbLs, args: 8, res: 8, upd: 8;
  cbLs:
      _saIT::P64 = R1;
      _saIU::P64 = P64[_saIT::P64 + 7];
      I64[(young<cbLx> + 8)] = cbLx;
      R1 = _saIU::P64;
      call stg_norec_readTVar#(R1) returns to cbLx, args: 8, res: 8, upd: 8;
  cbLx:
      _saIX::P64 = R1;
      I64[(young<cbLz> + 8)] = cbLz;
      R2 = _cbJV::P64;
      R1 = _saIU::P64;
      call stg_norec_writeTVar#(R2,
                                R1) returns to cbLz, args: 8, res: 8, upd: 8;
  cbLz:
      I64[(young<cbLD> + 8)] = cbLD;
      R1 = _saIf::P64;
      if (R1 & 7 != 0) goto cbLD; else goto cbLE;
  cbLE:
      call (I64[R1])(R1) returns to cbLD, args: 8, res: 8, upd: 8;
  cbLD:
      _saIZ::P64 = R1;
      _saJ0::P64 = P64[_saIZ::P64 + 7];
      _saJ1::P64 = P64[_saIZ::P64 + 15];
      _saJ3::P64 = P64[_saIZ::P64 + 23];
      _saJ2::I64 = I64[_saIZ::P64 + 31];
      I64[(young<cbLI> + 8)] = cbLI;
      R1 = _saJ0::P64;
      if (R1 & 7 != 0) goto cbLI; else goto cbLJ;
  cbLJ:
      call (I64[R1])(R1) returns to cbLI, args: 8, res: 8, upd: 8;
  cbLI:
      _saJ4::P64 = R1;
      _saJ5::I64 = I64[_saJ4::P64 + 7];
      I64[(young<cbLN> + 8)] = cbLN;
      R1 = _saJ1::P64;
      if (R1 & 7 != 0) goto cbLN; else goto cbLU;
  cbLU:
      call (I64[R1])(R1) returns to cbLN, args: 8, res: 8, upd: 8;
  cbLN:
      _saJ6::P64 = R1;
      _saJ7::I64 = I64[_saJ6::P64 + 7];
      _cbLZ::I64 = %MO_S_Le_W64(_saJ5::I64, 1);
      _saJ8::I64 = _cbLZ::I64;
      switch [0 .. 1] _saJ8::I64 {
          case 0 : goto cbMc;
          case 1 : goto cbPi;
      }
  cbPi:
      _cbM7::I64 = %MO_S_Le_W64(1, _saJ7::I64);
      _saJc::I64 = _cbM7::I64;
      switch [0 .. 1] _saJc::I64 {
          case 0 : goto cbMc;
          case 1 : goto cbPh;
      }
  cbPh:
      _cbMf::I64 = 1 - _saJ5::I64;
      _saJg::I64 = _cbMf::I64;
      _cbMi::I64 = %MO_S_Le_W64(0, _saJg::I64);
      _saJh::I64 = _cbMi::I64;
      switch [0 .. 1] _saJh::I64 {
          case 0 : goto cbMv;
          case 1 : goto cbPg;
      }
  cbPg:
      _cbMq::I64 = %MO_S_Lt_W64(_saJg::I64, _saJ2::I64);
      _saJk::I64 = _cbMq::I64;
      switch [0 .. 1] _saJk::I64 {
          case 0 : goto cbMv;
          case 1 : goto cbME;
      }
  cbME:
      _saJo::P64 = P64[(_saJ3::P64 + 24) + (_saJg::I64 << 3)];
      _saJo::P64 = _saJo::P64;
      I64[(young<cbMy> + 8)] = cbMy;
      R1 = _saJo::P64;
      if (R1 & 7 != 0) goto cbMy; else goto cbMz;
  cbMz:
      call (I64[R1])(R1) returns to cbMy, args: 8, res: 8, upd: 8;
  cbMy:
      _saJp::P64 = R1;
      _saJq::P64 = P64[_saJp::P64 + 7];
      I64[(young<cbMD> + 8)] = cbMD;
      R2 = _saIX::P64;
      R1 = _saJq::P64;
      call stg_norec_writeTVar#(R2,
                                R1) returns to cbMD, args: 8, res: 8, upd: 8;
  cbMD:
      _saJu::P64 = _saIs::P64;
      _saJt::I64 = 2;
      goto cbMM;
  cbMM:
      if (HpLim == 0) goto cbMP; else goto cbPf;
  cbMP:
      I64[(young<cbMN> + 8)] = cbMN;
      call stg_gc_noregs() returns to cbMN, args: 8, res: 8, upd: 8;
  cbMN:
      goto cbMM;
  cbPf:
      _cbMQ::I64 = %MO_S_Gt_W64(_saJt::I64, _saIm::I64);
      _saJw::I64 = _cbMQ::I64;
      switch [0 .. 1] _saJw::I64 {
          case 0 : goto cbMX;
          case 1 : goto cbPm;
      }
  cbPm:
      R1 = GHC.Tuple.()_closure+1;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
  cbMX:
      I64[(young<cbMV> + 8)] = cbMV;
      R1 = _saJu::P64;
      if (R1 & 7 != 0) goto cbMV; else goto cbMY;
  cbMY:
      call (I64[R1])(R1) returns to cbMV, args: 8, res: 8, upd: 8;
  cbMV:
      _saJy::P64 = R1;
      _cbPo::P64 = _saJy::P64 & 7;
      switch [1 .. 2] _cbPo::P64 {
          case 1 : goto cbN4;
          case 2 : goto cbNj;
      }
  cbNj:
      _saJA::P64 = P64[_saJy::P64 + 6];
      _saJB::P64 = P64[_saJy::P64 + 14];
      I64[(young<cbN7> + 8)] = cbN7;
      R1 = _saJA::P64;
      if (R1 & 7 != 0) goto cbN7; else goto cbN8;
  cbN8:
      call (I64[R1])(R1) returns to cbN7, args: 8, res: 8, upd: 8;
  cbN7:
      _saJC::P64 = R1;
      _saJD::P64 = P64[_saJC::P64 + 7];
      _saJE::P64 = P64[_saJC::P64 + 15];
      _saJG::P64 = P64[_saJC::P64 + 23];
      _saJF::I64 = I64[_saJC::P64 + 31];
      I64[(young<cbNc> + 8)] = cbNc;
      R1 = _saJD::P64;
      if (R1 & 7 != 0) goto cbNc; else goto cbNd;
  cbNd:
      call (I64[R1])(R1) returns to cbNc, args: 8, res: 8, upd: 8;
  cbNc:
      _saJH::P64 = R1;
      _saJI::I64 = I64[_saJH::P64 + 7];
      I64[(young<cbNh> + 8)] = cbNh;
      R1 = _saJE::P64;
      if (R1 & 7 != 0) goto cbNh; else goto cbNm;
  cbNm:
      call (I64[R1])(R1) returns to cbNh, args: 8, res: 8, upd: 8;
  cbNh:
      _saJJ::P64 = R1;
      Hp = Hp + 16;
      if (Hp > HpLim) goto cbNs; else goto cbNr;
  cbNs:
      HpAlloc = 16;
      R1 = _saJJ::P64;
      call stg_gc_unpt_r1(R1) returns to cbNh, args: 8, res: 8, upd: 8;
  cbNr:
      _saJK::I64 = I64[_saJJ::P64 + 7];
      _cbNt::I64 = %MO_S_Le_W64(_saJI::I64, _saJt::I64);
      _saJL::I64 = _cbNt::I64;
      switch [0 .. 1] _saJL::I64 {
          case 0 : goto cbNA;
          case 1 : goto cbPd;
      }
  cbPd:
      _cbNC::I64 = %MO_S_Le_W64(_saJt::I64, _saJK::I64);
      _saJP::I64 = _cbNC::I64;
      switch [0 .. 1] _saJP::I64 {
          case 0 : goto cbNJ;
          case 1 : goto cbPc;
      }
  cbPc:
      _cbNL::I64 = _saJt::I64 - _saJI::I64;
      _saJT::I64 = _cbNL::I64;
      _cbNO::I64 = %MO_S_Le_W64(0, _saJT::I64);
      _saJU::I64 = _cbNO::I64;
      switch [0 .. 1] _saJU::I64 {
          case 0 : goto cbO1;
          case 1 : goto cbPb;
      }
  cbPb:
      _cbNW::I64 = %MO_S_Lt_W64(_saJT::I64, _saJF::I64);
      _saJX::I64 = _cbNW::I64;
      switch [0 .. 1] _saJX::I64 {
          case 0 : goto cbO1;
          case 1 : goto cbOc;
      }
  cbOc:
      _saK1::P64 = P64[(_saJG::P64 + 24) + (_saJT::I64 << 3)];
      _saK1::P64 = _saK1::P64;
      Hp = Hp - 16;
      I64[(young<cbO4> + 8)] = cbO4;
      R1 = _saK1::P64;
      if (R1 & 7 != 0) goto cbO4; else goto cbO5;
  cbO5:
      call (I64[R1])(R1) returns to cbO4, args: 8, res: 8, upd: 8;
  cbO4:
      _saK2::P64 = R1;
      _saK3::P64 = P64[_saK2::P64 + 7];
      I64[(young<cbO9> + 8)] = cbO9;
      R1 = _saK3::P64;
      call stg_norec_readTVar#(R1) returns to cbO9, args: 8, res: 8, upd: 8;
  cbO9:
      _saK6::P64 = R1;
      I64[(young<cbOb> + 8)] = cbOb;
      R2 = _cbJV::P64;
      R1 = _saK3::P64;
      call stg_norec_writeTVar#(R2,
                                R1) returns to cbOb, args: 8, res: 8, upd: 8;
  cbOb:
      Hp = Hp + 16;
      if (Hp > HpLim) goto cbOk; else goto cbOj;
  cbOk:
      HpAlloc = 16;
      call stg_gc_noregs() returns to cbOb, args: 8, res: 8, upd: 8;
  cbOj:
      _cbOl::I64 = %MO_S_Le_W64(_saJ5::I64, _saJt::I64);
      _saK8::I64 = _cbOl::I64;
      switch [0 .. 1] _saK8::I64 {
          case 0 : goto cbOs;
          case 1 : goto cbPa;
      }
  cbPa:
      _cbOu::I64 = %MO_S_Le_W64(_saJt::I64, _saJ7::I64);
      _saKc::I64 = _cbOu::I64;
      switch [0 .. 1] _saKc::I64 {
          case 0 : goto cbOB;
          case 1 : goto cbP9;
      }
  cbP9:
      _cbOD::I64 = _saJt::I64 - _saJ5::I64;
      _saKg::I64 = _cbOD::I64;
      _cbOG::I64 = %MO_S_Le_W64(0, _saKg::I64);
      _saKh::I64 = _cbOG::I64;
      switch [0 .. 1] _saKh::I64 {
          case 0 : goto cbOT;
          case 1 : goto cbP8;
      }
  cbP8:
      _cbOO::I64 = %MO_S_Lt_W64(_saKg::I64, _saJ2::I64);
      _saKk::I64 = _cbOO::I64;
      switch [0 .. 1] _saKk::I64 {
          case 0 : goto cbOT;
          case 1 : goto cbP2;
      }
  cbP2:
      _saKo::P64 = P64[(_saJ3::P64 + 24) + (_saKg::I64 << 3)];
      _saKo::P64 = _saKo::P64;
      Hp = Hp - 16;
      I64[(young<cbOW> + 8)] = cbOW;
      R1 = _saKo::P64;
      if (R1 & 7 != 0) goto cbOW; else goto cbOX;
  cbOX:
      call (I64[R1])(R1) returns to cbOW, args: 8, res: 8, upd: 8;
  cbOW:
      _saKp::P64 = R1;
      _saKq::P64 = P64[_saKp::P64 + 7];
      I64[(young<cbP1> + 8)] = cbP1;
      R2 = _saK6::P64;
      R1 = _saKq::P64;
      call stg_norec_writeTVar#(R2,
                                R1) returns to cbP1, args: 8, res: 8, upd: 8;
  cbP1:
      _cbPp::I64 = _saJt::I64 + 1;
      _saKs::I64 = _cbPp::I64;
      _saJu::P64 = _saJB::P64;
      _saJt::I64 = _saKs::I64;
      goto cbMM;
  cbOT:
      Hp = Hp - 16;
      R3 = _saKg::I64;
      R2 = _saJ2::I64;
      call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
  cbOB:
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _saJt::I64;
      _cbOz::P64 = Hp - 7;
      R4 = _saJ6::P64;
      R3 = _saJ4::P64;
      R2 = _cbOz::P64;
      call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbOs:
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _saJt::I64;
      _cbOq::P64 = Hp - 7;
      R4 = _saJ6::P64;
      R3 = _saJ4::P64;
      R2 = _cbOq::P64;
      call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbO1:
      Hp = Hp - 16;
      R3 = _saJT::I64;
      R2 = _saJF::I64;
      call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
  cbNJ:
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _saJt::I64;
      _cbNH::P64 = Hp - 7;
      R4 = _saJJ::P64;
      R3 = _saJH::P64;
      R2 = _cbNH::P64;
      call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbNA:
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _saJt::I64;
      _cbNy::P64 = Hp - 7;
      R4 = _saJJ::P64;
      R3 = _saJH::P64;
      R2 = _cbNy::P64;
      call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbMv:
      R3 = _saJg::I64;
      R2 = _saJ2::I64;
      call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
  cbMc:
      R4 = _saJ6::P64;
      R3 = _saJ4::P64;
      R2 = stg_INTLIKE_closure+273;
      call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbLp:
      R3 = _saIK::I64;
      R2 = _saIw::I64;
      call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
  cbL6:
      R4 = _saIA::P64;
      R3 = _saIy::P64;
      R2 = stg_INTLIKE_closure+273;
      call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbN4:
      R1 = lvl40_rawz_closure;
      call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:47.208075 UTC

{offset
  cbJO:
      _saFF::P64 = R6;
      _saFE::P64 = R5;
      _saFD::P64 = R4;
      _saFC::P64 = R3;
      _saFB::P64 = R2;
      _saFG::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto cbJX; else goto cbJY;
  cbJY:
      if (HpLim == 0) goto cbJX; else goto cbJZ;
  cbJX:
      R6 = _saFF::P64;
      R5 = _saFE::P64;
      R4 = _saFD::P64;
      R3 = _saFC::P64;
      R2 = _saFB::P64;
      R1 = SkipList.$wa4_closure;
      P64[(old + 16)] = _saFG::P64;
      call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
  cbJZ:
      I64[(young<cbD0> + 8)] = cbD0;
      R1 = _saFD::P64;
      call stg_norec_readTVar#(R1) returns to cbD0, args: 8, res: 8, upd: 8;
  cbD0:
      _saFK::P64 = R1;
      I64[(young<cbD2> + 8)] = cbD2;
      R1 = _saFK::P64;
      if (R1 & 7 != 0) goto cbD2; else goto cbD3;
  cbD3:
      call (I64[R1])(R1) returns to cbD2, args: 8, res: 8, upd: 8;
  cbD2:
      _saFL::P64 = R1;
      Hp = Hp + 64;
      if (Hp > HpLim) goto cbK3; else goto cbK2;
  cbK3:
      HpAlloc = 64;
      R1 = _saFL::P64;
      call stg_gc_unpt_r1(R1) returns to cbD2, args: 8, res: 8, upd: 8;
  cbK2:
      _saFM::I64 = I64[_saFL::P64 + 7];
      _cbD7::P64 = Hp - 52;
      _cbD8::P64 = Hp - 24;
      I64[Hp - 56] = $wa8_saFO_info;
      P64[Hp - 48] = _saFB::P64;
      P64[Hp - 40] = _saFF::P64;
      P64[Hp - 32] = _cbD8::P64;
      I64[Hp - 24] = $s$wa_saFN_info;
      P64[Hp - 16] = _saFB::P64;
      P64[Hp - 8] = _saFF::P64;
      P64[Hp] = _cbD7::P64;
      I64[(young<cbHA> + 8)] = cbHA;
      R4 = GHC.Types.[]_closure+1;
      R3 = _saFM::I64;
      R2 = _saFC::P64;
      R1 = _cbD7::P64;
      call $wa8_saFO_info(R4,
                          R3,
                          R2,
                          R1) returns to cbHA, args: 8, res: 8, upd: 8;
  cbHA:
      _saHj::P64 = R1;
      I64[(young<cbHC> + 8)] = cbHC;
      call stg_myThreadId#() returns to cbHC, args: 8, res: 8, upd: 8;
  cbHC:
      _saHm::P64 = R1;
      I64[(young<cbHE> + 8)] = cbHE;
      R1 = _saHm::P64;
      call stg_threadStatus#(R1) returns to cbHE, args: 8, res: 8, upd: 8;
  cbHE:
      _saHr::I64 = R3;
      _saHq::I64 = R2;
      _saHp::I64 = R1;
      goto cbHF;
  cbHF:
      Hp = Hp + 72;
      if (Hp > HpLim) goto cbK8; else goto cbK7;
  cbK8:
      HpAlloc = 72;
      I64[(young<cbHG> + 8)] = cbHG;
      call stg_gc_noregs() returns to cbHG, args: 8, res: 8, upd: 8;
  cbHG:
      goto cbHF;
  cbK7:
      I64[Hp - 64] = nodesHeight_saHs_info;
      P64[Hp - 48] = _saFE::P64;
      P64[Hp - 40] = _saFL::P64;
      I64[Hp - 32] = _saFM::I64;
      I64[Hp - 24] = _saHq::I64;
      _cbHI::P64 = Hp - 64;
      I64[Hp - 16] = (,)_con_info;
      P64[Hp - 8] = SkipList.newSL10_closure+1;
      P64[Hp] = _cbHI::P64;
      _cbJP::P64 = Hp - 15;
      I64[(young<cbJQ> + 8)] = cbJQ;
      R3 = _cbJP::P64;
      R2 = GHC.Arr.$fIxInt_closure;
      call SkipList.$fMArrayTArrayeSTM8_info(R3,
                                             R2) returns to cbJQ, args: 8, res: 8, upd: 8;
  cbJQ:
      _saIf::P64 = R1;
      I64[(young<cbJS> + 8)] = cbJS;
      R1 = _saFG::P64;
      call stg_newNOrecTVar#(R1) returns to cbJS, args: 8, res: 8, upd: 8;
  cbJS:
      _saIi::P64 = R1;
      Hp = Hp + 48;
      if (Hp > HpLim) goto cbKc; else goto cbKb;
  cbKc:
      HpAlloc = 48;
      R1 = _saIi::P64;
      call stg_gc_unpt_r1(R1) returns to cbJS, args: 8, res: 8, upd: 8;
  cbKb:
      I64[Hp - 40] = GHC.Conc.Sync.TVar_con_info;
      P64[Hp - 32] = _saIi::P64;
      _cbJU::P64 = Hp - 39;
      I64[Hp - 24] = SkipList.Node_con_info;
      P64[Hp - 16] = _saFF::P64;
      P64[Hp - 8] = _cbJU::P64;
      P64[Hp] = _saIf::P64;
      _cbJV::P64 = Hp - 22;
      I64[(young<cbJW> + 8)] = cbJW;
      R1 = _cbHI::P64;
      if (R1 & 7 != 0) goto cbJW; else goto cbKd;
  cbKd:
      call (I64[R1])(R1) returns to cbJW, args: 8, res: 8, upd: 8;
  cbJW:
      _saIl::P64 = R1;
      _saIm::I64 = I64[_saIl::P64 + 7];
      _cbKi::I64 = %MO_S_Gt_W64(1, _saIm::I64);
      _saIn::I64 = _cbKi::I64;
      if (_saIn::I64 != 0) goto cbPm; else goto cbKp;
  cbKp:
      I64[(young<cbKn> + 8)] = cbKn;
      R1 = _saHj::P64;
      if (R1 & 7 != 0) goto cbKn; else goto cbKq;
  cbKq:
      call (I64[R1])(R1) returns to cbKn, args: 8, res: 8, upd: 8;
  cbKn:
      _saIp::P64 = R1;
      _cbPn::P64 = _saIp::P64 & 7;
      if (_cbPn::P64 != 1) goto cbKL; else goto cbN4;
  cbKL:
      _saIr::P64 = P64[_saIp::P64 + 6];
      _saIs::P64 = P64[_saIp::P64 + 14];
      I64[(young<cbKz> + 8)] = cbKz;
      R1 = _saIr::P64;
      if (R1 & 7 != 0) goto cbKz; else goto cbKA;
  cbKA:
      call (I64[R1])(R1) returns to cbKz, args: 8, res: 8, upd: 8;
  cbKz:
      _saIt::P64 = R1;
      _saIu::P64 = P64[_saIt::P64 + 7];
      _saIv::P64 = P64[_saIt::P64 + 15];
      _saIx::P64 = P64[_saIt::P64 + 23];
      _saIw::I64 = I64[_saIt::P64 + 31];
      I64[(young<cbKE> + 8)] = cbKE;
      R1 = _saIu::P64;
      if (R1 & 7 != 0) goto cbKE; else goto cbKF;
  cbKF:
      call (I64[R1])(R1) returns to cbKE, args: 8, res: 8, upd: 8;
  cbKE:
      _saIy::P64 = R1;
      _saIz::I64 = I64[_saIy::P64 + 7];
      I64[(young<cbKJ> + 8)] = cbKJ;
      R1 = _saIv::P64;
      if (R1 & 7 != 0) goto cbKJ; else goto cbKO;
  cbKO:
      call (I64[R1])(R1) returns to cbKJ, args: 8, res: 8, upd: 8;
  cbKJ:
      _saIA::P64 = R1;
      _saIB::I64 = I64[_saIA::P64 + 7];
      _cbKT::I64 = %MO_S_Le_W64(_saIz::I64, 1);
      _saIC::I64 = _cbKT::I64;
      if (_saIC::I64 != 0) goto cbPl; else goto cbL6;
  cbPl:
      _cbL1::I64 = %MO_S_Le_W64(1, _saIB::I64);
      _saIG::I64 = _cbL1::I64;
      if (_saIG::I64 != 0) goto cbPk; else goto cbL6;
  cbPk:
      _cbL9::I64 = 1 - _saIz::I64;
      _saIK::I64 = _cbL9::I64;
      _cbLc::I64 = %MO_S_Le_W64(0, _saIK::I64);
      _saIL::I64 = _cbLc::I64;
      if (_saIL::I64 != 0) goto cbPj; else goto cbLp;
  cbPj:
      _cbLk::I64 = %MO_S_Lt_W64(_saIK::I64, _saIw::I64);
      _saIO::I64 = _cbLk::I64;
      if (_saIO::I64 != 0) goto cbLO; else goto cbLp;
  cbLO:
      _saIS::P64 = P64[(_saIx::P64 + 24) + (_saIK::I64 << 3)];
      _saIS::P64 = _saIS::P64;
      I64[(young<cbLs> + 8)] = cbLs;
      R1 = _saIS::P64;
      if (R1 & 7 != 0) goto cbLs; else goto cbLt;
  cbLt:
      call (I64[R1])(R1) returns to cbLs, args: 8, res: 8, upd: 8;
  cbLs:
      _saIT::P64 = R1;
      _saIU::P64 = P64[_saIT::P64 + 7];
      I64[(young<cbLx> + 8)] = cbLx;
      R1 = _saIU::P64;
      call stg_norec_readTVar#(R1) returns to cbLx, args: 8, res: 8, upd: 8;
  cbLx:
      _saIX::P64 = R1;
      I64[(young<cbLz> + 8)] = cbLz;
      R2 = _cbJV::P64;
      R1 = _saIU::P64;
      call stg_norec_writeTVar#(R2,
                                R1) returns to cbLz, args: 8, res: 8, upd: 8;
  cbLz:
      I64[(young<cbLD> + 8)] = cbLD;
      R1 = _saIf::P64;
      if (R1 & 7 != 0) goto cbLD; else goto cbLE;
  cbLE:
      call (I64[R1])(R1) returns to cbLD, args: 8, res: 8, upd: 8;
  cbLD:
      _saIZ::P64 = R1;
      _saJ0::P64 = P64[_saIZ::P64 + 7];
      _saJ1::P64 = P64[_saIZ::P64 + 15];
      _saJ3::P64 = P64[_saIZ::P64 + 23];
      _saJ2::I64 = I64[_saIZ::P64 + 31];
      I64[(young<cbLI> + 8)] = cbLI;
      R1 = _saJ0::P64;
      if (R1 & 7 != 0) goto cbLI; else goto cbLJ;
  cbLJ:
      call (I64[R1])(R1) returns to cbLI, args: 8, res: 8, upd: 8;
  cbLI:
      _saJ4::P64 = R1;
      _saJ5::I64 = I64[_saJ4::P64 + 7];
      I64[(young<cbLN> + 8)] = cbLN;
      R1 = _saJ1::P64;
      if (R1 & 7 != 0) goto cbLN; else goto cbLU;
  cbLU:
      call (I64[R1])(R1) returns to cbLN, args: 8, res: 8, upd: 8;
  cbLN:
      _saJ6::P64 = R1;
      _saJ7::I64 = I64[_saJ6::P64 + 7];
      _cbLZ::I64 = %MO_S_Le_W64(_saJ5::I64, 1);
      _saJ8::I64 = _cbLZ::I64;
      if (_saJ8::I64 != 0) goto cbPi; else goto cbMc;
  cbPi:
      _cbM7::I64 = %MO_S_Le_W64(1, _saJ7::I64);
      _saJc::I64 = _cbM7::I64;
      if (_saJc::I64 != 0) goto cbPh; else goto cbMc;
  cbPh:
      _cbMf::I64 = 1 - _saJ5::I64;
      _saJg::I64 = _cbMf::I64;
      _cbMi::I64 = %MO_S_Le_W64(0, _saJg::I64);
      _saJh::I64 = _cbMi::I64;
      if (_saJh::I64 != 0) goto cbPg; else goto cbMv;
  cbPg:
      _cbMq::I64 = %MO_S_Lt_W64(_saJg::I64, _saJ2::I64);
      _saJk::I64 = _cbMq::I64;
      if (_saJk::I64 != 0) goto cbME; else goto cbMv;
  cbME:
      _saJo::P64 = P64[(_saJ3::P64 + 24) + (_saJg::I64 << 3)];
      _saJo::P64 = _saJo::P64;
      I64[(young<cbMy> + 8)] = cbMy;
      R1 = _saJo::P64;
      if (R1 & 7 != 0) goto cbMy; else goto cbMz;
  cbMz:
      call (I64[R1])(R1) returns to cbMy, args: 8, res: 8, upd: 8;
  cbMy:
      _saJp::P64 = R1;
      _saJq::P64 = P64[_saJp::P64 + 7];
      I64[(young<cbMD> + 8)] = cbMD;
      R2 = _saIX::P64;
      R1 = _saJq::P64;
      call stg_norec_writeTVar#(R2,
                                R1) returns to cbMD, args: 8, res: 8, upd: 8;
  cbMD:
      _saJu::P64 = _saIs::P64;
      _saJt::I64 = 2;
      goto cbMM;
  cbMM:
      if (HpLim == 0) goto cbMP; else goto cbPf;
  cbMP:
      I64[(young<cbMN> + 8)] = cbMN;
      call stg_gc_noregs() returns to cbMN, args: 8, res: 8, upd: 8;
  cbMN:
      goto cbMM;
  cbPf:
      _cbMQ::I64 = %MO_S_Gt_W64(_saJt::I64, _saIm::I64);
      _saJw::I64 = _cbMQ::I64;
      if (_saJw::I64 != 0) goto cbPm; else goto cbMX;
  cbPm:
      R1 = GHC.Tuple.()_closure+1;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
  cbMX:
      I64[(young<cbMV> + 8)] = cbMV;
      R1 = _saJu::P64;
      if (R1 & 7 != 0) goto cbMV; else goto cbMY;
  cbMY:
      call (I64[R1])(R1) returns to cbMV, args: 8, res: 8, upd: 8;
  cbMV:
      _saJy::P64 = R1;
      _cbPo::P64 = _saJy::P64 & 7;
      if (_cbPo::P64 != 1) goto cbNj; else goto cbN4;
  cbNj:
      _saJA::P64 = P64[_saJy::P64 + 6];
      _saJB::P64 = P64[_saJy::P64 + 14];
      I64[(young<cbN7> + 8)] = cbN7;
      R1 = _saJA::P64;
      if (R1 & 7 != 0) goto cbN7; else goto cbN8;
  cbN8:
      call (I64[R1])(R1) returns to cbN7, args: 8, res: 8, upd: 8;
  cbN7:
      _saJC::P64 = R1;
      _saJD::P64 = P64[_saJC::P64 + 7];
      _saJE::P64 = P64[_saJC::P64 + 15];
      _saJG::P64 = P64[_saJC::P64 + 23];
      _saJF::I64 = I64[_saJC::P64 + 31];
      I64[(young<cbNc> + 8)] = cbNc;
      R1 = _saJD::P64;
      if (R1 & 7 != 0) goto cbNc; else goto cbNd;
  cbNd:
      call (I64[R1])(R1) returns to cbNc, args: 8, res: 8, upd: 8;
  cbNc:
      _saJH::P64 = R1;
      _saJI::I64 = I64[_saJH::P64 + 7];
      I64[(young<cbNh> + 8)] = cbNh;
      R1 = _saJE::P64;
      if (R1 & 7 != 0) goto cbNh; else goto cbNm;
  cbNm:
      call (I64[R1])(R1) returns to cbNh, args: 8, res: 8, upd: 8;
  cbNh:
      _saJJ::P64 = R1;
      Hp = Hp + 16;
      if (Hp > HpLim) goto cbNs; else goto cbNr;
  cbNs:
      HpAlloc = 16;
      R1 = _saJJ::P64;
      call stg_gc_unpt_r1(R1) returns to cbNh, args: 8, res: 8, upd: 8;
  cbNr:
      _saJK::I64 = I64[_saJJ::P64 + 7];
      _cbNt::I64 = %MO_S_Le_W64(_saJI::I64, _saJt::I64);
      _saJL::I64 = _cbNt::I64;
      if (_saJL::I64 != 0) goto cbPd; else goto cbNA;
  cbPd:
      _cbNC::I64 = %MO_S_Le_W64(_saJt::I64, _saJK::I64);
      _saJP::I64 = _cbNC::I64;
      if (_saJP::I64 != 0) goto cbPc; else goto cbNJ;
  cbPc:
      _cbNL::I64 = _saJt::I64 - _saJI::I64;
      _saJT::I64 = _cbNL::I64;
      _cbNO::I64 = %MO_S_Le_W64(0, _saJT::I64);
      _saJU::I64 = _cbNO::I64;
      if (_saJU::I64 != 0) goto cbPb; else goto cbO1;
  cbPb:
      _cbNW::I64 = %MO_S_Lt_W64(_saJT::I64, _saJF::I64);
      _saJX::I64 = _cbNW::I64;
      if (_saJX::I64 != 0) goto cbOc; else goto cbO1;
  cbOc:
      _saK1::P64 = P64[(_saJG::P64 + 24) + (_saJT::I64 << 3)];
      _saK1::P64 = _saK1::P64;
      Hp = Hp - 16;
      I64[(young<cbO4> + 8)] = cbO4;
      R1 = _saK1::P64;
      if (R1 & 7 != 0) goto cbO4; else goto cbO5;
  cbO5:
      call (I64[R1])(R1) returns to cbO4, args: 8, res: 8, upd: 8;
  cbO4:
      _saK2::P64 = R1;
      _saK3::P64 = P64[_saK2::P64 + 7];
      I64[(young<cbO9> + 8)] = cbO9;
      R1 = _saK3::P64;
      call stg_norec_readTVar#(R1) returns to cbO9, args: 8, res: 8, upd: 8;
  cbO9:
      _saK6::P64 = R1;
      I64[(young<cbOb> + 8)] = cbOb;
      R2 = _cbJV::P64;
      R1 = _saK3::P64;
      call stg_norec_writeTVar#(R2,
                                R1) returns to cbOb, args: 8, res: 8, upd: 8;
  cbOb:
      Hp = Hp + 16;
      if (Hp > HpLim) goto cbOk; else goto cbOj;
  cbOk:
      HpAlloc = 16;
      call stg_gc_noregs() returns to cbOb, args: 8, res: 8, upd: 8;
  cbOj:
      _cbOl::I64 = %MO_S_Le_W64(_saJ5::I64, _saJt::I64);
      _saK8::I64 = _cbOl::I64;
      if (_saK8::I64 != 0) goto cbPa; else goto cbOs;
  cbPa:
      _cbOu::I64 = %MO_S_Le_W64(_saJt::I64, _saJ7::I64);
      _saKc::I64 = _cbOu::I64;
      if (_saKc::I64 != 0) goto cbP9; else goto cbOB;
  cbP9:
      _cbOD::I64 = _saJt::I64 - _saJ5::I64;
      _saKg::I64 = _cbOD::I64;
      _cbOG::I64 = %MO_S_Le_W64(0, _saKg::I64);
      _saKh::I64 = _cbOG::I64;
      if (_saKh::I64 != 0) goto cbP8; else goto cbOT;
  cbP8:
      _cbOO::I64 = %MO_S_Lt_W64(_saKg::I64, _saJ2::I64);
      _saKk::I64 = _cbOO::I64;
      if (_saKk::I64 != 0) goto cbP2; else goto cbOT;
  cbP2:
      _saKo::P64 = P64[(_saJ3::P64 + 24) + (_saKg::I64 << 3)];
      _saKo::P64 = _saKo::P64;
      Hp = Hp - 16;
      I64[(young<cbOW> + 8)] = cbOW;
      R1 = _saKo::P64;
      if (R1 & 7 != 0) goto cbOW; else goto cbOX;
  cbOX:
      call (I64[R1])(R1) returns to cbOW, args: 8, res: 8, upd: 8;
  cbOW:
      _saKp::P64 = R1;
      _saKq::P64 = P64[_saKp::P64 + 7];
      I64[(young<cbP1> + 8)] = cbP1;
      R2 = _saK6::P64;
      R1 = _saKq::P64;
      call stg_norec_writeTVar#(R2,
                                R1) returns to cbP1, args: 8, res: 8, upd: 8;
  cbP1:
      _cbPp::I64 = _saJt::I64 + 1;
      _saKs::I64 = _cbPp::I64;
      _saJu::P64 = _saJB::P64;
      _saJt::I64 = _saKs::I64;
      goto cbMM;
  cbOT:
      Hp = Hp - 16;
      R3 = _saKg::I64;
      R2 = _saJ2::I64;
      call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
  cbOB:
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _saJt::I64;
      _cbOz::P64 = Hp - 7;
      R4 = _saJ6::P64;
      R3 = _saJ4::P64;
      R2 = _cbOz::P64;
      call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbOs:
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _saJt::I64;
      _cbOq::P64 = Hp - 7;
      R4 = _saJ6::P64;
      R3 = _saJ4::P64;
      R2 = _cbOq::P64;
      call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbO1:
      Hp = Hp - 16;
      R3 = _saJT::I64;
      R2 = _saJF::I64;
      call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
  cbNJ:
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _saJt::I64;
      _cbNH::P64 = Hp - 7;
      R4 = _saJJ::P64;
      R3 = _saJH::P64;
      R2 = _cbNH::P64;
      call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbNA:
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _saJt::I64;
      _cbNy::P64 = Hp - 7;
      R4 = _saJJ::P64;
      R3 = _saJH::P64;
      R2 = _cbNy::P64;
      call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbMv:
      R3 = _saJg::I64;
      R2 = _saJ2::I64;
      call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
  cbMc:
      R4 = _saJ6::P64;
      R3 = _saJ4::P64;
      R2 = stg_INTLIKE_closure+273;
      call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbLp:
      R3 = _saIK::I64;
      R2 = _saIw::I64;
      call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
  cbL6:
      R4 = _saIA::P64;
      R3 = _saIy::P64;
      R2 = stg_INTLIKE_closure+273;
      call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbN4:
      R1 = lvl40_rawz_closure;
      call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:47.234394 UTC

{offset
  cbJO:
      _saFF::P64 = R6;
      _saFE::P64 = R5;
      _saFD::P64 = R4;
      _saFC::P64 = R3;
      _saFB::P64 = R2;
      _saFG::P64 = P64[Sp];
      if ((Sp + 16) - 128 < SpLim) goto cbJX; else goto cbJY;
  cbJY:
      if (HpLim == 0) goto cbJX; else goto cbJZ;
  cbJX:
      R6 = _saFF::P64;
      R5 = _saFE::P64;
      R4 = _saFD::P64;
      R3 = _saFC::P64;
      R2 = _saFB::P64;
      R1 = SkipList.$wa4_closure;
      call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
  cbJZ:
      I64[Sp - 40] = cbD0;
      R1 = _saFD::P64;
      P64[Sp - 32] = _saFB::P64;
      P64[Sp - 24] = _saFC::P64;
      P64[Sp - 16] = _saFE::P64;
      P64[Sp - 8] = _saFF::P64;
      Sp = Sp - 40;
      call stg_norec_readTVar#(R1) returns to cbD0, args: 8, res: 8, upd: 8;
  cbD0:
      _saFB::P64 = P64[Sp + 8];
      _saFC::P64 = P64[Sp + 16];
      _saFE::P64 = P64[Sp + 24];
      _saFF::P64 = P64[Sp + 32];
      _saFG::P64 = P64[Sp + 40];
      _saFK::P64 = R1;
      I64[Sp] = cbD2;
      R1 = _saFK::P64;
      if (R1 & 7 != 0) goto cbD2; else goto cbD3;
  cbD3:
      call (I64[R1])(R1) returns to cbD2, args: 8, res: 8, upd: 8;
  cbD2:
      _saFB::P64 = P64[Sp + 8];
      _saFC::P64 = P64[Sp + 16];
      _saFE::P64 = P64[Sp + 24];
      _saFF::P64 = P64[Sp + 32];
      _saFG::P64 = P64[Sp + 40];
      _saFL::P64 = R1;
      Hp = Hp + 64;
      if (Hp > HpLim) goto cbK3; else goto cbK2;
  cbK3:
      HpAlloc = 64;
      R1 = _saFL::P64;
      call stg_gc_unpt_r1(R1) returns to cbD2, args: 8, res: 8, upd: 8;
  cbK2:
      _saFM::I64 = I64[_saFL::P64 + 7];
      _cbD7::P64 = Hp - 52;
      _cbD8::P64 = Hp - 24;
      I64[Hp - 56] = $wa8_saFO_info;
      P64[Hp - 48] = _saFB::P64;
      P64[Hp - 40] = _saFF::P64;
      P64[Hp - 32] = _cbD8::P64;
      I64[Hp - 24] = $s$wa_saFN_info;
      P64[Hp - 16] = _saFB::P64;
      P64[Hp - 8] = _saFF::P64;
      P64[Hp] = _cbD7::P64;
      I64[Sp] = cbHA;
      R4 = GHC.Types.[]_closure+1;
      R3 = _saFM::I64;
      R2 = _saFC::P64;
      R1 = _cbD7::P64;
      I64[Sp + 8] = _saFM::I64;
      P64[Sp + 16] = _saFL::P64;
      call $wa8_saFO_info(R4,
                          R3,
                          R2,
                          R1) returns to cbHA, args: 8, res: 8, upd: 8;
  cbHA:
      _saFE::P64 = P64[Sp + 24];
      _saFF::P64 = P64[Sp + 32];
      _saFG::P64 = P64[Sp + 40];
      _saFL::P64 = P64[Sp + 16];
      _saFM::I64 = I64[Sp + 8];
      _saHj::P64 = R1;
      I64[Sp - 8] = cbHC;
      P64[Sp] = _saHj::P64;
      Sp = Sp - 8;
      call stg_myThreadId#() returns to cbHC, args: 8, res: 8, upd: 8;
  cbHC:
      _saFE::P64 = P64[Sp + 32];
      _saFF::P64 = P64[Sp + 40];
      _saFG::P64 = P64[Sp + 48];
      _saFL::P64 = P64[Sp + 24];
      _saFM::I64 = I64[Sp + 16];
      _saHj::P64 = P64[Sp + 8];
      _saHm::P64 = R1;
      I64[Sp] = cbHE;
      R1 = _saHm::P64;
      call stg_threadStatus#(R1) returns to cbHE, args: 8, res: 8, upd: 8;
  cbHE:
      _saFE::P64 = P64[Sp + 32];
      _saFF::P64 = P64[Sp + 40];
      _saFG::P64 = P64[Sp + 48];
      _saFL::P64 = P64[Sp + 24];
      _saFM::I64 = I64[Sp + 16];
      _saHj::P64 = P64[Sp + 8];
      _saHr::I64 = R3;
      _saHq::I64 = R2;
      _saHp::I64 = R1;
      goto cbHF;
  cbHF:
      Hp = Hp + 72;
      if (Hp > HpLim) goto cbK8; else goto cbK7;
  cbK8:
      HpAlloc = 72;
      I64[Sp - 8] = cbHG;
      I64[Sp] = _saHq::I64;
      Sp = Sp - 8;
      call stg_gc_noregs() returns to cbHG, args: 8, res: 8, upd: 8;
  cbHG:
      _saFE::P64 = P64[Sp + 40];
      _saFF::P64 = P64[Sp + 48];
      _saFG::P64 = P64[Sp + 56];
      _saFL::P64 = P64[Sp + 32];
      _saFM::I64 = I64[Sp + 24];
      _saHj::P64 = P64[Sp + 16];
      _saHq::I64 = I64[Sp + 8];
      goto ubPq;
  ubPq:
      Sp = Sp + 8;
      goto cbHF;
  cbK7:
      I64[Hp - 64] = nodesHeight_saHs_info;
      P64[Hp - 48] = _saFE::P64;
      P64[Hp - 40] = _saFL::P64;
      I64[Hp - 32] = _saFM::I64;
      I64[Hp - 24] = _saHq::I64;
      _cbHI::P64 = Hp - 64;
      I64[Hp - 16] = (,)_con_info;
      P64[Hp - 8] = SkipList.newSL10_closure+1;
      P64[Hp] = _cbHI::P64;
      _cbJP::P64 = Hp - 15;
      I64[Sp] = cbJQ;
      R3 = _cbJP::P64;
      R2 = GHC.Arr.$fIxInt_closure;
      P64[Sp + 32] = _cbHI::P64;
      call SkipList.$fMArrayTArrayeSTM8_info(R3,
                                             R2) returns to cbJQ, args: 8, res: 8, upd: 8;
  cbJQ:
      _cbHI::P64 = P64[Sp + 32];
      _saFF::P64 = P64[Sp + 40];
      _saFG::P64 = P64[Sp + 48];
      _saHj::P64 = P64[Sp + 8];
      _saIf::P64 = R1;
      I64[Sp] = cbJS;
      R1 = _saFG::P64;
      P64[Sp + 48] = _saIf::P64;
      call stg_newNOrecTVar#(R1) returns to cbJS, args: 8, res: 8, upd: 8;
  cbJS:
      _cbHI::P64 = P64[Sp + 32];
      _saFF::P64 = P64[Sp + 40];
      _saHj::P64 = P64[Sp + 8];
      _saIf::P64 = P64[Sp + 48];
      _saIi::P64 = R1;
      Hp = Hp + 48;
      if (Hp > HpLim) goto cbKc; else goto cbKb;
  cbKc:
      HpAlloc = 48;
      R1 = _saIi::P64;
      call stg_gc_unpt_r1(R1) returns to cbJS, args: 8, res: 8, upd: 8;
  cbKb:
      I64[Hp - 40] = GHC.Conc.Sync.TVar_con_info;
      P64[Hp - 32] = _saIi::P64;
      _cbJU::P64 = Hp - 39;
      I64[Hp - 24] = SkipList.Node_con_info;
      P64[Hp - 16] = _saFF::P64;
      P64[Hp - 8] = _cbJU::P64;
      P64[Hp] = _saIf::P64;
      _cbJV::P64 = Hp - 22;
      I64[Sp] = cbJW;
      R1 = _cbHI::P64;
      P64[Sp + 40] = _cbJV::P64;
      if (R1 & 7 != 0) goto cbJW; else goto cbKd;
  cbKd:
      call (I64[R1])(R1) returns to cbJW, args: 8, res: 8, upd: 8;
  cbJW:
      _cbJV::P64 = P64[Sp + 40];
      _saHj::P64 = P64[Sp + 8];
      _saIf::P64 = P64[Sp + 48];
      _saIl::P64 = R1;
      _saIm::I64 = I64[_saIl::P64 + 7];
      _cbKi::I64 = %MO_S_Gt_W64(1, _saIm::I64);
      _saIn::I64 = _cbKi::I64;
      if (_saIn::I64 != 0) goto cbPm; else goto cbKp;
  cbKp:
      I64[Sp + 24] = cbKn;
      R1 = _saHj::P64;
      I64[Sp + 32] = _saIm::I64;
      Sp = Sp + 24;
      if (R1 & 7 != 0) goto cbKn; else goto cbKq;
  cbKq:
      call (I64[R1])(R1) returns to cbKn, args: 8, res: 8, upd: 8;
  cbKn:
      _cbJV::P64 = P64[Sp + 16];
      _saIf::P64 = P64[Sp + 24];
      _saIm::I64 = I64[Sp + 8];
      _saIp::P64 = R1;
      _cbPn::P64 = _saIp::P64 & 7;
      if (_cbPn::P64 != 1) goto cbKL; else goto cbN4;
  cbKL:
      _saIr::P64 = P64[_saIp::P64 + 6];
      _saIs::P64 = P64[_saIp::P64 + 14];
      I64[Sp - 8] = cbKz;
      R1 = _saIr::P64;
      P64[Sp] = _saIs::P64;
      Sp = Sp - 8;
      if (R1 & 7 != 0) goto cbKz; else goto cbKA;
  cbKA:
      call (I64[R1])(R1) returns to cbKz, args: 8, res: 8, upd: 8;
  cbKz:
      _cbJV::P64 = P64[Sp + 24];
      _saIf::P64 = P64[Sp + 32];
      _saIm::I64 = I64[Sp + 16];
      _saIs::P64 = P64[Sp + 8];
      _saIt::P64 = R1;
      _saIu::P64 = P64[_saIt::P64 + 7];
      _saIv::P64 = P64[_saIt::P64 + 15];
      _saIx::P64 = P64[_saIt::P64 + 23];
      _saIw::I64 = I64[_saIt::P64 + 31];
      I64[Sp - 24] = cbKE;
      R1 = _saIu::P64;
      I64[Sp - 16] = _saIw::I64;
      P64[Sp - 8] = _saIx::P64;
      P64[Sp] = _saIv::P64;
      Sp = Sp - 24;
      if (R1 & 7 != 0) goto cbKE; else goto cbKF;
  cbKF:
      call (I64[R1])(R1) returns to cbKE, args: 8, res: 8, upd: 8;
  cbKE:
      _cbJV::P64 = P64[Sp + 48];
      _saIf::P64 = P64[Sp + 56];
      _saIm::I64 = I64[Sp + 40];
      _saIs::P64 = P64[Sp + 32];
      _saIv::P64 = P64[Sp + 24];
      _saIw::I64 = I64[Sp + 8];
      _saIx::P64 = P64[Sp + 16];
      _saIy::P64 = R1;
      _saIz::I64 = I64[_saIy::P64 + 7];
      I64[Sp - 8] = cbKJ;
      R1 = _saIv::P64;
      I64[Sp] = _saIz::I64;
      P64[Sp + 24] = _saIy::P64;
      Sp = Sp - 8;
      if (R1 & 7 != 0) goto cbKJ; else goto cbKO;
  cbKO:
      call (I64[R1])(R1) returns to cbKJ, args: 8, res: 8, upd: 8;
  cbKJ:
      _cbJV::P64 = P64[Sp + 56];
      _saIf::P64 = P64[Sp + 64];
      _saIm::I64 = I64[Sp + 48];
      _saIs::P64 = P64[Sp + 40];
      _saIw::I64 = I64[Sp + 16];
      _saIx::P64 = P64[Sp + 24];
      _saIy::P64 = P64[Sp + 32];
      _saIz::I64 = I64[Sp + 8];
      _saIA::P64 = R1;
      _saIB::I64 = I64[_saIA::P64 + 7];
      _cbKT::I64 = %MO_S_Le_W64(_saIz::I64, 1);
      _saIC::I64 = _cbKT::I64;
      if (_saIC::I64 != 0) goto cbPl; else goto cbL6;
  cbPl:
      _cbL1::I64 = %MO_S_Le_W64(1, _saIB::I64);
      _saIG::I64 = _cbL1::I64;
      if (_saIG::I64 != 0) goto cbPk; else goto cbL6;
  cbPk:
      _cbL9::I64 = 1 - _saIz::I64;
      _saIK::I64 = _cbL9::I64;
      _cbLc::I64 = %MO_S_Le_W64(0, _saIK::I64);
      _saIL::I64 = _cbLc::I64;
      if (_saIL::I64 != 0) goto cbPj; else goto cbLp;
  cbPj:
      _cbLk::I64 = %MO_S_Lt_W64(_saIK::I64, _saIw::I64);
      _saIO::I64 = _cbLk::I64;
      if (_saIO::I64 != 0) goto cbLO; else goto cbLp;
  cbLO:
      _saIS::P64 = P64[(_saIx::P64 + 24) + (_saIK::I64 << 3)];
      _saIS::P64 = _saIS::P64;
      I64[Sp + 32] = cbLs;
      R1 = _saIS::P64;
      Sp = Sp + 32;
      if (R1 & 7 != 0) goto cbLs; else goto cbLt;
  cbLt:
      call (I64[R1])(R1) returns to cbLs, args: 8, res: 8, upd: 8;
  cbLs:
      _cbJV::P64 = P64[Sp + 24];
      _saIf::P64 = P64[Sp + 32];
      _saIm::I64 = I64[Sp + 16];
      _saIs::P64 = P64[Sp + 8];
      _saIT::P64 = R1;
      _saIU::P64 = P64[_saIT::P64 + 7];
      I64[Sp - 8] = cbLx;
      R1 = _saIU::P64;
      P64[Sp] = _saIU::P64;
      Sp = Sp - 8;
      call stg_norec_readTVar#(R1) returns to cbLx, args: 8, res: 8, upd: 8;
  cbLx:
      _cbJV::P64 = P64[Sp + 32];
      _saIf::P64 = P64[Sp + 40];
      _saIm::I64 = I64[Sp + 24];
      _saIs::P64 = P64[Sp + 16];
      _saIU::P64 = P64[Sp + 8];
      _saIX::P64 = R1;
      I64[Sp] = cbLz;
      R2 = _cbJV::P64;
      R1 = _saIU::P64;
      P64[Sp + 8] = _saIX::P64;
      call stg_norec_writeTVar#(R2,
                                R1) returns to cbLz, args: 8, res: 8, upd: 8;
  cbLz:
      _cbJV::P64 = P64[Sp + 32];
      _saIf::P64 = P64[Sp + 40];
      _saIm::I64 = I64[Sp + 24];
      _saIs::P64 = P64[Sp + 16];
      _saIX::P64 = P64[Sp + 8];
      I64[Sp] = cbLD;
      R1 = _saIf::P64;
      if (R1 & 7 != 0) goto cbLD; else goto cbLE;
  cbLE:
      call (I64[R1])(R1) returns to cbLD, args: 8, res: 8, upd: 8;
  cbLD:
      _cbJV::P64 = P64[Sp + 32];
      _saIm::I64 = I64[Sp + 24];
      _saIs::P64 = P64[Sp + 16];
      _saIX::P64 = P64[Sp + 8];
      _saIZ::P64 = R1;
      _saJ0::P64 = P64[_saIZ::P64 + 7];
      _saJ1::P64 = P64[_saIZ::P64 + 15];
      _saJ3::P64 = P64[_saIZ::P64 + 23];
      _saJ2::I64 = I64[_saIZ::P64 + 31];
      I64[Sp - 16] = cbLI;
      R1 = _saJ0::P64;
      P64[Sp - 8] = _saJ3::P64;
      I64[Sp] = _saJ2::I64;
      P64[Sp + 40] = _saJ1::P64;
      Sp = Sp - 16;
      if (R1 & 7 != 0) goto cbLI; else goto cbLJ;
  cbLJ:
      call (I64[R1])(R1) returns to cbLI, args: 8, res: 8, upd: 8;
  cbLI:
      _cbJV::P64 = P64[Sp + 48];
      _saIm::I64 = I64[Sp + 40];
      _saIs::P64 = P64[Sp + 32];
      _saIX::P64 = P64[Sp + 24];
      _saJ1::P64 = P64[Sp + 56];
      _saJ2::I64 = I64[Sp + 16];
      _saJ3::P64 = P64[Sp + 8];
      _saJ4::P64 = R1;
      _saJ5::I64 = I64[_saJ4::P64 + 7];
      I64[Sp - 8] = cbLN;
      R1 = _saJ1::P64;
      I64[Sp] = _saJ5::I64;
      P64[Sp + 56] = _saJ4::P64;
      Sp = Sp - 8;
      if (R1 & 7 != 0) goto cbLN; else goto cbLU;
  cbLU:
      call (I64[R1])(R1) returns to cbLN, args: 8, res: 8, upd: 8;
  cbLN:
      _cbJV::P64 = P64[Sp + 56];
      _saIm::I64 = I64[Sp + 48];
      _saIs::P64 = P64[Sp + 40];
      _saIX::P64 = P64[Sp + 32];
      _saJ2::I64 = I64[Sp + 24];
      _saJ3::P64 = P64[Sp + 16];
      _saJ4::P64 = P64[Sp + 64];
      _saJ5::I64 = I64[Sp + 8];
      _saJ6::P64 = R1;
      _saJ7::I64 = I64[_saJ6::P64 + 7];
      _cbLZ::I64 = %MO_S_Le_W64(_saJ5::I64, 1);
      _saJ8::I64 = _cbLZ::I64;
      if (_saJ8::I64 != 0) goto cbPi; else goto cbMc;
  cbPi:
      _cbM7::I64 = %MO_S_Le_W64(1, _saJ7::I64);
      _saJc::I64 = _cbM7::I64;
      if (_saJc::I64 != 0) goto cbPh; else goto cbMc;
  cbPh:
      _cbMf::I64 = 1 - _saJ5::I64;
      _saJg::I64 = _cbMf::I64;
      _cbMi::I64 = %MO_S_Le_W64(0, _saJg::I64);
      _saJh::I64 = _cbMi::I64;
      if (_saJh::I64 != 0) goto cbPg; else goto cbMv;
  cbPg:
      _cbMq::I64 = %MO_S_Lt_W64(_saJg::I64, _saJ2::I64);
      _saJk::I64 = _cbMq::I64;
      if (_saJk::I64 != 0) goto cbME; else goto cbMv;
  cbME:
      _saJo::P64 = P64[(_saJ3::P64 + 24) + (_saJg::I64 << 3)];
      _saJo::P64 = _saJo::P64;
      I64[Sp - 16] = cbMy;
      R1 = _saJo::P64;
      I64[Sp - 8] = _saJ7::I64;
      P64[Sp] = _saJ6::P64;
      Sp = Sp - 16;
      if (R1 & 7 != 0) goto cbMy; else goto cbMz;
  cbMz:
      call (I64[R1])(R1) returns to cbMy, args: 8, res: 8, upd: 8;
  cbMy:
      _cbJV::P64 = P64[Sp + 72];
      _saIm::I64 = I64[Sp + 64];
      _saIs::P64 = P64[Sp + 56];
      _saIX::P64 = P64[Sp + 48];
      _saJ2::I64 = I64[Sp + 40];
      _saJ3::P64 = P64[Sp + 32];
      _saJ4::P64 = P64[Sp + 80];
      _saJ5::I64 = I64[Sp + 24];
      _saJ6::P64 = P64[Sp + 16];
      _saJ7::I64 = I64[Sp + 8];
      _saJp::P64 = R1;
      _saJq::P64 = P64[_saJp::P64 + 7];
      I64[Sp] = cbMD;
      R2 = _saIX::P64;
      R1 = _saJq::P64;
      call stg_norec_writeTVar#(R2,
                                R1) returns to cbMD, args: 8, res: 8, upd: 8;
  cbMD:
      _cbJV::P64 = P64[Sp + 72];
      _saIm::I64 = I64[Sp + 64];
      _saIs::P64 = P64[Sp + 56];
      _saJ2::I64 = I64[Sp + 40];
      _saJ3::P64 = P64[Sp + 32];
      _saJ4::P64 = P64[Sp + 80];
      _saJ5::I64 = I64[Sp + 24];
      _saJ6::P64 = P64[Sp + 16];
      _saJ7::I64 = I64[Sp + 8];
      _saJu::P64 = _saIs::P64;
      _saJt::I64 = 2;
      goto cbMM;
  cbMM:
      if (HpLim == 0) goto cbMP; else goto cbPf;
  cbMP:
      I64[Sp] = cbMN;
      P64[Sp + 48] = _saJu::P64;
      I64[Sp + 56] = _saJt::I64;
      call stg_gc_noregs() returns to cbMN, args: 8, res: 8, upd: 8;
  cbMN:
      _cbJV::P64 = P64[Sp + 72];
      _saIm::I64 = I64[Sp + 64];
      _saJ2::I64 = I64[Sp + 40];
      _saJ3::P64 = P64[Sp + 32];
      _saJ4::P64 = P64[Sp + 80];
      _saJ5::I64 = I64[Sp + 24];
      _saJ6::P64 = P64[Sp + 16];
      _saJ7::I64 = I64[Sp + 8];
      _saJt::I64 = I64[Sp + 56];
      _saJu::P64 = P64[Sp + 48];
      goto cbMM;
  cbPf:
      _cbMQ::I64 = %MO_S_Gt_W64(_saJt::I64, _saIm::I64);
      _saJw::I64 = _cbMQ::I64;
      if (_saJw::I64 != 0) goto ubPr; else goto cbMX;
  ubPr:
      Sp = Sp + 32;
      goto cbPm;
  cbPm:
      R1 = GHC.Tuple.()_closure+1;
      Sp = Sp + 56;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
  cbMX:
      I64[Sp] = cbMV;
      R1 = _saJu::P64;
      I64[Sp + 56] = _saJt::I64;
      if (R1 & 7 != 0) goto cbMV; else goto cbMY;
  cbMY:
      call (I64[R1])(R1) returns to cbMV, args: 8, res: 8, upd: 8;
  cbMV:
      _cbJV::P64 = P64[Sp + 72];
      _saIm::I64 = I64[Sp + 64];
      _saJ2::I64 = I64[Sp + 40];
      _saJ3::P64 = P64[Sp + 32];
      _saJ4::P64 = P64[Sp + 80];
      _saJ5::I64 = I64[Sp + 24];
      _saJ6::P64 = P64[Sp + 16];
      _saJ7::I64 = I64[Sp + 8];
      _saJt::I64 = I64[Sp + 56];
      _saJy::P64 = R1;
      _cbPo::P64 = _saJy::P64 & 7;
      if (_cbPo::P64 != 1) goto cbNj; else goto ubPs;
  cbNj:
      _saJA::P64 = P64[_saJy::P64 + 6];
      _saJB::P64 = P64[_saJy::P64 + 14];
      I64[Sp] = cbN7;
      R1 = _saJA::P64;
      P64[Sp + 48] = _saJB::P64;
      if (R1 & 7 != 0) goto cbN7; else goto cbN8;
  cbN8:
      call (I64[R1])(R1) returns to cbN7, args: 8, res: 8, upd: 8;
  cbN7:
      _cbJV::P64 = P64[Sp + 72];
      _saIm::I64 = I64[Sp + 64];
      _saJ2::I64 = I64[Sp + 40];
      _saJ3::P64 = P64[Sp + 32];
      _saJ4::P64 = P64[Sp + 80];
      _saJ5::I64 = I64[Sp + 24];
      _saJ6::P64 = P64[Sp + 16];
      _saJ7::I64 = I64[Sp + 8];
      _saJt::I64 = I64[Sp + 56];
      _saJB::P64 = P64[Sp + 48];
      _saJC::P64 = R1;
      _saJD::P64 = P64[_saJC::P64 + 7];
      _saJE::P64 = P64[_saJC::P64 + 15];
      _saJG::P64 = P64[_saJC::P64 + 23];
      _saJF::I64 = I64[_saJC::P64 + 31];
      I64[Sp - 24] = cbNc;
      R1 = _saJD::P64;
      I64[Sp - 16] = _saJF::I64;
      P64[Sp - 8] = _saJG::P64;
      P64[Sp] = _saJE::P64;
      Sp = Sp - 24;
      if (R1 & 7 != 0) goto cbNc; else goto cbNd;
  cbNd:
      call (I64[R1])(R1) returns to cbNc, args: 8, res: 8, upd: 8;
  cbNc:
      _cbJV::P64 = P64[Sp + 96];
      _saIm::I64 = I64[Sp + 88];
      _saJ2::I64 = I64[Sp + 64];
      _saJ3::P64 = P64[Sp + 56];
      _saJ4::P64 = P64[Sp + 104];
      _saJ5::I64 = I64[Sp + 48];
      _saJ6::P64 = P64[Sp + 40];
      _saJ7::I64 = I64[Sp + 32];
      _saJt::I64 = I64[Sp + 80];
      _saJB::P64 = P64[Sp + 72];
      _saJE::P64 = P64[Sp + 24];
      _saJF::I64 = I64[Sp + 8];
      _saJG::P64 = P64[Sp + 16];
      _saJH::P64 = R1;
      _saJI::I64 = I64[_saJH::P64 + 7];
      I64[Sp - 8] = cbNh;
      R1 = _saJE::P64;
      I64[Sp] = _saJI::I64;
      P64[Sp + 24] = _saJH::P64;
      Sp = Sp - 8;
      if (R1 & 7 != 0) goto cbNh; else goto cbNm;
  cbNm:
      call (I64[R1])(R1) returns to cbNh, args: 8, res: 8, upd: 8;
  cbNh:
      _cbJV::P64 = P64[Sp + 104];
      _saIm::I64 = I64[Sp + 96];
      _saJ2::I64 = I64[Sp + 72];
      _saJ3::P64 = P64[Sp + 64];
      _saJ4::P64 = P64[Sp + 112];
      _saJ5::I64 = I64[Sp + 56];
      _saJ6::P64 = P64[Sp + 48];
      _saJ7::I64 = I64[Sp + 40];
      _saJt::I64 = I64[Sp + 88];
      _saJB::P64 = P64[Sp + 80];
      _saJF::I64 = I64[Sp + 16];
      _saJG::P64 = P64[Sp + 24];
      _saJH::P64 = P64[Sp + 32];
      _saJI::I64 = I64[Sp + 8];
      _saJJ::P64 = R1;
      Hp = Hp + 16;
      if (Hp > HpLim) goto cbNs; else goto cbNr;
  cbNs:
      HpAlloc = 16;
      R1 = _saJJ::P64;
      call stg_gc_unpt_r1(R1) returns to cbNh, args: 8, res: 8, upd: 8;
  cbNr:
      _saJK::I64 = I64[_saJJ::P64 + 7];
      _cbNt::I64 = %MO_S_Le_W64(_saJI::I64, _saJt::I64);
      _saJL::I64 = _cbNt::I64;
      if (_saJL::I64 != 0) goto cbPd; else goto cbNA;
  cbPd:
      _cbNC::I64 = %MO_S_Le_W64(_saJt::I64, _saJK::I64);
      _saJP::I64 = _cbNC::I64;
      if (_saJP::I64 != 0) goto cbPc; else goto cbNJ;
  cbPc:
      _cbNL::I64 = _saJt::I64 - _saJI::I64;
      _saJT::I64 = _cbNL::I64;
      _cbNO::I64 = %MO_S_Le_W64(0, _saJT::I64);
      _saJU::I64 = _cbNO::I64;
      if (_saJU::I64 != 0) goto cbPb; else goto cbO1;
  cbPb:
      _cbNW::I64 = %MO_S_Lt_W64(_saJT::I64, _saJF::I64);
      _saJX::I64 = _cbNW::I64;
      if (_saJX::I64 != 0) goto cbOc; else goto cbO1;
  cbOc:
      _saK1::P64 = P64[(_saJG::P64 + 24) + (_saJT::I64 << 3)];
      _saK1::P64 = _saK1::P64;
      Hp = Hp - 16;
      I64[Sp + 32] = cbO4;
      R1 = _saK1::P64;
      Sp = Sp + 32;
      if (R1 & 7 != 0) goto cbO4; else goto cbO5;
  cbO5:
      call (I64[R1])(R1) returns to cbO4, args: 8, res: 8, upd: 8;
  cbO4:
      _cbJV::P64 = P64[Sp + 72];
      _saIm::I64 = I64[Sp + 64];
      _saJ2::I64 = I64[Sp + 40];
      _saJ3::P64 = P64[Sp + 32];
      _saJ4::P64 = P64[Sp + 80];
      _saJ5::I64 = I64[Sp + 24];
      _saJ6::P64 = P64[Sp + 16];
      _saJ7::I64 = I64[Sp + 8];
      _saJt::I64 = I64[Sp + 56];
      _saJB::P64 = P64[Sp + 48];
      _saK2::P64 = R1;
      _saK3::P64 = P64[_saK2::P64 + 7];
      I64[Sp - 8] = cbO9;
      R1 = _saK3::P64;
      P64[Sp] = _saK3::P64;
      Sp = Sp - 8;
      call stg_norec_readTVar#(R1) returns to cbO9, args: 8, res: 8, upd: 8;
  cbO9:
      _cbJV::P64 = P64[Sp + 80];
      _saIm::I64 = I64[Sp + 72];
      _saJ2::I64 = I64[Sp + 48];
      _saJ3::P64 = P64[Sp + 40];
      _saJ4::P64 = P64[Sp + 88];
      _saJ5::I64 = I64[Sp + 32];
      _saJ6::P64 = P64[Sp + 24];
      _saJ7::I64 = I64[Sp + 16];
      _saJt::I64 = I64[Sp + 64];
      _saJB::P64 = P64[Sp + 56];
      _saK3::P64 = P64[Sp + 8];
      _saK6::P64 = R1;
      I64[Sp] = cbOb;
      R2 = _cbJV::P64;
      R1 = _saK3::P64;
      P64[Sp + 8] = _saK6::P64;
      call stg_norec_writeTVar#(R2,
                                R1) returns to cbOb, args: 8, res: 8, upd: 8;
  cbOb:
      _cbJV::P64 = P64[Sp + 80];
      _saIm::I64 = I64[Sp + 72];
      _saJ2::I64 = I64[Sp + 48];
      _saJ3::P64 = P64[Sp + 40];
      _saJ4::P64 = P64[Sp + 88];
      _saJ5::I64 = I64[Sp + 32];
      _saJ6::P64 = P64[Sp + 24];
      _saJ7::I64 = I64[Sp + 16];
      _saJt::I64 = I64[Sp + 64];
      _saJB::P64 = P64[Sp + 56];
      _saK6::P64 = P64[Sp + 8];
      Hp = Hp + 16;
      if (Hp > HpLim) goto cbOk; else goto cbOj;
  cbOk:
      HpAlloc = 16;
      call stg_gc_noregs() returns to cbOb, args: 8, res: 8, upd: 8;
  cbOj:
      _cbOl::I64 = %MO_S_Le_W64(_saJ5::I64, _saJt::I64);
      _saK8::I64 = _cbOl::I64;
      if (_saK8::I64 != 0) goto cbPa; else goto cbOs;
  cbPa:
      _cbOu::I64 = %MO_S_Le_W64(_saJt::I64, _saJ7::I64);
      _saKc::I64 = _cbOu::I64;
      if (_saKc::I64 != 0) goto cbP9; else goto cbOB;
  cbP9:
      _cbOD::I64 = _saJt::I64 - _saJ5::I64;
      _saKg::I64 = _cbOD::I64;
      _cbOG::I64 = %MO_S_Le_W64(0, _saKg::I64);
      _saKh::I64 = _cbOG::I64;
      if (_saKh::I64 != 0) goto cbP8; else goto cbOT;
  cbP8:
      _cbOO::I64 = %MO_S_Lt_W64(_saKg::I64, _saJ2::I64);
      _saKk::I64 = _cbOO::I64;
      if (_saKk::I64 != 0) goto cbP2; else goto cbOT;
  cbP2:
      _saKo::P64 = P64[(_saJ3::P64 + 24) + (_saKg::I64 << 3)];
      _saKo::P64 = _saKo::P64;
      Hp = Hp - 16;
      I64[Sp] = cbOW;
      R1 = _saKo::P64;
      if (R1 & 7 != 0) goto cbOW; else goto cbOX;
  cbOX:
      call (I64[R1])(R1) returns to cbOW, args: 8, res: 8, upd: 8;
  cbOW:
      _cbJV::P64 = P64[Sp + 80];
      _saIm::I64 = I64[Sp + 72];
      _saJ2::I64 = I64[Sp + 48];
      _saJ3::P64 = P64[Sp + 40];
      _saJ4::P64 = P64[Sp + 88];
      _saJ5::I64 = I64[Sp + 32];
      _saJ6::P64 = P64[Sp + 24];
      _saJ7::I64 = I64[Sp + 16];
      _saJt::I64 = I64[Sp + 64];
      _saJB::P64 = P64[Sp + 56];
      _saK6::P64 = P64[Sp + 8];
      _saKp::P64 = R1;
      _saKq::P64 = P64[_saKp::P64 + 7];
      I64[Sp + 8] = cbP1;
      R2 = _saK6::P64;
      R1 = _saKq::P64;
      Sp = Sp + 8;
      call stg_norec_writeTVar#(R2,
                                R1) returns to cbP1, args: 8, res: 8, upd: 8;
  cbP1:
      _cbJV::P64 = P64[Sp + 72];
      _saIm::I64 = I64[Sp + 64];
      _saJ2::I64 = I64[Sp + 40];
      _saJ3::P64 = P64[Sp + 32];
      _saJ4::P64 = P64[Sp + 80];
      _saJ5::I64 = I64[Sp + 24];
      _saJ6::P64 = P64[Sp + 16];
      _saJ7::I64 = I64[Sp + 8];
      _saJt::I64 = I64[Sp + 56];
      _saJB::P64 = P64[Sp + 48];
      _cbPp::I64 = _saJt::I64 + 1;
      _saKs::I64 = _cbPp::I64;
      _saJu::P64 = _saJB::P64;
      _saJt::I64 = _saKs::I64;
      goto cbMM;
  cbOT:
      Hp = Hp - 16;
      R3 = _saKg::I64;
      R2 = _saJ2::I64;
      Sp = Sp + 96;
      call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
  cbOB:
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _saJt::I64;
      _cbOz::P64 = Hp - 7;
      R4 = _saJ6::P64;
      R3 = _saJ4::P64;
      R2 = _cbOz::P64;
      Sp = Sp + 96;
      call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbOs:
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _saJt::I64;
      _cbOq::P64 = Hp - 7;
      R4 = _saJ6::P64;
      R3 = _saJ4::P64;
      R2 = _cbOq::P64;
      Sp = Sp + 96;
      call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbO1:
      Hp = Hp - 16;
      R3 = _saJT::I64;
      R2 = _saJF::I64;
      Sp = Sp + 120;
      call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
  cbNJ:
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _saJt::I64;
      _cbNH::P64 = Hp - 7;
      R4 = _saJJ::P64;
      R3 = _saJH::P64;
      R2 = _cbNH::P64;
      Sp = Sp + 120;
      call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbNA:
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _saJt::I64;
      _cbNy::P64 = Hp - 7;
      R4 = _saJJ::P64;
      R3 = _saJH::P64;
      R2 = _cbNy::P64;
      Sp = Sp + 120;
      call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  ubPs:
      Sp = Sp + 56;
      goto cbN4;
  cbMv:
      R3 = _saJg::I64;
      R2 = _saJ2::I64;
      Sp = Sp + 72;
      call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
  cbMc:
      R4 = _saJ6::P64;
      R3 = _saJ4::P64;
      R2 = stg_INTLIKE_closure+273;
      Sp = Sp + 72;
      call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbLp:
      R3 = _saIK::I64;
      R2 = _saIw::I64;
      Sp = Sp + 72;
      call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
  cbL6:
      R4 = _saIA::P64;
      R3 = _saIy::P64;
      R2 = stg_INTLIKE_closure+273;
      Sp = Sp + 72;
      call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbN4:
      R1 = lvl40_rawz_closure;
      Sp = Sp + 32;
      call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:47.273125 UTC

{offset
  cbJO:
      _saFF::P64 = R6;
      _saFE::P64 = R5;
      _saFD::P64 = R4;
      _saFC::P64 = R3;
      _saFB::P64 = R2;
      if ((Sp + -112) < SpLim) goto cbJX; else goto cbJY;
  cbJY:
      if (HpLim == 0) goto cbJX; else goto cbJZ;
  cbJX:
      R6 = _saFF::P64;
      R5 = _saFE::P64;
      R4 = _saFD::P64;
      R3 = _saFC::P64;
      R2 = _saFB::P64;
      R1 = SkipList.$wa4_closure;
      call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
  cbJZ:
      I64[Sp - 40] = cbD0;
      R1 = _saFD::P64;
      P64[Sp - 32] = _saFB::P64;
      P64[Sp - 24] = _saFC::P64;
      P64[Sp - 16] = _saFE::P64;
      P64[Sp - 8] = _saFF::P64;
      Sp = Sp - 40;
      call stg_norec_readTVar#(R1) returns to cbD0, args: 8, res: 8, upd: 8;
  cbD0:
      I64[Sp] = cbD2;
      R1 = R1;
      if (R1 & 7 != 0) goto cbD2; else goto cbD3;
  cbD3:
      call (I64[R1])(R1) returns to cbD2, args: 8, res: 8, upd: 8;
  cbD2:
      Hp = Hp + 64;
      if (Hp > HpLim) goto cbK3; else goto cbK2;
  cbK3:
      HpAlloc = 64;
      R1 = R1;
      call stg_gc_unpt_r1(R1) returns to cbD2, args: 8, res: 8, upd: 8;
  cbK2:
      _saFM::I64 = I64[R1 + 7];
      I64[Hp - 56] = $wa8_saFO_info;
      _saFB::P64 = P64[Sp + 8];
      P64[Hp - 48] = _saFB::P64;
      _saFF::P64 = P64[Sp + 32];
      P64[Hp - 40] = _saFF::P64;
      P64[Hp - 32] = Hp - 24;
      I64[Hp - 24] = $s$wa_saFN_info;
      P64[Hp - 16] = _saFB::P64;
      P64[Hp - 8] = _saFF::P64;
      _cbD7::P64 = Hp - 52;
      P64[Hp] = _cbD7::P64;
      I64[Sp] = cbHA;
      R4 = GHC.Types.[]_closure+1;
      R3 = _saFM::I64;
      R2 = P64[Sp + 16];
      _saFL::P64 = R1;
      R1 = _cbD7::P64;
      I64[Sp + 8] = _saFM::I64;
      P64[Sp + 16] = _saFL::P64;
      call $wa8_saFO_info(R4,
                          R3,
                          R2,
                          R1) returns to cbHA, args: 8, res: 8, upd: 8;
  cbHA:
      I64[Sp - 8] = cbHC;
      P64[Sp] = R1;
      Sp = Sp - 8;
      call stg_myThreadId#() returns to cbHC, args: 8, res: 8, upd: 8;
  cbHC:
      I64[Sp] = cbHE;
      R1 = R1;
      call stg_threadStatus#(R1) returns to cbHE, args: 8, res: 8, upd: 8;
  cbHE:
      _saFE::P64 = P64[Sp + 32];
      _saFL::P64 = P64[Sp + 24];
      _saFM::I64 = I64[Sp + 16];
      _saHq::I64 = R2;
      goto cbHF;
  cbHF:
      Hp = Hp + 72;
      if (Hp > HpLim) goto cbK8; else goto cbK7;
  cbK8:
      HpAlloc = 72;
      I64[Sp - 8] = cbHG;
      I64[Sp] = _saHq::I64;
      Sp = Sp - 8;
      call stg_gc_noregs() returns to cbHG, args: 8, res: 8, upd: 8;
  cbHG:
      goto ubPq;
  ubPq:
      _saFE::P64 = P64[Sp + 40];
      _saFL::P64 = P64[Sp + 32];
      _saFM::I64 = I64[Sp + 24];
      _saHq::I64 = I64[Sp + 8];
      Sp = Sp + 8;
      goto cbHF;
  cbK7:
      I64[Hp - 64] = nodesHeight_saHs_info;
      P64[Hp - 48] = _saFE::P64;
      P64[Hp - 40] = _saFL::P64;
      I64[Hp - 32] = _saFM::I64;
      I64[Hp - 24] = _saHq::I64;
      I64[Hp - 16] = (,)_con_info;
      P64[Hp - 8] = SkipList.newSL10_closure+1;
      _cbHI::P64 = Hp - 64;
      P64[Hp] = _cbHI::P64;
      I64[Sp] = cbJQ;
      R3 = Hp - 15;
      R2 = GHC.Arr.$fIxInt_closure;
      P64[Sp + 32] = _cbHI::P64;
      call SkipList.$fMArrayTArrayeSTM8_info(R3,
                                             R2) returns to cbJQ, args: 8, res: 8, upd: 8;
  cbJQ:
      I64[Sp] = cbJS;
      _saIf::P64 = R1;
      R1 = P64[Sp + 48];
      P64[Sp + 48] = _saIf::P64;
      call stg_newNOrecTVar#(R1) returns to cbJS, args: 8, res: 8, upd: 8;
  cbJS:
      Hp = Hp + 48;
      if (Hp > HpLim) goto cbKc; else goto cbKb;
  cbKc:
      HpAlloc = 48;
      R1 = R1;
      call stg_gc_unpt_r1(R1) returns to cbJS, args: 8, res: 8, upd: 8;
  cbKb:
      I64[Hp - 40] = GHC.Conc.Sync.TVar_con_info;
      P64[Hp - 32] = R1;
      I64[Hp - 24] = SkipList.Node_con_info;
      P64[Hp - 16] = P64[Sp + 40];
      P64[Hp - 8] = Hp - 39;
      P64[Hp] = P64[Sp + 48];
      I64[Sp] = cbJW;
      R1 = P64[Sp + 32];
      P64[Sp + 40] = Hp - 22;
      if (R1 & 7 != 0) goto cbJW; else goto cbKd;
  cbKd:
      call (I64[R1])(R1) returns to cbJW, args: 8, res: 8, upd: 8;
  cbJW:
      _saIm::I64 = I64[R1 + 7];
      if (%MO_S_Gt_W64(1, _saIm::I64)) goto cbPm; else goto cbKp;
  cbKp:
      I64[Sp + 24] = cbKn;
      R1 = P64[Sp + 8];
      I64[Sp + 32] = _saIm::I64;
      Sp = Sp + 24;
      if (R1 & 7 != 0) goto cbKn; else goto cbKq;
  cbKq:
      call (I64[R1])(R1) returns to cbKn, args: 8, res: 8, upd: 8;
  cbKn:
      if (R1 & 7 != 1) goto cbKL; else goto cbN4;
  cbKL:
      I64[Sp - 8] = cbKz;
      _saIs::P64 = P64[R1 + 14];
      R1 = P64[R1 + 6];
      P64[Sp] = _saIs::P64;
      Sp = Sp - 8;
      if (R1 & 7 != 0) goto cbKz; else goto cbKA;
  cbKA:
      call (I64[R1])(R1) returns to cbKz, args: 8, res: 8, upd: 8;
  cbKz:
      I64[Sp - 24] = cbKE;
      _saIv::P64 = P64[R1 + 15];
      _saIx::P64 = P64[R1 + 23];
      _saIw::I64 = I64[R1 + 31];
      R1 = P64[R1 + 7];
      I64[Sp - 16] = _saIw::I64;
      P64[Sp - 8] = _saIx::P64;
      P64[Sp] = _saIv::P64;
      Sp = Sp - 24;
      if (R1 & 7 != 0) goto cbKE; else goto cbKF;
  cbKF:
      call (I64[R1])(R1) returns to cbKE, args: 8, res: 8, upd: 8;
  cbKE:
      I64[Sp - 8] = cbKJ;
      _saIy::P64 = R1;
      _saIz::I64 = I64[R1 + 7];
      R1 = P64[Sp + 24];
      I64[Sp] = _saIz::I64;
      P64[Sp + 24] = _saIy::P64;
      Sp = Sp - 8;
      if (R1 & 7 != 0) goto cbKJ; else goto cbKO;
  cbKO:
      call (I64[R1])(R1) returns to cbKJ, args: 8, res: 8, upd: 8;
  cbKJ:
      _saIy::P64 = P64[Sp + 32];
      _saIz::I64 = I64[Sp + 8];
      _saIA::P64 = R1;
      if (%MO_S_Le_W64(_saIz::I64, 1)) goto cbPl; else goto cbL6;
  cbPl:
      if (%MO_S_Le_W64(1, I64[R1 + 7])) goto cbPk; else goto cbL6;
  cbPk:
      _saIw::I64 = I64[Sp + 16];
      _saIK::I64 = 1 - _saIz::I64;
      if (%MO_S_Le_W64(0, _saIK::I64)) goto cbPj; else goto cbLp;
  cbPj:
      if (%MO_S_Lt_W64(_saIK::I64,
                       _saIw::I64)) goto cbLO; else goto cbLp;
  cbLO:
      _saIS::P64 = P64[P64[Sp + 24] + ((_saIK::I64 << 3) + 24)];
      I64[Sp + 32] = cbLs;
      R1 = _saIS::P64;
      Sp = Sp + 32;
      if (R1 & 7 != 0) goto cbLs; else goto cbLt;
  cbLt:
      call (I64[R1])(R1) returns to cbLs, args: 8, res: 8, upd: 8;
  cbLs:
      I64[Sp - 8] = cbLx;
      _saIU::P64 = P64[R1 + 7];
      R1 = _saIU::P64;
      P64[Sp] = _saIU::P64;
      Sp = Sp - 8;
      call stg_norec_readTVar#(R1) returns to cbLx, args: 8, res: 8, upd: 8;
  cbLx:
      I64[Sp] = cbLz;
      R2 = P64[Sp + 32];
      _saIX::P64 = R1;
      R1 = P64[Sp + 8];
      P64[Sp + 8] = _saIX::P64;
      call stg_norec_writeTVar#(R2,
                                R1) returns to cbLz, args: 8, res: 8, upd: 8;
  cbLz:
      I64[Sp] = cbLD;
      R1 = P64[Sp + 40];
      if (R1 & 7 != 0) goto cbLD; else goto cbLE;
  cbLE:
      call (I64[R1])(R1) returns to cbLD, args: 8, res: 8, upd: 8;
  cbLD:
      I64[Sp - 16] = cbLI;
      _saJ1::P64 = P64[R1 + 15];
      _saJ3::P64 = P64[R1 + 23];
      _saJ2::I64 = I64[R1 + 31];
      R1 = P64[R1 + 7];
      P64[Sp - 8] = _saJ3::P64;
      I64[Sp] = _saJ2::I64;
      P64[Sp + 40] = _saJ1::P64;
      Sp = Sp - 16;
      if (R1 & 7 != 0) goto cbLI; else goto cbLJ;
  cbLJ:
      call (I64[R1])(R1) returns to cbLI, args: 8, res: 8, upd: 8;
  cbLI:
      I64[Sp - 8] = cbLN;
      _saJ4::P64 = R1;
      _saJ5::I64 = I64[R1 + 7];
      R1 = P64[Sp + 56];
      I64[Sp] = _saJ5::I64;
      P64[Sp + 56] = _saJ4::P64;
      Sp = Sp - 8;
      if (R1 & 7 != 0) goto cbLN; else goto cbLU;
  cbLU:
      call (I64[R1])(R1) returns to cbLN, args: 8, res: 8, upd: 8;
  cbLN:
      _saJ4::P64 = P64[Sp + 64];
      _saJ5::I64 = I64[Sp + 8];
      _saJ6::P64 = R1;
      if (%MO_S_Le_W64(_saJ5::I64, 1)) goto cbPi; else goto cbMc;
  cbPi:
      _saJ7::I64 = I64[R1 + 7];
      if (%MO_S_Le_W64(1, _saJ7::I64)) goto cbPh; else goto cbMc;
  cbPh:
      _saJ2::I64 = I64[Sp + 24];
      _saJg::I64 = 1 - _saJ5::I64;
      if (%MO_S_Le_W64(0, _saJg::I64)) goto cbPg; else goto cbMv;
  cbPg:
      if (%MO_S_Lt_W64(_saJg::I64,
                       _saJ2::I64)) goto cbME; else goto cbMv;
  cbME:
      _saJo::P64 = P64[P64[Sp + 16] + ((_saJg::I64 << 3) + 24)];
      I64[Sp - 16] = cbMy;
      R1 = _saJo::P64;
      I64[Sp - 8] = _saJ7::I64;
      P64[Sp] = _saJ6::P64;
      Sp = Sp - 16;
      if (R1 & 7 != 0) goto cbMy; else goto cbMz;
  cbMz:
      call (I64[R1])(R1) returns to cbMy, args: 8, res: 8, upd: 8;
  cbMy:
      I64[Sp] = cbMD;
      R2 = P64[Sp + 48];
      R1 = P64[R1 + 7];
      call stg_norec_writeTVar#(R2,
                                R1) returns to cbMD, args: 8, res: 8, upd: 8;
  cbMD:
      _saIm::I64 = I64[Sp + 64];
      _saJu::P64 = P64[Sp + 56];
      _saJt::I64 = 2;
      goto cbMM;
  cbMM:
      if (HpLim == 0) goto cbMP; else goto cbPf;
  cbMP:
      I64[Sp] = cbMN;
      P64[Sp + 48] = _saJu::P64;
      I64[Sp + 56] = _saJt::I64;
      call stg_gc_noregs() returns to cbMN, args: 8, res: 8, upd: 8;
  cbMN:
      _saIm::I64 = I64[Sp + 64];
      _saJt::I64 = I64[Sp + 56];
      _saJu::P64 = P64[Sp + 48];
      goto cbMM;
  cbPf:
      if (%MO_S_Gt_W64(_saJt::I64,
                       _saIm::I64)) goto ubPr; else goto cbMX;
  ubPr:
      Sp = Sp + 32;
      goto cbPm;
  cbPm:
      R1 = GHC.Tuple.()_closure+1;
      Sp = Sp + 56;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
  cbMX:
      I64[Sp] = cbMV;
      R1 = _saJu::P64;
      I64[Sp + 56] = _saJt::I64;
      if (R1 & 7 != 0) goto cbMV; else goto cbMY;
  cbMY:
      call (I64[R1])(R1) returns to cbMV, args: 8, res: 8, upd: 8;
  cbMV:
      if (R1 & 7 != 1) goto cbNj; else goto ubPs;
  cbNj:
      I64[Sp] = cbN7;
      _saJB::P64 = P64[R1 + 14];
      R1 = P64[R1 + 6];
      P64[Sp + 48] = _saJB::P64;
      if (R1 & 7 != 0) goto cbN7; else goto cbN8;
  cbN8:
      call (I64[R1])(R1) returns to cbN7, args: 8, res: 8, upd: 8;
  cbN7:
      I64[Sp - 24] = cbNc;
      _saJE::P64 = P64[R1 + 15];
      _saJG::P64 = P64[R1 + 23];
      _saJF::I64 = I64[R1 + 31];
      R1 = P64[R1 + 7];
      I64[Sp - 16] = _saJF::I64;
      P64[Sp - 8] = _saJG::P64;
      P64[Sp] = _saJE::P64;
      Sp = Sp - 24;
      if (R1 & 7 != 0) goto cbNc; else goto cbNd;
  cbNd:
      call (I64[R1])(R1) returns to cbNc, args: 8, res: 8, upd: 8;
  cbNc:
      I64[Sp - 8] = cbNh;
      _saJH::P64 = R1;
      _saJI::I64 = I64[R1 + 7];
      R1 = P64[Sp + 24];
      I64[Sp] = _saJI::I64;
      P64[Sp + 24] = _saJH::P64;
      Sp = Sp - 8;
      if (R1 & 7 != 0) goto cbNh; else goto cbNm;
  cbNm:
      call (I64[R1])(R1) returns to cbNh, args: 8, res: 8, upd: 8;
  cbNh:
      Hp = Hp + 16;
      if (Hp > HpLim) goto cbNs; else goto cbNr;
  cbNs:
      HpAlloc = 16;
      R1 = R1;
      call stg_gc_unpt_r1(R1) returns to cbNh, args: 8, res: 8, upd: 8;
  cbNr:
      _saJt::I64 = I64[Sp + 88];
      _saJH::P64 = P64[Sp + 32];
      _saJI::I64 = I64[Sp + 8];
      if (%MO_S_Le_W64(_saJI::I64,
                       _saJt::I64)) goto cbPd; else goto cbNA;
  cbPd:
      if (%MO_S_Le_W64(_saJt::I64,
                       I64[R1 + 7])) goto cbPc; else goto cbNJ;
  cbPc:
      _saJF::I64 = I64[Sp + 16];
      _saJT::I64 = _saJt::I64 - _saJI::I64;
      if (%MO_S_Le_W64(0, _saJT::I64)) goto cbPb; else goto cbO1;
  cbPb:
      if (%MO_S_Lt_W64(_saJT::I64,
                       _saJF::I64)) goto cbOc; else goto cbO1;
  cbOc:
      Hp = Hp - 16;
      _saK1::P64 = P64[P64[Sp + 24] + ((_saJT::I64 << 3) + 24)];
      I64[Sp + 32] = cbO4;
      R1 = _saK1::P64;
      Sp = Sp + 32;
      if (R1 & 7 != 0) goto cbO4; else goto cbO5;
  cbO5:
      call (I64[R1])(R1) returns to cbO4, args: 8, res: 8, upd: 8;
  cbO4:
      I64[Sp - 8] = cbO9;
      _saK3::P64 = P64[R1 + 7];
      R1 = _saK3::P64;
      P64[Sp] = _saK3::P64;
      Sp = Sp - 8;
      call stg_norec_readTVar#(R1) returns to cbO9, args: 8, res: 8, upd: 8;
  cbO9:
      I64[Sp] = cbOb;
      R2 = P64[Sp + 80];
      _saK6::P64 = R1;
      R1 = P64[Sp + 8];
      P64[Sp + 8] = _saK6::P64;
      call stg_norec_writeTVar#(R2,
                                R1) returns to cbOb, args: 8, res: 8, upd: 8;
  cbOb:
      Hp = Hp + 16;
      if (Hp > HpLim) goto cbOk; else goto cbOj;
  cbOk:
      HpAlloc = 16;
      call stg_gc_noregs() returns to cbOb, args: 8, res: 8, upd: 8;
  cbOj:
      _saJ4::P64 = P64[Sp + 88];
      _saJ5::I64 = I64[Sp + 32];
      _saJ6::P64 = P64[Sp + 24];
      _saJt::I64 = I64[Sp + 64];
      if (%MO_S_Le_W64(_saJ5::I64,
                       _saJt::I64)) goto cbPa; else goto cbOs;
  cbPa:
      if (%MO_S_Le_W64(_saJt::I64,
                       I64[Sp + 16])) goto cbP9; else goto cbOB;
  cbP9:
      _saJ2::I64 = I64[Sp + 48];
      _saKg::I64 = _saJt::I64 - _saJ5::I64;
      if (%MO_S_Le_W64(0, _saKg::I64)) goto cbP8; else goto cbOT;
  cbP8:
      if (%MO_S_Lt_W64(_saKg::I64,
                       _saJ2::I64)) goto cbP2; else goto cbOT;
  cbP2:
      Hp = Hp - 16;
      _saKo::P64 = P64[P64[Sp + 40] + ((_saKg::I64 << 3) + 24)];
      I64[Sp] = cbOW;
      R1 = _saKo::P64;
      if (R1 & 7 != 0) goto cbOW; else goto cbOX;
  cbOX:
      call (I64[R1])(R1) returns to cbOW, args: 8, res: 8, upd: 8;
  cbOW:
      _saK6::P64 = P64[Sp + 8];
      I64[Sp + 8] = cbP1;
      R2 = _saK6::P64;
      R1 = P64[R1 + 7];
      Sp = Sp + 8;
      call stg_norec_writeTVar#(R2,
                                R1) returns to cbP1, args: 8, res: 8, upd: 8;
  cbP1:
      _saIm::I64 = I64[Sp + 64];
      _saJu::P64 = P64[Sp + 48];
      _saJt::I64 = I64[Sp + 56] + 1;
      goto cbMM;
  cbOT:
      Hp = Hp - 16;
      R3 = _saKg::I64;
      R2 = _saJ2::I64;
      Sp = Sp + 96;
      call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
  cbOB:
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _saJt::I64;
      R4 = _saJ6::P64;
      R3 = _saJ4::P64;
      R2 = Hp - 7;
      Sp = Sp + 96;
      call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbOs:
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _saJt::I64;
      R4 = _saJ6::P64;
      R3 = _saJ4::P64;
      R2 = Hp - 7;
      Sp = Sp + 96;
      call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbO1:
      Hp = Hp - 16;
      R3 = _saJT::I64;
      R2 = _saJF::I64;
      Sp = Sp + 120;
      call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
  cbNJ:
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _saJt::I64;
      R4 = R1;
      R3 = _saJH::P64;
      R2 = Hp - 7;
      Sp = Sp + 120;
      call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbNA:
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _saJt::I64;
      R4 = R1;
      R3 = _saJH::P64;
      R2 = Hp - 7;
      Sp = Sp + 120;
      call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  ubPs:
      Sp = Sp + 56;
      goto cbN4;
  cbMv:
      R3 = _saJg::I64;
      R2 = _saJ2::I64;
      Sp = Sp + 72;
      call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
  cbMc:
      R4 = _saJ6::P64;
      R3 = _saJ4::P64;
      R2 = stg_INTLIKE_closure+273;
      Sp = Sp + 72;
      call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbLp:
      R3 = _saIK::I64;
      R2 = _saIw::I64;
      Sp = Sp + 72;
      call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
  cbL6:
      R4 = _saIA::P64;
      R3 = _saIy::P64;
      R2 = stg_INTLIKE_closure+273;
      Sp = Sp + 72;
      call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
  cbN4:
      R1 = lvl40_rawz_closure;
      Sp = Sp + 32;
      call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:47.302897 UTC

[(cbD0,
  {GHC.Arr.$fIxInt_closure, SkipList.$fMArrayTArrayeSTM8_closure,
   lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure,
   $s$wa_saFN_closure, $wa8_saFO_closure, nodesHeight_saHs_closure}),
 (cbD2,
  {GHC.Arr.$fIxInt_closure, SkipList.$fMArrayTArrayeSTM8_closure,
   lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure,
   $s$wa_saFN_closure, $wa8_saFO_closure, nodesHeight_saHs_closure}),
 (cbD3,
  {GHC.Arr.$fIxInt_closure, SkipList.$fMArrayTArrayeSTM8_closure,
   lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure,
   $s$wa_saFN_closure, $wa8_saFO_closure, nodesHeight_saHs_closure}),
 (cbHA,
  {GHC.Arr.$fIxInt_closure, SkipList.$fMArrayTArrayeSTM8_closure,
   lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure,
   nodesHeight_saHs_closure}),
 (cbHC,
  {GHC.Arr.$fIxInt_closure, SkipList.$fMArrayTArrayeSTM8_closure,
   lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure,
   nodesHeight_saHs_closure}),
 (cbHE,
  {GHC.Arr.$fIxInt_closure, SkipList.$fMArrayTArrayeSTM8_closure,
   lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure,
   nodesHeight_saHs_closure}),
 (cbHF,
  {GHC.Arr.$fIxInt_closure, SkipList.$fMArrayTArrayeSTM8_closure,
   lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure,
   nodesHeight_saHs_closure}),
 (cbHG,
  {GHC.Arr.$fIxInt_closure, SkipList.$fMArrayTArrayeSTM8_closure,
   lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure,
   nodesHeight_saHs_closure}),
 (cbJO,
  {GHC.Arr.$fIxInt_closure, SkipList.$fMArrayTArrayeSTM8_closure,
   SkipList.$wa4_closure, lvl29_rawn_closure, lvl30_rawo_closure,
   lvl40_rawz_closure, $s$wa_saFN_closure, $wa8_saFO_closure,
   nodesHeight_saHs_closure}),
 (cbJQ,
  {lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure}),
 (cbJS,
  {lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure}),
 (cbJW,
  {lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure}),
 (cbJX, {SkipList.$wa4_closure}),
 (cbJY,
  {GHC.Arr.$fIxInt_closure, SkipList.$fMArrayTArrayeSTM8_closure,
   SkipList.$wa4_closure, lvl29_rawn_closure, lvl30_rawo_closure,
   lvl40_rawz_closure, $s$wa_saFN_closure, $wa8_saFO_closure,
   nodesHeight_saHs_closure}),
 (cbJZ,
  {GHC.Arr.$fIxInt_closure, SkipList.$fMArrayTArrayeSTM8_closure,
   lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure,
   $s$wa_saFN_closure, $wa8_saFO_closure, nodesHeight_saHs_closure}),
 (cbK2,
  {GHC.Arr.$fIxInt_closure, SkipList.$fMArrayTArrayeSTM8_closure,
   lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure,
   $s$wa_saFN_closure, $wa8_saFO_closure, nodesHeight_saHs_closure}),
 (cbK3,
  {GHC.Arr.$fIxInt_closure, SkipList.$fMArrayTArrayeSTM8_closure,
   lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure,
   $s$wa_saFN_closure, $wa8_saFO_closure, nodesHeight_saHs_closure}),
 (cbK7,
  {GHC.Arr.$fIxInt_closure, SkipList.$fMArrayTArrayeSTM8_closure,
   lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure,
   nodesHeight_saHs_closure}),
 (cbK8,
  {GHC.Arr.$fIxInt_closure, SkipList.$fMArrayTArrayeSTM8_closure,
   lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure,
   nodesHeight_saHs_closure}),
 (cbKb,
  {lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure}),
 (cbKc,
  {lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure}),
 (cbKd,
  {lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure}),
 (cbKn,
  {lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure}),
 (cbKp,
  {lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure}),
 (cbKq,
  {lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure}),
 (cbKz,
  {lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure}),
 (cbKA,
  {lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure}),
 (cbKE,
  {lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure}),
 (cbKF,
  {lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure}),
 (cbKJ,
  {lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure}),
 (cbKL,
  {lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure}),
 (cbKO,
  {lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure}),
 (cbL6, {lvl30_rawo_closure}), (cbLp, {lvl29_rawn_closure}),
 (cbLs,
  {lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure}),
 (cbLt,
  {lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure}),
 (cbLx,
  {lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure}),
 (cbLz,
  {lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure}),
 (cbLD,
  {lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure}),
 (cbLE,
  {lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure}),
 (cbLI,
  {lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure}),
 (cbLJ,
  {lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure}),
 (cbLN,
  {lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure}),
 (cbLO,
  {lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure}),
 (cbLU,
  {lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure}),
 (cbMc, {lvl30_rawo_closure}), (cbMv, {lvl29_rawn_closure}),
 (cbMy,
  {lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure}),
 (cbMz,
  {lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure}),
 (cbMD,
  {lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure}),
 (cbME,
  {lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure}),
 (cbMM,
  {lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure}),
 (cbMN,
  {lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure}),
 (cbMP,
  {lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure}),
 (cbMV,
  {lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure}),
 (cbMX,
  {lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure}),
 (cbMY,
  {lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure}),
 (cbN4, {lvl40_rawz_closure}),
 (cbN7,
  {lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure}),
 (cbN8,
  {lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure}),
 (cbNc,
  {lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure}),
 (cbNd,
  {lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure}),
 (cbNh,
  {lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure}),
 (cbNj,
  {lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure}),
 (cbNm,
  {lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure}),
 (cbNr,
  {lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure}),
 (cbNs,
  {lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure}),
 (cbNA, {lvl30_rawo_closure}), (cbNJ, {lvl30_rawo_closure}),
 (cbO1, {lvl29_rawn_closure}),
 (cbO4,
  {lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure}),
 (cbO5,
  {lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure}),
 (cbO9,
  {lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure}),
 (cbOb,
  {lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure}),
 (cbOc,
  {lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure}),
 (cbOj,
  {lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure}),
 (cbOk,
  {lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure}),
 (cbOs, {lvl30_rawo_closure}), (cbOB, {lvl30_rawo_closure}),
 (cbOT, {lvl29_rawn_closure}),
 (cbOW,
  {lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure}),
 (cbOX,
  {lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure}),
 (cbP1,
  {lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure}),
 (cbP2,
  {lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure}),
 (cbP8,
  {lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure}),
 (cbP9,
  {lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure}),
 (cbPa,
  {lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure}),
 (cbPb,
  {lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure}),
 (cbPc,
  {lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure}),
 (cbPd,
  {lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure}),
 (cbPf,
  {lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure}),
 (cbPg,
  {lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure}),
 (cbPh,
  {lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure}),
 (cbPi,
  {lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure}),
 (cbPj,
  {lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure}),
 (cbPk,
  {lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure}),
 (cbPl,
  {lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure}),
 (cbPm, {}),
 (ubPq,
  {GHC.Arr.$fIxInt_closure, SkipList.$fMArrayTArrayeSTM8_closure,
   lvl29_rawn_closure, lvl30_rawo_closure, lvl40_rawz_closure,
   nodesHeight_saHs_closure}),
 (ubPr, {}), (ubPs, {lvl40_rawz_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:47.316298 UTC

SkipList.$wa4_entry() //  [R6, R5, R4, R3, R2]
        { info_tbl: [(cbD0,
                      label: block_cbD0_info
                      rep:StackRep [False, False, False, False, False]),
                     (cbD2,
                      label: block_cbD2_info
                      rep:StackRep [False, False, False, False, False]),
                     (cbHA,
                      label: block_cbHA_info
                      rep:StackRep [True, False, False, False, False]),
                     (cbHC,
                      label: block_cbHC_info
                      rep:StackRep [False, True, False, False, False, False]),
                     (cbHE,
                      label: block_cbHE_info
                      rep:StackRep [False, True, False, False, False, False]),
                     (cbHG,
                      label: block_cbHG_info
                      rep:StackRep [True, False, True, False, False, False, False]),
                     (cbJO,
                      label: SkipList.$wa4_info
                      rep:HeapRep static { Fun {arity: 7 fun_type: ArgSpec 26} }),
                     (cbJQ,
                      label: block_cbJQ_info
                      rep:StackRep [False, True, True, False, False, False]),
                     (cbJS,
                      label: block_cbJS_info
                      rep:StackRep [False, True, True, False, False, False]),
                     (cbJW,
                      label: block_cbJW_info
                      rep:StackRep [False, True, True, True, False, False]),
                     (cbKn,
                      label: block_cbKn_info
                      rep:StackRep [True, False, False]),
                     (cbKz,
                      label: block_cbKz_info
                      rep:StackRep [False, True, False, False]),
                     (cbKE,
                      label: block_cbKE_info
                      rep:StackRep [True, False, False, False, True, False, False]),
                     (cbKJ,
                      label: block_cbKJ_info
                      rep:StackRep [True, True, False, False, False, True, False,
                                    False]),
                     (cbLs,
                      label: block_cbLs_info
                      rep:StackRep [False, True, False, False]),
                     (cbLx,
                      label: block_cbLx_info
                      rep:StackRep [False, False, True, False, False]),
                     (cbLz,
                      label: block_cbLz_info
                      rep:StackRep [False, False, True, False, False]),
                     (cbLD,
                      label: block_cbLD_info
                      rep:StackRep [False, False, True, False, True]),
                     (cbLI,
                      label: block_cbLI_info
                      rep:StackRep [False, True, False, False, True, False, False]),
                     (cbLN,
                      label: block_cbLN_info
                      rep:StackRep [True, False, True, False, False, True, False,
                                    False]),
                     (cbMy,
                      label: block_cbMy_info
                      rep:StackRep [True, False, True, False, True, False, False, True,
                                    False, False]),
                     (cbMD,
                      label: block_cbMD_info
                      rep:StackRep [True, False, True, False, True, True, False, True,
                                    False, False]),
                     (cbMN,
                      label: block_cbMN_info
                      rep:StackRep [True, False, True, False, True, False, True, True,
                                    False, False]),
                     (cbMV,
                      label: block_cbMV_info
                      rep:StackRep [True, False, True, False, True, True, True, True,
                                    False, False]),
                     (cbN7,
                      label: block_cbN7_info
                      rep:StackRep [True, False, True, False, True, False, True, True,
                                    False, False]),
                     (cbNc,
                      label: block_cbNc_info
                      rep:StackRep [True, False, False, True, False, True, False, True,
                                    False, True, True, False, False]),
                     (cbNh,
                      label: block_cbNh_info
                      rep:StackRep [True, True, False, False, True, False, True, False,
                                    True, False, True, True, False, False]),
                     (cbO4,
                      label: block_cbO4_info
                      rep:StackRep [True, False, True, False, True, False, True, True,
                                    False, False]),
                     (cbO9,
                      label: block_cbO9_info
                      rep:StackRep [False, True, False, True, False, True, False, True,
                                    True, False, False]),
                     (cbOb,
                      label: block_cbOb_info
                      rep:StackRep [False, True, False, True, False, True, False, True,
                                    True, False, False]),
                     (cbOW,
                      label: block_cbOW_info
                      rep:StackRep [False, True, False, True, False, True, False, True,
                                    True, False, False]),
                     (cbP1,
                      label: block_cbP1_info
                      rep:StackRep [True, False, True, False, True, False, True, True,
                                    False, False])]
          stack_info: arg_space: 16 updfr_space: Just 8
        }
    {offset
      cbJO:
          _saFF::P64 = R6;
          _saFE::P64 = R5;
          _saFD::P64 = R4;
          _saFC::P64 = R3;
          _saFB::P64 = R2;
          if ((Sp + -112) < SpLim) goto cbJX; else goto cbJY;
      cbJY:
          if (HpLim == 0) goto cbJX; else goto cbJZ;
      cbJX:
          R6 = _saFF::P64;
          R5 = _saFE::P64;
          R4 = _saFD::P64;
          R3 = _saFC::P64;
          R2 = _saFB::P64;
          R1 = SkipList.$wa4_closure;
          call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
      cbJZ:
          I64[Sp - 40] = cbD0;
          R1 = _saFD::P64;
          P64[Sp - 32] = _saFB::P64;
          P64[Sp - 24] = _saFC::P64;
          P64[Sp - 16] = _saFE::P64;
          P64[Sp - 8] = _saFF::P64;
          Sp = Sp - 40;
          call stg_norec_readTVar#(R1) returns to cbD0, args: 8, res: 8, upd: 8;
      cbD0:
          I64[Sp] = cbD2;
          R1 = R1;
          if (R1 & 7 != 0) goto cbD2; else goto cbD3;
      cbD3:
          call (I64[R1])(R1) returns to cbD2, args: 8, res: 8, upd: 8;
      cbD2:
          Hp = Hp + 64;
          if (Hp > HpLim) goto cbK3; else goto cbK2;
      cbK3:
          HpAlloc = 64;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to cbD2, args: 8, res: 8, upd: 8;
      cbK2:
          _saFM::I64 = I64[R1 + 7];
          I64[Hp - 56] = $wa8_saFO_info;
          _saFB::P64 = P64[Sp + 8];
          P64[Hp - 48] = _saFB::P64;
          _saFF::P64 = P64[Sp + 32];
          P64[Hp - 40] = _saFF::P64;
          P64[Hp - 32] = Hp - 24;
          I64[Hp - 24] = $s$wa_saFN_info;
          P64[Hp - 16] = _saFB::P64;
          P64[Hp - 8] = _saFF::P64;
          _cbD7::P64 = Hp - 52;
          P64[Hp] = _cbD7::P64;
          I64[Sp] = cbHA;
          R4 = GHC.Types.[]_closure+1;
          R3 = _saFM::I64;
          R2 = P64[Sp + 16];
          _saFL::P64 = R1;
          R1 = _cbD7::P64;
          I64[Sp + 8] = _saFM::I64;
          P64[Sp + 16] = _saFL::P64;
          call $wa8_saFO_info(R4,
                              R3,
                              R2,
                              R1) returns to cbHA, args: 8, res: 8, upd: 8;
      cbHA:
          I64[Sp - 8] = cbHC;
          P64[Sp] = R1;
          Sp = Sp - 8;
          call stg_myThreadId#() returns to cbHC, args: 8, res: 8, upd: 8;
      cbHC:
          I64[Sp] = cbHE;
          R1 = R1;
          call stg_threadStatus#(R1) returns to cbHE, args: 8, res: 8, upd: 8;
      cbHE:
          _saFE::P64 = P64[Sp + 32];
          _saFL::P64 = P64[Sp + 24];
          _saFM::I64 = I64[Sp + 16];
          _saHq::I64 = R2;
          goto cbHF;
      cbHF:
          Hp = Hp + 72;
          if (Hp > HpLim) goto cbK8; else goto cbK7;
      cbK8:
          HpAlloc = 72;
          I64[Sp - 8] = cbHG;
          I64[Sp] = _saHq::I64;
          Sp = Sp - 8;
          call stg_gc_noregs() returns to cbHG, args: 8, res: 8, upd: 8;
      cbHG:
          goto ubPq;
      ubPq:
          _saFE::P64 = P64[Sp + 40];
          _saFL::P64 = P64[Sp + 32];
          _saFM::I64 = I64[Sp + 24];
          _saHq::I64 = I64[Sp + 8];
          Sp = Sp + 8;
          goto cbHF;
      cbK7:
          I64[Hp - 64] = nodesHeight_saHs_info;
          P64[Hp - 48] = _saFE::P64;
          P64[Hp - 40] = _saFL::P64;
          I64[Hp - 32] = _saFM::I64;
          I64[Hp - 24] = _saHq::I64;
          I64[Hp - 16] = (,)_con_info;
          P64[Hp - 8] = SkipList.newSL10_closure+1;
          _cbHI::P64 = Hp - 64;
          P64[Hp] = _cbHI::P64;
          I64[Sp] = cbJQ;
          R3 = Hp - 15;
          R2 = GHC.Arr.$fIxInt_closure;
          P64[Sp + 32] = _cbHI::P64;
          call SkipList.$fMArrayTArrayeSTM8_info(R3,
                                                 R2) returns to cbJQ, args: 8, res: 8, upd: 8;
      cbJQ:
          I64[Sp] = cbJS;
          _saIf::P64 = R1;
          R1 = P64[Sp + 48];
          P64[Sp + 48] = _saIf::P64;
          call stg_newNOrecTVar#(R1) returns to cbJS, args: 8, res: 8, upd: 8;
      cbJS:
          Hp = Hp + 48;
          if (Hp > HpLim) goto cbKc; else goto cbKb;
      cbKc:
          HpAlloc = 48;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to cbJS, args: 8, res: 8, upd: 8;
      cbKb:
          I64[Hp - 40] = GHC.Conc.Sync.TVar_con_info;
          P64[Hp - 32] = R1;
          I64[Hp - 24] = SkipList.Node_con_info;
          P64[Hp - 16] = P64[Sp + 40];
          P64[Hp - 8] = Hp - 39;
          P64[Hp] = P64[Sp + 48];
          I64[Sp] = cbJW;
          R1 = P64[Sp + 32];
          P64[Sp + 40] = Hp - 22;
          if (R1 & 7 != 0) goto cbJW; else goto cbKd;
      cbKd:
          call (I64[R1])(R1) returns to cbJW, args: 8, res: 8, upd: 8;
      cbJW:
          _saIm::I64 = I64[R1 + 7];
          if (%MO_S_Gt_W64(1, _saIm::I64)) goto cbPm; else goto cbKp;
      cbKp:
          I64[Sp + 24] = cbKn;
          R1 = P64[Sp + 8];
          I64[Sp + 32] = _saIm::I64;
          Sp = Sp + 24;
          if (R1 & 7 != 0) goto cbKn; else goto cbKq;
      cbKq:
          call (I64[R1])(R1) returns to cbKn, args: 8, res: 8, upd: 8;
      cbKn:
          if (R1 & 7 != 1) goto cbKL; else goto cbN4;
      cbKL:
          I64[Sp - 8] = cbKz;
          _saIs::P64 = P64[R1 + 14];
          R1 = P64[R1 + 6];
          P64[Sp] = _saIs::P64;
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto cbKz; else goto cbKA;
      cbKA:
          call (I64[R1])(R1) returns to cbKz, args: 8, res: 8, upd: 8;
      cbKz:
          I64[Sp - 24] = cbKE;
          _saIv::P64 = P64[R1 + 15];
          _saIx::P64 = P64[R1 + 23];
          _saIw::I64 = I64[R1 + 31];
          R1 = P64[R1 + 7];
          I64[Sp - 16] = _saIw::I64;
          P64[Sp - 8] = _saIx::P64;
          P64[Sp] = _saIv::P64;
          Sp = Sp - 24;
          if (R1 & 7 != 0) goto cbKE; else goto cbKF;
      cbKF:
          call (I64[R1])(R1) returns to cbKE, args: 8, res: 8, upd: 8;
      cbKE:
          I64[Sp - 8] = cbKJ;
          _saIy::P64 = R1;
          _saIz::I64 = I64[R1 + 7];
          R1 = P64[Sp + 24];
          I64[Sp] = _saIz::I64;
          P64[Sp + 24] = _saIy::P64;
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto cbKJ; else goto cbKO;
      cbKO:
          call (I64[R1])(R1) returns to cbKJ, args: 8, res: 8, upd: 8;
      cbKJ:
          _saIy::P64 = P64[Sp + 32];
          _saIz::I64 = I64[Sp + 8];
          _saIA::P64 = R1;
          if (%MO_S_Le_W64(_saIz::I64, 1)) goto cbPl; else goto cbL6;
      cbPl:
          if (%MO_S_Le_W64(1, I64[R1 + 7])) goto cbPk; else goto cbL6;
      cbPk:
          _saIw::I64 = I64[Sp + 16];
          _saIK::I64 = 1 - _saIz::I64;
          if (%MO_S_Le_W64(0, _saIK::I64)) goto cbPj; else goto cbLp;
      cbPj:
          if (%MO_S_Lt_W64(_saIK::I64,
                           _saIw::I64)) goto cbLO; else goto cbLp;
      cbLO:
          _saIS::P64 = P64[P64[Sp + 24] + ((_saIK::I64 << 3) + 24)];
          I64[Sp + 32] = cbLs;
          R1 = _saIS::P64;
          Sp = Sp + 32;
          if (R1 & 7 != 0) goto cbLs; else goto cbLt;
      cbLt:
          call (I64[R1])(R1) returns to cbLs, args: 8, res: 8, upd: 8;
      cbLs:
          I64[Sp - 8] = cbLx;
          _saIU::P64 = P64[R1 + 7];
          R1 = _saIU::P64;
          P64[Sp] = _saIU::P64;
          Sp = Sp - 8;
          call stg_norec_readTVar#(R1) returns to cbLx, args: 8, res: 8, upd: 8;
      cbLx:
          I64[Sp] = cbLz;
          R2 = P64[Sp + 32];
          _saIX::P64 = R1;
          R1 = P64[Sp + 8];
          P64[Sp + 8] = _saIX::P64;
          call stg_norec_writeTVar#(R2,
                                    R1) returns to cbLz, args: 8, res: 8, upd: 8;
      cbLz:
          I64[Sp] = cbLD;
          R1 = P64[Sp + 40];
          if (R1 & 7 != 0) goto cbLD; else goto cbLE;
      cbLE:
          call (I64[R1])(R1) returns to cbLD, args: 8, res: 8, upd: 8;
      cbLD:
          I64[Sp - 16] = cbLI;
          _saJ1::P64 = P64[R1 + 15];
          _saJ3::P64 = P64[R1 + 23];
          _saJ2::I64 = I64[R1 + 31];
          R1 = P64[R1 + 7];
          P64[Sp - 8] = _saJ3::P64;
          I64[Sp] = _saJ2::I64;
          P64[Sp + 40] = _saJ1::P64;
          Sp = Sp - 16;
          if (R1 & 7 != 0) goto cbLI; else goto cbLJ;
      cbLJ:
          call (I64[R1])(R1) returns to cbLI, args: 8, res: 8, upd: 8;
      cbLI:
          I64[Sp - 8] = cbLN;
          _saJ4::P64 = R1;
          _saJ5::I64 = I64[R1 + 7];
          R1 = P64[Sp + 56];
          I64[Sp] = _saJ5::I64;
          P64[Sp + 56] = _saJ4::P64;
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto cbLN; else goto cbLU;
      cbLU:
          call (I64[R1])(R1) returns to cbLN, args: 8, res: 8, upd: 8;
      cbLN:
          _saJ4::P64 = P64[Sp + 64];
          _saJ5::I64 = I64[Sp + 8];
          _saJ6::P64 = R1;
          if (%MO_S_Le_W64(_saJ5::I64, 1)) goto cbPi; else goto cbMc;
      cbPi:
          _saJ7::I64 = I64[R1 + 7];
          if (%MO_S_Le_W64(1, _saJ7::I64)) goto cbPh; else goto cbMc;
      cbPh:
          _saJ2::I64 = I64[Sp + 24];
          _saJg::I64 = 1 - _saJ5::I64;
          if (%MO_S_Le_W64(0, _saJg::I64)) goto cbPg; else goto cbMv;
      cbPg:
          if (%MO_S_Lt_W64(_saJg::I64,
                           _saJ2::I64)) goto cbME; else goto cbMv;
      cbME:
          _saJo::P64 = P64[P64[Sp + 16] + ((_saJg::I64 << 3) + 24)];
          I64[Sp - 16] = cbMy;
          R1 = _saJo::P64;
          I64[Sp - 8] = _saJ7::I64;
          P64[Sp] = _saJ6::P64;
          Sp = Sp - 16;
          if (R1 & 7 != 0) goto cbMy; else goto cbMz;
      cbMz:
          call (I64[R1])(R1) returns to cbMy, args: 8, res: 8, upd: 8;
      cbMy:
          I64[Sp] = cbMD;
          R2 = P64[Sp + 48];
          R1 = P64[R1 + 7];
          call stg_norec_writeTVar#(R2,
                                    R1) returns to cbMD, args: 8, res: 8, upd: 8;
      cbMD:
          _saIm::I64 = I64[Sp + 64];
          _saJu::P64 = P64[Sp + 56];
          _saJt::I64 = 2;
          goto cbMM;
      cbMM:
          if (HpLim == 0) goto cbMP; else goto cbPf;
      cbMP:
          I64[Sp] = cbMN;
          P64[Sp + 48] = _saJu::P64;
          I64[Sp + 56] = _saJt::I64;
          call stg_gc_noregs() returns to cbMN, args: 8, res: 8, upd: 8;
      cbMN:
          _saIm::I64 = I64[Sp + 64];
          _saJt::I64 = I64[Sp + 56];
          _saJu::P64 = P64[Sp + 48];
          goto cbMM;
      cbPf:
          if (%MO_S_Gt_W64(_saJt::I64,
                           _saIm::I64)) goto ubPr; else goto cbMX;
      ubPr:
          Sp = Sp + 32;
          goto cbPm;
      cbPm:
          R1 = GHC.Tuple.()_closure+1;
          Sp = Sp + 56;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
      cbMX:
          I64[Sp] = cbMV;
          R1 = _saJu::P64;
          I64[Sp + 56] = _saJt::I64;
          if (R1 & 7 != 0) goto cbMV; else goto cbMY;
      cbMY:
          call (I64[R1])(R1) returns to cbMV, args: 8, res: 8, upd: 8;
      cbMV:
          if (R1 & 7 != 1) goto cbNj; else goto ubPs;
      cbNj:
          I64[Sp] = cbN7;
          _saJB::P64 = P64[R1 + 14];
          R1 = P64[R1 + 6];
          P64[Sp + 48] = _saJB::P64;
          if (R1 & 7 != 0) goto cbN7; else goto cbN8;
      cbN8:
          call (I64[R1])(R1) returns to cbN7, args: 8, res: 8, upd: 8;
      cbN7:
          I64[Sp - 24] = cbNc;
          _saJE::P64 = P64[R1 + 15];
          _saJG::P64 = P64[R1 + 23];
          _saJF::I64 = I64[R1 + 31];
          R1 = P64[R1 + 7];
          I64[Sp - 16] = _saJF::I64;
          P64[Sp - 8] = _saJG::P64;
          P64[Sp] = _saJE::P64;
          Sp = Sp - 24;
          if (R1 & 7 != 0) goto cbNc; else goto cbNd;
      cbNd:
          call (I64[R1])(R1) returns to cbNc, args: 8, res: 8, upd: 8;
      cbNc:
          I64[Sp - 8] = cbNh;
          _saJH::P64 = R1;
          _saJI::I64 = I64[R1 + 7];
          R1 = P64[Sp + 24];
          I64[Sp] = _saJI::I64;
          P64[Sp + 24] = _saJH::P64;
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto cbNh; else goto cbNm;
      cbNm:
          call (I64[R1])(R1) returns to cbNh, args: 8, res: 8, upd: 8;
      cbNh:
          Hp = Hp + 16;
          if (Hp > HpLim) goto cbNs; else goto cbNr;
      cbNs:
          HpAlloc = 16;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to cbNh, args: 8, res: 8, upd: 8;
      cbNr:
          _saJt::I64 = I64[Sp + 88];
          _saJH::P64 = P64[Sp + 32];
          _saJI::I64 = I64[Sp + 8];
          if (%MO_S_Le_W64(_saJI::I64,
                           _saJt::I64)) goto cbPd; else goto cbNA;
      cbPd:
          if (%MO_S_Le_W64(_saJt::I64,
                           I64[R1 + 7])) goto cbPc; else goto cbNJ;
      cbPc:
          _saJF::I64 = I64[Sp + 16];
          _saJT::I64 = _saJt::I64 - _saJI::I64;
          if (%MO_S_Le_W64(0, _saJT::I64)) goto cbPb; else goto cbO1;
      cbPb:
          if (%MO_S_Lt_W64(_saJT::I64,
                           _saJF::I64)) goto cbOc; else goto cbO1;
      cbOc:
          Hp = Hp - 16;
          _saK1::P64 = P64[P64[Sp + 24] + ((_saJT::I64 << 3) + 24)];
          I64[Sp + 32] = cbO4;
          R1 = _saK1::P64;
          Sp = Sp + 32;
          if (R1 & 7 != 0) goto cbO4; else goto cbO5;
      cbO5:
          call (I64[R1])(R1) returns to cbO4, args: 8, res: 8, upd: 8;
      cbO4:
          I64[Sp - 8] = cbO9;
          _saK3::P64 = P64[R1 + 7];
          R1 = _saK3::P64;
          P64[Sp] = _saK3::P64;
          Sp = Sp - 8;
          call stg_norec_readTVar#(R1) returns to cbO9, args: 8, res: 8, upd: 8;
      cbO9:
          I64[Sp] = cbOb;
          R2 = P64[Sp + 80];
          _saK6::P64 = R1;
          R1 = P64[Sp + 8];
          P64[Sp + 8] = _saK6::P64;
          call stg_norec_writeTVar#(R2,
                                    R1) returns to cbOb, args: 8, res: 8, upd: 8;
      cbOb:
          Hp = Hp + 16;
          if (Hp > HpLim) goto cbOk; else goto cbOj;
      cbOk:
          HpAlloc = 16;
          call stg_gc_noregs() returns to cbOb, args: 8, res: 8, upd: 8;
      cbOj:
          _saJ4::P64 = P64[Sp + 88];
          _saJ5::I64 = I64[Sp + 32];
          _saJ6::P64 = P64[Sp + 24];
          _saJt::I64 = I64[Sp + 64];
          if (%MO_S_Le_W64(_saJ5::I64,
                           _saJt::I64)) goto cbPa; else goto cbOs;
      cbPa:
          if (%MO_S_Le_W64(_saJt::I64,
                           I64[Sp + 16])) goto cbP9; else goto cbOB;
      cbP9:
          _saJ2::I64 = I64[Sp + 48];
          _saKg::I64 = _saJt::I64 - _saJ5::I64;
          if (%MO_S_Le_W64(0, _saKg::I64)) goto cbP8; else goto cbOT;
      cbP8:
          if (%MO_S_Lt_W64(_saKg::I64,
                           _saJ2::I64)) goto cbP2; else goto cbOT;
      cbP2:
          Hp = Hp - 16;
          _saKo::P64 = P64[P64[Sp + 40] + ((_saKg::I64 << 3) + 24)];
          I64[Sp] = cbOW;
          R1 = _saKo::P64;
          if (R1 & 7 != 0) goto cbOW; else goto cbOX;
      cbOX:
          call (I64[R1])(R1) returns to cbOW, args: 8, res: 8, upd: 8;
      cbOW:
          _saK6::P64 = P64[Sp + 8];
          I64[Sp + 8] = cbP1;
          R2 = _saK6::P64;
          R1 = P64[R1 + 7];
          Sp = Sp + 8;
          call stg_norec_writeTVar#(R2,
                                    R1) returns to cbP1, args: 8, res: 8, upd: 8;
      cbP1:
          _saIm::I64 = I64[Sp + 64];
          _saJu::P64 = P64[Sp + 48];
          _saJt::I64 = I64[Sp + 56] + 1;
          goto cbMM;
      cbOT:
          Hp = Hp - 16;
          R3 = _saKg::I64;
          R2 = _saJ2::I64;
          Sp = Sp + 96;
          call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
      cbOB:
          I64[Hp - 8] = GHC.Types.I#_con_info;
          I64[Hp] = _saJt::I64;
          R4 = _saJ6::P64;
          R3 = _saJ4::P64;
          R2 = Hp - 7;
          Sp = Sp + 96;
          call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
      cbOs:
          I64[Hp - 8] = GHC.Types.I#_con_info;
          I64[Hp] = _saJt::I64;
          R4 = _saJ6::P64;
          R3 = _saJ4::P64;
          R2 = Hp - 7;
          Sp = Sp + 96;
          call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
      cbO1:
          Hp = Hp - 16;
          R3 = _saJT::I64;
          R2 = _saJF::I64;
          Sp = Sp + 120;
          call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
      cbNJ:
          I64[Hp - 8] = GHC.Types.I#_con_info;
          I64[Hp] = _saJt::I64;
          R4 = R1;
          R3 = _saJH::P64;
          R2 = Hp - 7;
          Sp = Sp + 120;
          call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
      cbNA:
          I64[Hp - 8] = GHC.Types.I#_con_info;
          I64[Hp] = _saJt::I64;
          R4 = R1;
          R3 = _saJH::P64;
          R2 = Hp - 7;
          Sp = Sp + 120;
          call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
      ubPs:
          Sp = Sp + 56;
          goto cbN4;
      cbMv:
          R3 = _saJg::I64;
          R2 = _saJ2::I64;
          Sp = Sp + 72;
          call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
      cbMc:
          R4 = _saJ6::P64;
          R3 = _saJ4::P64;
          R2 = stg_INTLIKE_closure+273;
          Sp = Sp + 72;
          call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
      cbLp:
          R3 = _saIK::I64;
          R2 = _saIw::I64;
          Sp = Sp + 72;
          call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
      cbL6:
          R4 = _saIA::P64;
          R3 = _saIy::P64;
          R2 = stg_INTLIKE_closure+273;
          Sp = Sp + 72;
          call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
      cbN4:
          R1 = lvl40_rawz_closure;
          Sp = Sp + 32;
          call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:47.346566 UTC

SkipList.$wa4_entry() //  [R6, R5, R4, R3, R2]
        { info_tbl: [(cbD0,
                      label: block_cbD0_info
                      rep:StackRep [False, False, False, False, False]),
                     (cbD2,
                      label: block_cbD2_info
                      rep:StackRep [False, False, False, False, False]),
                     (cbHA,
                      label: block_cbHA_info
                      rep:StackRep [True, False, False, False, False]),
                     (cbHC,
                      label: block_cbHC_info
                      rep:StackRep [False, True, False, False, False, False]),
                     (cbHE,
                      label: block_cbHE_info
                      rep:StackRep [False, True, False, False, False, False]),
                     (cbHG,
                      label: block_cbHG_info
                      rep:StackRep [True, False, True, False, False, False, False]),
                     (cbJO,
                      label: SkipList.$wa4_info
                      rep:HeapRep static { Fun {arity: 7 fun_type: ArgSpec 26} }),
                     (cbJQ,
                      label: block_cbJQ_info
                      rep:StackRep [False, True, True, False, False, False]),
                     (cbJS,
                      label: block_cbJS_info
                      rep:StackRep [False, True, True, False, False, False]),
                     (cbJW,
                      label: block_cbJW_info
                      rep:StackRep [False, True, True, True, False, False]),
                     (cbKn,
                      label: block_cbKn_info
                      rep:StackRep [True, False, False]),
                     (cbKz,
                      label: block_cbKz_info
                      rep:StackRep [False, True, False, False]),
                     (cbKE,
                      label: block_cbKE_info
                      rep:StackRep [True, False, False, False, True, False, False]),
                     (cbKJ,
                      label: block_cbKJ_info
                      rep:StackRep [True, True, False, False, False, True, False,
                                    False]),
                     (cbLs,
                      label: block_cbLs_info
                      rep:StackRep [False, True, False, False]),
                     (cbLx,
                      label: block_cbLx_info
                      rep:StackRep [False, False, True, False, False]),
                     (cbLz,
                      label: block_cbLz_info
                      rep:StackRep [False, False, True, False, False]),
                     (cbLD,
                      label: block_cbLD_info
                      rep:StackRep [False, False, True, False, True]),
                     (cbLI,
                      label: block_cbLI_info
                      rep:StackRep [False, True, False, False, True, False, False]),
                     (cbLN,
                      label: block_cbLN_info
                      rep:StackRep [True, False, True, False, False, True, False,
                                    False]),
                     (cbMy,
                      label: block_cbMy_info
                      rep:StackRep [True, False, True, False, True, False, False, True,
                                    False, False]),
                     (cbMD,
                      label: block_cbMD_info
                      rep:StackRep [True, False, True, False, True, True, False, True,
                                    False, False]),
                     (cbMN,
                      label: block_cbMN_info
                      rep:StackRep [True, False, True, False, True, False, True, True,
                                    False, False]),
                     (cbMV,
                      label: block_cbMV_info
                      rep:StackRep [True, False, True, False, True, True, True, True,
                                    False, False]),
                     (cbN7,
                      label: block_cbN7_info
                      rep:StackRep [True, False, True, False, True, False, True, True,
                                    False, False]),
                     (cbNc,
                      label: block_cbNc_info
                      rep:StackRep [True, False, False, True, False, True, False, True,
                                    False, True, True, False, False]),
                     (cbNh,
                      label: block_cbNh_info
                      rep:StackRep [True, True, False, False, True, False, True, False,
                                    True, False, True, True, False, False]),
                     (cbO4,
                      label: block_cbO4_info
                      rep:StackRep [True, False, True, False, True, False, True, True,
                                    False, False]),
                     (cbO9,
                      label: block_cbO9_info
                      rep:StackRep [False, True, False, True, False, True, False, True,
                                    True, False, False]),
                     (cbOb,
                      label: block_cbOb_info
                      rep:StackRep [False, True, False, True, False, True, False, True,
                                    True, False, False]),
                     (cbOW,
                      label: block_cbOW_info
                      rep:StackRep [False, True, False, True, False, True, False, True,
                                    True, False, False]),
                     (cbP1,
                      label: block_cbP1_info
                      rep:StackRep [True, False, True, False, True, False, True, True,
                                    False, False])]
          stack_info: arg_space: 16 updfr_space: Just 8
        }
    {offset
      cbJO:
          _saFF::P64 = R6;
          _saFE::P64 = R5;
          _saFD::P64 = R4;
          _saFC::P64 = R3;
          _saFB::P64 = R2;
          if ((Sp + -112) < SpLim) goto cbJX; else goto cbJY;
      cbJY:
          if (HpLim == 0) goto cbJX; else goto cbJZ;
      cbJX:
          R6 = _saFF::P64;
          R5 = _saFE::P64;
          R4 = _saFD::P64;
          R3 = _saFC::P64;
          R2 = _saFB::P64;
          R1 = SkipList.$wa4_closure;
          call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
      cbJZ:
          I64[Sp - 40] = cbD0;
          R1 = _saFD::P64;
          P64[Sp - 32] = _saFB::P64;
          P64[Sp - 24] = _saFC::P64;
          P64[Sp - 16] = _saFE::P64;
          P64[Sp - 8] = _saFF::P64;
          Sp = Sp - 40;
          call stg_norec_readTVar#(R1) returns to cbD0, args: 8, res: 8, upd: 8;
      cbD0:
          I64[Sp] = cbD2;
          R1 = R1;
          if (R1 & 7 != 0) goto cbD2; else goto cbD3;
      cbD3:
          call (I64[R1])(R1) returns to cbD2, args: 8, res: 8, upd: 8;
      cbD2:
          Hp = Hp + 64;
          if (Hp > HpLim) goto cbK3; else goto cbK2;
      cbK3:
          HpAlloc = 64;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to cbD2, args: 8, res: 8, upd: 8;
      cbK2:
          _saFM::I64 = I64[R1 + 7];
          I64[Hp - 56] = $wa8_saFO_info;
          _saFB::P64 = P64[Sp + 8];
          P64[Hp - 48] = _saFB::P64;
          _saFF::P64 = P64[Sp + 32];
          P64[Hp - 40] = _saFF::P64;
          P64[Hp - 32] = Hp - 24;
          I64[Hp - 24] = $s$wa_saFN_info;
          P64[Hp - 16] = _saFB::P64;
          P64[Hp - 8] = _saFF::P64;
          _cbD7::P64 = Hp - 52;
          P64[Hp] = _cbD7::P64;
          I64[Sp] = cbHA;
          R4 = GHC.Types.[]_closure+1;
          R3 = _saFM::I64;
          R2 = P64[Sp + 16];
          _saFL::P64 = R1;
          R1 = _cbD7::P64;
          I64[Sp + 8] = _saFM::I64;
          P64[Sp + 16] = _saFL::P64;
          call $wa8_saFO_info(R4,
                              R3,
                              R2,
                              R1) returns to cbHA, args: 8, res: 8, upd: 8;
      cbHA:
          I64[Sp - 8] = cbHC;
          P64[Sp] = R1;
          Sp = Sp - 8;
          call stg_myThreadId#() returns to cbHC, args: 8, res: 8, upd: 8;
      cbHC:
          I64[Sp] = cbHE;
          R1 = R1;
          call stg_threadStatus#(R1) returns to cbHE, args: 8, res: 8, upd: 8;
      cbHE:
          _saFE::P64 = P64[Sp + 32];
          _saFL::P64 = P64[Sp + 24];
          _saFM::I64 = I64[Sp + 16];
          _saHq::I64 = R2;
          goto cbHF;
      cbHF:
          Hp = Hp + 72;
          if (Hp > HpLim) goto cbK8; else goto cbK7;
      cbK8:
          HpAlloc = 72;
          I64[Sp - 8] = cbHG;
          I64[Sp] = _saHq::I64;
          Sp = Sp - 8;
          call stg_gc_noregs() returns to cbHG, args: 8, res: 8, upd: 8;
      cbHG:
          _saFE::P64 = P64[Sp + 40];
          _saFL::P64 = P64[Sp + 32];
          _saFM::I64 = I64[Sp + 24];
          _saHq::I64 = I64[Sp + 8];
          Sp = Sp + 8;
          goto cbHF;
      cbK7:
          I64[Hp - 64] = nodesHeight_saHs_info;
          P64[Hp - 48] = _saFE::P64;
          P64[Hp - 40] = _saFL::P64;
          I64[Hp - 32] = _saFM::I64;
          I64[Hp - 24] = _saHq::I64;
          I64[Hp - 16] = (,)_con_info;
          P64[Hp - 8] = SkipList.newSL10_closure+1;
          _cbHI::P64 = Hp - 64;
          P64[Hp] = _cbHI::P64;
          I64[Sp] = cbJQ;
          R3 = Hp - 15;
          R2 = GHC.Arr.$fIxInt_closure;
          P64[Sp + 32] = _cbHI::P64;
          call SkipList.$fMArrayTArrayeSTM8_info(R3,
                                                 R2) returns to cbJQ, args: 8, res: 8, upd: 8;
      cbJQ:
          I64[Sp] = cbJS;
          _saIf::P64 = R1;
          R1 = P64[Sp + 48];
          P64[Sp + 48] = _saIf::P64;
          call stg_newNOrecTVar#(R1) returns to cbJS, args: 8, res: 8, upd: 8;
      cbJS:
          Hp = Hp + 48;
          if (Hp > HpLim) goto cbKc; else goto cbKb;
      cbKc:
          HpAlloc = 48;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to cbJS, args: 8, res: 8, upd: 8;
      cbKb:
          I64[Hp - 40] = GHC.Conc.Sync.TVar_con_info;
          P64[Hp - 32] = R1;
          I64[Hp - 24] = SkipList.Node_con_info;
          P64[Hp - 16] = P64[Sp + 40];
          P64[Hp - 8] = Hp - 39;
          P64[Hp] = P64[Sp + 48];
          I64[Sp] = cbJW;
          R1 = P64[Sp + 32];
          P64[Sp + 40] = Hp - 22;
          if (R1 & 7 != 0) goto cbJW; else goto cbKd;
      cbKd:
          call (I64[R1])(R1) returns to cbJW, args: 8, res: 8, upd: 8;
      cbJW:
          _saIm::I64 = I64[R1 + 7];
          if (%MO_S_Gt_W64(1, _saIm::I64)) goto cbPm; else goto cbKp;
      cbKp:
          I64[Sp + 24] = cbKn;
          R1 = P64[Sp + 8];
          I64[Sp + 32] = _saIm::I64;
          Sp = Sp + 24;
          if (R1 & 7 != 0) goto cbKn; else goto cbKq;
      cbKq:
          call (I64[R1])(R1) returns to cbKn, args: 8, res: 8, upd: 8;
      cbKn:
          if (R1 & 7 == 1) goto cbN4; else goto cbKL;
      cbKL:
          I64[Sp - 8] = cbKz;
          _saIs::P64 = P64[R1 + 14];
          R1 = P64[R1 + 6];
          P64[Sp] = _saIs::P64;
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto cbKz; else goto cbKA;
      cbKA:
          call (I64[R1])(R1) returns to cbKz, args: 8, res: 8, upd: 8;
      cbKz:
          I64[Sp - 24] = cbKE;
          _saIv::P64 = P64[R1 + 15];
          _saIx::P64 = P64[R1 + 23];
          _saIw::I64 = I64[R1 + 31];
          R1 = P64[R1 + 7];
          I64[Sp - 16] = _saIw::I64;
          P64[Sp - 8] = _saIx::P64;
          P64[Sp] = _saIv::P64;
          Sp = Sp - 24;
          if (R1 & 7 != 0) goto cbKE; else goto cbKF;
      cbKF:
          call (I64[R1])(R1) returns to cbKE, args: 8, res: 8, upd: 8;
      cbKE:
          I64[Sp - 8] = cbKJ;
          _saIy::P64 = R1;
          _saIz::I64 = I64[R1 + 7];
          R1 = P64[Sp + 24];
          I64[Sp] = _saIz::I64;
          P64[Sp + 24] = _saIy::P64;
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto cbKJ; else goto cbKO;
      cbKO:
          call (I64[R1])(R1) returns to cbKJ, args: 8, res: 8, upd: 8;
      cbKJ:
          _saIy::P64 = P64[Sp + 32];
          _saIz::I64 = I64[Sp + 8];
          _saIA::P64 = R1;
          if (%MO_S_Gt_W64(_saIz::I64, 1)) goto cbL6; else goto cbPl;
      cbPl:
          if (%MO_S_Gt_W64(1, I64[R1 + 7])) goto cbL6; else goto cbPk;
      cbL6:
          R4 = _saIA::P64;
          R3 = _saIy::P64;
          R2 = stg_INTLIKE_closure+273;
          Sp = Sp + 72;
          call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
      cbPk:
          _saIw::I64 = I64[Sp + 16];
          _saIK::I64 = 1 - _saIz::I64;
          if (%MO_S_Gt_W64(0, _saIK::I64)) goto cbLp; else goto cbPj;
      cbPj:
          if (%MO_S_Ge_W64(_saIK::I64,
                           _saIw::I64)) goto cbLp; else goto cbLO;
      cbLp:
          R3 = _saIK::I64;
          R2 = _saIw::I64;
          Sp = Sp + 72;
          call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
      cbLO:
          _saIS::P64 = P64[P64[Sp + 24] + ((_saIK::I64 << 3) + 24)];
          I64[Sp + 32] = cbLs;
          R1 = _saIS::P64;
          Sp = Sp + 32;
          if (R1 & 7 != 0) goto cbLs; else goto cbLt;
      cbLt:
          call (I64[R1])(R1) returns to cbLs, args: 8, res: 8, upd: 8;
      cbLs:
          I64[Sp - 8] = cbLx;
          _saIU::P64 = P64[R1 + 7];
          R1 = _saIU::P64;
          P64[Sp] = _saIU::P64;
          Sp = Sp - 8;
          call stg_norec_readTVar#(R1) returns to cbLx, args: 8, res: 8, upd: 8;
      cbLx:
          I64[Sp] = cbLz;
          R2 = P64[Sp + 32];
          _saIX::P64 = R1;
          R1 = P64[Sp + 8];
          P64[Sp + 8] = _saIX::P64;
          call stg_norec_writeTVar#(R2,
                                    R1) returns to cbLz, args: 8, res: 8, upd: 8;
      cbLz:
          I64[Sp] = cbLD;
          R1 = P64[Sp + 40];
          if (R1 & 7 != 0) goto cbLD; else goto cbLE;
      cbLE:
          call (I64[R1])(R1) returns to cbLD, args: 8, res: 8, upd: 8;
      cbLD:
          I64[Sp - 16] = cbLI;
          _saJ1::P64 = P64[R1 + 15];
          _saJ3::P64 = P64[R1 + 23];
          _saJ2::I64 = I64[R1 + 31];
          R1 = P64[R1 + 7];
          P64[Sp - 8] = _saJ3::P64;
          I64[Sp] = _saJ2::I64;
          P64[Sp + 40] = _saJ1::P64;
          Sp = Sp - 16;
          if (R1 & 7 != 0) goto cbLI; else goto cbLJ;
      cbLJ:
          call (I64[R1])(R1) returns to cbLI, args: 8, res: 8, upd: 8;
      cbLI:
          I64[Sp - 8] = cbLN;
          _saJ4::P64 = R1;
          _saJ5::I64 = I64[R1 + 7];
          R1 = P64[Sp + 56];
          I64[Sp] = _saJ5::I64;
          P64[Sp + 56] = _saJ4::P64;
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto cbLN; else goto cbLU;
      cbLU:
          call (I64[R1])(R1) returns to cbLN, args: 8, res: 8, upd: 8;
      cbLN:
          _saJ4::P64 = P64[Sp + 64];
          _saJ5::I64 = I64[Sp + 8];
          _saJ6::P64 = R1;
          if (%MO_S_Gt_W64(_saJ5::I64, 1)) goto cbMc; else goto cbPi;
      cbPi:
          _saJ7::I64 = I64[R1 + 7];
          if (%MO_S_Gt_W64(1, _saJ7::I64)) goto cbMc; else goto cbPh;
      cbMc:
          R4 = _saJ6::P64;
          R3 = _saJ4::P64;
          R2 = stg_INTLIKE_closure+273;
          Sp = Sp + 72;
          call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
      cbPh:
          _saJ2::I64 = I64[Sp + 24];
          _saJg::I64 = 1 - _saJ5::I64;
          if (%MO_S_Gt_W64(0, _saJg::I64)) goto cbMv; else goto cbPg;
      cbPg:
          if (%MO_S_Ge_W64(_saJg::I64,
                           _saJ2::I64)) goto cbMv; else goto cbME;
      cbMv:
          R3 = _saJg::I64;
          R2 = _saJ2::I64;
          Sp = Sp + 72;
          call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
      cbME:
          _saJo::P64 = P64[P64[Sp + 16] + ((_saJg::I64 << 3) + 24)];
          I64[Sp - 16] = cbMy;
          R1 = _saJo::P64;
          I64[Sp - 8] = _saJ7::I64;
          P64[Sp] = _saJ6::P64;
          Sp = Sp - 16;
          if (R1 & 7 != 0) goto cbMy; else goto cbMz;
      cbMz:
          call (I64[R1])(R1) returns to cbMy, args: 8, res: 8, upd: 8;
      cbMy:
          I64[Sp] = cbMD;
          R2 = P64[Sp + 48];
          R1 = P64[R1 + 7];
          call stg_norec_writeTVar#(R2,
                                    R1) returns to cbMD, args: 8, res: 8, upd: 8;
      cbMD:
          _saIm::I64 = I64[Sp + 64];
          _saJu::P64 = P64[Sp + 56];
          _saJt::I64 = 2;
          goto cbMM;
      cbMM:
          if (HpLim == 0) goto cbMP; else goto cbPf;
      cbMP:
          I64[Sp] = cbMN;
          P64[Sp + 48] = _saJu::P64;
          I64[Sp + 56] = _saJt::I64;
          call stg_gc_noregs() returns to cbMN, args: 8, res: 8, upd: 8;
      cbMN:
          _saIm::I64 = I64[Sp + 64];
          _saJt::I64 = I64[Sp + 56];
          _saJu::P64 = P64[Sp + 48];
          goto cbMM;
      cbPf:
          if (%MO_S_Gt_W64(_saJt::I64,
                           _saIm::I64)) goto ubPr; else goto cbMX;
      ubPr:
          Sp = Sp + 32;
          goto cbPm;
      cbPm:
          R1 = GHC.Tuple.()_closure+1;
          Sp = Sp + 56;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
      cbMX:
          I64[Sp] = cbMV;
          R1 = _saJu::P64;
          I64[Sp + 56] = _saJt::I64;
          if (R1 & 7 != 0) goto cbMV; else goto cbMY;
      cbMY:
          call (I64[R1])(R1) returns to cbMV, args: 8, res: 8, upd: 8;
      cbMV:
          if (R1 & 7 != 1) goto cbNj; else goto ubPs;
      cbNj:
          I64[Sp] = cbN7;
          _saJB::P64 = P64[R1 + 14];
          R1 = P64[R1 + 6];
          P64[Sp + 48] = _saJB::P64;
          if (R1 & 7 != 0) goto cbN7; else goto cbN8;
      cbN8:
          call (I64[R1])(R1) returns to cbN7, args: 8, res: 8, upd: 8;
      cbN7:
          I64[Sp - 24] = cbNc;
          _saJE::P64 = P64[R1 + 15];
          _saJG::P64 = P64[R1 + 23];
          _saJF::I64 = I64[R1 + 31];
          R1 = P64[R1 + 7];
          I64[Sp - 16] = _saJF::I64;
          P64[Sp - 8] = _saJG::P64;
          P64[Sp] = _saJE::P64;
          Sp = Sp - 24;
          if (R1 & 7 != 0) goto cbNc; else goto cbNd;
      cbNd:
          call (I64[R1])(R1) returns to cbNc, args: 8, res: 8, upd: 8;
      cbNc:
          I64[Sp - 8] = cbNh;
          _saJH::P64 = R1;
          _saJI::I64 = I64[R1 + 7];
          R1 = P64[Sp + 24];
          I64[Sp] = _saJI::I64;
          P64[Sp + 24] = _saJH::P64;
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto cbNh; else goto cbNm;
      cbNm:
          call (I64[R1])(R1) returns to cbNh, args: 8, res: 8, upd: 8;
      cbNh:
          Hp = Hp + 16;
          if (Hp > HpLim) goto cbNs; else goto cbNr;
      cbNs:
          HpAlloc = 16;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to cbNh, args: 8, res: 8, upd: 8;
      cbNr:
          _saJt::I64 = I64[Sp + 88];
          _saJH::P64 = P64[Sp + 32];
          _saJI::I64 = I64[Sp + 8];
          if (%MO_S_Le_W64(_saJI::I64,
                           _saJt::I64)) goto cbPd; else goto cbNA;
      cbPd:
          if (%MO_S_Le_W64(_saJt::I64,
                           I64[R1 + 7])) goto cbPc; else goto cbNJ;
      cbPc:
          _saJF::I64 = I64[Sp + 16];
          _saJT::I64 = _saJt::I64 - _saJI::I64;
          if (%MO_S_Gt_W64(0, _saJT::I64)) goto cbO1; else goto cbPb;
      cbPb:
          if (%MO_S_Ge_W64(_saJT::I64,
                           _saJF::I64)) goto cbO1; else goto cbOc;
      cbO1:
          Hp = Hp - 16;
          R3 = _saJT::I64;
          R2 = _saJF::I64;
          Sp = Sp + 120;
          call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
      cbOc:
          Hp = Hp - 16;
          _saK1::P64 = P64[P64[Sp + 24] + ((_saJT::I64 << 3) + 24)];
          I64[Sp + 32] = cbO4;
          R1 = _saK1::P64;
          Sp = Sp + 32;
          if (R1 & 7 != 0) goto cbO4; else goto cbO5;
      cbO5:
          call (I64[R1])(R1) returns to cbO4, args: 8, res: 8, upd: 8;
      cbO4:
          I64[Sp - 8] = cbO9;
          _saK3::P64 = P64[R1 + 7];
          R1 = _saK3::P64;
          P64[Sp] = _saK3::P64;
          Sp = Sp - 8;
          call stg_norec_readTVar#(R1) returns to cbO9, args: 8, res: 8, upd: 8;
      cbO9:
          I64[Sp] = cbOb;
          R2 = P64[Sp + 80];
          _saK6::P64 = R1;
          R1 = P64[Sp + 8];
          P64[Sp + 8] = _saK6::P64;
          call stg_norec_writeTVar#(R2,
                                    R1) returns to cbOb, args: 8, res: 8, upd: 8;
      cbOb:
          Hp = Hp + 16;
          if (Hp > HpLim) goto cbOk; else goto cbOj;
      cbOk:
          HpAlloc = 16;
          call stg_gc_noregs() returns to cbOb, args: 8, res: 8, upd: 8;
      cbOj:
          _saJ4::P64 = P64[Sp + 88];
          _saJ5::I64 = I64[Sp + 32];
          _saJ6::P64 = P64[Sp + 24];
          _saJt::I64 = I64[Sp + 64];
          if (%MO_S_Le_W64(_saJ5::I64,
                           _saJt::I64)) goto cbPa; else goto cbOs;
      cbPa:
          if (%MO_S_Le_W64(_saJt::I64,
                           I64[Sp + 16])) goto cbP9; else goto cbOB;
      cbP9:
          _saJ2::I64 = I64[Sp + 48];
          _saKg::I64 = _saJt::I64 - _saJ5::I64;
          if (%MO_S_Gt_W64(0, _saKg::I64)) goto cbOT; else goto cbP8;
      cbP8:
          if (%MO_S_Ge_W64(_saKg::I64,
                           _saJ2::I64)) goto cbOT; else goto cbP2;
      cbOT:
          Hp = Hp - 16;
          R3 = _saKg::I64;
          R2 = _saJ2::I64;
          Sp = Sp + 96;
          call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
      cbP2:
          Hp = Hp - 16;
          _saKo::P64 = P64[P64[Sp + 40] + ((_saKg::I64 << 3) + 24)];
          I64[Sp] = cbOW;
          R1 = _saKo::P64;
          if (R1 & 7 != 0) goto cbOW; else goto cbOX;
      cbOX:
          call (I64[R1])(R1) returns to cbOW, args: 8, res: 8, upd: 8;
      cbOW:
          _saK6::P64 = P64[Sp + 8];
          I64[Sp + 8] = cbP1;
          R2 = _saK6::P64;
          R1 = P64[R1 + 7];
          Sp = Sp + 8;
          call stg_norec_writeTVar#(R2,
                                    R1) returns to cbP1, args: 8, res: 8, upd: 8;
      cbP1:
          _saIm::I64 = I64[Sp + 64];
          _saJu::P64 = P64[Sp + 48];
          _saJt::I64 = I64[Sp + 56] + 1;
          goto cbMM;
      cbOB:
          I64[Hp - 8] = GHC.Types.I#_con_info;
          I64[Hp] = _saJt::I64;
          R4 = _saJ6::P64;
          R3 = _saJ4::P64;
          R2 = Hp - 7;
          Sp = Sp + 96;
          call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
      cbOs:
          I64[Hp - 8] = GHC.Types.I#_con_info;
          I64[Hp] = _saJt::I64;
          R4 = _saJ6::P64;
          R3 = _saJ4::P64;
          R2 = Hp - 7;
          Sp = Sp + 96;
          call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
      cbNJ:
          I64[Hp - 8] = GHC.Types.I#_con_info;
          I64[Hp] = _saJt::I64;
          R4 = R1;
          R3 = _saJH::P64;
          R2 = Hp - 7;
          Sp = Sp + 120;
          call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
      cbNA:
          I64[Hp - 8] = GHC.Types.I#_con_info;
          I64[Hp] = _saJt::I64;
          R4 = R1;
          R3 = _saJH::P64;
          R2 = Hp - 7;
          Sp = Sp + 120;
          call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
      ubPs:
          Sp = Sp + 56;
          goto cbN4;
      cbN4:
          R1 = lvl40_rawz_closure;
          Sp = Sp + 32;
          call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:47.376493 UTC

[section "data" {
     SkipList.$wa4_closure:
         const SkipList.$wa4_info;
         const 0;
 },
 $wa8_saFO_entry() //  [R4, R3, R2, R1]
         { info_tbl: [(cbDh,
                       label: $wa8_saFO_info
                       rep:HeapRep 3 ptrs { Fun {arity: 4 fun_type: ArgSpec 21} }),
                      (cbDl,
                       label: block_cbDl_info
                       rep:StackRep [False, False, False, False, False, True]),
                      (cbDq,
                       label: block_cbDq_info
                       rep:StackRep [False, True, False, False, False, False, False,
                                     False, False, True]),
                      (cbDv,
                       label: block_cbDv_info
                       rep:StackRep [True, False, True, False, False, False, False, False,
                                     False, False, True]),
                      (cbEc,
                       label: block_cbEc_info
                       rep:StackRep [True, True, True, False, False, False, False, False,
                                     False, False, True]),
                      (cbEi,
                       label: block_cbEi_info
                       rep:StackRep [True, True, True, False, False, False, False, False,
                                     False, False, True]),
                      (cbEk,
                       label: block_cbEk_info
                       rep:StackRep [True, True, True, False, False, False, False, False,
                                     False, False, True]),
                      (cbEz,
                       label: block_cbEz_info
                       rep:StackRep [True, True, True, False, False, True, False, False,
                                     False, False, True])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbDh:
           _saGC::P64 = R4;
           _saGB::I64 = R3;
           _saGA::P64 = R2;
           _saFO::P64 = R1;
           if ((Sp + -120) < SpLim) goto cbDi; else goto cbDj;
       cbDj:
           if (HpLim == 0) goto cbDi; else goto cbES;
       cbDi:
           R4 = _saGC::P64;
           R3 = _saGB::I64;
           R2 = _saGA::P64;
           R1 = _saFO::P64;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbES:
           if (_saGB::I64 != 0) goto cbDf; else goto cbDg;
       cbDf:
           I64[Sp - 56] = cbDl;
           R1 = _saGA::P64;
           P64[Sp - 48] = P64[_saFO::P64 + 4];
           P64[Sp - 40] = P64[_saFO::P64 + 12];
           P64[Sp - 32] = P64[_saFO::P64 + 20];
           P64[Sp - 24] = _saFO::P64;
           P64[Sp - 16] = _saGC::P64;
           I64[Sp - 8] = _saGB::I64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto cbDl; else goto cbDm;
       cbDm:
           call (I64[R1])(R1) returns to cbDl, args: 8, res: 8, upd: 8;
       cbDl:
           I64[Sp - 32] = cbDq;
           _saGF::P64 = R1;
           _saGH::P64 = P64[R1 + 15];
           _saGJ::P64 = P64[R1 + 23];
           _saGI::I64 = I64[R1 + 31];
           R1 = P64[R1 + 7];
           P64[Sp - 24] = _saGH::P64;
           I64[Sp - 16] = _saGI::I64;
           P64[Sp - 8] = _saGJ::P64;
           P64[Sp] = _saGF::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto cbDq; else goto cbDr;
       cbDr:
           call (I64[R1])(R1) returns to cbDq, args: 8, res: 8, upd: 8;
       cbDq:
           I64[Sp - 8] = cbDv;
           _saGK::P64 = R1;
           _saGL::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _saGL::I64;
           P64[Sp + 8] = _saGK::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto cbDv; else goto cbDy;
       cbDy:
           call (I64[R1])(R1) returns to cbDv, args: 8, res: 8, upd: 8;
       cbDv:
           _saGE::I64 = I64[Sp + 88];
           _saGK::P64 = P64[Sp + 16];
           _saGL::I64 = I64[Sp + 8];
           _saGM::P64 = R1;
           if (%MO_S_Gt_W64(_saGL::I64,
                            _saGE::I64)) goto cbDQ; else goto cbER;
       cbER:
           _saGN::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(_saGE::I64,
                            _saGN::I64)) goto cbDQ; else goto cbEQ;
       cbDQ:
           R4 = _saGM::P64;
           R3 = _saGK::P64;
           R2 = _saGE::I64;
           Sp = Sp + 96;
           call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
       cbEQ:
           _saGI::I64 = I64[Sp + 24];
           _saGU::I64 = _saGE::I64 - _saGL::I64;
           if (%MO_S_Gt_W64(0, _saGU::I64)) goto cbE9; else goto cbEP;
       cbEP:
           if (%MO_S_Ge_W64(_saGU::I64,
                            _saGI::I64)) goto cbE9; else goto cbEd;
       cbE9:
           R3 = _saGU::I64;
           R2 = _saGI::I64;
           Sp = Sp + 96;
           call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
       cbEd:
           _saH2::P64 = P64[P64[Sp + 32] + ((_saGU::I64 << 3) + 24)];
           I64[Sp] = cbEc;
           R1 = _saH2::P64;
           I64[Sp + 16] = _saGN::I64;
           if (R1 & 7 != 0) goto cbEc; else goto cbEe;
       cbEe:
           call (I64[R1])(R1) returns to cbEc, args: 8, res: 8, upd: 8;
       cbEc:
           I64[Sp] = cbEi;
           R1 = P64[R1 + 7];
           call stg_norec_readTVar#(R1) returns to cbEi, args: 8, res: 8, upd: 8;
       cbEi:
           I64[Sp] = cbEk;
           R1 = R1;
           if (R1 & 7 != 0) goto cbEk; else goto cbEn;
       cbEn:
           call (I64[R1])(R1) returns to cbEk, args: 8, res: 8, upd: 8;
       cbEk:
           if (R1 & 7 != 1) goto cbEB; else goto cbEt;
       cbEB:
           I64[Sp] = cbEz;
           R2 = P64[Sp + 48];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[R1 + 6];
           P64[Sp - 8] = P64[Sp + 56];
           P64[Sp + 56] = P64[R1 + 22];
           Sp = Sp - 24;
           call GHC.Classes.>_info(R2) returns to cbEz, args: 32, res: 8, upd: 8;
       cbEz:
           _saGC::P64 = P64[Sp + 80];
           _saGE::I64 = I64[Sp + 88];
           if (R1 & 7 != 1) goto cbEL; else goto cbEH;
       cbEL:
           Hp = Hp + 24;
           if (Hp > HpLim) goto cbEO; else goto cbEN;
       cbEO:
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to cbEz, args: 8, res: 8, upd: 8;
       cbEN:
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = _saGC::P64;
           R6 = _saGE::I64 - 1;
           R5 = P64[Sp + 32];
           R4 = I64[Sp + 24];
           R3 = I64[Sp + 16];
           R2 = I64[Sp + 8];
           R1 = P64[Sp + 64];
           P64[Sp + 88] = Hp - 14;
           Sp = Sp + 88;
           call $s$wa_saFN_info(R6,
                                R5,
                                R4,
                                R3,
                                R2,
                                R1) args: 16, res: 0, upd: 8;
       cbEH:
           R4 = _saGC::P64;
           R3 = _saGE::I64;
           R2 = P64[Sp + 56];
           R1 = P64[Sp + 72];
           Sp = Sp + 96;
           call $wa8_saFO_info(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbEt:
           Hp = Hp + 24;
           if (Hp > HpLim) goto cbEw; else goto cbEv;
       cbEw:
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to cbEk, args: 8, res: 8, upd: 8;
       cbEv:
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = P64[Sp + 80];
           R6 = I64[Sp + 88] - 1;
           R5 = P64[Sp + 32];
           R4 = I64[Sp + 24];
           R3 = I64[Sp + 16];
           R2 = I64[Sp + 8];
           R1 = P64[Sp + 64];
           P64[Sp + 88] = Hp - 14;
           Sp = Sp + 88;
           call $s$wa_saFN_info(R6,
                                R5,
                                R4,
                                R3,
                                R2,
                                R1) args: 16, res: 0, upd: 8;
       cbDg:
           R1 = _saGC::P64;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 },
 $s$wa_saFN_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 56 updfr_space: Just 8
         }
     {offset
       cbEY:
           R6 = I64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call $s$wa_saFN_info(R6,
                                R5,
                                R4,
                                R3,
                                R2,
                                R1) args: 16, res: 0, upd: 8;
     }
 },
 $s$wa_saFN_entry() //  [R6, R5, R4, R3, R2, R1]
         { info_tbl: [(cbG1,
                       label: $s$wa_saFN_info
                       rep:HeapRep 3 ptrs {
                             Fun {arity: 8
                                  fun_type: ArgGen [True, True, True, False, True, False]} }),
                      (cbGK,
                       label: block_cbGK_info
                       rep:StackRep [False, False, False, False, True, True, True, False,
                                     True, False]),
                      (cbGQ,
                       label: block_cbGQ_info
                       rep:StackRep [False, False, False, False, True, True, True, False,
                                     True, False]),
                      (cbGS,
                       label: block_cbGS_info
                       rep:StackRep [False, False, False, False, True, True, True, False,
                                     True, False]),
                      (cbHa,
                       label: block_cbHa_info
                       rep:StackRep [False, False, False, True, True, True, False, True,
                                     False])]
           stack_info: arg_space: 16 updfr_space: Just 8
         }
     {offset
       cbG1:
           _saFT::I64 = R6;
           _saFS::P64 = R5;
           _saFR::I64 = R4;
           _saFQ::I64 = R3;
           _saFP::I64 = R2;
           _saFN::P64 = R1;
           if ((Sp + -96) < SpLim) goto cbG2; else goto cbG3;
       cbG3:
           Hp = Hp + 32;
           if (Hp > HpLim) goto cbG5; else goto cbG4;
       cbG5:
           HpAlloc = 32;
           goto cbG2;
       cbG2:
           R1 = _saFN::P64;
           I64[Sp - 40] = _saFP::I64;
           I64[Sp - 32] = _saFQ::I64;
           I64[Sp - 24] = _saFR::I64;
           P64[Sp - 16] = _saFS::P64;
           I64[Sp - 8] = _saFT::I64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 56, res: 0, upd: 8;
       cbG4:
           if (_saFT::I64 != 0) goto cbFZ; else goto cbG0;
       cbFZ:
           if (%MO_S_Le_W64(_saFP::I64,
                            _saFT::I64)) goto cbHv; else goto cbGf;
       cbHv:
           if (%MO_S_Le_W64(_saFT::I64,
                            _saFQ::I64)) goto cbHu; else goto cbGp;
       cbHu:
           _saG7::I64 = _saFT::I64 - _saFP::I64;
           if (%MO_S_Gt_W64(0, _saG7::I64)) goto cbGH; else goto cbHt;
       cbHt:
           if (%MO_S_Ge_W64(_saG7::I64,
                            _saFR::I64)) goto cbGH; else goto cbGL;
       cbGH:
           Hp = Hp - 32;
           R3 = _saG7::I64;
           R2 = _saFR::I64;
           Sp = Sp + 8;
           call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
       cbGL:
           _saFB::P64 = P64[_saFN::P64 + 8];
           _saFF::P64 = P64[_saFN::P64 + 16];
           _saFO::P64 = P64[_saFN::P64 + 24];
           Hp = Hp - 32;
           _saGf::P64 = P64[(_saFS::P64 + 24) + (_saG7::I64 << 3)];
           I64[Sp - 80] = cbGK;
           R1 = _saGf::P64;
           P64[Sp - 72] = _saFB::P64;
           P64[Sp - 64] = _saFF::P64;
           P64[Sp - 56] = _saFN::P64;
           P64[Sp - 48] = _saFO::P64;
           I64[Sp - 40] = _saFP::I64;
           I64[Sp - 32] = _saFQ::I64;
           I64[Sp - 24] = _saFR::I64;
           P64[Sp - 16] = _saFS::P64;
           I64[Sp - 8] = _saFT::I64;
           Sp = Sp - 80;
           if (R1 & 7 != 0) goto cbGK; else goto cbGM;
       cbGM:
           call (I64[R1])(R1) returns to cbGK, args: 8, res: 8, upd: 8;
       cbGK:
           I64[Sp] = cbGQ;
           R1 = P64[R1 + 7];
           call stg_norec_readTVar#(R1) returns to cbGQ, args: 8, res: 8, upd: 8;
       cbGQ:
           I64[Sp] = cbGS;
           R1 = R1;
           if (R1 & 7 != 0) goto cbGS; else goto cbGV;
       cbGV:
           call (I64[R1])(R1) returns to cbGS, args: 8, res: 8, upd: 8;
       cbGS:
           if (R1 & 7 != 1) goto cbHc; else goto cbH4;
       cbHc:
           _saFB::P64 = P64[Sp + 8];
           I64[Sp + 8] = cbHa;
           R2 = _saFB::P64;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = P64[R1 + 6];
           P64[Sp] = P64[Sp + 16];
           P64[Sp + 16] = P64[R1 + 22];
           Sp = Sp - 16;
           call GHC.Classes.>_info(R2) returns to cbHa, args: 32, res: 8, upd: 8;
       cbHa:
           _saFU::P64 = P64[Sp + 72];
           _saFW::I64 = I64[Sp + 64];
           if (R1 & 7 != 1) goto cbHp; else goto cbHi;
       cbHp:
           Hp = Hp + 96;
           if (Hp > HpLim) goto cbHs; else goto cbHr;
       cbHs:
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to cbHa, args: 8, res: 8, upd: 8;
       cbHr:
           I64[Hp - 88] = GHC.Types.I#_con_info;
           _saFQ::I64 = I64[Sp + 40];
           I64[Hp - 80] = _saFQ::I64;
           I64[Hp - 72] = GHC.Types.I#_con_info;
           _saFP::I64 = I64[Sp + 32];
           I64[Hp - 64] = _saFP::I64;
           I64[Hp - 56] = GHC.Arr.Array_con_info;
           P64[Hp - 48] = Hp - 71;
           P64[Hp - 40] = Hp - 87;
           _saFS::P64 = P64[Sp + 56];
           P64[Hp - 32] = _saFS::P64;
           _saFR::I64 = I64[Sp + 48];
           I64[Hp - 24] = _saFR::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = _saFU::P64;
           R6 = _saFW::I64 - 1;
           R5 = _saFS::P64;
           R4 = _saFR::I64;
           R3 = _saFQ::I64;
           R2 = _saFP::I64;
           R1 = P64[Sp + 16];
           P64[Sp + 72] = Hp - 14;
           Sp = Sp + 72;
           call $s$wa_saFN_info(R6,
                                R5,
                                R4,
                                R3,
                                R2,
                                R1) args: 16, res: 0, upd: 8;
       cbHi:
           R4 = _saFU::P64;
           R3 = _saFW::I64;
           R2 = P64[Sp + 8];
           R1 = P64[Sp + 24];
           Sp = Sp + 80;
           call $wa8_saFO_info(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbH4:
           Hp = Hp + 96;
           if (Hp > HpLim) goto cbH7; else goto cbH6;
       cbH7:
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to cbGS, args: 8, res: 8, upd: 8;
       cbH6:
           I64[Hp - 88] = GHC.Types.I#_con_info;
           _saFQ::I64 = I64[Sp + 48];
           I64[Hp - 80] = _saFQ::I64;
           I64[Hp - 72] = GHC.Types.I#_con_info;
           _saFP::I64 = I64[Sp + 40];
           I64[Hp - 64] = _saFP::I64;
           I64[Hp - 56] = GHC.Arr.Array_con_info;
           P64[Hp - 48] = Hp - 71;
           P64[Hp - 40] = Hp - 87;
           _saFS::P64 = P64[Sp + 64];
           P64[Hp - 32] = _saFS::P64;
           _saFR::I64 = I64[Sp + 56];
           I64[Hp - 24] = _saFR::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = P64[Sp + 80];
           R6 = I64[Sp + 72] - 1;
           R5 = _saFS::P64;
           R4 = _saFR::I64;
           R3 = _saFQ::I64;
           R2 = _saFP::I64;
           R1 = P64[Sp + 24];
           P64[Sp + 80] = Hp - 14;
           Sp = Sp + 80;
           call $s$wa_saFN_info(R6,
                                R5,
                                R4,
                                R3,
                                R2,
                                R1) args: 16, res: 0, upd: 8;
       cbGp:
           I64[Hp - 24] = GHC.Types.I#_con_info;
           I64[Hp - 16] = _saFQ::I64;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saFP::I64;
           R4 = Hp - 23;
           R3 = Hp - 7;
           R2 = _saFT::I64;
           Sp = Sp + 8;
           call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
       cbGf:
           I64[Hp - 24] = GHC.Types.I#_con_info;
           I64[Hp - 16] = _saFQ::I64;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saFP::I64;
           R4 = Hp - 23;
           R3 = Hp - 7;
           R2 = _saFT::I64;
           Sp = Sp + 8;
           call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
       cbG0:
           Hp = Hp - 32;
           R1 = P64[Sp];
           Sp = Sp + 8;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saHY_entry() //  [R1]
         { info_tbl: [(cbHT,
                       label: sat_saHY_info
                       rep:HeapRep 1 ptrs 1 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} }),
                      (cbI2,
                       label: block_cbI2_info
                       rep:StackRep [True]),
                      (cbIa,
                       label: block_cbIa_info
                       rep:StackRep [True])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbHT:
           _saHY::P64 = R1;
           if ((Sp + -16) < SpLim) goto cbHU; else goto cbHV;
       cbHV:
           if (HpLim == 0) goto cbHU; else goto cbIY;
       cbHU:
           R1 = _saHY::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbIY:
           _saFE::P64 = P64[_saHY::P64 + 7];
           _saHu::I64 = I64[_saHY::P64 + 15] << 3;
           if (%MO_S_Ge_W64(_saHu::I64, 0)) goto cbIb; else goto cbI4;
       cbIb:
           I64[Sp - 16] = cbIa;
           R1 = _saFE::P64;
           I64[Sp - 8] = _saHu::I64;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) returns to cbIa, args: 8, res: 8, upd: 8;
       cbIa:
           Hp = Hp + 16;
           if (Hp > HpLim) goto cbIh; else goto cbIg;
       cbIh:
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to cbIa, args: 8, res: 8, upd: 8;
       cbIg:
           _saHu::I64 = I64[Sp + 8];
           _saHE::I64 = I64[R1 + 23];
           if (%MO_S_Lt_W64(_saHu::I64,
                            _saHE::I64)) goto cbIX; else goto cbIn;
       cbIX:
           _saHF::P64 = P64[R1 + 7];
           _saHD::I64 = I64[R1 + 15];
           _saHM::I64 = I64[(_saHF::P64 + 16) + (_saHD::I64 + _saHu::I64 << 3)];
           I64[(_saHF::P64 + 16) + (_saHD::I64 + _saHu::I64 << 3)] = _saHM::I64 * 6364136223846793005;
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32((_saHM::I64 >> 22) ^ _saHM::I64 >> (_saHM::I64 >> 61) + 22));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
       cbIn:
           Hp = Hp - 16;
           R3 = _saHu::I64;
           R2 = _saHE::I64;
           Sp = Sp + 16;
           call lvl5_ravU_info(R3, R2) args: 8, res: 0, upd: 8;
       cbI4:
           I64[Sp - 16] = cbI2;
           R1 = _saFE::P64;
           I64[Sp - 8] = _saHu::I64;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) returns to cbI2, args: 8, res: 8, upd: 8;
       cbI2:
           R3 = I64[Sp + 8];
           R2 = I64[R1 + 23];
           Sp = Sp + 16;
           call lvl5_ravU_info(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 nodesHeight_saHs_entry() //  [R1]
         { info_tbl: [(cbIZ,
                       label: block_cbIZ_info
                       rep:StackRep [False, True]),
                      (cbJ1,
                       label: nodesHeight_saHs_info
                       rep:HeapRep 2 ptrs 2 nonptrs { Thunk }),
                      (cbJ4,
                       label: block_cbJ4_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbJ1:
           _saHs::P64 = R1;
           if ((Sp + -48) < SpLim) goto cbJ5; else goto cbJ6;
       cbJ6:
           Hp = Hp + 24;
           if (Hp > HpLim) goto cbJ8; else goto cbJ7;
       cbJ8:
           HpAlloc = 24;
           goto cbJ5;
       cbJ5:
           R1 = _saHs::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJ7:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _saHs::P64;
           _saFE::P64 = P64[_saHs::P64 + 16];
           _saFL::P64 = P64[_saHs::P64 + 24];
           _saFM::I64 = I64[_saHs::P64 + 32];
           _saHq::I64 = I64[_saHs::P64 + 40];
           I64[Hp - 16] = sat_saHY_info;
           P64[Hp - 8] = _saFE::P64;
           I64[Hp] = _saHq::I64;
           I64[Sp - 40] = cbIZ;
           R2 = Hp - 15;
           P64[Sp - 32] = _saFL::P64;
           I64[Sp - 24] = _saFM::I64;
           Sp = Sp - 40;
           call GHC.IO.unsafeDupablePerformIO_info(R2) returns to cbIZ, args: 8, res: 8, upd: 24;
       cbIZ:
           I64[Sp - 8] = cbJ4;
           _saI0::I64 = I64[R1 + 7];
           R1 = logHalf_r2BC_closure;
           I64[Sp] = _saI0::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto cbJ4; else goto cbJa;
       cbJa:
           call (I64[R1])(R1) returns to cbJ4, args: 8, res: 8, upd: 24;
       cbJ4:
           Hp = Hp + 16;
           if (Hp > HpLim) goto cbJg; else goto cbJf;
       cbJg:
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to cbJ4, args: 8, res: 8, upd: 24;
       cbJf:
           _saFL::P64 = P64[Sp + 16];
           _saFM::I64 = I64[Sp + 24];
           _saI0::I64 = I64[Sp + 8];
           _saI2::F32 = F32[R1 + 7];
           (_cbJh::F32) = call MO_UF_Conv W32(4294967295);
           (_cbJl::F32) = call MO_UF_Conv W32(_saI0::I64);
           (_cbJs::F32) = call MO_F32_Log(%MO_F_Quot_W32(_cbJl::F32,
                                                         _cbJh::F32));
           _saI8::I64 = %MO_FS_Conv_W32_W64(%MO_F_Quot_W32(_cbJs::F32,
                                                           _saI2::F32)) + 1;
           if (%MO_S_Le_W64(_saFM::I64,
                            _saI8::I64)) goto cbJN; else goto cbJM;
       cbJN:
           Hp = Hp - 16;
           R1 = _saFL::P64 & (-8);
           Sp = Sp + 32;
           call (I64[R1])(R1) args: 24, res: 0, upd: 24;
       cbJM:
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saI8::I64;
           R1 = Hp - 7;
           Sp = Sp + 32;
           call (P64[Sp])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section "relreadonly" {
     ubPt_srtd:
         const SaM6_srt+168;
         const 37;
         const 120527528513;
 },
 section "relreadonly" {
     ubPu_srtd:
         const SaM6_srt+168;
         const 37;
         const 120527528513;
 },
 section "relreadonly" {
     ubPv_srtd:
         const SaM6_srt+168;
         const 37;
         const 120527528449;
 },
 section "relreadonly" {
     ubPw_srtd:
         const SaM6_srt+168;
         const 37;
         const 120527528449;
 },
 section "relreadonly" {
     ubPx_srtd:
         const SaM6_srt+168;
         const 37;
         const 120527528449;
 },
 section "relreadonly" {
     ubPy_srtd:
         const SaM6_srt+168;
         const 37;
         const 120527528449;
 },
 section "relreadonly" {
     ubPz_srtd:
         const SaM6_srt+168;
         const 38;
         const 257966481985;
 },
 SkipList.$wa4_entry() //  [R6, R5, R4, R3, R2]
         { info_tbl: [(cbD0,
                       label: block_cbD0_info
                       rep:StackRep [False, False, False, False, False]),
                      (cbD2,
                       label: block_cbD2_info
                       rep:StackRep [False, False, False, False, False]),
                      (cbHA,
                       label: block_cbHA_info
                       rep:StackRep [True, False, False, False, False]),
                      (cbHC,
                       label: block_cbHC_info
                       rep:StackRep [False, True, False, False, False, False]),
                      (cbHE,
                       label: block_cbHE_info
                       rep:StackRep [False, True, False, False, False, False]),
                      (cbHG,
                       label: block_cbHG_info
                       rep:StackRep [True, False, True, False, False, False, False]),
                      (cbJO,
                       label: SkipList.$wa4_info
                       rep:HeapRep static { Fun {arity: 7 fun_type: ArgSpec 26} }),
                      (cbJQ,
                       label: block_cbJQ_info
                       rep:StackRep [False, True, True, False, False, False]),
                      (cbJS,
                       label: block_cbJS_info
                       rep:StackRep [False, True, True, False, False, False]),
                      (cbJW,
                       label: block_cbJW_info
                       rep:StackRep [False, True, True, True, False, False]),
                      (cbKn,
                       label: block_cbKn_info
                       rep:StackRep [True, False, False]),
                      (cbKz,
                       label: block_cbKz_info
                       rep:StackRep [False, True, False, False]),
                      (cbKE,
                       label: block_cbKE_info
                       rep:StackRep [True, False, False, False, True, False, False]),
                      (cbKJ,
                       label: block_cbKJ_info
                       rep:StackRep [True, True, False, False, False, True, False,
                                     False]),
                      (cbLs,
                       label: block_cbLs_info
                       rep:StackRep [False, True, False, False]),
                      (cbLx,
                       label: block_cbLx_info
                       rep:StackRep [False, False, True, False, False]),
                      (cbLz,
                       label: block_cbLz_info
                       rep:StackRep [False, False, True, False, False]),
                      (cbLD,
                       label: block_cbLD_info
                       rep:StackRep [False, False, True, False, True]),
                      (cbLI,
                       label: block_cbLI_info
                       rep:StackRep [False, True, False, False, True, False, False]),
                      (cbLN,
                       label: block_cbLN_info
                       rep:StackRep [True, False, True, False, False, True, False,
                                     False]),
                      (cbMy,
                       label: block_cbMy_info
                       rep:StackRep [True, False, True, False, True, False, False, True,
                                     False, False]),
                      (cbMD,
                       label: block_cbMD_info
                       rep:StackRep [True, False, True, False, True, True, False, True,
                                     False, False]),
                      (cbMN,
                       label: block_cbMN_info
                       rep:StackRep [True, False, True, False, True, False, True, True,
                                     False, False]),
                      (cbMV,
                       label: block_cbMV_info
                       rep:StackRep [True, False, True, False, True, True, True, True,
                                     False, False]),
                      (cbN7,
                       label: block_cbN7_info
                       rep:StackRep [True, False, True, False, True, False, True, True,
                                     False, False]),
                      (cbNc,
                       label: block_cbNc_info
                       rep:StackRep [True, False, False, True, False, True, False, True,
                                     False, True, True, False, False]),
                      (cbNh,
                       label: block_cbNh_info
                       rep:StackRep [True, True, False, False, True, False, True, False,
                                     True, False, True, True, False, False]),
                      (cbO4,
                       label: block_cbO4_info
                       rep:StackRep [True, False, True, False, True, False, True, True,
                                     False, False]),
                      (cbO9,
                       label: block_cbO9_info
                       rep:StackRep [False, True, False, True, False, True, False, True,
                                     True, False, False]),
                      (cbOb,
                       label: block_cbOb_info
                       rep:StackRep [False, True, False, True, False, True, False, True,
                                     True, False, False]),
                      (cbOW,
                       label: block_cbOW_info
                       rep:StackRep [False, True, False, True, False, True, False, True,
                                     True, False, False]),
                      (cbP1,
                       label: block_cbP1_info
                       rep:StackRep [True, False, True, False, True, False, True, True,
                                     False, False])]
           stack_info: arg_space: 16 updfr_space: Just 8
         }
     {offset
       cbJO:
           _saFF::P64 = R6;
           _saFE::P64 = R5;
           _saFD::P64 = R4;
           _saFC::P64 = R3;
           _saFB::P64 = R2;
           if ((Sp + -112) < SpLim) goto cbJX; else goto cbJY;
       cbJY:
           if (HpLim == 0) goto cbJX; else goto cbJZ;
       cbJX:
           R6 = _saFF::P64;
           R5 = _saFE::P64;
           R4 = _saFD::P64;
           R3 = _saFC::P64;
           R2 = _saFB::P64;
           R1 = SkipList.$wa4_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cbJZ:
           I64[Sp - 40] = cbD0;
           R1 = _saFD::P64;
           P64[Sp - 32] = _saFB::P64;
           P64[Sp - 24] = _saFC::P64;
           P64[Sp - 16] = _saFE::P64;
           P64[Sp - 8] = _saFF::P64;
           Sp = Sp - 40;
           call stg_norec_readTVar#(R1) returns to cbD0, args: 8, res: 8, upd: 8;
       cbD0:
           I64[Sp] = cbD2;
           R1 = R1;
           if (R1 & 7 != 0) goto cbD2; else goto cbD3;
       cbD3:
           call (I64[R1])(R1) returns to cbD2, args: 8, res: 8, upd: 8;
       cbD2:
           Hp = Hp + 64;
           if (Hp > HpLim) goto cbK3; else goto cbK2;
       cbK3:
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to cbD2, args: 8, res: 8, upd: 8;
       cbK2:
           _saFM::I64 = I64[R1 + 7];
           I64[Hp - 56] = $wa8_saFO_info;
           _saFB::P64 = P64[Sp + 8];
           P64[Hp - 48] = _saFB::P64;
           _saFF::P64 = P64[Sp + 32];
           P64[Hp - 40] = _saFF::P64;
           P64[Hp - 32] = Hp - 24;
           I64[Hp - 24] = $s$wa_saFN_info;
           P64[Hp - 16] = _saFB::P64;
           P64[Hp - 8] = _saFF::P64;
           _cbD7::P64 = Hp - 52;
           P64[Hp] = _cbD7::P64;
           I64[Sp] = cbHA;
           R4 = GHC.Types.[]_closure+1;
           R3 = _saFM::I64;
           R2 = P64[Sp + 16];
           _saFL::P64 = R1;
           R1 = _cbD7::P64;
           I64[Sp + 8] = _saFM::I64;
           P64[Sp + 16] = _saFL::P64;
           call $wa8_saFO_info(R4,
                               R3,
                               R2,
                               R1) returns to cbHA, args: 8, res: 8, upd: 8;
       cbHA:
           I64[Sp - 8] = cbHC;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_myThreadId#() returns to cbHC, args: 8, res: 8, upd: 8;
       cbHC:
           I64[Sp] = cbHE;
           R1 = R1;
           call stg_threadStatus#(R1) returns to cbHE, args: 8, res: 8, upd: 8;
       cbHE:
           _saFE::P64 = P64[Sp + 32];
           _saFL::P64 = P64[Sp + 24];
           _saFM::I64 = I64[Sp + 16];
           _saHq::I64 = R2;
           goto cbHF;
       cbHF:
           Hp = Hp + 72;
           if (Hp > HpLim) goto cbK8; else goto cbK7;
       cbK8:
           HpAlloc = 72;
           I64[Sp - 8] = cbHG;
           I64[Sp] = _saHq::I64;
           Sp = Sp - 8;
           call stg_gc_noregs() returns to cbHG, args: 8, res: 8, upd: 8;
       cbHG:
           _saFE::P64 = P64[Sp + 40];
           _saFL::P64 = P64[Sp + 32];
           _saFM::I64 = I64[Sp + 24];
           _saHq::I64 = I64[Sp + 8];
           Sp = Sp + 8;
           goto cbHF;
       cbK7:
           I64[Hp - 64] = nodesHeight_saHs_info;
           P64[Hp - 48] = _saFE::P64;
           P64[Hp - 40] = _saFL::P64;
           I64[Hp - 32] = _saFM::I64;
           I64[Hp - 24] = _saHq::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = SkipList.newSL10_closure+1;
           _cbHI::P64 = Hp - 64;
           P64[Hp] = _cbHI::P64;
           I64[Sp] = cbJQ;
           R3 = Hp - 15;
           R2 = GHC.Arr.$fIxInt_closure;
           P64[Sp + 32] = _cbHI::P64;
           call SkipList.$fMArrayTArrayeSTM8_info(R3,
                                                  R2) returns to cbJQ, args: 8, res: 8, upd: 8;
       cbJQ:
           I64[Sp] = cbJS;
           _saIf::P64 = R1;
           R1 = P64[Sp + 48];
           P64[Sp + 48] = _saIf::P64;
           call stg_newNOrecTVar#(R1) returns to cbJS, args: 8, res: 8, upd: 8;
       cbJS:
           Hp = Hp + 48;
           if (Hp > HpLim) goto cbKc; else goto cbKb;
       cbKc:
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to cbJS, args: 8, res: 8, upd: 8;
       cbKb:
           I64[Hp - 40] = GHC.Conc.Sync.TVar_con_info;
           P64[Hp - 32] = R1;
           I64[Hp - 24] = SkipList.Node_con_info;
           P64[Hp - 16] = P64[Sp + 40];
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = P64[Sp + 48];
           I64[Sp] = cbJW;
           R1 = P64[Sp + 32];
           P64[Sp + 40] = Hp - 22;
           if (R1 & 7 != 0) goto cbJW; else goto cbKd;
       cbKd:
           call (I64[R1])(R1) returns to cbJW, args: 8, res: 8, upd: 8;
       cbJW:
           _saIm::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(1, _saIm::I64)) goto cbPm; else goto cbKp;
       cbKp:
           I64[Sp + 24] = cbKn;
           R1 = P64[Sp + 8];
           I64[Sp + 32] = _saIm::I64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto cbKn; else goto cbKq;
       cbKq:
           call (I64[R1])(R1) returns to cbKn, args: 8, res: 8, upd: 8;
       cbKn:
           if (R1 & 7 == 1) goto cbN4; else goto cbKL;
       cbKL:
           I64[Sp - 8] = cbKz;
           _saIs::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _saIs::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto cbKz; else goto cbKA;
       cbKA:
           call (I64[R1])(R1) returns to cbKz, args: 8, res: 8, upd: 8;
       cbKz:
           I64[Sp - 24] = cbKE;
           _saIv::P64 = P64[R1 + 15];
           _saIx::P64 = P64[R1 + 23];
           _saIw::I64 = I64[R1 + 31];
           R1 = P64[R1 + 7];
           I64[Sp - 16] = _saIw::I64;
           P64[Sp - 8] = _saIx::P64;
           P64[Sp] = _saIv::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto cbKE; else goto cbKF;
       cbKF:
           call (I64[R1])(R1) returns to cbKE, args: 8, res: 8, upd: 8;
       cbKE:
           I64[Sp - 8] = cbKJ;
           _saIy::P64 = R1;
           _saIz::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp] = _saIz::I64;
           P64[Sp + 24] = _saIy::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto cbKJ; else goto cbKO;
       cbKO:
           call (I64[R1])(R1) returns to cbKJ, args: 8, res: 8, upd: 8;
       cbKJ:
           _saIy::P64 = P64[Sp + 32];
           _saIz::I64 = I64[Sp + 8];
           _saIA::P64 = R1;
           if (%MO_S_Gt_W64(_saIz::I64, 1)) goto cbL6; else goto cbPl;
       cbPl:
           if (%MO_S_Gt_W64(1, I64[R1 + 7])) goto cbL6; else goto cbPk;
       cbL6:
           R4 = _saIA::P64;
           R3 = _saIy::P64;
           R2 = stg_INTLIKE_closure+273;
           Sp = Sp + 72;
           call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
       cbPk:
           _saIw::I64 = I64[Sp + 16];
           _saIK::I64 = 1 - _saIz::I64;
           if (%MO_S_Gt_W64(0, _saIK::I64)) goto cbLp; else goto cbPj;
       cbPj:
           if (%MO_S_Ge_W64(_saIK::I64,
                            _saIw::I64)) goto cbLp; else goto cbLO;
       cbLp:
           R3 = _saIK::I64;
           R2 = _saIw::I64;
           Sp = Sp + 72;
           call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
       cbLO:
           _saIS::P64 = P64[P64[Sp + 24] + ((_saIK::I64 << 3) + 24)];
           I64[Sp + 32] = cbLs;
           R1 = _saIS::P64;
           Sp = Sp + 32;
           if (R1 & 7 != 0) goto cbLs; else goto cbLt;
       cbLt:
           call (I64[R1])(R1) returns to cbLs, args: 8, res: 8, upd: 8;
       cbLs:
           I64[Sp - 8] = cbLx;
           _saIU::P64 = P64[R1 + 7];
           R1 = _saIU::P64;
           P64[Sp] = _saIU::P64;
           Sp = Sp - 8;
           call stg_norec_readTVar#(R1) returns to cbLx, args: 8, res: 8, upd: 8;
       cbLx:
           I64[Sp] = cbLz;
           R2 = P64[Sp + 32];
           _saIX::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _saIX::P64;
           call stg_norec_writeTVar#(R2,
                                     R1) returns to cbLz, args: 8, res: 8, upd: 8;
       cbLz:
           I64[Sp] = cbLD;
           R1 = P64[Sp + 40];
           if (R1 & 7 != 0) goto cbLD; else goto cbLE;
       cbLE:
           call (I64[R1])(R1) returns to cbLD, args: 8, res: 8, upd: 8;
       cbLD:
           I64[Sp - 16] = cbLI;
           _saJ1::P64 = P64[R1 + 15];
           _saJ3::P64 = P64[R1 + 23];
           _saJ2::I64 = I64[R1 + 31];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _saJ3::P64;
           I64[Sp] = _saJ2::I64;
           P64[Sp + 40] = _saJ1::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto cbLI; else goto cbLJ;
       cbLJ:
           call (I64[R1])(R1) returns to cbLI, args: 8, res: 8, upd: 8;
       cbLI:
           I64[Sp - 8] = cbLN;
           _saJ4::P64 = R1;
           _saJ5::I64 = I64[R1 + 7];
           R1 = P64[Sp + 56];
           I64[Sp] = _saJ5::I64;
           P64[Sp + 56] = _saJ4::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto cbLN; else goto cbLU;
       cbLU:
           call (I64[R1])(R1) returns to cbLN, args: 8, res: 8, upd: 8;
       cbLN:
           _saJ4::P64 = P64[Sp + 64];
           _saJ5::I64 = I64[Sp + 8];
           _saJ6::P64 = R1;
           if (%MO_S_Gt_W64(_saJ5::I64, 1)) goto cbMc; else goto cbPi;
       cbPi:
           _saJ7::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(1, _saJ7::I64)) goto cbMc; else goto cbPh;
       cbMc:
           R4 = _saJ6::P64;
           R3 = _saJ4::P64;
           R2 = stg_INTLIKE_closure+273;
           Sp = Sp + 72;
           call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
       cbPh:
           _saJ2::I64 = I64[Sp + 24];
           _saJg::I64 = 1 - _saJ5::I64;
           if (%MO_S_Gt_W64(0, _saJg::I64)) goto cbMv; else goto cbPg;
       cbPg:
           if (%MO_S_Ge_W64(_saJg::I64,
                            _saJ2::I64)) goto cbMv; else goto cbME;
       cbMv:
           R3 = _saJg::I64;
           R2 = _saJ2::I64;
           Sp = Sp + 72;
           call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
       cbME:
           _saJo::P64 = P64[P64[Sp + 16] + ((_saJg::I64 << 3) + 24)];
           I64[Sp - 16] = cbMy;
           R1 = _saJo::P64;
           I64[Sp - 8] = _saJ7::I64;
           P64[Sp] = _saJ6::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto cbMy; else goto cbMz;
       cbMz:
           call (I64[R1])(R1) returns to cbMy, args: 8, res: 8, upd: 8;
       cbMy:
           I64[Sp] = cbMD;
           R2 = P64[Sp + 48];
           R1 = P64[R1 + 7];
           call stg_norec_writeTVar#(R2,
                                     R1) returns to cbMD, args: 8, res: 8, upd: 8;
       cbMD:
           _saIm::I64 = I64[Sp + 64];
           _saJu::P64 = P64[Sp + 56];
           _saJt::I64 = 2;
           goto cbMM;
       cbMM:
           if (HpLim == 0) goto cbMP; else goto cbPf;
       cbMP:
           I64[Sp] = cbMN;
           P64[Sp + 48] = _saJu::P64;
           I64[Sp + 56] = _saJt::I64;
           call stg_gc_noregs() returns to cbMN, args: 8, res: 8, upd: 8;
       cbMN:
           _saIm::I64 = I64[Sp + 64];
           _saJt::I64 = I64[Sp + 56];
           _saJu::P64 = P64[Sp + 48];
           goto cbMM;
       cbPf:
           if (%MO_S_Gt_W64(_saJt::I64,
                            _saIm::I64)) goto ubPr; else goto cbMX;
       ubPr:
           Sp = Sp + 32;
           goto cbPm;
       cbPm:
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 56;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
       cbMX:
           I64[Sp] = cbMV;
           R1 = _saJu::P64;
           I64[Sp + 56] = _saJt::I64;
           if (R1 & 7 != 0) goto cbMV; else goto cbMY;
       cbMY:
           call (I64[R1])(R1) returns to cbMV, args: 8, res: 8, upd: 8;
       cbMV:
           if (R1 & 7 != 1) goto cbNj; else goto ubPs;
       cbNj:
           I64[Sp] = cbN7;
           _saJB::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 48] = _saJB::P64;
           if (R1 & 7 != 0) goto cbN7; else goto cbN8;
       cbN8:
           call (I64[R1])(R1) returns to cbN7, args: 8, res: 8, upd: 8;
       cbN7:
           I64[Sp - 24] = cbNc;
           _saJE::P64 = P64[R1 + 15];
           _saJG::P64 = P64[R1 + 23];
           _saJF::I64 = I64[R1 + 31];
           R1 = P64[R1 + 7];
           I64[Sp - 16] = _saJF::I64;
           P64[Sp - 8] = _saJG::P64;
           P64[Sp] = _saJE::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto cbNc; else goto cbNd;
       cbNd:
           call (I64[R1])(R1) returns to cbNc, args: 8, res: 8, upd: 8;
       cbNc:
           I64[Sp - 8] = cbNh;
           _saJH::P64 = R1;
           _saJI::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp] = _saJI::I64;
           P64[Sp + 24] = _saJH::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto cbNh; else goto cbNm;
       cbNm:
           call (I64[R1])(R1) returns to cbNh, args: 8, res: 8, upd: 8;
       cbNh:
           Hp = Hp + 16;
           if (Hp > HpLim) goto cbNs; else goto cbNr;
       cbNs:
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to cbNh, args: 8, res: 8, upd: 8;
       cbNr:
           _saJt::I64 = I64[Sp + 88];
           _saJH::P64 = P64[Sp + 32];
           _saJI::I64 = I64[Sp + 8];
           if (%MO_S_Le_W64(_saJI::I64,
                            _saJt::I64)) goto cbPd; else goto cbNA;
       cbPd:
           if (%MO_S_Le_W64(_saJt::I64,
                            I64[R1 + 7])) goto cbPc; else goto cbNJ;
       cbPc:
           _saJF::I64 = I64[Sp + 16];
           _saJT::I64 = _saJt::I64 - _saJI::I64;
           if (%MO_S_Gt_W64(0, _saJT::I64)) goto cbO1; else goto cbPb;
       cbPb:
           if (%MO_S_Ge_W64(_saJT::I64,
                            _saJF::I64)) goto cbO1; else goto cbOc;
       cbO1:
           Hp = Hp - 16;
           R3 = _saJT::I64;
           R2 = _saJF::I64;
           Sp = Sp + 120;
           call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
       cbOc:
           Hp = Hp - 16;
           _saK1::P64 = P64[P64[Sp + 24] + ((_saJT::I64 << 3) + 24)];
           I64[Sp + 32] = cbO4;
           R1 = _saK1::P64;
           Sp = Sp + 32;
           if (R1 & 7 != 0) goto cbO4; else goto cbO5;
       cbO5:
           call (I64[R1])(R1) returns to cbO4, args: 8, res: 8, upd: 8;
       cbO4:
           I64[Sp - 8] = cbO9;
           _saK3::P64 = P64[R1 + 7];
           R1 = _saK3::P64;
           P64[Sp] = _saK3::P64;
           Sp = Sp - 8;
           call stg_norec_readTVar#(R1) returns to cbO9, args: 8, res: 8, upd: 8;
       cbO9:
           I64[Sp] = cbOb;
           R2 = P64[Sp + 80];
           _saK6::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _saK6::P64;
           call stg_norec_writeTVar#(R2,
                                     R1) returns to cbOb, args: 8, res: 8, upd: 8;
       cbOb:
           Hp = Hp + 16;
           if (Hp > HpLim) goto cbOk; else goto cbOj;
       cbOk:
           HpAlloc = 16;
           call stg_gc_noregs() returns to cbOb, args: 8, res: 8, upd: 8;
       cbOj:
           _saJ4::P64 = P64[Sp + 88];
           _saJ5::I64 = I64[Sp + 32];
           _saJ6::P64 = P64[Sp + 24];
           _saJt::I64 = I64[Sp + 64];
           if (%MO_S_Le_W64(_saJ5::I64,
                            _saJt::I64)) goto cbPa; else goto cbOs;
       cbPa:
           if (%MO_S_Le_W64(_saJt::I64,
                            I64[Sp + 16])) goto cbP9; else goto cbOB;
       cbP9:
           _saJ2::I64 = I64[Sp + 48];
           _saKg::I64 = _saJt::I64 - _saJ5::I64;
           if (%MO_S_Gt_W64(0, _saKg::I64)) goto cbOT; else goto cbP8;
       cbP8:
           if (%MO_S_Ge_W64(_saKg::I64,
                            _saJ2::I64)) goto cbOT; else goto cbP2;
       cbOT:
           Hp = Hp - 16;
           R3 = _saKg::I64;
           R2 = _saJ2::I64;
           Sp = Sp + 96;
           call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
       cbP2:
           Hp = Hp - 16;
           _saKo::P64 = P64[P64[Sp + 40] + ((_saKg::I64 << 3) + 24)];
           I64[Sp] = cbOW;
           R1 = _saKo::P64;
           if (R1 & 7 != 0) goto cbOW; else goto cbOX;
       cbOX:
           call (I64[R1])(R1) returns to cbOW, args: 8, res: 8, upd: 8;
       cbOW:
           _saK6::P64 = P64[Sp + 8];
           I64[Sp + 8] = cbP1;
           R2 = _saK6::P64;
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_norec_writeTVar#(R2,
                                     R1) returns to cbP1, args: 8, res: 8, upd: 8;
       cbP1:
           _saIm::I64 = I64[Sp + 64];
           _saJu::P64 = P64[Sp + 48];
           _saJt::I64 = I64[Sp + 56] + 1;
           goto cbMM;
       cbOB:
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saJt::I64;
           R4 = _saJ6::P64;
           R3 = _saJ4::P64;
           R2 = Hp - 7;
           Sp = Sp + 96;
           call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
       cbOs:
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saJt::I64;
           R4 = _saJ6::P64;
           R3 = _saJ4::P64;
           R2 = Hp - 7;
           Sp = Sp + 96;
           call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
       cbNJ:
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saJt::I64;
           R4 = R1;
           R3 = _saJH::P64;
           R2 = Hp - 7;
           Sp = Sp + 120;
           call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
       cbNA:
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saJt::I64;
           R4 = R1;
           R3 = _saJH::P64;
           R2 = Hp - 7;
           Sp = Sp + 120;
           call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
       ubPs:
           Sp = Sp + 56;
           goto cbN4;
       cbN4:
           R1 = lvl40_rawz_closure;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:47.440564 UTC

[section "data" {
     SkipList.$wa4_closure:
         const SkipList.$wa4_info;
         const 0;
 },
 $wa8_saFO_entry() //  [R4, R3, R2, R1]
         { info_tbl: [(cbDh,
                       label: $wa8_saFO_info
                       rep:HeapRep 3 ptrs { Fun {arity: 4 fun_type: ArgSpec 21} }),
                      (cbDl,
                       label: block_cbDl_info
                       rep:StackRep [False, False, False, False, False, True]),
                      (cbDq,
                       label: block_cbDq_info
                       rep:StackRep [False, True, False, False, False, False, False,
                                     False, False, True]),
                      (cbDv,
                       label: block_cbDv_info
                       rep:StackRep [True, False, True, False, False, False, False, False,
                                     False, False, True]),
                      (cbEc,
                       label: block_cbEc_info
                       rep:StackRep [True, True, True, False, False, False, False, False,
                                     False, False, True]),
                      (cbEi,
                       label: block_cbEi_info
                       rep:StackRep [True, True, True, False, False, False, False, False,
                                     False, False, True]),
                      (cbEk,
                       label: block_cbEk_info
                       rep:StackRep [True, True, True, False, False, False, False, False,
                                     False, False, True]),
                      (cbEz,
                       label: block_cbEz_info
                       rep:StackRep [True, True, True, False, False, True, False, False,
                                     False, False, True])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbDh:
           _saGC::P64 = R4;
           _saGB::I64 = R3;
           _saGA::P64 = R2;
           _saFO::P64 = R1;
           if ((Sp + -120) < SpLim) goto cbDi; else goto cbDj;
       cbDj:
           if (HpLim == 0) goto cbDi; else goto cbES;
       cbDi:
           R4 = _saGC::P64;
           R3 = _saGB::I64;
           R2 = _saGA::P64;
           R1 = _saFO::P64;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbES:
           if (_saGB::I64 != 0) goto cbDf; else goto cbDg;
       cbDf:
           I64[Sp - 56] = cbDl;
           R1 = _saGA::P64;
           P64[Sp - 48] = P64[_saFO::P64 + 4];
           P64[Sp - 40] = P64[_saFO::P64 + 12];
           P64[Sp - 32] = P64[_saFO::P64 + 20];
           P64[Sp - 24] = _saFO::P64;
           P64[Sp - 16] = _saGC::P64;
           I64[Sp - 8] = _saGB::I64;
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto cbDl; else goto cbDm;
       cbDm:
           call (I64[R1])(R1) returns to cbDl, args: 8, res: 8, upd: 8;
       cbDl:
           I64[Sp - 32] = cbDq;
           _saGF::P64 = R1;
           _saGH::P64 = P64[R1 + 15];
           _saGJ::P64 = P64[R1 + 23];
           _saGI::I64 = I64[R1 + 31];
           R1 = P64[R1 + 7];
           P64[Sp - 24] = _saGH::P64;
           I64[Sp - 16] = _saGI::I64;
           P64[Sp - 8] = _saGJ::P64;
           P64[Sp] = _saGF::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto cbDq; else goto cbDr;
       cbDr:
           call (I64[R1])(R1) returns to cbDq, args: 8, res: 8, upd: 8;
       cbDq:
           I64[Sp - 8] = cbDv;
           _saGK::P64 = R1;
           _saGL::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp] = _saGL::I64;
           P64[Sp + 8] = _saGK::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto cbDv; else goto cbDy;
       cbDy:
           call (I64[R1])(R1) returns to cbDv, args: 8, res: 8, upd: 8;
       cbDv:
           _saGE::I64 = I64[Sp + 88];
           _saGK::P64 = P64[Sp + 16];
           _saGL::I64 = I64[Sp + 8];
           _saGM::P64 = R1;
           if (%MO_S_Gt_W64(_saGL::I64,
                            _saGE::I64)) goto cbDQ; else goto cbER;
       cbER:
           _saGN::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(_saGE::I64,
                            _saGN::I64)) goto cbDQ; else goto cbEQ;
       cbDQ:
           R4 = _saGM::P64;
           R3 = _saGK::P64;
           R2 = _saGE::I64;
           Sp = Sp + 96;
           call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
       cbEQ:
           _saGI::I64 = I64[Sp + 24];
           _saGU::I64 = _saGE::I64 - _saGL::I64;
           if (%MO_S_Gt_W64(0, _saGU::I64)) goto cbE9; else goto cbEP;
       cbEP:
           if (%MO_S_Ge_W64(_saGU::I64,
                            _saGI::I64)) goto cbE9; else goto cbEd;
       cbE9:
           R3 = _saGU::I64;
           R2 = _saGI::I64;
           Sp = Sp + 96;
           call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
       cbEd:
           _saH2::P64 = P64[P64[Sp + 32] + ((_saGU::I64 << 3) + 24)];
           I64[Sp] = cbEc;
           R1 = _saH2::P64;
           I64[Sp + 16] = _saGN::I64;
           if (R1 & 7 != 0) goto cbEc; else goto cbEe;
       cbEe:
           call (I64[R1])(R1) returns to cbEc, args: 8, res: 8, upd: 8;
       cbEc:
           I64[Sp] = cbEi;
           R1 = P64[R1 + 7];
           call stg_norec_readTVar#(R1) returns to cbEi, args: 8, res: 8, upd: 8;
       cbEi:
           I64[Sp] = cbEk;
           R1 = R1;
           if (R1 & 7 != 0) goto cbEk; else goto cbEn;
       cbEn:
           call (I64[R1])(R1) returns to cbEk, args: 8, res: 8, upd: 8;
       cbEk:
           if (R1 & 7 != 1) goto cbEB; else goto cbEt;
       cbEB:
           I64[Sp] = cbEz;
           R2 = P64[Sp + 48];
           I64[Sp - 24] = stg_ap_pp_info;
           P64[Sp - 16] = P64[R1 + 6];
           P64[Sp - 8] = P64[Sp + 56];
           P64[Sp + 56] = P64[R1 + 22];
           Sp = Sp - 24;
           call GHC.Classes.>_info(R2) returns to cbEz, args: 32, res: 8, upd: 8;
       cbEz:
           _saGC::P64 = P64[Sp + 80];
           _saGE::I64 = I64[Sp + 88];
           if (R1 & 7 != 1) goto cbEL; else goto cbEH;
       cbEL:
           Hp = Hp + 24;
           if (Hp > HpLim) goto cbEO; else goto cbEN;
       cbEO:
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to cbEz, args: 8, res: 8, upd: 8;
       cbEN:
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = _saGC::P64;
           R6 = _saGE::I64 - 1;
           R5 = P64[Sp + 32];
           R4 = I64[Sp + 24];
           R3 = I64[Sp + 16];
           R2 = I64[Sp + 8];
           R1 = P64[Sp + 64];
           P64[Sp + 88] = Hp - 14;
           Sp = Sp + 88;
           call $s$wa_saFN_info(R6,
                                R5,
                                R4,
                                R3,
                                R2,
                                R1) args: 16, res: 0, upd: 8;
       cbEH:
           R4 = _saGC::P64;
           R3 = _saGE::I64;
           R2 = P64[Sp + 56];
           R1 = P64[Sp + 72];
           Sp = Sp + 96;
           call $wa8_saFO_info(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbEt:
           Hp = Hp + 24;
           if (Hp > HpLim) goto cbEw; else goto cbEv;
       cbEw:
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to cbEk, args: 8, res: 8, upd: 8;
       cbEv:
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = P64[Sp + 80];
           R6 = I64[Sp + 88] - 1;
           R5 = P64[Sp + 32];
           R4 = I64[Sp + 24];
           R3 = I64[Sp + 16];
           R2 = I64[Sp + 8];
           R1 = P64[Sp + 64];
           P64[Sp + 88] = Hp - 14;
           Sp = Sp + 88;
           call $s$wa_saFN_info(R6,
                                R5,
                                R4,
                                R3,
                                R2,
                                R1) args: 16, res: 0, upd: 8;
       cbDg:
           R1 = _saGC::P64;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 },
 $s$wa_saFN_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 56 updfr_space: Just 8
         }
     {offset
       cbEY:
           R6 = I64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = I64[Sp + 8];
           R2 = I64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call $s$wa_saFN_info(R6,
                                R5,
                                R4,
                                R3,
                                R2,
                                R1) args: 16, res: 0, upd: 8;
     }
 },
 $s$wa_saFN_entry() //  [R6, R5, R4, R3, R2, R1]
         { info_tbl: [(cbG1,
                       label: $s$wa_saFN_info
                       rep:HeapRep 3 ptrs {
                             Fun {arity: 8
                                  fun_type: ArgGen [True, True, True, False, True, False]} }),
                      (cbGK,
                       label: block_cbGK_info
                       rep:StackRep [False, False, False, False, True, True, True, False,
                                     True, False]),
                      (cbGQ,
                       label: block_cbGQ_info
                       rep:StackRep [False, False, False, False, True, True, True, False,
                                     True, False]),
                      (cbGS,
                       label: block_cbGS_info
                       rep:StackRep [False, False, False, False, True, True, True, False,
                                     True, False]),
                      (cbHa,
                       label: block_cbHa_info
                       rep:StackRep [False, False, False, True, True, True, False, True,
                                     False])]
           stack_info: arg_space: 16 updfr_space: Just 8
         }
     {offset
       cbG1:
           _saFT::I64 = R6;
           _saFS::P64 = R5;
           _saFR::I64 = R4;
           _saFQ::I64 = R3;
           _saFP::I64 = R2;
           _saFN::P64 = R1;
           if ((Sp + -96) < SpLim) goto cbG2; else goto cbG3;
       cbG3:
           Hp = Hp + 32;
           if (Hp > HpLim) goto cbG5; else goto cbG4;
       cbG5:
           HpAlloc = 32;
           goto cbG2;
       cbG2:
           R1 = _saFN::P64;
           I64[Sp - 40] = _saFP::I64;
           I64[Sp - 32] = _saFQ::I64;
           I64[Sp - 24] = _saFR::I64;
           P64[Sp - 16] = _saFS::P64;
           I64[Sp - 8] = _saFT::I64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 56, res: 0, upd: 8;
       cbG4:
           if (_saFT::I64 != 0) goto cbFZ; else goto cbG0;
       cbFZ:
           if (%MO_S_Le_W64(_saFP::I64,
                            _saFT::I64)) goto cbHv; else goto cbGf;
       cbHv:
           if (%MO_S_Le_W64(_saFT::I64,
                            _saFQ::I64)) goto cbHu; else goto cbGp;
       cbHu:
           _saG7::I64 = _saFT::I64 - _saFP::I64;
           if (%MO_S_Gt_W64(0, _saG7::I64)) goto cbGH; else goto cbHt;
       cbHt:
           if (%MO_S_Ge_W64(_saG7::I64,
                            _saFR::I64)) goto cbGH; else goto cbGL;
       cbGH:
           Hp = Hp - 32;
           R3 = _saG7::I64;
           R2 = _saFR::I64;
           Sp = Sp + 8;
           call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
       cbGL:
           _saFB::P64 = P64[_saFN::P64 + 8];
           _saFF::P64 = P64[_saFN::P64 + 16];
           _saFO::P64 = P64[_saFN::P64 + 24];
           Hp = Hp - 32;
           _saGf::P64 = P64[(_saFS::P64 + 24) + (_saG7::I64 << 3)];
           I64[Sp - 80] = cbGK;
           R1 = _saGf::P64;
           P64[Sp - 72] = _saFB::P64;
           P64[Sp - 64] = _saFF::P64;
           P64[Sp - 56] = _saFN::P64;
           P64[Sp - 48] = _saFO::P64;
           I64[Sp - 40] = _saFP::I64;
           I64[Sp - 32] = _saFQ::I64;
           I64[Sp - 24] = _saFR::I64;
           P64[Sp - 16] = _saFS::P64;
           I64[Sp - 8] = _saFT::I64;
           Sp = Sp - 80;
           if (R1 & 7 != 0) goto cbGK; else goto cbGM;
       cbGM:
           call (I64[R1])(R1) returns to cbGK, args: 8, res: 8, upd: 8;
       cbGK:
           I64[Sp] = cbGQ;
           R1 = P64[R1 + 7];
           call stg_norec_readTVar#(R1) returns to cbGQ, args: 8, res: 8, upd: 8;
       cbGQ:
           I64[Sp] = cbGS;
           R1 = R1;
           if (R1 & 7 != 0) goto cbGS; else goto cbGV;
       cbGV:
           call (I64[R1])(R1) returns to cbGS, args: 8, res: 8, upd: 8;
       cbGS:
           if (R1 & 7 != 1) goto cbHc; else goto cbH4;
       cbHc:
           _saFB::P64 = P64[Sp + 8];
           I64[Sp + 8] = cbHa;
           R2 = _saFB::P64;
           I64[Sp - 16] = stg_ap_pp_info;
           P64[Sp - 8] = P64[R1 + 6];
           P64[Sp] = P64[Sp + 16];
           P64[Sp + 16] = P64[R1 + 22];
           Sp = Sp - 16;
           call GHC.Classes.>_info(R2) returns to cbHa, args: 32, res: 8, upd: 8;
       cbHa:
           _saFU::P64 = P64[Sp + 72];
           _saFW::I64 = I64[Sp + 64];
           if (R1 & 7 != 1) goto cbHp; else goto cbHi;
       cbHp:
           Hp = Hp + 96;
           if (Hp > HpLim) goto cbHs; else goto cbHr;
       cbHs:
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to cbHa, args: 8, res: 8, upd: 8;
       cbHr:
           I64[Hp - 88] = GHC.Types.I#_con_info;
           _saFQ::I64 = I64[Sp + 40];
           I64[Hp - 80] = _saFQ::I64;
           I64[Hp - 72] = GHC.Types.I#_con_info;
           _saFP::I64 = I64[Sp + 32];
           I64[Hp - 64] = _saFP::I64;
           I64[Hp - 56] = GHC.Arr.Array_con_info;
           P64[Hp - 48] = Hp - 71;
           P64[Hp - 40] = Hp - 87;
           _saFS::P64 = P64[Sp + 56];
           P64[Hp - 32] = _saFS::P64;
           _saFR::I64 = I64[Sp + 48];
           I64[Hp - 24] = _saFR::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = _saFU::P64;
           R6 = _saFW::I64 - 1;
           R5 = _saFS::P64;
           R4 = _saFR::I64;
           R3 = _saFQ::I64;
           R2 = _saFP::I64;
           R1 = P64[Sp + 16];
           P64[Sp + 72] = Hp - 14;
           Sp = Sp + 72;
           call $s$wa_saFN_info(R6,
                                R5,
                                R4,
                                R3,
                                R2,
                                R1) args: 16, res: 0, upd: 8;
       cbHi:
           R4 = _saFU::P64;
           R3 = _saFW::I64;
           R2 = P64[Sp + 8];
           R1 = P64[Sp + 24];
           Sp = Sp + 80;
           call $wa8_saFO_info(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbH4:
           Hp = Hp + 96;
           if (Hp > HpLim) goto cbH7; else goto cbH6;
       cbH7:
           HpAlloc = 96;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to cbGS, args: 8, res: 8, upd: 8;
       cbH6:
           I64[Hp - 88] = GHC.Types.I#_con_info;
           _saFQ::I64 = I64[Sp + 48];
           I64[Hp - 80] = _saFQ::I64;
           I64[Hp - 72] = GHC.Types.I#_con_info;
           _saFP::I64 = I64[Sp + 40];
           I64[Hp - 64] = _saFP::I64;
           I64[Hp - 56] = GHC.Arr.Array_con_info;
           P64[Hp - 48] = Hp - 71;
           P64[Hp - 40] = Hp - 87;
           _saFS::P64 = P64[Sp + 64];
           P64[Hp - 32] = _saFS::P64;
           _saFR::I64 = I64[Sp + 56];
           I64[Hp - 24] = _saFR::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 55;
           P64[Hp] = P64[Sp + 80];
           R6 = I64[Sp + 72] - 1;
           R5 = _saFS::P64;
           R4 = _saFR::I64;
           R3 = _saFQ::I64;
           R2 = _saFP::I64;
           R1 = P64[Sp + 24];
           P64[Sp + 80] = Hp - 14;
           Sp = Sp + 80;
           call $s$wa_saFN_info(R6,
                                R5,
                                R4,
                                R3,
                                R2,
                                R1) args: 16, res: 0, upd: 8;
       cbGp:
           I64[Hp - 24] = GHC.Types.I#_con_info;
           I64[Hp - 16] = _saFQ::I64;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saFP::I64;
           R4 = Hp - 23;
           R3 = Hp - 7;
           R2 = _saFT::I64;
           Sp = Sp + 8;
           call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
       cbGf:
           I64[Hp - 24] = GHC.Types.I#_con_info;
           I64[Hp - 16] = _saFQ::I64;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saFP::I64;
           R4 = Hp - 23;
           R3 = Hp - 7;
           R2 = _saFT::I64;
           Sp = Sp + 8;
           call lvl20_rawe_info(R4, R3, R2) args: 8, res: 0, upd: 8;
       cbG0:
           Hp = Hp - 32;
           R1 = P64[Sp];
           Sp = Sp + 8;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_saHY_entry() //  [R1]
         { info_tbl: [(cbHT,
                       label: sat_saHY_info
                       rep:HeapRep 1 ptrs 1 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} }),
                      (cbI2,
                       label: block_cbI2_info
                       rep:StackRep [True]),
                      (cbIa,
                       label: block_cbIa_info
                       rep:StackRep [True])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbHT:
           _saHY::P64 = R1;
           if ((Sp + -16) < SpLim) goto cbHU; else goto cbHV;
       cbHV:
           if (HpLim == 0) goto cbHU; else goto cbIY;
       cbHU:
           R1 = _saHY::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cbIY:
           _saFE::P64 = P64[_saHY::P64 + 7];
           _saHu::I64 = I64[_saHY::P64 + 15] << 3;
           if (%MO_S_Ge_W64(_saHu::I64, 0)) goto cbIb; else goto cbI4;
       cbIb:
           I64[Sp - 16] = cbIa;
           R1 = _saFE::P64;
           I64[Sp - 8] = _saHu::I64;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) returns to cbIa, args: 8, res: 8, upd: 8;
       cbIa:
           Hp = Hp + 16;
           if (Hp > HpLim) goto cbIh; else goto cbIg;
       cbIh:
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to cbIa, args: 8, res: 8, upd: 8;
       cbIg:
           _saHu::I64 = I64[Sp + 8];
           _saHE::I64 = I64[R1 + 23];
           if (%MO_S_Lt_W64(_saHu::I64,
                            _saHE::I64)) goto cbIX; else goto cbIn;
       cbIX:
           _saHF::P64 = P64[R1 + 7];
           _saHD::I64 = I64[R1 + 15];
           _saHM::I64 = I64[(_saHF::P64 + 16) + (_saHD::I64 + _saHu::I64 << 3)];
           I64[(_saHF::P64 + 16) + (_saHD::I64 + _saHu::I64 << 3)] = _saHM::I64 * 6364136223846793005;
           I64[Hp - 8] = GHC.Word.W32#_con_info;
           I64[Hp] = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32((_saHM::I64 >> 22) ^ _saHM::I64 >> (_saHM::I64 >> 61) + 22));
           R1 = Hp - 7;
           Sp = Sp + 16;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
       cbIn:
           Hp = Hp - 16;
           R3 = _saHu::I64;
           R2 = _saHE::I64;
           Sp = Sp + 16;
           call lvl5_ravU_info(R3, R2) args: 8, res: 0, upd: 8;
       cbI4:
           I64[Sp - 16] = cbI2;
           R1 = _saFE::P64;
           I64[Sp - 8] = _saHu::I64;
           Sp = Sp - 16;
           call stg_ap_0_fast(R1) returns to cbI2, args: 8, res: 8, upd: 8;
       cbI2:
           R3 = I64[Sp + 8];
           R2 = I64[R1 + 23];
           Sp = Sp + 16;
           call lvl5_ravU_info(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 nodesHeight_saHs_entry() //  [R1]
         { info_tbl: [(cbIZ,
                       label: block_cbIZ_info
                       rep:StackRep [False, True]),
                      (cbJ1,
                       label: nodesHeight_saHs_info
                       rep:HeapRep 2 ptrs 2 nonptrs { Thunk }),
                      (cbJ4,
                       label: block_cbJ4_info
                       rep:StackRep [True, False, True])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbJ1:
           _saHs::P64 = R1;
           if ((Sp + -48) < SpLim) goto cbJ5; else goto cbJ6;
       cbJ6:
           Hp = Hp + 24;
           if (Hp > HpLim) goto cbJ8; else goto cbJ7;
       cbJ8:
           HpAlloc = 24;
           goto cbJ5;
       cbJ5:
           R1 = _saHs::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cbJ7:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _saHs::P64;
           _saFE::P64 = P64[_saHs::P64 + 16];
           _saFL::P64 = P64[_saHs::P64 + 24];
           _saFM::I64 = I64[_saHs::P64 + 32];
           _saHq::I64 = I64[_saHs::P64 + 40];
           I64[Hp - 16] = sat_saHY_info;
           P64[Hp - 8] = _saFE::P64;
           I64[Hp] = _saHq::I64;
           I64[Sp - 40] = cbIZ;
           R2 = Hp - 15;
           P64[Sp - 32] = _saFL::P64;
           I64[Sp - 24] = _saFM::I64;
           Sp = Sp - 40;
           call GHC.IO.unsafeDupablePerformIO_info(R2) returns to cbIZ, args: 8, res: 8, upd: 24;
       cbIZ:
           I64[Sp - 8] = cbJ4;
           _saI0::I64 = I64[R1 + 7];
           R1 = logHalf_r2BC_closure;
           I64[Sp] = _saI0::I64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto cbJ4; else goto cbJa;
       cbJa:
           call (I64[R1])(R1) returns to cbJ4, args: 8, res: 8, upd: 24;
       cbJ4:
           Hp = Hp + 16;
           if (Hp > HpLim) goto cbJg; else goto cbJf;
       cbJg:
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to cbJ4, args: 8, res: 8, upd: 24;
       cbJf:
           _saFL::P64 = P64[Sp + 16];
           _saFM::I64 = I64[Sp + 24];
           _saI0::I64 = I64[Sp + 8];
           _saI2::F32 = F32[R1 + 7];
           (_cbJh::F32) = call MO_UF_Conv W32(4294967295);
           (_cbJl::F32) = call MO_UF_Conv W32(_saI0::I64);
           (_cbJs::F32) = call MO_F32_Log(%MO_F_Quot_W32(_cbJl::F32,
                                                         _cbJh::F32));
           _saI8::I64 = %MO_FS_Conv_W32_W64(%MO_F_Quot_W32(_cbJs::F32,
                                                           _saI2::F32)) + 1;
           if (%MO_S_Le_W64(_saFM::I64,
                            _saI8::I64)) goto cbJN; else goto cbJM;
       cbJN:
           Hp = Hp - 16;
           R1 = _saFL::P64 & (-8);
           Sp = Sp + 32;
           call (I64[R1])(R1) args: 24, res: 0, upd: 24;
       cbJM:
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saI8::I64;
           R1 = Hp - 7;
           Sp = Sp + 32;
           call (P64[Sp])(R1) args: 24, res: 0, upd: 24;
     }
 },
 section "relreadonly" {
     ubPt_srtd:
         const SaM6_srt+168;
         const 37;
         const 120527528513;
 },
 section "relreadonly" {
     ubPu_srtd:
         const SaM6_srt+168;
         const 37;
         const 120527528513;
 },
 section "relreadonly" {
     ubPv_srtd:
         const SaM6_srt+168;
         const 37;
         const 120527528449;
 },
 section "relreadonly" {
     ubPw_srtd:
         const SaM6_srt+168;
         const 37;
         const 120527528449;
 },
 section "relreadonly" {
     ubPx_srtd:
         const SaM6_srt+168;
         const 37;
         const 120527528449;
 },
 section "relreadonly" {
     ubPy_srtd:
         const SaM6_srt+168;
         const 37;
         const 120527528449;
 },
 section "relreadonly" {
     ubPz_srtd:
         const SaM6_srt+168;
         const 38;
         const 257966481985;
 },
 SkipList.$wa4_entry() //  [R6, R5, R4, R3, R2]
         { info_tbl: [(cbD0,
                       label: block_cbD0_info
                       rep:StackRep [False, False, False, False, False]),
                      (cbD2,
                       label: block_cbD2_info
                       rep:StackRep [False, False, False, False, False]),
                      (cbHA,
                       label: block_cbHA_info
                       rep:StackRep [True, False, False, False, False]),
                      (cbHC,
                       label: block_cbHC_info
                       rep:StackRep [False, True, False, False, False, False]),
                      (cbHE,
                       label: block_cbHE_info
                       rep:StackRep [False, True, False, False, False, False]),
                      (cbHG,
                       label: block_cbHG_info
                       rep:StackRep [True, False, True, False, False, False, False]),
                      (cbJO,
                       label: SkipList.$wa4_info
                       rep:HeapRep static { Fun {arity: 7 fun_type: ArgSpec 26} }),
                      (cbJQ,
                       label: block_cbJQ_info
                       rep:StackRep [False, True, True, False, False, False]),
                      (cbJS,
                       label: block_cbJS_info
                       rep:StackRep [False, True, True, False, False, False]),
                      (cbJW,
                       label: block_cbJW_info
                       rep:StackRep [False, True, True, True, False, False]),
                      (cbKn,
                       label: block_cbKn_info
                       rep:StackRep [True, False, False]),
                      (cbKz,
                       label: block_cbKz_info
                       rep:StackRep [False, True, False, False]),
                      (cbKE,
                       label: block_cbKE_info
                       rep:StackRep [True, False, False, False, True, False, False]),
                      (cbKJ,
                       label: block_cbKJ_info
                       rep:StackRep [True, True, False, False, False, True, False,
                                     False]),
                      (cbLs,
                       label: block_cbLs_info
                       rep:StackRep [False, True, False, False]),
                      (cbLx,
                       label: block_cbLx_info
                       rep:StackRep [False, False, True, False, False]),
                      (cbLz,
                       label: block_cbLz_info
                       rep:StackRep [False, False, True, False, False]),
                      (cbLD,
                       label: block_cbLD_info
                       rep:StackRep [False, False, True, False, True]),
                      (cbLI,
                       label: block_cbLI_info
                       rep:StackRep [False, True, False, False, True, False, False]),
                      (cbLN,
                       label: block_cbLN_info
                       rep:StackRep [True, False, True, False, False, True, False,
                                     False]),
                      (cbMy,
                       label: block_cbMy_info
                       rep:StackRep [True, False, True, False, True, False, False, True,
                                     False, False]),
                      (cbMD,
                       label: block_cbMD_info
                       rep:StackRep [True, False, True, False, True, True, False, True,
                                     False, False]),
                      (cbMN,
                       label: block_cbMN_info
                       rep:StackRep [True, False, True, False, True, False, True, True,
                                     False, False]),
                      (cbMV,
                       label: block_cbMV_info
                       rep:StackRep [True, False, True, False, True, True, True, True,
                                     False, False]),
                      (cbN7,
                       label: block_cbN7_info
                       rep:StackRep [True, False, True, False, True, False, True, True,
                                     False, False]),
                      (cbNc,
                       label: block_cbNc_info
                       rep:StackRep [True, False, False, True, False, True, False, True,
                                     False, True, True, False, False]),
                      (cbNh,
                       label: block_cbNh_info
                       rep:StackRep [True, True, False, False, True, False, True, False,
                                     True, False, True, True, False, False]),
                      (cbO4,
                       label: block_cbO4_info
                       rep:StackRep [True, False, True, False, True, False, True, True,
                                     False, False]),
                      (cbO9,
                       label: block_cbO9_info
                       rep:StackRep [False, True, False, True, False, True, False, True,
                                     True, False, False]),
                      (cbOb,
                       label: block_cbOb_info
                       rep:StackRep [False, True, False, True, False, True, False, True,
                                     True, False, False]),
                      (cbOW,
                       label: block_cbOW_info
                       rep:StackRep [False, True, False, True, False, True, False, True,
                                     True, False, False]),
                      (cbP1,
                       label: block_cbP1_info
                       rep:StackRep [True, False, True, False, True, False, True, True,
                                     False, False])]
           stack_info: arg_space: 16 updfr_space: Just 8
         }
     {offset
       cbJO:
           _saFF::P64 = R6;
           _saFE::P64 = R5;
           _saFD::P64 = R4;
           _saFC::P64 = R3;
           _saFB::P64 = R2;
           if ((Sp + -112) < SpLim) goto cbJX; else goto cbJY;
       cbJY:
           if (HpLim == 0) goto cbJX; else goto cbJZ;
       cbJX:
           R6 = _saFF::P64;
           R5 = _saFE::P64;
           R4 = _saFD::P64;
           R3 = _saFC::P64;
           R2 = _saFB::P64;
           R1 = SkipList.$wa4_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 16, res: 0, upd: 8;
       cbJZ:
           I64[Sp - 40] = cbD0;
           R1 = _saFD::P64;
           P64[Sp - 32] = _saFB::P64;
           P64[Sp - 24] = _saFC::P64;
           P64[Sp - 16] = _saFE::P64;
           P64[Sp - 8] = _saFF::P64;
           Sp = Sp - 40;
           call stg_norec_readTVar#(R1) returns to cbD0, args: 8, res: 8, upd: 8;
       cbD0:
           I64[Sp] = cbD2;
           R1 = R1;
           if (R1 & 7 != 0) goto cbD2; else goto cbD3;
       cbD3:
           call (I64[R1])(R1) returns to cbD2, args: 8, res: 8, upd: 8;
       cbD2:
           Hp = Hp + 64;
           if (Hp > HpLim) goto cbK3; else goto cbK2;
       cbK3:
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to cbD2, args: 8, res: 8, upd: 8;
       cbK2:
           _saFM::I64 = I64[R1 + 7];
           I64[Hp - 56] = $wa8_saFO_info;
           _saFB::P64 = P64[Sp + 8];
           P64[Hp - 48] = _saFB::P64;
           _saFF::P64 = P64[Sp + 32];
           P64[Hp - 40] = _saFF::P64;
           P64[Hp - 32] = Hp - 24;
           I64[Hp - 24] = $s$wa_saFN_info;
           P64[Hp - 16] = _saFB::P64;
           P64[Hp - 8] = _saFF::P64;
           _cbD7::P64 = Hp - 52;
           P64[Hp] = _cbD7::P64;
           I64[Sp] = cbHA;
           R4 = GHC.Types.[]_closure+1;
           R3 = _saFM::I64;
           R2 = P64[Sp + 16];
           _saFL::P64 = R1;
           R1 = _cbD7::P64;
           I64[Sp + 8] = _saFM::I64;
           P64[Sp + 16] = _saFL::P64;
           call $wa8_saFO_info(R4,
                               R3,
                               R2,
                               R1) returns to cbHA, args: 8, res: 8, upd: 8;
       cbHA:
           I64[Sp - 8] = cbHC;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call stg_myThreadId#() returns to cbHC, args: 8, res: 8, upd: 8;
       cbHC:
           I64[Sp] = cbHE;
           R1 = R1;
           call stg_threadStatus#(R1) returns to cbHE, args: 8, res: 8, upd: 8;
       cbHE:
           _saFE::P64 = P64[Sp + 32];
           _saFL::P64 = P64[Sp + 24];
           _saFM::I64 = I64[Sp + 16];
           _saHq::I64 = R2;
           goto cbHF;
       cbHF:
           Hp = Hp + 72;
           if (Hp > HpLim) goto cbK8; else goto cbK7;
       cbK8:
           HpAlloc = 72;
           I64[Sp - 8] = cbHG;
           I64[Sp] = _saHq::I64;
           Sp = Sp - 8;
           call stg_gc_noregs() returns to cbHG, args: 8, res: 8, upd: 8;
       cbHG:
           _saFE::P64 = P64[Sp + 40];
           _saFL::P64 = P64[Sp + 32];
           _saFM::I64 = I64[Sp + 24];
           _saHq::I64 = I64[Sp + 8];
           Sp = Sp + 8;
           goto cbHF;
       cbK7:
           I64[Hp - 64] = nodesHeight_saHs_info;
           P64[Hp - 48] = _saFE::P64;
           P64[Hp - 40] = _saFL::P64;
           I64[Hp - 32] = _saFM::I64;
           I64[Hp - 24] = _saHq::I64;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = SkipList.newSL10_closure+1;
           _cbHI::P64 = Hp - 64;
           P64[Hp] = _cbHI::P64;
           I64[Sp] = cbJQ;
           R3 = Hp - 15;
           R2 = GHC.Arr.$fIxInt_closure;
           P64[Sp + 32] = _cbHI::P64;
           call SkipList.$fMArrayTArrayeSTM8_info(R3,
                                                  R2) returns to cbJQ, args: 8, res: 8, upd: 8;
       cbJQ:
           I64[Sp] = cbJS;
           _saIf::P64 = R1;
           R1 = P64[Sp + 48];
           P64[Sp + 48] = _saIf::P64;
           call stg_newNOrecTVar#(R1) returns to cbJS, args: 8, res: 8, upd: 8;
       cbJS:
           Hp = Hp + 48;
           if (Hp > HpLim) goto cbKc; else goto cbKb;
       cbKc:
           HpAlloc = 48;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to cbJS, args: 8, res: 8, upd: 8;
       cbKb:
           I64[Hp - 40] = GHC.Conc.Sync.TVar_con_info;
           P64[Hp - 32] = R1;
           I64[Hp - 24] = SkipList.Node_con_info;
           P64[Hp - 16] = P64[Sp + 40];
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = P64[Sp + 48];
           I64[Sp] = cbJW;
           R1 = P64[Sp + 32];
           P64[Sp + 40] = Hp - 22;
           if (R1 & 7 != 0) goto cbJW; else goto cbKd;
       cbKd:
           call (I64[R1])(R1) returns to cbJW, args: 8, res: 8, upd: 8;
       cbJW:
           _saIm::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(1, _saIm::I64)) goto cbPm; else goto cbKp;
       cbKp:
           I64[Sp + 24] = cbKn;
           R1 = P64[Sp + 8];
           I64[Sp + 32] = _saIm::I64;
           Sp = Sp + 24;
           if (R1 & 7 != 0) goto cbKn; else goto cbKq;
       cbKq:
           call (I64[R1])(R1) returns to cbKn, args: 8, res: 8, upd: 8;
       cbKn:
           if (R1 & 7 == 1) goto cbN4; else goto cbKL;
       cbKL:
           I64[Sp - 8] = cbKz;
           _saIs::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _saIs::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto cbKz; else goto cbKA;
       cbKA:
           call (I64[R1])(R1) returns to cbKz, args: 8, res: 8, upd: 8;
       cbKz:
           I64[Sp - 24] = cbKE;
           _saIv::P64 = P64[R1 + 15];
           _saIx::P64 = P64[R1 + 23];
           _saIw::I64 = I64[R1 + 31];
           R1 = P64[R1 + 7];
           I64[Sp - 16] = _saIw::I64;
           P64[Sp - 8] = _saIx::P64;
           P64[Sp] = _saIv::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto cbKE; else goto cbKF;
       cbKF:
           call (I64[R1])(R1) returns to cbKE, args: 8, res: 8, upd: 8;
       cbKE:
           I64[Sp - 8] = cbKJ;
           _saIy::P64 = R1;
           _saIz::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp] = _saIz::I64;
           P64[Sp + 24] = _saIy::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto cbKJ; else goto cbKO;
       cbKO:
           call (I64[R1])(R1) returns to cbKJ, args: 8, res: 8, upd: 8;
       cbKJ:
           _saIy::P64 = P64[Sp + 32];
           _saIz::I64 = I64[Sp + 8];
           _saIA::P64 = R1;
           if (%MO_S_Gt_W64(_saIz::I64, 1)) goto cbL6; else goto cbPl;
       cbPl:
           if (%MO_S_Gt_W64(1, I64[R1 + 7])) goto cbL6; else goto cbPk;
       cbL6:
           R4 = _saIA::P64;
           R3 = _saIy::P64;
           R2 = stg_INTLIKE_closure+273;
           Sp = Sp + 72;
           call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
       cbPk:
           _saIw::I64 = I64[Sp + 16];
           _saIK::I64 = 1 - _saIz::I64;
           if (%MO_S_Gt_W64(0, _saIK::I64)) goto cbLp; else goto cbPj;
       cbPj:
           if (%MO_S_Ge_W64(_saIK::I64,
                            _saIw::I64)) goto cbLp; else goto cbLO;
       cbLp:
           R3 = _saIK::I64;
           R2 = _saIw::I64;
           Sp = Sp + 72;
           call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
       cbLO:
           _saIS::P64 = P64[P64[Sp + 24] + ((_saIK::I64 << 3) + 24)];
           I64[Sp + 32] = cbLs;
           R1 = _saIS::P64;
           Sp = Sp + 32;
           if (R1 & 7 != 0) goto cbLs; else goto cbLt;
       cbLt:
           call (I64[R1])(R1) returns to cbLs, args: 8, res: 8, upd: 8;
       cbLs:
           I64[Sp - 8] = cbLx;
           _saIU::P64 = P64[R1 + 7];
           R1 = _saIU::P64;
           P64[Sp] = _saIU::P64;
           Sp = Sp - 8;
           call stg_norec_readTVar#(R1) returns to cbLx, args: 8, res: 8, upd: 8;
       cbLx:
           I64[Sp] = cbLz;
           R2 = P64[Sp + 32];
           _saIX::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _saIX::P64;
           call stg_norec_writeTVar#(R2,
                                     R1) returns to cbLz, args: 8, res: 8, upd: 8;
       cbLz:
           I64[Sp] = cbLD;
           R1 = P64[Sp + 40];
           if (R1 & 7 != 0) goto cbLD; else goto cbLE;
       cbLE:
           call (I64[R1])(R1) returns to cbLD, args: 8, res: 8, upd: 8;
       cbLD:
           I64[Sp - 16] = cbLI;
           _saJ1::P64 = P64[R1 + 15];
           _saJ3::P64 = P64[R1 + 23];
           _saJ2::I64 = I64[R1 + 31];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _saJ3::P64;
           I64[Sp] = _saJ2::I64;
           P64[Sp + 40] = _saJ1::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto cbLI; else goto cbLJ;
       cbLJ:
           call (I64[R1])(R1) returns to cbLI, args: 8, res: 8, upd: 8;
       cbLI:
           I64[Sp - 8] = cbLN;
           _saJ4::P64 = R1;
           _saJ5::I64 = I64[R1 + 7];
           R1 = P64[Sp + 56];
           I64[Sp] = _saJ5::I64;
           P64[Sp + 56] = _saJ4::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto cbLN; else goto cbLU;
       cbLU:
           call (I64[R1])(R1) returns to cbLN, args: 8, res: 8, upd: 8;
       cbLN:
           _saJ4::P64 = P64[Sp + 64];
           _saJ5::I64 = I64[Sp + 8];
           _saJ6::P64 = R1;
           if (%MO_S_Gt_W64(_saJ5::I64, 1)) goto cbMc; else goto cbPi;
       cbPi:
           _saJ7::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(1, _saJ7::I64)) goto cbMc; else goto cbPh;
       cbMc:
           R4 = _saJ6::P64;
           R3 = _saJ4::P64;
           R2 = stg_INTLIKE_closure+273;
           Sp = Sp + 72;
           call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
       cbPh:
           _saJ2::I64 = I64[Sp + 24];
           _saJg::I64 = 1 - _saJ5::I64;
           if (%MO_S_Gt_W64(0, _saJg::I64)) goto cbMv; else goto cbPg;
       cbPg:
           if (%MO_S_Ge_W64(_saJg::I64,
                            _saJ2::I64)) goto cbMv; else goto cbME;
       cbMv:
           R3 = _saJg::I64;
           R2 = _saJ2::I64;
           Sp = Sp + 72;
           call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
       cbME:
           _saJo::P64 = P64[P64[Sp + 16] + ((_saJg::I64 << 3) + 24)];
           I64[Sp - 16] = cbMy;
           R1 = _saJo::P64;
           I64[Sp - 8] = _saJ7::I64;
           P64[Sp] = _saJ6::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto cbMy; else goto cbMz;
       cbMz:
           call (I64[R1])(R1) returns to cbMy, args: 8, res: 8, upd: 8;
       cbMy:
           I64[Sp] = cbMD;
           R2 = P64[Sp + 48];
           R1 = P64[R1 + 7];
           call stg_norec_writeTVar#(R2,
                                     R1) returns to cbMD, args: 8, res: 8, upd: 8;
       cbMD:
           _saIm::I64 = I64[Sp + 64];
           _saJu::P64 = P64[Sp + 56];
           _saJt::I64 = 2;
           goto cbMM;
       cbMM:
           if (HpLim == 0) goto cbMP; else goto cbPf;
       cbMP:
           I64[Sp] = cbMN;
           P64[Sp + 48] = _saJu::P64;
           I64[Sp + 56] = _saJt::I64;
           call stg_gc_noregs() returns to cbMN, args: 8, res: 8, upd: 8;
       cbMN:
           _saIm::I64 = I64[Sp + 64];
           _saJt::I64 = I64[Sp + 56];
           _saJu::P64 = P64[Sp + 48];
           goto cbMM;
       cbPf:
           if (%MO_S_Gt_W64(_saJt::I64,
                            _saIm::I64)) goto ubPr; else goto cbMX;
       ubPr:
           Sp = Sp + 32;
           goto cbPm;
       cbPm:
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 56;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
       cbMX:
           I64[Sp] = cbMV;
           R1 = _saJu::P64;
           I64[Sp + 56] = _saJt::I64;
           if (R1 & 7 != 0) goto cbMV; else goto cbMY;
       cbMY:
           call (I64[R1])(R1) returns to cbMV, args: 8, res: 8, upd: 8;
       cbMV:
           if (R1 & 7 != 1) goto cbNj; else goto ubPs;
       cbNj:
           I64[Sp] = cbN7;
           _saJB::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp + 48] = _saJB::P64;
           if (R1 & 7 != 0) goto cbN7; else goto cbN8;
       cbN8:
           call (I64[R1])(R1) returns to cbN7, args: 8, res: 8, upd: 8;
       cbN7:
           I64[Sp - 24] = cbNc;
           _saJE::P64 = P64[R1 + 15];
           _saJG::P64 = P64[R1 + 23];
           _saJF::I64 = I64[R1 + 31];
           R1 = P64[R1 + 7];
           I64[Sp - 16] = _saJF::I64;
           P64[Sp - 8] = _saJG::P64;
           P64[Sp] = _saJE::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto cbNc; else goto cbNd;
       cbNd:
           call (I64[R1])(R1) returns to cbNc, args: 8, res: 8, upd: 8;
       cbNc:
           I64[Sp - 8] = cbNh;
           _saJH::P64 = R1;
           _saJI::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp] = _saJI::I64;
           P64[Sp + 24] = _saJH::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto cbNh; else goto cbNm;
       cbNm:
           call (I64[R1])(R1) returns to cbNh, args: 8, res: 8, upd: 8;
       cbNh:
           Hp = Hp + 16;
           if (Hp > HpLim) goto cbNs; else goto cbNr;
       cbNs:
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to cbNh, args: 8, res: 8, upd: 8;
       cbNr:
           _saJt::I64 = I64[Sp + 88];
           _saJH::P64 = P64[Sp + 32];
           _saJI::I64 = I64[Sp + 8];
           if (%MO_S_Le_W64(_saJI::I64,
                            _saJt::I64)) goto cbPd; else goto cbNA;
       cbPd:
           if (%MO_S_Le_W64(_saJt::I64,
                            I64[R1 + 7])) goto cbPc; else goto cbNJ;
       cbPc:
           _saJF::I64 = I64[Sp + 16];
           _saJT::I64 = _saJt::I64 - _saJI::I64;
           if (%MO_S_Gt_W64(0, _saJT::I64)) goto cbO1; else goto cbPb;
       cbPb:
           if (%MO_S_Ge_W64(_saJT::I64,
                            _saJF::I64)) goto cbO1; else goto cbOc;
       cbO1:
           Hp = Hp - 16;
           R3 = _saJT::I64;
           R2 = _saJF::I64;
           Sp = Sp + 120;
           call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
       cbOc:
           Hp = Hp - 16;
           _saK1::P64 = P64[P64[Sp + 24] + ((_saJT::I64 << 3) + 24)];
           I64[Sp + 32] = cbO4;
           R1 = _saK1::P64;
           Sp = Sp + 32;
           if (R1 & 7 != 0) goto cbO4; else goto cbO5;
       cbO5:
           call (I64[R1])(R1) returns to cbO4, args: 8, res: 8, upd: 8;
       cbO4:
           I64[Sp - 8] = cbO9;
           _saK3::P64 = P64[R1 + 7];
           R1 = _saK3::P64;
           P64[Sp] = _saK3::P64;
           Sp = Sp - 8;
           call stg_norec_readTVar#(R1) returns to cbO9, args: 8, res: 8, upd: 8;
       cbO9:
           I64[Sp] = cbOb;
           R2 = P64[Sp + 80];
           _saK6::P64 = R1;
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _saK6::P64;
           call stg_norec_writeTVar#(R2,
                                     R1) returns to cbOb, args: 8, res: 8, upd: 8;
       cbOb:
           Hp = Hp + 16;
           if (Hp > HpLim) goto cbOk; else goto cbOj;
       cbOk:
           HpAlloc = 16;
           call stg_gc_noregs() returns to cbOb, args: 8, res: 8, upd: 8;
       cbOj:
           _saJ4::P64 = P64[Sp + 88];
           _saJ5::I64 = I64[Sp + 32];
           _saJ6::P64 = P64[Sp + 24];
           _saJt::I64 = I64[Sp + 64];
           if (%MO_S_Le_W64(_saJ5::I64,
                            _saJt::I64)) goto cbPa; else goto cbOs;
       cbPa:
           if (%MO_S_Le_W64(_saJt::I64,
                            I64[Sp + 16])) goto cbP9; else goto cbOB;
       cbP9:
           _saJ2::I64 = I64[Sp + 48];
           _saKg::I64 = _saJt::I64 - _saJ5::I64;
           if (%MO_S_Gt_W64(0, _saKg::I64)) goto cbOT; else goto cbP8;
       cbP8:
           if (%MO_S_Ge_W64(_saKg::I64,
                            _saJ2::I64)) goto cbOT; else goto cbP2;
       cbOT:
           Hp = Hp - 16;
           R3 = _saKg::I64;
           R2 = _saJ2::I64;
           Sp = Sp + 96;
           call lvl29_rawn_info(R3, R2) args: 8, res: 0, upd: 8;
       cbP2:
           Hp = Hp - 16;
           _saKo::P64 = P64[P64[Sp + 40] + ((_saKg::I64 << 3) + 24)];
           I64[Sp] = cbOW;
           R1 = _saKo::P64;
           if (R1 & 7 != 0) goto cbOW; else goto cbOX;
       cbOX:
           call (I64[R1])(R1) returns to cbOW, args: 8, res: 8, upd: 8;
       cbOW:
           _saK6::P64 = P64[Sp + 8];
           I64[Sp + 8] = cbP1;
           R2 = _saK6::P64;
           R1 = P64[R1 + 7];
           Sp = Sp + 8;
           call stg_norec_writeTVar#(R2,
                                     R1) returns to cbP1, args: 8, res: 8, upd: 8;
       cbP1:
           _saIm::I64 = I64[Sp + 64];
           _saJu::P64 = P64[Sp + 48];
           _saJt::I64 = I64[Sp + 56] + 1;
           goto cbMM;
       cbOB:
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saJt::I64;
           R4 = _saJ6::P64;
           R3 = _saJ4::P64;
           R2 = Hp - 7;
           Sp = Sp + 96;
           call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
       cbOs:
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saJt::I64;
           R4 = _saJ6::P64;
           R3 = _saJ4::P64;
           R2 = Hp - 7;
           Sp = Sp + 96;
           call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
       cbNJ:
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saJt::I64;
           R4 = R1;
           R3 = _saJH::P64;
           R2 = Hp - 7;
           Sp = Sp + 120;
           call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
       cbNA:
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _saJt::I64;
           R4 = R1;
           R3 = _saJH::P64;
           R2 = Hp - 7;
           Sp = Sp + 120;
           call lvl30_rawo_info(R4, R3, R2) args: 8, res: 0, upd: 8;
       ubPs:
           Sp = Sp + 56;
           goto cbN4;
       cbN4:
           R1 = lvl40_rawz_closure;
           Sp = Sp + 32;
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:47.58963 UTC

[section "data" {
     SkipList.insert1_closure:
         const SkipList.insert1_info;
         const 0;
 },
 SkipList.insert1_entry() //  [R5, R4, R3, R2]
         { info_tbl: [(cbRo,
                       label: SkipList.insert1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbRo:
           _saKw::P64 = R5;
           _saKv::P64 = R4;
           _saKu::P64 = R3;
           _saKt::P64 = R2;
           goto cbRj;
       cbRj:
           if ((old + 0) - <highSp> < SpLim) goto cbRs; else goto cbRt;
       cbRt:
           goto cbRi;
       cbRi:
           if (HpLim == 0) goto cbRs; else goto cbRu;
       cbRs:
           R5 = _saKw::P64;
           R4 = _saKv::P64;
           R3 = _saKu::P64;
           R2 = _saKt::P64;
           R1 = SkipList.insert1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbRu:
           I64[(young<cbRl> + 8)] = cbRl;
           R1 = _saKu::P64;
           if (R1 & 7 != 0) goto cbRl; else goto cbRm;
       cbRm:
           call (I64[R1])(R1) returns to cbRl, args: 8, res: 8, upd: 8;
       cbRl:
           _saKy::P64 = R1;
           _saKz::P64 = P64[_saKy::P64 + 7];
           _saKA::P64 = P64[_saKy::P64 + 15];
           _saKB::P64 = P64[_saKy::P64 + 23];
           I64[(young<cbRr> + 8)] = cbRr;
           R1 = _saKA::P64;
           if (R1 & 7 != 0) goto cbRr; else goto cbRw;
       cbRw:
           call (I64[R1])(R1) returns to cbRr, args: 8, res: 8, upd: 8;
       cbRr:
           _saKC::P64 = R1;
           _saKD::P64 = P64[_saKC::P64 + 7];
           R6 = _saKv::P64;
           R5 = _saKB::P64;
           R4 = _saKD::P64;
           R3 = _saKz::P64;
           R2 = _saKt::P64;
           P64[(old + 16)] = _saKw::P64;
           call SkipList.$wa4_info(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:47.593508 UTC

{offset
  cbRo:
      _saKw::P64 = R5;
      _saKv::P64 = R4;
      _saKu::P64 = R3;
      _saKt::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cbRs; else goto cbRt;
  cbRt:
      if (HpLim == 0) goto cbRs; else goto cbRu;
  cbRs:
      R5 = _saKw::P64;
      R4 = _saKv::P64;
      R3 = _saKu::P64;
      R2 = _saKt::P64;
      R1 = SkipList.insert1_closure;
      call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  cbRu:
      I64[(young<cbRl> + 8)] = cbRl;
      R1 = _saKu::P64;
      if (R1 & 7 != 0) goto cbRl; else goto cbRm;
  cbRm:
      call (I64[R1])(R1) returns to cbRl, args: 8, res: 8, upd: 8;
  cbRl:
      _saKy::P64 = R1;
      _saKz::P64 = P64[_saKy::P64 + 7];
      _saKA::P64 = P64[_saKy::P64 + 15];
      _saKB::P64 = P64[_saKy::P64 + 23];
      I64[(young<cbRr> + 8)] = cbRr;
      R1 = _saKA::P64;
      if (R1 & 7 != 0) goto cbRr; else goto cbRw;
  cbRw:
      call (I64[R1])(R1) returns to cbRr, args: 8, res: 8, upd: 8;
  cbRr:
      _saKC::P64 = R1;
      _saKD::P64 = P64[_saKC::P64 + 7];
      R6 = _saKv::P64;
      R5 = _saKB::P64;
      R4 = _saKD::P64;
      R3 = _saKz::P64;
      R2 = _saKt::P64;
      P64[(old + 16)] = _saKw::P64;
      call SkipList.$wa4_info(R6,
                              R5,
                              R4,
                              R3,
                              R2) args: 16, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:47.595554 UTC

{offset
  cbRo:
      _saKw::P64 = R5;
      _saKv::P64 = R4;
      _saKu::P64 = R3;
      _saKt::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cbRs; else goto cbRt;
  cbRt:
      if (HpLim == 0) goto cbRs; else goto cbRu;
  cbRs:
      R5 = _saKw::P64;
      R4 = _saKv::P64;
      R3 = _saKu::P64;
      R2 = _saKt::P64;
      R1 = SkipList.insert1_closure;
      call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  cbRu:
      I64[(young<cbRl> + 8)] = cbRl;
      R1 = _saKu::P64;
      if (R1 & 7 != 0) goto cbRl; else goto cbRm;
  cbRm:
      call (I64[R1])(R1) returns to cbRl, args: 8, res: 8, upd: 8;
  cbRl:
      _saKy::P64 = R1;
      _saKz::P64 = P64[_saKy::P64 + 7];
      _saKA::P64 = P64[_saKy::P64 + 15];
      _saKB::P64 = P64[_saKy::P64 + 23];
      I64[(young<cbRr> + 8)] = cbRr;
      R1 = _saKA::P64;
      if (R1 & 7 != 0) goto cbRr; else goto cbRw;
  cbRw:
      call (I64[R1])(R1) returns to cbRr, args: 8, res: 8, upd: 8;
  cbRr:
      _saKC::P64 = R1;
      _saKD::P64 = P64[_saKC::P64 + 7];
      R6 = _saKv::P64;
      R5 = _saKB::P64;
      R4 = _saKD::P64;
      R3 = _saKz::P64;
      R2 = _saKt::P64;
      P64[(old + 16)] = _saKw::P64;
      call SkipList.$wa4_info(R6,
                              R5,
                              R4,
                              R3,
                              R2) args: 16, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:47.597677 UTC

{offset
  cbRo:
      _saKw::P64 = R5;
      _saKv::P64 = R4;
      _saKu::P64 = R3;
      _saKt::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cbRs; else goto cbRt;
  cbRt:
      if (HpLim == 0) goto cbRs; else goto cbRu;
  cbRs:
      R5 = _saKw::P64;
      R4 = _saKv::P64;
      R3 = _saKu::P64;
      R2 = _saKt::P64;
      R1 = SkipList.insert1_closure;
      call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  cbRu:
      I64[(young<cbRl> + 8)] = cbRl;
      R1 = _saKu::P64;
      if (R1 & 7 != 0) goto cbRl; else goto cbRm;
  cbRm:
      call (I64[R1])(R1) returns to cbRl, args: 8, res: 8, upd: 8;
  cbRl:
      _saKy::P64 = R1;
      _saKz::P64 = P64[_saKy::P64 + 7];
      _saKA::P64 = P64[_saKy::P64 + 15];
      _saKB::P64 = P64[_saKy::P64 + 23];
      I64[(young<cbRr> + 8)] = cbRr;
      R1 = _saKA::P64;
      if (R1 & 7 != 0) goto cbRr; else goto cbRw;
  cbRw:
      call (I64[R1])(R1) returns to cbRr, args: 8, res: 8, upd: 8;
  cbRr:
      _saKC::P64 = R1;
      _saKD::P64 = P64[_saKC::P64 + 7];
      R6 = _saKv::P64;
      R5 = _saKB::P64;
      R4 = _saKD::P64;
      R3 = _saKz::P64;
      R2 = _saKt::P64;
      P64[(old + 16)] = _saKw::P64;
      call SkipList.$wa4_info(R6,
                              R5,
                              R4,
                              R3,
                              R2) args: 16, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:47.600021 UTC

{offset
  cbRo:
      _saKw::P64 = R5;
      _saKv::P64 = R4;
      _saKu::P64 = R3;
      _saKt::P64 = R2;
      if ((Sp + 8) - 56 < SpLim) goto cbRs; else goto cbRt;
  cbRt:
      if (HpLim == 0) goto cbRs; else goto cbRu;
  cbRs:
      R5 = _saKw::P64;
      R4 = _saKv::P64;
      R3 = _saKu::P64;
      R2 = _saKt::P64;
      R1 = SkipList.insert1_closure;
      call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  cbRu:
      I64[Sp - 32] = cbRl;
      R1 = _saKu::P64;
      P64[Sp - 24] = _saKt::P64;
      P64[Sp - 16] = _saKv::P64;
      P64[Sp - 8] = _saKw::P64;
      Sp = Sp - 32;
      if (R1 & 7 != 0) goto cbRl; else goto cbRm;
  cbRm:
      call (I64[R1])(R1) returns to cbRl, args: 8, res: 8, upd: 8;
  cbRl:
      _saKt::P64 = P64[Sp + 8];
      _saKv::P64 = P64[Sp + 16];
      _saKw::P64 = P64[Sp + 24];
      _saKy::P64 = R1;
      _saKz::P64 = P64[_saKy::P64 + 7];
      _saKA::P64 = P64[_saKy::P64 + 15];
      _saKB::P64 = P64[_saKy::P64 + 23];
      I64[Sp - 16] = cbRr;
      R1 = _saKA::P64;
      P64[Sp - 8] = _saKB::P64;
      P64[Sp] = _saKz::P64;
      Sp = Sp - 16;
      if (R1 & 7 != 0) goto cbRr; else goto cbRw;
  cbRw:
      call (I64[R1])(R1) returns to cbRr, args: 8, res: 8, upd: 8;
  cbRr:
      _saKt::P64 = P64[Sp + 24];
      _saKv::P64 = P64[Sp + 32];
      _saKw::P64 = P64[Sp + 40];
      _saKz::P64 = P64[Sp + 16];
      _saKB::P64 = P64[Sp + 8];
      _saKC::P64 = R1;
      _saKD::P64 = P64[_saKC::P64 + 7];
      R6 = _saKv::P64;
      R5 = _saKB::P64;
      R4 = _saKD::P64;
      R3 = _saKz::P64;
      R2 = _saKt::P64;
      Sp = Sp + 40;
      call SkipList.$wa4_info(R6,
                              R5,
                              R4,
                              R3,
                              R2) args: 16, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:47.602932 UTC

{offset
  cbRo:
      _saKw::P64 = R5;
      _saKv::P64 = R4;
      _saKu::P64 = R3;
      _saKt::P64 = R2;
      if ((Sp + -48) < SpLim) goto cbRs; else goto cbRt;
  cbRt:
      if (HpLim == 0) goto cbRs; else goto cbRu;
  cbRs:
      R5 = _saKw::P64;
      R4 = _saKv::P64;
      R3 = _saKu::P64;
      R2 = _saKt::P64;
      R1 = SkipList.insert1_closure;
      call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  cbRu:
      I64[Sp - 32] = cbRl;
      R1 = _saKu::P64;
      P64[Sp - 24] = _saKt::P64;
      P64[Sp - 16] = _saKv::P64;
      P64[Sp - 8] = _saKw::P64;
      Sp = Sp - 32;
      if (R1 & 7 != 0) goto cbRl; else goto cbRm;
  cbRm:
      call (I64[R1])(R1) returns to cbRl, args: 8, res: 8, upd: 8;
  cbRl:
      I64[Sp - 16] = cbRr;
      _saKz::P64 = P64[R1 + 7];
      _saKB::P64 = P64[R1 + 23];
      R1 = P64[R1 + 15];
      P64[Sp - 8] = _saKB::P64;
      P64[Sp] = _saKz::P64;
      Sp = Sp - 16;
      if (R1 & 7 != 0) goto cbRr; else goto cbRw;
  cbRw:
      call (I64[R1])(R1) returns to cbRr, args: 8, res: 8, upd: 8;
  cbRr:
      R6 = P64[Sp + 32];
      R5 = P64[Sp + 8];
      R4 = P64[R1 + 7];
      R3 = P64[Sp + 16];
      R2 = P64[Sp + 24];
      Sp = Sp + 40;
      call SkipList.$wa4_info(R6,
                              R5,
                              R4,
                              R3,
                              R2) args: 16, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:47.605516 UTC

[(cbRl, {SkipList.$wa4_closure}), (cbRm, {SkipList.$wa4_closure}),
 (cbRo, {SkipList.insert1_closure, SkipList.$wa4_closure}),
 (cbRr, {SkipList.$wa4_closure}),
 (cbRs, {SkipList.insert1_closure}),
 (cbRt, {SkipList.insert1_closure, SkipList.$wa4_closure}),
 (cbRu, {SkipList.$wa4_closure}), (cbRw, {SkipList.$wa4_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:47.606275 UTC

SkipList.insert1_entry() //  [R5, R4, R3, R2]
        { info_tbl: [(cbRl,
                      label: block_cbRl_info
                      rep:StackRep [False, False, False]),
                     (cbRo,
                      label: SkipList.insert1_info
                      rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} }),
                     (cbRr,
                      label: block_cbRr_info
                      rep:StackRep [False, False, False, False, False])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cbRo:
          _saKw::P64 = R5;
          _saKv::P64 = R4;
          _saKu::P64 = R3;
          _saKt::P64 = R2;
          if ((Sp + -48) < SpLim) goto cbRs; else goto cbRt;
      cbRt:
          if (HpLim == 0) goto cbRs; else goto cbRu;
      cbRs:
          R5 = _saKw::P64;
          R4 = _saKv::P64;
          R3 = _saKu::P64;
          R2 = _saKt::P64;
          R1 = SkipList.insert1_closure;
          call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
      cbRu:
          I64[Sp - 32] = cbRl;
          R1 = _saKu::P64;
          P64[Sp - 24] = _saKt::P64;
          P64[Sp - 16] = _saKv::P64;
          P64[Sp - 8] = _saKw::P64;
          Sp = Sp - 32;
          if (R1 & 7 != 0) goto cbRl; else goto cbRm;
      cbRm:
          call (I64[R1])(R1) returns to cbRl, args: 8, res: 8, upd: 8;
      cbRl:
          I64[Sp - 16] = cbRr;
          _saKz::P64 = P64[R1 + 7];
          _saKB::P64 = P64[R1 + 23];
          R1 = P64[R1 + 15];
          P64[Sp - 8] = _saKB::P64;
          P64[Sp] = _saKz::P64;
          Sp = Sp - 16;
          if (R1 & 7 != 0) goto cbRr; else goto cbRw;
      cbRw:
          call (I64[R1])(R1) returns to cbRr, args: 8, res: 8, upd: 8;
      cbRr:
          R6 = P64[Sp + 32];
          R5 = P64[Sp + 8];
          R4 = P64[R1 + 7];
          R3 = P64[Sp + 16];
          R2 = P64[Sp + 24];
          Sp = Sp + 40;
          call SkipList.$wa4_info(R6,
                                  R5,
                                  R4,
                                  R3,
                                  R2) args: 16, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:47.609177 UTC

SkipList.insert1_entry() //  [R5, R4, R3, R2]
        { info_tbl: [(cbRl,
                      label: block_cbRl_info
                      rep:StackRep [False, False, False]),
                     (cbRo,
                      label: SkipList.insert1_info
                      rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} }),
                     (cbRr,
                      label: block_cbRr_info
                      rep:StackRep [False, False, False, False, False])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cbRo:
          _saKw::P64 = R5;
          _saKv::P64 = R4;
          _saKu::P64 = R3;
          _saKt::P64 = R2;
          if ((Sp + -48) < SpLim) goto cbRs; else goto cbRt;
      cbRt:
          if (HpLim == 0) goto cbRs; else goto cbRu;
      cbRs:
          R5 = _saKw::P64;
          R4 = _saKv::P64;
          R3 = _saKu::P64;
          R2 = _saKt::P64;
          R1 = SkipList.insert1_closure;
          call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
      cbRu:
          I64[Sp - 32] = cbRl;
          R1 = _saKu::P64;
          P64[Sp - 24] = _saKt::P64;
          P64[Sp - 16] = _saKv::P64;
          P64[Sp - 8] = _saKw::P64;
          Sp = Sp - 32;
          if (R1 & 7 != 0) goto cbRl; else goto cbRm;
      cbRm:
          call (I64[R1])(R1) returns to cbRl, args: 8, res: 8, upd: 8;
      cbRl:
          I64[Sp - 16] = cbRr;
          _saKz::P64 = P64[R1 + 7];
          _saKB::P64 = P64[R1 + 23];
          R1 = P64[R1 + 15];
          P64[Sp - 8] = _saKB::P64;
          P64[Sp] = _saKz::P64;
          Sp = Sp - 16;
          if (R1 & 7 != 0) goto cbRr; else goto cbRw;
      cbRw:
          call (I64[R1])(R1) returns to cbRr, args: 8, res: 8, upd: 8;
      cbRr:
          R6 = P64[Sp + 32];
          R5 = P64[Sp + 8];
          R4 = P64[R1 + 7];
          R3 = P64[Sp + 16];
          R2 = P64[Sp + 24];
          Sp = Sp + 40;
          call SkipList.$wa4_info(R6,
                                  R5,
                                  R4,
                                  R3,
                                  R2) args: 16, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:47.61202 UTC

[section "data" {
     SkipList.insert1_closure:
         const SkipList.insert1_info;
         const 0;
 },
 SkipList.insert1_entry() //  [R5, R4, R3, R2]
         { info_tbl: [(cbRl,
                       label: block_cbRl_info
                       rep:StackRep [False, False, False]),
                      (cbRo,
                       label: SkipList.insert1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} }),
                      (cbRr,
                       label: block_cbRr_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbRo:
           _saKw::P64 = R5;
           _saKv::P64 = R4;
           _saKu::P64 = R3;
           _saKt::P64 = R2;
           if ((Sp + -48) < SpLim) goto cbRs; else goto cbRt;
       cbRt:
           if (HpLim == 0) goto cbRs; else goto cbRu;
       cbRs:
           R5 = _saKw::P64;
           R4 = _saKv::P64;
           R3 = _saKu::P64;
           R2 = _saKt::P64;
           R1 = SkipList.insert1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbRu:
           I64[Sp - 32] = cbRl;
           R1 = _saKu::P64;
           P64[Sp - 24] = _saKt::P64;
           P64[Sp - 16] = _saKv::P64;
           P64[Sp - 8] = _saKw::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto cbRl; else goto cbRm;
       cbRm:
           call (I64[R1])(R1) returns to cbRl, args: 8, res: 8, upd: 8;
       cbRl:
           I64[Sp - 16] = cbRr;
           _saKz::P64 = P64[R1 + 7];
           _saKB::P64 = P64[R1 + 23];
           R1 = P64[R1 + 15];
           P64[Sp - 8] = _saKB::P64;
           P64[Sp] = _saKz::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto cbRr; else goto cbRw;
       cbRw:
           call (I64[R1])(R1) returns to cbRr, args: 8, res: 8, upd: 8;
       cbRr:
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 8];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 24];
           Sp = Sp + 40;
           call SkipList.$wa4_info(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:47.615261 UTC

[section "data" {
     SkipList.insert1_closure:
         const SkipList.insert1_info;
         const 0;
 },
 SkipList.insert1_entry() //  [R5, R4, R3, R2]
         { info_tbl: [(cbRl,
                       label: block_cbRl_info
                       rep:StackRep [False, False, False]),
                      (cbRo,
                       label: SkipList.insert1_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} }),
                      (cbRr,
                       label: block_cbRr_info
                       rep:StackRep [False, False, False, False, False])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbRo:
           _saKw::P64 = R5;
           _saKv::P64 = R4;
           _saKu::P64 = R3;
           _saKt::P64 = R2;
           if ((Sp + -48) < SpLim) goto cbRs; else goto cbRt;
       cbRt:
           if (HpLim == 0) goto cbRs; else goto cbRu;
       cbRs:
           R5 = _saKw::P64;
           R4 = _saKv::P64;
           R3 = _saKu::P64;
           R2 = _saKt::P64;
           R1 = SkipList.insert1_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbRu:
           I64[Sp - 32] = cbRl;
           R1 = _saKu::P64;
           P64[Sp - 24] = _saKt::P64;
           P64[Sp - 16] = _saKv::P64;
           P64[Sp - 8] = _saKw::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto cbRl; else goto cbRm;
       cbRm:
           call (I64[R1])(R1) returns to cbRl, args: 8, res: 8, upd: 8;
       cbRl:
           I64[Sp - 16] = cbRr;
           _saKz::P64 = P64[R1 + 7];
           _saKB::P64 = P64[R1 + 23];
           R1 = P64[R1 + 15];
           P64[Sp - 8] = _saKB::P64;
           P64[Sp] = _saKz::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto cbRr; else goto cbRw;
       cbRw:
           call (I64[R1])(R1) returns to cbRr, args: 8, res: 8, upd: 8;
       cbRr:
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 8];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 24];
           Sp = Sp + 40;
           call SkipList.$wa4_info(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 16, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:47.62294 UTC

[section "data" {
     SkipList.insert_closure:
         const SkipList.insert_info;
         const 0;
 },
 SkipList.insert_entry() //  [R5, R4, R3, R2]
         { info_tbl: [(cbRK,
                       label: SkipList.insert_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbRK:
           _B2::P64 = R5;
           _B3::P64 = R4;
           _B4::P64 = R3;
           _B5::P64 = R2;
           goto cbRI;
       cbRI:
           if ((old + 0) - <highSp> < SpLim) goto cbRL; else goto cbRM;
       cbRM:
           goto cbRH;
       cbRH:
           if (HpLim == 0) goto cbRL; else goto cbRN;
       cbRL:
           R5 = _B2::P64;
           R4 = _B3::P64;
           R3 = _B4::P64;
           R2 = _B5::P64;
           R1 = SkipList.insert_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbRN:
           R5 = _B2::P64;
           R4 = _B3::P64;
           R3 = _B4::P64;
           R2 = _B5::P64;
           call SkipList.insert1_info(R5, R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:47.624984 UTC

{offset
  cbRK:
      _B2::P64 = R5;
      _B3::P64 = R4;
      _B4::P64 = R3;
      _B5::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cbRL; else goto cbRM;
  cbRM:
      if (HpLim == 0) goto cbRL; else goto cbRN;
  cbRL:
      R5 = _B2::P64;
      R4 = _B3::P64;
      R3 = _B4::P64;
      R2 = _B5::P64;
      R1 = SkipList.insert_closure;
      call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  cbRN:
      R5 = _B2::P64;
      R4 = _B3::P64;
      R3 = _B4::P64;
      R2 = _B5::P64;
      call SkipList.insert1_info(R5, R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:47.62604 UTC

{offset
  cbRK:
      _B2::P64 = R5;
      _B3::P64 = R4;
      _B4::P64 = R3;
      _B5::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cbRL; else goto cbRM;
  cbRM:
      if (HpLim == 0) goto cbRL; else goto cbRN;
  cbRL:
      R5 = _B2::P64;
      R4 = _B3::P64;
      R3 = _B4::P64;
      R2 = _B5::P64;
      R1 = SkipList.insert_closure;
      call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  cbRN:
      R5 = _B2::P64;
      R4 = _B3::P64;
      R3 = _B4::P64;
      R2 = _B5::P64;
      call SkipList.insert1_info(R5, R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:47.627124 UTC

{offset
  cbRK:
      _B2::P64 = R5;
      _B3::P64 = R4;
      _B4::P64 = R3;
      _B5::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cbRL; else goto cbRM;
  cbRM:
      if (HpLim == 0) goto cbRL; else goto cbRN;
  cbRL:
      R5 = _B2::P64;
      R4 = _B3::P64;
      R3 = _B4::P64;
      R2 = _B5::P64;
      R1 = SkipList.insert_closure;
      call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  cbRN:
      R5 = _B2::P64;
      R4 = _B3::P64;
      R3 = _B4::P64;
      R2 = _B5::P64;
      call SkipList.insert1_info(R5, R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:47.628876 UTC

{offset
  cbRK:
      _B2::P64 = R5;
      _B3::P64 = R4;
      _B4::P64 = R3;
      _B5::P64 = R2;
      goto cbRM;
  cbRM:
      if (HpLim == 0) goto cbRL; else goto cbRN;
  cbRL:
      R5 = _B2::P64;
      R4 = _B3::P64;
      R3 = _B4::P64;
      R2 = _B5::P64;
      R1 = SkipList.insert_closure;
      call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  cbRN:
      R5 = _B2::P64;
      R4 = _B3::P64;
      R3 = _B4::P64;
      R2 = _B5::P64;
      call SkipList.insert1_info(R5, R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:47.62986 UTC

{offset
  cbRK:
      goto cbRM;
  cbRM:
      if (HpLim == 0) goto cbRL; else goto cbRN;
  cbRL:
      R5 = R5;
      R4 = R4;
      R3 = R3;
      R2 = R2;
      R1 = SkipList.insert_closure;
      call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  cbRN:
      R5 = R5;
      R4 = R4;
      R3 = R3;
      R2 = R2;
      call SkipList.insert1_info(R5, R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:47.630924 UTC

[(cbRK, {SkipList.insert1_closure, SkipList.insert_closure}),
 (cbRL, {SkipList.insert_closure}),
 (cbRM, {SkipList.insert1_closure, SkipList.insert_closure}),
 (cbRN, {SkipList.insert1_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:47.63143 UTC

SkipList.insert_entry() //  [R5, R4, R3, R2]
        { info_tbl: [(cbRK,
                      label: SkipList.insert_info
                      rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cbRK:
          goto cbRM;
      cbRM:
          if (HpLim == 0) goto cbRL; else goto cbRN;
      cbRL:
          R5 = R5;
          R4 = R4;
          R3 = R3;
          R2 = R2;
          R1 = SkipList.insert_closure;
          call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
      cbRN:
          R5 = R5;
          R4 = R4;
          R3 = R3;
          R2 = R2;
          call SkipList.insert1_info(R5, R4, R3, R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:47.632591 UTC

SkipList.insert_entry() //  [R5, R4, R3, R2]
        { info_tbl: [(cbRK,
                      label: SkipList.insert_info
                      rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cbRK:
          if (HpLim == 0) goto cbRL; else goto cbRN;
      cbRL:
          R5 = R5;
          R4 = R4;
          R3 = R3;
          R2 = R2;
          R1 = SkipList.insert_closure;
          call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
      cbRN:
          R5 = R5;
          R4 = R4;
          R3 = R3;
          R2 = R2;
          call SkipList.insert1_info(R5, R4, R3, R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:47.633631 UTC

[section "data" {
     SkipList.insert_closure:
         const SkipList.insert_info;
         const 0;
 },
 SkipList.insert_entry() //  [R5, R4, R3, R2]
         { info_tbl: [(cbRK,
                       label: SkipList.insert_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbRK:
           if (HpLim == 0) goto cbRL; else goto cbRN;
       cbRL:
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = SkipList.insert_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbRN:
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call SkipList.insert1_info(R5, R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:47.634896 UTC

[section "data" {
     SkipList.insert_closure:
         const SkipList.insert_info;
         const 0;
 },
 SkipList.insert_entry() //  [R5, R4, R3, R2]
         { info_tbl: [(cbRK,
                       label: SkipList.insert_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbRK:
           if (HpLim == 0) goto cbRL; else goto cbRN;
       cbRL:
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = SkipList.insert_closure;
           call (stg_gc_fun)(R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbRN:
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call SkipList.insert1_info(R5, R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:47.63773 UTC

[section "data" {
     SkipList.Nil_closure:
         const SkipList.Nil_static_info;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:47.638061 UTC

[section "data" {
     SkipList.Nil_closure:
         const SkipList.Nil_static_info;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:47.638354 UTC

[section "data" {
     SkipList.Nil_closure:
         const SkipList.Nil_static_info;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:47.639035 UTC

[section "data" {
     SkipList.Node_closure:
         const SkipList.Node_info;
 },
 SkipList.Node_entry() //  [R4, R3, R2]
         { info_tbl: [(cbRZ,
                       label: SkipList.Node_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbRZ:
           _B1::P64 = R4;
           _B2::P64 = R3;
           _B3::P64 = R2;
           goto cbRW;
       cbRW:
           if ((old + 0) - <highSp> < SpLim) goto cbS0; else goto cbS1;
       cbS1:
           goto cbRV;
       cbRV:
           Hp = Hp + 32;
           if (Hp > HpLim) goto cbS3; else goto cbS2;
       cbS3:
           HpAlloc = 32;
           goto cbS0;
       cbS0:
           R4 = _B1::P64;
           R3 = _B2::P64;
           R2 = _B3::P64;
           R1 = SkipList.Node_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbS2:
           I64[Hp - 24] = SkipList.Node_con_info;
           P64[Hp - 16] = _B3::P64;
           P64[Hp - 8] = _B2::P64;
           P64[Hp] = _B1::P64;
           _cbRY::P64 = Hp - 22;
           R1 = _cbRY::P64;
           call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:47.641318 UTC

{offset
  cbRZ:
      _B1::P64 = R4;
      _B2::P64 = R3;
      _B3::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cbS0; else goto cbS1;
  cbS1:
      Hp = Hp + 32;
      if (Hp > HpLim) goto cbS3; else goto cbS2;
  cbS3:
      HpAlloc = 32;
      goto cbS0;
  cbS0:
      R4 = _B1::P64;
      R3 = _B2::P64;
      R2 = _B3::P64;
      R1 = SkipList.Node_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  cbS2:
      I64[Hp - 24] = SkipList.Node_con_info;
      P64[Hp - 16] = _B3::P64;
      P64[Hp - 8] = _B2::P64;
      P64[Hp] = _B1::P64;
      _cbRY::P64 = Hp - 22;
      R1 = _cbRY::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:47.642575 UTC

{offset
  cbRZ:
      _B1::P64 = R4;
      _B2::P64 = R3;
      _B3::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cbS0; else goto cbS1;
  cbS1:
      Hp = Hp + 32;
      if (Hp > HpLim) goto cbS3; else goto cbS2;
  cbS3:
      HpAlloc = 32;
      goto cbS0;
  cbS0:
      R4 = _B1::P64;
      R3 = _B2::P64;
      R2 = _B3::P64;
      R1 = SkipList.Node_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  cbS2:
      I64[Hp - 24] = SkipList.Node_con_info;
      P64[Hp - 16] = _B3::P64;
      P64[Hp - 8] = _B2::P64;
      P64[Hp] = _B1::P64;
      _cbRY::P64 = Hp - 22;
      R1 = _cbRY::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:47.643822 UTC

{offset
  cbRZ:
      _B1::P64 = R4;
      _B2::P64 = R3;
      _B3::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cbS0; else goto cbS1;
  cbS1:
      Hp = Hp + 32;
      if (Hp > HpLim) goto cbS3; else goto cbS2;
  cbS3:
      HpAlloc = 32;
      goto cbS0;
  cbS0:
      R4 = _B1::P64;
      R3 = _B2::P64;
      R2 = _B3::P64;
      R1 = SkipList.Node_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  cbS2:
      I64[Hp - 24] = SkipList.Node_con_info;
      P64[Hp - 16] = _B3::P64;
      P64[Hp - 8] = _B2::P64;
      P64[Hp] = _B1::P64;
      _cbRY::P64 = Hp - 22;
      R1 = _cbRY::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:47.645109 UTC

{offset
  cbRZ:
      _B1::P64 = R4;
      _B2::P64 = R3;
      _B3::P64 = R2;
      goto cbS1;
  cbS1:
      Hp = Hp + 32;
      if (Hp > HpLim) goto cbS3; else goto cbS2;
  cbS3:
      HpAlloc = 32;
      goto cbS0;
  cbS0:
      R4 = _B1::P64;
      R3 = _B2::P64;
      R2 = _B3::P64;
      R1 = SkipList.Node_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  cbS2:
      I64[Hp - 24] = SkipList.Node_con_info;
      P64[Hp - 16] = _B3::P64;
      P64[Hp - 8] = _B2::P64;
      P64[Hp] = _B1::P64;
      _cbRY::P64 = Hp - 22;
      R1 = _cbRY::P64;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:47.646257 UTC

{offset
  cbRZ:
      goto cbS1;
  cbS1:
      Hp = Hp + 32;
      if (Hp > HpLim) goto cbS3; else goto cbS2;
  cbS3:
      HpAlloc = 32;
      goto cbS0;
  cbS0:
      R4 = R4;
      R3 = R3;
      R2 = R2;
      R1 = SkipList.Node_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  cbS2:
      I64[Hp - 24] = SkipList.Node_con_info;
      P64[Hp - 16] = R2;
      P64[Hp - 8] = R3;
      P64[Hp] = R4;
      R1 = Hp - 22;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:47.647543 UTC

[(cbRZ, {}), (cbS0, {}), (cbS1, {}), (cbS2, {}), (cbS3, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:47.647892 UTC

SkipList.Node_entry() //  [R4, R3, R2]
        { info_tbl: [(cbRZ,
                      label: SkipList.Node_info
                      rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cbRZ:
          goto cbS1;
      cbS1:
          Hp = Hp + 32;
          if (Hp > HpLim) goto cbS3; else goto cbS2;
      cbS3:
          HpAlloc = 32;
          goto cbS0;
      cbS0:
          R4 = R4;
          R3 = R3;
          R2 = R2;
          R1 = SkipList.Node_closure;
          call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
      cbS2:
          I64[Hp - 24] = SkipList.Node_con_info;
          P64[Hp - 16] = R2;
          P64[Hp - 8] = R3;
          P64[Hp] = R4;
          R1 = Hp - 22;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:47.649134 UTC

SkipList.Node_entry() //  [R4, R3, R2]
        { info_tbl: [(cbRZ,
                      label: SkipList.Node_info
                      rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cbRZ:
          Hp = Hp + 32;
          if (Hp > HpLim) goto cbS3; else goto cbS2;
      cbS3:
          HpAlloc = 32;
          R4 = R4;
          R3 = R3;
          R2 = R2;
          R1 = SkipList.Node_closure;
          call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
      cbS2:
          I64[Hp - 24] = SkipList.Node_con_info;
          P64[Hp - 16] = R2;
          P64[Hp - 8] = R3;
          P64[Hp] = R4;
          R1 = Hp - 22;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:47.650323 UTC

[section "data" {
     SkipList.Node_closure:
         const SkipList.Node_info;
 },
 SkipList.Node_entry() //  [R4, R3, R2]
         { info_tbl: [(cbRZ,
                       label: SkipList.Node_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbRZ:
           Hp = Hp + 32;
           if (Hp > HpLim) goto cbS3; else goto cbS2;
       cbS3:
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = SkipList.Node_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbS2:
           I64[Hp - 24] = SkipList.Node_con_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R1 = Hp - 22;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:47.651663 UTC

[section "data" {
     SkipList.Node_closure:
         const SkipList.Node_info;
 },
 SkipList.Node_entry() //  [R4, R3, R2]
         { info_tbl: [(cbRZ,
                       label: SkipList.Node_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbRZ:
           Hp = Hp + 32;
           if (Hp > HpLim) goto cbS3; else goto cbS2;
       cbS3:
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = SkipList.Node_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbS2:
           I64[Hp - 24] = SkipList.Node_con_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R1 = Hp - 22;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:47.655633 UTC

[section "data" {
     SkipList.PQ_closure:
         const SkipList.PQ_info;
 },
 SkipList.PQ_entry() //  [R4, R3, R2]
         { info_tbl: [(cbSd,
                       label: SkipList.PQ_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbSd:
           _B1::P64 = R4;
           _B2::P64 = R3;
           _B3::P64 = R2;
           goto cbSa;
       cbSa:
           if ((old + 0) - <highSp> < SpLim) goto cbSe; else goto cbSf;
       cbSf:
           goto cbS9;
       cbS9:
           Hp = Hp + 32;
           if (Hp > HpLim) goto cbSh; else goto cbSg;
       cbSh:
           HpAlloc = 32;
           goto cbSe;
       cbSe:
           R4 = _B1::P64;
           R3 = _B2::P64;
           R2 = _B3::P64;
           R1 = SkipList.PQ_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbSg:
           I64[Hp - 24] = SkipList.PQ_con_info;
           P64[Hp - 16] = _B3::P64;
           P64[Hp - 8] = _B2::P64;
           P64[Hp] = _B1::P64;
           _cbSc::P64 = Hp - 23;
           R1 = _cbSc::P64;
           call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:47.657942 UTC

{offset
  cbSd:
      _B1::P64 = R4;
      _B2::P64 = R3;
      _B3::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cbSe; else goto cbSf;
  cbSf:
      Hp = Hp + 32;
      if (Hp > HpLim) goto cbSh; else goto cbSg;
  cbSh:
      HpAlloc = 32;
      goto cbSe;
  cbSe:
      R4 = _B1::P64;
      R3 = _B2::P64;
      R2 = _B3::P64;
      R1 = SkipList.PQ_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  cbSg:
      I64[Hp - 24] = SkipList.PQ_con_info;
      P64[Hp - 16] = _B3::P64;
      P64[Hp - 8] = _B2::P64;
      P64[Hp] = _B1::P64;
      _cbSc::P64 = Hp - 23;
      R1 = _cbSc::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:47.659149 UTC

{offset
  cbSd:
      _B1::P64 = R4;
      _B2::P64 = R3;
      _B3::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cbSe; else goto cbSf;
  cbSf:
      Hp = Hp + 32;
      if (Hp > HpLim) goto cbSh; else goto cbSg;
  cbSh:
      HpAlloc = 32;
      goto cbSe;
  cbSe:
      R4 = _B1::P64;
      R3 = _B2::P64;
      R2 = _B3::P64;
      R1 = SkipList.PQ_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  cbSg:
      I64[Hp - 24] = SkipList.PQ_con_info;
      P64[Hp - 16] = _B3::P64;
      P64[Hp - 8] = _B2::P64;
      P64[Hp] = _B1::P64;
      _cbSc::P64 = Hp - 23;
      R1 = _cbSc::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:47.66039 UTC

{offset
  cbSd:
      _B1::P64 = R4;
      _B2::P64 = R3;
      _B3::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cbSe; else goto cbSf;
  cbSf:
      Hp = Hp + 32;
      if (Hp > HpLim) goto cbSh; else goto cbSg;
  cbSh:
      HpAlloc = 32;
      goto cbSe;
  cbSe:
      R4 = _B1::P64;
      R3 = _B2::P64;
      R2 = _B3::P64;
      R1 = SkipList.PQ_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  cbSg:
      I64[Hp - 24] = SkipList.PQ_con_info;
      P64[Hp - 16] = _B3::P64;
      P64[Hp - 8] = _B2::P64;
      P64[Hp] = _B1::P64;
      _cbSc::P64 = Hp - 23;
      R1 = _cbSc::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:47.66167 UTC

{offset
  cbSd:
      _B1::P64 = R4;
      _B2::P64 = R3;
      _B3::P64 = R2;
      goto cbSf;
  cbSf:
      Hp = Hp + 32;
      if (Hp > HpLim) goto cbSh; else goto cbSg;
  cbSh:
      HpAlloc = 32;
      goto cbSe;
  cbSe:
      R4 = _B1::P64;
      R3 = _B2::P64;
      R2 = _B3::P64;
      R1 = SkipList.PQ_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  cbSg:
      I64[Hp - 24] = SkipList.PQ_con_info;
      P64[Hp - 16] = _B3::P64;
      P64[Hp - 8] = _B2::P64;
      P64[Hp] = _B1::P64;
      _cbSc::P64 = Hp - 23;
      R1 = _cbSc::P64;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:47.662838 UTC

{offset
  cbSd:
      goto cbSf;
  cbSf:
      Hp = Hp + 32;
      if (Hp > HpLim) goto cbSh; else goto cbSg;
  cbSh:
      HpAlloc = 32;
      goto cbSe;
  cbSe:
      R4 = R4;
      R3 = R3;
      R2 = R2;
      R1 = SkipList.PQ_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  cbSg:
      I64[Hp - 24] = SkipList.PQ_con_info;
      P64[Hp - 16] = R2;
      P64[Hp - 8] = R3;
      P64[Hp] = R4;
      R1 = Hp - 23;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:47.664086 UTC

[(cbSd, {}), (cbSe, {}), (cbSf, {}), (cbSg, {}), (cbSh, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:47.664429 UTC

SkipList.PQ_entry() //  [R4, R3, R2]
        { info_tbl: [(cbSd,
                      label: SkipList.PQ_info
                      rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cbSd:
          goto cbSf;
      cbSf:
          Hp = Hp + 32;
          if (Hp > HpLim) goto cbSh; else goto cbSg;
      cbSh:
          HpAlloc = 32;
          goto cbSe;
      cbSe:
          R4 = R4;
          R3 = R3;
          R2 = R2;
          R1 = SkipList.PQ_closure;
          call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
      cbSg:
          I64[Hp - 24] = SkipList.PQ_con_info;
          P64[Hp - 16] = R2;
          P64[Hp - 8] = R3;
          P64[Hp] = R4;
          R1 = Hp - 23;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:47.665674 UTC

SkipList.PQ_entry() //  [R4, R3, R2]
        { info_tbl: [(cbSd,
                      label: SkipList.PQ_info
                      rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cbSd:
          Hp = Hp + 32;
          if (Hp > HpLim) goto cbSh; else goto cbSg;
      cbSh:
          HpAlloc = 32;
          R4 = R4;
          R3 = R3;
          R2 = R2;
          R1 = SkipList.PQ_closure;
          call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
      cbSg:
          I64[Hp - 24] = SkipList.PQ_con_info;
          P64[Hp - 16] = R2;
          P64[Hp - 8] = R3;
          P64[Hp] = R4;
          R1 = Hp - 23;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:47.666873 UTC

[section "data" {
     SkipList.PQ_closure:
         const SkipList.PQ_info;
 },
 SkipList.PQ_entry() //  [R4, R3, R2]
         { info_tbl: [(cbSd,
                       label: SkipList.PQ_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbSd:
           Hp = Hp + 32;
           if (Hp > HpLim) goto cbSh; else goto cbSg;
       cbSh:
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = SkipList.PQ_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbSg:
           I64[Hp - 24] = SkipList.PQ_con_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R1 = Hp - 23;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:47.668229 UTC

[section "data" {
     SkipList.PQ_closure:
         const SkipList.PQ_info;
 },
 SkipList.PQ_entry() //  [R4, R3, R2]
         { info_tbl: [(cbSd,
                       label: SkipList.PQ_info
                       rep:HeapRep static { Fun {arity: 3 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbSd:
           Hp = Hp + 32;
           if (Hp > HpLim) goto cbSh; else goto cbSg;
       cbSh:
           HpAlloc = 32;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = SkipList.PQ_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       cbSg:
           I64[Hp - 24] = SkipList.PQ_con_info;
           P64[Hp - 16] = R2;
           P64[Hp - 8] = R3;
           P64[Hp] = R4;
           R1 = Hp - 23;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:47.671463 UTC

[SkipList.Nil_static_entry() //  []
         { info_tbl: [(cbSm,
                       label: SkipList.Nil_static_info
                       rep:HeapRep static {
                             Con {tag: 0
                                  descr:[109,97,105,110,58,83,107,105,112,76,105,115,116,46,78,105,108]} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbSm:
           R1 = R1 + 1;
           call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:47.672262 UTC

{offset
  cbSm:
      R1 = R1 + 1;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:47.672728 UTC

{offset
  cbSm:
      R1 = R1 + 1;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:47.673089 UTC

{offset
  cbSm:
      R1 = R1 + 1;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:47.673442 UTC

{offset
  cbSm:
      R1 = R1 + 1;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:47.67377 UTC

{offset
  cbSm:
      R1 = R1 + 1;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:47.674092 UTC

[(cbSm, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:47.674312 UTC

SkipList.Nil_static_entry() //  []
        { info_tbl: [(cbSm,
                      label: SkipList.Nil_static_info
                      rep:HeapRep static {
                            Con {tag: 0
                                 descr:[109,97,105,110,58,83,107,105,112,76,105,115,116,46,78,105,108]} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cbSm:
          R1 = R1 + 1;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:47.674923 UTC

SkipList.Nil_static_entry() //  []
        { info_tbl: [(cbSm,
                      label: SkipList.Nil_static_info
                      rep:HeapRep static {
                            Con {tag: 0
                                 descr:[109,97,105,110,58,83,107,105,112,76,105,115,116,46,78,105,108]} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cbSm:
          R1 = R1 + 1;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:47.675532 UTC

[SkipList.Nil_static_entry() //  []
         { info_tbl: [(cbSm,
                       label: SkipList.Nil_static_info
                       rep:HeapRep static {
                             Con {tag: 0
                                  descr:[109,97,105,110,58,83,107,105,112,76,105,115,116,46,78,105,108]} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbSm:
           R1 = R1 + 1;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:47.676207 UTC

[SkipList.Nil_static_entry() //  []
         { info_tbl: [(cbSm,
                       label: SkipList.Nil_static_info
                       rep:HeapRep static {
                             Con {tag: 0
                                  descr:[109,97,105,110,58,83,107,105,112,76,105,115,116,46,78,105,108]} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbSm:
           R1 = R1 + 1;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:47.678394 UTC

[SkipList.Node_con_entry() //  []
         { info_tbl: [(cbSr,
                       label: SkipList.Node_con_info
                       rep:HeapRep 3 ptrs {
                             Con {tag: 1
                                  descr:[109,97,105,110,58,83,107,105,112,76,105,115,116,46,78,111,100,101]} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbSr:
           R1 = R1 + 2;
           call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
     }
 },
 SkipList.Node_static_entry() //  []
         { info_tbl: [(cbSs,
                       label: SkipList.Node_static_info
                       rep:HeapRep static {
                             Con {tag: 1
                                  descr:[109,97,105,110,58,83,107,105,112,76,105,115,116,46,78,111,100,101]} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbSs:
           R1 = R1 + 2;
           call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:47.679774 UTC

{offset
  cbSr:
      R1 = R1 + 2;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:47.680133 UTC

{offset
  cbSr:
      R1 = R1 + 2;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:47.680494 UTC

{offset
  cbSr:
      R1 = R1 + 2;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:47.680853 UTC

{offset
  cbSr:
      R1 = R1 + 2;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:47.681187 UTC

{offset
  cbSr:
      R1 = R1 + 2;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:47.681514 UTC

[(cbSr, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:47.681737 UTC

SkipList.Node_con_entry() //  []
        { info_tbl: [(cbSr,
                      label: SkipList.Node_con_info
                      rep:HeapRep 3 ptrs {
                            Con {tag: 1
                                 descr:[109,97,105,110,58,83,107,105,112,76,105,115,116,46,78,111,100,101]} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cbSr:
          R1 = R1 + 2;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:47.682361 UTC

SkipList.Node_con_entry() //  []
        { info_tbl: [(cbSr,
                      label: SkipList.Node_con_info
                      rep:HeapRep 3 ptrs {
                            Con {tag: 1
                                 descr:[109,97,105,110,58,83,107,105,112,76,105,115,116,46,78,111,100,101]} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cbSr:
          R1 = R1 + 2;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:47.683012 UTC

{offset
  cbSs:
      R1 = R1 + 2;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:47.683357 UTC

{offset
  cbSs:
      R1 = R1 + 2;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:47.683702 UTC

{offset
  cbSs:
      R1 = R1 + 2;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:47.684048 UTC

{offset
  cbSs:
      R1 = R1 + 2;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:47.684379 UTC

{offset
  cbSs:
      R1 = R1 + 2;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:47.684705 UTC

[(cbSs, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:47.684916 UTC

SkipList.Node_static_entry() //  []
        { info_tbl: [(cbSs,
                      label: SkipList.Node_static_info
                      rep:HeapRep static {
                            Con {tag: 1
                                 descr:[109,97,105,110,58,83,107,105,112,76,105,115,116,46,78,111,100,101]} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cbSs:
          R1 = R1 + 2;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:47.685519 UTC

SkipList.Node_static_entry() //  []
        { info_tbl: [(cbSs,
                      label: SkipList.Node_static_info
                      rep:HeapRep static {
                            Con {tag: 1
                                 descr:[109,97,105,110,58,83,107,105,112,76,105,115,116,46,78,111,100,101]} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cbSs:
          R1 = R1 + 2;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:47.686137 UTC

[SkipList.Node_con_entry() //  []
         { info_tbl: [(cbSr,
                       label: SkipList.Node_con_info
                       rep:HeapRep 3 ptrs {
                             Con {tag: 1
                                  descr:[109,97,105,110,58,83,107,105,112,76,105,115,116,46,78,111,100,101]} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbSr:
           R1 = R1 + 2;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 },
 SkipList.Node_static_entry() //  []
         { info_tbl: [(cbSs,
                       label: SkipList.Node_static_info
                       rep:HeapRep static {
                             Con {tag: 1
                                  descr:[109,97,105,110,58,83,107,105,112,76,105,115,116,46,78,111,100,101]} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbSs:
           R1 = R1 + 2;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:47.687374 UTC

[SkipList.Node_con_entry() //  []
         { info_tbl: [(cbSr,
                       label: SkipList.Node_con_info
                       rep:HeapRep 3 ptrs {
                             Con {tag: 1
                                  descr:[109,97,105,110,58,83,107,105,112,76,105,115,116,46,78,111,100,101]} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbSr:
           R1 = R1 + 2;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 },
 SkipList.Node_static_entry() //  []
         { info_tbl: [(cbSs,
                       label: SkipList.Node_static_info
                       rep:HeapRep static {
                             Con {tag: 1
                                  descr:[109,97,105,110,58,83,107,105,112,76,105,115,116,46,78,111,100,101]} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbSs:
           R1 = R1 + 2;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:47.690484 UTC

[SkipList.PQ_con_entry() //  []
         { info_tbl: [(cbSB,
                       label: SkipList.PQ_con_info
                       rep:HeapRep 3 ptrs {
                             Con {tag: 0
                                  descr:[109,97,105,110,58,83,107,105,112,76,105,115,116,46,80,81]} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbSB:
           R1 = R1 + 1;
           call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
     }
 },
 SkipList.PQ_static_entry() //  []
         { info_tbl: [(cbSC,
                       label: SkipList.PQ_static_info
                       rep:HeapRep static {
                             Con {tag: 0
                                  descr:[109,97,105,110,58,83,107,105,112,76,105,115,116,46,80,81]} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbSC:
           R1 = R1 + 1;
           call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:47.691888 UTC

{offset
  cbSB:
      R1 = R1 + 1;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:47.692746 UTC

{offset
  cbSB:
      R1 = R1 + 1;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:47.693232 UTC

{offset
  cbSB:
      R1 = R1 + 1;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:47.693585 UTC

{offset
  cbSB:
      R1 = R1 + 1;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:47.693913 UTC

{offset
  cbSB:
      R1 = R1 + 1;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:47.694233 UTC

[(cbSB, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:47.694451 UTC

SkipList.PQ_con_entry() //  []
        { info_tbl: [(cbSB,
                      label: SkipList.PQ_con_info
                      rep:HeapRep 3 ptrs {
                            Con {tag: 0
                                 descr:[109,97,105,110,58,83,107,105,112,76,105,115,116,46,80,81]} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cbSB:
          R1 = R1 + 1;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:47.69505 UTC

SkipList.PQ_con_entry() //  []
        { info_tbl: [(cbSB,
                      label: SkipList.PQ_con_info
                      rep:HeapRep 3 ptrs {
                            Con {tag: 0
                                 descr:[109,97,105,110,58,83,107,105,112,76,105,115,116,46,80,81]} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cbSB:
          R1 = R1 + 1;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:47.695675 UTC

{offset
  cbSC:
      R1 = R1 + 1;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:47.69601 UTC

{offset
  cbSC:
      R1 = R1 + 1;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:47.696348 UTC

{offset
  cbSC:
      R1 = R1 + 1;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:47.696687 UTC

{offset
  cbSC:
      R1 = R1 + 1;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:47.697022 UTC

{offset
  cbSC:
      R1 = R1 + 1;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:47.697341 UTC

[(cbSC, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:47.697546 UTC

SkipList.PQ_static_entry() //  []
        { info_tbl: [(cbSC,
                      label: SkipList.PQ_static_info
                      rep:HeapRep static {
                            Con {tag: 0
                                 descr:[109,97,105,110,58,83,107,105,112,76,105,115,116,46,80,81]} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cbSC:
          R1 = R1 + 1;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:47.698124 UTC

SkipList.PQ_static_entry() //  []
        { info_tbl: [(cbSC,
                      label: SkipList.PQ_static_info
                      rep:HeapRep static {
                            Con {tag: 0
                                 descr:[109,97,105,110,58,83,107,105,112,76,105,115,116,46,80,81]} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cbSC:
          R1 = R1 + 1;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:47.69872 UTC

[SkipList.PQ_con_entry() //  []
         { info_tbl: [(cbSB,
                       label: SkipList.PQ_con_info
                       rep:HeapRep 3 ptrs {
                             Con {tag: 0
                                  descr:[109,97,105,110,58,83,107,105,112,76,105,115,116,46,80,81]} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbSB:
           R1 = R1 + 1;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 },
 SkipList.PQ_static_entry() //  []
         { info_tbl: [(cbSC,
                       label: SkipList.PQ_static_info
                       rep:HeapRep static {
                             Con {tag: 0
                                  descr:[109,97,105,110,58,83,107,105,112,76,105,115,116,46,80,81]} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbSC:
           R1 = R1 + 1;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:47.699899 UTC

[SkipList.PQ_con_entry() //  []
         { info_tbl: [(cbSB,
                       label: SkipList.PQ_con_info
                       rep:HeapRep 3 ptrs {
                             Con {tag: 0
                                  descr:[109,97,105,110,58,83,107,105,112,76,105,115,116,46,80,81]} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbSB:
           R1 = R1 + 1;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 },
 SkipList.PQ_static_entry() //  []
         { info_tbl: [(cbSC,
                       label: SkipList.PQ_static_info
                       rep:HeapRep static {
                             Con {tag: 0
                                  descr:[109,97,105,110,58,83,107,105,112,76,105,115,116,46,80,81]} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cbSC:
           R1 = R1 + 1;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:47.702893 UTC

[section "relreadonly" {
     SaM6_srt:
         const Data.Vector.Internal.Check.checkError_closure;
         const SkipList.newSL8_closure;
         const lvl_ravL_closure;
         const Data.Vector.Internal.Check.checkIndex_msg#_closure;
         const lvl5_ravU_closure;
         const Control.Exception.Base.recSelError_closure;
         const SkipList._getNodes1_closure;
         const SkipList._getNodes_closure;
         const SkipList._getVal1_closure;
         const SkipList._getVal_closure;
         const SkipList._getKey1_closure;
         const SkipList._getKey_closure;
         const GHC.Err.error_closure;
         const lvl17_rawb_closure;
         const lvl18_rawc_closure;
         const GHC.Arr.negRange_closure;
         const Data.Array.Base.arrEleBottom_closure;
         const SkipList.$fMArrayTArrayeSTM5_closure;
         const SkipList.$fMArrayTArrayeSTM4_closure;
         const SkipList.$fMArrayTArrayeSTM_$cnewArray_closure;
         const SkipList.$fMArrayTArrayeSTM9_closure;
         const SkipList.$fMArrayTArrayeSTM8_closure;
         const SkipList.$fMArrayTArrayeSTM_$cnewArray__closure;
         const SkipList.$fMArrayTArrayeSTM_closure;
         const SkipList.$fMArrayTArrayeSTM_$cunsafeNewArray__closure;
         const GHC.Arr.indexError_closure;
         const lvl19_rawd_closure;
         const lvl20_rawe_closure;
         const lvl28_rawm_closure;
         const lvl27_rawl_closure;
         const lvl29_rawn_closure;
         const SkipList.$wa3_closure;
         const SkipList.get1_closure;
         const SkipList.get_closure;
         const lvl30_rawo_closure;
         const $s$wpoly_a_rawp_closure;
         const SkipList.$wa2_closure;
         const SkipList.delete1_closure;
         const SkipList.delete_closure;
         const lvl2_ravN_closure;
         const SkipList.newSL8_closure;
         const Data.Vector.Internal.Check.checkError_closure;
         const SkipList.newSL5_closure;
         const System.Random.PCG.Class.sysRandom2_closure;
         const System.Random.PCG.Class.sysRandom10_closure;
         const SkipList.newSL4_closure;
         const SkipList.newSL6_closure;
         const SkipList.newSL3_closure;
         const SkipList.newSL2_closure;
         const GHC.Arr.$fIxInt_closure;
         const SkipList.newSL1_closure;
         const SkipList.newSL_closure;
         const lvl38_rawx_closure;
         const lvl39_rawy_closure;
         const GHC.Err.error_closure;
         const lvl5_ravU_closure;
         const logHalf_r2BC_closure;
         const lvl40_rawz_closure;
         const SkipList.$wa4_closure;
         const SkipList.insert1_closure;
         const SkipList.insert_closure;
 }]

