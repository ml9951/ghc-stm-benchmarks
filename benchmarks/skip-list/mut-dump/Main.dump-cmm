
==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.053537 UTC

[section "data" { __stginit_main@main:Main:
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.053938 UTC

[section "data" { __stginit_main@main:Main:
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.054184 UTC

[section "data" { __stginit_main@main:Main:
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.066983 UTC

[section "data" {
     Main.rbTreeOpts46_closure:
         const GHC.Base.Just_static_info;
         const GHC.Types.False_closure+1;
         const 3;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.067549 UTC

[section "data" {
     Main.rbTreeOpts46_closure:
         const GHC.Base.Just_static_info;
         const GHC.Types.False_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.067907 UTC

[section "data" {
     Main.rbTreeOpts46_closure:
         const GHC.Base.Just_static_info;
         const GHC.Types.False_closure+1;
         const 3;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.068681 UTC

[section "data" {
     Main.rbTreeOpts45_closure:
         const Options.Applicative.Types.NilP_static_info;
         const Main.rbTreeOpts46_closure+2;
         const 3;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.069108 UTC

[section "data" {
     Main.rbTreeOpts45_closure:
         const Options.Applicative.Types.NilP_static_info;
         const Main.rbTreeOpts46_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.069462 UTC

[section "data" {
     Main.rbTreeOpts45_closure:
         const Options.Applicative.Types.NilP_static_info;
         const Main.rbTreeOpts46_closure+2;
         const 3;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.070146 UTC

[section "data" {
     Main.rbTreeOpts55_closure:
         const Main.rbTreeOpts55_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ck7M_str:
         I8[] [119,105,116,104,111,117,116,84,77]
 },
 Main.rbTreeOpts55_entry() //  [R1]
         { info_tbl: [(ck7N,
                       label: Main.rbTreeOpts55_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ck7N:
           _rbSY::P64 = R1;
           goto ck7H;
       ck7H:
           if ((old + 0) - <highSp> < SpLim) goto ck7O; else goto ck7P;
       ck7P:
           if (HpLim == 0) goto ck7O; else goto ck7Q;
       ck7O:
           R1 = _rbSY::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ck7Q:
           (_ck7J::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbSY::P64);
           if (_ck7J::I64 == 0) goto ck7L; else goto ck7K;
       ck7L:
           call (I64[_rbSY::P64])() args: 8, res: 0, upd: 8;
       ck7K:
           I64[(old + 24)] = stg_bh_upd_frame_info;
           I64[(old + 16)] = _ck7J::I64;
           R2 = ck7M_str;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.072371 UTC

{offset
  ck7N:
      _rbSY::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ck7O; else goto ck7P;
  ck7P:
      if (HpLim == 0) goto ck7O; else goto ck7Q;
  ck7O:
      R1 = _rbSY::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ck7Q:
      (_ck7J::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbSY::P64);
      if (_ck7J::I64 == 0) goto ck7L; else goto ck7K;
  ck7L:
      call (I64[_rbSY::P64])() args: 8, res: 0, upd: 8;
  ck7K:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ck7J::I64;
      R2 = ck7M_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:52.073495 UTC

{offset
  ck7N:
      _rbSY::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ck7O; else goto ck7P;
  ck7P:
      if (HpLim == 0) goto ck7O; else goto ck7Q;
  ck7O:
      R1 = _rbSY::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ck7Q:
      (_ck7J::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbSY::P64);
      if (_ck7J::I64 == 0) goto ck7L; else goto ck7K;
  ck7L:
      call (I64[_rbSY::P64])() args: 8, res: 0, upd: 8;
  ck7K:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ck7J::I64;
      R2 = ck7M_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:52.074619 UTC

{offset
  ck7N:
      _rbSY::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ck7O; else goto ck7P;
  ck7P:
      if (HpLim == 0) goto ck7O; else goto ck7Q;
  ck7O:
      R1 = _rbSY::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ck7Q:
      (_ck7J::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbSY::P64);
      if (_ck7J::I64 == 0) goto ck7L; else goto ck7K;
  ck7L:
      call (I64[_rbSY::P64])() args: 8, res: 0, upd: 8;
  ck7K:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ck7J::I64;
      R2 = ck7M_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:52.075793 UTC

{offset
  ck7N:
      _rbSY::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto ck7O; else goto ck7P;
  ck7P:
      if (HpLim == 0) goto ck7O; else goto ck7Q;
  ck7O:
      R1 = _rbSY::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ck7Q:
      (_ck7J::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbSY::P64);
      if (_ck7J::I64 == 0) goto ck7L; else goto ck7K;
  ck7L:
      call (I64[_rbSY::P64])() args: 8, res: 0, upd: 8;
  ck7K:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _ck7J::I64;
      R2 = ck7M_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:52.076942 UTC

{offset
  ck7N:
      _rbSY::P64 = R1;
      if ((Sp + -16) < SpLim) goto ck7O; else goto ck7P;
  ck7P:
      if (HpLim == 0) goto ck7O; else goto ck7Q;
  ck7O:
      R1 = _rbSY::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ck7Q:
      (_ck7J::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbSY::P64);
      if (_ck7J::I64 == 0) goto ck7L; else goto ck7K;
  ck7L:
      call (I64[_rbSY::P64])() args: 8, res: 0, upd: 8;
  ck7K:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _ck7J::I64;
      R2 = ck7M_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:52.078255 UTC

[(ck7K, {}), (ck7L, {}), (ck7N, {}), (ck7O, {}), (ck7P, {}),
 (ck7Q, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:52.07864 UTC

Main.rbTreeOpts55_entry() //  [R1]
        { info_tbl: [(ck7N,
                      label: Main.rbTreeOpts55_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ck7N:
          _rbSY::P64 = R1;
          if ((Sp + -16) < SpLim) goto ck7O; else goto ck7P;
      ck7P:
          if (HpLim == 0) goto ck7O; else goto ck7Q;
      ck7O:
          R1 = _rbSY::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ck7Q:
          (_ck7J::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbSY::P64);
          if (_ck7J::I64 == 0) goto ck7L; else goto ck7K;
      ck7L:
          call (I64[_rbSY::P64])() args: 8, res: 0, upd: 8;
      ck7K:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _ck7J::I64;
          R2 = ck7M_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.08004 UTC

Main.rbTreeOpts55_entry() //  [R1]
        { info_tbl: [(ck7N,
                      label: Main.rbTreeOpts55_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ck7N:
          _rbSY::P64 = R1;
          if ((Sp + -16) < SpLim) goto ck7O; else goto ck7P;
      ck7P:
          if (HpLim == 0) goto ck7O; else goto ck7Q;
      ck7O:
          R1 = _rbSY::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ck7Q:
          (_ck7J::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbSY::P64);
          if (_ck7J::I64 == 0) goto ck7L; else goto ck7K;
      ck7L:
          call (I64[_rbSY::P64])() args: 8, res: 0, upd: 8;
      ck7K:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _ck7J::I64;
          R2 = ck7M_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.081433 UTC

[section "data" {
     Main.rbTreeOpts55_closure:
         const Main.rbTreeOpts55_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ck7M_str:
         I8[] [119,105,116,104,111,117,116,84,77]
 },
 Main.rbTreeOpts55_entry() //  [R1]
         { info_tbl: [(ck7N,
                       label: Main.rbTreeOpts55_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ck7N:
           _rbSY::P64 = R1;
           if ((Sp + -16) < SpLim) goto ck7O; else goto ck7P;
       ck7P:
           if (HpLim == 0) goto ck7O; else goto ck7Q;
       ck7O:
           R1 = _rbSY::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ck7Q:
           (_ck7J::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbSY::P64);
           if (_ck7J::I64 == 0) goto ck7L; else goto ck7K;
       ck7L:
           call (I64[_rbSY::P64])() args: 8, res: 0, upd: 8;
       ck7K:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ck7J::I64;
           R2 = ck7M_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.083141 UTC

[section "data" {
     Main.rbTreeOpts55_closure:
         const Main.rbTreeOpts55_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ck7M_str:
         I8[] [119,105,116,104,111,117,116,84,77]
 },
 Main.rbTreeOpts55_entry() //  [R1]
         { info_tbl: [(ck7N,
                       label: Main.rbTreeOpts55_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ck7N:
           _rbSY::P64 = R1;
           if ((Sp + -16) < SpLim) goto ck7O; else goto ck7P;
       ck7P:
           if (HpLim == 0) goto ck7O; else goto ck7Q;
       ck7O:
           R1 = _rbSY::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ck7Q:
           (_ck7J::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbSY::P64);
           if (_ck7J::I64 == 0) goto ck7L; else goto ck7K;
       ck7L:
           call (I64[_rbSY::P64])() args: 8, res: 0, upd: 8;
       ck7K:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ck7J::I64;
           R2 = ck7M_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.090791 UTC

[section "data" {
     Main.rbTreeOpts_n6_closure:
         const Options.Applicative.Types.OptLong_static_info;
         const Main.rbTreeOpts55_closure;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.091278 UTC

[section "data" {
     Main.rbTreeOpts_n6_closure:
         const Options.Applicative.Types.OptLong_static_info;
         const Main.rbTreeOpts55_closure;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.091621 UTC

[section "data" {
     Main.rbTreeOpts_n6_closure:
         const Options.Applicative.Types.OptLong_static_info;
         const Main.rbTreeOpts55_closure;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.092328 UTC

[section "data" {
     Main.rbTreeOpts51_closure:
         const Main.rbTreeOpts51_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ck85_str:
         I8[] [78,111,32,116,114,97,110,115,97,99,116,105,111,110,115]
 },
 Main.rbTreeOpts51_entry() //  [R1]
         { info_tbl: [(ck86,
                       label: Main.rbTreeOpts51_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ck86:
           _rbT9::P64 = R1;
           goto ck80;
       ck80:
           if ((old + 0) - <highSp> < SpLim) goto ck87; else goto ck88;
       ck88:
           if (HpLim == 0) goto ck87; else goto ck89;
       ck87:
           R1 = _rbT9::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ck89:
           (_ck82::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT9::P64);
           if (_ck82::I64 == 0) goto ck84; else goto ck83;
       ck84:
           call (I64[_rbT9::P64])() args: 8, res: 0, upd: 8;
       ck83:
           I64[(old + 24)] = stg_bh_upd_frame_info;
           I64[(old + 16)] = _ck82::I64;
           R2 = ck85_str;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.094432 UTC

{offset
  ck86:
      _rbT9::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ck87; else goto ck88;
  ck88:
      if (HpLim == 0) goto ck87; else goto ck89;
  ck87:
      R1 = _rbT9::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ck89:
      (_ck82::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT9::P64);
      if (_ck82::I64 == 0) goto ck84; else goto ck83;
  ck84:
      call (I64[_rbT9::P64])() args: 8, res: 0, upd: 8;
  ck83:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ck82::I64;
      R2 = ck85_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:52.095547 UTC

{offset
  ck86:
      _rbT9::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ck87; else goto ck88;
  ck88:
      if (HpLim == 0) goto ck87; else goto ck89;
  ck87:
      R1 = _rbT9::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ck89:
      (_ck82::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT9::P64);
      if (_ck82::I64 == 0) goto ck84; else goto ck83;
  ck84:
      call (I64[_rbT9::P64])() args: 8, res: 0, upd: 8;
  ck83:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ck82::I64;
      R2 = ck85_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:52.096688 UTC

{offset
  ck86:
      _rbT9::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ck87; else goto ck88;
  ck88:
      if (HpLim == 0) goto ck87; else goto ck89;
  ck87:
      R1 = _rbT9::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ck89:
      (_ck82::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT9::P64);
      if (_ck82::I64 == 0) goto ck84; else goto ck83;
  ck84:
      call (I64[_rbT9::P64])() args: 8, res: 0, upd: 8;
  ck83:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ck82::I64;
      R2 = ck85_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:52.097857 UTC

{offset
  ck86:
      _rbT9::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto ck87; else goto ck88;
  ck88:
      if (HpLim == 0) goto ck87; else goto ck89;
  ck87:
      R1 = _rbT9::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ck89:
      (_ck82::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT9::P64);
      if (_ck82::I64 == 0) goto ck84; else goto ck83;
  ck84:
      call (I64[_rbT9::P64])() args: 8, res: 0, upd: 8;
  ck83:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _ck82::I64;
      R2 = ck85_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:52.099 UTC

{offset
  ck86:
      _rbT9::P64 = R1;
      if ((Sp + -16) < SpLim) goto ck87; else goto ck88;
  ck88:
      if (HpLim == 0) goto ck87; else goto ck89;
  ck87:
      R1 = _rbT9::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ck89:
      (_ck82::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT9::P64);
      if (_ck82::I64 == 0) goto ck84; else goto ck83;
  ck84:
      call (I64[_rbT9::P64])() args: 8, res: 0, upd: 8;
  ck83:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _ck82::I64;
      R2 = ck85_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:52.10037 UTC

[(ck83, {}), (ck84, {}), (ck86, {}), (ck87, {}), (ck88, {}),
 (ck89, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:52.100746 UTC

Main.rbTreeOpts51_entry() //  [R1]
        { info_tbl: [(ck86,
                      label: Main.rbTreeOpts51_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ck86:
          _rbT9::P64 = R1;
          if ((Sp + -16) < SpLim) goto ck87; else goto ck88;
      ck88:
          if (HpLim == 0) goto ck87; else goto ck89;
      ck87:
          R1 = _rbT9::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ck89:
          (_ck82::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT9::P64);
          if (_ck82::I64 == 0) goto ck84; else goto ck83;
      ck84:
          call (I64[_rbT9::P64])() args: 8, res: 0, upd: 8;
      ck83:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _ck82::I64;
          R2 = ck85_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.102085 UTC

Main.rbTreeOpts51_entry() //  [R1]
        { info_tbl: [(ck86,
                      label: Main.rbTreeOpts51_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ck86:
          _rbT9::P64 = R1;
          if ((Sp + -16) < SpLim) goto ck87; else goto ck88;
      ck88:
          if (HpLim == 0) goto ck87; else goto ck89;
      ck87:
          R1 = _rbT9::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ck89:
          (_ck82::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT9::P64);
          if (_ck82::I64 == 0) goto ck84; else goto ck83;
      ck84:
          call (I64[_rbT9::P64])() args: 8, res: 0, upd: 8;
      ck83:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _ck82::I64;
          R2 = ck85_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.103464 UTC

[section "data" {
     Main.rbTreeOpts51_closure:
         const Main.rbTreeOpts51_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ck85_str:
         I8[] [78,111,32,116,114,97,110,115,97,99,116,105,111,110,115]
 },
 Main.rbTreeOpts51_entry() //  [R1]
         { info_tbl: [(ck86,
                       label: Main.rbTreeOpts51_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ck86:
           _rbT9::P64 = R1;
           if ((Sp + -16) < SpLim) goto ck87; else goto ck88;
       ck88:
           if (HpLim == 0) goto ck87; else goto ck89;
       ck87:
           R1 = _rbT9::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ck89:
           (_ck82::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT9::P64);
           if (_ck82::I64 == 0) goto ck84; else goto ck83;
       ck84:
           call (I64[_rbT9::P64])() args: 8, res: 0, upd: 8;
       ck83:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ck82::I64;
           R2 = ck85_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.105158 UTC

[section "data" {
     Main.rbTreeOpts51_closure:
         const Main.rbTreeOpts51_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ck85_str:
         I8[] [78,111,32,116,114,97,110,115,97,99,116,105,111,110,115]
 },
 Main.rbTreeOpts51_entry() //  [R1]
         { info_tbl: [(ck86,
                       label: Main.rbTreeOpts51_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ck86:
           _rbT9::P64 = R1;
           if ((Sp + -16) < SpLim) goto ck87; else goto ck88;
       ck88:
           if (HpLim == 0) goto ck87; else goto ck89;
       ck87:
           R1 = _rbT9::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ck89:
           (_ck82::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT9::P64);
           if (_ck82::I64 == 0) goto ck84; else goto ck83;
       ck84:
           call (I64[_rbT9::P64])() args: 8, res: 0, upd: 8;
       ck83:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ck82::I64;
           R2 = ck85_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.109978 UTC

[section "data" {
     Main.rbTreeOpts_lvl4_closure:
         const Main.rbTreeOpts_lvl4_info;
         const 0;
         const 0;
         const 0;
 },
 Main.rbTreeOpts_lvl4_entry() //  [R1]
         { info_tbl: [(ck8m,
                       label: Main.rbTreeOpts_lvl4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ck8m:
           _rbU9::P64 = R1;
           goto ck8h;
       ck8h:
           if ((old + 0) - <highSp> < SpLim) goto ck8n; else goto ck8o;
       ck8o:
           if (HpLim == 0) goto ck8n; else goto ck8p;
       ck8n:
           R1 = _rbU9::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ck8p:
           (_ck8j::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbU9::P64);
           if (_ck8j::I64 == 0) goto ck8l; else goto ck8k;
       ck8l:
           call (I64[_rbU9::P64])() args: 8, res: 0, upd: 8;
       ck8k:
           I64[(old + 24)] = stg_bh_upd_frame_info;
           I64[(old + 16)] = _ck8j::I64;
           R4 = Main.rbTreeOpts51_closure;
           R3 = GHC.Base.Nothing_closure+1;
           R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
           call Data.OldList.wordsFB_info(R4,
                                          R3,
                                          R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.112238 UTC

{offset
  ck8m:
      _rbU9::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ck8n; else goto ck8o;
  ck8o:
      if (HpLim == 0) goto ck8n; else goto ck8p;
  ck8n:
      R1 = _rbU9::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ck8p:
      (_ck8j::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbU9::P64);
      if (_ck8j::I64 == 0) goto ck8l; else goto ck8k;
  ck8l:
      call (I64[_rbU9::P64])() args: 8, res: 0, upd: 8;
  ck8k:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ck8j::I64;
      R4 = Main.rbTreeOpts51_closure;
      R3 = GHC.Base.Nothing_closure+1;
      R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
      call Data.OldList.wordsFB_info(R4,
                                     R3,
                                     R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:52.113448 UTC

{offset
  ck8m:
      _rbU9::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ck8n; else goto ck8o;
  ck8o:
      if (HpLim == 0) goto ck8n; else goto ck8p;
  ck8n:
      R1 = _rbU9::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ck8p:
      (_ck8j::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbU9::P64);
      if (_ck8j::I64 == 0) goto ck8l; else goto ck8k;
  ck8l:
      call (I64[_rbU9::P64])() args: 8, res: 0, upd: 8;
  ck8k:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ck8j::I64;
      R4 = Main.rbTreeOpts51_closure;
      R3 = GHC.Base.Nothing_closure+1;
      R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
      call Data.OldList.wordsFB_info(R4,
                                     R3,
                                     R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:52.114691 UTC

{offset
  ck8m:
      _rbU9::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ck8n; else goto ck8o;
  ck8o:
      if (HpLim == 0) goto ck8n; else goto ck8p;
  ck8n:
      R1 = _rbU9::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ck8p:
      (_ck8j::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbU9::P64);
      if (_ck8j::I64 == 0) goto ck8l; else goto ck8k;
  ck8l:
      call (I64[_rbU9::P64])() args: 8, res: 0, upd: 8;
  ck8k:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ck8j::I64;
      R4 = Main.rbTreeOpts51_closure;
      R3 = GHC.Base.Nothing_closure+1;
      R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
      call Data.OldList.wordsFB_info(R4,
                                     R3,
                                     R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:52.115981 UTC

{offset
  ck8m:
      _rbU9::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto ck8n; else goto ck8o;
  ck8o:
      if (HpLim == 0) goto ck8n; else goto ck8p;
  ck8n:
      R1 = _rbU9::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ck8p:
      (_ck8j::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbU9::P64);
      if (_ck8j::I64 == 0) goto ck8l; else goto ck8k;
  ck8l:
      call (I64[_rbU9::P64])() args: 8, res: 0, upd: 8;
  ck8k:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _ck8j::I64;
      R4 = Main.rbTreeOpts51_closure;
      R3 = GHC.Base.Nothing_closure+1;
      R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
      Sp = Sp - 16;
      call Data.OldList.wordsFB_info(R4,
                                     R3,
                                     R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:52.117304 UTC

{offset
  ck8m:
      _rbU9::P64 = R1;
      if ((Sp + -16) < SpLim) goto ck8n; else goto ck8o;
  ck8o:
      if (HpLim == 0) goto ck8n; else goto ck8p;
  ck8n:
      R1 = _rbU9::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ck8p:
      (_ck8j::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbU9::P64);
      if (_ck8j::I64 == 0) goto ck8l; else goto ck8k;
  ck8l:
      call (I64[_rbU9::P64])() args: 8, res: 0, upd: 8;
  ck8k:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _ck8j::I64;
      R4 = Main.rbTreeOpts51_closure;
      R3 = GHC.Base.Nothing_closure+1;
      R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
      Sp = Sp - 16;
      call Data.OldList.wordsFB_info(R4,
                                     R3,
                                     R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:52.118721 UTC

[(ck8k,
  {Main.rbTreeOpts51_closure,
   Options.Applicative.Help.Chunk.paragraph1_closure}),
 (ck8l, {}),
 (ck8m,
  {Main.rbTreeOpts51_closure,
   Options.Applicative.Help.Chunk.paragraph1_closure}),
 (ck8n, {}),
 (ck8o,
  {Main.rbTreeOpts51_closure,
   Options.Applicative.Help.Chunk.paragraph1_closure}),
 (ck8p,
  {Main.rbTreeOpts51_closure,
   Options.Applicative.Help.Chunk.paragraph1_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:52.120872 UTC

Main.rbTreeOpts_lvl4_entry() //  [R1]
        { info_tbl: [(ck8m,
                      label: Main.rbTreeOpts_lvl4_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ck8m:
          _rbU9::P64 = R1;
          if ((Sp + -16) < SpLim) goto ck8n; else goto ck8o;
      ck8o:
          if (HpLim == 0) goto ck8n; else goto ck8p;
      ck8n:
          R1 = _rbU9::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ck8p:
          (_ck8j::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbU9::P64);
          if (_ck8j::I64 == 0) goto ck8l; else goto ck8k;
      ck8l:
          call (I64[_rbU9::P64])() args: 8, res: 0, upd: 8;
      ck8k:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _ck8j::I64;
          R4 = Main.rbTreeOpts51_closure;
          R3 = GHC.Base.Nothing_closure+1;
          R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
          Sp = Sp - 16;
          call Data.OldList.wordsFB_info(R4,
                                         R3,
                                         R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.122401 UTC

Main.rbTreeOpts_lvl4_entry() //  [R1]
        { info_tbl: [(ck8m,
                      label: Main.rbTreeOpts_lvl4_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ck8m:
          _rbU9::P64 = R1;
          if ((Sp + -16) < SpLim) goto ck8n; else goto ck8o;
      ck8o:
          if (HpLim == 0) goto ck8n; else goto ck8p;
      ck8n:
          R1 = _rbU9::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ck8p:
          (_ck8j::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbU9::P64);
          if (_ck8j::I64 == 0) goto ck8l; else goto ck8k;
      ck8l:
          call (I64[_rbU9::P64])() args: 8, res: 0, upd: 8;
      ck8k:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _ck8j::I64;
          R4 = Main.rbTreeOpts51_closure;
          R3 = GHC.Base.Nothing_closure+1;
          R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
          Sp = Sp - 16;
          call Data.OldList.wordsFB_info(R4,
                                         R3,
                                         R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.12389 UTC

[section "data" {
     Main.rbTreeOpts_lvl4_closure:
         const Main.rbTreeOpts_lvl4_info;
         const 0;
         const 0;
         const 0;
 },
 Main.rbTreeOpts_lvl4_entry() //  [R1]
         { info_tbl: [(ck8m,
                       label: Main.rbTreeOpts_lvl4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ck8m:
           _rbU9::P64 = R1;
           if ((Sp + -16) < SpLim) goto ck8n; else goto ck8o;
       ck8o:
           if (HpLim == 0) goto ck8n; else goto ck8p;
       ck8n:
           R1 = _rbU9::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ck8p:
           (_ck8j::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbU9::P64);
           if (_ck8j::I64 == 0) goto ck8l; else goto ck8k;
       ck8l:
           call (I64[_rbU9::P64])() args: 8, res: 0, upd: 8;
       ck8k:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ck8j::I64;
           R4 = Main.rbTreeOpts51_closure;
           R3 = GHC.Base.Nothing_closure+1;
           R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
           Sp = Sp - 16;
           call Data.OldList.wordsFB_info(R4,
                                          R3,
                                          R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.125704 UTC

[section "data" {
     Main.rbTreeOpts_lvl4_closure:
         const Main.rbTreeOpts_lvl4_info;
         const 0;
         const 0;
         const 0;
 },
 Main.rbTreeOpts_lvl4_entry() //  [R1]
         { info_tbl: [(ck8m,
                       label: Main.rbTreeOpts_lvl4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ck8m:
           _rbU9::P64 = R1;
           if ((Sp + -16) < SpLim) goto ck8n; else goto ck8o;
       ck8o:
           if (HpLim == 0) goto ck8n; else goto ck8p;
       ck8n:
           R1 = _rbU9::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ck8p:
           (_ck8j::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbU9::P64);
           if (_ck8j::I64 == 0) goto ck8l; else goto ck8k;
       ck8l:
           call (I64[_rbU9::P64])() args: 8, res: 0, upd: 8;
       ck8k:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ck8j::I64;
           R4 = Main.rbTreeOpts51_closure;
           R3 = GHC.Base.Nothing_closure+1;
           R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
           Sp = Sp - 16;
           call Data.OldList.wordsFB_info(R4,
                                          R3,
                                          R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.130576 UTC

[section "data" {
     Main.rbTreeOpts_n7_closure:
         const Options.Applicative.Types.OptShort_static_info;
         const 119;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.130954 UTC

[section "data" {
     Main.rbTreeOpts_n7_closure:
         const Options.Applicative.Types.OptShort_static_info;
         const 119;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.131269 UTC

[section "data" {
     Main.rbTreeOpts_n7_closure:
         const Options.Applicative.Types.OptShort_static_info;
         const 119;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.131935 UTC

[section "data" {
     Main.rbTreeOpts54_closure:
         const :_static_info;
         const Main.rbTreeOpts_n6_closure+2;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.132354 UTC

[section "data" {
     Main.rbTreeOpts54_closure:
         const :_static_info;
         const Main.rbTreeOpts_n6_closure+2;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.132729 UTC

[section "data" {
     Main.rbTreeOpts54_closure:
         const :_static_info;
         const Main.rbTreeOpts_n6_closure+2;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.133498 UTC

[section "data" {
     Main.rbTreeOpts53_closure:
         const :_static_info;
         const Main.rbTreeOpts_n7_closure+1;
         const Main.rbTreeOpts54_closure+2;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.133913 UTC

[section "data" {
     Main.rbTreeOpts53_closure:
         const :_static_info;
         const Main.rbTreeOpts_n7_closure+1;
         const Main.rbTreeOpts54_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.13429 UTC

[section "data" {
     Main.rbTreeOpts53_closure:
         const :_static_info;
         const Main.rbTreeOpts_n7_closure+1;
         const Main.rbTreeOpts54_closure+2;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.135065 UTC

[section "data" {
     Main.rbTreeOpts52_closure:
         const Options.Applicative.Types.FlagReader_static_info;
         const Main.rbTreeOpts53_closure+2;
         const GHC.Types.True_closure+2;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.135492 UTC

[section "data" {
     Main.rbTreeOpts52_closure:
         const Options.Applicative.Types.FlagReader_static_info;
         const Main.rbTreeOpts53_closure+2;
         const GHC.Types.True_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.135881 UTC

[section "data" {
     Main.rbTreeOpts52_closure:
         const Options.Applicative.Types.FlagReader_static_info;
         const Main.rbTreeOpts53_closure+2;
         const GHC.Types.True_closure+2;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.136739 UTC

[section "data" {
     Main.rbTreeOpts50_closure:
         const Options.Applicative.Types.OptProperties_static_info;
         const Options.Applicative.Types.Visible_closure+3;
         const Main.rbTreeOpts_lvl4_closure;
         const GHC.Types.[]_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.137256 UTC

[section "data" {
     Main.rbTreeOpts50_closure:
         const Options.Applicative.Types.OptProperties_static_info;
         const Options.Applicative.Types.Visible_closure+3;
         const Main.rbTreeOpts_lvl4_closure;
         const GHC.Types.[]_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.137708 UTC

[section "data" {
     Main.rbTreeOpts50_closure:
         const Options.Applicative.Types.OptProperties_static_info;
         const Options.Applicative.Types.Visible_closure+3;
         const Main.rbTreeOpts_lvl4_closure;
         const GHC.Types.[]_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.138649 UTC

[section "data" {
     Main.rbTreeOpts49_closure:
         const Options.Applicative.Types.Option_static_info;
         const Main.rbTreeOpts52_closure+2;
         const Main.rbTreeOpts50_closure+1;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.139179 UTC

[section "data" {
     Main.rbTreeOpts49_closure:
         const Options.Applicative.Types.Option_static_info;
         const Main.rbTreeOpts52_closure+2;
         const Main.rbTreeOpts50_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.139564 UTC

[section "data" {
     Main.rbTreeOpts49_closure:
         const Options.Applicative.Types.Option_static_info;
         const Main.rbTreeOpts52_closure+2;
         const Main.rbTreeOpts50_closure+1;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.140768 UTC

[section "data" {
     Main.rbTreeOpts48_closure:
         const Options.Applicative.Types.OptP_static_info;
         const Main.rbTreeOpts49_closure+1;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.14115 UTC

[section "data" {
     Main.rbTreeOpts48_closure:
         const Options.Applicative.Types.OptP_static_info;
         const Main.rbTreeOpts49_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.141489 UTC

[section "data" {
     Main.rbTreeOpts48_closure:
         const Options.Applicative.Types.OptP_static_info;
         const Main.rbTreeOpts49_closure+1;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.142187 UTC

[section "data" {
     Main.rbTreeOpts47_closure:
         const Options.Applicative.Types.AltP_static_info;
         const Main.rbTreeOpts48_closure+2;
         const Options.Applicative.Types.$fAlternativeParser_$cempty_closure;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.142601 UTC

[section "data" {
     Main.rbTreeOpts47_closure:
         const Options.Applicative.Types.AltP_static_info;
         const Main.rbTreeOpts48_closure+2;
         const Options.Applicative.Types.$fAlternativeParser_$cempty_closure;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.142976 UTC

[section "data" {
     Main.rbTreeOpts47_closure:
         const Options.Applicative.Types.AltP_static_info;
         const Main.rbTreeOpts48_closure+2;
         const Options.Applicative.Types.$fAlternativeParser_$cempty_closure;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.143724 UTC

[section "data" {
     Main.rbTreeOpts66_closure:
         const Main.rbTreeOpts66_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ck8S_str:
         I8[] [105,110,105,116,79,110,108,121]
 },
 Main.rbTreeOpts66_entry() //  [R1]
         { info_tbl: [(ck8T,
                       label: Main.rbTreeOpts66_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ck8T:
           _rbSX::P64 = R1;
           goto ck8N;
       ck8N:
           if ((old + 0) - <highSp> < SpLim) goto ck8U; else goto ck8V;
       ck8V:
           if (HpLim == 0) goto ck8U; else goto ck8W;
       ck8U:
           R1 = _rbSX::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ck8W:
           (_ck8P::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbSX::P64);
           if (_ck8P::I64 == 0) goto ck8R; else goto ck8Q;
       ck8R:
           call (I64[_rbSX::P64])() args: 8, res: 0, upd: 8;
       ck8Q:
           I64[(old + 24)] = stg_bh_upd_frame_info;
           I64[(old + 16)] = _ck8P::I64;
           R2 = ck8S_str;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.145868 UTC

{offset
  ck8T:
      _rbSX::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ck8U; else goto ck8V;
  ck8V:
      if (HpLim == 0) goto ck8U; else goto ck8W;
  ck8U:
      R1 = _rbSX::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ck8W:
      (_ck8P::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbSX::P64);
      if (_ck8P::I64 == 0) goto ck8R; else goto ck8Q;
  ck8R:
      call (I64[_rbSX::P64])() args: 8, res: 0, upd: 8;
  ck8Q:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ck8P::I64;
      R2 = ck8S_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:52.146991 UTC

{offset
  ck8T:
      _rbSX::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ck8U; else goto ck8V;
  ck8V:
      if (HpLim == 0) goto ck8U; else goto ck8W;
  ck8U:
      R1 = _rbSX::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ck8W:
      (_ck8P::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbSX::P64);
      if (_ck8P::I64 == 0) goto ck8R; else goto ck8Q;
  ck8R:
      call (I64[_rbSX::P64])() args: 8, res: 0, upd: 8;
  ck8Q:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ck8P::I64;
      R2 = ck8S_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:52.148112 UTC

{offset
  ck8T:
      _rbSX::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ck8U; else goto ck8V;
  ck8V:
      if (HpLim == 0) goto ck8U; else goto ck8W;
  ck8U:
      R1 = _rbSX::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ck8W:
      (_ck8P::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbSX::P64);
      if (_ck8P::I64 == 0) goto ck8R; else goto ck8Q;
  ck8R:
      call (I64[_rbSX::P64])() args: 8, res: 0, upd: 8;
  ck8Q:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ck8P::I64;
      R2 = ck8S_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:52.149308 UTC

{offset
  ck8T:
      _rbSX::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto ck8U; else goto ck8V;
  ck8V:
      if (HpLim == 0) goto ck8U; else goto ck8W;
  ck8U:
      R1 = _rbSX::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ck8W:
      (_ck8P::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbSX::P64);
      if (_ck8P::I64 == 0) goto ck8R; else goto ck8Q;
  ck8R:
      call (I64[_rbSX::P64])() args: 8, res: 0, upd: 8;
  ck8Q:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _ck8P::I64;
      R2 = ck8S_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:52.150465 UTC

{offset
  ck8T:
      _rbSX::P64 = R1;
      if ((Sp + -16) < SpLim) goto ck8U; else goto ck8V;
  ck8V:
      if (HpLim == 0) goto ck8U; else goto ck8W;
  ck8U:
      R1 = _rbSX::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ck8W:
      (_ck8P::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbSX::P64);
      if (_ck8P::I64 == 0) goto ck8R; else goto ck8Q;
  ck8R:
      call (I64[_rbSX::P64])() args: 8, res: 0, upd: 8;
  ck8Q:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _ck8P::I64;
      R2 = ck8S_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:52.151749 UTC

[(ck8Q, {}), (ck8R, {}), (ck8T, {}), (ck8U, {}), (ck8V, {}),
 (ck8W, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:52.152133 UTC

Main.rbTreeOpts66_entry() //  [R1]
        { info_tbl: [(ck8T,
                      label: Main.rbTreeOpts66_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ck8T:
          _rbSX::P64 = R1;
          if ((Sp + -16) < SpLim) goto ck8U; else goto ck8V;
      ck8V:
          if (HpLim == 0) goto ck8U; else goto ck8W;
      ck8U:
          R1 = _rbSX::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ck8W:
          (_ck8P::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbSX::P64);
          if (_ck8P::I64 == 0) goto ck8R; else goto ck8Q;
      ck8R:
          call (I64[_rbSX::P64])() args: 8, res: 0, upd: 8;
      ck8Q:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _ck8P::I64;
          R2 = ck8S_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.153502 UTC

Main.rbTreeOpts66_entry() //  [R1]
        { info_tbl: [(ck8T,
                      label: Main.rbTreeOpts66_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ck8T:
          _rbSX::P64 = R1;
          if ((Sp + -16) < SpLim) goto ck8U; else goto ck8V;
      ck8V:
          if (HpLim == 0) goto ck8U; else goto ck8W;
      ck8U:
          R1 = _rbSX::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ck8W:
          (_ck8P::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbSX::P64);
          if (_ck8P::I64 == 0) goto ck8R; else goto ck8Q;
      ck8R:
          call (I64[_rbSX::P64])() args: 8, res: 0, upd: 8;
      ck8Q:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _ck8P::I64;
          R2 = ck8S_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.154917 UTC

[section "data" {
     Main.rbTreeOpts66_closure:
         const Main.rbTreeOpts66_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ck8S_str:
         I8[] [105,110,105,116,79,110,108,121]
 },
 Main.rbTreeOpts66_entry() //  [R1]
         { info_tbl: [(ck8T,
                       label: Main.rbTreeOpts66_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ck8T:
           _rbSX::P64 = R1;
           if ((Sp + -16) < SpLim) goto ck8U; else goto ck8V;
       ck8V:
           if (HpLim == 0) goto ck8U; else goto ck8W;
       ck8U:
           R1 = _rbSX::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ck8W:
           (_ck8P::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbSX::P64);
           if (_ck8P::I64 == 0) goto ck8R; else goto ck8Q;
       ck8R:
           call (I64[_rbSX::P64])() args: 8, res: 0, upd: 8;
       ck8Q:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ck8P::I64;
           R2 = ck8S_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.156639 UTC

[section "data" {
     Main.rbTreeOpts66_closure:
         const Main.rbTreeOpts66_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ck8S_str:
         I8[] [105,110,105,116,79,110,108,121]
 },
 Main.rbTreeOpts66_entry() //  [R1]
         { info_tbl: [(ck8T,
                       label: Main.rbTreeOpts66_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ck8T:
           _rbSX::P64 = R1;
           if ((Sp + -16) < SpLim) goto ck8U; else goto ck8V;
       ck8V:
           if (HpLim == 0) goto ck8U; else goto ck8W;
       ck8U:
           R1 = _rbSX::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ck8W:
           (_ck8P::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbSX::P64);
           if (_ck8P::I64 == 0) goto ck8R; else goto ck8Q;
       ck8R:
           call (I64[_rbSX::P64])() args: 8, res: 0, upd: 8;
       ck8Q:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ck8P::I64;
           R2 = ck8S_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.16152 UTC

[section "data" {
     Main.rbTreeOpts_n8_closure:
         const Options.Applicative.Types.OptLong_static_info;
         const Main.rbTreeOpts66_closure;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.161936 UTC

[section "data" {
     Main.rbTreeOpts_n8_closure:
         const Options.Applicative.Types.OptLong_static_info;
         const Main.rbTreeOpts66_closure;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.162282 UTC

[section "data" {
     Main.rbTreeOpts_n8_closure:
         const Options.Applicative.Types.OptLong_static_info;
         const Main.rbTreeOpts66_closure;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.162931 UTC

[section "data" {
     Main.rbTreeOpts62_closure:
         const Main.rbTreeOpts62_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ck9b_str:
         I8[] [73,110,105,116,105,97,108,105,122,101,32,111,110,108,121]
 },
 Main.rbTreeOpts62_entry() //  [R1]
         { info_tbl: [(ck9c,
                       label: Main.rbTreeOpts62_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ck9c:
           _rbT8::P64 = R1;
           goto ck96;
       ck96:
           if ((old + 0) - <highSp> < SpLim) goto ck9d; else goto ck9e;
       ck9e:
           if (HpLim == 0) goto ck9d; else goto ck9f;
       ck9d:
           R1 = _rbT8::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ck9f:
           (_ck98::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT8::P64);
           if (_ck98::I64 == 0) goto ck9a; else goto ck99;
       ck9a:
           call (I64[_rbT8::P64])() args: 8, res: 0, upd: 8;
       ck99:
           I64[(old + 24)] = stg_bh_upd_frame_info;
           I64[(old + 16)] = _ck98::I64;
           R2 = ck9b_str;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.165535 UTC

{offset
  ck9c:
      _rbT8::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ck9d; else goto ck9e;
  ck9e:
      if (HpLim == 0) goto ck9d; else goto ck9f;
  ck9d:
      R1 = _rbT8::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ck9f:
      (_ck98::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT8::P64);
      if (_ck98::I64 == 0) goto ck9a; else goto ck99;
  ck9a:
      call (I64[_rbT8::P64])() args: 8, res: 0, upd: 8;
  ck99:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ck98::I64;
      R2 = ck9b_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:52.166624 UTC

{offset
  ck9c:
      _rbT8::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ck9d; else goto ck9e;
  ck9e:
      if (HpLim == 0) goto ck9d; else goto ck9f;
  ck9d:
      R1 = _rbT8::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ck9f:
      (_ck98::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT8::P64);
      if (_ck98::I64 == 0) goto ck9a; else goto ck99;
  ck9a:
      call (I64[_rbT8::P64])() args: 8, res: 0, upd: 8;
  ck99:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ck98::I64;
      R2 = ck9b_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:52.167745 UTC

{offset
  ck9c:
      _rbT8::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ck9d; else goto ck9e;
  ck9e:
      if (HpLim == 0) goto ck9d; else goto ck9f;
  ck9d:
      R1 = _rbT8::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ck9f:
      (_ck98::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT8::P64);
      if (_ck98::I64 == 0) goto ck9a; else goto ck99;
  ck9a:
      call (I64[_rbT8::P64])() args: 8, res: 0, upd: 8;
  ck99:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ck98::I64;
      R2 = ck9b_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:52.168877 UTC

{offset
  ck9c:
      _rbT8::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto ck9d; else goto ck9e;
  ck9e:
      if (HpLim == 0) goto ck9d; else goto ck9f;
  ck9d:
      R1 = _rbT8::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ck9f:
      (_ck98::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT8::P64);
      if (_ck98::I64 == 0) goto ck9a; else goto ck99;
  ck9a:
      call (I64[_rbT8::P64])() args: 8, res: 0, upd: 8;
  ck99:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _ck98::I64;
      R2 = ck9b_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:52.170033 UTC

{offset
  ck9c:
      _rbT8::P64 = R1;
      if ((Sp + -16) < SpLim) goto ck9d; else goto ck9e;
  ck9e:
      if (HpLim == 0) goto ck9d; else goto ck9f;
  ck9d:
      R1 = _rbT8::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ck9f:
      (_ck98::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT8::P64);
      if (_ck98::I64 == 0) goto ck9a; else goto ck99;
  ck9a:
      call (I64[_rbT8::P64])() args: 8, res: 0, upd: 8;
  ck99:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _ck98::I64;
      R2 = ck9b_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:52.171306 UTC

[(ck99, {}), (ck9a, {}), (ck9c, {}), (ck9d, {}), (ck9e, {}),
 (ck9f, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:52.171682 UTC

Main.rbTreeOpts62_entry() //  [R1]
        { info_tbl: [(ck9c,
                      label: Main.rbTreeOpts62_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ck9c:
          _rbT8::P64 = R1;
          if ((Sp + -16) < SpLim) goto ck9d; else goto ck9e;
      ck9e:
          if (HpLim == 0) goto ck9d; else goto ck9f;
      ck9d:
          R1 = _rbT8::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ck9f:
          (_ck98::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT8::P64);
          if (_ck98::I64 == 0) goto ck9a; else goto ck99;
      ck9a:
          call (I64[_rbT8::P64])() args: 8, res: 0, upd: 8;
      ck99:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _ck98::I64;
          R2 = ck9b_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.173032 UTC

Main.rbTreeOpts62_entry() //  [R1]
        { info_tbl: [(ck9c,
                      label: Main.rbTreeOpts62_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ck9c:
          _rbT8::P64 = R1;
          if ((Sp + -16) < SpLim) goto ck9d; else goto ck9e;
      ck9e:
          if (HpLim == 0) goto ck9d; else goto ck9f;
      ck9d:
          R1 = _rbT8::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ck9f:
          (_ck98::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT8::P64);
          if (_ck98::I64 == 0) goto ck9a; else goto ck99;
      ck9a:
          call (I64[_rbT8::P64])() args: 8, res: 0, upd: 8;
      ck99:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _ck98::I64;
          R2 = ck9b_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.174404 UTC

[section "data" {
     Main.rbTreeOpts62_closure:
         const Main.rbTreeOpts62_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ck9b_str:
         I8[] [73,110,105,116,105,97,108,105,122,101,32,111,110,108,121]
 },
 Main.rbTreeOpts62_entry() //  [R1]
         { info_tbl: [(ck9c,
                       label: Main.rbTreeOpts62_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ck9c:
           _rbT8::P64 = R1;
           if ((Sp + -16) < SpLim) goto ck9d; else goto ck9e;
       ck9e:
           if (HpLim == 0) goto ck9d; else goto ck9f;
       ck9d:
           R1 = _rbT8::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ck9f:
           (_ck98::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT8::P64);
           if (_ck98::I64 == 0) goto ck9a; else goto ck99;
       ck9a:
           call (I64[_rbT8::P64])() args: 8, res: 0, upd: 8;
       ck99:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ck98::I64;
           R2 = ck9b_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.176161 UTC

[section "data" {
     Main.rbTreeOpts62_closure:
         const Main.rbTreeOpts62_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ck9b_str:
         I8[] [73,110,105,116,105,97,108,105,122,101,32,111,110,108,121]
 },
 Main.rbTreeOpts62_entry() //  [R1]
         { info_tbl: [(ck9c,
                       label: Main.rbTreeOpts62_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ck9c:
           _rbT8::P64 = R1;
           if ((Sp + -16) < SpLim) goto ck9d; else goto ck9e;
       ck9e:
           if (HpLim == 0) goto ck9d; else goto ck9f;
       ck9d:
           R1 = _rbT8::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ck9f:
           (_ck98::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT8::P64);
           if (_ck98::I64 == 0) goto ck9a; else goto ck99;
       ck9a:
           call (I64[_rbT8::P64])() args: 8, res: 0, upd: 8;
       ck99:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ck98::I64;
           R2 = ck9b_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.18111 UTC

[section "data" {
     Main.rbTreeOpts_lvl5_closure:
         const Main.rbTreeOpts_lvl5_info;
         const 0;
         const 0;
         const 0;
 },
 Main.rbTreeOpts_lvl5_entry() //  [R1]
         { info_tbl: [(ck9s,
                       label: Main.rbTreeOpts_lvl5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ck9s:
           _rbTU::P64 = R1;
           goto ck9n;
       ck9n:
           if ((old + 0) - <highSp> < SpLim) goto ck9t; else goto ck9u;
       ck9u:
           if (HpLim == 0) goto ck9t; else goto ck9v;
       ck9t:
           R1 = _rbTU::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ck9v:
           (_ck9p::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTU::P64);
           if (_ck9p::I64 == 0) goto ck9r; else goto ck9q;
       ck9r:
           call (I64[_rbTU::P64])() args: 8, res: 0, upd: 8;
       ck9q:
           I64[(old + 24)] = stg_bh_upd_frame_info;
           I64[(old + 16)] = _ck9p::I64;
           R4 = Main.rbTreeOpts62_closure;
           R3 = GHC.Base.Nothing_closure+1;
           R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
           call Data.OldList.wordsFB_info(R4,
                                          R3,
                                          R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.183348 UTC

{offset
  ck9s:
      _rbTU::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ck9t; else goto ck9u;
  ck9u:
      if (HpLim == 0) goto ck9t; else goto ck9v;
  ck9t:
      R1 = _rbTU::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ck9v:
      (_ck9p::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTU::P64);
      if (_ck9p::I64 == 0) goto ck9r; else goto ck9q;
  ck9r:
      call (I64[_rbTU::P64])() args: 8, res: 0, upd: 8;
  ck9q:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ck9p::I64;
      R4 = Main.rbTreeOpts62_closure;
      R3 = GHC.Base.Nothing_closure+1;
      R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
      call Data.OldList.wordsFB_info(R4,
                                     R3,
                                     R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:52.184575 UTC

{offset
  ck9s:
      _rbTU::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ck9t; else goto ck9u;
  ck9u:
      if (HpLim == 0) goto ck9t; else goto ck9v;
  ck9t:
      R1 = _rbTU::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ck9v:
      (_ck9p::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTU::P64);
      if (_ck9p::I64 == 0) goto ck9r; else goto ck9q;
  ck9r:
      call (I64[_rbTU::P64])() args: 8, res: 0, upd: 8;
  ck9q:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ck9p::I64;
      R4 = Main.rbTreeOpts62_closure;
      R3 = GHC.Base.Nothing_closure+1;
      R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
      call Data.OldList.wordsFB_info(R4,
                                     R3,
                                     R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:52.185831 UTC

{offset
  ck9s:
      _rbTU::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ck9t; else goto ck9u;
  ck9u:
      if (HpLim == 0) goto ck9t; else goto ck9v;
  ck9t:
      R1 = _rbTU::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ck9v:
      (_ck9p::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTU::P64);
      if (_ck9p::I64 == 0) goto ck9r; else goto ck9q;
  ck9r:
      call (I64[_rbTU::P64])() args: 8, res: 0, upd: 8;
  ck9q:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ck9p::I64;
      R4 = Main.rbTreeOpts62_closure;
      R3 = GHC.Base.Nothing_closure+1;
      R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
      call Data.OldList.wordsFB_info(R4,
                                     R3,
                                     R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:52.18712 UTC

{offset
  ck9s:
      _rbTU::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto ck9t; else goto ck9u;
  ck9u:
      if (HpLim == 0) goto ck9t; else goto ck9v;
  ck9t:
      R1 = _rbTU::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ck9v:
      (_ck9p::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTU::P64);
      if (_ck9p::I64 == 0) goto ck9r; else goto ck9q;
  ck9r:
      call (I64[_rbTU::P64])() args: 8, res: 0, upd: 8;
  ck9q:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _ck9p::I64;
      R4 = Main.rbTreeOpts62_closure;
      R3 = GHC.Base.Nothing_closure+1;
      R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
      Sp = Sp - 16;
      call Data.OldList.wordsFB_info(R4,
                                     R3,
                                     R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:52.188397 UTC

{offset
  ck9s:
      _rbTU::P64 = R1;
      if ((Sp + -16) < SpLim) goto ck9t; else goto ck9u;
  ck9u:
      if (HpLim == 0) goto ck9t; else goto ck9v;
  ck9t:
      R1 = _rbTU::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ck9v:
      (_ck9p::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTU::P64);
      if (_ck9p::I64 == 0) goto ck9r; else goto ck9q;
  ck9r:
      call (I64[_rbTU::P64])() args: 8, res: 0, upd: 8;
  ck9q:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _ck9p::I64;
      R4 = Main.rbTreeOpts62_closure;
      R3 = GHC.Base.Nothing_closure+1;
      R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
      Sp = Sp - 16;
      call Data.OldList.wordsFB_info(R4,
                                     R3,
                                     R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:52.189828 UTC

[(ck9q,
  {Main.rbTreeOpts62_closure,
   Options.Applicative.Help.Chunk.paragraph1_closure}),
 (ck9r, {}),
 (ck9s,
  {Main.rbTreeOpts62_closure,
   Options.Applicative.Help.Chunk.paragraph1_closure}),
 (ck9t, {}),
 (ck9u,
  {Main.rbTreeOpts62_closure,
   Options.Applicative.Help.Chunk.paragraph1_closure}),
 (ck9v,
  {Main.rbTreeOpts62_closure,
   Options.Applicative.Help.Chunk.paragraph1_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:52.190536 UTC

Main.rbTreeOpts_lvl5_entry() //  [R1]
        { info_tbl: [(ck9s,
                      label: Main.rbTreeOpts_lvl5_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ck9s:
          _rbTU::P64 = R1;
          if ((Sp + -16) < SpLim) goto ck9t; else goto ck9u;
      ck9u:
          if (HpLim == 0) goto ck9t; else goto ck9v;
      ck9t:
          R1 = _rbTU::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ck9v:
          (_ck9p::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTU::P64);
          if (_ck9p::I64 == 0) goto ck9r; else goto ck9q;
      ck9r:
          call (I64[_rbTU::P64])() args: 8, res: 0, upd: 8;
      ck9q:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _ck9p::I64;
          R4 = Main.rbTreeOpts62_closure;
          R3 = GHC.Base.Nothing_closure+1;
          R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
          Sp = Sp - 16;
          call Data.OldList.wordsFB_info(R4,
                                         R3,
                                         R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.192059 UTC

Main.rbTreeOpts_lvl5_entry() //  [R1]
        { info_tbl: [(ck9s,
                      label: Main.rbTreeOpts_lvl5_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ck9s:
          _rbTU::P64 = R1;
          if ((Sp + -16) < SpLim) goto ck9t; else goto ck9u;
      ck9u:
          if (HpLim == 0) goto ck9t; else goto ck9v;
      ck9t:
          R1 = _rbTU::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ck9v:
          (_ck9p::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTU::P64);
          if (_ck9p::I64 == 0) goto ck9r; else goto ck9q;
      ck9r:
          call (I64[_rbTU::P64])() args: 8, res: 0, upd: 8;
      ck9q:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _ck9p::I64;
          R4 = Main.rbTreeOpts62_closure;
          R3 = GHC.Base.Nothing_closure+1;
          R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
          Sp = Sp - 16;
          call Data.OldList.wordsFB_info(R4,
                                         R3,
                                         R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.193588 UTC

[section "data" {
     Main.rbTreeOpts_lvl5_closure:
         const Main.rbTreeOpts_lvl5_info;
         const 0;
         const 0;
         const 0;
 },
 Main.rbTreeOpts_lvl5_entry() //  [R1]
         { info_tbl: [(ck9s,
                       label: Main.rbTreeOpts_lvl5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ck9s:
           _rbTU::P64 = R1;
           if ((Sp + -16) < SpLim) goto ck9t; else goto ck9u;
       ck9u:
           if (HpLim == 0) goto ck9t; else goto ck9v;
       ck9t:
           R1 = _rbTU::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ck9v:
           (_ck9p::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTU::P64);
           if (_ck9p::I64 == 0) goto ck9r; else goto ck9q;
       ck9r:
           call (I64[_rbTU::P64])() args: 8, res: 0, upd: 8;
       ck9q:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ck9p::I64;
           R4 = Main.rbTreeOpts62_closure;
           R3 = GHC.Base.Nothing_closure+1;
           R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
           Sp = Sp - 16;
           call Data.OldList.wordsFB_info(R4,
                                          R3,
                                          R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.195435 UTC

[section "data" {
     Main.rbTreeOpts_lvl5_closure:
         const Main.rbTreeOpts_lvl5_info;
         const 0;
         const 0;
         const 0;
 },
 Main.rbTreeOpts_lvl5_entry() //  [R1]
         { info_tbl: [(ck9s,
                       label: Main.rbTreeOpts_lvl5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ck9s:
           _rbTU::P64 = R1;
           if ((Sp + -16) < SpLim) goto ck9t; else goto ck9u;
       ck9u:
           if (HpLim == 0) goto ck9t; else goto ck9v;
       ck9t:
           R1 = _rbTU::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ck9v:
           (_ck9p::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTU::P64);
           if (_ck9p::I64 == 0) goto ck9r; else goto ck9q;
       ck9r:
           call (I64[_rbTU::P64])() args: 8, res: 0, upd: 8;
       ck9q:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ck9p::I64;
           R4 = Main.rbTreeOpts62_closure;
           R3 = GHC.Base.Nothing_closure+1;
           R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
           Sp = Sp - 16;
           call Data.OldList.wordsFB_info(R4,
                                          R3,
                                          R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.200381 UTC

[section "data" {
     Main.rbTreeOpts_n9_closure:
         const Options.Applicative.Types.OptShort_static_info;
         const 105;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.201249 UTC

[section "data" {
     Main.rbTreeOpts_n9_closure:
         const Options.Applicative.Types.OptShort_static_info;
         const 105;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.201559 UTC

[section "data" {
     Main.rbTreeOpts_n9_closure:
         const Options.Applicative.Types.OptShort_static_info;
         const 105;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.202226 UTC

[section "data" {
     Main.rbTreeOpts65_closure:
         const :_static_info;
         const Main.rbTreeOpts_n8_closure+2;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.202656 UTC

[section "data" {
     Main.rbTreeOpts65_closure:
         const :_static_info;
         const Main.rbTreeOpts_n8_closure+2;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.203035 UTC

[section "data" {
     Main.rbTreeOpts65_closure:
         const :_static_info;
         const Main.rbTreeOpts_n8_closure+2;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.203805 UTC

[section "data" {
     Main.rbTreeOpts64_closure:
         const :_static_info;
         const Main.rbTreeOpts_n9_closure+1;
         const Main.rbTreeOpts65_closure+2;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.204222 UTC

[section "data" {
     Main.rbTreeOpts64_closure:
         const :_static_info;
         const Main.rbTreeOpts_n9_closure+1;
         const Main.rbTreeOpts65_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.204597 UTC

[section "data" {
     Main.rbTreeOpts64_closure:
         const :_static_info;
         const Main.rbTreeOpts_n9_closure+1;
         const Main.rbTreeOpts65_closure+2;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.205358 UTC

[section "data" {
     Main.rbTreeOpts63_closure:
         const Options.Applicative.Types.FlagReader_static_info;
         const Main.rbTreeOpts64_closure+2;
         const GHC.Types.True_closure+2;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.205782 UTC

[section "data" {
     Main.rbTreeOpts63_closure:
         const Options.Applicative.Types.FlagReader_static_info;
         const Main.rbTreeOpts64_closure+2;
         const GHC.Types.True_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.206176 UTC

[section "data" {
     Main.rbTreeOpts63_closure:
         const Options.Applicative.Types.FlagReader_static_info;
         const Main.rbTreeOpts64_closure+2;
         const GHC.Types.True_closure+2;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.207015 UTC

[section "data" {
     Main.rbTreeOpts61_closure:
         const Options.Applicative.Types.OptProperties_static_info;
         const Options.Applicative.Types.Visible_closure+3;
         const Main.rbTreeOpts_lvl5_closure;
         const GHC.Types.[]_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.207512 UTC

[section "data" {
     Main.rbTreeOpts61_closure:
         const Options.Applicative.Types.OptProperties_static_info;
         const Options.Applicative.Types.Visible_closure+3;
         const Main.rbTreeOpts_lvl5_closure;
         const GHC.Types.[]_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.207967 UTC

[section "data" {
     Main.rbTreeOpts61_closure:
         const Options.Applicative.Types.OptProperties_static_info;
         const Options.Applicative.Types.Visible_closure+3;
         const Main.rbTreeOpts_lvl5_closure;
         const GHC.Types.[]_closure+1;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.20888 UTC

[section "data" {
     Main.rbTreeOpts60_closure:
         const Options.Applicative.Types.Option_static_info;
         const Main.rbTreeOpts63_closure+2;
         const Main.rbTreeOpts61_closure+1;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.209327 UTC

[section "data" {
     Main.rbTreeOpts60_closure:
         const Options.Applicative.Types.Option_static_info;
         const Main.rbTreeOpts63_closure+2;
         const Main.rbTreeOpts61_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.209733 UTC

[section "data" {
     Main.rbTreeOpts60_closure:
         const Options.Applicative.Types.Option_static_info;
         const Main.rbTreeOpts63_closure+2;
         const Main.rbTreeOpts61_closure+1;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.210493 UTC

[section "data" {
     Main.rbTreeOpts59_closure:
         const Options.Applicative.Types.OptP_static_info;
         const Main.rbTreeOpts60_closure+1;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.210881 UTC

[section "data" {
     Main.rbTreeOpts59_closure:
         const Options.Applicative.Types.OptP_static_info;
         const Main.rbTreeOpts60_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.211224 UTC

[section "data" {
     Main.rbTreeOpts59_closure:
         const Options.Applicative.Types.OptP_static_info;
         const Main.rbTreeOpts60_closure+1;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.211929 UTC

[section "data" {
     Main.rbTreeOpts58_closure:
         const Options.Applicative.Types.AltP_static_info;
         const Main.rbTreeOpts59_closure+2;
         const Options.Applicative.Types.$fAlternativeParser_$cempty_closure;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.212782 UTC

[section "data" {
     Main.rbTreeOpts58_closure:
         const Options.Applicative.Types.AltP_static_info;
         const Main.rbTreeOpts59_closure+2;
         const Options.Applicative.Types.$fAlternativeParser_$cempty_closure;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.21318 UTC

[section "data" {
     Main.rbTreeOpts58_closure:
         const Options.Applicative.Types.AltP_static_info;
         const Main.rbTreeOpts59_closure+2;
         const Options.Applicative.Types.$fAlternativeParser_$cempty_closure;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.214482 UTC

[section "data" {
     Main.$wa2_closure:
         const Main.$wa2_info;
         const 0;
 },
 Main.$wa2_entry() //  [R4, R3, R2]
         { info_tbl: [(ckak,
                       label: Main.$wa2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 17} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckak:
           _sjVy::P64 = R4;
           _sjVx::I64 = R3;
           _sjVw::I64 = R2;
           goto ckag;
       ckag:
           if ((old + 0) - <highSp> < SpLim) goto ckaM; else goto ckaN;
       ckaN:
           goto ckaf;
       ckaf:
           if (HpLim == 0) goto ckaM; else goto ckaO;
       ckaM:
           R4 = _sjVy::P64;
           R3 = _sjVx::I64;
           R2 = _sjVw::I64;
           R1 = Main.$wa2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckaO:
           _sjVC::I64 = I64[_sjVy::P64 + 16];
           _sjVC::I64 = _sjVC::I64;
           _ckai::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_sjVw::I64));
           _sjVD::I64 = _ckai::I64;
           I64[(young<ckam> + 8)] = ckam;
           R3 = _sjVC::I64;
           R2 = _sjVD::I64;
           call System.Random.PCG.Fast.Pure.$wbounded_info(R3,
                                                           R2) returns to ckam, args: 8, res: 8, upd: 8;
       ckam:
           _sjVG::I64 = R2;
           _sjVF::I64 = R1;
           goto ckan;
       ckan:
           I64[_sjVy::P64 + 16] = _sjVF::I64;
           _sjVK::I64 = I64[_sjVy::P64 + 16];
           _sjVK::I64 = _sjVK::I64;
           _ckas::I64 = _sjVx::I64 - 2;
           _sjVL::I64 = _ckas::I64;
           _ckav::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_sjVL::I64));
           _sjVM::I64 = _ckav::I64;
           I64[(young<ckay> + 8)] = ckay;
           R3 = _sjVK::I64;
           R2 = _sjVM::I64;
           call System.Random.PCG.Fast.Pure.$wbounded_info(R3,
                                                           R2) returns to ckay, args: 8, res: 8, upd: 8;
       ckay:
           _sjVP::I64 = R2;
           _sjVO::I64 = R1;
           goto ckaz;
       ckaz:
           Hp = Hp + 96;
           if (Hp > HpLim) goto ckaS; else goto ckaR;
       ckaS:
           HpAlloc = 96;
           goto ckaQ;
       ckaQ:
           I64[(young<ckaA> + 8)] = ckaA;
           call stg_gc_noregs() returns to ckaA, args: 8, res: 8, upd: 8;
       ckaA:
           goto ckaz;
       ckaR:
           I64[_sjVy::P64 + 16] = _sjVO::I64;
           I64[Hp - 88] = Data.Primitive.ByteArray.MutableByteArray_con_info;
           P64[Hp - 80] = _sjVy::P64;
           _ckaE::P64 = Hp - 87;
           _ckaF::I64 = _sjVP::I64 + 1;
           _sjVS::I64 = _ckaF::I64;
           I64[Hp - 72] = GHC.Types.W#_con_info;
           I64[Hp - 64] = _sjVS::I64;
           _ckaI::P64 = Hp - 71;
           I64[Hp - 56] = GHC.Types.W#_con_info;
           I64[Hp - 48] = _sjVG::I64;
           _ckaJ::P64 = Hp - 55;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = _ckaJ::P64;
           P64[Hp - 24] = _ckaI::P64;
           _ckaK::P64 = Hp - 39;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = _ckaK::P64;
           P64[Hp] = _ckaE::P64;
           _ckaL::P64 = Hp - 15;
           R1 = _ckaL::P64;
           call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.220926 UTC

{offset
  ckak:
      _sjVy::P64 = R4;
      _sjVx::I64 = R3;
      _sjVw::I64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckaM; else goto ckaN;
  ckaN:
      if (HpLim == 0) goto ckaM; else goto ckaO;
  ckaM:
      R4 = _sjVy::P64;
      R3 = _sjVx::I64;
      R2 = _sjVw::I64;
      R1 = Main.$wa2_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  ckaO:
      _sjVC::I64 = I64[_sjVy::P64 + 16];
      _sjVC::I64 = _sjVC::I64;
      _ckai::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_sjVw::I64));
      _sjVD::I64 = _ckai::I64;
      I64[(young<ckam> + 8)] = ckam;
      R3 = _sjVC::I64;
      R2 = _sjVD::I64;
      call System.Random.PCG.Fast.Pure.$wbounded_info(R3,
                                                      R2) returns to ckam, args: 8, res: 8, upd: 8;
  ckam:
      _sjVG::I64 = R2;
      _sjVF::I64 = R1;
      I64[_sjVy::P64 + 16] = _sjVF::I64;
      _sjVK::I64 = I64[_sjVy::P64 + 16];
      _sjVK::I64 = _sjVK::I64;
      _ckas::I64 = _sjVx::I64 - 2;
      _sjVL::I64 = _ckas::I64;
      _ckav::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_sjVL::I64));
      _sjVM::I64 = _ckav::I64;
      I64[(young<ckay> + 8)] = ckay;
      R3 = _sjVK::I64;
      R2 = _sjVM::I64;
      call System.Random.PCG.Fast.Pure.$wbounded_info(R3,
                                                      R2) returns to ckay, args: 8, res: 8, upd: 8;
  ckay:
      _sjVP::I64 = R2;
      _sjVO::I64 = R1;
      goto ckaz;
  ckaz:
      Hp = Hp + 96;
      if (Hp > HpLim) goto ckaS; else goto ckaR;
  ckaS:
      HpAlloc = 96;
      I64[(young<ckaA> + 8)] = ckaA;
      call stg_gc_noregs() returns to ckaA, args: 8, res: 8, upd: 8;
  ckaA:
      goto ckaz;
  ckaR:
      I64[_sjVy::P64 + 16] = _sjVO::I64;
      I64[Hp - 88] = Data.Primitive.ByteArray.MutableByteArray_con_info;
      P64[Hp - 80] = _sjVy::P64;
      _ckaE::P64 = Hp - 87;
      _ckaF::I64 = _sjVP::I64 + 1;
      _sjVS::I64 = _ckaF::I64;
      I64[Hp - 72] = GHC.Types.W#_con_info;
      I64[Hp - 64] = _sjVS::I64;
      _ckaI::P64 = Hp - 71;
      I64[Hp - 56] = GHC.Types.W#_con_info;
      I64[Hp - 48] = _sjVG::I64;
      _ckaJ::P64 = Hp - 55;
      I64[Hp - 40] = (,)_con_info;
      P64[Hp - 32] = _ckaJ::P64;
      P64[Hp - 24] = _ckaI::P64;
      _ckaK::P64 = Hp - 39;
      I64[Hp - 16] = (,)_con_info;
      P64[Hp - 8] = _ckaK::P64;
      P64[Hp] = _ckaE::P64;
      _ckaL::P64 = Hp - 15;
      R1 = _ckaL::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:52.224337 UTC

{offset
  ckak:
      _sjVy::P64 = R4;
      _sjVx::I64 = R3;
      _sjVw::I64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckaM; else goto ckaN;
  ckaN:
      if (HpLim == 0) goto ckaM; else goto ckaO;
  ckaM:
      R4 = _sjVy::P64;
      R3 = _sjVx::I64;
      R2 = _sjVw::I64;
      R1 = Main.$wa2_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  ckaO:
      _sjVC::I64 = I64[_sjVy::P64 + 16];
      _sjVC::I64 = _sjVC::I64;
      _ckai::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_sjVw::I64));
      _sjVD::I64 = _ckai::I64;
      I64[(young<ckam> + 8)] = ckam;
      R3 = _sjVC::I64;
      R2 = _sjVD::I64;
      call System.Random.PCG.Fast.Pure.$wbounded_info(R3,
                                                      R2) returns to ckam, args: 8, res: 8, upd: 8;
  ckam:
      _sjVG::I64 = R2;
      _sjVF::I64 = R1;
      I64[_sjVy::P64 + 16] = _sjVF::I64;
      _sjVK::I64 = I64[_sjVy::P64 + 16];
      _sjVK::I64 = _sjVK::I64;
      _ckas::I64 = _sjVx::I64 - 2;
      _sjVL::I64 = _ckas::I64;
      _ckav::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_sjVL::I64));
      _sjVM::I64 = _ckav::I64;
      I64[(young<ckay> + 8)] = ckay;
      R3 = _sjVK::I64;
      R2 = _sjVM::I64;
      call System.Random.PCG.Fast.Pure.$wbounded_info(R3,
                                                      R2) returns to ckay, args: 8, res: 8, upd: 8;
  ckay:
      _sjVP::I64 = R2;
      _sjVO::I64 = R1;
      goto ckaz;
  ckaz:
      Hp = Hp + 96;
      if (Hp > HpLim) goto ckaS; else goto ckaR;
  ckaS:
      HpAlloc = 96;
      I64[(young<ckaA> + 8)] = ckaA;
      call stg_gc_noregs() returns to ckaA, args: 8, res: 8, upd: 8;
  ckaA:
      goto ckaz;
  ckaR:
      I64[_sjVy::P64 + 16] = _sjVO::I64;
      I64[Hp - 88] = Data.Primitive.ByteArray.MutableByteArray_con_info;
      P64[Hp - 80] = _sjVy::P64;
      _ckaE::P64 = Hp - 87;
      _ckaF::I64 = _sjVP::I64 + 1;
      _sjVS::I64 = _ckaF::I64;
      I64[Hp - 72] = GHC.Types.W#_con_info;
      I64[Hp - 64] = _sjVS::I64;
      _ckaI::P64 = Hp - 71;
      I64[Hp - 56] = GHC.Types.W#_con_info;
      I64[Hp - 48] = _sjVG::I64;
      _ckaJ::P64 = Hp - 55;
      I64[Hp - 40] = (,)_con_info;
      P64[Hp - 32] = _ckaJ::P64;
      P64[Hp - 24] = _ckaI::P64;
      _ckaK::P64 = Hp - 39;
      I64[Hp - 16] = (,)_con_info;
      P64[Hp - 8] = _ckaK::P64;
      P64[Hp] = _ckaE::P64;
      _ckaL::P64 = Hp - 15;
      R1 = _ckaL::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:52.227758 UTC

{offset
  ckak:
      _sjVy::P64 = R4;
      _sjVx::I64 = R3;
      _sjVw::I64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckaM; else goto ckaN;
  ckaN:
      if (HpLim == 0) goto ckaM; else goto ckaO;
  ckaM:
      R4 = _sjVy::P64;
      R3 = _sjVx::I64;
      R2 = _sjVw::I64;
      R1 = Main.$wa2_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  ckaO:
      _sjVC::I64 = I64[_sjVy::P64 + 16];
      _sjVC::I64 = _sjVC::I64;
      _ckai::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_sjVw::I64));
      _sjVD::I64 = _ckai::I64;
      I64[(young<ckam> + 8)] = ckam;
      R3 = _sjVC::I64;
      R2 = _sjVD::I64;
      call System.Random.PCG.Fast.Pure.$wbounded_info(R3,
                                                      R2) returns to ckam, args: 8, res: 8, upd: 8;
  ckam:
      _sjVG::I64 = R2;
      _sjVF::I64 = R1;
      I64[_sjVy::P64 + 16] = _sjVF::I64;
      _sjVK::I64 = I64[_sjVy::P64 + 16];
      _sjVK::I64 = _sjVK::I64;
      _ckas::I64 = _sjVx::I64 - 2;
      _sjVL::I64 = _ckas::I64;
      _ckav::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_sjVL::I64));
      _sjVM::I64 = _ckav::I64;
      I64[(young<ckay> + 8)] = ckay;
      R3 = _sjVK::I64;
      R2 = _sjVM::I64;
      call System.Random.PCG.Fast.Pure.$wbounded_info(R3,
                                                      R2) returns to ckay, args: 8, res: 8, upd: 8;
  ckay:
      _sjVP::I64 = R2;
      _sjVO::I64 = R1;
      goto ckaz;
  ckaz:
      Hp = Hp + 96;
      if (Hp > HpLim) goto ckaS; else goto ckaR;
  ckaS:
      HpAlloc = 96;
      I64[(young<ckaA> + 8)] = ckaA;
      call stg_gc_noregs() returns to ckaA, args: 8, res: 8, upd: 8;
  ckaA:
      goto ckaz;
  ckaR:
      I64[_sjVy::P64 + 16] = _sjVO::I64;
      I64[Hp - 88] = Data.Primitive.ByteArray.MutableByteArray_con_info;
      P64[Hp - 80] = _sjVy::P64;
      _ckaE::P64 = Hp - 87;
      _ckaF::I64 = _sjVP::I64 + 1;
      _sjVS::I64 = _ckaF::I64;
      I64[Hp - 72] = GHC.Types.W#_con_info;
      I64[Hp - 64] = _sjVS::I64;
      _ckaI::P64 = Hp - 71;
      I64[Hp - 56] = GHC.Types.W#_con_info;
      I64[Hp - 48] = _sjVG::I64;
      _ckaJ::P64 = Hp - 55;
      I64[Hp - 40] = (,)_con_info;
      P64[Hp - 32] = _ckaJ::P64;
      P64[Hp - 24] = _ckaI::P64;
      _ckaK::P64 = Hp - 39;
      I64[Hp - 16] = (,)_con_info;
      P64[Hp - 8] = _ckaK::P64;
      P64[Hp] = _ckaE::P64;
      _ckaL::P64 = Hp - 15;
      R1 = _ckaL::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:52.231563 UTC

{offset
  ckak:
      _sjVy::P64 = R4;
      _sjVx::I64 = R3;
      _sjVw::I64 = R2;
      if ((Sp + 8) - 48 < SpLim) goto ckaM; else goto ckaN;
  ckaN:
      if (HpLim == 0) goto ckaM; else goto ckaO;
  ckaM:
      R4 = _sjVy::P64;
      R3 = _sjVx::I64;
      R2 = _sjVw::I64;
      R1 = Main.$wa2_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  ckaO:
      _sjVC::I64 = I64[_sjVy::P64 + 16];
      _sjVC::I64 = _sjVC::I64;
      _ckai::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_sjVw::I64));
      _sjVD::I64 = _ckai::I64;
      I64[Sp - 24] = ckam;
      R3 = _sjVC::I64;
      R2 = _sjVD::I64;
      I64[Sp - 16] = _sjVx::I64;
      P64[Sp - 8] = _sjVy::P64;
      Sp = Sp - 24;
      call System.Random.PCG.Fast.Pure.$wbounded_info(R3,
                                                      R2) returns to ckam, args: 8, res: 8, upd: 8;
  ckam:
      _sjVx::I64 = I64[Sp + 8];
      _sjVy::P64 = P64[Sp + 16];
      _sjVG::I64 = R2;
      _sjVF::I64 = R1;
      I64[_sjVy::P64 + 16] = _sjVF::I64;
      _sjVK::I64 = I64[_sjVy::P64 + 16];
      _sjVK::I64 = _sjVK::I64;
      _ckas::I64 = _sjVx::I64 - 2;
      _sjVL::I64 = _ckas::I64;
      _ckav::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_sjVL::I64));
      _sjVM::I64 = _ckav::I64;
      I64[Sp] = ckay;
      R3 = _sjVK::I64;
      R2 = _sjVM::I64;
      I64[Sp + 8] = _sjVG::I64;
      call System.Random.PCG.Fast.Pure.$wbounded_info(R3,
                                                      R2) returns to ckay, args: 8, res: 8, upd: 8;
  ckay:
      _sjVy::P64 = P64[Sp + 16];
      _sjVG::I64 = I64[Sp + 8];
      _sjVP::I64 = R2;
      _sjVO::I64 = R1;
      goto ckaz;
  ckaz:
      Hp = Hp + 96;
      if (Hp > HpLim) goto ckaS; else goto ckaR;
  ckaS:
      HpAlloc = 96;
      I64[Sp - 16] = ckaA;
      I64[Sp - 8] = _sjVP::I64;
      I64[Sp] = _sjVO::I64;
      Sp = Sp - 16;
      call stg_gc_noregs() returns to ckaA, args: 8, res: 8, upd: 8;
  ckaA:
      _sjVy::P64 = P64[Sp + 32];
      _sjVG::I64 = I64[Sp + 24];
      _sjVO::I64 = I64[Sp + 16];
      _sjVP::I64 = I64[Sp + 8];
      goto ukaT;
  ukaT:
      Sp = Sp + 16;
      goto ckaz;
  ckaR:
      I64[_sjVy::P64 + 16] = _sjVO::I64;
      I64[Hp - 88] = Data.Primitive.ByteArray.MutableByteArray_con_info;
      P64[Hp - 80] = _sjVy::P64;
      _ckaE::P64 = Hp - 87;
      _ckaF::I64 = _sjVP::I64 + 1;
      _sjVS::I64 = _ckaF::I64;
      I64[Hp - 72] = GHC.Types.W#_con_info;
      I64[Hp - 64] = _sjVS::I64;
      _ckaI::P64 = Hp - 71;
      I64[Hp - 56] = GHC.Types.W#_con_info;
      I64[Hp - 48] = _sjVG::I64;
      _ckaJ::P64 = Hp - 55;
      I64[Hp - 40] = (,)_con_info;
      P64[Hp - 32] = _ckaJ::P64;
      P64[Hp - 24] = _ckaI::P64;
      _ckaK::P64 = Hp - 39;
      I64[Hp - 16] = (,)_con_info;
      P64[Hp - 8] = _ckaK::P64;
      P64[Hp] = _ckaE::P64;
      _ckaL::P64 = Hp - 15;
      R1 = _ckaL::P64;
      Sp = Sp + 24;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:52.23587 UTC

{offset
  ckak:
      _sjVy::P64 = R4;
      _sjVx::I64 = R3;
      _sjVw::I64 = R2;
      if ((Sp + -40) < SpLim) goto ckaM; else goto ckaN;
  ckaN:
      if (HpLim == 0) goto ckaM; else goto ckaO;
  ckaM:
      R4 = _sjVy::P64;
      R3 = _sjVx::I64;
      R2 = _sjVw::I64;
      R1 = Main.$wa2_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  ckaO:
      I64[Sp - 24] = ckam;
      R3 = I64[_sjVy::P64 + 16];
      R2 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_sjVw::I64));
      I64[Sp - 16] = _sjVx::I64;
      P64[Sp - 8] = _sjVy::P64;
      Sp = Sp - 24;
      call System.Random.PCG.Fast.Pure.$wbounded_info(R3,
                                                      R2) returns to ckam, args: 8, res: 8, upd: 8;
  ckam:
      _sjVy::P64 = P64[Sp + 16];
      I64[_sjVy::P64 + 16] = R1;
      I64[Sp] = ckay;
      R3 = I64[_sjVy::P64 + 16];
      _sjVG::I64 = R2;
      R2 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[Sp + 8] - 2));
      I64[Sp + 8] = _sjVG::I64;
      call System.Random.PCG.Fast.Pure.$wbounded_info(R3,
                                                      R2) returns to ckay, args: 8, res: 8, upd: 8;
  ckay:
      _sjVy::P64 = P64[Sp + 16];
      _sjVG::I64 = I64[Sp + 8];
      _sjVP::I64 = R2;
      _sjVO::I64 = R1;
      goto ckaz;
  ckaz:
      Hp = Hp + 96;
      if (Hp > HpLim) goto ckaS; else goto ckaR;
  ckaS:
      HpAlloc = 96;
      I64[Sp - 16] = ckaA;
      I64[Sp - 8] = _sjVP::I64;
      I64[Sp] = _sjVO::I64;
      Sp = Sp - 16;
      call stg_gc_noregs() returns to ckaA, args: 8, res: 8, upd: 8;
  ckaA:
      goto ukaT;
  ukaT:
      _sjVy::P64 = P64[Sp + 32];
      _sjVG::I64 = I64[Sp + 24];
      _sjVO::I64 = I64[Sp + 16];
      _sjVP::I64 = I64[Sp + 8];
      Sp = Sp + 16;
      goto ckaz;
  ckaR:
      I64[_sjVy::P64 + 16] = _sjVO::I64;
      I64[Hp - 88] = Data.Primitive.ByteArray.MutableByteArray_con_info;
      P64[Hp - 80] = _sjVy::P64;
      I64[Hp - 72] = GHC.Types.W#_con_info;
      I64[Hp - 64] = _sjVP::I64 + 1;
      I64[Hp - 56] = GHC.Types.W#_con_info;
      I64[Hp - 48] = _sjVG::I64;
      I64[Hp - 40] = (,)_con_info;
      P64[Hp - 32] = Hp - 55;
      P64[Hp - 24] = Hp - 71;
      I64[Hp - 16] = (,)_con_info;
      P64[Hp - 8] = Hp - 39;
      P64[Hp] = Hp - 87;
      R1 = Hp - 15;
      Sp = Sp + 24;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:52.240054 UTC

[(ckak,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   Main.$wa2_closure}),
 (ckam, {System.Random.PCG.Fast.Pure.$wbounded_closure}),
 (ckay, {}), (ckaz, {}), (ckaA, {}), (ckaM, {Main.$wa2_closure}),
 (ckaN,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   Main.$wa2_closure}),
 (ckaO, {System.Random.PCG.Fast.Pure.$wbounded_closure}),
 (ckaR, {}), (ckaS, {}), (ukaT, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:52.240847 UTC

Main.$wa2_entry() //  [R4, R3, R2]
        { info_tbl: [(ckak,
                      label: Main.$wa2_info
                      rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 17} }),
                     (ckam,
                      label: block_ckam_info
                      rep:StackRep [True, False]),
                     (ckay,
                      label: block_ckay_info
                      rep:StackRep [True, False]),
                     (ckaA,
                      label: block_ckaA_info
                      rep:StackRep [True, True, True, False])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckak:
          _sjVy::P64 = R4;
          _sjVx::I64 = R3;
          _sjVw::I64 = R2;
          if ((Sp + -40) < SpLim) goto ckaM; else goto ckaN;
      ckaN:
          if (HpLim == 0) goto ckaM; else goto ckaO;
      ckaM:
          R4 = _sjVy::P64;
          R3 = _sjVx::I64;
          R2 = _sjVw::I64;
          R1 = Main.$wa2_closure;
          call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
      ckaO:
          I64[Sp - 24] = ckam;
          R3 = I64[_sjVy::P64 + 16];
          R2 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_sjVw::I64));
          I64[Sp - 16] = _sjVx::I64;
          P64[Sp - 8] = _sjVy::P64;
          Sp = Sp - 24;
          call System.Random.PCG.Fast.Pure.$wbounded_info(R3,
                                                          R2) returns to ckam, args: 8, res: 8, upd: 8;
      ckam:
          _sjVy::P64 = P64[Sp + 16];
          I64[_sjVy::P64 + 16] = R1;
          I64[Sp] = ckay;
          R3 = I64[_sjVy::P64 + 16];
          _sjVG::I64 = R2;
          R2 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[Sp + 8] - 2));
          I64[Sp + 8] = _sjVG::I64;
          call System.Random.PCG.Fast.Pure.$wbounded_info(R3,
                                                          R2) returns to ckay, args: 8, res: 8, upd: 8;
      ckay:
          _sjVy::P64 = P64[Sp + 16];
          _sjVG::I64 = I64[Sp + 8];
          _sjVP::I64 = R2;
          _sjVO::I64 = R1;
          goto ckaz;
      ckaz:
          Hp = Hp + 96;
          if (Hp > HpLim) goto ckaS; else goto ckaR;
      ckaS:
          HpAlloc = 96;
          I64[Sp - 16] = ckaA;
          I64[Sp - 8] = _sjVP::I64;
          I64[Sp] = _sjVO::I64;
          Sp = Sp - 16;
          call stg_gc_noregs() returns to ckaA, args: 8, res: 8, upd: 8;
      ckaA:
          goto ukaT;
      ukaT:
          _sjVy::P64 = P64[Sp + 32];
          _sjVG::I64 = I64[Sp + 24];
          _sjVO::I64 = I64[Sp + 16];
          _sjVP::I64 = I64[Sp + 8];
          Sp = Sp + 16;
          goto ckaz;
      ckaR:
          I64[_sjVy::P64 + 16] = _sjVO::I64;
          I64[Hp - 88] = Data.Primitive.ByteArray.MutableByteArray_con_info;
          P64[Hp - 80] = _sjVy::P64;
          I64[Hp - 72] = GHC.Types.W#_con_info;
          I64[Hp - 64] = _sjVP::I64 + 1;
          I64[Hp - 56] = GHC.Types.W#_con_info;
          I64[Hp - 48] = _sjVG::I64;
          I64[Hp - 40] = (,)_con_info;
          P64[Hp - 32] = Hp - 55;
          P64[Hp - 24] = Hp - 71;
          I64[Hp - 16] = (,)_con_info;
          P64[Hp - 8] = Hp - 39;
          P64[Hp] = Hp - 87;
          R1 = Hp - 15;
          Sp = Sp + 24;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.245229 UTC

Main.$wa2_entry() //  [R4, R3, R2]
        { info_tbl: [(ckak,
                      label: Main.$wa2_info
                      rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 17} }),
                     (ckam,
                      label: block_ckam_info
                      rep:StackRep [True, False]),
                     (ckay,
                      label: block_ckay_info
                      rep:StackRep [True, False]),
                     (ckaA,
                      label: block_ckaA_info
                      rep:StackRep [True, True, True, False])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckak:
          _sjVy::P64 = R4;
          _sjVx::I64 = R3;
          _sjVw::I64 = R2;
          if ((Sp + -40) < SpLim) goto ckaM; else goto ckaN;
      ckaN:
          if (HpLim == 0) goto ckaM; else goto ckaO;
      ckaM:
          R4 = _sjVy::P64;
          R3 = _sjVx::I64;
          R2 = _sjVw::I64;
          R1 = Main.$wa2_closure;
          call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
      ckaO:
          I64[Sp - 24] = ckam;
          R3 = I64[_sjVy::P64 + 16];
          R2 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_sjVw::I64));
          I64[Sp - 16] = _sjVx::I64;
          P64[Sp - 8] = _sjVy::P64;
          Sp = Sp - 24;
          call System.Random.PCG.Fast.Pure.$wbounded_info(R3,
                                                          R2) returns to ckam, args: 8, res: 8, upd: 8;
      ckam:
          _sjVy::P64 = P64[Sp + 16];
          I64[_sjVy::P64 + 16] = R1;
          I64[Sp] = ckay;
          R3 = I64[_sjVy::P64 + 16];
          _sjVG::I64 = R2;
          R2 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[Sp + 8] - 2));
          I64[Sp + 8] = _sjVG::I64;
          call System.Random.PCG.Fast.Pure.$wbounded_info(R3,
                                                          R2) returns to ckay, args: 8, res: 8, upd: 8;
      ckay:
          _sjVy::P64 = P64[Sp + 16];
          _sjVG::I64 = I64[Sp + 8];
          _sjVP::I64 = R2;
          _sjVO::I64 = R1;
          goto ckaz;
      ckaz:
          Hp = Hp + 96;
          if (Hp > HpLim) goto ckaS; else goto ckaR;
      ckaS:
          HpAlloc = 96;
          I64[Sp - 16] = ckaA;
          I64[Sp - 8] = _sjVP::I64;
          I64[Sp] = _sjVO::I64;
          Sp = Sp - 16;
          call stg_gc_noregs() returns to ckaA, args: 8, res: 8, upd: 8;
      ckaA:
          _sjVy::P64 = P64[Sp + 32];
          _sjVG::I64 = I64[Sp + 24];
          _sjVO::I64 = I64[Sp + 16];
          _sjVP::I64 = I64[Sp + 8];
          Sp = Sp + 16;
          goto ckaz;
      ckaR:
          I64[_sjVy::P64 + 16] = _sjVO::I64;
          I64[Hp - 88] = Data.Primitive.ByteArray.MutableByteArray_con_info;
          P64[Hp - 80] = _sjVy::P64;
          I64[Hp - 72] = GHC.Types.W#_con_info;
          I64[Hp - 64] = _sjVP::I64 + 1;
          I64[Hp - 56] = GHC.Types.W#_con_info;
          I64[Hp - 48] = _sjVG::I64;
          I64[Hp - 40] = (,)_con_info;
          P64[Hp - 32] = Hp - 55;
          P64[Hp - 24] = Hp - 71;
          I64[Hp - 16] = (,)_con_info;
          P64[Hp - 8] = Hp - 39;
          P64[Hp] = Hp - 87;
          R1 = Hp - 15;
          Sp = Sp + 24;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.249595 UTC

[section "data" {
     Main.$wa2_closure:
         const Main.$wa2_info;
         const 0;
 },
 Main.$wa2_entry() //  [R4, R3, R2]
         { info_tbl: [(ckak,
                       label: Main.$wa2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 17} }),
                      (ckam,
                       label: block_ckam_info
                       rep:StackRep [True, False]),
                      (ckay,
                       label: block_ckay_info
                       rep:StackRep [True, False]),
                      (ckaA,
                       label: block_ckaA_info
                       rep:StackRep [True, True, True, False])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckak:
           _sjVy::P64 = R4;
           _sjVx::I64 = R3;
           _sjVw::I64 = R2;
           if ((Sp + -40) < SpLim) goto ckaM; else goto ckaN;
       ckaN:
           if (HpLim == 0) goto ckaM; else goto ckaO;
       ckaM:
           R4 = _sjVy::P64;
           R3 = _sjVx::I64;
           R2 = _sjVw::I64;
           R1 = Main.$wa2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckaO:
           I64[Sp - 24] = ckam;
           R3 = I64[_sjVy::P64 + 16];
           R2 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_sjVw::I64));
           I64[Sp - 16] = _sjVx::I64;
           P64[Sp - 8] = _sjVy::P64;
           Sp = Sp - 24;
           call System.Random.PCG.Fast.Pure.$wbounded_info(R3,
                                                           R2) returns to ckam, args: 8, res: 8, upd: 8;
       ckam:
           _sjVy::P64 = P64[Sp + 16];
           I64[_sjVy::P64 + 16] = R1;
           I64[Sp] = ckay;
           R3 = I64[_sjVy::P64 + 16];
           _sjVG::I64 = R2;
           R2 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[Sp + 8] - 2));
           I64[Sp + 8] = _sjVG::I64;
           call System.Random.PCG.Fast.Pure.$wbounded_info(R3,
                                                           R2) returns to ckay, args: 8, res: 8, upd: 8;
       ckay:
           _sjVy::P64 = P64[Sp + 16];
           _sjVG::I64 = I64[Sp + 8];
           _sjVP::I64 = R2;
           _sjVO::I64 = R1;
           goto ckaz;
       ckaz:
           Hp = Hp + 96;
           if (Hp > HpLim) goto ckaS; else goto ckaR;
       ckaS:
           HpAlloc = 96;
           I64[Sp - 16] = ckaA;
           I64[Sp - 8] = _sjVP::I64;
           I64[Sp] = _sjVO::I64;
           Sp = Sp - 16;
           call stg_gc_noregs() returns to ckaA, args: 8, res: 8, upd: 8;
       ckaA:
           _sjVy::P64 = P64[Sp + 32];
           _sjVG::I64 = I64[Sp + 24];
           _sjVO::I64 = I64[Sp + 16];
           _sjVP::I64 = I64[Sp + 8];
           Sp = Sp + 16;
           goto ckaz;
       ckaR:
           I64[_sjVy::P64 + 16] = _sjVO::I64;
           I64[Hp - 88] = Data.Primitive.ByteArray.MutableByteArray_con_info;
           P64[Hp - 80] = _sjVy::P64;
           I64[Hp - 72] = GHC.Types.W#_con_info;
           I64[Hp - 64] = _sjVP::I64 + 1;
           I64[Hp - 56] = GHC.Types.W#_con_info;
           I64[Hp - 48] = _sjVG::I64;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = Hp - 55;
           P64[Hp - 24] = Hp - 71;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 87;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.254474 UTC

[section "data" {
     Main.$wa2_closure:
         const Main.$wa2_info;
         const 0;
 },
 Main.$wa2_entry() //  [R4, R3, R2]
         { info_tbl: [(ckak,
                       label: Main.$wa2_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 17} }),
                      (ckam,
                       label: block_ckam_info
                       rep:StackRep [True, False]),
                      (ckay,
                       label: block_ckay_info
                       rep:StackRep [True, False]),
                      (ckaA,
                       label: block_ckaA_info
                       rep:StackRep [True, True, True, False])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckak:
           _sjVy::P64 = R4;
           _sjVx::I64 = R3;
           _sjVw::I64 = R2;
           if ((Sp + -40) < SpLim) goto ckaM; else goto ckaN;
       ckaN:
           if (HpLim == 0) goto ckaM; else goto ckaO;
       ckaM:
           R4 = _sjVy::P64;
           R3 = _sjVx::I64;
           R2 = _sjVw::I64;
           R1 = Main.$wa2_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckaO:
           I64[Sp - 24] = ckam;
           R3 = I64[_sjVy::P64 + 16];
           R2 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_sjVw::I64));
           I64[Sp - 16] = _sjVx::I64;
           P64[Sp - 8] = _sjVy::P64;
           Sp = Sp - 24;
           call System.Random.PCG.Fast.Pure.$wbounded_info(R3,
                                                           R2) returns to ckam, args: 8, res: 8, upd: 8;
       ckam:
           _sjVy::P64 = P64[Sp + 16];
           I64[_sjVy::P64 + 16] = R1;
           I64[Sp] = ckay;
           R3 = I64[_sjVy::P64 + 16];
           _sjVG::I64 = R2;
           R2 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[Sp + 8] - 2));
           I64[Sp + 8] = _sjVG::I64;
           call System.Random.PCG.Fast.Pure.$wbounded_info(R3,
                                                           R2) returns to ckay, args: 8, res: 8, upd: 8;
       ckay:
           _sjVy::P64 = P64[Sp + 16];
           _sjVG::I64 = I64[Sp + 8];
           _sjVP::I64 = R2;
           _sjVO::I64 = R1;
           goto ckaz;
       ckaz:
           Hp = Hp + 96;
           if (Hp > HpLim) goto ckaS; else goto ckaR;
       ckaS:
           HpAlloc = 96;
           I64[Sp - 16] = ckaA;
           I64[Sp - 8] = _sjVP::I64;
           I64[Sp] = _sjVO::I64;
           Sp = Sp - 16;
           call stg_gc_noregs() returns to ckaA, args: 8, res: 8, upd: 8;
       ckaA:
           _sjVy::P64 = P64[Sp + 32];
           _sjVG::I64 = I64[Sp + 24];
           _sjVO::I64 = I64[Sp + 16];
           _sjVP::I64 = I64[Sp + 8];
           Sp = Sp + 16;
           goto ckaz;
       ckaR:
           I64[_sjVy::P64 + 16] = _sjVO::I64;
           I64[Hp - 88] = Data.Primitive.ByteArray.MutableByteArray_con_info;
           P64[Hp - 80] = _sjVy::P64;
           I64[Hp - 72] = GHC.Types.W#_con_info;
           I64[Hp - 64] = _sjVP::I64 + 1;
           I64[Hp - 56] = GHC.Types.W#_con_info;
           I64[Hp - 48] = _sjVG::I64;
           I64[Hp - 40] = (,)_con_info;
           P64[Hp - 32] = Hp - 55;
           P64[Hp - 24] = Hp - 71;
           I64[Hp - 16] = (,)_con_info;
           P64[Hp - 8] = Hp - 39;
           P64[Hp] = Hp - 87;
           R1 = Hp - 15;
           Sp = Sp + 24;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.266369 UTC

[section "data" {
     Main.samples1_closure:
         const Main.samples1_info;
         const 0;
 },
 Main.samples1_entry() //  [R4, R3, R2]
         { info_tbl: [(ckbn,
                       label: Main.samples1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckbn:
           _sjVZ::P64 = R4;
           _sjVY::P64 = R3;
           _sjVX::P64 = R2;
           goto ckbi;
       ckbi:
           if ((old + 0) - <highSp> < SpLim) goto ckbw; else goto ckbx;
       ckbx:
           goto ckbh;
       ckbh:
           if (HpLim == 0) goto ckbw; else goto ckby;
       ckbw:
           R4 = _sjVZ::P64;
           R3 = _sjVY::P64;
           R2 = _sjVX::P64;
           R1 = Main.samples1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckby:
           I64[(young<ckbk> + 8)] = ckbk;
           R1 = _sjVX::P64;
           if (R1 & 7 != 0) goto ckbk; else goto ckbl;
       ckbl:
           call (I64[R1])(R1) returns to ckbk, args: 8, res: 8, upd: 8;
       ckbk:
           _sjW1::P64 = R1;
           _sjW2::I64 = I64[_sjW1::P64 + 7];
           I64[(young<ckbq> + 8)] = ckbq;
           R1 = _sjVY::P64;
           if (R1 & 7 != 0) goto ckbq; else goto ckbr;
       ckbr:
           call (I64[R1])(R1) returns to ckbq, args: 8, res: 8, upd: 8;
       ckbq:
           _sjW3::P64 = R1;
           _sjW4::I64 = I64[_sjW3::P64 + 7];
           I64[(young<ckbv> + 8)] = ckbv;
           R1 = _sjVZ::P64;
           if (R1 & 7 != 0) goto ckbv; else goto ckbB;
       ckbB:
           call (I64[R1])(R1) returns to ckbv, args: 8, res: 8, upd: 8;
       ckbv:
           _sjW5::P64 = R1;
           _sjW6::P64 = P64[_sjW5::P64 + 7];
           R4 = _sjW6::P64;
           R3 = _sjW4::I64;
           R2 = _sjW2::I64;
           call Main.$wa2_info(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.270221 UTC

{offset
  ckbn:
      _sjVZ::P64 = R4;
      _sjVY::P64 = R3;
      _sjVX::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckbw; else goto ckbx;
  ckbx:
      if (HpLim == 0) goto ckbw; else goto ckby;
  ckbw:
      R4 = _sjVZ::P64;
      R3 = _sjVY::P64;
      R2 = _sjVX::P64;
      R1 = Main.samples1_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  ckby:
      I64[(young<ckbk> + 8)] = ckbk;
      R1 = _sjVX::P64;
      if (R1 & 7 != 0) goto ckbk; else goto ckbl;
  ckbl:
      call (I64[R1])(R1) returns to ckbk, args: 8, res: 8, upd: 8;
  ckbk:
      _sjW1::P64 = R1;
      _sjW2::I64 = I64[_sjW1::P64 + 7];
      I64[(young<ckbq> + 8)] = ckbq;
      R1 = _sjVY::P64;
      if (R1 & 7 != 0) goto ckbq; else goto ckbr;
  ckbr:
      call (I64[R1])(R1) returns to ckbq, args: 8, res: 8, upd: 8;
  ckbq:
      _sjW3::P64 = R1;
      _sjW4::I64 = I64[_sjW3::P64 + 7];
      I64[(young<ckbv> + 8)] = ckbv;
      R1 = _sjVZ::P64;
      if (R1 & 7 != 0) goto ckbv; else goto ckbB;
  ckbB:
      call (I64[R1])(R1) returns to ckbv, args: 8, res: 8, upd: 8;
  ckbv:
      _sjW5::P64 = R1;
      _sjW6::P64 = P64[_sjW5::P64 + 7];
      R4 = _sjW6::P64;
      R3 = _sjW4::I64;
      R2 = _sjW2::I64;
      call Main.$wa2_info(R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:52.272297 UTC

{offset
  ckbn:
      _sjVZ::P64 = R4;
      _sjVY::P64 = R3;
      _sjVX::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckbw; else goto ckbx;
  ckbx:
      if (HpLim == 0) goto ckbw; else goto ckby;
  ckbw:
      R4 = _sjVZ::P64;
      R3 = _sjVY::P64;
      R2 = _sjVX::P64;
      R1 = Main.samples1_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  ckby:
      I64[(young<ckbk> + 8)] = ckbk;
      R1 = _sjVX::P64;
      if (R1 & 7 != 0) goto ckbk; else goto ckbl;
  ckbl:
      call (I64[R1])(R1) returns to ckbk, args: 8, res: 8, upd: 8;
  ckbk:
      _sjW1::P64 = R1;
      _sjW2::I64 = I64[_sjW1::P64 + 7];
      I64[(young<ckbq> + 8)] = ckbq;
      R1 = _sjVY::P64;
      if (R1 & 7 != 0) goto ckbq; else goto ckbr;
  ckbr:
      call (I64[R1])(R1) returns to ckbq, args: 8, res: 8, upd: 8;
  ckbq:
      _sjW3::P64 = R1;
      _sjW4::I64 = I64[_sjW3::P64 + 7];
      I64[(young<ckbv> + 8)] = ckbv;
      R1 = _sjVZ::P64;
      if (R1 & 7 != 0) goto ckbv; else goto ckbB;
  ckbB:
      call (I64[R1])(R1) returns to ckbv, args: 8, res: 8, upd: 8;
  ckbv:
      _sjW5::P64 = R1;
      _sjW6::P64 = P64[_sjW5::P64 + 7];
      R4 = _sjW6::P64;
      R3 = _sjW4::I64;
      R2 = _sjW2::I64;
      call Main.$wa2_info(R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:52.274422 UTC

{offset
  ckbn:
      _sjVZ::P64 = R4;
      _sjVY::P64 = R3;
      _sjVX::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckbw; else goto ckbx;
  ckbx:
      if (HpLim == 0) goto ckbw; else goto ckby;
  ckbw:
      R4 = _sjVZ::P64;
      R3 = _sjVY::P64;
      R2 = _sjVX::P64;
      R1 = Main.samples1_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  ckby:
      I64[(young<ckbk> + 8)] = ckbk;
      R1 = _sjVX::P64;
      if (R1 & 7 != 0) goto ckbk; else goto ckbl;
  ckbl:
      call (I64[R1])(R1) returns to ckbk, args: 8, res: 8, upd: 8;
  ckbk:
      _sjW1::P64 = R1;
      _sjW2::I64 = I64[_sjW1::P64 + 7];
      I64[(young<ckbq> + 8)] = ckbq;
      R1 = _sjVY::P64;
      if (R1 & 7 != 0) goto ckbq; else goto ckbr;
  ckbr:
      call (I64[R1])(R1) returns to ckbq, args: 8, res: 8, upd: 8;
  ckbq:
      _sjW3::P64 = R1;
      _sjW4::I64 = I64[_sjW3::P64 + 7];
      I64[(young<ckbv> + 8)] = ckbv;
      R1 = _sjVZ::P64;
      if (R1 & 7 != 0) goto ckbv; else goto ckbB;
  ckbB:
      call (I64[R1])(R1) returns to ckbv, args: 8, res: 8, upd: 8;
  ckbv:
      _sjW5::P64 = R1;
      _sjW6::P64 = P64[_sjW5::P64 + 7];
      R4 = _sjW6::P64;
      R3 = _sjW4::I64;
      R2 = _sjW2::I64;
      call Main.$wa2_info(R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:52.276815 UTC

{offset
  ckbn:
      _sjVZ::P64 = R4;
      _sjVY::P64 = R3;
      _sjVX::P64 = R2;
      if ((Sp + 8) - 32 < SpLim) goto ckbw; else goto ckbx;
  ckbx:
      if (HpLim == 0) goto ckbw; else goto ckby;
  ckbw:
      R4 = _sjVZ::P64;
      R3 = _sjVY::P64;
      R2 = _sjVX::P64;
      R1 = Main.samples1_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  ckby:
      I64[Sp - 24] = ckbk;
      R1 = _sjVX::P64;
      P64[Sp - 16] = _sjVY::P64;
      P64[Sp - 8] = _sjVZ::P64;
      Sp = Sp - 24;
      if (R1 & 7 != 0) goto ckbk; else goto ckbl;
  ckbl:
      call (I64[R1])(R1) returns to ckbk, args: 8, res: 8, upd: 8;
  ckbk:
      _sjVY::P64 = P64[Sp + 8];
      _sjVZ::P64 = P64[Sp + 16];
      _sjW1::P64 = R1;
      _sjW2::I64 = I64[_sjW1::P64 + 7];
      I64[Sp] = ckbq;
      R1 = _sjVY::P64;
      I64[Sp + 8] = _sjW2::I64;
      if (R1 & 7 != 0) goto ckbq; else goto ckbr;
  ckbr:
      call (I64[R1])(R1) returns to ckbq, args: 8, res: 8, upd: 8;
  ckbq:
      _sjVZ::P64 = P64[Sp + 16];
      _sjW2::I64 = I64[Sp + 8];
      _sjW3::P64 = R1;
      _sjW4::I64 = I64[_sjW3::P64 + 7];
      I64[Sp] = ckbv;
      R1 = _sjVZ::P64;
      I64[Sp + 16] = _sjW4::I64;
      if (R1 & 7 != 0) goto ckbv; else goto ckbB;
  ckbB:
      call (I64[R1])(R1) returns to ckbv, args: 8, res: 8, upd: 8;
  ckbv:
      _sjW2::I64 = I64[Sp + 8];
      _sjW4::I64 = I64[Sp + 16];
      _sjW5::P64 = R1;
      _sjW6::P64 = P64[_sjW5::P64 + 7];
      R4 = _sjW6::P64;
      R3 = _sjW4::I64;
      R2 = _sjW2::I64;
      Sp = Sp + 24;
      call Main.$wa2_info(R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:52.280425 UTC

{offset
  ckbn:
      _sjVZ::P64 = R4;
      _sjVY::P64 = R3;
      _sjVX::P64 = R2;
      if ((Sp + -24) < SpLim) goto ckbw; else goto ckbx;
  ckbx:
      if (HpLim == 0) goto ckbw; else goto ckby;
  ckbw:
      R4 = _sjVZ::P64;
      R3 = _sjVY::P64;
      R2 = _sjVX::P64;
      R1 = Main.samples1_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  ckby:
      I64[Sp - 24] = ckbk;
      R1 = _sjVX::P64;
      P64[Sp - 16] = _sjVY::P64;
      P64[Sp - 8] = _sjVZ::P64;
      Sp = Sp - 24;
      if (R1 & 7 != 0) goto ckbk; else goto ckbl;
  ckbl:
      call (I64[R1])(R1) returns to ckbk, args: 8, res: 8, upd: 8;
  ckbk:
      I64[Sp] = ckbq;
      _sjW2::I64 = I64[R1 + 7];
      R1 = P64[Sp + 8];
      I64[Sp + 8] = _sjW2::I64;
      if (R1 & 7 != 0) goto ckbq; else goto ckbr;
  ckbr:
      call (I64[R1])(R1) returns to ckbq, args: 8, res: 8, upd: 8;
  ckbq:
      I64[Sp] = ckbv;
      _sjW4::I64 = I64[R1 + 7];
      R1 = P64[Sp + 16];
      I64[Sp + 16] = _sjW4::I64;
      if (R1 & 7 != 0) goto ckbv; else goto ckbB;
  ckbB:
      call (I64[R1])(R1) returns to ckbv, args: 8, res: 8, upd: 8;
  ckbv:
      R4 = P64[R1 + 7];
      R3 = I64[Sp + 16];
      R2 = I64[Sp + 8];
      Sp = Sp + 24;
      call Main.$wa2_info(R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:52.28293 UTC

[(ckbk, {Main.$wa2_closure}), (ckbl, {Main.$wa2_closure}),
 (ckbn, {Main.$wa2_closure, Main.samples1_closure}),
 (ckbq, {Main.$wa2_closure}), (ckbr, {Main.$wa2_closure}),
 (ckbv, {Main.$wa2_closure}), (ckbw, {Main.samples1_closure}),
 (ckbx, {Main.$wa2_closure, Main.samples1_closure}),
 (ckby, {Main.$wa2_closure}), (ckbB, {Main.$wa2_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:52.283767 UTC

Main.samples1_entry() //  [R4, R3, R2]
        { info_tbl: [(ckbk,
                      label: block_ckbk_info
                      rep:StackRep [False, False]),
                     (ckbn,
                      label: Main.samples1_info
                      rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} }),
                     (ckbq,
                      label: block_ckbq_info
                      rep:StackRep [True, False]),
                     (ckbv,
                      label: block_ckbv_info
                      rep:StackRep [True, True])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckbn:
          _sjVZ::P64 = R4;
          _sjVY::P64 = R3;
          _sjVX::P64 = R2;
          if ((Sp + -24) < SpLim) goto ckbw; else goto ckbx;
      ckbx:
          if (HpLim == 0) goto ckbw; else goto ckby;
      ckbw:
          R4 = _sjVZ::P64;
          R3 = _sjVY::P64;
          R2 = _sjVX::P64;
          R1 = Main.samples1_closure;
          call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
      ckby:
          I64[Sp - 24] = ckbk;
          R1 = _sjVX::P64;
          P64[Sp - 16] = _sjVY::P64;
          P64[Sp - 8] = _sjVZ::P64;
          Sp = Sp - 24;
          if (R1 & 7 != 0) goto ckbk; else goto ckbl;
      ckbl:
          call (I64[R1])(R1) returns to ckbk, args: 8, res: 8, upd: 8;
      ckbk:
          I64[Sp] = ckbq;
          _sjW2::I64 = I64[R1 + 7];
          R1 = P64[Sp + 8];
          I64[Sp + 8] = _sjW2::I64;
          if (R1 & 7 != 0) goto ckbq; else goto ckbr;
      ckbr:
          call (I64[R1])(R1) returns to ckbq, args: 8, res: 8, upd: 8;
      ckbq:
          I64[Sp] = ckbv;
          _sjW4::I64 = I64[R1 + 7];
          R1 = P64[Sp + 16];
          I64[Sp + 16] = _sjW4::I64;
          if (R1 & 7 != 0) goto ckbv; else goto ckbB;
      ckbB:
          call (I64[R1])(R1) returns to ckbv, args: 8, res: 8, upd: 8;
      ckbv:
          R4 = P64[R1 + 7];
          R3 = I64[Sp + 16];
          R2 = I64[Sp + 8];
          Sp = Sp + 24;
          call Main.$wa2_info(R4, R3, R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.286688 UTC

Main.samples1_entry() //  [R4, R3, R2]
        { info_tbl: [(ckbk,
                      label: block_ckbk_info
                      rep:StackRep [False, False]),
                     (ckbn,
                      label: Main.samples1_info
                      rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} }),
                     (ckbq,
                      label: block_ckbq_info
                      rep:StackRep [True, False]),
                     (ckbv,
                      label: block_ckbv_info
                      rep:StackRep [True, True])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckbn:
          _sjVZ::P64 = R4;
          _sjVY::P64 = R3;
          _sjVX::P64 = R2;
          if ((Sp + -24) < SpLim) goto ckbw; else goto ckbx;
      ckbx:
          if (HpLim == 0) goto ckbw; else goto ckby;
      ckbw:
          R4 = _sjVZ::P64;
          R3 = _sjVY::P64;
          R2 = _sjVX::P64;
          R1 = Main.samples1_closure;
          call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
      ckby:
          I64[Sp - 24] = ckbk;
          R1 = _sjVX::P64;
          P64[Sp - 16] = _sjVY::P64;
          P64[Sp - 8] = _sjVZ::P64;
          Sp = Sp - 24;
          if (R1 & 7 != 0) goto ckbk; else goto ckbl;
      ckbl:
          call (I64[R1])(R1) returns to ckbk, args: 8, res: 8, upd: 8;
      ckbk:
          I64[Sp] = ckbq;
          _sjW2::I64 = I64[R1 + 7];
          R1 = P64[Sp + 8];
          I64[Sp + 8] = _sjW2::I64;
          if (R1 & 7 != 0) goto ckbq; else goto ckbr;
      ckbr:
          call (I64[R1])(R1) returns to ckbq, args: 8, res: 8, upd: 8;
      ckbq:
          I64[Sp] = ckbv;
          _sjW4::I64 = I64[R1 + 7];
          R1 = P64[Sp + 16];
          I64[Sp + 16] = _sjW4::I64;
          if (R1 & 7 != 0) goto ckbv; else goto ckbB;
      ckbB:
          call (I64[R1])(R1) returns to ckbv, args: 8, res: 8, upd: 8;
      ckbv:
          R4 = P64[R1 + 7];
          R3 = I64[Sp + 16];
          R2 = I64[Sp + 8];
          Sp = Sp + 24;
          call Main.$wa2_info(R4, R3, R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.289641 UTC

[section "data" {
     Main.samples1_closure:
         const Main.samples1_info;
         const 0;
 },
 Main.samples1_entry() //  [R4, R3, R2]
         { info_tbl: [(ckbk,
                       label: block_ckbk_info
                       rep:StackRep [False, False]),
                      (ckbn,
                       label: Main.samples1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} }),
                      (ckbq,
                       label: block_ckbq_info
                       rep:StackRep [True, False]),
                      (ckbv,
                       label: block_ckbv_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckbn:
           _sjVZ::P64 = R4;
           _sjVY::P64 = R3;
           _sjVX::P64 = R2;
           if ((Sp + -24) < SpLim) goto ckbw; else goto ckbx;
       ckbx:
           if (HpLim == 0) goto ckbw; else goto ckby;
       ckbw:
           R4 = _sjVZ::P64;
           R3 = _sjVY::P64;
           R2 = _sjVX::P64;
           R1 = Main.samples1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckby:
           I64[Sp - 24] = ckbk;
           R1 = _sjVX::P64;
           P64[Sp - 16] = _sjVY::P64;
           P64[Sp - 8] = _sjVZ::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ckbk; else goto ckbl;
       ckbl:
           call (I64[R1])(R1) returns to ckbk, args: 8, res: 8, upd: 8;
       ckbk:
           I64[Sp] = ckbq;
           _sjW2::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _sjW2::I64;
           if (R1 & 7 != 0) goto ckbq; else goto ckbr;
       ckbr:
           call (I64[R1])(R1) returns to ckbq, args: 8, res: 8, upd: 8;
       ckbq:
           I64[Sp] = ckbv;
           _sjW4::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _sjW4::I64;
           if (R1 & 7 != 0) goto ckbv; else goto ckbB;
       ckbB:
           call (I64[R1])(R1) returns to ckbv, args: 8, res: 8, upd: 8;
       ckbv:
           R4 = P64[R1 + 7];
           R3 = I64[Sp + 16];
           R2 = I64[Sp + 8];
           Sp = Sp + 24;
           call Main.$wa2_info(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.292911 UTC

[section "data" {
     Main.samples1_closure:
         const Main.samples1_info;
         const 0;
 },
 Main.samples1_entry() //  [R4, R3, R2]
         { info_tbl: [(ckbk,
                       label: block_ckbk_info
                       rep:StackRep [False, False]),
                      (ckbn,
                       label: Main.samples1_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} }),
                      (ckbq,
                       label: block_ckbq_info
                       rep:StackRep [True, False]),
                      (ckbv,
                       label: block_ckbv_info
                       rep:StackRep [True, True])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckbn:
           _sjVZ::P64 = R4;
           _sjVY::P64 = R3;
           _sjVX::P64 = R2;
           if ((Sp + -24) < SpLim) goto ckbw; else goto ckbx;
       ckbx:
           if (HpLim == 0) goto ckbw; else goto ckby;
       ckbw:
           R4 = _sjVZ::P64;
           R3 = _sjVY::P64;
           R2 = _sjVX::P64;
           R1 = Main.samples1_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckby:
           I64[Sp - 24] = ckbk;
           R1 = _sjVX::P64;
           P64[Sp - 16] = _sjVY::P64;
           P64[Sp - 8] = _sjVZ::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ckbk; else goto ckbl;
       ckbl:
           call (I64[R1])(R1) returns to ckbk, args: 8, res: 8, upd: 8;
       ckbk:
           I64[Sp] = ckbq;
           _sjW2::I64 = I64[R1 + 7];
           R1 = P64[Sp + 8];
           I64[Sp + 8] = _sjW2::I64;
           if (R1 & 7 != 0) goto ckbq; else goto ckbr;
       ckbr:
           call (I64[R1])(R1) returns to ckbq, args: 8, res: 8, upd: 8;
       ckbq:
           I64[Sp] = ckbv;
           _sjW4::I64 = I64[R1 + 7];
           R1 = P64[Sp + 16];
           I64[Sp + 16] = _sjW4::I64;
           if (R1 & 7 != 0) goto ckbv; else goto ckbB;
       ckbB:
           call (I64[R1])(R1) returns to ckbv, args: 8, res: 8, upd: 8;
       ckbv:
           R4 = P64[R1 + 7];
           R3 = I64[Sp + 16];
           R2 = I64[Sp + 8];
           Sp = Sp + 24;
           call Main.$wa2_info(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.300615 UTC

[section "data" {
     Main.runRSTMSingle'2_closure:
         const GHC.Types.W#_static_info;
         const 1;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.301015 UTC

[section "data" {
     Main.runRSTMSingle'2_closure:
         const GHC.Types.W#_static_info;
         const 1;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.301324 UTC

[section "data" {
     Main.runRSTMSingle'2_closure:
         const GHC.Types.W#_static_info;
         const 1;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.301932 UTC

[section "data" {
     lvl_rjUX_closure:
         const GHC.Word.W64#_static_info;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.30228 UTC

[section "data" {
     lvl_rjUX_closure:
         const GHC.Word.W64#_static_info;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.302603 UTC

[section "data" {
     lvl_rjUX_closure:
         const GHC.Word.W64#_static_info;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.303147 UTC

[section "data" {
     lvl1_rjUY_closure:
         const lvl1_rjUY_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ckbV_str:
         I8[] [125]
 },
 lvl1_rjUY_entry() //  [R1]
         { info_tbl: [(ckbW,
                       label: lvl1_rjUY_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckbW:
           _rjUY::P64 = R1;
           goto ckbQ;
       ckbQ:
           if ((old + 0) - <highSp> < SpLim) goto ckbX; else goto ckbY;
       ckbY:
           if (HpLim == 0) goto ckbX; else goto ckbZ;
       ckbX:
           R1 = _rjUY::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckbZ:
           (_ckbS::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjUY::P64);
           if (_ckbS::I64 == 0) goto ckbU; else goto ckbT;
       ckbU:
           call (I64[_rjUY::P64])() args: 8, res: 0, upd: 8;
       ckbT:
           I64[(old + 24)] = stg_bh_upd_frame_info;
           I64[(old + 16)] = _ckbS::I64;
           R2 = ckbV_str;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.305257 UTC

{offset
  ckbW:
      _rjUY::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckbX; else goto ckbY;
  ckbY:
      if (HpLim == 0) goto ckbX; else goto ckbZ;
  ckbX:
      R1 = _rjUY::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckbZ:
      (_ckbS::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjUY::P64);
      if (_ckbS::I64 == 0) goto ckbU; else goto ckbT;
  ckbU:
      call (I64[_rjUY::P64])() args: 8, res: 0, upd: 8;
  ckbT:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckbS::I64;
      R2 = ckbV_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:52.306371 UTC

{offset
  ckbW:
      _rjUY::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckbX; else goto ckbY;
  ckbY:
      if (HpLim == 0) goto ckbX; else goto ckbZ;
  ckbX:
      R1 = _rjUY::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckbZ:
      (_ckbS::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjUY::P64);
      if (_ckbS::I64 == 0) goto ckbU; else goto ckbT;
  ckbU:
      call (I64[_rjUY::P64])() args: 8, res: 0, upd: 8;
  ckbT:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckbS::I64;
      R2 = ckbV_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:52.307522 UTC

{offset
  ckbW:
      _rjUY::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckbX; else goto ckbY;
  ckbY:
      if (HpLim == 0) goto ckbX; else goto ckbZ;
  ckbX:
      R1 = _rjUY::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckbZ:
      (_ckbS::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjUY::P64);
      if (_ckbS::I64 == 0) goto ckbU; else goto ckbT;
  ckbU:
      call (I64[_rjUY::P64])() args: 8, res: 0, upd: 8;
  ckbT:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckbS::I64;
      R2 = ckbV_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:52.30869 UTC

{offset
  ckbW:
      _rjUY::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto ckbX; else goto ckbY;
  ckbY:
      if (HpLim == 0) goto ckbX; else goto ckbZ;
  ckbX:
      R1 = _rjUY::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckbZ:
      (_ckbS::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjUY::P64);
      if (_ckbS::I64 == 0) goto ckbU; else goto ckbT;
  ckbU:
      call (I64[_rjUY::P64])() args: 8, res: 0, upd: 8;
  ckbT:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _ckbS::I64;
      R2 = ckbV_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:52.309848 UTC

{offset
  ckbW:
      _rjUY::P64 = R1;
      if ((Sp + -16) < SpLim) goto ckbX; else goto ckbY;
  ckbY:
      if (HpLim == 0) goto ckbX; else goto ckbZ;
  ckbX:
      R1 = _rjUY::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckbZ:
      (_ckbS::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjUY::P64);
      if (_ckbS::I64 == 0) goto ckbU; else goto ckbT;
  ckbU:
      call (I64[_rjUY::P64])() args: 8, res: 0, upd: 8;
  ckbT:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _ckbS::I64;
      R2 = ckbV_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:52.311132 UTC

[(ckbT, {}), (ckbU, {}), (ckbW, {}), (ckbX, {}), (ckbY, {}),
 (ckbZ, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:52.311511 UTC

lvl1_rjUY_entry() //  [R1]
        { info_tbl: [(ckbW,
                      label: lvl1_rjUY_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckbW:
          _rjUY::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckbX; else goto ckbY;
      ckbY:
          if (HpLim == 0) goto ckbX; else goto ckbZ;
      ckbX:
          R1 = _rjUY::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckbZ:
          (_ckbS::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjUY::P64);
          if (_ckbS::I64 == 0) goto ckbU; else goto ckbT;
      ckbU:
          call (I64[_rjUY::P64])() args: 8, res: 0, upd: 8;
      ckbT:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _ckbS::I64;
          R2 = ckbV_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.312885 UTC

lvl1_rjUY_entry() //  [R1]
        { info_tbl: [(ckbW,
                      label: lvl1_rjUY_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckbW:
          _rjUY::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckbX; else goto ckbY;
      ckbY:
          if (HpLim == 0) goto ckbX; else goto ckbZ;
      ckbX:
          R1 = _rjUY::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckbZ:
          (_ckbS::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjUY::P64);
          if (_ckbS::I64 == 0) goto ckbU; else goto ckbT;
      ckbU:
          call (I64[_rjUY::P64])() args: 8, res: 0, upd: 8;
      ckbT:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _ckbS::I64;
          R2 = ckbV_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.314786 UTC

[section "data" {
     lvl1_rjUY_closure:
         const lvl1_rjUY_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ckbV_str:
         I8[] [125]
 },
 lvl1_rjUY_entry() //  [R1]
         { info_tbl: [(ckbW,
                       label: lvl1_rjUY_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckbW:
           _rjUY::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckbX; else goto ckbY;
       ckbY:
           if (HpLim == 0) goto ckbX; else goto ckbZ;
       ckbX:
           R1 = _rjUY::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckbZ:
           (_ckbS::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjUY::P64);
           if (_ckbS::I64 == 0) goto ckbU; else goto ckbT;
       ckbU:
           call (I64[_rjUY::P64])() args: 8, res: 0, upd: 8;
       ckbT:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ckbS::I64;
           R2 = ckbV_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.316507 UTC

[section "data" {
     lvl1_rjUY_closure:
         const lvl1_rjUY_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ckbV_str:
         I8[] [125]
 },
 lvl1_rjUY_entry() //  [R1]
         { info_tbl: [(ckbW,
                       label: lvl1_rjUY_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckbW:
           _rjUY::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckbX; else goto ckbY;
       ckbY:
           if (HpLim == 0) goto ckbX; else goto ckbZ;
       ckbX:
           R1 = _rjUY::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckbZ:
           (_ckbS::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjUY::P64);
           if (_ckbS::I64 == 0) goto ckbU; else goto ckbT;
       ckbU:
           call (I64[_rjUY::P64])() args: 8, res: 0, upd: 8;
       ckbT:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ckbS::I64;
           R2 = ckbV_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.321109 UTC

[section "data" {
     lvl2_rjUZ_closure:
         const lvl2_rjUZ_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ckcc_str:
         I8[] [95,116,104,114,111,117,103,104,112,117,116,32,61,32]
 },
 lvl2_rjUZ_entry() //  [R1]
         { info_tbl: [(ckcd,
                       label: lvl2_rjUZ_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckcd:
           _rjUZ::P64 = R1;
           goto ckc7;
       ckc7:
           if ((old + 0) - <highSp> < SpLim) goto ckce; else goto ckcf;
       ckcf:
           if (HpLim == 0) goto ckce; else goto ckcg;
       ckce:
           R1 = _rjUZ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckcg:
           (_ckc9::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjUZ::P64);
           if (_ckc9::I64 == 0) goto ckcb; else goto ckca;
       ckcb:
           call (I64[_rjUZ::P64])() args: 8, res: 0, upd: 8;
       ckca:
           I64[(old + 24)] = stg_bh_upd_frame_info;
           I64[(old + 16)] = _ckc9::I64;
           R2 = ckcc_str;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.323228 UTC

{offset
  ckcd:
      _rjUZ::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckce; else goto ckcf;
  ckcf:
      if (HpLim == 0) goto ckce; else goto ckcg;
  ckce:
      R1 = _rjUZ::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckcg:
      (_ckc9::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjUZ::P64);
      if (_ckc9::I64 == 0) goto ckcb; else goto ckca;
  ckcb:
      call (I64[_rjUZ::P64])() args: 8, res: 0, upd: 8;
  ckca:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckc9::I64;
      R2 = ckcc_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:52.324336 UTC

{offset
  ckcd:
      _rjUZ::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckce; else goto ckcf;
  ckcf:
      if (HpLim == 0) goto ckce; else goto ckcg;
  ckce:
      R1 = _rjUZ::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckcg:
      (_ckc9::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjUZ::P64);
      if (_ckc9::I64 == 0) goto ckcb; else goto ckca;
  ckcb:
      call (I64[_rjUZ::P64])() args: 8, res: 0, upd: 8;
  ckca:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckc9::I64;
      R2 = ckcc_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:52.325462 UTC

{offset
  ckcd:
      _rjUZ::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckce; else goto ckcf;
  ckcf:
      if (HpLim == 0) goto ckce; else goto ckcg;
  ckce:
      R1 = _rjUZ::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckcg:
      (_ckc9::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjUZ::P64);
      if (_ckc9::I64 == 0) goto ckcb; else goto ckca;
  ckcb:
      call (I64[_rjUZ::P64])() args: 8, res: 0, upd: 8;
  ckca:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckc9::I64;
      R2 = ckcc_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:52.326621 UTC

{offset
  ckcd:
      _rjUZ::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto ckce; else goto ckcf;
  ckcf:
      if (HpLim == 0) goto ckce; else goto ckcg;
  ckce:
      R1 = _rjUZ::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckcg:
      (_ckc9::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjUZ::P64);
      if (_ckc9::I64 == 0) goto ckcb; else goto ckca;
  ckcb:
      call (I64[_rjUZ::P64])() args: 8, res: 0, upd: 8;
  ckca:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _ckc9::I64;
      R2 = ckcc_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:52.327782 UTC

{offset
  ckcd:
      _rjUZ::P64 = R1;
      if ((Sp + -16) < SpLim) goto ckce; else goto ckcf;
  ckcf:
      if (HpLim == 0) goto ckce; else goto ckcg;
  ckce:
      R1 = _rjUZ::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckcg:
      (_ckc9::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjUZ::P64);
      if (_ckc9::I64 == 0) goto ckcb; else goto ckca;
  ckcb:
      call (I64[_rjUZ::P64])() args: 8, res: 0, upd: 8;
  ckca:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _ckc9::I64;
      R2 = ckcc_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:52.329096 UTC

[(ckca, {}), (ckcb, {}), (ckcd, {}), (ckce, {}), (ckcf, {}),
 (ckcg, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:52.329479 UTC

lvl2_rjUZ_entry() //  [R1]
        { info_tbl: [(ckcd,
                      label: lvl2_rjUZ_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckcd:
          _rjUZ::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckce; else goto ckcf;
      ckcf:
          if (HpLim == 0) goto ckce; else goto ckcg;
      ckce:
          R1 = _rjUZ::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckcg:
          (_ckc9::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjUZ::P64);
          if (_ckc9::I64 == 0) goto ckcb; else goto ckca;
      ckcb:
          call (I64[_rjUZ::P64])() args: 8, res: 0, upd: 8;
      ckca:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _ckc9::I64;
          R2 = ckcc_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.330856 UTC

lvl2_rjUZ_entry() //  [R1]
        { info_tbl: [(ckcd,
                      label: lvl2_rjUZ_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckcd:
          _rjUZ::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckce; else goto ckcf;
      ckcf:
          if (HpLim == 0) goto ckce; else goto ckcg;
      ckce:
          R1 = _rjUZ::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckcg:
          (_ckc9::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjUZ::P64);
          if (_ckc9::I64 == 0) goto ckcb; else goto ckca;
      ckcb:
          call (I64[_rjUZ::P64])() args: 8, res: 0, upd: 8;
      ckca:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _ckc9::I64;
          R2 = ckcc_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.332256 UTC

[section "data" {
     lvl2_rjUZ_closure:
         const lvl2_rjUZ_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ckcc_str:
         I8[] [95,116,104,114,111,117,103,104,112,117,116,32,61,32]
 },
 lvl2_rjUZ_entry() //  [R1]
         { info_tbl: [(ckcd,
                       label: lvl2_rjUZ_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckcd:
           _rjUZ::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckce; else goto ckcf;
       ckcf:
           if (HpLim == 0) goto ckce; else goto ckcg;
       ckce:
           R1 = _rjUZ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckcg:
           (_ckc9::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjUZ::P64);
           if (_ckc9::I64 == 0) goto ckcb; else goto ckca;
       ckcb:
           call (I64[_rjUZ::P64])() args: 8, res: 0, upd: 8;
       ckca:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ckc9::I64;
           R2 = ckcc_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.333986 UTC

[section "data" {
     lvl2_rjUZ_closure:
         const lvl2_rjUZ_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ckcc_str:
         I8[] [95,116,104,114,111,117,103,104,112,117,116,32,61,32]
 },
 lvl2_rjUZ_entry() //  [R1]
         { info_tbl: [(ckcd,
                       label: lvl2_rjUZ_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckcd:
           _rjUZ::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckce; else goto ckcf;
       ckcf:
           if (HpLim == 0) goto ckce; else goto ckcg;
       ckce:
           R1 = _rjUZ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckcg:
           (_ckc9::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjUZ::P64);
           if (_ckc9::I64 == 0) goto ckcb; else goto ckca;
       ckcb:
           call (I64[_rjUZ::P64])() args: 8, res: 0, upd: 8;
       ckca:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ckc9::I64;
           R2 = ckcc_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.338678 UTC

[section "data" {
     lvl3_rjV0_closure:
         const lvl3_rjV0_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ckct_str:
         I8[] [44,32]
 },
 lvl3_rjV0_entry() //  [R1]
         { info_tbl: [(ckcu,
                       label: lvl3_rjV0_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckcu:
           _rjV0::P64 = R1;
           goto ckco;
       ckco:
           if ((old + 0) - <highSp> < SpLim) goto ckcv; else goto ckcw;
       ckcw:
           if (HpLim == 0) goto ckcv; else goto ckcx;
       ckcv:
           R1 = _rjV0::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckcx:
           (_ckcq::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV0::P64);
           if (_ckcq::I64 == 0) goto ckcs; else goto ckcr;
       ckcs:
           call (I64[_rjV0::P64])() args: 8, res: 0, upd: 8;
       ckcr:
           I64[(old + 24)] = stg_bh_upd_frame_info;
           I64[(old + 16)] = _ckcq::I64;
           R2 = ckct_str;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.340802 UTC

{offset
  ckcu:
      _rjV0::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckcv; else goto ckcw;
  ckcw:
      if (HpLim == 0) goto ckcv; else goto ckcx;
  ckcv:
      R1 = _rjV0::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckcx:
      (_ckcq::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV0::P64);
      if (_ckcq::I64 == 0) goto ckcs; else goto ckcr;
  ckcs:
      call (I64[_rjV0::P64])() args: 8, res: 0, upd: 8;
  ckcr:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckcq::I64;
      R2 = ckct_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:52.341907 UTC

{offset
  ckcu:
      _rjV0::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckcv; else goto ckcw;
  ckcw:
      if (HpLim == 0) goto ckcv; else goto ckcx;
  ckcv:
      R1 = _rjV0::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckcx:
      (_ckcq::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV0::P64);
      if (_ckcq::I64 == 0) goto ckcs; else goto ckcr;
  ckcs:
      call (I64[_rjV0::P64])() args: 8, res: 0, upd: 8;
  ckcr:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckcq::I64;
      R2 = ckct_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:52.343037 UTC

{offset
  ckcu:
      _rjV0::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckcv; else goto ckcw;
  ckcw:
      if (HpLim == 0) goto ckcv; else goto ckcx;
  ckcv:
      R1 = _rjV0::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckcx:
      (_ckcq::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV0::P64);
      if (_ckcq::I64 == 0) goto ckcs; else goto ckcr;
  ckcs:
      call (I64[_rjV0::P64])() args: 8, res: 0, upd: 8;
  ckcr:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckcq::I64;
      R2 = ckct_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:52.344192 UTC

{offset
  ckcu:
      _rjV0::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto ckcv; else goto ckcw;
  ckcw:
      if (HpLim == 0) goto ckcv; else goto ckcx;
  ckcv:
      R1 = _rjV0::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckcx:
      (_ckcq::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV0::P64);
      if (_ckcq::I64 == 0) goto ckcs; else goto ckcr;
  ckcs:
      call (I64[_rjV0::P64])() args: 8, res: 0, upd: 8;
  ckcr:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _ckcq::I64;
      R2 = ckct_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:52.345323 UTC

{offset
  ckcu:
      _rjV0::P64 = R1;
      if ((Sp + -16) < SpLim) goto ckcv; else goto ckcw;
  ckcw:
      if (HpLim == 0) goto ckcv; else goto ckcx;
  ckcv:
      R1 = _rjV0::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckcx:
      (_ckcq::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV0::P64);
      if (_ckcq::I64 == 0) goto ckcs; else goto ckcr;
  ckcs:
      call (I64[_rjV0::P64])() args: 8, res: 0, upd: 8;
  ckcr:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _ckcq::I64;
      R2 = ckct_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:52.346615 UTC

[(ckcr, {}), (ckcs, {}), (ckcu, {}), (ckcv, {}), (ckcw, {}),
 (ckcx, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:52.347021 UTC

lvl3_rjV0_entry() //  [R1]
        { info_tbl: [(ckcu,
                      label: lvl3_rjV0_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckcu:
          _rjV0::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckcv; else goto ckcw;
      ckcw:
          if (HpLim == 0) goto ckcv; else goto ckcx;
      ckcv:
          R1 = _rjV0::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckcx:
          (_ckcq::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV0::P64);
          if (_ckcq::I64 == 0) goto ckcs; else goto ckcr;
      ckcs:
          call (I64[_rjV0::P64])() args: 8, res: 0, upd: 8;
      ckcr:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _ckcq::I64;
          R2 = ckct_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.348391 UTC

lvl3_rjV0_entry() //  [R1]
        { info_tbl: [(ckcu,
                      label: lvl3_rjV0_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckcu:
          _rjV0::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckcv; else goto ckcw;
      ckcw:
          if (HpLim == 0) goto ckcv; else goto ckcx;
      ckcv:
          R1 = _rjV0::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckcx:
          (_ckcq::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV0::P64);
          if (_ckcq::I64 == 0) goto ckcs; else goto ckcr;
      ckcs:
          call (I64[_rjV0::P64])() args: 8, res: 0, upd: 8;
      ckcr:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _ckcq::I64;
          R2 = ckct_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.350264 UTC

[section "data" {
     lvl3_rjV0_closure:
         const lvl3_rjV0_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ckct_str:
         I8[] [44,32]
 },
 lvl3_rjV0_entry() //  [R1]
         { info_tbl: [(ckcu,
                       label: lvl3_rjV0_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckcu:
           _rjV0::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckcv; else goto ckcw;
       ckcw:
           if (HpLim == 0) goto ckcv; else goto ckcx;
       ckcv:
           R1 = _rjV0::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckcx:
           (_ckcq::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV0::P64);
           if (_ckcq::I64 == 0) goto ckcs; else goto ckcr;
       ckcs:
           call (I64[_rjV0::P64])() args: 8, res: 0, upd: 8;
       ckcr:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ckcq::I64;
           R2 = ckct_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.351952 UTC

[section "data" {
     lvl3_rjV0_closure:
         const lvl3_rjV0_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ckct_str:
         I8[] [44,32]
 },
 lvl3_rjV0_entry() //  [R1]
         { info_tbl: [(ckcu,
                       label: lvl3_rjV0_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckcu:
           _rjV0::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckcv; else goto ckcw;
       ckcw:
           if (HpLim == 0) goto ckcv; else goto ckcx;
       ckcv:
           R1 = _rjV0::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckcx:
           (_ckcq::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV0::P64);
           if (_ckcq::I64 == 0) goto ckcs; else goto ckcr;
       ckcs:
           call (I64[_rjV0::P64])() args: 8, res: 0, upd: 8;
       ckcr:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ckcq::I64;
           R2 = ckct_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.356429 UTC

[section "data" {
     lvl4_rjV1_closure:
         const GHC.Types.I#_static_info;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.356817 UTC

[section "data" {
     lvl4_rjV1_closure:
         const GHC.Types.I#_static_info;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.35717 UTC

[section "data" {
     lvl4_rjV1_closure:
         const GHC.Types.I#_static_info;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.357721 UTC

[section "data" {
     lvl5_rjV2_closure:
         const lvl5_rjV2_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ckcM_str:
         I8[] [95,109,105,120,32,61,32]
 },
 lvl5_rjV2_entry() //  [R1]
         { info_tbl: [(ckcN,
                       label: lvl5_rjV2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckcN:
           _rjV2::P64 = R1;
           goto ckcH;
       ckcH:
           if ((old + 0) - <highSp> < SpLim) goto ckcO; else goto ckcP;
       ckcP:
           if (HpLim == 0) goto ckcO; else goto ckcQ;
       ckcO:
           R1 = _rjV2::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckcQ:
           (_ckcJ::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV2::P64);
           if (_ckcJ::I64 == 0) goto ckcL; else goto ckcK;
       ckcL:
           call (I64[_rjV2::P64])() args: 8, res: 0, upd: 8;
       ckcK:
           I64[(old + 24)] = stg_bh_upd_frame_info;
           I64[(old + 16)] = _ckcJ::I64;
           R2 = ckcM_str;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.359929 UTC

{offset
  ckcN:
      _rjV2::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckcO; else goto ckcP;
  ckcP:
      if (HpLim == 0) goto ckcO; else goto ckcQ;
  ckcO:
      R1 = _rjV2::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckcQ:
      (_ckcJ::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV2::P64);
      if (_ckcJ::I64 == 0) goto ckcL; else goto ckcK;
  ckcL:
      call (I64[_rjV2::P64])() args: 8, res: 0, upd: 8;
  ckcK:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckcJ::I64;
      R2 = ckcM_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:52.361024 UTC

{offset
  ckcN:
      _rjV2::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckcO; else goto ckcP;
  ckcP:
      if (HpLim == 0) goto ckcO; else goto ckcQ;
  ckcO:
      R1 = _rjV2::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckcQ:
      (_ckcJ::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV2::P64);
      if (_ckcJ::I64 == 0) goto ckcL; else goto ckcK;
  ckcL:
      call (I64[_rjV2::P64])() args: 8, res: 0, upd: 8;
  ckcK:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckcJ::I64;
      R2 = ckcM_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:52.362117 UTC

{offset
  ckcN:
      _rjV2::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckcO; else goto ckcP;
  ckcP:
      if (HpLim == 0) goto ckcO; else goto ckcQ;
  ckcO:
      R1 = _rjV2::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckcQ:
      (_ckcJ::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV2::P64);
      if (_ckcJ::I64 == 0) goto ckcL; else goto ckcK;
  ckcL:
      call (I64[_rjV2::P64])() args: 8, res: 0, upd: 8;
  ckcK:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckcJ::I64;
      R2 = ckcM_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:52.363264 UTC

{offset
  ckcN:
      _rjV2::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto ckcO; else goto ckcP;
  ckcP:
      if (HpLim == 0) goto ckcO; else goto ckcQ;
  ckcO:
      R1 = _rjV2::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckcQ:
      (_ckcJ::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV2::P64);
      if (_ckcJ::I64 == 0) goto ckcL; else goto ckcK;
  ckcL:
      call (I64[_rjV2::P64])() args: 8, res: 0, upd: 8;
  ckcK:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _ckcJ::I64;
      R2 = ckcM_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:52.364394 UTC

{offset
  ckcN:
      _rjV2::P64 = R1;
      if ((Sp + -16) < SpLim) goto ckcO; else goto ckcP;
  ckcP:
      if (HpLim == 0) goto ckcO; else goto ckcQ;
  ckcO:
      R1 = _rjV2::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckcQ:
      (_ckcJ::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV2::P64);
      if (_ckcJ::I64 == 0) goto ckcL; else goto ckcK;
  ckcL:
      call (I64[_rjV2::P64])() args: 8, res: 0, upd: 8;
  ckcK:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _ckcJ::I64;
      R2 = ckcM_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:52.365658 UTC

[(ckcK, {}), (ckcL, {}), (ckcN, {}), (ckcO, {}), (ckcP, {}),
 (ckcQ, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:52.366032 UTC

lvl5_rjV2_entry() //  [R1]
        { info_tbl: [(ckcN,
                      label: lvl5_rjV2_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckcN:
          _rjV2::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckcO; else goto ckcP;
      ckcP:
          if (HpLim == 0) goto ckcO; else goto ckcQ;
      ckcO:
          R1 = _rjV2::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckcQ:
          (_ckcJ::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV2::P64);
          if (_ckcJ::I64 == 0) goto ckcL; else goto ckcK;
      ckcL:
          call (I64[_rjV2::P64])() args: 8, res: 0, upd: 8;
      ckcK:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _ckcJ::I64;
          R2 = ckcM_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.367387 UTC

lvl5_rjV2_entry() //  [R1]
        { info_tbl: [(ckcN,
                      label: lvl5_rjV2_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckcN:
          _rjV2::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckcO; else goto ckcP;
      ckcP:
          if (HpLim == 0) goto ckcO; else goto ckcQ;
      ckcO:
          R1 = _rjV2::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckcQ:
          (_ckcJ::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV2::P64);
          if (_ckcJ::I64 == 0) goto ckcL; else goto ckcK;
      ckcL:
          call (I64[_rjV2::P64])() args: 8, res: 0, upd: 8;
      ckcK:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _ckcJ::I64;
          R2 = ckcM_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.368761 UTC

[section "data" {
     lvl5_rjV2_closure:
         const lvl5_rjV2_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ckcM_str:
         I8[] [95,109,105,120,32,61,32]
 },
 lvl5_rjV2_entry() //  [R1]
         { info_tbl: [(ckcN,
                       label: lvl5_rjV2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckcN:
           _rjV2::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckcO; else goto ckcP;
       ckcP:
           if (HpLim == 0) goto ckcO; else goto ckcQ;
       ckcO:
           R1 = _rjV2::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckcQ:
           (_ckcJ::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV2::P64);
           if (_ckcJ::I64 == 0) goto ckcL; else goto ckcK;
       ckcL:
           call (I64[_rjV2::P64])() args: 8, res: 0, upd: 8;
       ckcK:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ckcJ::I64;
           R2 = ckcM_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.370458 UTC

[section "data" {
     lvl5_rjV2_closure:
         const lvl5_rjV2_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ckcM_str:
         I8[] [95,109,105,120,32,61,32]
 },
 lvl5_rjV2_entry() //  [R1]
         { info_tbl: [(ckcN,
                       label: lvl5_rjV2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckcN:
           _rjV2::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckcO; else goto ckcP;
       ckcP:
           if (HpLim == 0) goto ckcO; else goto ckcQ;
       ckcO:
           R1 = _rjV2::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckcQ:
           (_ckcJ::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV2::P64);
           if (_ckcJ::I64 == 0) goto ckcL; else goto ckcK;
       ckcL:
           call (I64[_rjV2::P64])() args: 8, res: 0, upd: 8;
       ckcK:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ckcJ::I64;
           R2 = ckcM_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.374956 UTC

[section "data" {
     lvl6_rjV3_closure:
         const lvl6_rjV3_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ckd3_str:
         I8[] [95,97,116,111,109,105,99,71,114,111,117,112,115,32,61,32]
 },
 lvl6_rjV3_entry() //  [R1]
         { info_tbl: [(ckd4,
                       label: lvl6_rjV3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckd4:
           _rjV3::P64 = R1;
           goto ckcY;
       ckcY:
           if ((old + 0) - <highSp> < SpLim) goto ckd5; else goto ckd6;
       ckd6:
           if (HpLim == 0) goto ckd5; else goto ckd7;
       ckd5:
           R1 = _rjV3::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckd7:
           (_ckd0::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV3::P64);
           if (_ckd0::I64 == 0) goto ckd2; else goto ckd1;
       ckd2:
           call (I64[_rjV3::P64])() args: 8, res: 0, upd: 8;
       ckd1:
           I64[(old + 24)] = stg_bh_upd_frame_info;
           I64[(old + 16)] = _ckd0::I64;
           R2 = ckd3_str;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.377096 UTC

{offset
  ckd4:
      _rjV3::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckd5; else goto ckd6;
  ckd6:
      if (HpLim == 0) goto ckd5; else goto ckd7;
  ckd5:
      R1 = _rjV3::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckd7:
      (_ckd0::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV3::P64);
      if (_ckd0::I64 == 0) goto ckd2; else goto ckd1;
  ckd2:
      call (I64[_rjV3::P64])() args: 8, res: 0, upd: 8;
  ckd1:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckd0::I64;
      R2 = ckd3_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:52.378211 UTC

{offset
  ckd4:
      _rjV3::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckd5; else goto ckd6;
  ckd6:
      if (HpLim == 0) goto ckd5; else goto ckd7;
  ckd5:
      R1 = _rjV3::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckd7:
      (_ckd0::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV3::P64);
      if (_ckd0::I64 == 0) goto ckd2; else goto ckd1;
  ckd2:
      call (I64[_rjV3::P64])() args: 8, res: 0, upd: 8;
  ckd1:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckd0::I64;
      R2 = ckd3_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:52.379365 UTC

{offset
  ckd4:
      _rjV3::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckd5; else goto ckd6;
  ckd6:
      if (HpLim == 0) goto ckd5; else goto ckd7;
  ckd5:
      R1 = _rjV3::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckd7:
      (_ckd0::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV3::P64);
      if (_ckd0::I64 == 0) goto ckd2; else goto ckd1;
  ckd2:
      call (I64[_rjV3::P64])() args: 8, res: 0, upd: 8;
  ckd1:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckd0::I64;
      R2 = ckd3_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:52.380531 UTC

{offset
  ckd4:
      _rjV3::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto ckd5; else goto ckd6;
  ckd6:
      if (HpLim == 0) goto ckd5; else goto ckd7;
  ckd5:
      R1 = _rjV3::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckd7:
      (_ckd0::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV3::P64);
      if (_ckd0::I64 == 0) goto ckd2; else goto ckd1;
  ckd2:
      call (I64[_rjV3::P64])() args: 8, res: 0, upd: 8;
  ckd1:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _ckd0::I64;
      R2 = ckd3_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:52.382166 UTC

{offset
  ckd4:
      _rjV3::P64 = R1;
      if ((Sp + -16) < SpLim) goto ckd5; else goto ckd6;
  ckd6:
      if (HpLim == 0) goto ckd5; else goto ckd7;
  ckd5:
      R1 = _rjV3::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckd7:
      (_ckd0::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV3::P64);
      if (_ckd0::I64 == 0) goto ckd2; else goto ckd1;
  ckd2:
      call (I64[_rjV3::P64])() args: 8, res: 0, upd: 8;
  ckd1:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _ckd0::I64;
      R2 = ckd3_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:52.383459 UTC

[(ckd1, {}), (ckd2, {}), (ckd4, {}), (ckd5, {}), (ckd6, {}),
 (ckd7, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:52.383838 UTC

lvl6_rjV3_entry() //  [R1]
        { info_tbl: [(ckd4,
                      label: lvl6_rjV3_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckd4:
          _rjV3::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckd5; else goto ckd6;
      ckd6:
          if (HpLim == 0) goto ckd5; else goto ckd7;
      ckd5:
          R1 = _rjV3::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckd7:
          (_ckd0::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV3::P64);
          if (_ckd0::I64 == 0) goto ckd2; else goto ckd1;
      ckd2:
          call (I64[_rjV3::P64])() args: 8, res: 0, upd: 8;
      ckd1:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _ckd0::I64;
          R2 = ckd3_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.385202 UTC

lvl6_rjV3_entry() //  [R1]
        { info_tbl: [(ckd4,
                      label: lvl6_rjV3_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckd4:
          _rjV3::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckd5; else goto ckd6;
      ckd6:
          if (HpLim == 0) goto ckd5; else goto ckd7;
      ckd5:
          R1 = _rjV3::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckd7:
          (_ckd0::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV3::P64);
          if (_ckd0::I64 == 0) goto ckd2; else goto ckd1;
      ckd2:
          call (I64[_rjV3::P64])() args: 8, res: 0, upd: 8;
      ckd1:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _ckd0::I64;
          R2 = ckd3_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.386604 UTC

[section "data" {
     lvl6_rjV3_closure:
         const lvl6_rjV3_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ckd3_str:
         I8[] [95,97,116,111,109,105,99,71,114,111,117,112,115,32,61,32]
 },
 lvl6_rjV3_entry() //  [R1]
         { info_tbl: [(ckd4,
                       label: lvl6_rjV3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckd4:
           _rjV3::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckd5; else goto ckd6;
       ckd6:
           if (HpLim == 0) goto ckd5; else goto ckd7;
       ckd5:
           R1 = _rjV3::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckd7:
           (_ckd0::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV3::P64);
           if (_ckd0::I64 == 0) goto ckd2; else goto ckd1;
       ckd2:
           call (I64[_rjV3::P64])() args: 8, res: 0, upd: 8;
       ckd1:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ckd0::I64;
           R2 = ckd3_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.388347 UTC

[section "data" {
     lvl6_rjV3_closure:
         const lvl6_rjV3_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ckd3_str:
         I8[] [95,97,116,111,109,105,99,71,114,111,117,112,115,32,61,32]
 },
 lvl6_rjV3_entry() //  [R1]
         { info_tbl: [(ckd4,
                       label: lvl6_rjV3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckd4:
           _rjV3::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckd5; else goto ckd6;
       ckd6:
           if (HpLim == 0) goto ckd5; else goto ckd7;
       ckd5:
           R1 = _rjV3::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckd7:
           (_ckd0::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV3::P64);
           if (_ckd0::I64 == 0) goto ckd2; else goto ckd1;
       ckd2:
           call (I64[_rjV3::P64])() args: 8, res: 0, upd: 8;
       ckd1:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ckd0::I64;
           R2 = ckd3_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.392984 UTC

[section "data" {
     lvl7_rjV4_closure:
         const lvl7_rjV4_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ckdk_str:
         I8[] [95,119,105,116,104,111,117,116,84,77,32,61,32]
 },
 lvl7_rjV4_entry() //  [R1]
         { info_tbl: [(ckdl,
                       label: lvl7_rjV4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckdl:
           _rjV4::P64 = R1;
           goto ckdf;
       ckdf:
           if ((old + 0) - <highSp> < SpLim) goto ckdm; else goto ckdn;
       ckdn:
           if (HpLim == 0) goto ckdm; else goto ckdo;
       ckdm:
           R1 = _rjV4::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckdo:
           (_ckdh::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV4::P64);
           if (_ckdh::I64 == 0) goto ckdj; else goto ckdi;
       ckdj:
           call (I64[_rjV4::P64])() args: 8, res: 0, upd: 8;
       ckdi:
           I64[(old + 24)] = stg_bh_upd_frame_info;
           I64[(old + 16)] = _ckdh::I64;
           R2 = ckdk_str;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.395094 UTC

{offset
  ckdl:
      _rjV4::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckdm; else goto ckdn;
  ckdn:
      if (HpLim == 0) goto ckdm; else goto ckdo;
  ckdm:
      R1 = _rjV4::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckdo:
      (_ckdh::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV4::P64);
      if (_ckdh::I64 == 0) goto ckdj; else goto ckdi;
  ckdj:
      call (I64[_rjV4::P64])() args: 8, res: 0, upd: 8;
  ckdi:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckdh::I64;
      R2 = ckdk_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:52.396194 UTC

{offset
  ckdl:
      _rjV4::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckdm; else goto ckdn;
  ckdn:
      if (HpLim == 0) goto ckdm; else goto ckdo;
  ckdm:
      R1 = _rjV4::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckdo:
      (_ckdh::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV4::P64);
      if (_ckdh::I64 == 0) goto ckdj; else goto ckdi;
  ckdj:
      call (I64[_rjV4::P64])() args: 8, res: 0, upd: 8;
  ckdi:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckdh::I64;
      R2 = ckdk_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:52.397382 UTC

{offset
  ckdl:
      _rjV4::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckdm; else goto ckdn;
  ckdn:
      if (HpLim == 0) goto ckdm; else goto ckdo;
  ckdm:
      R1 = _rjV4::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckdo:
      (_ckdh::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV4::P64);
      if (_ckdh::I64 == 0) goto ckdj; else goto ckdi;
  ckdj:
      call (I64[_rjV4::P64])() args: 8, res: 0, upd: 8;
  ckdi:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckdh::I64;
      R2 = ckdk_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:52.398538 UTC

{offset
  ckdl:
      _rjV4::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto ckdm; else goto ckdn;
  ckdn:
      if (HpLim == 0) goto ckdm; else goto ckdo;
  ckdm:
      R1 = _rjV4::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckdo:
      (_ckdh::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV4::P64);
      if (_ckdh::I64 == 0) goto ckdj; else goto ckdi;
  ckdj:
      call (I64[_rjV4::P64])() args: 8, res: 0, upd: 8;
  ckdi:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _ckdh::I64;
      R2 = ckdk_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:52.399785 UTC

{offset
  ckdl:
      _rjV4::P64 = R1;
      if ((Sp + -16) < SpLim) goto ckdm; else goto ckdn;
  ckdn:
      if (HpLim == 0) goto ckdm; else goto ckdo;
  ckdm:
      R1 = _rjV4::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckdo:
      (_ckdh::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV4::P64);
      if (_ckdh::I64 == 0) goto ckdj; else goto ckdi;
  ckdj:
      call (I64[_rjV4::P64])() args: 8, res: 0, upd: 8;
  ckdi:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _ckdh::I64;
      R2 = ckdk_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:52.401056 UTC

[(ckdi, {}), (ckdj, {}), (ckdl, {}), (ckdm, {}), (ckdn, {}),
 (ckdo, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:52.401432 UTC

lvl7_rjV4_entry() //  [R1]
        { info_tbl: [(ckdl,
                      label: lvl7_rjV4_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckdl:
          _rjV4::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckdm; else goto ckdn;
      ckdn:
          if (HpLim == 0) goto ckdm; else goto ckdo;
      ckdm:
          R1 = _rjV4::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckdo:
          (_ckdh::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV4::P64);
          if (_ckdh::I64 == 0) goto ckdj; else goto ckdi;
      ckdj:
          call (I64[_rjV4::P64])() args: 8, res: 0, upd: 8;
      ckdi:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _ckdh::I64;
          R2 = ckdk_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.402795 UTC

lvl7_rjV4_entry() //  [R1]
        { info_tbl: [(ckdl,
                      label: lvl7_rjV4_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckdl:
          _rjV4::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckdm; else goto ckdn;
      ckdn:
          if (HpLim == 0) goto ckdm; else goto ckdo;
      ckdm:
          R1 = _rjV4::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckdo:
          (_ckdh::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV4::P64);
          if (_ckdh::I64 == 0) goto ckdj; else goto ckdi;
      ckdj:
          call (I64[_rjV4::P64])() args: 8, res: 0, upd: 8;
      ckdi:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _ckdh::I64;
          R2 = ckdk_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.404177 UTC

[section "data" {
     lvl7_rjV4_closure:
         const lvl7_rjV4_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ckdk_str:
         I8[] [95,119,105,116,104,111,117,116,84,77,32,61,32]
 },
 lvl7_rjV4_entry() //  [R1]
         { info_tbl: [(ckdl,
                       label: lvl7_rjV4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckdl:
           _rjV4::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckdm; else goto ckdn;
       ckdn:
           if (HpLim == 0) goto ckdm; else goto ckdo;
       ckdm:
           R1 = _rjV4::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckdo:
           (_ckdh::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV4::P64);
           if (_ckdh::I64 == 0) goto ckdj; else goto ckdi;
       ckdj:
           call (I64[_rjV4::P64])() args: 8, res: 0, upd: 8;
       ckdi:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ckdh::I64;
           R2 = ckdk_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.405893 UTC

[section "data" {
     lvl7_rjV4_closure:
         const lvl7_rjV4_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ckdk_str:
         I8[] [95,119,105,116,104,111,117,116,84,77,32,61,32]
 },
 lvl7_rjV4_entry() //  [R1]
         { info_tbl: [(ckdl,
                       label: lvl7_rjV4_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckdl:
           _rjV4::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckdm; else goto ckdn;
       ckdn:
           if (HpLim == 0) goto ckdm; else goto ckdo;
       ckdm:
           R1 = _rjV4::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckdo:
           (_ckdh::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV4::P64);
           if (_ckdh::I64 == 0) goto ckdj; else goto ckdi;
       ckdj:
           call (I64[_rjV4::P64])() args: 8, res: 0, upd: 8;
       ckdi:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ckdh::I64;
           R2 = ckdk_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.410536 UTC

[section "data" {
     lvl8_rjV5_closure:
         const lvl8_rjV5_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ckdB_str:
         I8[] [95,105,110,105,116,79,110,108,121,32,61,32]
 },
 lvl8_rjV5_entry() //  [R1]
         { info_tbl: [(ckdC,
                       label: lvl8_rjV5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckdC:
           _rjV5::P64 = R1;
           goto ckdw;
       ckdw:
           if ((old + 0) - <highSp> < SpLim) goto ckdD; else goto ckdE;
       ckdE:
           if (HpLim == 0) goto ckdD; else goto ckdF;
       ckdD:
           R1 = _rjV5::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckdF:
           (_ckdy::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV5::P64);
           if (_ckdy::I64 == 0) goto ckdA; else goto ckdz;
       ckdA:
           call (I64[_rjV5::P64])() args: 8, res: 0, upd: 8;
       ckdz:
           I64[(old + 24)] = stg_bh_upd_frame_info;
           I64[(old + 16)] = _ckdy::I64;
           R2 = ckdB_str;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.412632 UTC

{offset
  ckdC:
      _rjV5::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckdD; else goto ckdE;
  ckdE:
      if (HpLim == 0) goto ckdD; else goto ckdF;
  ckdD:
      R1 = _rjV5::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckdF:
      (_ckdy::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV5::P64);
      if (_ckdy::I64 == 0) goto ckdA; else goto ckdz;
  ckdA:
      call (I64[_rjV5::P64])() args: 8, res: 0, upd: 8;
  ckdz:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckdy::I64;
      R2 = ckdB_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:52.413739 UTC

{offset
  ckdC:
      _rjV5::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckdD; else goto ckdE;
  ckdE:
      if (HpLim == 0) goto ckdD; else goto ckdF;
  ckdD:
      R1 = _rjV5::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckdF:
      (_ckdy::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV5::P64);
      if (_ckdy::I64 == 0) goto ckdA; else goto ckdz;
  ckdA:
      call (I64[_rjV5::P64])() args: 8, res: 0, upd: 8;
  ckdz:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckdy::I64;
      R2 = ckdB_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:52.41485 UTC

{offset
  ckdC:
      _rjV5::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckdD; else goto ckdE;
  ckdE:
      if (HpLim == 0) goto ckdD; else goto ckdF;
  ckdD:
      R1 = _rjV5::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckdF:
      (_ckdy::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV5::P64);
      if (_ckdy::I64 == 0) goto ckdA; else goto ckdz;
  ckdA:
      call (I64[_rjV5::P64])() args: 8, res: 0, upd: 8;
  ckdz:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckdy::I64;
      R2 = ckdB_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:52.416013 UTC

{offset
  ckdC:
      _rjV5::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto ckdD; else goto ckdE;
  ckdE:
      if (HpLim == 0) goto ckdD; else goto ckdF;
  ckdD:
      R1 = _rjV5::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckdF:
      (_ckdy::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV5::P64);
      if (_ckdy::I64 == 0) goto ckdA; else goto ckdz;
  ckdA:
      call (I64[_rjV5::P64])() args: 8, res: 0, upd: 8;
  ckdz:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _ckdy::I64;
      R2 = ckdB_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:52.417693 UTC

{offset
  ckdC:
      _rjV5::P64 = R1;
      if ((Sp + -16) < SpLim) goto ckdD; else goto ckdE;
  ckdE:
      if (HpLim == 0) goto ckdD; else goto ckdF;
  ckdD:
      R1 = _rjV5::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckdF:
      (_ckdy::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV5::P64);
      if (_ckdy::I64 == 0) goto ckdA; else goto ckdz;
  ckdA:
      call (I64[_rjV5::P64])() args: 8, res: 0, upd: 8;
  ckdz:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _ckdy::I64;
      R2 = ckdB_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:52.418971 UTC

[(ckdz, {}), (ckdA, {}), (ckdC, {}), (ckdD, {}), (ckdE, {}),
 (ckdF, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:52.419458 UTC

lvl8_rjV5_entry() //  [R1]
        { info_tbl: [(ckdC,
                      label: lvl8_rjV5_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckdC:
          _rjV5::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckdD; else goto ckdE;
      ckdE:
          if (HpLim == 0) goto ckdD; else goto ckdF;
      ckdD:
          R1 = _rjV5::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckdF:
          (_ckdy::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV5::P64);
          if (_ckdy::I64 == 0) goto ckdA; else goto ckdz;
      ckdA:
          call (I64[_rjV5::P64])() args: 8, res: 0, upd: 8;
      ckdz:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _ckdy::I64;
          R2 = ckdB_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.420807 UTC

lvl8_rjV5_entry() //  [R1]
        { info_tbl: [(ckdC,
                      label: lvl8_rjV5_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckdC:
          _rjV5::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckdD; else goto ckdE;
      ckdE:
          if (HpLim == 0) goto ckdD; else goto ckdF;
      ckdD:
          R1 = _rjV5::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckdF:
          (_ckdy::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV5::P64);
          if (_ckdy::I64 == 0) goto ckdA; else goto ckdz;
      ckdA:
          call (I64[_rjV5::P64])() args: 8, res: 0, upd: 8;
      ckdz:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _ckdy::I64;
          R2 = ckdB_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.422187 UTC

[section "data" {
     lvl8_rjV5_closure:
         const lvl8_rjV5_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ckdB_str:
         I8[] [95,105,110,105,116,79,110,108,121,32,61,32]
 },
 lvl8_rjV5_entry() //  [R1]
         { info_tbl: [(ckdC,
                       label: lvl8_rjV5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckdC:
           _rjV5::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckdD; else goto ckdE;
       ckdE:
           if (HpLim == 0) goto ckdD; else goto ckdF;
       ckdD:
           R1 = _rjV5::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckdF:
           (_ckdy::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV5::P64);
           if (_ckdy::I64 == 0) goto ckdA; else goto ckdz;
       ckdA:
           call (I64[_rjV5::P64])() args: 8, res: 0, upd: 8;
       ckdz:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ckdy::I64;
           R2 = ckdB_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.423873 UTC

[section "data" {
     lvl8_rjV5_closure:
         const lvl8_rjV5_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ckdB_str:
         I8[] [95,105,110,105,116,79,110,108,121,32,61,32]
 },
 lvl8_rjV5_entry() //  [R1]
         { info_tbl: [(ckdC,
                       label: lvl8_rjV5_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckdC:
           _rjV5::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckdD; else goto ckdE;
       ckdE:
           if (HpLim == 0) goto ckdD; else goto ckdF;
       ckdD:
           R1 = _rjV5::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckdF:
           (_ckdy::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV5::P64);
           if (_ckdy::I64 == 0) goto ckdA; else goto ckdz;
       ckdA:
           call (I64[_rjV5::P64])() args: 8, res: 0, upd: 8;
       ckdz:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ckdy::I64;
           R2 = ckdB_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.428417 UTC

[section "data" {
     lvl9_rjV6_closure:
         const lvl9_rjV6_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ckdS_str:
         I8[] [95,116,104,114,101,97,100,115,32,61,32]
 },
 lvl9_rjV6_entry() //  [R1]
         { info_tbl: [(ckdT,
                       label: lvl9_rjV6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckdT:
           _rjV6::P64 = R1;
           goto ckdN;
       ckdN:
           if ((old + 0) - <highSp> < SpLim) goto ckdU; else goto ckdV;
       ckdV:
           if (HpLim == 0) goto ckdU; else goto ckdW;
       ckdU:
           R1 = _rjV6::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckdW:
           (_ckdP::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV6::P64);
           if (_ckdP::I64 == 0) goto ckdR; else goto ckdQ;
       ckdR:
           call (I64[_rjV6::P64])() args: 8, res: 0, upd: 8;
       ckdQ:
           I64[(old + 24)] = stg_bh_upd_frame_info;
           I64[(old + 16)] = _ckdP::I64;
           R2 = ckdS_str;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.430549 UTC

{offset
  ckdT:
      _rjV6::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckdU; else goto ckdV;
  ckdV:
      if (HpLim == 0) goto ckdU; else goto ckdW;
  ckdU:
      R1 = _rjV6::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckdW:
      (_ckdP::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV6::P64);
      if (_ckdP::I64 == 0) goto ckdR; else goto ckdQ;
  ckdR:
      call (I64[_rjV6::P64])() args: 8, res: 0, upd: 8;
  ckdQ:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckdP::I64;
      R2 = ckdS_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:52.431649 UTC

{offset
  ckdT:
      _rjV6::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckdU; else goto ckdV;
  ckdV:
      if (HpLim == 0) goto ckdU; else goto ckdW;
  ckdU:
      R1 = _rjV6::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckdW:
      (_ckdP::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV6::P64);
      if (_ckdP::I64 == 0) goto ckdR; else goto ckdQ;
  ckdR:
      call (I64[_rjV6::P64])() args: 8, res: 0, upd: 8;
  ckdQ:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckdP::I64;
      R2 = ckdS_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:52.43278 UTC

{offset
  ckdT:
      _rjV6::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckdU; else goto ckdV;
  ckdV:
      if (HpLim == 0) goto ckdU; else goto ckdW;
  ckdU:
      R1 = _rjV6::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckdW:
      (_ckdP::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV6::P64);
      if (_ckdP::I64 == 0) goto ckdR; else goto ckdQ;
  ckdR:
      call (I64[_rjV6::P64])() args: 8, res: 0, upd: 8;
  ckdQ:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckdP::I64;
      R2 = ckdS_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:52.433941 UTC

{offset
  ckdT:
      _rjV6::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto ckdU; else goto ckdV;
  ckdV:
      if (HpLim == 0) goto ckdU; else goto ckdW;
  ckdU:
      R1 = _rjV6::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckdW:
      (_ckdP::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV6::P64);
      if (_ckdP::I64 == 0) goto ckdR; else goto ckdQ;
  ckdR:
      call (I64[_rjV6::P64])() args: 8, res: 0, upd: 8;
  ckdQ:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _ckdP::I64;
      R2 = ckdS_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:52.43508 UTC

{offset
  ckdT:
      _rjV6::P64 = R1;
      if ((Sp + -16) < SpLim) goto ckdU; else goto ckdV;
  ckdV:
      if (HpLim == 0) goto ckdU; else goto ckdW;
  ckdU:
      R1 = _rjV6::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckdW:
      (_ckdP::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV6::P64);
      if (_ckdP::I64 == 0) goto ckdR; else goto ckdQ;
  ckdR:
      call (I64[_rjV6::P64])() args: 8, res: 0, upd: 8;
  ckdQ:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _ckdP::I64;
      R2 = ckdS_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:52.436383 UTC

[(ckdQ, {}), (ckdR, {}), (ckdT, {}), (ckdU, {}), (ckdV, {}),
 (ckdW, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:52.436766 UTC

lvl9_rjV6_entry() //  [R1]
        { info_tbl: [(ckdT,
                      label: lvl9_rjV6_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckdT:
          _rjV6::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckdU; else goto ckdV;
      ckdV:
          if (HpLim == 0) goto ckdU; else goto ckdW;
      ckdU:
          R1 = _rjV6::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckdW:
          (_ckdP::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV6::P64);
          if (_ckdP::I64 == 0) goto ckdR; else goto ckdQ;
      ckdR:
          call (I64[_rjV6::P64])() args: 8, res: 0, upd: 8;
      ckdQ:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _ckdP::I64;
          R2 = ckdS_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.438181 UTC

lvl9_rjV6_entry() //  [R1]
        { info_tbl: [(ckdT,
                      label: lvl9_rjV6_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckdT:
          _rjV6::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckdU; else goto ckdV;
      ckdV:
          if (HpLim == 0) goto ckdU; else goto ckdW;
      ckdU:
          R1 = _rjV6::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckdW:
          (_ckdP::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV6::P64);
          if (_ckdP::I64 == 0) goto ckdR; else goto ckdQ;
      ckdR:
          call (I64[_rjV6::P64])() args: 8, res: 0, upd: 8;
      ckdQ:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _ckdP::I64;
          R2 = ckdS_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.439621 UTC

[section "data" {
     lvl9_rjV6_closure:
         const lvl9_rjV6_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ckdS_str:
         I8[] [95,116,104,114,101,97,100,115,32,61,32]
 },
 lvl9_rjV6_entry() //  [R1]
         { info_tbl: [(ckdT,
                       label: lvl9_rjV6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckdT:
           _rjV6::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckdU; else goto ckdV;
       ckdV:
           if (HpLim == 0) goto ckdU; else goto ckdW;
       ckdU:
           R1 = _rjV6::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckdW:
           (_ckdP::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV6::P64);
           if (_ckdP::I64 == 0) goto ckdR; else goto ckdQ;
       ckdR:
           call (I64[_rjV6::P64])() args: 8, res: 0, upd: 8;
       ckdQ:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ckdP::I64;
           R2 = ckdS_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.441351 UTC

[section "data" {
     lvl9_rjV6_closure:
         const lvl9_rjV6_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ckdS_str:
         I8[] [95,116,104,114,101,97,100,115,32,61,32]
 },
 lvl9_rjV6_entry() //  [R1]
         { info_tbl: [(ckdT,
                       label: lvl9_rjV6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckdT:
           _rjV6::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckdU; else goto ckdV;
       ckdV:
           if (HpLim == 0) goto ckdU; else goto ckdW;
       ckdU:
           R1 = _rjV6::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckdW:
           (_ckdP::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV6::P64);
           if (_ckdP::I64 == 0) goto ckdR; else goto ckdQ;
       ckdR:
           call (I64[_rjV6::P64])() args: 8, res: 0, upd: 8;
       ckdQ:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ckdP::I64;
           R2 = ckdS_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.445932 UTC

[section "data" {
     lvl10_rjV7_closure:
         const lvl10_rjV7_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     cke9_str:
         I8[] [95,101,110,116,114,105,101,115,32,61,32]
 },
 lvl10_rjV7_entry() //  [R1]
         { info_tbl: [(ckea,
                       label: lvl10_rjV7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckea:
           _rjV7::P64 = R1;
           goto cke4;
       cke4:
           if ((old + 0) - <highSp> < SpLim) goto ckeb; else goto ckec;
       ckec:
           if (HpLim == 0) goto ckeb; else goto cked;
       ckeb:
           R1 = _rjV7::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cked:
           (_cke6::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV7::P64);
           if (_cke6::I64 == 0) goto cke8; else goto cke7;
       cke8:
           call (I64[_rjV7::P64])() args: 8, res: 0, upd: 8;
       cke7:
           I64[(old + 24)] = stg_bh_upd_frame_info;
           I64[(old + 16)] = _cke6::I64;
           R2 = cke9_str;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.448074 UTC

{offset
  ckea:
      _rjV7::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckeb; else goto ckec;
  ckec:
      if (HpLim == 0) goto ckeb; else goto cked;
  ckeb:
      R1 = _rjV7::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cked:
      (_cke6::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV7::P64);
      if (_cke6::I64 == 0) goto cke8; else goto cke7;
  cke8:
      call (I64[_rjV7::P64])() args: 8, res: 0, upd: 8;
  cke7:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _cke6::I64;
      R2 = cke9_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:52.449206 UTC

{offset
  ckea:
      _rjV7::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckeb; else goto ckec;
  ckec:
      if (HpLim == 0) goto ckeb; else goto cked;
  ckeb:
      R1 = _rjV7::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cked:
      (_cke6::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV7::P64);
      if (_cke6::I64 == 0) goto cke8; else goto cke7;
  cke8:
      call (I64[_rjV7::P64])() args: 8, res: 0, upd: 8;
  cke7:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _cke6::I64;
      R2 = cke9_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:52.450343 UTC

{offset
  ckea:
      _rjV7::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckeb; else goto ckec;
  ckec:
      if (HpLim == 0) goto ckeb; else goto cked;
  ckeb:
      R1 = _rjV7::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cked:
      (_cke6::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV7::P64);
      if (_cke6::I64 == 0) goto cke8; else goto cke7;
  cke8:
      call (I64[_rjV7::P64])() args: 8, res: 0, upd: 8;
  cke7:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _cke6::I64;
      R2 = cke9_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:52.452008 UTC

{offset
  ckea:
      _rjV7::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto ckeb; else goto ckec;
  ckec:
      if (HpLim == 0) goto ckeb; else goto cked;
  ckeb:
      R1 = _rjV7::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cked:
      (_cke6::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV7::P64);
      if (_cke6::I64 == 0) goto cke8; else goto cke7;
  cke8:
      call (I64[_rjV7::P64])() args: 8, res: 0, upd: 8;
  cke7:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _cke6::I64;
      R2 = cke9_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:52.453144 UTC

{offset
  ckea:
      _rjV7::P64 = R1;
      if ((Sp + -16) < SpLim) goto ckeb; else goto ckec;
  ckec:
      if (HpLim == 0) goto ckeb; else goto cked;
  ckeb:
      R1 = _rjV7::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cked:
      (_cke6::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV7::P64);
      if (_cke6::I64 == 0) goto cke8; else goto cke7;
  cke8:
      call (I64[_rjV7::P64])() args: 8, res: 0, upd: 8;
  cke7:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _cke6::I64;
      R2 = cke9_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:52.454406 UTC

[(cke7, {}), (cke8, {}), (ckea, {}), (ckeb, {}), (ckec, {}),
 (cked, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:52.454783 UTC

lvl10_rjV7_entry() //  [R1]
        { info_tbl: [(ckea,
                      label: lvl10_rjV7_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckea:
          _rjV7::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckeb; else goto ckec;
      ckec:
          if (HpLim == 0) goto ckeb; else goto cked;
      ckeb:
          R1 = _rjV7::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      cked:
          (_cke6::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV7::P64);
          if (_cke6::I64 == 0) goto cke8; else goto cke7;
      cke8:
          call (I64[_rjV7::P64])() args: 8, res: 0, upd: 8;
      cke7:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _cke6::I64;
          R2 = cke9_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.45614 UTC

lvl10_rjV7_entry() //  [R1]
        { info_tbl: [(ckea,
                      label: lvl10_rjV7_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckea:
          _rjV7::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckeb; else goto ckec;
      ckec:
          if (HpLim == 0) goto ckeb; else goto cked;
      ckeb:
          R1 = _rjV7::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      cked:
          (_cke6::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV7::P64);
          if (_cke6::I64 == 0) goto cke8; else goto cke7;
      cke8:
          call (I64[_rjV7::P64])() args: 8, res: 0, upd: 8;
      cke7:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _cke6::I64;
          R2 = cke9_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.457558 UTC

[section "data" {
     lvl10_rjV7_closure:
         const lvl10_rjV7_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     cke9_str:
         I8[] [95,101,110,116,114,105,101,115,32,61,32]
 },
 lvl10_rjV7_entry() //  [R1]
         { info_tbl: [(ckea,
                       label: lvl10_rjV7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckea:
           _rjV7::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckeb; else goto ckec;
       ckec:
           if (HpLim == 0) goto ckeb; else goto cked;
       ckeb:
           R1 = _rjV7::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cked:
           (_cke6::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV7::P64);
           if (_cke6::I64 == 0) goto cke8; else goto cke7;
       cke8:
           call (I64[_rjV7::P64])() args: 8, res: 0, upd: 8;
       cke7:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cke6::I64;
           R2 = cke9_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.459365 UTC

[section "data" {
     lvl10_rjV7_closure:
         const lvl10_rjV7_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     cke9_str:
         I8[] [95,101,110,116,114,105,101,115,32,61,32]
 },
 lvl10_rjV7_entry() //  [R1]
         { info_tbl: [(ckea,
                       label: lvl10_rjV7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckea:
           _rjV7::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckeb; else goto ckec;
       ckec:
           if (HpLim == 0) goto ckeb; else goto cked;
       ckeb:
           R1 = _rjV7::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cked:
           (_cke6::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV7::P64);
           if (_cke6::I64 == 0) goto cke8; else goto cke7;
       cke8:
           call (I64[_rjV7::P64])() args: 8, res: 0, upd: 8;
       cke7:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cke6::I64;
           R2 = cke9_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.463898 UTC

[section "data" {
     lvl11_rjV8_closure:
         const lvl11_rjV8_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ckeq_str:
         I8[] [82,66,84,114,101,101,79,112,116,115,32,123]
 },
 lvl11_rjV8_entry() //  [R1]
         { info_tbl: [(cker,
                       label: lvl11_rjV8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cker:
           _rjV8::P64 = R1;
           goto ckel;
       ckel:
           if ((old + 0) - <highSp> < SpLim) goto ckes; else goto cket;
       cket:
           if (HpLim == 0) goto ckes; else goto ckeu;
       ckes:
           R1 = _rjV8::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckeu:
           (_cken::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV8::P64);
           if (_cken::I64 == 0) goto ckep; else goto ckeo;
       ckep:
           call (I64[_rjV8::P64])() args: 8, res: 0, upd: 8;
       ckeo:
           I64[(old + 24)] = stg_bh_upd_frame_info;
           I64[(old + 16)] = _cken::I64;
           R2 = ckeq_str;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.465999 UTC

{offset
  cker:
      _rjV8::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckes; else goto cket;
  cket:
      if (HpLim == 0) goto ckes; else goto ckeu;
  ckes:
      R1 = _rjV8::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckeu:
      (_cken::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV8::P64);
      if (_cken::I64 == 0) goto ckep; else goto ckeo;
  ckep:
      call (I64[_rjV8::P64])() args: 8, res: 0, upd: 8;
  ckeo:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _cken::I64;
      R2 = ckeq_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:52.467111 UTC

{offset
  cker:
      _rjV8::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckes; else goto cket;
  cket:
      if (HpLim == 0) goto ckes; else goto ckeu;
  ckes:
      R1 = _rjV8::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckeu:
      (_cken::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV8::P64);
      if (_cken::I64 == 0) goto ckep; else goto ckeo;
  ckep:
      call (I64[_rjV8::P64])() args: 8, res: 0, upd: 8;
  ckeo:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _cken::I64;
      R2 = ckeq_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:52.468211 UTC

{offset
  cker:
      _rjV8::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckes; else goto cket;
  cket:
      if (HpLim == 0) goto ckes; else goto ckeu;
  ckes:
      R1 = _rjV8::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckeu:
      (_cken::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV8::P64);
      if (_cken::I64 == 0) goto ckep; else goto ckeo;
  ckep:
      call (I64[_rjV8::P64])() args: 8, res: 0, upd: 8;
  ckeo:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _cken::I64;
      R2 = ckeq_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:52.469395 UTC

{offset
  cker:
      _rjV8::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto ckes; else goto cket;
  cket:
      if (HpLim == 0) goto ckes; else goto ckeu;
  ckes:
      R1 = _rjV8::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckeu:
      (_cken::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV8::P64);
      if (_cken::I64 == 0) goto ckep; else goto ckeo;
  ckep:
      call (I64[_rjV8::P64])() args: 8, res: 0, upd: 8;
  ckeo:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _cken::I64;
      R2 = ckeq_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:52.470535 UTC

{offset
  cker:
      _rjV8::P64 = R1;
      if ((Sp + -16) < SpLim) goto ckes; else goto cket;
  cket:
      if (HpLim == 0) goto ckes; else goto ckeu;
  ckes:
      R1 = _rjV8::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckeu:
      (_cken::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV8::P64);
      if (_cken::I64 == 0) goto ckep; else goto ckeo;
  ckep:
      call (I64[_rjV8::P64])() args: 8, res: 0, upd: 8;
  ckeo:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _cken::I64;
      R2 = ckeq_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:52.471815 UTC

[(ckeo, {}), (ckep, {}), (cker, {}), (ckes, {}), (cket, {}),
 (ckeu, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:52.472197 UTC

lvl11_rjV8_entry() //  [R1]
        { info_tbl: [(cker,
                      label: lvl11_rjV8_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cker:
          _rjV8::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckes; else goto cket;
      cket:
          if (HpLim == 0) goto ckes; else goto ckeu;
      ckes:
          R1 = _rjV8::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckeu:
          (_cken::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV8::P64);
          if (_cken::I64 == 0) goto ckep; else goto ckeo;
      ckep:
          call (I64[_rjV8::P64])() args: 8, res: 0, upd: 8;
      ckeo:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _cken::I64;
          R2 = ckeq_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.473552 UTC

lvl11_rjV8_entry() //  [R1]
        { info_tbl: [(cker,
                      label: lvl11_rjV8_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cker:
          _rjV8::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckes; else goto cket;
      cket:
          if (HpLim == 0) goto ckes; else goto ckeu;
      ckes:
          R1 = _rjV8::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckeu:
          (_cken::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV8::P64);
          if (_cken::I64 == 0) goto ckep; else goto ckeo;
      ckep:
          call (I64[_rjV8::P64])() args: 8, res: 0, upd: 8;
      ckeo:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _cken::I64;
          R2 = ckeq_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.47494 UTC

[section "data" {
     lvl11_rjV8_closure:
         const lvl11_rjV8_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ckeq_str:
         I8[] [82,66,84,114,101,101,79,112,116,115,32,123]
 },
 lvl11_rjV8_entry() //  [R1]
         { info_tbl: [(cker,
                       label: lvl11_rjV8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cker:
           _rjV8::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckes; else goto cket;
       cket:
           if (HpLim == 0) goto ckes; else goto ckeu;
       ckes:
           R1 = _rjV8::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckeu:
           (_cken::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV8::P64);
           if (_cken::I64 == 0) goto ckep; else goto ckeo;
       ckep:
           call (I64[_rjV8::P64])() args: 8, res: 0, upd: 8;
       ckeo:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cken::I64;
           R2 = ckeq_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.476677 UTC

[section "data" {
     lvl11_rjV8_closure:
         const lvl11_rjV8_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ckeq_str:
         I8[] [82,66,84,114,101,101,79,112,116,115,32,123]
 },
 lvl11_rjV8_entry() //  [R1]
         { info_tbl: [(cker,
                       label: lvl11_rjV8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cker:
           _rjV8::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckes; else goto cket;
       cket:
           if (HpLim == 0) goto ckes; else goto ckeu;
       ckes:
           R1 = _rjV8::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckeu:
           (_cken::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjV8::P64);
           if (_cken::I64 == 0) goto ckep; else goto ckeo;
       ckep:
           call (I64[_rjV8::P64])() args: 8, res: 0, upd: 8;
       ckeo:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cken::I64;
           R2 = ckeq_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.481852 UTC

[section "data" {
     Main.runRSTMSingle'1_closure:
         const Main.runRSTMSingle'1_info;
         const 0;
 },
 sat_sjWp_entry() //  [R1]
         { info_tbl: [(ckf2,
                       label: sat_sjWp_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckf2:
           _sjWp::P64 = R1;
           goto ckeX;
       ckeX:
           if ((old + 0) - <highSp> < SpLim) goto ckfb; else goto ckfc;
       ckfc:
           goto ckeW;
       ckeW:
           if (HpLim == 0) goto ckfb; else goto ckfd;
       ckfb:
           R1 = _sjWp::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ckfd:
           _sjW9::P64 = P64[_sjWp::P64 + 7];
           I64[(young<ckeZ> + 8)] = ckeZ;
           R1 = _sjW9::P64;
           if (R1 & 7 != 0) goto ckeZ; else goto ckf0;
       ckf0:
           call (I64[R1])(R1) returns to ckeZ, args: 8, res: 8, upd: 8;
       ckeZ:
           _sjWg::P64 = R1;
           _sjWh::P64 = P64[_sjWg::P64 + 7];
           _sjWi::P64 = P64[_sjWg::P64 + 15];
           _sjWj::P64 = P64[_sjWg::P64 + 23];
           I64[(young<ckf5> + 8)] = ckf5;
           R1 = _sjWi::P64;
           if (R1 & 7 != 0) goto ckf5; else goto ckf6;
       ckf6:
           call (I64[R1])(R1) returns to ckf5, args: 8, res: 8, upd: 8;
       ckf5:
           _sjWk::P64 = R1;
           _sjWl::P64 = P64[_sjWk::P64 + 7];
           I64[(young<ckfa> + 8)] = ckfa;
           R5 = Main.runRSTMSingle'2_closure+1;
           R4 = _sjWl::P64;
           R3 = _sjWh::P64;
           R2 = GHC.Classes.$fOrdWord_closure;
           call SkipList.$wa3_info(R5,
                                   R4,
                                   R3,
                                   R2) returns to ckfa, args: 8, res: 8, upd: 8;
       ckfa:
           _sjWo::P64 = R1;
           R1 = GHC.Tuple.()_closure+1;
           call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Main.runRSTMSingle'1_entry() //  [R6, R5, R4, R3, R2]
         { info_tbl: [(ckfm,
                       label: Main.runRSTMSingle'1_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckfm:
           _sjWb::P64 = R6;
           _sjWa::P64 = R5;
           _sjW9::P64 = R4;
           _sjW8::P64 = R3;
           _sjW7::P64 = R2;
           goto ckeN;
       ckeN:
           if ((old + 0) - <highSp> < SpLim) goto ckfn; else goto ckfo;
       ckfo:
           goto ckeM;
       ckeM:
           if (HpLim == 0) goto ckfn; else goto ckfF;
       ckfn:
           R6 = _sjWb::P64;
           R5 = _sjWa::P64;
           R4 = _sjW9::P64;
           R3 = _sjW8::P64;
           R2 = _sjW7::P64;
           R1 = Main.runRSTMSingle'1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckfF:
           goto sjWv;
       sjWv:
           goto ckfB;
       ckfB:
           if (HpLim == 0) goto ckfD; else goto ckfE;
       ckfD:
           I64[(young<ckfA> + 8)] = ckfA;
           call stg_gc_noregs() returns to ckfA, args: 8, res: 8, upd: 8;
       ckfA:
           goto ckfB;
       ckfE:
           goto sjWt;
       sjWt:
           goto ckfw;
       ckfw:
           if (HpLim == 0) goto ckfy; else goto ckfz;
       ckfy:
           I64[(young<ckfv> + 8)] = ckfv;
           call stg_gc_noregs() returns to ckfv, args: 8, res: 8, upd: 8;
       ckfv:
           goto ckfw;
       ckfz:
           goto sjWd;
       sjWd:
           goto ckeS;
       ckeS:
           Hp = Hp + 16;
           if (Hp > HpLim) goto ckfs; else goto ckfr;
       ckfs:
           HpAlloc = 16;
           goto ckfq;
       ckfq:
           I64[(young<ckeR> + 8)] = ckeR;
           call stg_gc_noregs() returns to ckeR, args: 8, res: 8, upd: 8;
       ckeR:
           goto ckeS;
       ckfr:
           I64[Hp - 8] = sat_sjWp_info;
           P64[Hp] = _sjW9::P64;
           _ckeU::P64 = Hp - 7;
           I64[(young<ckfp> + 8)] = ckfp;
           R1 = _ckeU::P64;
           call stg_norec_atomically#(R1) returns to ckfp, args: 8, res: 8, upd: 8;
       ckfp:
           _sjWs::P64 = R1;
           goto sjWd;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.489111 UTC

{offset
  ckf2:
      _sjWp::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckfb; else goto ckfc;
  ckfc:
      if (HpLim == 0) goto ckfb; else goto ckfd;
  ckfb:
      R1 = _sjWp::P64;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  ckfd:
      _sjW9::P64 = P64[_sjWp::P64 + 7];
      I64[(young<ckeZ> + 8)] = ckeZ;
      R1 = _sjW9::P64;
      if (R1 & 7 != 0) goto ckeZ; else goto ckf0;
  ckf0:
      call (I64[R1])(R1) returns to ckeZ, args: 8, res: 8, upd: 8;
  ckeZ:
      _sjWg::P64 = R1;
      _sjWh::P64 = P64[_sjWg::P64 + 7];
      _sjWi::P64 = P64[_sjWg::P64 + 15];
      _sjWj::P64 = P64[_sjWg::P64 + 23];
      I64[(young<ckf5> + 8)] = ckf5;
      R1 = _sjWi::P64;
      if (R1 & 7 != 0) goto ckf5; else goto ckf6;
  ckf6:
      call (I64[R1])(R1) returns to ckf5, args: 8, res: 8, upd: 8;
  ckf5:
      _sjWk::P64 = R1;
      _sjWl::P64 = P64[_sjWk::P64 + 7];
      I64[(young<ckfa> + 8)] = ckfa;
      R5 = Main.runRSTMSingle'2_closure+1;
      R4 = _sjWl::P64;
      R3 = _sjWh::P64;
      R2 = GHC.Classes.$fOrdWord_closure;
      call SkipList.$wa3_info(R5,
                              R4,
                              R3,
                              R2) returns to ckfa, args: 8, res: 8, upd: 8;
  ckfa:
      _sjWo::P64 = R1;
      R1 = GHC.Tuple.()_closure+1;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:52.491182 UTC

{offset
  ckf2:
      _sjWp::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckfb; else goto ckfc;
  ckfc:
      if (HpLim == 0) goto ckfb; else goto ckfd;
  ckfb:
      R1 = _sjWp::P64;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  ckfd:
      _sjW9::P64 = P64[_sjWp::P64 + 7];
      I64[(young<ckeZ> + 8)] = ckeZ;
      R1 = _sjW9::P64;
      if (R1 & 7 != 0) goto ckeZ; else goto ckf0;
  ckf0:
      call (I64[R1])(R1) returns to ckeZ, args: 8, res: 8, upd: 8;
  ckeZ:
      _sjWg::P64 = R1;
      _sjWh::P64 = P64[_sjWg::P64 + 7];
      _sjWi::P64 = P64[_sjWg::P64 + 15];
      _sjWj::P64 = P64[_sjWg::P64 + 23];
      I64[(young<ckf5> + 8)] = ckf5;
      R1 = _sjWi::P64;
      if (R1 & 7 != 0) goto ckf5; else goto ckf6;
  ckf6:
      call (I64[R1])(R1) returns to ckf5, args: 8, res: 8, upd: 8;
  ckf5:
      _sjWk::P64 = R1;
      _sjWl::P64 = P64[_sjWk::P64 + 7];
      I64[(young<ckfa> + 8)] = ckfa;
      R5 = Main.runRSTMSingle'2_closure+1;
      R4 = _sjWl::P64;
      R3 = _sjWh::P64;
      R2 = GHC.Classes.$fOrdWord_closure;
      call SkipList.$wa3_info(R5,
                              R4,
                              R3,
                              R2) returns to ckfa, args: 8, res: 8, upd: 8;
  ckfa:
      _sjWo::P64 = R1;
      R1 = GHC.Tuple.()_closure+1;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:52.493249 UTC

{offset
  ckf2:
      _sjWp::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckfb; else goto ckfc;
  ckfc:
      if (HpLim == 0) goto ckfb; else goto ckfd;
  ckfb:
      R1 = _sjWp::P64;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  ckfd:
      _sjW9::P64 = P64[_sjWp::P64 + 7];
      I64[(young<ckeZ> + 8)] = ckeZ;
      R1 = _sjW9::P64;
      if (R1 & 7 != 0) goto ckeZ; else goto ckf0;
  ckf0:
      call (I64[R1])(R1) returns to ckeZ, args: 8, res: 8, upd: 8;
  ckeZ:
      _sjWg::P64 = R1;
      _sjWh::P64 = P64[_sjWg::P64 + 7];
      _sjWi::P64 = P64[_sjWg::P64 + 15];
      _sjWj::P64 = P64[_sjWg::P64 + 23];
      I64[(young<ckf5> + 8)] = ckf5;
      R1 = _sjWi::P64;
      if (R1 & 7 != 0) goto ckf5; else goto ckf6;
  ckf6:
      call (I64[R1])(R1) returns to ckf5, args: 8, res: 8, upd: 8;
  ckf5:
      _sjWk::P64 = R1;
      _sjWl::P64 = P64[_sjWk::P64 + 7];
      I64[(young<ckfa> + 8)] = ckfa;
      R5 = Main.runRSTMSingle'2_closure+1;
      R4 = _sjWl::P64;
      R3 = _sjWh::P64;
      R2 = GHC.Classes.$fOrdWord_closure;
      call SkipList.$wa3_info(R5,
                              R4,
                              R3,
                              R2) returns to ckfa, args: 8, res: 8, upd: 8;
  ckfa:
      _sjWo::P64 = R1;
      R1 = GHC.Tuple.()_closure+1;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:52.496193 UTC

{offset
  ckf2:
      _sjWp::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto ckfb; else goto ckfc;
  ckfc:
      if (HpLim == 0) goto ckfb; else goto ckfd;
  ckfb:
      R1 = _sjWp::P64;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  ckfd:
      _sjW9::P64 = P64[_sjWp::P64 + 7];
      I64[Sp - 8] = ckeZ;
      R1 = _sjW9::P64;
      Sp = Sp - 8;
      if (R1 & 7 != 0) goto ckeZ; else goto ckf0;
  ckf0:
      call (I64[R1])(R1) returns to ckeZ, args: 8, res: 8, upd: 8;
  ckeZ:
      _sjWg::P64 = R1;
      _sjWh::P64 = P64[_sjWg::P64 + 7];
      _sjWi::P64 = P64[_sjWg::P64 + 15];
      _sjWj::P64 = P64[_sjWg::P64 + 23];
      I64[Sp - 8] = ckf5;
      R1 = _sjWi::P64;
      P64[Sp] = _sjWh::P64;
      Sp = Sp - 8;
      if (R1 & 7 != 0) goto ckf5; else goto ckf6;
  ckf6:
      call (I64[R1])(R1) returns to ckf5, args: 8, res: 8, upd: 8;
  ckf5:
      _sjWh::P64 = P64[Sp + 8];
      _sjWk::P64 = R1;
      _sjWl::P64 = P64[_sjWk::P64 + 7];
      I64[Sp + 8] = ckfa;
      R5 = Main.runRSTMSingle'2_closure+1;
      R4 = _sjWl::P64;
      R3 = _sjWh::P64;
      R2 = GHC.Classes.$fOrdWord_closure;
      Sp = Sp + 8;
      call SkipList.$wa3_info(R5,
                              R4,
                              R3,
                              R2) returns to ckfa, args: 8, res: 8, upd: 8;
  ckfa:
      _sjWo::P64 = R1;
      R1 = GHC.Tuple.()_closure+1;
      Sp = Sp + 8;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:52.498467 UTC

{offset
  ckf2:
      _sjWp::P64 = R1;
      if ((Sp + -16) < SpLim) goto ckfb; else goto ckfc;
  ckfc:
      if (HpLim == 0) goto ckfb; else goto ckfd;
  ckfb:
      R1 = _sjWp::P64;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  ckfd:
      I64[Sp - 8] = ckeZ;
      R1 = P64[_sjWp::P64 + 7];
      Sp = Sp - 8;
      if (R1 & 7 != 0) goto ckeZ; else goto ckf0;
  ckf0:
      call (I64[R1])(R1) returns to ckeZ, args: 8, res: 8, upd: 8;
  ckeZ:
      I64[Sp - 8] = ckf5;
      _sjWh::P64 = P64[R1 + 7];
      R1 = P64[R1 + 15];
      P64[Sp] = _sjWh::P64;
      Sp = Sp - 8;
      if (R1 & 7 != 0) goto ckf5; else goto ckf6;
  ckf6:
      call (I64[R1])(R1) returns to ckf5, args: 8, res: 8, upd: 8;
  ckf5:
      _sjWh::P64 = P64[Sp + 8];
      I64[Sp + 8] = ckfa;
      R5 = Main.runRSTMSingle'2_closure+1;
      R4 = P64[R1 + 7];
      R3 = _sjWh::P64;
      R2 = GHC.Classes.$fOrdWord_closure;
      Sp = Sp + 8;
      call SkipList.$wa3_info(R5,
                              R4,
                              R3,
                              R2) returns to ckfa, args: 8, res: 8, upd: 8;
  ckfa:
      R1 = GHC.Tuple.()_closure+1;
      Sp = Sp + 8;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:52.500744 UTC

[(ckeZ, {SkipList.$wa3_closure}), (ckf0, {SkipList.$wa3_closure}),
 (ckf2, {SkipList.$wa3_closure}), (ckf5, {SkipList.$wa3_closure}),
 (ckf6, {SkipList.$wa3_closure}), (ckfa, {}), (ckfb, {}),
 (ckfc, {SkipList.$wa3_closure}), (ckfd, {SkipList.$wa3_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:52.501401 UTC

sat_sjWp_entry() //  [R1]
        { info_tbl: [(ckeZ,
                      label: block_ckeZ_info
                      rep:StackRep []),
                     (ckf2,
                      label: sat_sjWp_info
                      rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} }),
                     (ckf5,
                      label: block_ckf5_info
                      rep:StackRep [False]),
                     (ckfa,
                      label: block_ckfa_info
                      rep:StackRep [])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckf2:
          _sjWp::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckfb; else goto ckfc;
      ckfc:
          if (HpLim == 0) goto ckfb; else goto ckfd;
      ckfb:
          R1 = _sjWp::P64;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
      ckfd:
          I64[Sp - 8] = ckeZ;
          R1 = P64[_sjWp::P64 + 7];
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto ckeZ; else goto ckf0;
      ckf0:
          call (I64[R1])(R1) returns to ckeZ, args: 8, res: 8, upd: 8;
      ckeZ:
          I64[Sp - 8] = ckf5;
          _sjWh::P64 = P64[R1 + 7];
          R1 = P64[R1 + 15];
          P64[Sp] = _sjWh::P64;
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto ckf5; else goto ckf6;
      ckf6:
          call (I64[R1])(R1) returns to ckf5, args: 8, res: 8, upd: 8;
      ckf5:
          _sjWh::P64 = P64[Sp + 8];
          I64[Sp + 8] = ckfa;
          R5 = Main.runRSTMSingle'2_closure+1;
          R4 = P64[R1 + 7];
          R3 = _sjWh::P64;
          R2 = GHC.Classes.$fOrdWord_closure;
          Sp = Sp + 8;
          call SkipList.$wa3_info(R5,
                                  R4,
                                  R3,
                                  R2) returns to ckfa, args: 8, res: 8, upd: 8;
      ckfa:
          R1 = GHC.Tuple.()_closure+1;
          Sp = Sp + 8;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.503996 UTC

sat_sjWp_entry() //  [R1]
        { info_tbl: [(ckeZ,
                      label: block_ckeZ_info
                      rep:StackRep []),
                     (ckf2,
                      label: sat_sjWp_info
                      rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} }),
                     (ckf5,
                      label: block_ckf5_info
                      rep:StackRep [False]),
                     (ckfa,
                      label: block_ckfa_info
                      rep:StackRep [])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckf2:
          _sjWp::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckfb; else goto ckfc;
      ckfc:
          if (HpLim == 0) goto ckfb; else goto ckfd;
      ckfb:
          R1 = _sjWp::P64;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
      ckfd:
          I64[Sp - 8] = ckeZ;
          R1 = P64[_sjWp::P64 + 7];
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto ckeZ; else goto ckf0;
      ckf0:
          call (I64[R1])(R1) returns to ckeZ, args: 8, res: 8, upd: 8;
      ckeZ:
          I64[Sp - 8] = ckf5;
          _sjWh::P64 = P64[R1 + 7];
          R1 = P64[R1 + 15];
          P64[Sp] = _sjWh::P64;
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto ckf5; else goto ckf6;
      ckf6:
          call (I64[R1])(R1) returns to ckf5, args: 8, res: 8, upd: 8;
      ckf5:
          _sjWh::P64 = P64[Sp + 8];
          I64[Sp + 8] = ckfa;
          R5 = Main.runRSTMSingle'2_closure+1;
          R4 = P64[R1 + 7];
          R3 = _sjWh::P64;
          R2 = GHC.Classes.$fOrdWord_closure;
          Sp = Sp + 8;
          call SkipList.$wa3_info(R5,
                                  R4,
                                  R3,
                                  R2) returns to ckfa, args: 8, res: 8, upd: 8;
      ckfa:
          R1 = GHC.Tuple.()_closure+1;
          Sp = Sp + 8;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.506502 UTC

{offset
  ckfm:
      _sjWb::P64 = R6;
      _sjWa::P64 = R5;
      _sjW9::P64 = R4;
      _sjW8::P64 = R3;
      _sjW7::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckfn; else goto ckfo;
  ckfo:
      if (HpLim == 0) goto ckfn; else goto ckfB;
  ckfn:
      R6 = _sjWb::P64;
      R5 = _sjWa::P64;
      R4 = _sjW9::P64;
      R3 = _sjW8::P64;
      R2 = _sjW7::P64;
      R1 = Main.runRSTMSingle'1_closure;
      call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  ckfB:
      if (HpLim != 0) goto ckfw; else goto ckfD;
  ckfw:
      if (HpLim != 0) goto ckeS; else goto ckfy;
  ckeS:
      Hp = Hp + 16;
      if (Hp > HpLim) goto ckfs; else goto ckfr;
  ckfs:
      HpAlloc = 16;
      I64[(young<ckeR> + 8)] = ckeR;
      call stg_gc_noregs() returns to ckeR, args: 8, res: 8, upd: 8;
  ckeR:
      goto ckeS;
  ckfr:
      I64[Hp - 8] = sat_sjWp_info;
      P64[Hp] = _sjW9::P64;
      _ckeU::P64 = Hp - 7;
      I64[(young<ckfp> + 8)] = ckfp;
      R1 = _ckeU::P64;
      call stg_norec_atomically#(R1) returns to ckfp, args: 8, res: 8, upd: 8;
  ckfp:
      _sjWs::P64 = R1;
      goto ckeS;
  ckfy:
      I64[(young<ckfv> + 8)] = ckfv;
      call stg_gc_noregs() returns to ckfv, args: 8, res: 8, upd: 8;
  ckfv:
      goto ckfw;
  ckfD:
      I64[(young<ckfA> + 8)] = ckfA;
      call stg_gc_noregs() returns to ckfA, args: 8, res: 8, upd: 8;
  ckfA:
      goto ckfB;
}


==================== Post common block elimination ====================
2015-11-09 18:21:52.508695 UTC

{offset
  ckfm:
      _sjWb::P64 = R6;
      _sjWa::P64 = R5;
      _sjW9::P64 = R4;
      _sjW8::P64 = R3;
      _sjW7::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckfn; else goto ckfo;
  ckfo:
      if (HpLim == 0) goto ckfn; else goto ckfB;
  ckfn:
      R6 = _sjWb::P64;
      R5 = _sjWa::P64;
      R4 = _sjW9::P64;
      R3 = _sjW8::P64;
      R2 = _sjW7::P64;
      R1 = Main.runRSTMSingle'1_closure;
      call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  ckfB:
      if (HpLim != 0) goto ckfw; else goto ckfD;
  ckfw:
      if (HpLim != 0) goto ckeS; else goto ckfy;
  ckeS:
      Hp = Hp + 16;
      if (Hp > HpLim) goto ckfs; else goto ckfr;
  ckfs:
      HpAlloc = 16;
      I64[(young<ckeR> + 8)] = ckeR;
      call stg_gc_noregs() returns to ckeR, args: 8, res: 8, upd: 8;
  ckeR:
      goto ckeS;
  ckfr:
      I64[Hp - 8] = sat_sjWp_info;
      P64[Hp] = _sjW9::P64;
      _ckeU::P64 = Hp - 7;
      I64[(young<ckfp> + 8)] = ckfp;
      R1 = _ckeU::P64;
      call stg_norec_atomically#(R1) returns to ckfp, args: 8, res: 8, upd: 8;
  ckfp:
      _sjWs::P64 = R1;
      goto ckeS;
  ckfy:
      I64[(young<ckfv> + 8)] = ckfv;
      call stg_gc_noregs() returns to ckfv, args: 8, res: 8, upd: 8;
  ckfv:
      goto ckfw;
  ckfD:
      I64[(young<ckfA> + 8)] = ckfA;
      call stg_gc_noregs() returns to ckfA, args: 8, res: 8, upd: 8;
  ckfA:
      goto ckfB;
}


==================== Post switch plan ====================
2015-11-09 18:21:52.510885 UTC

{offset
  ckfm:
      _sjWb::P64 = R6;
      _sjWa::P64 = R5;
      _sjW9::P64 = R4;
      _sjW8::P64 = R3;
      _sjW7::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckfn; else goto ckfo;
  ckfo:
      if (HpLim == 0) goto ckfn; else goto ckfB;
  ckfn:
      R6 = _sjWb::P64;
      R5 = _sjWa::P64;
      R4 = _sjW9::P64;
      R3 = _sjW8::P64;
      R2 = _sjW7::P64;
      R1 = Main.runRSTMSingle'1_closure;
      call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  ckfB:
      if (HpLim != 0) goto ckfw; else goto ckfD;
  ckfw:
      if (HpLim != 0) goto ckeS; else goto ckfy;
  ckeS:
      Hp = Hp + 16;
      if (Hp > HpLim) goto ckfs; else goto ckfr;
  ckfs:
      HpAlloc = 16;
      I64[(young<ckeR> + 8)] = ckeR;
      call stg_gc_noregs() returns to ckeR, args: 8, res: 8, upd: 8;
  ckeR:
      goto ckeS;
  ckfr:
      I64[Hp - 8] = sat_sjWp_info;
      P64[Hp] = _sjW9::P64;
      _ckeU::P64 = Hp - 7;
      I64[(young<ckfp> + 8)] = ckfp;
      R1 = _ckeU::P64;
      call stg_norec_atomically#(R1) returns to ckfp, args: 8, res: 8, upd: 8;
  ckfp:
      _sjWs::P64 = R1;
      goto ckeS;
  ckfy:
      I64[(young<ckfv> + 8)] = ckfv;
      call stg_gc_noregs() returns to ckfv, args: 8, res: 8, upd: 8;
  ckfv:
      goto ckfw;
  ckfD:
      I64[(young<ckfA> + 8)] = ckfA;
      call stg_gc_noregs() returns to ckfA, args: 8, res: 8, upd: 8;
  ckfA:
      goto ckfB;
}


==================== Layout Stack ====================
2015-11-09 18:21:52.513397 UTC

{offset
  ckfm:
      _sjWb::P64 = R6;
      _sjWa::P64 = R5;
      _sjW9::P64 = R4;
      _sjW8::P64 = R3;
      _sjW7::P64 = R2;
      if ((Sp + 8) - 24 < SpLim) goto ckfn; else goto ckfo;
  ckfo:
      if (HpLim == 0) goto ckfn; else goto ckfB;
  ckfn:
      R6 = _sjWb::P64;
      R5 = _sjWa::P64;
      R4 = _sjW9::P64;
      R3 = _sjW8::P64;
      R2 = _sjW7::P64;
      R1 = Main.runRSTMSingle'1_closure;
      call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  ckfB:
      if (HpLim != 0) goto ckfw; else goto ckfD;
  ckfw:
      if (HpLim != 0) goto ckeS; else goto ckfy;
  ckeS:
      Hp = Hp + 16;
      if (Hp > HpLim) goto ckfs; else goto ckfr;
  ckfs:
      HpAlloc = 16;
      I64[Sp - 16] = ckeR;
      P64[Sp - 8] = _sjW9::P64;
      Sp = Sp - 16;
      call stg_gc_noregs() returns to ckeR, args: 8, res: 8, upd: 8;
  ckeR:
      _sjW9::P64 = P64[Sp + 8];
      goto ukfG;
  ukfG:
      Sp = Sp + 16;
      goto ckeS;
  ckfr:
      I64[Hp - 8] = sat_sjWp_info;
      P64[Hp] = _sjW9::P64;
      _ckeU::P64 = Hp - 7;
      I64[Sp - 16] = ckfp;
      R1 = _ckeU::P64;
      P64[Sp - 8] = _sjW9::P64;
      Sp = Sp - 16;
      call stg_norec_atomically#(R1) returns to ckfp, args: 8, res: 8, upd: 8;
  ckfp:
      _sjW9::P64 = P64[Sp + 8];
      _sjWs::P64 = R1;
      goto ukfH;
  ukfH:
      Sp = Sp + 16;
      goto ckeS;
  ckfy:
      I64[Sp - 16] = ckfv;
      P64[Sp - 8] = _sjW9::P64;
      Sp = Sp - 16;
      call stg_gc_noregs() returns to ckfv, args: 8, res: 8, upd: 8;
  ckfv:
      _sjW9::P64 = P64[Sp + 8];
      goto ukfI;
  ukfI:
      Sp = Sp + 16;
      goto ckfw;
  ckfD:
      I64[Sp - 16] = ckfA;
      P64[Sp - 8] = _sjW9::P64;
      Sp = Sp - 16;
      call stg_gc_noregs() returns to ckfA, args: 8, res: 8, upd: 8;
  ckfA:
      _sjW9::P64 = P64[Sp + 8];
      goto ukfJ;
  ukfJ:
      Sp = Sp + 16;
      goto ckfB;
}


==================== Sink assignments ====================
2015-11-09 18:21:52.516466 UTC

{offset
  ckfm:
      _sjWb::P64 = R6;
      _sjWa::P64 = R5;
      _sjW9::P64 = R4;
      _sjW8::P64 = R3;
      _sjW7::P64 = R2;
      if ((Sp + -16) < SpLim) goto ckfn; else goto ckfo;
  ckfo:
      if (HpLim == 0) goto ckfn; else goto ckfB;
  ckfn:
      R6 = _sjWb::P64;
      R5 = _sjWa::P64;
      R4 = _sjW9::P64;
      R3 = _sjW8::P64;
      R2 = _sjW7::P64;
      R1 = Main.runRSTMSingle'1_closure;
      call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  ckfB:
      if (HpLim != 0) goto ckfw; else goto ckfD;
  ckfw:
      if (HpLim != 0) goto ckeS; else goto ckfy;
  ckeS:
      Hp = Hp + 16;
      if (Hp > HpLim) goto ckfs; else goto ckfr;
  ckfs:
      HpAlloc = 16;
      I64[Sp - 16] = ckeR;
      P64[Sp - 8] = _sjW9::P64;
      Sp = Sp - 16;
      call stg_gc_noregs() returns to ckeR, args: 8, res: 8, upd: 8;
  ckeR:
      goto ukfG;
  ukfG:
      _sjW9::P64 = P64[Sp + 8];
      Sp = Sp + 16;
      goto ckeS;
  ckfr:
      I64[Hp - 8] = sat_sjWp_info;
      P64[Hp] = _sjW9::P64;
      I64[Sp - 16] = ckfp;
      R1 = Hp - 7;
      P64[Sp - 8] = _sjW9::P64;
      Sp = Sp - 16;
      call stg_norec_atomically#(R1) returns to ckfp, args: 8, res: 8, upd: 8;
  ckfp:
      goto ukfH;
  ukfH:
      _sjW9::P64 = P64[Sp + 8];
      Sp = Sp + 16;
      goto ckeS;
  ckfy:
      I64[Sp - 16] = ckfv;
      P64[Sp - 8] = _sjW9::P64;
      Sp = Sp - 16;
      call stg_gc_noregs() returns to ckfv, args: 8, res: 8, upd: 8;
  ckfv:
      goto ukfI;
  ukfI:
      _sjW9::P64 = P64[Sp + 8];
      Sp = Sp + 16;
      goto ckfw;
  ckfD:
      I64[Sp - 16] = ckfA;
      P64[Sp - 8] = _sjW9::P64;
      Sp = Sp - 16;
      call stg_gc_noregs() returns to ckfA, args: 8, res: 8, upd: 8;
  ckfA:
      goto ukfJ;
  ukfJ:
      _sjW9::P64 = P64[Sp + 8];
      Sp = Sp + 16;
      goto ckfB;
}


==================== CAFEnv ====================
2015-11-09 18:21:52.519851 UTC

[(ckeR, {sat_sjWp_closure}), (ckeS, {sat_sjWp_closure}),
 (ckfm, {Main.runRSTMSingle'1_closure, sat_sjWp_closure}),
 (ckfn, {Main.runRSTMSingle'1_closure}),
 (ckfo, {Main.runRSTMSingle'1_closure, sat_sjWp_closure}),
 (ckfp, {sat_sjWp_closure}), (ckfr, {sat_sjWp_closure}),
 (ckfs, {sat_sjWp_closure}), (ckfv, {sat_sjWp_closure}),
 (ckfw, {sat_sjWp_closure}), (ckfy, {sat_sjWp_closure}),
 (ckfA, {sat_sjWp_closure}), (ckfB, {sat_sjWp_closure}),
 (ckfD, {sat_sjWp_closure}), (ukfG, {sat_sjWp_closure}),
 (ukfH, {sat_sjWp_closure}), (ukfI, {sat_sjWp_closure}),
 (ukfJ, {sat_sjWp_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:52.521163 UTC

Main.runRSTMSingle'1_entry() //  [R6, R5, R4, R3, R2]
        { info_tbl: [(ckeR,
                      label: block_ckeR_info
                      rep:StackRep [False]),
                     (ckfm,
                      label: Main.runRSTMSingle'1_info
                      rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} }),
                     (ckfp,
                      label: block_ckfp_info
                      rep:StackRep [False]),
                     (ckfv,
                      label: block_ckfv_info
                      rep:StackRep [False]),
                     (ckfA,
                      label: block_ckfA_info
                      rep:StackRep [False])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckfm:
          _sjWb::P64 = R6;
          _sjWa::P64 = R5;
          _sjW9::P64 = R4;
          _sjW8::P64 = R3;
          _sjW7::P64 = R2;
          if ((Sp + -16) < SpLim) goto ckfn; else goto ckfo;
      ckfo:
          if (HpLim == 0) goto ckfn; else goto ckfB;
      ckfn:
          R6 = _sjWb::P64;
          R5 = _sjWa::P64;
          R4 = _sjW9::P64;
          R3 = _sjW8::P64;
          R2 = _sjW7::P64;
          R1 = Main.runRSTMSingle'1_closure;
          call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
      ckfB:
          if (HpLim != 0) goto ckfw; else goto ckfD;
      ckfw:
          if (HpLim != 0) goto ckeS; else goto ckfy;
      ckeS:
          Hp = Hp + 16;
          if (Hp > HpLim) goto ckfs; else goto ckfr;
      ckfs:
          HpAlloc = 16;
          I64[Sp - 16] = ckeR;
          P64[Sp - 8] = _sjW9::P64;
          Sp = Sp - 16;
          call stg_gc_noregs() returns to ckeR, args: 8, res: 8, upd: 8;
      ckeR:
          goto ukfG;
      ukfG:
          _sjW9::P64 = P64[Sp + 8];
          Sp = Sp + 16;
          goto ckeS;
      ckfr:
          I64[Hp - 8] = sat_sjWp_info;
          P64[Hp] = _sjW9::P64;
          I64[Sp - 16] = ckfp;
          R1 = Hp - 7;
          P64[Sp - 8] = _sjW9::P64;
          Sp = Sp - 16;
          call stg_norec_atomically#(R1) returns to ckfp, args: 8, res: 8, upd: 8;
      ckfp:
          goto ukfH;
      ukfH:
          _sjW9::P64 = P64[Sp + 8];
          Sp = Sp + 16;
          goto ckeS;
      ckfy:
          I64[Sp - 16] = ckfv;
          P64[Sp - 8] = _sjW9::P64;
          Sp = Sp - 16;
          call stg_gc_noregs() returns to ckfv, args: 8, res: 8, upd: 8;
      ckfv:
          goto ukfI;
      ukfI:
          _sjW9::P64 = P64[Sp + 8];
          Sp = Sp + 16;
          goto ckfw;
      ckfD:
          I64[Sp - 16] = ckfA;
          P64[Sp - 8] = _sjW9::P64;
          Sp = Sp - 16;
          call stg_gc_noregs() returns to ckfA, args: 8, res: 8, upd: 8;
      ckfA:
          goto ukfJ;
      ukfJ:
          _sjW9::P64 = P64[Sp + 8];
          Sp = Sp + 16;
          goto ckfB;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.524896 UTC

Main.runRSTMSingle'1_entry() //  [R6, R5, R4, R3, R2]
        { info_tbl: [(ckeR,
                      label: block_ckeR_info
                      rep:StackRep [False]),
                     (ckfm,
                      label: Main.runRSTMSingle'1_info
                      rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} }),
                     (ckfp,
                      label: block_ckfp_info
                      rep:StackRep [False]),
                     (ckfv,
                      label: block_ckfv_info
                      rep:StackRep [False]),
                     (ckfA,
                      label: block_ckfA_info
                      rep:StackRep [False])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckfm:
          _sjWb::P64 = R6;
          _sjWa::P64 = R5;
          _sjW9::P64 = R4;
          _sjW8::P64 = R3;
          _sjW7::P64 = R2;
          if ((Sp + -16) < SpLim) goto ckfn; else goto ckfo;
      ckfo:
          if (HpLim == 0) goto ckfn; else goto ckfB;
      ckfn:
          R6 = _sjWb::P64;
          R5 = _sjWa::P64;
          R4 = _sjW9::P64;
          R3 = _sjW8::P64;
          R2 = _sjW7::P64;
          R1 = Main.runRSTMSingle'1_closure;
          call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
      ckfB:
          if (HpLim != 0) goto ckfw; else goto ckfD;
      ckfw:
          if (HpLim != 0) goto ckeS; else goto ckfy;
      ckeS:
          Hp = Hp + 16;
          if (Hp > HpLim) goto ckfs; else goto ckfr;
      ckfs:
          HpAlloc = 16;
          I64[Sp - 16] = ckeR;
          P64[Sp - 8] = _sjW9::P64;
          Sp = Sp - 16;
          call stg_gc_noregs() returns to ckeR, args: 8, res: 8, upd: 8;
      ckeR:
          _sjW9::P64 = P64[Sp + 8];
          Sp = Sp + 16;
          goto ckeS;
      ckfr:
          I64[Hp - 8] = sat_sjWp_info;
          P64[Hp] = _sjW9::P64;
          I64[Sp - 16] = ckfp;
          R1 = Hp - 7;
          P64[Sp - 8] = _sjW9::P64;
          Sp = Sp - 16;
          call stg_norec_atomically#(R1) returns to ckfp, args: 8, res: 8, upd: 8;
      ckfp:
          _sjW9::P64 = P64[Sp + 8];
          Sp = Sp + 16;
          goto ckeS;
      ckfy:
          I64[Sp - 16] = ckfv;
          P64[Sp - 8] = _sjW9::P64;
          Sp = Sp - 16;
          call stg_gc_noregs() returns to ckfv, args: 8, res: 8, upd: 8;
      ckfv:
          _sjW9::P64 = P64[Sp + 8];
          Sp = Sp + 16;
          goto ckfw;
      ckfD:
          I64[Sp - 16] = ckfA;
          P64[Sp - 8] = _sjW9::P64;
          Sp = Sp - 16;
          call stg_gc_noregs() returns to ckfA, args: 8, res: 8, upd: 8;
      ckfA:
          _sjW9::P64 = P64[Sp + 8];
          Sp = Sp + 16;
          goto ckfB;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.528529 UTC

[section "data" {
     Main.runRSTMSingle'1_closure:
         const Main.runRSTMSingle'1_info;
         const 0;
 },
 sat_sjWp_entry() //  [R1]
         { info_tbl: [(ckeZ,
                       label: block_ckeZ_info
                       rep:StackRep []),
                      (ckf2,
                       label: sat_sjWp_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} }),
                      (ckf5,
                       label: block_ckf5_info
                       rep:StackRep [False]),
                      (ckfa,
                       label: block_ckfa_info
                       rep:StackRep [])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckf2:
           _sjWp::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckfb; else goto ckfc;
       ckfc:
           if (HpLim == 0) goto ckfb; else goto ckfd;
       ckfb:
           R1 = _sjWp::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ckfd:
           I64[Sp - 8] = ckeZ;
           R1 = P64[_sjWp::P64 + 7];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ckeZ; else goto ckf0;
       ckf0:
           call (I64[R1])(R1) returns to ckeZ, args: 8, res: 8, upd: 8;
       ckeZ:
           I64[Sp - 8] = ckf5;
           _sjWh::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _sjWh::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ckf5; else goto ckf6;
       ckf6:
           call (I64[R1])(R1) returns to ckf5, args: 8, res: 8, upd: 8;
       ckf5:
           _sjWh::P64 = P64[Sp + 8];
           I64[Sp + 8] = ckfa;
           R5 = Main.runRSTMSingle'2_closure+1;
           R4 = P64[R1 + 7];
           R3 = _sjWh::P64;
           R2 = GHC.Classes.$fOrdWord_closure;
           Sp = Sp + 8;
           call SkipList.$wa3_info(R5,
                                   R4,
                                   R3,
                                   R2) returns to ckfa, args: 8, res: 8, upd: 8;
       ckfa:
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Main.runRSTMSingle'1_entry() //  [R6, R5, R4, R3, R2]
         { info_tbl: [(ckeR,
                       label: block_ckeR_info
                       rep:StackRep [False]),
                      (ckfm,
                       label: Main.runRSTMSingle'1_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} }),
                      (ckfp,
                       label: block_ckfp_info
                       rep:StackRep [False]),
                      (ckfv,
                       label: block_ckfv_info
                       rep:StackRep [False]),
                      (ckfA,
                       label: block_ckfA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckfm:
           _sjWb::P64 = R6;
           _sjWa::P64 = R5;
           _sjW9::P64 = R4;
           _sjW8::P64 = R3;
           _sjW7::P64 = R2;
           if ((Sp + -16) < SpLim) goto ckfn; else goto ckfo;
       ckfo:
           if (HpLim == 0) goto ckfn; else goto ckfB;
       ckfn:
           R6 = _sjWb::P64;
           R5 = _sjWa::P64;
           R4 = _sjW9::P64;
           R3 = _sjW8::P64;
           R2 = _sjW7::P64;
           R1 = Main.runRSTMSingle'1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckfB:
           if (HpLim != 0) goto ckfw; else goto ckfD;
       ckfw:
           if (HpLim != 0) goto ckeS; else goto ckfy;
       ckeS:
           Hp = Hp + 16;
           if (Hp > HpLim) goto ckfs; else goto ckfr;
       ckfs:
           HpAlloc = 16;
           I64[Sp - 16] = ckeR;
           P64[Sp - 8] = _sjW9::P64;
           Sp = Sp - 16;
           call stg_gc_noregs() returns to ckeR, args: 8, res: 8, upd: 8;
       ckeR:
           _sjW9::P64 = P64[Sp + 8];
           Sp = Sp + 16;
           goto ckeS;
       ckfr:
           I64[Hp - 8] = sat_sjWp_info;
           P64[Hp] = _sjW9::P64;
           I64[Sp - 16] = ckfp;
           R1 = Hp - 7;
           P64[Sp - 8] = _sjW9::P64;
           Sp = Sp - 16;
           call stg_norec_atomically#(R1) returns to ckfp, args: 8, res: 8, upd: 8;
       ckfp:
           _sjW9::P64 = P64[Sp + 8];
           Sp = Sp + 16;
           goto ckeS;
       ckfy:
           I64[Sp - 16] = ckfv;
           P64[Sp - 8] = _sjW9::P64;
           Sp = Sp - 16;
           call stg_gc_noregs() returns to ckfv, args: 8, res: 8, upd: 8;
       ckfv:
           _sjW9::P64 = P64[Sp + 8];
           Sp = Sp + 16;
           goto ckfw;
       ckfD:
           I64[Sp - 16] = ckfA;
           P64[Sp - 8] = _sjW9::P64;
           Sp = Sp - 16;
           call stg_gc_noregs() returns to ckfA, args: 8, res: 8, upd: 8;
       ckfA:
           _sjW9::P64 = P64[Sp + 8];
           Sp = Sp + 16;
           goto ckfB;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.534916 UTC

[section "data" {
     Main.runRSTMSingle'1_closure:
         const Main.runRSTMSingle'1_info;
         const 0;
 },
 sat_sjWp_entry() //  [R1]
         { info_tbl: [(ckeZ,
                       label: block_ckeZ_info
                       rep:StackRep []),
                      (ckf2,
                       label: sat_sjWp_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} }),
                      (ckf5,
                       label: block_ckf5_info
                       rep:StackRep [False]),
                      (ckfa,
                       label: block_ckfa_info
                       rep:StackRep [])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckf2:
           _sjWp::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckfb; else goto ckfc;
       ckfc:
           if (HpLim == 0) goto ckfb; else goto ckfd;
       ckfb:
           R1 = _sjWp::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ckfd:
           I64[Sp - 8] = ckeZ;
           R1 = P64[_sjWp::P64 + 7];
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ckeZ; else goto ckf0;
       ckf0:
           call (I64[R1])(R1) returns to ckeZ, args: 8, res: 8, upd: 8;
       ckeZ:
           I64[Sp - 8] = ckf5;
           _sjWh::P64 = P64[R1 + 7];
           R1 = P64[R1 + 15];
           P64[Sp] = _sjWh::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ckf5; else goto ckf6;
       ckf6:
           call (I64[R1])(R1) returns to ckf5, args: 8, res: 8, upd: 8;
       ckf5:
           _sjWh::P64 = P64[Sp + 8];
           I64[Sp + 8] = ckfa;
           R5 = Main.runRSTMSingle'2_closure+1;
           R4 = P64[R1 + 7];
           R3 = _sjWh::P64;
           R2 = GHC.Classes.$fOrdWord_closure;
           Sp = Sp + 8;
           call SkipList.$wa3_info(R5,
                                   R4,
                                   R3,
                                   R2) returns to ckfa, args: 8, res: 8, upd: 8;
       ckfa:
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Main.runRSTMSingle'1_entry() //  [R6, R5, R4, R3, R2]
         { info_tbl: [(ckeR,
                       label: block_ckeR_info
                       rep:StackRep [False]),
                      (ckfm,
                       label: Main.runRSTMSingle'1_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} }),
                      (ckfp,
                       label: block_ckfp_info
                       rep:StackRep [False]),
                      (ckfv,
                       label: block_ckfv_info
                       rep:StackRep [False]),
                      (ckfA,
                       label: block_ckfA_info
                       rep:StackRep [False])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckfm:
           _sjWb::P64 = R6;
           _sjWa::P64 = R5;
           _sjW9::P64 = R4;
           _sjW8::P64 = R3;
           _sjW7::P64 = R2;
           if ((Sp + -16) < SpLim) goto ckfn; else goto ckfo;
       ckfo:
           if (HpLim == 0) goto ckfn; else goto ckfB;
       ckfn:
           R6 = _sjWb::P64;
           R5 = _sjWa::P64;
           R4 = _sjW9::P64;
           R3 = _sjW8::P64;
           R2 = _sjW7::P64;
           R1 = Main.runRSTMSingle'1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckfB:
           if (HpLim != 0) goto ckfw; else goto ckfD;
       ckfw:
           if (HpLim != 0) goto ckeS; else goto ckfy;
       ckeS:
           Hp = Hp + 16;
           if (Hp > HpLim) goto ckfs; else goto ckfr;
       ckfs:
           HpAlloc = 16;
           I64[Sp - 16] = ckeR;
           P64[Sp - 8] = _sjW9::P64;
           Sp = Sp - 16;
           call stg_gc_noregs() returns to ckeR, args: 8, res: 8, upd: 8;
       ckeR:
           _sjW9::P64 = P64[Sp + 8];
           Sp = Sp + 16;
           goto ckeS;
       ckfr:
           I64[Hp - 8] = sat_sjWp_info;
           P64[Hp] = _sjW9::P64;
           I64[Sp - 16] = ckfp;
           R1 = Hp - 7;
           P64[Sp - 8] = _sjW9::P64;
           Sp = Sp - 16;
           call stg_norec_atomically#(R1) returns to ckfp, args: 8, res: 8, upd: 8;
       ckfp:
           _sjW9::P64 = P64[Sp + 8];
           Sp = Sp + 16;
           goto ckeS;
       ckfy:
           I64[Sp - 16] = ckfv;
           P64[Sp - 8] = _sjW9::P64;
           Sp = Sp - 16;
           call stg_gc_noregs() returns to ckfv, args: 8, res: 8, upd: 8;
       ckfv:
           _sjW9::P64 = P64[Sp + 8];
           Sp = Sp + 16;
           goto ckfw;
       ckfD:
           I64[Sp - 16] = ckfA;
           P64[Sp - 8] = _sjW9::P64;
           Sp = Sp - 16;
           call stg_gc_noregs() returns to ckfA, args: 8, res: 8, upd: 8;
       ckfA:
           _sjW9::P64 = P64[Sp + 8];
           Sp = Sp + 16;
           goto ckfB;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.550506 UTC

[section "data" {
     Main.rbTreeOpts4_closure:
         const GHC.Types.I#_static_info;
         const 1000;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.550952 UTC

[section "data" {
     Main.rbTreeOpts4_closure:
         const GHC.Types.I#_static_info;
         const 1000;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.551274 UTC

[section "data" {
     Main.rbTreeOpts4_closure:
         const GHC.Types.I#_static_info;
         const 1000;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.551886 UTC

[section "data" {
     Main.rbTreeOpts14_closure:
         const Main.rbTreeOpts14_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ckg1_str:
         I8[] [116,104,114,111,117,103,104,112,117,116]
 },
 Main.rbTreeOpts14_entry() //  [R1]
         { info_tbl: [(ckg2,
                       label: Main.rbTreeOpts14_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckg2:
           _rbT4::P64 = R1;
           goto ckfW;
       ckfW:
           if ((old + 0) - <highSp> < SpLim) goto ckg3; else goto ckg4;
       ckg4:
           if (HpLim == 0) goto ckg3; else goto ckg5;
       ckg3:
           R1 = _rbT4::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckg5:
           (_ckfY::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT4::P64);
           if (_ckfY::I64 == 0) goto ckg0; else goto ckfZ;
       ckg0:
           call (I64[_rbT4::P64])() args: 8, res: 0, upd: 8;
       ckfZ:
           I64[(old + 24)] = stg_bh_upd_frame_info;
           I64[(old + 16)] = _ckfY::I64;
           R2 = ckg1_str;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.554037 UTC

{offset
  ckg2:
      _rbT4::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckg3; else goto ckg4;
  ckg4:
      if (HpLim == 0) goto ckg3; else goto ckg5;
  ckg3:
      R1 = _rbT4::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckg5:
      (_ckfY::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT4::P64);
      if (_ckfY::I64 == 0) goto ckg0; else goto ckfZ;
  ckg0:
      call (I64[_rbT4::P64])() args: 8, res: 0, upd: 8;
  ckfZ:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckfY::I64;
      R2 = ckg1_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:52.55516 UTC

{offset
  ckg2:
      _rbT4::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckg3; else goto ckg4;
  ckg4:
      if (HpLim == 0) goto ckg3; else goto ckg5;
  ckg3:
      R1 = _rbT4::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckg5:
      (_ckfY::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT4::P64);
      if (_ckfY::I64 == 0) goto ckg0; else goto ckfZ;
  ckg0:
      call (I64[_rbT4::P64])() args: 8, res: 0, upd: 8;
  ckfZ:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckfY::I64;
      R2 = ckg1_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:52.556805 UTC

{offset
  ckg2:
      _rbT4::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckg3; else goto ckg4;
  ckg4:
      if (HpLim == 0) goto ckg3; else goto ckg5;
  ckg3:
      R1 = _rbT4::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckg5:
      (_ckfY::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT4::P64);
      if (_ckfY::I64 == 0) goto ckg0; else goto ckfZ;
  ckg0:
      call (I64[_rbT4::P64])() args: 8, res: 0, upd: 8;
  ckfZ:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckfY::I64;
      R2 = ckg1_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:52.558013 UTC

{offset
  ckg2:
      _rbT4::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto ckg3; else goto ckg4;
  ckg4:
      if (HpLim == 0) goto ckg3; else goto ckg5;
  ckg3:
      R1 = _rbT4::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckg5:
      (_ckfY::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT4::P64);
      if (_ckfY::I64 == 0) goto ckg0; else goto ckfZ;
  ckg0:
      call (I64[_rbT4::P64])() args: 8, res: 0, upd: 8;
  ckfZ:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _ckfY::I64;
      R2 = ckg1_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:52.55925 UTC

{offset
  ckg2:
      _rbT4::P64 = R1;
      if ((Sp + -16) < SpLim) goto ckg3; else goto ckg4;
  ckg4:
      if (HpLim == 0) goto ckg3; else goto ckg5;
  ckg3:
      R1 = _rbT4::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckg5:
      (_ckfY::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT4::P64);
      if (_ckfY::I64 == 0) goto ckg0; else goto ckfZ;
  ckg0:
      call (I64[_rbT4::P64])() args: 8, res: 0, upd: 8;
  ckfZ:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _ckfY::I64;
      R2 = ckg1_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:52.560503 UTC

[(ckfZ, {}), (ckg0, {}), (ckg2, {}), (ckg3, {}), (ckg4, {}),
 (ckg5, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:52.560874 UTC

Main.rbTreeOpts14_entry() //  [R1]
        { info_tbl: [(ckg2,
                      label: Main.rbTreeOpts14_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckg2:
          _rbT4::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckg3; else goto ckg4;
      ckg4:
          if (HpLim == 0) goto ckg3; else goto ckg5;
      ckg3:
          R1 = _rbT4::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckg5:
          (_ckfY::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT4::P64);
          if (_ckfY::I64 == 0) goto ckg0; else goto ckfZ;
      ckg0:
          call (I64[_rbT4::P64])() args: 8, res: 0, upd: 8;
      ckfZ:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _ckfY::I64;
          R2 = ckg1_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.562189 UTC

Main.rbTreeOpts14_entry() //  [R1]
        { info_tbl: [(ckg2,
                      label: Main.rbTreeOpts14_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckg2:
          _rbT4::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckg3; else goto ckg4;
      ckg4:
          if (HpLim == 0) goto ckg3; else goto ckg5;
      ckg3:
          R1 = _rbT4::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckg5:
          (_ckfY::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT4::P64);
          if (_ckfY::I64 == 0) goto ckg0; else goto ckfZ;
      ckg0:
          call (I64[_rbT4::P64])() args: 8, res: 0, upd: 8;
      ckfZ:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _ckfY::I64;
          R2 = ckg1_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.563529 UTC

[section "data" {
     Main.rbTreeOpts14_closure:
         const Main.rbTreeOpts14_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ckg1_str:
         I8[] [116,104,114,111,117,103,104,112,117,116]
 },
 Main.rbTreeOpts14_entry() //  [R1]
         { info_tbl: [(ckg2,
                       label: Main.rbTreeOpts14_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckg2:
           _rbT4::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckg3; else goto ckg4;
       ckg4:
           if (HpLim == 0) goto ckg3; else goto ckg5;
       ckg3:
           R1 = _rbT4::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckg5:
           (_ckfY::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT4::P64);
           if (_ckfY::I64 == 0) goto ckg0; else goto ckfZ;
       ckg0:
           call (I64[_rbT4::P64])() args: 8, res: 0, upd: 8;
       ckfZ:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ckfY::I64;
           R2 = ckg1_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.565181 UTC

[section "data" {
     Main.rbTreeOpts14_closure:
         const Main.rbTreeOpts14_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ckg1_str:
         I8[] [116,104,114,111,117,103,104,112,117,116]
 },
 Main.rbTreeOpts14_entry() //  [R1]
         { info_tbl: [(ckg2,
                       label: Main.rbTreeOpts14_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckg2:
           _rbT4::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckg3; else goto ckg4;
       ckg4:
           if (HpLim == 0) goto ckg3; else goto ckg5;
       ckg3:
           R1 = _rbT4::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckg5:
           (_ckfY::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT4::P64);
           if (_ckfY::I64 == 0) goto ckg0; else goto ckfZ;
       ckg0:
           call (I64[_rbT4::P64])() args: 8, res: 0, upd: 8;
       ckfZ:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ckfY::I64;
           R2 = ckg1_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.569914 UTC

[section "data" {
     Main.rbTreeOpts_n_closure:
         const Options.Applicative.Types.OptLong_static_info;
         const Main.rbTreeOpts14_closure;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.570332 UTC

[section "data" {
     Main.rbTreeOpts_n_closure:
         const Options.Applicative.Types.OptLong_static_info;
         const Main.rbTreeOpts14_closure;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.570673 UTC

[section "data" {
     Main.rbTreeOpts_n_closure:
         const Options.Applicative.Types.OptLong_static_info;
         const Main.rbTreeOpts14_closure;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.571325 UTC

[section "data" {
     Main.rbTreeOpts8_closure:
         const Main.rbTreeOpts8_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ckgk_str:
         I8[] [84,104,114,111,117,103,104,112,117,116,32,114,117,110,116,105,109,101,32,105,110,32,109,105,108,108,105,115,101,99,111,110,100,115]
 },
 Main.rbTreeOpts8_entry() //  [R1]
         { info_tbl: [(ckgl,
                       label: Main.rbTreeOpts8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckgl:
           _rbTb::P64 = R1;
           goto ckgf;
       ckgf:
           if ((old + 0) - <highSp> < SpLim) goto ckgm; else goto ckgn;
       ckgn:
           if (HpLim == 0) goto ckgm; else goto ckgo;
       ckgm:
           R1 = _rbTb::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckgo:
           (_ckgh::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTb::P64);
           if (_ckgh::I64 == 0) goto ckgj; else goto ckgi;
       ckgj:
           call (I64[_rbTb::P64])() args: 8, res: 0, upd: 8;
       ckgi:
           I64[(old + 24)] = stg_bh_upd_frame_info;
           I64[(old + 16)] = _ckgh::I64;
           R2 = ckgk_str;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.573437 UTC

{offset
  ckgl:
      _rbTb::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckgm; else goto ckgn;
  ckgn:
      if (HpLim == 0) goto ckgm; else goto ckgo;
  ckgm:
      R1 = _rbTb::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckgo:
      (_ckgh::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTb::P64);
      if (_ckgh::I64 == 0) goto ckgj; else goto ckgi;
  ckgj:
      call (I64[_rbTb::P64])() args: 8, res: 0, upd: 8;
  ckgi:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckgh::I64;
      R2 = ckgk_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:52.574551 UTC

{offset
  ckgl:
      _rbTb::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckgm; else goto ckgn;
  ckgn:
      if (HpLim == 0) goto ckgm; else goto ckgo;
  ckgm:
      R1 = _rbTb::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckgo:
      (_ckgh::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTb::P64);
      if (_ckgh::I64 == 0) goto ckgj; else goto ckgi;
  ckgj:
      call (I64[_rbTb::P64])() args: 8, res: 0, upd: 8;
  ckgi:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckgh::I64;
      R2 = ckgk_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:52.575672 UTC

{offset
  ckgl:
      _rbTb::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckgm; else goto ckgn;
  ckgn:
      if (HpLim == 0) goto ckgm; else goto ckgo;
  ckgm:
      R1 = _rbTb::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckgo:
      (_ckgh::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTb::P64);
      if (_ckgh::I64 == 0) goto ckgj; else goto ckgi;
  ckgj:
      call (I64[_rbTb::P64])() args: 8, res: 0, upd: 8;
  ckgi:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckgh::I64;
      R2 = ckgk_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:52.576831 UTC

{offset
  ckgl:
      _rbTb::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto ckgm; else goto ckgn;
  ckgn:
      if (HpLim == 0) goto ckgm; else goto ckgo;
  ckgm:
      R1 = _rbTb::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckgo:
      (_ckgh::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTb::P64);
      if (_ckgh::I64 == 0) goto ckgj; else goto ckgi;
  ckgj:
      call (I64[_rbTb::P64])() args: 8, res: 0, upd: 8;
  ckgi:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _ckgh::I64;
      R2 = ckgk_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:52.578001 UTC

{offset
  ckgl:
      _rbTb::P64 = R1;
      if ((Sp + -16) < SpLim) goto ckgm; else goto ckgn;
  ckgn:
      if (HpLim == 0) goto ckgm; else goto ckgo;
  ckgm:
      R1 = _rbTb::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckgo:
      (_ckgh::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTb::P64);
      if (_ckgh::I64 == 0) goto ckgj; else goto ckgi;
  ckgj:
      call (I64[_rbTb::P64])() args: 8, res: 0, upd: 8;
  ckgi:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _ckgh::I64;
      R2 = ckgk_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:52.57932 UTC

[(ckgi, {}), (ckgj, {}), (ckgl, {}), (ckgm, {}), (ckgn, {}),
 (ckgo, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:52.579706 UTC

Main.rbTreeOpts8_entry() //  [R1]
        { info_tbl: [(ckgl,
                      label: Main.rbTreeOpts8_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckgl:
          _rbTb::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckgm; else goto ckgn;
      ckgn:
          if (HpLim == 0) goto ckgm; else goto ckgo;
      ckgm:
          R1 = _rbTb::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckgo:
          (_ckgh::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTb::P64);
          if (_ckgh::I64 == 0) goto ckgj; else goto ckgi;
      ckgj:
          call (I64[_rbTb::P64])() args: 8, res: 0, upd: 8;
      ckgi:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _ckgh::I64;
          R2 = ckgk_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.581073 UTC

Main.rbTreeOpts8_entry() //  [R1]
        { info_tbl: [(ckgl,
                      label: Main.rbTreeOpts8_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckgl:
          _rbTb::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckgm; else goto ckgn;
      ckgn:
          if (HpLim == 0) goto ckgm; else goto ckgo;
      ckgm:
          R1 = _rbTb::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckgo:
          (_ckgh::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTb::P64);
          if (_ckgh::I64 == 0) goto ckgj; else goto ckgi;
      ckgj:
          call (I64[_rbTb::P64])() args: 8, res: 0, upd: 8;
      ckgi:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _ckgh::I64;
          R2 = ckgk_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.582456 UTC

[section "data" {
     Main.rbTreeOpts8_closure:
         const Main.rbTreeOpts8_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ckgk_str:
         I8[] [84,104,114,111,117,103,104,112,117,116,32,114,117,110,116,105,109,101,32,105,110,32,109,105,108,108,105,115,101,99,111,110,100,115]
 },
 Main.rbTreeOpts8_entry() //  [R1]
         { info_tbl: [(ckgl,
                       label: Main.rbTreeOpts8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckgl:
           _rbTb::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckgm; else goto ckgn;
       ckgn:
           if (HpLim == 0) goto ckgm; else goto ckgo;
       ckgm:
           R1 = _rbTb::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckgo:
           (_ckgh::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTb::P64);
           if (_ckgh::I64 == 0) goto ckgj; else goto ckgi;
       ckgj:
           call (I64[_rbTb::P64])() args: 8, res: 0, upd: 8;
       ckgi:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ckgh::I64;
           R2 = ckgk_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.5842 UTC

[section "data" {
     Main.rbTreeOpts8_closure:
         const Main.rbTreeOpts8_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ckgk_str:
         I8[] [84,104,114,111,117,103,104,112,117,116,32,114,117,110,116,105,109,101,32,105,110,32,109,105,108,108,105,115,101,99,111,110,100,115]
 },
 Main.rbTreeOpts8_entry() //  [R1]
         { info_tbl: [(ckgl,
                       label: Main.rbTreeOpts8_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckgl:
           _rbTb::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckgm; else goto ckgn;
       ckgn:
           if (HpLim == 0) goto ckgm; else goto ckgo;
       ckgm:
           R1 = _rbTb::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckgo:
           (_ckgh::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTb::P64);
           if (_ckgh::I64 == 0) goto ckgj; else goto ckgi;
       ckgj:
           call (I64[_rbTb::P64])() args: 8, res: 0, upd: 8;
       ckgi:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ckgh::I64;
           R2 = ckgk_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.589682 UTC

[section "data" {
     Main.rbTreeOpts_lvl2_closure:
         const Main.rbTreeOpts_lvl2_info;
         const 0;
         const 0;
         const 0;
 },
 Main.rbTreeOpts_lvl2_entry() //  [R1]
         { info_tbl: [(ckgB,
                       label: Main.rbTreeOpts_lvl2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckgB:
           _rbTK::P64 = R1;
           goto ckgw;
       ckgw:
           if ((old + 0) - <highSp> < SpLim) goto ckgC; else goto ckgD;
       ckgD:
           if (HpLim == 0) goto ckgC; else goto ckgE;
       ckgC:
           R1 = _rbTK::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckgE:
           (_ckgy::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTK::P64);
           if (_ckgy::I64 == 0) goto ckgA; else goto ckgz;
       ckgA:
           call (I64[_rbTK::P64])() args: 8, res: 0, upd: 8;
       ckgz:
           I64[(old + 24)] = stg_bh_upd_frame_info;
           I64[(old + 16)] = _ckgy::I64;
           R4 = Main.rbTreeOpts8_closure;
           R3 = GHC.Base.Nothing_closure+1;
           R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
           call Data.OldList.wordsFB_info(R4,
                                          R3,
                                          R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.591918 UTC

{offset
  ckgB:
      _rbTK::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckgC; else goto ckgD;
  ckgD:
      if (HpLim == 0) goto ckgC; else goto ckgE;
  ckgC:
      R1 = _rbTK::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckgE:
      (_ckgy::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTK::P64);
      if (_ckgy::I64 == 0) goto ckgA; else goto ckgz;
  ckgA:
      call (I64[_rbTK::P64])() args: 8, res: 0, upd: 8;
  ckgz:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckgy::I64;
      R4 = Main.rbTreeOpts8_closure;
      R3 = GHC.Base.Nothing_closure+1;
      R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
      call Data.OldList.wordsFB_info(R4,
                                     R3,
                                     R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:52.593159 UTC

{offset
  ckgB:
      _rbTK::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckgC; else goto ckgD;
  ckgD:
      if (HpLim == 0) goto ckgC; else goto ckgE;
  ckgC:
      R1 = _rbTK::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckgE:
      (_ckgy::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTK::P64);
      if (_ckgy::I64 == 0) goto ckgA; else goto ckgz;
  ckgA:
      call (I64[_rbTK::P64])() args: 8, res: 0, upd: 8;
  ckgz:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckgy::I64;
      R4 = Main.rbTreeOpts8_closure;
      R3 = GHC.Base.Nothing_closure+1;
      R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
      call Data.OldList.wordsFB_info(R4,
                                     R3,
                                     R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:52.594397 UTC

{offset
  ckgB:
      _rbTK::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckgC; else goto ckgD;
  ckgD:
      if (HpLim == 0) goto ckgC; else goto ckgE;
  ckgC:
      R1 = _rbTK::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckgE:
      (_ckgy::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTK::P64);
      if (_ckgy::I64 == 0) goto ckgA; else goto ckgz;
  ckgA:
      call (I64[_rbTK::P64])() args: 8, res: 0, upd: 8;
  ckgz:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckgy::I64;
      R4 = Main.rbTreeOpts8_closure;
      R3 = GHC.Base.Nothing_closure+1;
      R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
      call Data.OldList.wordsFB_info(R4,
                                     R3,
                                     R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:52.595682 UTC

{offset
  ckgB:
      _rbTK::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto ckgC; else goto ckgD;
  ckgD:
      if (HpLim == 0) goto ckgC; else goto ckgE;
  ckgC:
      R1 = _rbTK::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckgE:
      (_ckgy::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTK::P64);
      if (_ckgy::I64 == 0) goto ckgA; else goto ckgz;
  ckgA:
      call (I64[_rbTK::P64])() args: 8, res: 0, upd: 8;
  ckgz:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _ckgy::I64;
      R4 = Main.rbTreeOpts8_closure;
      R3 = GHC.Base.Nothing_closure+1;
      R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
      Sp = Sp - 16;
      call Data.OldList.wordsFB_info(R4,
                                     R3,
                                     R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:52.596945 UTC

{offset
  ckgB:
      _rbTK::P64 = R1;
      if ((Sp + -16) < SpLim) goto ckgC; else goto ckgD;
  ckgD:
      if (HpLim == 0) goto ckgC; else goto ckgE;
  ckgC:
      R1 = _rbTK::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckgE:
      (_ckgy::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTK::P64);
      if (_ckgy::I64 == 0) goto ckgA; else goto ckgz;
  ckgA:
      call (I64[_rbTK::P64])() args: 8, res: 0, upd: 8;
  ckgz:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _ckgy::I64;
      R4 = Main.rbTreeOpts8_closure;
      R3 = GHC.Base.Nothing_closure+1;
      R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
      Sp = Sp - 16;
      call Data.OldList.wordsFB_info(R4,
                                     R3,
                                     R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:52.598411 UTC

[(ckgz,
  {Main.rbTreeOpts8_closure,
   Options.Applicative.Help.Chunk.paragraph1_closure}),
 (ckgA, {}),
 (ckgB,
  {Main.rbTreeOpts8_closure,
   Options.Applicative.Help.Chunk.paragraph1_closure}),
 (ckgC, {}),
 (ckgD,
  {Main.rbTreeOpts8_closure,
   Options.Applicative.Help.Chunk.paragraph1_closure}),
 (ckgE,
  {Main.rbTreeOpts8_closure,
   Options.Applicative.Help.Chunk.paragraph1_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:52.599229 UTC

Main.rbTreeOpts_lvl2_entry() //  [R1]
        { info_tbl: [(ckgB,
                      label: Main.rbTreeOpts_lvl2_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckgB:
          _rbTK::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckgC; else goto ckgD;
      ckgD:
          if (HpLim == 0) goto ckgC; else goto ckgE;
      ckgC:
          R1 = _rbTK::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckgE:
          (_ckgy::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTK::P64);
          if (_ckgy::I64 == 0) goto ckgA; else goto ckgz;
      ckgA:
          call (I64[_rbTK::P64])() args: 8, res: 0, upd: 8;
      ckgz:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _ckgy::I64;
          R4 = Main.rbTreeOpts8_closure;
          R3 = GHC.Base.Nothing_closure+1;
          R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
          Sp = Sp - 16;
          call Data.OldList.wordsFB_info(R4,
                                         R3,
                                         R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.600721 UTC

Main.rbTreeOpts_lvl2_entry() //  [R1]
        { info_tbl: [(ckgB,
                      label: Main.rbTreeOpts_lvl2_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckgB:
          _rbTK::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckgC; else goto ckgD;
      ckgD:
          if (HpLim == 0) goto ckgC; else goto ckgE;
      ckgC:
          R1 = _rbTK::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckgE:
          (_ckgy::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTK::P64);
          if (_ckgy::I64 == 0) goto ckgA; else goto ckgz;
      ckgA:
          call (I64[_rbTK::P64])() args: 8, res: 0, upd: 8;
      ckgz:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _ckgy::I64;
          R4 = Main.rbTreeOpts8_closure;
          R3 = GHC.Base.Nothing_closure+1;
          R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
          Sp = Sp - 16;
          call Data.OldList.wordsFB_info(R4,
                                         R3,
                                         R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.602226 UTC

[section "data" {
     Main.rbTreeOpts_lvl2_closure:
         const Main.rbTreeOpts_lvl2_info;
         const 0;
         const 0;
         const 0;
 },
 Main.rbTreeOpts_lvl2_entry() //  [R1]
         { info_tbl: [(ckgB,
                       label: Main.rbTreeOpts_lvl2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckgB:
           _rbTK::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckgC; else goto ckgD;
       ckgD:
           if (HpLim == 0) goto ckgC; else goto ckgE;
       ckgC:
           R1 = _rbTK::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckgE:
           (_ckgy::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTK::P64);
           if (_ckgy::I64 == 0) goto ckgA; else goto ckgz;
       ckgA:
           call (I64[_rbTK::P64])() args: 8, res: 0, upd: 8;
       ckgz:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ckgy::I64;
           R4 = Main.rbTreeOpts8_closure;
           R3 = GHC.Base.Nothing_closure+1;
           R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
           Sp = Sp - 16;
           call Data.OldList.wordsFB_info(R4,
                                          R3,
                                          R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.604085 UTC

[section "data" {
     Main.rbTreeOpts_lvl2_closure:
         const Main.rbTreeOpts_lvl2_info;
         const 0;
         const 0;
         const 0;
 },
 Main.rbTreeOpts_lvl2_entry() //  [R1]
         { info_tbl: [(ckgB,
                       label: Main.rbTreeOpts_lvl2_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckgB:
           _rbTK::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckgC; else goto ckgD;
       ckgD:
           if (HpLim == 0) goto ckgC; else goto ckgE;
       ckgC:
           R1 = _rbTK::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckgE:
           (_ckgy::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTK::P64);
           if (_ckgy::I64 == 0) goto ckgA; else goto ckgz;
       ckgA:
           call (I64[_rbTK::P64])() args: 8, res: 0, upd: 8;
       ckgz:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ckgy::I64;
           R4 = Main.rbTreeOpts8_closure;
           R3 = GHC.Base.Nothing_closure+1;
           R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
           Sp = Sp - 16;
           call Data.OldList.wordsFB_info(R4,
                                          R3,
                                          R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.608933 UTC

[section "data" {
     Main.rbTreeOpts_n1_closure:
         const Options.Applicative.Types.OptShort_static_info;
         const 115;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.609339 UTC

[section "data" {
     Main.rbTreeOpts_n1_closure:
         const Options.Applicative.Types.OptShort_static_info;
         const 115;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.609649 UTC

[section "data" {
     Main.rbTreeOpts_n1_closure:
         const Options.Applicative.Types.OptShort_static_info;
         const 115;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.610309 UTC

[section "data" {
     Main.rbTreeOpts13_closure:
         const :_static_info;
         const Main.rbTreeOpts_n_closure+2;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.610723 UTC

[section "data" {
     Main.rbTreeOpts13_closure:
         const :_static_info;
         const Main.rbTreeOpts_n_closure+2;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.611101 UTC

[section "data" {
     Main.rbTreeOpts13_closure:
         const :_static_info;
         const Main.rbTreeOpts_n_closure+2;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.611873 UTC

[section "data" {
     Main.rbTreeOpts12_closure:
         const :_static_info;
         const Main.rbTreeOpts_n1_closure+1;
         const Main.rbTreeOpts13_closure+2;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.612301 UTC

[section "data" {
     Main.rbTreeOpts12_closure:
         const :_static_info;
         const Main.rbTreeOpts_n1_closure+1;
         const Main.rbTreeOpts13_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.612678 UTC

[section "data" {
     Main.rbTreeOpts12_closure:
         const :_static_info;
         const Main.rbTreeOpts_n1_closure+1;
         const Main.rbTreeOpts13_closure+2;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.613483 UTC

[section "data" {
     Main.rbTreeOpts11_closure:
         const Main.rbTreeOpts11_info;
         const 0;
 },
 Main.rbTreeOpts11_entry() //  [R2]
         { info_tbl: [(ckgU,
                       label: Main.rbTreeOpts11_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckgU:
           _B1::P64 = R2;
           goto ckgS;
       ckgS:
           if ((old + 0) - <highSp> < SpLim) goto ckgV; else goto ckgW;
       ckgW:
           goto ckgR;
       ckgR:
           if (HpLim == 0) goto ckgV; else goto ckgX;
       ckgV:
           R2 = _B1::P64;
           R1 = Main.rbTreeOpts11_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckgX:
           R3 = _B1::P64;
           R2 = GHC.Read.$fReadInt_closure;
           call Options.Applicative.Builder.auto1_info(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.615585 UTC

{offset
  ckgU:
      _B1::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckgV; else goto ckgW;
  ckgW:
      if (HpLim == 0) goto ckgV; else goto ckgX;
  ckgV:
      R2 = _B1::P64;
      R1 = Main.rbTreeOpts11_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckgX:
      R3 = _B1::P64;
      R2 = GHC.Read.$fReadInt_closure;
      call Options.Applicative.Builder.auto1_info(R3,
                                                  R2) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:52.616395 UTC

{offset
  ckgU:
      _B1::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckgV; else goto ckgW;
  ckgW:
      if (HpLim == 0) goto ckgV; else goto ckgX;
  ckgV:
      R2 = _B1::P64;
      R1 = Main.rbTreeOpts11_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckgX:
      R3 = _B1::P64;
      R2 = GHC.Read.$fReadInt_closure;
      call Options.Applicative.Builder.auto1_info(R3,
                                                  R2) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:52.617231 UTC

{offset
  ckgU:
      _B1::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckgV; else goto ckgW;
  ckgW:
      if (HpLim == 0) goto ckgV; else goto ckgX;
  ckgV:
      R2 = _B1::P64;
      R1 = Main.rbTreeOpts11_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckgX:
      R3 = _B1::P64;
      R2 = GHC.Read.$fReadInt_closure;
      call Options.Applicative.Builder.auto1_info(R3,
                                                  R2) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:52.618076 UTC

{offset
  ckgU:
      _B1::P64 = R2;
      goto ckgW;
  ckgW:
      if (HpLim == 0) goto ckgV; else goto ckgX;
  ckgV:
      R2 = _B1::P64;
      R1 = Main.rbTreeOpts11_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckgX:
      R3 = _B1::P64;
      R2 = GHC.Read.$fReadInt_closure;
      call Options.Applicative.Builder.auto1_info(R3,
                                                  R2) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:52.618805 UTC

{offset
  ckgU:
      goto ckgW;
  ckgW:
      if (HpLim == 0) goto ckgV; else goto ckgX;
  ckgV:
      R2 = R2;
      R1 = Main.rbTreeOpts11_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckgX:
      R3 = R2;
      R2 = GHC.Read.$fReadInt_closure;
      call Options.Applicative.Builder.auto1_info(R3,
                                                  R2) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:52.619707 UTC

[(ckgU,
  {GHC.Read.$fReadInt_closure,
   Options.Applicative.Builder.auto1_closure,
   Main.rbTreeOpts11_closure}),
 (ckgV, {Main.rbTreeOpts11_closure}),
 (ckgW,
  {GHC.Read.$fReadInt_closure,
   Options.Applicative.Builder.auto1_closure,
   Main.rbTreeOpts11_closure}),
 (ckgX,
  {GHC.Read.$fReadInt_closure,
   Options.Applicative.Builder.auto1_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:52.620352 UTC

Main.rbTreeOpts11_entry() //  [R2]
        { info_tbl: [(ckgU,
                      label: Main.rbTreeOpts11_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckgU:
          goto ckgW;
      ckgW:
          if (HpLim == 0) goto ckgV; else goto ckgX;
      ckgV:
          R2 = R2;
          R1 = Main.rbTreeOpts11_closure;
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
      ckgX:
          R3 = R2;
          R2 = GHC.Read.$fReadInt_closure;
          call Options.Applicative.Builder.auto1_info(R3,
                                                      R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.621269 UTC

Main.rbTreeOpts11_entry() //  [R2]
        { info_tbl: [(ckgU,
                      label: Main.rbTreeOpts11_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckgU:
          if (HpLim == 0) goto ckgV; else goto ckgX;
      ckgV:
          R2 = R2;
          R1 = Main.rbTreeOpts11_closure;
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
      ckgX:
          R3 = R2;
          R2 = GHC.Read.$fReadInt_closure;
          call Options.Applicative.Builder.auto1_info(R3,
                                                      R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.62215 UTC

[section "data" {
     Main.rbTreeOpts11_closure:
         const Main.rbTreeOpts11_info;
         const 0;
 },
 Main.rbTreeOpts11_entry() //  [R2]
         { info_tbl: [(ckgU,
                       label: Main.rbTreeOpts11_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckgU:
           if (HpLim == 0) goto ckgV; else goto ckgX;
       ckgV:
           R2 = R2;
           R1 = Main.rbTreeOpts11_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckgX:
           R3 = R2;
           R2 = GHC.Read.$fReadInt_closure;
           call Options.Applicative.Builder.auto1_info(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.623256 UTC

[section "data" {
     Main.rbTreeOpts11_closure:
         const Main.rbTreeOpts11_info;
         const 0;
 },
 Main.rbTreeOpts11_entry() //  [R2]
         { info_tbl: [(ckgU,
                       label: Main.rbTreeOpts11_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckgU:
           if (HpLim == 0) goto ckgV; else goto ckgX;
       ckgV:
           R2 = R2;
           R1 = Main.rbTreeOpts11_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckgX:
           R3 = R2;
           R2 = GHC.Read.$fReadInt_closure;
           call Options.Applicative.Builder.auto1_info(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.626072 UTC

[section "data" {
     Main.rbTreeOpts10_closure:
         const Options.Applicative.Types.CReader_static_info;
         const Options.Applicative.Types.$fMonoidCompleter4_closure+2;
         const Main.rbTreeOpts11_closure+1;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.626533 UTC

[section "data" {
     Main.rbTreeOpts10_closure:
         const Options.Applicative.Types.CReader_static_info;
         const Options.Applicative.Types.$fMonoidCompleter4_closure+2;
         const Main.rbTreeOpts11_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.626919 UTC

[section "data" {
     Main.rbTreeOpts10_closure:
         const Options.Applicative.Types.CReader_static_info;
         const Options.Applicative.Types.$fMonoidCompleter4_closure+2;
         const Main.rbTreeOpts11_closure+1;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.627754 UTC

[section "data" {
     Main.rbTreeOpts9_closure:
         const Options.Applicative.Types.OptReader_static_info;
         const Main.rbTreeOpts12_closure+2;
         const Main.rbTreeOpts10_closure+1;
         const Options.Applicative.Builder.abortOption3_closure;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.628208 UTC

[section "data" {
     Main.rbTreeOpts9_closure:
         const Options.Applicative.Types.OptReader_static_info;
         const Main.rbTreeOpts12_closure+2;
         const Main.rbTreeOpts10_closure+1;
         const Options.Applicative.Builder.abortOption3_closure;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.62862 UTC

[section "data" {
     Main.rbTreeOpts9_closure:
         const Options.Applicative.Types.OptReader_static_info;
         const Main.rbTreeOpts12_closure+2;
         const Main.rbTreeOpts10_closure+1;
         const Options.Applicative.Builder.abortOption3_closure;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.629544 UTC

[section "data" {
     Main.rbTreeOpts7_closure:
         const Options.Applicative.Types.OptProperties_static_info;
         const Options.Applicative.Types.Visible_closure+3;
         const Main.rbTreeOpts_lvl2_closure;
         const Options.Applicative.Builder.abortOption_var_closure;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.630038 UTC

[section "data" {
     Main.rbTreeOpts7_closure:
         const Options.Applicative.Types.OptProperties_static_info;
         const Options.Applicative.Types.Visible_closure+3;
         const Main.rbTreeOpts_lvl2_closure;
         const Options.Applicative.Builder.abortOption_var_closure;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.630486 UTC

[section "data" {
     Main.rbTreeOpts7_closure:
         const Options.Applicative.Types.OptProperties_static_info;
         const Options.Applicative.Types.Visible_closure+3;
         const Main.rbTreeOpts_lvl2_closure;
         const Options.Applicative.Builder.abortOption_var_closure;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.631391 UTC

[section "data" {
     Main.rbTreeOpts6_closure:
         const Options.Applicative.Types.Option_static_info;
         const Main.rbTreeOpts9_closure+1;
         const Main.rbTreeOpts7_closure+1;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.631824 UTC

[section "data" {
     Main.rbTreeOpts6_closure:
         const Options.Applicative.Types.Option_static_info;
         const Main.rbTreeOpts9_closure+1;
         const Main.rbTreeOpts7_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.632204 UTC

[section "data" {
     Main.rbTreeOpts6_closure:
         const Options.Applicative.Types.Option_static_info;
         const Main.rbTreeOpts9_closure+1;
         const Main.rbTreeOpts7_closure+1;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.633435 UTC

[section "data" {
     Main.rbTreeOpts3_closure:
         const GHC.Base.Just_static_info;
         const Main.rbTreeOpts4_closure+1;
         const 3;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.63381 UTC

[section "data" {
     Main.rbTreeOpts3_closure:
         const GHC.Base.Just_static_info;
         const Main.rbTreeOpts4_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.634165 UTC

[section "data" {
     Main.rbTreeOpts3_closure:
         const GHC.Base.Just_static_info;
         const Main.rbTreeOpts4_closure+1;
         const 3;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.634843 UTC

[section "data" {
     Main.rbTreeOpts5_closure:
         const Options.Applicative.Types.OptP_static_info;
         const Main.rbTreeOpts6_closure+1;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.63522 UTC

[section "data" {
     Main.rbTreeOpts5_closure:
         const Options.Applicative.Types.OptP_static_info;
         const Main.rbTreeOpts6_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.63556 UTC

[section "data" {
     Main.rbTreeOpts5_closure:
         const Options.Applicative.Types.OptP_static_info;
         const Main.rbTreeOpts6_closure+1;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.63628 UTC

[section "data" {
     Main.rbTreeOpts2_closure:
         const Options.Applicative.Types.NilP_static_info;
         const Main.rbTreeOpts3_closure+2;
         const 3;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.636655 UTC

[section "data" {
     Main.rbTreeOpts2_closure:
         const Options.Applicative.Types.NilP_static_info;
         const Main.rbTreeOpts3_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.637029 UTC

[section "data" {
     Main.rbTreeOpts2_closure:
         const Options.Applicative.Types.NilP_static_info;
         const Main.rbTreeOpts3_closure+2;
         const 3;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.637722 UTC

[section "data" {
     Main.rbTreeOpts1_closure:
         const Options.Applicative.Types.AltP_static_info;
         const Main.rbTreeOpts5_closure+2;
         const Main.rbTreeOpts2_closure+1;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.638142 UTC

[section "data" {
     Main.rbTreeOpts1_closure:
         const Options.Applicative.Types.AltP_static_info;
         const Main.rbTreeOpts5_closure+2;
         const Main.rbTreeOpts2_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.638527 UTC

[section "data" {
     Main.rbTreeOpts1_closure:
         const Options.Applicative.Types.AltP_static_info;
         const Main.rbTreeOpts5_closure+2;
         const Main.rbTreeOpts2_closure+1;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.639387 UTC

[section "data" {
     Main.rbTreeOpts19_closure:
         const GHC.Types.D#_static_info;
         const 90.0 :: W64;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.639777 UTC

[section "data" {
     Main.rbTreeOpts19_closure:
         const GHC.Types.D#_static_info;
         const 90.0 :: W64;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.640097 UTC

[section "data" {
     Main.rbTreeOpts19_closure:
         const GHC.Types.D#_static_info;
         const 90.0 :: W64;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.640792 UTC

[section "data" {
     Main.rbTreeOpts29_closure:
         const Main.rbTreeOpts29_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ckhq_str:
         I8[] [109,105,120]
 },
 Main.rbTreeOpts29_entry() //  [R1]
         { info_tbl: [(ckhr,
                       label: Main.rbTreeOpts29_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckhr:
           _rbT0::P64 = R1;
           goto ckhl;
       ckhl:
           if ((old + 0) - <highSp> < SpLim) goto ckhs; else goto ckht;
       ckht:
           if (HpLim == 0) goto ckhs; else goto ckhu;
       ckhs:
           R1 = _rbT0::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckhu:
           (_ckhn::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT0::P64);
           if (_ckhn::I64 == 0) goto ckhp; else goto ckho;
       ckhp:
           call (I64[_rbT0::P64])() args: 8, res: 0, upd: 8;
       ckho:
           I64[(old + 24)] = stg_bh_upd_frame_info;
           I64[(old + 16)] = _ckhn::I64;
           R2 = ckhq_str;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.642946 UTC

{offset
  ckhr:
      _rbT0::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckhs; else goto ckht;
  ckht:
      if (HpLim == 0) goto ckhs; else goto ckhu;
  ckhs:
      R1 = _rbT0::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckhu:
      (_ckhn::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT0::P64);
      if (_ckhn::I64 == 0) goto ckhp; else goto ckho;
  ckhp:
      call (I64[_rbT0::P64])() args: 8, res: 0, upd: 8;
  ckho:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckhn::I64;
      R2 = ckhq_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:52.644056 UTC

{offset
  ckhr:
      _rbT0::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckhs; else goto ckht;
  ckht:
      if (HpLim == 0) goto ckhs; else goto ckhu;
  ckhs:
      R1 = _rbT0::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckhu:
      (_ckhn::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT0::P64);
      if (_ckhn::I64 == 0) goto ckhp; else goto ckho;
  ckhp:
      call (I64[_rbT0::P64])() args: 8, res: 0, upd: 8;
  ckho:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckhn::I64;
      R2 = ckhq_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:52.645191 UTC

{offset
  ckhr:
      _rbT0::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckhs; else goto ckht;
  ckht:
      if (HpLim == 0) goto ckhs; else goto ckhu;
  ckhs:
      R1 = _rbT0::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckhu:
      (_ckhn::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT0::P64);
      if (_ckhn::I64 == 0) goto ckhp; else goto ckho;
  ckhp:
      call (I64[_rbT0::P64])() args: 8, res: 0, upd: 8;
  ckho:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckhn::I64;
      R2 = ckhq_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:52.646367 UTC

{offset
  ckhr:
      _rbT0::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto ckhs; else goto ckht;
  ckht:
      if (HpLim == 0) goto ckhs; else goto ckhu;
  ckhs:
      R1 = _rbT0::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckhu:
      (_ckhn::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT0::P64);
      if (_ckhn::I64 == 0) goto ckhp; else goto ckho;
  ckhp:
      call (I64[_rbT0::P64])() args: 8, res: 0, upd: 8;
  ckho:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _ckhn::I64;
      R2 = ckhq_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:52.647531 UTC

{offset
  ckhr:
      _rbT0::P64 = R1;
      if ((Sp + -16) < SpLim) goto ckhs; else goto ckht;
  ckht:
      if (HpLim == 0) goto ckhs; else goto ckhu;
  ckhs:
      R1 = _rbT0::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckhu:
      (_ckhn::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT0::P64);
      if (_ckhn::I64 == 0) goto ckhp; else goto ckho;
  ckhp:
      call (I64[_rbT0::P64])() args: 8, res: 0, upd: 8;
  ckho:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _ckhn::I64;
      R2 = ckhq_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:52.649365 UTC

[(ckho, {}), (ckhp, {}), (ckhr, {}), (ckhs, {}), (ckht, {}),
 (ckhu, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:52.649766 UTC

Main.rbTreeOpts29_entry() //  [R1]
        { info_tbl: [(ckhr,
                      label: Main.rbTreeOpts29_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckhr:
          _rbT0::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckhs; else goto ckht;
      ckht:
          if (HpLim == 0) goto ckhs; else goto ckhu;
      ckhs:
          R1 = _rbT0::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckhu:
          (_ckhn::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT0::P64);
          if (_ckhn::I64 == 0) goto ckhp; else goto ckho;
      ckhp:
          call (I64[_rbT0::P64])() args: 8, res: 0, upd: 8;
      ckho:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _ckhn::I64;
          R2 = ckhq_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.651122 UTC

Main.rbTreeOpts29_entry() //  [R1]
        { info_tbl: [(ckhr,
                      label: Main.rbTreeOpts29_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckhr:
          _rbT0::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckhs; else goto ckht;
      ckht:
          if (HpLim == 0) goto ckhs; else goto ckhu;
      ckhs:
          R1 = _rbT0::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckhu:
          (_ckhn::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT0::P64);
          if (_ckhn::I64 == 0) goto ckhp; else goto ckho;
      ckhp:
          call (I64[_rbT0::P64])() args: 8, res: 0, upd: 8;
      ckho:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _ckhn::I64;
          R2 = ckhq_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.652519 UTC

[section "data" {
     Main.rbTreeOpts29_closure:
         const Main.rbTreeOpts29_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ckhq_str:
         I8[] [109,105,120]
 },
 Main.rbTreeOpts29_entry() //  [R1]
         { info_tbl: [(ckhr,
                       label: Main.rbTreeOpts29_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckhr:
           _rbT0::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckhs; else goto ckht;
       ckht:
           if (HpLim == 0) goto ckhs; else goto ckhu;
       ckhs:
           R1 = _rbT0::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckhu:
           (_ckhn::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT0::P64);
           if (_ckhn::I64 == 0) goto ckhp; else goto ckho;
       ckhp:
           call (I64[_rbT0::P64])() args: 8, res: 0, upd: 8;
       ckho:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ckhn::I64;
           R2 = ckhq_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.654238 UTC

[section "data" {
     Main.rbTreeOpts29_closure:
         const Main.rbTreeOpts29_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ckhq_str:
         I8[] [109,105,120]
 },
 Main.rbTreeOpts29_entry() //  [R1]
         { info_tbl: [(ckhr,
                       label: Main.rbTreeOpts29_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckhr:
           _rbT0::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckhs; else goto ckht;
       ckht:
           if (HpLim == 0) goto ckhs; else goto ckhu;
       ckhs:
           R1 = _rbT0::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckhu:
           (_ckhn::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT0::P64);
           if (_ckhn::I64 == 0) goto ckhp; else goto ckho;
       ckhp:
           call (I64[_rbT0::P64])() args: 8, res: 0, upd: 8;
       ckho:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ckhn::I64;
           R2 = ckhq_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.658926 UTC

[section "data" {
     Main.rbTreeOpts_n2_closure:
         const Options.Applicative.Types.OptLong_static_info;
         const Main.rbTreeOpts29_closure;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.659445 UTC

[section "data" {
     Main.rbTreeOpts_n2_closure:
         const Options.Applicative.Types.OptLong_static_info;
         const Main.rbTreeOpts29_closure;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.659789 UTC

[section "data" {
     Main.rbTreeOpts_n2_closure:
         const Options.Applicative.Types.OptLong_static_info;
         const Main.rbTreeOpts29_closure;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.660458 UTC

[section "data" {
     Main.rbTreeOpts23_closure:
         const Main.rbTreeOpts23_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ckhJ_str:
         I8[] [82,101,97,100,32,109,105,120,32,112,101,114,99,101,110,116]
 },
 Main.rbTreeOpts23_entry() //  [R1]
         { info_tbl: [(ckhK,
                       label: Main.rbTreeOpts23_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckhK:
           _rbTc::P64 = R1;
           goto ckhE;
       ckhE:
           if ((old + 0) - <highSp> < SpLim) goto ckhL; else goto ckhM;
       ckhM:
           if (HpLim == 0) goto ckhL; else goto ckhN;
       ckhL:
           R1 = _rbTc::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckhN:
           (_ckhG::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTc::P64);
           if (_ckhG::I64 == 0) goto ckhI; else goto ckhH;
       ckhI:
           call (I64[_rbTc::P64])() args: 8, res: 0, upd: 8;
       ckhH:
           I64[(old + 24)] = stg_bh_upd_frame_info;
           I64[(old + 16)] = _ckhG::I64;
           R2 = ckhJ_str;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.662572 UTC

{offset
  ckhK:
      _rbTc::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckhL; else goto ckhM;
  ckhM:
      if (HpLim == 0) goto ckhL; else goto ckhN;
  ckhL:
      R1 = _rbTc::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckhN:
      (_ckhG::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTc::P64);
      if (_ckhG::I64 == 0) goto ckhI; else goto ckhH;
  ckhI:
      call (I64[_rbTc::P64])() args: 8, res: 0, upd: 8;
  ckhH:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckhG::I64;
      R2 = ckhJ_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:52.663664 UTC

{offset
  ckhK:
      _rbTc::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckhL; else goto ckhM;
  ckhM:
      if (HpLim == 0) goto ckhL; else goto ckhN;
  ckhL:
      R1 = _rbTc::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckhN:
      (_ckhG::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTc::P64);
      if (_ckhG::I64 == 0) goto ckhI; else goto ckhH;
  ckhI:
      call (I64[_rbTc::P64])() args: 8, res: 0, upd: 8;
  ckhH:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckhG::I64;
      R2 = ckhJ_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:52.66478 UTC

{offset
  ckhK:
      _rbTc::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckhL; else goto ckhM;
  ckhM:
      if (HpLim == 0) goto ckhL; else goto ckhN;
  ckhL:
      R1 = _rbTc::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckhN:
      (_ckhG::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTc::P64);
      if (_ckhG::I64 == 0) goto ckhI; else goto ckhH;
  ckhI:
      call (I64[_rbTc::P64])() args: 8, res: 0, upd: 8;
  ckhH:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckhG::I64;
      R2 = ckhJ_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:52.665957 UTC

{offset
  ckhK:
      _rbTc::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto ckhL; else goto ckhM;
  ckhM:
      if (HpLim == 0) goto ckhL; else goto ckhN;
  ckhL:
      R1 = _rbTc::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckhN:
      (_ckhG::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTc::P64);
      if (_ckhG::I64 == 0) goto ckhI; else goto ckhH;
  ckhI:
      call (I64[_rbTc::P64])() args: 8, res: 0, upd: 8;
  ckhH:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _ckhG::I64;
      R2 = ckhJ_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:52.667118 UTC

{offset
  ckhK:
      _rbTc::P64 = R1;
      if ((Sp + -16) < SpLim) goto ckhL; else goto ckhM;
  ckhM:
      if (HpLim == 0) goto ckhL; else goto ckhN;
  ckhL:
      R1 = _rbTc::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckhN:
      (_ckhG::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTc::P64);
      if (_ckhG::I64 == 0) goto ckhI; else goto ckhH;
  ckhI:
      call (I64[_rbTc::P64])() args: 8, res: 0, upd: 8;
  ckhH:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _ckhG::I64;
      R2 = ckhJ_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:52.668409 UTC

[(ckhH, {}), (ckhI, {}), (ckhK, {}), (ckhL, {}), (ckhM, {}),
 (ckhN, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:52.668792 UTC

Main.rbTreeOpts23_entry() //  [R1]
        { info_tbl: [(ckhK,
                      label: Main.rbTreeOpts23_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckhK:
          _rbTc::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckhL; else goto ckhM;
      ckhM:
          if (HpLim == 0) goto ckhL; else goto ckhN;
      ckhL:
          R1 = _rbTc::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckhN:
          (_ckhG::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTc::P64);
          if (_ckhG::I64 == 0) goto ckhI; else goto ckhH;
      ckhI:
          call (I64[_rbTc::P64])() args: 8, res: 0, upd: 8;
      ckhH:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _ckhG::I64;
          R2 = ckhJ_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.670175 UTC

Main.rbTreeOpts23_entry() //  [R1]
        { info_tbl: [(ckhK,
                      label: Main.rbTreeOpts23_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckhK:
          _rbTc::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckhL; else goto ckhM;
      ckhM:
          if (HpLim == 0) goto ckhL; else goto ckhN;
      ckhL:
          R1 = _rbTc::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckhN:
          (_ckhG::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTc::P64);
          if (_ckhG::I64 == 0) goto ckhI; else goto ckhH;
      ckhI:
          call (I64[_rbTc::P64])() args: 8, res: 0, upd: 8;
      ckhH:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _ckhG::I64;
          R2 = ckhJ_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.671563 UTC

[section "data" {
     Main.rbTreeOpts23_closure:
         const Main.rbTreeOpts23_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ckhJ_str:
         I8[] [82,101,97,100,32,109,105,120,32,112,101,114,99,101,110,116]
 },
 Main.rbTreeOpts23_entry() //  [R1]
         { info_tbl: [(ckhK,
                       label: Main.rbTreeOpts23_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckhK:
           _rbTc::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckhL; else goto ckhM;
       ckhM:
           if (HpLim == 0) goto ckhL; else goto ckhN;
       ckhL:
           R1 = _rbTc::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckhN:
           (_ckhG::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTc::P64);
           if (_ckhG::I64 == 0) goto ckhI; else goto ckhH;
       ckhI:
           call (I64[_rbTc::P64])() args: 8, res: 0, upd: 8;
       ckhH:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ckhG::I64;
           R2 = ckhJ_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.673303 UTC

[section "data" {
     Main.rbTreeOpts23_closure:
         const Main.rbTreeOpts23_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ckhJ_str:
         I8[] [82,101,97,100,32,109,105,120,32,112,101,114,99,101,110,116]
 },
 Main.rbTreeOpts23_entry() //  [R1]
         { info_tbl: [(ckhK,
                       label: Main.rbTreeOpts23_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckhK:
           _rbTc::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckhL; else goto ckhM;
       ckhM:
           if (HpLim == 0) goto ckhL; else goto ckhN;
       ckhL:
           R1 = _rbTc::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckhN:
           (_ckhG::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTc::P64);
           if (_ckhG::I64 == 0) goto ckhI; else goto ckhH;
       ckhI:
           call (I64[_rbTc::P64])() args: 8, res: 0, upd: 8;
       ckhH:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ckhG::I64;
           R2 = ckhJ_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.678128 UTC

[section "data" {
     Main.rbTreeOpts_lvl1_closure:
         const Main.rbTreeOpts_lvl1_info;
         const 0;
         const 0;
         const 0;
 },
 Main.rbTreeOpts_lvl1_entry() //  [R1]
         { info_tbl: [(cki0,
                       label: Main.rbTreeOpts_lvl1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cki0:
           _rbUM::P64 = R1;
           goto ckhV;
       ckhV:
           if ((old + 0) - <highSp> < SpLim) goto cki1; else goto cki2;
       cki2:
           if (HpLim == 0) goto cki1; else goto cki3;
       cki1:
           R1 = _rbUM::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cki3:
           (_ckhX::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbUM::P64);
           if (_ckhX::I64 == 0) goto ckhZ; else goto ckhY;
       ckhZ:
           call (I64[_rbUM::P64])() args: 8, res: 0, upd: 8;
       ckhY:
           I64[(old + 24)] = stg_bh_upd_frame_info;
           I64[(old + 16)] = _ckhX::I64;
           R4 = Main.rbTreeOpts23_closure;
           R3 = GHC.Base.Nothing_closure+1;
           R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
           call Data.OldList.wordsFB_info(R4,
                                          R3,
                                          R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.680408 UTC

{offset
  cki0:
      _rbUM::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cki1; else goto cki2;
  cki2:
      if (HpLim == 0) goto cki1; else goto cki3;
  cki1:
      R1 = _rbUM::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cki3:
      (_ckhX::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbUM::P64);
      if (_ckhX::I64 == 0) goto ckhZ; else goto ckhY;
  ckhZ:
      call (I64[_rbUM::P64])() args: 8, res: 0, upd: 8;
  ckhY:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckhX::I64;
      R4 = Main.rbTreeOpts23_closure;
      R3 = GHC.Base.Nothing_closure+1;
      R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
      call Data.OldList.wordsFB_info(R4,
                                     R3,
                                     R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:52.681637 UTC

{offset
  cki0:
      _rbUM::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cki1; else goto cki2;
  cki2:
      if (HpLim == 0) goto cki1; else goto cki3;
  cki1:
      R1 = _rbUM::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cki3:
      (_ckhX::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbUM::P64);
      if (_ckhX::I64 == 0) goto ckhZ; else goto ckhY;
  ckhZ:
      call (I64[_rbUM::P64])() args: 8, res: 0, upd: 8;
  ckhY:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckhX::I64;
      R4 = Main.rbTreeOpts23_closure;
      R3 = GHC.Base.Nothing_closure+1;
      R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
      call Data.OldList.wordsFB_info(R4,
                                     R3,
                                     R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:52.683393 UTC

{offset
  cki0:
      _rbUM::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cki1; else goto cki2;
  cki2:
      if (HpLim == 0) goto cki1; else goto cki3;
  cki1:
      R1 = _rbUM::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cki3:
      (_ckhX::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbUM::P64);
      if (_ckhX::I64 == 0) goto ckhZ; else goto ckhY;
  ckhZ:
      call (I64[_rbUM::P64])() args: 8, res: 0, upd: 8;
  ckhY:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckhX::I64;
      R4 = Main.rbTreeOpts23_closure;
      R3 = GHC.Base.Nothing_closure+1;
      R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
      call Data.OldList.wordsFB_info(R4,
                                     R3,
                                     R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:52.684667 UTC

{offset
  cki0:
      _rbUM::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto cki1; else goto cki2;
  cki2:
      if (HpLim == 0) goto cki1; else goto cki3;
  cki1:
      R1 = _rbUM::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cki3:
      (_ckhX::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbUM::P64);
      if (_ckhX::I64 == 0) goto ckhZ; else goto ckhY;
  ckhZ:
      call (I64[_rbUM::P64])() args: 8, res: 0, upd: 8;
  ckhY:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _ckhX::I64;
      R4 = Main.rbTreeOpts23_closure;
      R3 = GHC.Base.Nothing_closure+1;
      R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
      Sp = Sp - 16;
      call Data.OldList.wordsFB_info(R4,
                                     R3,
                                     R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:52.685939 UTC

{offset
  cki0:
      _rbUM::P64 = R1;
      if ((Sp + -16) < SpLim) goto cki1; else goto cki2;
  cki2:
      if (HpLim == 0) goto cki1; else goto cki3;
  cki1:
      R1 = _rbUM::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cki3:
      (_ckhX::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbUM::P64);
      if (_ckhX::I64 == 0) goto ckhZ; else goto ckhY;
  ckhZ:
      call (I64[_rbUM::P64])() args: 8, res: 0, upd: 8;
  ckhY:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _ckhX::I64;
      R4 = Main.rbTreeOpts23_closure;
      R3 = GHC.Base.Nothing_closure+1;
      R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
      Sp = Sp - 16;
      call Data.OldList.wordsFB_info(R4,
                                     R3,
                                     R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:52.687367 UTC

[(ckhY,
  {Main.rbTreeOpts23_closure,
   Options.Applicative.Help.Chunk.paragraph1_closure}),
 (ckhZ, {}),
 (cki0,
  {Main.rbTreeOpts23_closure,
   Options.Applicative.Help.Chunk.paragraph1_closure}),
 (cki1, {}),
 (cki2,
  {Main.rbTreeOpts23_closure,
   Options.Applicative.Help.Chunk.paragraph1_closure}),
 (cki3,
  {Main.rbTreeOpts23_closure,
   Options.Applicative.Help.Chunk.paragraph1_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:52.688081 UTC

Main.rbTreeOpts_lvl1_entry() //  [R1]
        { info_tbl: [(cki0,
                      label: Main.rbTreeOpts_lvl1_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cki0:
          _rbUM::P64 = R1;
          if ((Sp + -16) < SpLim) goto cki1; else goto cki2;
      cki2:
          if (HpLim == 0) goto cki1; else goto cki3;
      cki1:
          R1 = _rbUM::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      cki3:
          (_ckhX::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbUM::P64);
          if (_ckhX::I64 == 0) goto ckhZ; else goto ckhY;
      ckhZ:
          call (I64[_rbUM::P64])() args: 8, res: 0, upd: 8;
      ckhY:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _ckhX::I64;
          R4 = Main.rbTreeOpts23_closure;
          R3 = GHC.Base.Nothing_closure+1;
          R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
          Sp = Sp - 16;
          call Data.OldList.wordsFB_info(R4,
                                         R3,
                                         R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.68959 UTC

Main.rbTreeOpts_lvl1_entry() //  [R1]
        { info_tbl: [(cki0,
                      label: Main.rbTreeOpts_lvl1_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cki0:
          _rbUM::P64 = R1;
          if ((Sp + -16) < SpLim) goto cki1; else goto cki2;
      cki2:
          if (HpLim == 0) goto cki1; else goto cki3;
      cki1:
          R1 = _rbUM::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      cki3:
          (_ckhX::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbUM::P64);
          if (_ckhX::I64 == 0) goto ckhZ; else goto ckhY;
      ckhZ:
          call (I64[_rbUM::P64])() args: 8, res: 0, upd: 8;
      ckhY:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _ckhX::I64;
          R4 = Main.rbTreeOpts23_closure;
          R3 = GHC.Base.Nothing_closure+1;
          R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
          Sp = Sp - 16;
          call Data.OldList.wordsFB_info(R4,
                                         R3,
                                         R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.691116 UTC

[section "data" {
     Main.rbTreeOpts_lvl1_closure:
         const Main.rbTreeOpts_lvl1_info;
         const 0;
         const 0;
         const 0;
 },
 Main.rbTreeOpts_lvl1_entry() //  [R1]
         { info_tbl: [(cki0,
                       label: Main.rbTreeOpts_lvl1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cki0:
           _rbUM::P64 = R1;
           if ((Sp + -16) < SpLim) goto cki1; else goto cki2;
       cki2:
           if (HpLim == 0) goto cki1; else goto cki3;
       cki1:
           R1 = _rbUM::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cki3:
           (_ckhX::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbUM::P64);
           if (_ckhX::I64 == 0) goto ckhZ; else goto ckhY;
       ckhZ:
           call (I64[_rbUM::P64])() args: 8, res: 0, upd: 8;
       ckhY:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ckhX::I64;
           R4 = Main.rbTreeOpts23_closure;
           R3 = GHC.Base.Nothing_closure+1;
           R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
           Sp = Sp - 16;
           call Data.OldList.wordsFB_info(R4,
                                          R3,
                                          R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.692994 UTC

[section "data" {
     Main.rbTreeOpts_lvl1_closure:
         const Main.rbTreeOpts_lvl1_info;
         const 0;
         const 0;
         const 0;
 },
 Main.rbTreeOpts_lvl1_entry() //  [R1]
         { info_tbl: [(cki0,
                       label: Main.rbTreeOpts_lvl1_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cki0:
           _rbUM::P64 = R1;
           if ((Sp + -16) < SpLim) goto cki1; else goto cki2;
       cki2:
           if (HpLim == 0) goto cki1; else goto cki3;
       cki1:
           R1 = _rbUM::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cki3:
           (_ckhX::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbUM::P64);
           if (_ckhX::I64 == 0) goto ckhZ; else goto ckhY;
       ckhZ:
           call (I64[_rbUM::P64])() args: 8, res: 0, upd: 8;
       ckhY:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ckhX::I64;
           R4 = Main.rbTreeOpts23_closure;
           R3 = GHC.Base.Nothing_closure+1;
           R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
           Sp = Sp - 16;
           call Data.OldList.wordsFB_info(R4,
                                          R3,
                                          R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.697852 UTC

[section "data" {
     Main.rbTreeOpts_n3_closure:
         const Options.Applicative.Types.OptShort_static_info;
         const 109;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.698228 UTC

[section "data" {
     Main.rbTreeOpts_n3_closure:
         const Options.Applicative.Types.OptShort_static_info;
         const 109;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.698528 UTC

[section "data" {
     Main.rbTreeOpts_n3_closure:
         const Options.Applicative.Types.OptShort_static_info;
         const 109;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.699314 UTC

[section "data" {
     Main.rbTreeOpts28_closure:
         const :_static_info;
         const Main.rbTreeOpts_n2_closure+2;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.699735 UTC

[section "data" {
     Main.rbTreeOpts28_closure:
         const :_static_info;
         const Main.rbTreeOpts_n2_closure+2;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.700101 UTC

[section "data" {
     Main.rbTreeOpts28_closure:
         const :_static_info;
         const Main.rbTreeOpts_n2_closure+2;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.700863 UTC

[section "data" {
     Main.rbTreeOpts27_closure:
         const :_static_info;
         const Main.rbTreeOpts_n3_closure+1;
         const Main.rbTreeOpts28_closure+2;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.701291 UTC

[section "data" {
     Main.rbTreeOpts27_closure:
         const :_static_info;
         const Main.rbTreeOpts_n3_closure+1;
         const Main.rbTreeOpts28_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.70166 UTC

[section "data" {
     Main.rbTreeOpts27_closure:
         const :_static_info;
         const Main.rbTreeOpts_n3_closure+1;
         const Main.rbTreeOpts28_closure+2;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.702439 UTC

[section "data" {
     Main.rbTreeOpts26_closure:
         const Main.rbTreeOpts26_info;
         const 0;
 },
 Main.rbTreeOpts26_entry() //  [R2]
         { info_tbl: [(ckij,
                       label: Main.rbTreeOpts26_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckij:
           _B1::P64 = R2;
           goto ckih;
       ckih:
           if ((old + 0) - <highSp> < SpLim) goto ckik; else goto ckil;
       ckil:
           goto ckig;
       ckig:
           if (HpLim == 0) goto ckik; else goto ckim;
       ckik:
           R2 = _B1::P64;
           R1 = Main.rbTreeOpts26_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckim:
           R3 = _B1::P64;
           R2 = GHC.Read.$fReadDouble_closure;
           call Options.Applicative.Builder.auto1_info(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.704081 UTC

{offset
  ckij:
      _B1::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckik; else goto ckil;
  ckil:
      if (HpLim == 0) goto ckik; else goto ckim;
  ckik:
      R2 = _B1::P64;
      R1 = Main.rbTreeOpts26_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckim:
      R3 = _B1::P64;
      R2 = GHC.Read.$fReadDouble_closure;
      call Options.Applicative.Builder.auto1_info(R3,
                                                  R2) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:52.704897 UTC

{offset
  ckij:
      _B1::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckik; else goto ckil;
  ckil:
      if (HpLim == 0) goto ckik; else goto ckim;
  ckik:
      R2 = _B1::P64;
      R1 = Main.rbTreeOpts26_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckim:
      R3 = _B1::P64;
      R2 = GHC.Read.$fReadDouble_closure;
      call Options.Applicative.Builder.auto1_info(R3,
                                                  R2) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:52.705722 UTC

{offset
  ckij:
      _B1::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckik; else goto ckil;
  ckil:
      if (HpLim == 0) goto ckik; else goto ckim;
  ckik:
      R2 = _B1::P64;
      R1 = Main.rbTreeOpts26_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckim:
      R3 = _B1::P64;
      R2 = GHC.Read.$fReadDouble_closure;
      call Options.Applicative.Builder.auto1_info(R3,
                                                  R2) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:52.707063 UTC

{offset
  ckij:
      _B1::P64 = R2;
      goto ckil;
  ckil:
      if (HpLim == 0) goto ckik; else goto ckim;
  ckik:
      R2 = _B1::P64;
      R1 = Main.rbTreeOpts26_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckim:
      R3 = _B1::P64;
      R2 = GHC.Read.$fReadDouble_closure;
      call Options.Applicative.Builder.auto1_info(R3,
                                                  R2) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:52.707801 UTC

{offset
  ckij:
      goto ckil;
  ckil:
      if (HpLim == 0) goto ckik; else goto ckim;
  ckik:
      R2 = R2;
      R1 = Main.rbTreeOpts26_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckim:
      R3 = R2;
      R2 = GHC.Read.$fReadDouble_closure;
      call Options.Applicative.Builder.auto1_info(R3,
                                                  R2) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:52.708624 UTC

[(ckij,
  {GHC.Read.$fReadDouble_closure, Main.rbTreeOpts26_closure,
   Options.Applicative.Builder.auto1_closure}),
 (ckik, {Main.rbTreeOpts26_closure}),
 (ckil,
  {GHC.Read.$fReadDouble_closure, Main.rbTreeOpts26_closure,
   Options.Applicative.Builder.auto1_closure}),
 (ckim,
  {GHC.Read.$fReadDouble_closure,
   Options.Applicative.Builder.auto1_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:52.709287 UTC

Main.rbTreeOpts26_entry() //  [R2]
        { info_tbl: [(ckij,
                      label: Main.rbTreeOpts26_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckij:
          goto ckil;
      ckil:
          if (HpLim == 0) goto ckik; else goto ckim;
      ckik:
          R2 = R2;
          R1 = Main.rbTreeOpts26_closure;
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
      ckim:
          R3 = R2;
          R2 = GHC.Read.$fReadDouble_closure;
          call Options.Applicative.Builder.auto1_info(R3,
                                                      R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.710208 UTC

Main.rbTreeOpts26_entry() //  [R2]
        { info_tbl: [(ckij,
                      label: Main.rbTreeOpts26_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckij:
          if (HpLim == 0) goto ckik; else goto ckim;
      ckik:
          R2 = R2;
          R1 = Main.rbTreeOpts26_closure;
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
      ckim:
          R3 = R2;
          R2 = GHC.Read.$fReadDouble_closure;
          call Options.Applicative.Builder.auto1_info(R3,
                                                      R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.711102 UTC

[section "data" {
     Main.rbTreeOpts26_closure:
         const Main.rbTreeOpts26_info;
         const 0;
 },
 Main.rbTreeOpts26_entry() //  [R2]
         { info_tbl: [(ckij,
                       label: Main.rbTreeOpts26_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckij:
           if (HpLim == 0) goto ckik; else goto ckim;
       ckik:
           R2 = R2;
           R1 = Main.rbTreeOpts26_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckim:
           R3 = R2;
           R2 = GHC.Read.$fReadDouble_closure;
           call Options.Applicative.Builder.auto1_info(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.712244 UTC

[section "data" {
     Main.rbTreeOpts26_closure:
         const Main.rbTreeOpts26_info;
         const 0;
 },
 Main.rbTreeOpts26_entry() //  [R2]
         { info_tbl: [(ckij,
                       label: Main.rbTreeOpts26_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckij:
           if (HpLim == 0) goto ckik; else goto ckim;
       ckik:
           R2 = R2;
           R1 = Main.rbTreeOpts26_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckim:
           R3 = R2;
           R2 = GHC.Read.$fReadDouble_closure;
           call Options.Applicative.Builder.auto1_info(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.715065 UTC

[section "data" {
     Main.rbTreeOpts25_closure:
         const Options.Applicative.Types.CReader_static_info;
         const Options.Applicative.Types.$fMonoidCompleter4_closure+2;
         const Main.rbTreeOpts26_closure+1;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.71552 UTC

[section "data" {
     Main.rbTreeOpts25_closure:
         const Options.Applicative.Types.CReader_static_info;
         const Options.Applicative.Types.$fMonoidCompleter4_closure+2;
         const Main.rbTreeOpts26_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.715901 UTC

[section "data" {
     Main.rbTreeOpts25_closure:
         const Options.Applicative.Types.CReader_static_info;
         const Options.Applicative.Types.$fMonoidCompleter4_closure+2;
         const Main.rbTreeOpts26_closure+1;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.716707 UTC

[section "data" {
     Main.rbTreeOpts24_closure:
         const Options.Applicative.Types.OptReader_static_info;
         const Main.rbTreeOpts27_closure+2;
         const Main.rbTreeOpts25_closure+1;
         const Options.Applicative.Builder.abortOption3_closure;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.717213 UTC

[section "data" {
     Main.rbTreeOpts24_closure:
         const Options.Applicative.Types.OptReader_static_info;
         const Main.rbTreeOpts27_closure+2;
         const Main.rbTreeOpts25_closure+1;
         const Options.Applicative.Builder.abortOption3_closure;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.717637 UTC

[section "data" {
     Main.rbTreeOpts24_closure:
         const Options.Applicative.Types.OptReader_static_info;
         const Main.rbTreeOpts27_closure+2;
         const Main.rbTreeOpts25_closure+1;
         const Options.Applicative.Builder.abortOption3_closure;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.718558 UTC

[section "data" {
     Main.rbTreeOpts22_closure:
         const Options.Applicative.Types.OptProperties_static_info;
         const Options.Applicative.Types.Visible_closure+3;
         const Main.rbTreeOpts_lvl1_closure;
         const Options.Applicative.Builder.abortOption_var_closure;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.719162 UTC

[section "data" {
     Main.rbTreeOpts22_closure:
         const Options.Applicative.Types.OptProperties_static_info;
         const Options.Applicative.Types.Visible_closure+3;
         const Main.rbTreeOpts_lvl1_closure;
         const Options.Applicative.Builder.abortOption_var_closure;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.719611 UTC

[section "data" {
     Main.rbTreeOpts22_closure:
         const Options.Applicative.Types.OptProperties_static_info;
         const Options.Applicative.Types.Visible_closure+3;
         const Main.rbTreeOpts_lvl1_closure;
         const Options.Applicative.Builder.abortOption_var_closure;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.720505 UTC

[section "data" {
     Main.rbTreeOpts21_closure:
         const Options.Applicative.Types.Option_static_info;
         const Main.rbTreeOpts24_closure+1;
         const Main.rbTreeOpts22_closure+1;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.720928 UTC

[section "data" {
     Main.rbTreeOpts21_closure:
         const Options.Applicative.Types.Option_static_info;
         const Main.rbTreeOpts24_closure+1;
         const Main.rbTreeOpts22_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.72131 UTC

[section "data" {
     Main.rbTreeOpts21_closure:
         const Options.Applicative.Types.Option_static_info;
         const Main.rbTreeOpts24_closure+1;
         const Main.rbTreeOpts22_closure+1;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.722068 UTC

[section "data" {
     Main.rbTreeOpts18_closure:
         const GHC.Base.Just_static_info;
         const Main.rbTreeOpts19_closure+1;
         const 3;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.722448 UTC

[section "data" {
     Main.rbTreeOpts18_closure:
         const GHC.Base.Just_static_info;
         const Main.rbTreeOpts19_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.722791 UTC

[section "data" {
     Main.rbTreeOpts18_closure:
         const GHC.Base.Just_static_info;
         const Main.rbTreeOpts19_closure+1;
         const 3;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.723933 UTC

[section "data" {
     Main.rbTreeOpts20_closure:
         const Options.Applicative.Types.OptP_static_info;
         const Main.rbTreeOpts21_closure+1;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.724311 UTC

[section "data" {
     Main.rbTreeOpts20_closure:
         const Options.Applicative.Types.OptP_static_info;
         const Main.rbTreeOpts21_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.724652 UTC

[section "data" {
     Main.rbTreeOpts20_closure:
         const Options.Applicative.Types.OptP_static_info;
         const Main.rbTreeOpts21_closure+1;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.725327 UTC

[section "data" {
     Main.rbTreeOpts17_closure:
         const Options.Applicative.Types.NilP_static_info;
         const Main.rbTreeOpts18_closure+2;
         const 3;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.725707 UTC

[section "data" {
     Main.rbTreeOpts17_closure:
         const Options.Applicative.Types.NilP_static_info;
         const Main.rbTreeOpts18_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.726054 UTC

[section "data" {
     Main.rbTreeOpts17_closure:
         const Options.Applicative.Types.NilP_static_info;
         const Main.rbTreeOpts18_closure+2;
         const 3;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.726769 UTC

[section "data" {
     Main.rbTreeOpts16_closure:
         const Options.Applicative.Types.AltP_static_info;
         const Main.rbTreeOpts20_closure+2;
         const Main.rbTreeOpts17_closure+1;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.727205 UTC

[section "data" {
     Main.rbTreeOpts16_closure:
         const Options.Applicative.Types.AltP_static_info;
         const Main.rbTreeOpts20_closure+2;
         const Main.rbTreeOpts17_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.727589 UTC

[section "data" {
     Main.rbTreeOpts16_closure:
         const Options.Applicative.Types.AltP_static_info;
         const Main.rbTreeOpts20_closure+2;
         const Main.rbTreeOpts17_closure+1;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.728327 UTC

[section "data" {
     Main.rbTreeOpts34_closure:
         const GHC.Types.I#_static_info;
         const 1;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.728669 UTC

[section "data" {
     Main.rbTreeOpts34_closure:
         const GHC.Types.I#_static_info;
         const 1;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.728969 UTC

[section "data" {
     Main.rbTreeOpts34_closure:
         const GHC.Types.I#_static_info;
         const 1;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.729605 UTC

[section "data" {
     Main.rbTreeOpts42_closure:
         const Main.rbTreeOpts42_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ckiP_str:
         I8[] [97,116,111,109,105,99,71,114,111,117,112,115]
 },
 Main.rbTreeOpts42_entry() //  [R1]
         { info_tbl: [(ckiQ,
                       label: Main.rbTreeOpts42_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckiQ:
           _rbSZ::P64 = R1;
           goto ckiK;
       ckiK:
           if ((old + 0) - <highSp> < SpLim) goto ckiR; else goto ckiS;
       ckiS:
           if (HpLim == 0) goto ckiR; else goto ckiT;
       ckiR:
           R1 = _rbSZ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckiT:
           (_ckiM::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbSZ::P64);
           if (_ckiM::I64 == 0) goto ckiO; else goto ckiN;
       ckiO:
           call (I64[_rbSZ::P64])() args: 8, res: 0, upd: 8;
       ckiN:
           I64[(old + 24)] = stg_bh_upd_frame_info;
           I64[(old + 16)] = _ckiM::I64;
           R2 = ckiP_str;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.731753 UTC

{offset
  ckiQ:
      _rbSZ::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckiR; else goto ckiS;
  ckiS:
      if (HpLim == 0) goto ckiR; else goto ckiT;
  ckiR:
      R1 = _rbSZ::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckiT:
      (_ckiM::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbSZ::P64);
      if (_ckiM::I64 == 0) goto ckiO; else goto ckiN;
  ckiO:
      call (I64[_rbSZ::P64])() args: 8, res: 0, upd: 8;
  ckiN:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckiM::I64;
      R2 = ckiP_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:52.732859 UTC

{offset
  ckiQ:
      _rbSZ::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckiR; else goto ckiS;
  ckiS:
      if (HpLim == 0) goto ckiR; else goto ckiT;
  ckiR:
      R1 = _rbSZ::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckiT:
      (_ckiM::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbSZ::P64);
      if (_ckiM::I64 == 0) goto ckiO; else goto ckiN;
  ckiO:
      call (I64[_rbSZ::P64])() args: 8, res: 0, upd: 8;
  ckiN:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckiM::I64;
      R2 = ckiP_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:52.733992 UTC

{offset
  ckiQ:
      _rbSZ::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckiR; else goto ckiS;
  ckiS:
      if (HpLim == 0) goto ckiR; else goto ckiT;
  ckiR:
      R1 = _rbSZ::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckiT:
      (_ckiM::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbSZ::P64);
      if (_ckiM::I64 == 0) goto ckiO; else goto ckiN;
  ckiO:
      call (I64[_rbSZ::P64])() args: 8, res: 0, upd: 8;
  ckiN:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckiM::I64;
      R2 = ckiP_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:52.735158 UTC

{offset
  ckiQ:
      _rbSZ::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto ckiR; else goto ckiS;
  ckiS:
      if (HpLim == 0) goto ckiR; else goto ckiT;
  ckiR:
      R1 = _rbSZ::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckiT:
      (_ckiM::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbSZ::P64);
      if (_ckiM::I64 == 0) goto ckiO; else goto ckiN;
  ckiO:
      call (I64[_rbSZ::P64])() args: 8, res: 0, upd: 8;
  ckiN:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _ckiM::I64;
      R2 = ckiP_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:52.7363 UTC

{offset
  ckiQ:
      _rbSZ::P64 = R1;
      if ((Sp + -16) < SpLim) goto ckiR; else goto ckiS;
  ckiS:
      if (HpLim == 0) goto ckiR; else goto ckiT;
  ckiR:
      R1 = _rbSZ::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckiT:
      (_ckiM::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbSZ::P64);
      if (_ckiM::I64 == 0) goto ckiO; else goto ckiN;
  ckiO:
      call (I64[_rbSZ::P64])() args: 8, res: 0, upd: 8;
  ckiN:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _ckiM::I64;
      R2 = ckiP_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:52.737605 UTC

[(ckiN, {}), (ckiO, {}), (ckiQ, {}), (ckiR, {}), (ckiS, {}),
 (ckiT, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:52.737986 UTC

Main.rbTreeOpts42_entry() //  [R1]
        { info_tbl: [(ckiQ,
                      label: Main.rbTreeOpts42_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckiQ:
          _rbSZ::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckiR; else goto ckiS;
      ckiS:
          if (HpLim == 0) goto ckiR; else goto ckiT;
      ckiR:
          R1 = _rbSZ::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckiT:
          (_ckiM::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbSZ::P64);
          if (_ckiM::I64 == 0) goto ckiO; else goto ckiN;
      ckiO:
          call (I64[_rbSZ::P64])() args: 8, res: 0, upd: 8;
      ckiN:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _ckiM::I64;
          R2 = ckiP_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.739481 UTC

Main.rbTreeOpts42_entry() //  [R1]
        { info_tbl: [(ckiQ,
                      label: Main.rbTreeOpts42_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckiQ:
          _rbSZ::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckiR; else goto ckiS;
      ckiS:
          if (HpLim == 0) goto ckiR; else goto ckiT;
      ckiR:
          R1 = _rbSZ::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckiT:
          (_ckiM::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbSZ::P64);
          if (_ckiM::I64 == 0) goto ckiO; else goto ckiN;
      ckiO:
          call (I64[_rbSZ::P64])() args: 8, res: 0, upd: 8;
      ckiN:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _ckiM::I64;
          R2 = ckiP_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.741338 UTC

[section "data" {
     Main.rbTreeOpts42_closure:
         const Main.rbTreeOpts42_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ckiP_str:
         I8[] [97,116,111,109,105,99,71,114,111,117,112,115]
 },
 Main.rbTreeOpts42_entry() //  [R1]
         { info_tbl: [(ckiQ,
                       label: Main.rbTreeOpts42_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckiQ:
           _rbSZ::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckiR; else goto ckiS;
       ckiS:
           if (HpLim == 0) goto ckiR; else goto ckiT;
       ckiR:
           R1 = _rbSZ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckiT:
           (_ckiM::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbSZ::P64);
           if (_ckiM::I64 == 0) goto ckiO; else goto ckiN;
       ckiO:
           call (I64[_rbSZ::P64])() args: 8, res: 0, upd: 8;
       ckiN:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ckiM::I64;
           R2 = ckiP_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.743017 UTC

[section "data" {
     Main.rbTreeOpts42_closure:
         const Main.rbTreeOpts42_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ckiP_str:
         I8[] [97,116,111,109,105,99,71,114,111,117,112,115]
 },
 Main.rbTreeOpts42_entry() //  [R1]
         { info_tbl: [(ckiQ,
                       label: Main.rbTreeOpts42_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckiQ:
           _rbSZ::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckiR; else goto ckiS;
       ckiS:
           if (HpLim == 0) goto ckiR; else goto ckiT;
       ckiR:
           R1 = _rbSZ::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckiT:
           (_ckiM::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbSZ::P64);
           if (_ckiM::I64 == 0) goto ckiO; else goto ckiN;
       ckiO:
           call (I64[_rbSZ::P64])() args: 8, res: 0, upd: 8;
       ckiN:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ckiM::I64;
           R2 = ckiP_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.747731 UTC

[section "data" {
     Main.rbTreeOpts_n4_closure:
         const Options.Applicative.Types.OptLong_static_info;
         const Main.rbTreeOpts42_closure;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.748141 UTC

[section "data" {
     Main.rbTreeOpts_n4_closure:
         const Options.Applicative.Types.OptLong_static_info;
         const Main.rbTreeOpts42_closure;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.748481 UTC

[section "data" {
     Main.rbTreeOpts_n4_closure:
         const Options.Applicative.Types.OptLong_static_info;
         const Main.rbTreeOpts42_closure;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.749149 UTC

[section "data" {
     Main.rbTreeOpts38_closure:
         const Main.rbTreeOpts38_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ckj8_str:
         I8[] [76,111,111,107,117,112,115,32,112,101,114,32,116,114,97,110,115,97,99,116,105,111,110]
 },
 Main.rbTreeOpts38_entry() //  [R1]
         { info_tbl: [(ckj9,
                       label: Main.rbTreeOpts38_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckj9:
           _rbTa::P64 = R1;
           goto ckj3;
       ckj3:
           if ((old + 0) - <highSp> < SpLim) goto ckja; else goto ckjb;
       ckjb:
           if (HpLim == 0) goto ckja; else goto ckjc;
       ckja:
           R1 = _rbTa::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckjc:
           (_ckj5::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTa::P64);
           if (_ckj5::I64 == 0) goto ckj7; else goto ckj6;
       ckj7:
           call (I64[_rbTa::P64])() args: 8, res: 0, upd: 8;
       ckj6:
           I64[(old + 24)] = stg_bh_upd_frame_info;
           I64[(old + 16)] = _ckj5::I64;
           R2 = ckj8_str;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.751242 UTC

{offset
  ckj9:
      _rbTa::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckja; else goto ckjb;
  ckjb:
      if (HpLim == 0) goto ckja; else goto ckjc;
  ckja:
      R1 = _rbTa::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckjc:
      (_ckj5::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTa::P64);
      if (_ckj5::I64 == 0) goto ckj7; else goto ckj6;
  ckj7:
      call (I64[_rbTa::P64])() args: 8, res: 0, upd: 8;
  ckj6:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckj5::I64;
      R2 = ckj8_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:52.75235 UTC

{offset
  ckj9:
      _rbTa::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckja; else goto ckjb;
  ckjb:
      if (HpLim == 0) goto ckja; else goto ckjc;
  ckja:
      R1 = _rbTa::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckjc:
      (_ckj5::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTa::P64);
      if (_ckj5::I64 == 0) goto ckj7; else goto ckj6;
  ckj7:
      call (I64[_rbTa::P64])() args: 8, res: 0, upd: 8;
  ckj6:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckj5::I64;
      R2 = ckj8_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:52.753488 UTC

{offset
  ckj9:
      _rbTa::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckja; else goto ckjb;
  ckjb:
      if (HpLim == 0) goto ckja; else goto ckjc;
  ckja:
      R1 = _rbTa::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckjc:
      (_ckj5::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTa::P64);
      if (_ckj5::I64 == 0) goto ckj7; else goto ckj6;
  ckj7:
      call (I64[_rbTa::P64])() args: 8, res: 0, upd: 8;
  ckj6:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckj5::I64;
      R2 = ckj8_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:52.754646 UTC

{offset
  ckj9:
      _rbTa::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto ckja; else goto ckjb;
  ckjb:
      if (HpLim == 0) goto ckja; else goto ckjc;
  ckja:
      R1 = _rbTa::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckjc:
      (_ckj5::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTa::P64);
      if (_ckj5::I64 == 0) goto ckj7; else goto ckj6;
  ckj7:
      call (I64[_rbTa::P64])() args: 8, res: 0, upd: 8;
  ckj6:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _ckj5::I64;
      R2 = ckj8_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:52.755784 UTC

{offset
  ckj9:
      _rbTa::P64 = R1;
      if ((Sp + -16) < SpLim) goto ckja; else goto ckjb;
  ckjb:
      if (HpLim == 0) goto ckja; else goto ckjc;
  ckja:
      R1 = _rbTa::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckjc:
      (_ckj5::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTa::P64);
      if (_ckj5::I64 == 0) goto ckj7; else goto ckj6;
  ckj7:
      call (I64[_rbTa::P64])() args: 8, res: 0, upd: 8;
  ckj6:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _ckj5::I64;
      R2 = ckj8_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:52.757108 UTC

[(ckj6, {}), (ckj7, {}), (ckj9, {}), (ckja, {}), (ckjb, {}),
 (ckjc, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:52.75749 UTC

Main.rbTreeOpts38_entry() //  [R1]
        { info_tbl: [(ckj9,
                      label: Main.rbTreeOpts38_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckj9:
          _rbTa::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckja; else goto ckjb;
      ckjb:
          if (HpLim == 0) goto ckja; else goto ckjc;
      ckja:
          R1 = _rbTa::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckjc:
          (_ckj5::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTa::P64);
          if (_ckj5::I64 == 0) goto ckj7; else goto ckj6;
      ckj7:
          call (I64[_rbTa::P64])() args: 8, res: 0, upd: 8;
      ckj6:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _ckj5::I64;
          R2 = ckj8_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.75885 UTC

Main.rbTreeOpts38_entry() //  [R1]
        { info_tbl: [(ckj9,
                      label: Main.rbTreeOpts38_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckj9:
          _rbTa::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckja; else goto ckjb;
      ckjb:
          if (HpLim == 0) goto ckja; else goto ckjc;
      ckja:
          R1 = _rbTa::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckjc:
          (_ckj5::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTa::P64);
          if (_ckj5::I64 == 0) goto ckj7; else goto ckj6;
      ckj7:
          call (I64[_rbTa::P64])() args: 8, res: 0, upd: 8;
      ckj6:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _ckj5::I64;
          R2 = ckj8_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.760323 UTC

[section "data" {
     Main.rbTreeOpts38_closure:
         const Main.rbTreeOpts38_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ckj8_str:
         I8[] [76,111,111,107,117,112,115,32,112,101,114,32,116,114,97,110,115,97,99,116,105,111,110]
 },
 Main.rbTreeOpts38_entry() //  [R1]
         { info_tbl: [(ckj9,
                       label: Main.rbTreeOpts38_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckj9:
           _rbTa::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckja; else goto ckjb;
       ckjb:
           if (HpLim == 0) goto ckja; else goto ckjc;
       ckja:
           R1 = _rbTa::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckjc:
           (_ckj5::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTa::P64);
           if (_ckj5::I64 == 0) goto ckj7; else goto ckj6;
       ckj7:
           call (I64[_rbTa::P64])() args: 8, res: 0, upd: 8;
       ckj6:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ckj5::I64;
           R2 = ckj8_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.762027 UTC

[section "data" {
     Main.rbTreeOpts38_closure:
         const Main.rbTreeOpts38_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ckj8_str:
         I8[] [76,111,111,107,117,112,115,32,112,101,114,32,116,114,97,110,115,97,99,116,105,111,110]
 },
 Main.rbTreeOpts38_entry() //  [R1]
         { info_tbl: [(ckj9,
                       label: Main.rbTreeOpts38_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckj9:
           _rbTa::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckja; else goto ckjb;
       ckjb:
           if (HpLim == 0) goto ckja; else goto ckjc;
       ckja:
           R1 = _rbTa::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckjc:
           (_ckj5::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTa::P64);
           if (_ckj5::I64 == 0) goto ckj7; else goto ckj6;
       ckj7:
           call (I64[_rbTa::P64])() args: 8, res: 0, upd: 8;
       ckj6:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ckj5::I64;
           R2 = ckj8_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.766848 UTC

[section "data" {
     Main.rbTreeOpts_lvl3_closure:
         const Main.rbTreeOpts_lvl3_info;
         const 0;
         const 0;
         const 0;
 },
 Main.rbTreeOpts_lvl3_entry() //  [R1]
         { info_tbl: [(ckjp,
                       label: Main.rbTreeOpts_lvl3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckjp:
           _rbUq::P64 = R1;
           goto ckjk;
       ckjk:
           if ((old + 0) - <highSp> < SpLim) goto ckjq; else goto ckjr;
       ckjr:
           if (HpLim == 0) goto ckjq; else goto ckjs;
       ckjq:
           R1 = _rbUq::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckjs:
           (_ckjm::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbUq::P64);
           if (_ckjm::I64 == 0) goto ckjo; else goto ckjn;
       ckjo:
           call (I64[_rbUq::P64])() args: 8, res: 0, upd: 8;
       ckjn:
           I64[(old + 24)] = stg_bh_upd_frame_info;
           I64[(old + 16)] = _ckjm::I64;
           R4 = Main.rbTreeOpts38_closure;
           R3 = GHC.Base.Nothing_closure+1;
           R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
           call Data.OldList.wordsFB_info(R4,
                                          R3,
                                          R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.769125 UTC

{offset
  ckjp:
      _rbUq::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckjq; else goto ckjr;
  ckjr:
      if (HpLim == 0) goto ckjq; else goto ckjs;
  ckjq:
      R1 = _rbUq::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckjs:
      (_ckjm::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbUq::P64);
      if (_ckjm::I64 == 0) goto ckjo; else goto ckjn;
  ckjo:
      call (I64[_rbUq::P64])() args: 8, res: 0, upd: 8;
  ckjn:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckjm::I64;
      R4 = Main.rbTreeOpts38_closure;
      R3 = GHC.Base.Nothing_closure+1;
      R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
      call Data.OldList.wordsFB_info(R4,
                                     R3,
                                     R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:52.770358 UTC

{offset
  ckjp:
      _rbUq::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckjq; else goto ckjr;
  ckjr:
      if (HpLim == 0) goto ckjq; else goto ckjs;
  ckjq:
      R1 = _rbUq::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckjs:
      (_ckjm::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbUq::P64);
      if (_ckjm::I64 == 0) goto ckjo; else goto ckjn;
  ckjo:
      call (I64[_rbUq::P64])() args: 8, res: 0, upd: 8;
  ckjn:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckjm::I64;
      R4 = Main.rbTreeOpts38_closure;
      R3 = GHC.Base.Nothing_closure+1;
      R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
      call Data.OldList.wordsFB_info(R4,
                                     R3,
                                     R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:52.771596 UTC

{offset
  ckjp:
      _rbUq::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckjq; else goto ckjr;
  ckjr:
      if (HpLim == 0) goto ckjq; else goto ckjs;
  ckjq:
      R1 = _rbUq::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckjs:
      (_ckjm::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbUq::P64);
      if (_ckjm::I64 == 0) goto ckjo; else goto ckjn;
  ckjo:
      call (I64[_rbUq::P64])() args: 8, res: 0, upd: 8;
  ckjn:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckjm::I64;
      R4 = Main.rbTreeOpts38_closure;
      R3 = GHC.Base.Nothing_closure+1;
      R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
      call Data.OldList.wordsFB_info(R4,
                                     R3,
                                     R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:52.772895 UTC

{offset
  ckjp:
      _rbUq::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto ckjq; else goto ckjr;
  ckjr:
      if (HpLim == 0) goto ckjq; else goto ckjs;
  ckjq:
      R1 = _rbUq::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckjs:
      (_ckjm::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbUq::P64);
      if (_ckjm::I64 == 0) goto ckjo; else goto ckjn;
  ckjo:
      call (I64[_rbUq::P64])() args: 8, res: 0, upd: 8;
  ckjn:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _ckjm::I64;
      R4 = Main.rbTreeOpts38_closure;
      R3 = GHC.Base.Nothing_closure+1;
      R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
      Sp = Sp - 16;
      call Data.OldList.wordsFB_info(R4,
                                     R3,
                                     R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:52.774155 UTC

{offset
  ckjp:
      _rbUq::P64 = R1;
      if ((Sp + -16) < SpLim) goto ckjq; else goto ckjr;
  ckjr:
      if (HpLim == 0) goto ckjq; else goto ckjs;
  ckjq:
      R1 = _rbUq::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckjs:
      (_ckjm::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbUq::P64);
      if (_ckjm::I64 == 0) goto ckjo; else goto ckjn;
  ckjo:
      call (I64[_rbUq::P64])() args: 8, res: 0, upd: 8;
  ckjn:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _ckjm::I64;
      R4 = Main.rbTreeOpts38_closure;
      R3 = GHC.Base.Nothing_closure+1;
      R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
      Sp = Sp - 16;
      call Data.OldList.wordsFB_info(R4,
                                     R3,
                                     R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:52.776091 UTC

[(ckjn,
  {Main.rbTreeOpts38_closure,
   Options.Applicative.Help.Chunk.paragraph1_closure}),
 (ckjo, {}),
 (ckjp,
  {Main.rbTreeOpts38_closure,
   Options.Applicative.Help.Chunk.paragraph1_closure}),
 (ckjq, {}),
 (ckjr,
  {Main.rbTreeOpts38_closure,
   Options.Applicative.Help.Chunk.paragraph1_closure}),
 (ckjs,
  {Main.rbTreeOpts38_closure,
   Options.Applicative.Help.Chunk.paragraph1_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:52.776796 UTC

Main.rbTreeOpts_lvl3_entry() //  [R1]
        { info_tbl: [(ckjp,
                      label: Main.rbTreeOpts_lvl3_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckjp:
          _rbUq::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckjq; else goto ckjr;
      ckjr:
          if (HpLim == 0) goto ckjq; else goto ckjs;
      ckjq:
          R1 = _rbUq::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckjs:
          (_ckjm::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbUq::P64);
          if (_ckjm::I64 == 0) goto ckjo; else goto ckjn;
      ckjo:
          call (I64[_rbUq::P64])() args: 8, res: 0, upd: 8;
      ckjn:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _ckjm::I64;
          R4 = Main.rbTreeOpts38_closure;
          R3 = GHC.Base.Nothing_closure+1;
          R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
          Sp = Sp - 16;
          call Data.OldList.wordsFB_info(R4,
                                         R3,
                                         R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.778319 UTC

Main.rbTreeOpts_lvl3_entry() //  [R1]
        { info_tbl: [(ckjp,
                      label: Main.rbTreeOpts_lvl3_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckjp:
          _rbUq::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckjq; else goto ckjr;
      ckjr:
          if (HpLim == 0) goto ckjq; else goto ckjs;
      ckjq:
          R1 = _rbUq::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckjs:
          (_ckjm::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbUq::P64);
          if (_ckjm::I64 == 0) goto ckjo; else goto ckjn;
      ckjo:
          call (I64[_rbUq::P64])() args: 8, res: 0, upd: 8;
      ckjn:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _ckjm::I64;
          R4 = Main.rbTreeOpts38_closure;
          R3 = GHC.Base.Nothing_closure+1;
          R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
          Sp = Sp - 16;
          call Data.OldList.wordsFB_info(R4,
                                         R3,
                                         R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.779915 UTC

[section "data" {
     Main.rbTreeOpts_lvl3_closure:
         const Main.rbTreeOpts_lvl3_info;
         const 0;
         const 0;
         const 0;
 },
 Main.rbTreeOpts_lvl3_entry() //  [R1]
         { info_tbl: [(ckjp,
                       label: Main.rbTreeOpts_lvl3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckjp:
           _rbUq::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckjq; else goto ckjr;
       ckjr:
           if (HpLim == 0) goto ckjq; else goto ckjs;
       ckjq:
           R1 = _rbUq::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckjs:
           (_ckjm::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbUq::P64);
           if (_ckjm::I64 == 0) goto ckjo; else goto ckjn;
       ckjo:
           call (I64[_rbUq::P64])() args: 8, res: 0, upd: 8;
       ckjn:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ckjm::I64;
           R4 = Main.rbTreeOpts38_closure;
           R3 = GHC.Base.Nothing_closure+1;
           R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
           Sp = Sp - 16;
           call Data.OldList.wordsFB_info(R4,
                                          R3,
                                          R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.781719 UTC

[section "data" {
     Main.rbTreeOpts_lvl3_closure:
         const Main.rbTreeOpts_lvl3_info;
         const 0;
         const 0;
         const 0;
 },
 Main.rbTreeOpts_lvl3_entry() //  [R1]
         { info_tbl: [(ckjp,
                       label: Main.rbTreeOpts_lvl3_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckjp:
           _rbUq::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckjq; else goto ckjr;
       ckjr:
           if (HpLim == 0) goto ckjq; else goto ckjs;
       ckjq:
           R1 = _rbUq::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckjs:
           (_ckjm::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbUq::P64);
           if (_ckjm::I64 == 0) goto ckjo; else goto ckjn;
       ckjo:
           call (I64[_rbUq::P64])() args: 8, res: 0, upd: 8;
       ckjn:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ckjm::I64;
           R4 = Main.rbTreeOpts38_closure;
           R3 = GHC.Base.Nothing_closure+1;
           R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
           Sp = Sp - 16;
           call Data.OldList.wordsFB_info(R4,
                                          R3,
                                          R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.786509 UTC

[section "data" {
     Main.rbTreeOpts_n5_closure:
         const Options.Applicative.Types.OptShort_static_info;
         const 103;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.786886 UTC

[section "data" {
     Main.rbTreeOpts_n5_closure:
         const Options.Applicative.Types.OptShort_static_info;
         const 103;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.787217 UTC

[section "data" {
     Main.rbTreeOpts_n5_closure:
         const Options.Applicative.Types.OptShort_static_info;
         const 103;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.787876 UTC

[section "data" {
     Main.rbTreeOpts41_closure:
         const :_static_info;
         const Main.rbTreeOpts_n4_closure+2;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.788298 UTC

[section "data" {
     Main.rbTreeOpts41_closure:
         const :_static_info;
         const Main.rbTreeOpts_n4_closure+2;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.788681 UTC

[section "data" {
     Main.rbTreeOpts41_closure:
         const :_static_info;
         const Main.rbTreeOpts_n4_closure+2;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.789471 UTC

[section "data" {
     Main.rbTreeOpts40_closure:
         const :_static_info;
         const Main.rbTreeOpts_n5_closure+1;
         const Main.rbTreeOpts41_closure+2;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.78989 UTC

[section "data" {
     Main.rbTreeOpts40_closure:
         const :_static_info;
         const Main.rbTreeOpts_n5_closure+1;
         const Main.rbTreeOpts41_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.790264 UTC

[section "data" {
     Main.rbTreeOpts40_closure:
         const :_static_info;
         const Main.rbTreeOpts_n5_closure+1;
         const Main.rbTreeOpts41_closure+2;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.791046 UTC

[section "data" {
     Main.rbTreeOpts39_closure:
         const Options.Applicative.Types.OptReader_static_info;
         const Main.rbTreeOpts40_closure+2;
         const Main.rbTreeOpts10_closure+1;
         const Options.Applicative.Builder.abortOption3_closure;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.791504 UTC

[section "data" {
     Main.rbTreeOpts39_closure:
         const Options.Applicative.Types.OptReader_static_info;
         const Main.rbTreeOpts40_closure+2;
         const Main.rbTreeOpts10_closure+1;
         const Options.Applicative.Builder.abortOption3_closure;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.791918 UTC

[section "data" {
     Main.rbTreeOpts39_closure:
         const Options.Applicative.Types.OptReader_static_info;
         const Main.rbTreeOpts40_closure+2;
         const Main.rbTreeOpts10_closure+1;
         const Options.Applicative.Builder.abortOption3_closure;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.792834 UTC

[section "data" {
     Main.rbTreeOpts37_closure:
         const Options.Applicative.Types.OptProperties_static_info;
         const Options.Applicative.Types.Visible_closure+3;
         const Main.rbTreeOpts_lvl3_closure;
         const Options.Applicative.Builder.abortOption_var_closure;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.793324 UTC

[section "data" {
     Main.rbTreeOpts37_closure:
         const Options.Applicative.Types.OptProperties_static_info;
         const Options.Applicative.Types.Visible_closure+3;
         const Main.rbTreeOpts_lvl3_closure;
         const Options.Applicative.Builder.abortOption_var_closure;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.793767 UTC

[section "data" {
     Main.rbTreeOpts37_closure:
         const Options.Applicative.Types.OptProperties_static_info;
         const Options.Applicative.Types.Visible_closure+3;
         const Main.rbTreeOpts_lvl3_closure;
         const Options.Applicative.Builder.abortOption_var_closure;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.794676 UTC

[section "data" {
     Main.rbTreeOpts36_closure:
         const Options.Applicative.Types.Option_static_info;
         const Main.rbTreeOpts39_closure+1;
         const Main.rbTreeOpts37_closure+1;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.795535 UTC

[section "data" {
     Main.rbTreeOpts36_closure:
         const Options.Applicative.Types.Option_static_info;
         const Main.rbTreeOpts39_closure+1;
         const Main.rbTreeOpts37_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.795941 UTC

[section "data" {
     Main.rbTreeOpts36_closure:
         const Options.Applicative.Types.Option_static_info;
         const Main.rbTreeOpts39_closure+1;
         const Main.rbTreeOpts37_closure+1;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.7967 UTC

[section "data" {
     Main.rbTreeOpts33_closure:
         const GHC.Base.Just_static_info;
         const Main.rbTreeOpts34_closure+1;
         const 3;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.797098 UTC

[section "data" {
     Main.rbTreeOpts33_closure:
         const GHC.Base.Just_static_info;
         const Main.rbTreeOpts34_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.797442 UTC

[section "data" {
     Main.rbTreeOpts33_closure:
         const GHC.Base.Just_static_info;
         const Main.rbTreeOpts34_closure+1;
         const 3;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.798121 UTC

[section "data" {
     Main.rbTreeOpts35_closure:
         const Options.Applicative.Types.OptP_static_info;
         const Main.rbTreeOpts36_closure+1;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.798498 UTC

[section "data" {
     Main.rbTreeOpts35_closure:
         const Options.Applicative.Types.OptP_static_info;
         const Main.rbTreeOpts36_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.798838 UTC

[section "data" {
     Main.rbTreeOpts35_closure:
         const Options.Applicative.Types.OptP_static_info;
         const Main.rbTreeOpts36_closure+1;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.799639 UTC

[section "data" {
     Main.rbTreeOpts32_closure:
         const Options.Applicative.Types.NilP_static_info;
         const Main.rbTreeOpts33_closure+2;
         const 3;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.800023 UTC

[section "data" {
     Main.rbTreeOpts32_closure:
         const Options.Applicative.Types.NilP_static_info;
         const Main.rbTreeOpts33_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.800362 UTC

[section "data" {
     Main.rbTreeOpts32_closure:
         const Options.Applicative.Types.NilP_static_info;
         const Main.rbTreeOpts33_closure+2;
         const 3;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.801066 UTC

[section "data" {
     Main.rbTreeOpts31_closure:
         const Options.Applicative.Types.AltP_static_info;
         const Main.rbTreeOpts35_closure+2;
         const Main.rbTreeOpts32_closure+1;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.801483 UTC

[section "data" {
     Main.rbTreeOpts31_closure:
         const Options.Applicative.Types.AltP_static_info;
         const Main.rbTreeOpts35_closure+2;
         const Main.rbTreeOpts32_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.80186 UTC

[section "data" {
     Main.rbTreeOpts31_closure:
         const Options.Applicative.Types.AltP_static_info;
         const Main.rbTreeOpts35_closure+2;
         const Main.rbTreeOpts32_closure+1;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.80262 UTC

[section "data" {
     Main.rbTreeOpts44_closure:
         const Options.Applicative.Types.AltP_static_info;
         const Main.rbTreeOpts47_closure+4;
         const Main.rbTreeOpts45_closure+1;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.803035 UTC

[section "data" {
     Main.rbTreeOpts44_closure:
         const Options.Applicative.Types.AltP_static_info;
         const Main.rbTreeOpts47_closure+4;
         const Main.rbTreeOpts45_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.803414 UTC

[section "data" {
     Main.rbTreeOpts44_closure:
         const Options.Applicative.Types.AltP_static_info;
         const Main.rbTreeOpts47_closure+4;
         const Main.rbTreeOpts45_closure+1;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.804184 UTC

[section "data" {
     Main.rbTreeOpts57_closure:
         const Options.Applicative.Types.AltP_static_info;
         const Main.rbTreeOpts58_closure+4;
         const Main.rbTreeOpts45_closure+1;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.804612 UTC

[section "data" {
     Main.rbTreeOpts57_closure:
         const Options.Applicative.Types.AltP_static_info;
         const Main.rbTreeOpts58_closure+4;
         const Main.rbTreeOpts45_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.804993 UTC

[section "data" {
     Main.rbTreeOpts57_closure:
         const Options.Applicative.Types.AltP_static_info;
         const Main.rbTreeOpts58_closure+4;
         const Main.rbTreeOpts45_closure+1;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.805729 UTC

[section "data" {
     Main.rbTreeOpts71_closure:
         const GHC.Types.I#_static_info;
         const 8;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.80607 UTC

[section "data" {
     Main.rbTreeOpts71_closure:
         const GHC.Types.I#_static_info;
         const 8;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.806804 UTC

[section "data" {
     Main.rbTreeOpts71_closure:
         const GHC.Types.I#_static_info;
         const 8;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.807417 UTC

[section "data" {
     Main.rbTreeOpts79_closure:
         const Main.rbTreeOpts79_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ckk4_str:
         I8[] [116,104,114,101,97,100,115]
 },
 Main.rbTreeOpts79_entry() //  [R1]
         { info_tbl: [(ckk5,
                       label: Main.rbTreeOpts79_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckk5:
           _rbT2::P64 = R1;
           goto ckjZ;
       ckjZ:
           if ((old + 0) - <highSp> < SpLim) goto ckk6; else goto ckk7;
       ckk7:
           if (HpLim == 0) goto ckk6; else goto ckk8;
       ckk6:
           R1 = _rbT2::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckk8:
           (_ckk1::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT2::P64);
           if (_ckk1::I64 == 0) goto ckk3; else goto ckk2;
       ckk3:
           call (I64[_rbT2::P64])() args: 8, res: 0, upd: 8;
       ckk2:
           I64[(old + 24)] = stg_bh_upd_frame_info;
           I64[(old + 16)] = _ckk1::I64;
           R2 = ckk4_str;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.809558 UTC

{offset
  ckk5:
      _rbT2::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckk6; else goto ckk7;
  ckk7:
      if (HpLim == 0) goto ckk6; else goto ckk8;
  ckk6:
      R1 = _rbT2::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckk8:
      (_ckk1::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT2::P64);
      if (_ckk1::I64 == 0) goto ckk3; else goto ckk2;
  ckk3:
      call (I64[_rbT2::P64])() args: 8, res: 0, upd: 8;
  ckk2:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckk1::I64;
      R2 = ckk4_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:52.810647 UTC

{offset
  ckk5:
      _rbT2::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckk6; else goto ckk7;
  ckk7:
      if (HpLim == 0) goto ckk6; else goto ckk8;
  ckk6:
      R1 = _rbT2::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckk8:
      (_ckk1::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT2::P64);
      if (_ckk1::I64 == 0) goto ckk3; else goto ckk2;
  ckk3:
      call (I64[_rbT2::P64])() args: 8, res: 0, upd: 8;
  ckk2:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckk1::I64;
      R2 = ckk4_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:52.811758 UTC

{offset
  ckk5:
      _rbT2::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckk6; else goto ckk7;
  ckk7:
      if (HpLim == 0) goto ckk6; else goto ckk8;
  ckk6:
      R1 = _rbT2::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckk8:
      (_ckk1::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT2::P64);
      if (_ckk1::I64 == 0) goto ckk3; else goto ckk2;
  ckk3:
      call (I64[_rbT2::P64])() args: 8, res: 0, upd: 8;
  ckk2:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckk1::I64;
      R2 = ckk4_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:52.812911 UTC

{offset
  ckk5:
      _rbT2::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto ckk6; else goto ckk7;
  ckk7:
      if (HpLim == 0) goto ckk6; else goto ckk8;
  ckk6:
      R1 = _rbT2::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckk8:
      (_ckk1::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT2::P64);
      if (_ckk1::I64 == 0) goto ckk3; else goto ckk2;
  ckk3:
      call (I64[_rbT2::P64])() args: 8, res: 0, upd: 8;
  ckk2:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _ckk1::I64;
      R2 = ckk4_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:52.814033 UTC

{offset
  ckk5:
      _rbT2::P64 = R1;
      if ((Sp + -16) < SpLim) goto ckk6; else goto ckk7;
  ckk7:
      if (HpLim == 0) goto ckk6; else goto ckk8;
  ckk6:
      R1 = _rbT2::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckk8:
      (_ckk1::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT2::P64);
      if (_ckk1::I64 == 0) goto ckk3; else goto ckk2;
  ckk3:
      call (I64[_rbT2::P64])() args: 8, res: 0, upd: 8;
  ckk2:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _ckk1::I64;
      R2 = ckk4_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:52.815312 UTC

[(ckk2, {}), (ckk3, {}), (ckk5, {}), (ckk6, {}), (ckk7, {}),
 (ckk8, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:52.815692 UTC

Main.rbTreeOpts79_entry() //  [R1]
        { info_tbl: [(ckk5,
                      label: Main.rbTreeOpts79_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckk5:
          _rbT2::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckk6; else goto ckk7;
      ckk7:
          if (HpLim == 0) goto ckk6; else goto ckk8;
      ckk6:
          R1 = _rbT2::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckk8:
          (_ckk1::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT2::P64);
          if (_ckk1::I64 == 0) goto ckk3; else goto ckk2;
      ckk3:
          call (I64[_rbT2::P64])() args: 8, res: 0, upd: 8;
      ckk2:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _ckk1::I64;
          R2 = ckk4_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.817085 UTC

Main.rbTreeOpts79_entry() //  [R1]
        { info_tbl: [(ckk5,
                      label: Main.rbTreeOpts79_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckk5:
          _rbT2::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckk6; else goto ckk7;
      ckk7:
          if (HpLim == 0) goto ckk6; else goto ckk8;
      ckk6:
          R1 = _rbT2::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckk8:
          (_ckk1::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT2::P64);
          if (_ckk1::I64 == 0) goto ckk3; else goto ckk2;
      ckk3:
          call (I64[_rbT2::P64])() args: 8, res: 0, upd: 8;
      ckk2:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _ckk1::I64;
          R2 = ckk4_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.818479 UTC

[section "data" {
     Main.rbTreeOpts79_closure:
         const Main.rbTreeOpts79_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ckk4_str:
         I8[] [116,104,114,101,97,100,115]
 },
 Main.rbTreeOpts79_entry() //  [R1]
         { info_tbl: [(ckk5,
                       label: Main.rbTreeOpts79_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckk5:
           _rbT2::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckk6; else goto ckk7;
       ckk7:
           if (HpLim == 0) goto ckk6; else goto ckk8;
       ckk6:
           R1 = _rbT2::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckk8:
           (_ckk1::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT2::P64);
           if (_ckk1::I64 == 0) goto ckk3; else goto ckk2;
       ckk3:
           call (I64[_rbT2::P64])() args: 8, res: 0, upd: 8;
       ckk2:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ckk1::I64;
           R2 = ckk4_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.820282 UTC

[section "data" {
     Main.rbTreeOpts79_closure:
         const Main.rbTreeOpts79_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ckk4_str:
         I8[] [116,104,114,101,97,100,115]
 },
 Main.rbTreeOpts79_entry() //  [R1]
         { info_tbl: [(ckk5,
                       label: Main.rbTreeOpts79_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckk5:
           _rbT2::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckk6; else goto ckk7;
       ckk7:
           if (HpLim == 0) goto ckk6; else goto ckk8;
       ckk6:
           R1 = _rbT2::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckk8:
           (_ckk1::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT2::P64);
           if (_ckk1::I64 == 0) goto ckk3; else goto ckk2;
       ckk3:
           call (I64[_rbT2::P64])() args: 8, res: 0, upd: 8;
       ckk2:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ckk1::I64;
           R2 = ckk4_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.824955 UTC

[section "data" {
     Main.rbTreeOpts_n10_closure:
         const Options.Applicative.Types.OptLong_static_info;
         const Main.rbTreeOpts79_closure;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.825361 UTC

[section "data" {
     Main.rbTreeOpts_n10_closure:
         const Options.Applicative.Types.OptLong_static_info;
         const Main.rbTreeOpts79_closure;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.825698 UTC

[section "data" {
     Main.rbTreeOpts_n10_closure:
         const Options.Applicative.Types.OptLong_static_info;
         const Main.rbTreeOpts79_closure;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.826395 UTC

[section "data" {
     Main.rbTreeOpts75_closure:
         const Main.rbTreeOpts75_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ckkn_str:
         I8[] [78,117,109,98,101,114,32,111,102,32,116,104,114,101,97,100,115]
 },
 Main.rbTreeOpts75_entry() //  [R1]
         { info_tbl: [(ckko,
                       label: Main.rbTreeOpts75_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckko:
           _rbT7::P64 = R1;
           goto ckki;
       ckki:
           if ((old + 0) - <highSp> < SpLim) goto ckkp; else goto ckkq;
       ckkq:
           if (HpLim == 0) goto ckkp; else goto ckkr;
       ckkp:
           R1 = _rbT7::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckkr:
           (_ckkk::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT7::P64);
           if (_ckkk::I64 == 0) goto ckkm; else goto ckkl;
       ckkm:
           call (I64[_rbT7::P64])() args: 8, res: 0, upd: 8;
       ckkl:
           I64[(old + 24)] = stg_bh_upd_frame_info;
           I64[(old + 16)] = _ckkk::I64;
           R2 = ckkn_str;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.828501 UTC

{offset
  ckko:
      _rbT7::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckkp; else goto ckkq;
  ckkq:
      if (HpLim == 0) goto ckkp; else goto ckkr;
  ckkp:
      R1 = _rbT7::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckkr:
      (_ckkk::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT7::P64);
      if (_ckkk::I64 == 0) goto ckkm; else goto ckkl;
  ckkm:
      call (I64[_rbT7::P64])() args: 8, res: 0, upd: 8;
  ckkl:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckkk::I64;
      R2 = ckkn_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:52.829619 UTC

{offset
  ckko:
      _rbT7::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckkp; else goto ckkq;
  ckkq:
      if (HpLim == 0) goto ckkp; else goto ckkr;
  ckkp:
      R1 = _rbT7::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckkr:
      (_ckkk::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT7::P64);
      if (_ckkk::I64 == 0) goto ckkm; else goto ckkl;
  ckkm:
      call (I64[_rbT7::P64])() args: 8, res: 0, upd: 8;
  ckkl:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckkk::I64;
      R2 = ckkn_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:52.830726 UTC

{offset
  ckko:
      _rbT7::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckkp; else goto ckkq;
  ckkq:
      if (HpLim == 0) goto ckkp; else goto ckkr;
  ckkp:
      R1 = _rbT7::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckkr:
      (_ckkk::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT7::P64);
      if (_ckkk::I64 == 0) goto ckkm; else goto ckkl;
  ckkm:
      call (I64[_rbT7::P64])() args: 8, res: 0, upd: 8;
  ckkl:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckkk::I64;
      R2 = ckkn_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:52.831883 UTC

{offset
  ckko:
      _rbT7::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto ckkp; else goto ckkq;
  ckkq:
      if (HpLim == 0) goto ckkp; else goto ckkr;
  ckkp:
      R1 = _rbT7::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckkr:
      (_ckkk::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT7::P64);
      if (_ckkk::I64 == 0) goto ckkm; else goto ckkl;
  ckkm:
      call (I64[_rbT7::P64])() args: 8, res: 0, upd: 8;
  ckkl:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _ckkk::I64;
      R2 = ckkn_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:52.833019 UTC

{offset
  ckko:
      _rbT7::P64 = R1;
      if ((Sp + -16) < SpLim) goto ckkp; else goto ckkq;
  ckkq:
      if (HpLim == 0) goto ckkp; else goto ckkr;
  ckkp:
      R1 = _rbT7::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckkr:
      (_ckkk::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT7::P64);
      if (_ckkk::I64 == 0) goto ckkm; else goto ckkl;
  ckkm:
      call (I64[_rbT7::P64])() args: 8, res: 0, upd: 8;
  ckkl:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _ckkk::I64;
      R2 = ckkn_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:52.834828 UTC

[(ckkl, {}), (ckkm, {}), (ckko, {}), (ckkp, {}), (ckkq, {}),
 (ckkr, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:52.835228 UTC

Main.rbTreeOpts75_entry() //  [R1]
        { info_tbl: [(ckko,
                      label: Main.rbTreeOpts75_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckko:
          _rbT7::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckkp; else goto ckkq;
      ckkq:
          if (HpLim == 0) goto ckkp; else goto ckkr;
      ckkp:
          R1 = _rbT7::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckkr:
          (_ckkk::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT7::P64);
          if (_ckkk::I64 == 0) goto ckkm; else goto ckkl;
      ckkm:
          call (I64[_rbT7::P64])() args: 8, res: 0, upd: 8;
      ckkl:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _ckkk::I64;
          R2 = ckkn_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.836563 UTC

Main.rbTreeOpts75_entry() //  [R1]
        { info_tbl: [(ckko,
                      label: Main.rbTreeOpts75_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckko:
          _rbT7::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckkp; else goto ckkq;
      ckkq:
          if (HpLim == 0) goto ckkp; else goto ckkr;
      ckkp:
          R1 = _rbT7::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckkr:
          (_ckkk::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT7::P64);
          if (_ckkk::I64 == 0) goto ckkm; else goto ckkl;
      ckkm:
          call (I64[_rbT7::P64])() args: 8, res: 0, upd: 8;
      ckkl:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _ckkk::I64;
          R2 = ckkn_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.837958 UTC

[section "data" {
     Main.rbTreeOpts75_closure:
         const Main.rbTreeOpts75_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ckkn_str:
         I8[] [78,117,109,98,101,114,32,111,102,32,116,104,114,101,97,100,115]
 },
 Main.rbTreeOpts75_entry() //  [R1]
         { info_tbl: [(ckko,
                       label: Main.rbTreeOpts75_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckko:
           _rbT7::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckkp; else goto ckkq;
       ckkq:
           if (HpLim == 0) goto ckkp; else goto ckkr;
       ckkp:
           R1 = _rbT7::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckkr:
           (_ckkk::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT7::P64);
           if (_ckkk::I64 == 0) goto ckkm; else goto ckkl;
       ckkm:
           call (I64[_rbT7::P64])() args: 8, res: 0, upd: 8;
       ckkl:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ckkk::I64;
           R2 = ckkn_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.839758 UTC

[section "data" {
     Main.rbTreeOpts75_closure:
         const Main.rbTreeOpts75_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ckkn_str:
         I8[] [78,117,109,98,101,114,32,111,102,32,116,104,114,101,97,100,115]
 },
 Main.rbTreeOpts75_entry() //  [R1]
         { info_tbl: [(ckko,
                       label: Main.rbTreeOpts75_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckko:
           _rbT7::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckkp; else goto ckkq;
       ckkq:
           if (HpLim == 0) goto ckkp; else goto ckkr;
       ckkp:
           R1 = _rbT7::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckkr:
           (_ckkk::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT7::P64);
           if (_ckkk::I64 == 0) goto ckkm; else goto ckkl;
       ckkm:
           call (I64[_rbT7::P64])() args: 8, res: 0, upd: 8;
       ckkl:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ckkk::I64;
           R2 = ckkn_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.84445 UTC

[section "data" {
     Main.rbTreeOpts_lvl6_closure:
         const Main.rbTreeOpts_lvl6_info;
         const 0;
         const 0;
         const 0;
 },
 Main.rbTreeOpts_lvl6_entry() //  [R1]
         { info_tbl: [(ckkE,
                       label: Main.rbTreeOpts_lvl6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckkE:
           _rbTF::P64 = R1;
           goto ckkz;
       ckkz:
           if ((old + 0) - <highSp> < SpLim) goto ckkF; else goto ckkG;
       ckkG:
           if (HpLim == 0) goto ckkF; else goto ckkH;
       ckkF:
           R1 = _rbTF::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckkH:
           (_ckkB::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTF::P64);
           if (_ckkB::I64 == 0) goto ckkD; else goto ckkC;
       ckkD:
           call (I64[_rbTF::P64])() args: 8, res: 0, upd: 8;
       ckkC:
           I64[(old + 24)] = stg_bh_upd_frame_info;
           I64[(old + 16)] = _ckkB::I64;
           R4 = Main.rbTreeOpts75_closure;
           R3 = GHC.Base.Nothing_closure+1;
           R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
           call Data.OldList.wordsFB_info(R4,
                                          R3,
                                          R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.84669 UTC

{offset
  ckkE:
      _rbTF::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckkF; else goto ckkG;
  ckkG:
      if (HpLim == 0) goto ckkF; else goto ckkH;
  ckkF:
      R1 = _rbTF::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckkH:
      (_ckkB::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTF::P64);
      if (_ckkB::I64 == 0) goto ckkD; else goto ckkC;
  ckkD:
      call (I64[_rbTF::P64])() args: 8, res: 0, upd: 8;
  ckkC:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckkB::I64;
      R4 = Main.rbTreeOpts75_closure;
      R3 = GHC.Base.Nothing_closure+1;
      R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
      call Data.OldList.wordsFB_info(R4,
                                     R3,
                                     R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:52.847948 UTC

{offset
  ckkE:
      _rbTF::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckkF; else goto ckkG;
  ckkG:
      if (HpLim == 0) goto ckkF; else goto ckkH;
  ckkF:
      R1 = _rbTF::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckkH:
      (_ckkB::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTF::P64);
      if (_ckkB::I64 == 0) goto ckkD; else goto ckkC;
  ckkD:
      call (I64[_rbTF::P64])() args: 8, res: 0, upd: 8;
  ckkC:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckkB::I64;
      R4 = Main.rbTreeOpts75_closure;
      R3 = GHC.Base.Nothing_closure+1;
      R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
      call Data.OldList.wordsFB_info(R4,
                                     R3,
                                     R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:52.849204 UTC

{offset
  ckkE:
      _rbTF::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckkF; else goto ckkG;
  ckkG:
      if (HpLim == 0) goto ckkF; else goto ckkH;
  ckkF:
      R1 = _rbTF::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckkH:
      (_ckkB::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTF::P64);
      if (_ckkB::I64 == 0) goto ckkD; else goto ckkC;
  ckkD:
      call (I64[_rbTF::P64])() args: 8, res: 0, upd: 8;
  ckkC:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckkB::I64;
      R4 = Main.rbTreeOpts75_closure;
      R3 = GHC.Base.Nothing_closure+1;
      R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
      call Data.OldList.wordsFB_info(R4,
                                     R3,
                                     R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:52.850479 UTC

{offset
  ckkE:
      _rbTF::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto ckkF; else goto ckkG;
  ckkG:
      if (HpLim == 0) goto ckkF; else goto ckkH;
  ckkF:
      R1 = _rbTF::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckkH:
      (_ckkB::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTF::P64);
      if (_ckkB::I64 == 0) goto ckkD; else goto ckkC;
  ckkD:
      call (I64[_rbTF::P64])() args: 8, res: 0, upd: 8;
  ckkC:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _ckkB::I64;
      R4 = Main.rbTreeOpts75_closure;
      R3 = GHC.Base.Nothing_closure+1;
      R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
      Sp = Sp - 16;
      call Data.OldList.wordsFB_info(R4,
                                     R3,
                                     R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:52.851737 UTC

{offset
  ckkE:
      _rbTF::P64 = R1;
      if ((Sp + -16) < SpLim) goto ckkF; else goto ckkG;
  ckkG:
      if (HpLim == 0) goto ckkF; else goto ckkH;
  ckkF:
      R1 = _rbTF::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckkH:
      (_ckkB::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTF::P64);
      if (_ckkB::I64 == 0) goto ckkD; else goto ckkC;
  ckkD:
      call (I64[_rbTF::P64])() args: 8, res: 0, upd: 8;
  ckkC:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _ckkB::I64;
      R4 = Main.rbTreeOpts75_closure;
      R3 = GHC.Base.Nothing_closure+1;
      R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
      Sp = Sp - 16;
      call Data.OldList.wordsFB_info(R4,
                                     R3,
                                     R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:52.853143 UTC

[(ckkC,
  {Main.rbTreeOpts75_closure,
   Options.Applicative.Help.Chunk.paragraph1_closure}),
 (ckkD, {}),
 (ckkE,
  {Main.rbTreeOpts75_closure,
   Options.Applicative.Help.Chunk.paragraph1_closure}),
 (ckkF, {}),
 (ckkG,
  {Main.rbTreeOpts75_closure,
   Options.Applicative.Help.Chunk.paragraph1_closure}),
 (ckkH,
  {Main.rbTreeOpts75_closure,
   Options.Applicative.Help.Chunk.paragraph1_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:52.853848 UTC

Main.rbTreeOpts_lvl6_entry() //  [R1]
        { info_tbl: [(ckkE,
                      label: Main.rbTreeOpts_lvl6_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckkE:
          _rbTF::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckkF; else goto ckkG;
      ckkG:
          if (HpLim == 0) goto ckkF; else goto ckkH;
      ckkF:
          R1 = _rbTF::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckkH:
          (_ckkB::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTF::P64);
          if (_ckkB::I64 == 0) goto ckkD; else goto ckkC;
      ckkD:
          call (I64[_rbTF::P64])() args: 8, res: 0, upd: 8;
      ckkC:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _ckkB::I64;
          R4 = Main.rbTreeOpts75_closure;
          R3 = GHC.Base.Nothing_closure+1;
          R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
          Sp = Sp - 16;
          call Data.OldList.wordsFB_info(R4,
                                         R3,
                                         R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.855355 UTC

Main.rbTreeOpts_lvl6_entry() //  [R1]
        { info_tbl: [(ckkE,
                      label: Main.rbTreeOpts_lvl6_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckkE:
          _rbTF::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckkF; else goto ckkG;
      ckkG:
          if (HpLim == 0) goto ckkF; else goto ckkH;
      ckkF:
          R1 = _rbTF::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckkH:
          (_ckkB::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTF::P64);
          if (_ckkB::I64 == 0) goto ckkD; else goto ckkC;
      ckkD:
          call (I64[_rbTF::P64])() args: 8, res: 0, upd: 8;
      ckkC:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _ckkB::I64;
          R4 = Main.rbTreeOpts75_closure;
          R3 = GHC.Base.Nothing_closure+1;
          R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
          Sp = Sp - 16;
          call Data.OldList.wordsFB_info(R4,
                                         R3,
                                         R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.856897 UTC

[section "data" {
     Main.rbTreeOpts_lvl6_closure:
         const Main.rbTreeOpts_lvl6_info;
         const 0;
         const 0;
         const 0;
 },
 Main.rbTreeOpts_lvl6_entry() //  [R1]
         { info_tbl: [(ckkE,
                       label: Main.rbTreeOpts_lvl6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckkE:
           _rbTF::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckkF; else goto ckkG;
       ckkG:
           if (HpLim == 0) goto ckkF; else goto ckkH;
       ckkF:
           R1 = _rbTF::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckkH:
           (_ckkB::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTF::P64);
           if (_ckkB::I64 == 0) goto ckkD; else goto ckkC;
       ckkD:
           call (I64[_rbTF::P64])() args: 8, res: 0, upd: 8;
       ckkC:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ckkB::I64;
           R4 = Main.rbTreeOpts75_closure;
           R3 = GHC.Base.Nothing_closure+1;
           R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
           Sp = Sp - 16;
           call Data.OldList.wordsFB_info(R4,
                                          R3,
                                          R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.858763 UTC

[section "data" {
     Main.rbTreeOpts_lvl6_closure:
         const Main.rbTreeOpts_lvl6_info;
         const 0;
         const 0;
         const 0;
 },
 Main.rbTreeOpts_lvl6_entry() //  [R1]
         { info_tbl: [(ckkE,
                       label: Main.rbTreeOpts_lvl6_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckkE:
           _rbTF::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckkF; else goto ckkG;
       ckkG:
           if (HpLim == 0) goto ckkF; else goto ckkH;
       ckkF:
           R1 = _rbTF::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckkH:
           (_ckkB::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTF::P64);
           if (_ckkB::I64 == 0) goto ckkD; else goto ckkC;
       ckkD:
           call (I64[_rbTF::P64])() args: 8, res: 0, upd: 8;
       ckkC:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ckkB::I64;
           R4 = Main.rbTreeOpts75_closure;
           R3 = GHC.Base.Nothing_closure+1;
           R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
           Sp = Sp - 16;
           call Data.OldList.wordsFB_info(R4,
                                          R3,
                                          R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.863678 UTC

[section "data" {
     Main.rbTreeOpts_n11_closure:
         const Options.Applicative.Types.OptShort_static_info;
         const 116;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.86405 UTC

[section "data" {
     Main.rbTreeOpts_n11_closure:
         const Options.Applicative.Types.OptShort_static_info;
         const 116;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.864352 UTC

[section "data" {
     Main.rbTreeOpts_n11_closure:
         const Options.Applicative.Types.OptShort_static_info;
         const 116;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.865014 UTC

[section "data" {
     Main.rbTreeOpts78_closure:
         const :_static_info;
         const Main.rbTreeOpts_n10_closure+2;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.865451 UTC

[section "data" {
     Main.rbTreeOpts78_closure:
         const :_static_info;
         const Main.rbTreeOpts_n10_closure+2;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.865829 UTC

[section "data" {
     Main.rbTreeOpts78_closure:
         const :_static_info;
         const Main.rbTreeOpts_n10_closure+2;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.867113 UTC

[section "data" {
     Main.rbTreeOpts77_closure:
         const :_static_info;
         const Main.rbTreeOpts_n11_closure+1;
         const Main.rbTreeOpts78_closure+2;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.867538 UTC

[section "data" {
     Main.rbTreeOpts77_closure:
         const :_static_info;
         const Main.rbTreeOpts_n11_closure+1;
         const Main.rbTreeOpts78_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.86791 UTC

[section "data" {
     Main.rbTreeOpts77_closure:
         const :_static_info;
         const Main.rbTreeOpts_n11_closure+1;
         const Main.rbTreeOpts78_closure+2;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.868689 UTC

[section "data" {
     Main.rbTreeOpts76_closure:
         const Options.Applicative.Types.OptReader_static_info;
         const Main.rbTreeOpts77_closure+2;
         const Main.rbTreeOpts10_closure+1;
         const Options.Applicative.Builder.abortOption3_closure;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.869167 UTC

[section "data" {
     Main.rbTreeOpts76_closure:
         const Options.Applicative.Types.OptReader_static_info;
         const Main.rbTreeOpts77_closure+2;
         const Main.rbTreeOpts10_closure+1;
         const Options.Applicative.Builder.abortOption3_closure;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.869585 UTC

[section "data" {
     Main.rbTreeOpts76_closure:
         const Options.Applicative.Types.OptReader_static_info;
         const Main.rbTreeOpts77_closure+2;
         const Main.rbTreeOpts10_closure+1;
         const Options.Applicative.Builder.abortOption3_closure;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.870487 UTC

[section "data" {
     Main.rbTreeOpts74_closure:
         const Options.Applicative.Types.OptProperties_static_info;
         const Options.Applicative.Types.Visible_closure+3;
         const Main.rbTreeOpts_lvl6_closure;
         const Options.Applicative.Builder.abortOption_var_closure;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.87097 UTC

[section "data" {
     Main.rbTreeOpts74_closure:
         const Options.Applicative.Types.OptProperties_static_info;
         const Options.Applicative.Types.Visible_closure+3;
         const Main.rbTreeOpts_lvl6_closure;
         const Options.Applicative.Builder.abortOption_var_closure;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.871433 UTC

[section "data" {
     Main.rbTreeOpts74_closure:
         const Options.Applicative.Types.OptProperties_static_info;
         const Options.Applicative.Types.Visible_closure+3;
         const Main.rbTreeOpts_lvl6_closure;
         const Options.Applicative.Builder.abortOption_var_closure;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.872338 UTC

[section "data" {
     Main.rbTreeOpts73_closure:
         const Options.Applicative.Types.Option_static_info;
         const Main.rbTreeOpts76_closure+1;
         const Main.rbTreeOpts74_closure+1;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.872772 UTC

[section "data" {
     Main.rbTreeOpts73_closure:
         const Options.Applicative.Types.Option_static_info;
         const Main.rbTreeOpts76_closure+1;
         const Main.rbTreeOpts74_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.873155 UTC

[section "data" {
     Main.rbTreeOpts73_closure:
         const Options.Applicative.Types.Option_static_info;
         const Main.rbTreeOpts76_closure+1;
         const Main.rbTreeOpts74_closure+1;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.873906 UTC

[section "data" {
     Main.rbTreeOpts70_closure:
         const GHC.Base.Just_static_info;
         const Main.rbTreeOpts71_closure+1;
         const 3;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.874284 UTC

[section "data" {
     Main.rbTreeOpts70_closure:
         const GHC.Base.Just_static_info;
         const Main.rbTreeOpts71_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.874627 UTC

[section "data" {
     Main.rbTreeOpts70_closure:
         const GHC.Base.Just_static_info;
         const Main.rbTreeOpts71_closure+1;
         const 3;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.875318 UTC

[section "data" {
     Main.rbTreeOpts72_closure:
         const Options.Applicative.Types.OptP_static_info;
         const Main.rbTreeOpts73_closure+1;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.8757 UTC

[section "data" {
     Main.rbTreeOpts72_closure:
         const Options.Applicative.Types.OptP_static_info;
         const Main.rbTreeOpts73_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.876047 UTC

[section "data" {
     Main.rbTreeOpts72_closure:
         const Options.Applicative.Types.OptP_static_info;
         const Main.rbTreeOpts73_closure+1;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.876731 UTC

[section "data" {
     Main.rbTreeOpts69_closure:
         const Options.Applicative.Types.NilP_static_info;
         const Main.rbTreeOpts70_closure+2;
         const 3;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.877163 UTC

[section "data" {
     Main.rbTreeOpts69_closure:
         const Options.Applicative.Types.NilP_static_info;
         const Main.rbTreeOpts70_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.877507 UTC

[section "data" {
     Main.rbTreeOpts69_closure:
         const Options.Applicative.Types.NilP_static_info;
         const Main.rbTreeOpts70_closure+2;
         const 3;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.878669 UTC

[section "data" {
     Main.rbTreeOpts68_closure:
         const Options.Applicative.Types.AltP_static_info;
         const Main.rbTreeOpts72_closure+2;
         const Main.rbTreeOpts69_closure+1;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.879218 UTC

[section "data" {
     Main.rbTreeOpts68_closure:
         const Options.Applicative.Types.AltP_static_info;
         const Main.rbTreeOpts72_closure+2;
         const Main.rbTreeOpts69_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.879603 UTC

[section "data" {
     Main.rbTreeOpts68_closure:
         const Options.Applicative.Types.AltP_static_info;
         const Main.rbTreeOpts72_closure+2;
         const Main.rbTreeOpts69_closure+1;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.880339 UTC

[section "data" {
     Main.rbTreeOpts84_closure:
         const GHC.Types.W#_static_info;
         const 800;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.880674 UTC

[section "data" {
     Main.rbTreeOpts84_closure:
         const GHC.Types.W#_static_info;
         const 800;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.880974 UTC

[section "data" {
     Main.rbTreeOpts84_closure:
         const GHC.Types.W#_static_info;
         const 800;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.881556 UTC

[section "data" {
     Main.rbTreeOpts94_closure:
         const Main.rbTreeOpts94_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     cklf_str:
         I8[] [101,110,116,114,105,101,115]
 },
 Main.rbTreeOpts94_entry() //  [R1]
         { info_tbl: [(cklg,
                       label: Main.rbTreeOpts94_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cklg:
           _rbT1::P64 = R1;
           goto ckla;
       ckla:
           if ((old + 0) - <highSp> < SpLim) goto cklh; else goto ckli;
       ckli:
           if (HpLim == 0) goto cklh; else goto cklj;
       cklh:
           R1 = _rbT1::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cklj:
           (_cklc::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT1::P64);
           if (_cklc::I64 == 0) goto ckle; else goto ckld;
       ckle:
           call (I64[_rbT1::P64])() args: 8, res: 0, upd: 8;
       ckld:
           I64[(old + 24)] = stg_bh_upd_frame_info;
           I64[(old + 16)] = _cklc::I64;
           R2 = cklf_str;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.883691 UTC

{offset
  cklg:
      _rbT1::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cklh; else goto ckli;
  ckli:
      if (HpLim == 0) goto cklh; else goto cklj;
  cklh:
      R1 = _rbT1::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cklj:
      (_cklc::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT1::P64);
      if (_cklc::I64 == 0) goto ckle; else goto ckld;
  ckle:
      call (I64[_rbT1::P64])() args: 8, res: 0, upd: 8;
  ckld:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _cklc::I64;
      R2 = cklf_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:52.884791 UTC

{offset
  cklg:
      _rbT1::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cklh; else goto ckli;
  ckli:
      if (HpLim == 0) goto cklh; else goto cklj;
  cklh:
      R1 = _rbT1::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cklj:
      (_cklc::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT1::P64);
      if (_cklc::I64 == 0) goto ckle; else goto ckld;
  ckle:
      call (I64[_rbT1::P64])() args: 8, res: 0, upd: 8;
  ckld:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _cklc::I64;
      R2 = cklf_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:52.885913 UTC

{offset
  cklg:
      _rbT1::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cklh; else goto ckli;
  ckli:
      if (HpLim == 0) goto cklh; else goto cklj;
  cklh:
      R1 = _rbT1::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cklj:
      (_cklc::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT1::P64);
      if (_cklc::I64 == 0) goto ckle; else goto ckld;
  ckle:
      call (I64[_rbT1::P64])() args: 8, res: 0, upd: 8;
  ckld:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _cklc::I64;
      R2 = cklf_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:52.887116 UTC

{offset
  cklg:
      _rbT1::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto cklh; else goto ckli;
  ckli:
      if (HpLim == 0) goto cklh; else goto cklj;
  cklh:
      R1 = _rbT1::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cklj:
      (_cklc::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT1::P64);
      if (_cklc::I64 == 0) goto ckle; else goto ckld;
  ckle:
      call (I64[_rbT1::P64])() args: 8, res: 0, upd: 8;
  ckld:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _cklc::I64;
      R2 = cklf_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:52.888256 UTC

{offset
  cklg:
      _rbT1::P64 = R1;
      if ((Sp + -16) < SpLim) goto cklh; else goto ckli;
  ckli:
      if (HpLim == 0) goto cklh; else goto cklj;
  cklh:
      R1 = _rbT1::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cklj:
      (_cklc::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT1::P64);
      if (_cklc::I64 == 0) goto ckle; else goto ckld;
  ckle:
      call (I64[_rbT1::P64])() args: 8, res: 0, upd: 8;
  ckld:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _cklc::I64;
      R2 = cklf_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:52.889576 UTC

[(ckld, {}), (ckle, {}), (cklg, {}), (cklh, {}), (ckli, {}),
 (cklj, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:52.889957 UTC

Main.rbTreeOpts94_entry() //  [R1]
        { info_tbl: [(cklg,
                      label: Main.rbTreeOpts94_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cklg:
          _rbT1::P64 = R1;
          if ((Sp + -16) < SpLim) goto cklh; else goto ckli;
      ckli:
          if (HpLim == 0) goto cklh; else goto cklj;
      cklh:
          R1 = _rbT1::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      cklj:
          (_cklc::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT1::P64);
          if (_cklc::I64 == 0) goto ckle; else goto ckld;
      ckle:
          call (I64[_rbT1::P64])() args: 8, res: 0, upd: 8;
      ckld:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _cklc::I64;
          R2 = cklf_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.891321 UTC

Main.rbTreeOpts94_entry() //  [R1]
        { info_tbl: [(cklg,
                      label: Main.rbTreeOpts94_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cklg:
          _rbT1::P64 = R1;
          if ((Sp + -16) < SpLim) goto cklh; else goto ckli;
      ckli:
          if (HpLim == 0) goto cklh; else goto cklj;
      cklh:
          R1 = _rbT1::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      cklj:
          (_cklc::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT1::P64);
          if (_cklc::I64 == 0) goto ckle; else goto ckld;
      ckle:
          call (I64[_rbT1::P64])() args: 8, res: 0, upd: 8;
      ckld:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _cklc::I64;
          R2 = cklf_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.89272 UTC

[section "data" {
     Main.rbTreeOpts94_closure:
         const Main.rbTreeOpts94_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     cklf_str:
         I8[] [101,110,116,114,105,101,115]
 },
 Main.rbTreeOpts94_entry() //  [R1]
         { info_tbl: [(cklg,
                       label: Main.rbTreeOpts94_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cklg:
           _rbT1::P64 = R1;
           if ((Sp + -16) < SpLim) goto cklh; else goto ckli;
       ckli:
           if (HpLim == 0) goto cklh; else goto cklj;
       cklh:
           R1 = _rbT1::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cklj:
           (_cklc::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT1::P64);
           if (_cklc::I64 == 0) goto ckle; else goto ckld;
       ckle:
           call (I64[_rbT1::P64])() args: 8, res: 0, upd: 8;
       ckld:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cklc::I64;
           R2 = cklf_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.894453 UTC

[section "data" {
     Main.rbTreeOpts94_closure:
         const Main.rbTreeOpts94_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     cklf_str:
         I8[] [101,110,116,114,105,101,115]
 },
 Main.rbTreeOpts94_entry() //  [R1]
         { info_tbl: [(cklg,
                       label: Main.rbTreeOpts94_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cklg:
           _rbT1::P64 = R1;
           if ((Sp + -16) < SpLim) goto cklh; else goto ckli;
       ckli:
           if (HpLim == 0) goto cklh; else goto cklj;
       cklh:
           R1 = _rbT1::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cklj:
           (_cklc::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT1::P64);
           if (_cklc::I64 == 0) goto ckle; else goto ckld;
       ckle:
           call (I64[_rbT1::P64])() args: 8, res: 0, upd: 8;
       ckld:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cklc::I64;
           R2 = cklf_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.899195 UTC

[section "data" {
     Main.rbTreeOpts_n12_closure:
         const Options.Applicative.Types.OptLong_static_info;
         const Main.rbTreeOpts94_closure;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.899605 UTC

[section "data" {
     Main.rbTreeOpts_n12_closure:
         const Options.Applicative.Types.OptLong_static_info;
         const Main.rbTreeOpts94_closure;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.899952 UTC

[section "data" {
     Main.rbTreeOpts_n12_closure:
         const Options.Applicative.Types.OptLong_static_info;
         const Main.rbTreeOpts94_closure;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.900614 UTC

[section "data" {
     Main.rbTreeOpts88_closure:
         const Main.rbTreeOpts88_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ckly_str:
         I8[] [78,117,109,98,101,114,32,111,102,32,118,97,108,117,101,115,32,105,110,32,116,104,101,32,116,114,101,101]
 },
 Main.rbTreeOpts88_entry() //  [R1]
         { info_tbl: [(cklz,
                       label: Main.rbTreeOpts88_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cklz:
           _rbT6::P64 = R1;
           goto cklt;
       cklt:
           if ((old + 0) - <highSp> < SpLim) goto cklA; else goto cklB;
       cklB:
           if (HpLim == 0) goto cklA; else goto cklC;
       cklA:
           R1 = _rbT6::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cklC:
           (_cklv::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT6::P64);
           if (_cklv::I64 == 0) goto cklx; else goto cklw;
       cklx:
           call (I64[_rbT6::P64])() args: 8, res: 0, upd: 8;
       cklw:
           I64[(old + 24)] = stg_bh_upd_frame_info;
           I64[(old + 16)] = _cklv::I64;
           R2 = ckly_str;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.902689 UTC

{offset
  cklz:
      _rbT6::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cklA; else goto cklB;
  cklB:
      if (HpLim == 0) goto cklA; else goto cklC;
  cklA:
      R1 = _rbT6::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cklC:
      (_cklv::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT6::P64);
      if (_cklv::I64 == 0) goto cklx; else goto cklw;
  cklx:
      call (I64[_rbT6::P64])() args: 8, res: 0, upd: 8;
  cklw:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _cklv::I64;
      R2 = ckly_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:52.904319 UTC

{offset
  cklz:
      _rbT6::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cklA; else goto cklB;
  cklB:
      if (HpLim == 0) goto cklA; else goto cklC;
  cklA:
      R1 = _rbT6::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cklC:
      (_cklv::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT6::P64);
      if (_cklv::I64 == 0) goto cklx; else goto cklw;
  cklx:
      call (I64[_rbT6::P64])() args: 8, res: 0, upd: 8;
  cklw:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _cklv::I64;
      R2 = ckly_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:52.905426 UTC

{offset
  cklz:
      _rbT6::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cklA; else goto cklB;
  cklB:
      if (HpLim == 0) goto cklA; else goto cklC;
  cklA:
      R1 = _rbT6::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cklC:
      (_cklv::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT6::P64);
      if (_cklv::I64 == 0) goto cklx; else goto cklw;
  cklx:
      call (I64[_rbT6::P64])() args: 8, res: 0, upd: 8;
  cklw:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _cklv::I64;
      R2 = ckly_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:52.906587 UTC

{offset
  cklz:
      _rbT6::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto cklA; else goto cklB;
  cklB:
      if (HpLim == 0) goto cklA; else goto cklC;
  cklA:
      R1 = _rbT6::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cklC:
      (_cklv::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT6::P64);
      if (_cklv::I64 == 0) goto cklx; else goto cklw;
  cklx:
      call (I64[_rbT6::P64])() args: 8, res: 0, upd: 8;
  cklw:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _cklv::I64;
      R2 = ckly_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:52.90773 UTC

{offset
  cklz:
      _rbT6::P64 = R1;
      if ((Sp + -16) < SpLim) goto cklA; else goto cklB;
  cklB:
      if (HpLim == 0) goto cklA; else goto cklC;
  cklA:
      R1 = _rbT6::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cklC:
      (_cklv::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT6::P64);
      if (_cklv::I64 == 0) goto cklx; else goto cklw;
  cklx:
      call (I64[_rbT6::P64])() args: 8, res: 0, upd: 8;
  cklw:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _cklv::I64;
      R2 = ckly_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:52.909013 UTC

[(cklw, {}), (cklx, {}), (cklz, {}), (cklA, {}), (cklB, {}),
 (cklC, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:52.909415 UTC

Main.rbTreeOpts88_entry() //  [R1]
        { info_tbl: [(cklz,
                      label: Main.rbTreeOpts88_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cklz:
          _rbT6::P64 = R1;
          if ((Sp + -16) < SpLim) goto cklA; else goto cklB;
      cklB:
          if (HpLim == 0) goto cklA; else goto cklC;
      cklA:
          R1 = _rbT6::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      cklC:
          (_cklv::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT6::P64);
          if (_cklv::I64 == 0) goto cklx; else goto cklw;
      cklx:
          call (I64[_rbT6::P64])() args: 8, res: 0, upd: 8;
      cklw:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _cklv::I64;
          R2 = ckly_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.910787 UTC

Main.rbTreeOpts88_entry() //  [R1]
        { info_tbl: [(cklz,
                      label: Main.rbTreeOpts88_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cklz:
          _rbT6::P64 = R1;
          if ((Sp + -16) < SpLim) goto cklA; else goto cklB;
      cklB:
          if (HpLim == 0) goto cklA; else goto cklC;
      cklA:
          R1 = _rbT6::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      cklC:
          (_cklv::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT6::P64);
          if (_cklv::I64 == 0) goto cklx; else goto cklw;
      cklx:
          call (I64[_rbT6::P64])() args: 8, res: 0, upd: 8;
      cklw:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _cklv::I64;
          R2 = ckly_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.91218 UTC

[section "data" {
     Main.rbTreeOpts88_closure:
         const Main.rbTreeOpts88_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ckly_str:
         I8[] [78,117,109,98,101,114,32,111,102,32,118,97,108,117,101,115,32,105,110,32,116,104,101,32,116,114,101,101]
 },
 Main.rbTreeOpts88_entry() //  [R1]
         { info_tbl: [(cklz,
                       label: Main.rbTreeOpts88_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cklz:
           _rbT6::P64 = R1;
           if ((Sp + -16) < SpLim) goto cklA; else goto cklB;
       cklB:
           if (HpLim == 0) goto cklA; else goto cklC;
       cklA:
           R1 = _rbT6::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cklC:
           (_cklv::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT6::P64);
           if (_cklv::I64 == 0) goto cklx; else goto cklw;
       cklx:
           call (I64[_rbT6::P64])() args: 8, res: 0, upd: 8;
       cklw:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cklv::I64;
           R2 = ckly_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.913926 UTC

[section "data" {
     Main.rbTreeOpts88_closure:
         const Main.rbTreeOpts88_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ckly_str:
         I8[] [78,117,109,98,101,114,32,111,102,32,118,97,108,117,101,115,32,105,110,32,116,104,101,32,116,114,101,101]
 },
 Main.rbTreeOpts88_entry() //  [R1]
         { info_tbl: [(cklz,
                       label: Main.rbTreeOpts88_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cklz:
           _rbT6::P64 = R1;
           if ((Sp + -16) < SpLim) goto cklA; else goto cklB;
       cklB:
           if (HpLim == 0) goto cklA; else goto cklC;
       cklA:
           R1 = _rbT6::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cklC:
           (_cklv::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbT6::P64);
           if (_cklv::I64 == 0) goto cklx; else goto cklw;
       cklx:
           call (I64[_rbT6::P64])() args: 8, res: 0, upd: 8;
       cklw:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cklv::I64;
           R2 = ckly_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.918824 UTC

[section "data" {
     Main.rbTreeOpts_lvl7_closure:
         const Main.rbTreeOpts_lvl7_info;
         const 0;
         const 0;
         const 0;
 },
 Main.rbTreeOpts_lvl7_entry() //  [R1]
         { info_tbl: [(cklP,
                       label: Main.rbTreeOpts_lvl7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cklP:
           _rbTq::P64 = R1;
           goto cklK;
       cklK:
           if ((old + 0) - <highSp> < SpLim) goto cklQ; else goto cklR;
       cklR:
           if (HpLim == 0) goto cklQ; else goto cklS;
       cklQ:
           R1 = _rbTq::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cklS:
           (_cklM::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTq::P64);
           if (_cklM::I64 == 0) goto cklO; else goto cklN;
       cklO:
           call (I64[_rbTq::P64])() args: 8, res: 0, upd: 8;
       cklN:
           I64[(old + 24)] = stg_bh_upd_frame_info;
           I64[(old + 16)] = _cklM::I64;
           R4 = Main.rbTreeOpts88_closure;
           R3 = GHC.Base.Nothing_closure+1;
           R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
           call Data.OldList.wordsFB_info(R4,
                                          R3,
                                          R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.921159 UTC

{offset
  cklP:
      _rbTq::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cklQ; else goto cklR;
  cklR:
      if (HpLim == 0) goto cklQ; else goto cklS;
  cklQ:
      R1 = _rbTq::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cklS:
      (_cklM::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTq::P64);
      if (_cklM::I64 == 0) goto cklO; else goto cklN;
  cklO:
      call (I64[_rbTq::P64])() args: 8, res: 0, upd: 8;
  cklN:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _cklM::I64;
      R4 = Main.rbTreeOpts88_closure;
      R3 = GHC.Base.Nothing_closure+1;
      R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
      call Data.OldList.wordsFB_info(R4,
                                     R3,
                                     R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:52.922374 UTC

{offset
  cklP:
      _rbTq::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cklQ; else goto cklR;
  cklR:
      if (HpLim == 0) goto cklQ; else goto cklS;
  cklQ:
      R1 = _rbTq::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cklS:
      (_cklM::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTq::P64);
      if (_cklM::I64 == 0) goto cklO; else goto cklN;
  cklO:
      call (I64[_rbTq::P64])() args: 8, res: 0, upd: 8;
  cklN:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _cklM::I64;
      R4 = Main.rbTreeOpts88_closure;
      R3 = GHC.Base.Nothing_closure+1;
      R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
      call Data.OldList.wordsFB_info(R4,
                                     R3,
                                     R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:52.923601 UTC

{offset
  cklP:
      _rbTq::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cklQ; else goto cklR;
  cklR:
      if (HpLim == 0) goto cklQ; else goto cklS;
  cklQ:
      R1 = _rbTq::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cklS:
      (_cklM::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTq::P64);
      if (_cklM::I64 == 0) goto cklO; else goto cklN;
  cklO:
      call (I64[_rbTq::P64])() args: 8, res: 0, upd: 8;
  cklN:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _cklM::I64;
      R4 = Main.rbTreeOpts88_closure;
      R3 = GHC.Base.Nothing_closure+1;
      R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
      call Data.OldList.wordsFB_info(R4,
                                     R3,
                                     R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:52.924875 UTC

{offset
  cklP:
      _rbTq::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto cklQ; else goto cklR;
  cklR:
      if (HpLim == 0) goto cklQ; else goto cklS;
  cklQ:
      R1 = _rbTq::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cklS:
      (_cklM::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTq::P64);
      if (_cklM::I64 == 0) goto cklO; else goto cklN;
  cklO:
      call (I64[_rbTq::P64])() args: 8, res: 0, upd: 8;
  cklN:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _cklM::I64;
      R4 = Main.rbTreeOpts88_closure;
      R3 = GHC.Base.Nothing_closure+1;
      R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
      Sp = Sp - 16;
      call Data.OldList.wordsFB_info(R4,
                                     R3,
                                     R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:52.926131 UTC

{offset
  cklP:
      _rbTq::P64 = R1;
      if ((Sp + -16) < SpLim) goto cklQ; else goto cklR;
  cklR:
      if (HpLim == 0) goto cklQ; else goto cklS;
  cklQ:
      R1 = _rbTq::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cklS:
      (_cklM::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTq::P64);
      if (_cklM::I64 == 0) goto cklO; else goto cklN;
  cklO:
      call (I64[_rbTq::P64])() args: 8, res: 0, upd: 8;
  cklN:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _cklM::I64;
      R4 = Main.rbTreeOpts88_closure;
      R3 = GHC.Base.Nothing_closure+1;
      R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
      Sp = Sp - 16;
      call Data.OldList.wordsFB_info(R4,
                                     R3,
                                     R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:52.927547 UTC

[(cklN,
  {Main.rbTreeOpts88_closure,
   Options.Applicative.Help.Chunk.paragraph1_closure}),
 (cklO, {}),
 (cklP,
  {Main.rbTreeOpts88_closure,
   Options.Applicative.Help.Chunk.paragraph1_closure}),
 (cklQ, {}),
 (cklR,
  {Main.rbTreeOpts88_closure,
   Options.Applicative.Help.Chunk.paragraph1_closure}),
 (cklS,
  {Main.rbTreeOpts88_closure,
   Options.Applicative.Help.Chunk.paragraph1_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:52.928252 UTC

Main.rbTreeOpts_lvl7_entry() //  [R1]
        { info_tbl: [(cklP,
                      label: Main.rbTreeOpts_lvl7_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cklP:
          _rbTq::P64 = R1;
          if ((Sp + -16) < SpLim) goto cklQ; else goto cklR;
      cklR:
          if (HpLim == 0) goto cklQ; else goto cklS;
      cklQ:
          R1 = _rbTq::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      cklS:
          (_cklM::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTq::P64);
          if (_cklM::I64 == 0) goto cklO; else goto cklN;
      cklO:
          call (I64[_rbTq::P64])() args: 8, res: 0, upd: 8;
      cklN:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _cklM::I64;
          R4 = Main.rbTreeOpts88_closure;
          R3 = GHC.Base.Nothing_closure+1;
          R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
          Sp = Sp - 16;
          call Data.OldList.wordsFB_info(R4,
                                         R3,
                                         R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.929756 UTC

Main.rbTreeOpts_lvl7_entry() //  [R1]
        { info_tbl: [(cklP,
                      label: Main.rbTreeOpts_lvl7_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cklP:
          _rbTq::P64 = R1;
          if ((Sp + -16) < SpLim) goto cklQ; else goto cklR;
      cklR:
          if (HpLim == 0) goto cklQ; else goto cklS;
      cklQ:
          R1 = _rbTq::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      cklS:
          (_cklM::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTq::P64);
          if (_cklM::I64 == 0) goto cklO; else goto cklN;
      cklO:
          call (I64[_rbTq::P64])() args: 8, res: 0, upd: 8;
      cklN:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _cklM::I64;
          R4 = Main.rbTreeOpts88_closure;
          R3 = GHC.Base.Nothing_closure+1;
          R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
          Sp = Sp - 16;
          call Data.OldList.wordsFB_info(R4,
                                         R3,
                                         R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.931294 UTC

[section "data" {
     Main.rbTreeOpts_lvl7_closure:
         const Main.rbTreeOpts_lvl7_info;
         const 0;
         const 0;
         const 0;
 },
 Main.rbTreeOpts_lvl7_entry() //  [R1]
         { info_tbl: [(cklP,
                       label: Main.rbTreeOpts_lvl7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cklP:
           _rbTq::P64 = R1;
           if ((Sp + -16) < SpLim) goto cklQ; else goto cklR;
       cklR:
           if (HpLim == 0) goto cklQ; else goto cklS;
       cklQ:
           R1 = _rbTq::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cklS:
           (_cklM::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTq::P64);
           if (_cklM::I64 == 0) goto cklO; else goto cklN;
       cklO:
           call (I64[_rbTq::P64])() args: 8, res: 0, upd: 8;
       cklN:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cklM::I64;
           R4 = Main.rbTreeOpts88_closure;
           R3 = GHC.Base.Nothing_closure+1;
           R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
           Sp = Sp - 16;
           call Data.OldList.wordsFB_info(R4,
                                          R3,
                                          R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.933133 UTC

[section "data" {
     Main.rbTreeOpts_lvl7_closure:
         const Main.rbTreeOpts_lvl7_info;
         const 0;
         const 0;
         const 0;
 },
 Main.rbTreeOpts_lvl7_entry() //  [R1]
         { info_tbl: [(cklP,
                       label: Main.rbTreeOpts_lvl7_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cklP:
           _rbTq::P64 = R1;
           if ((Sp + -16) < SpLim) goto cklQ; else goto cklR;
       cklR:
           if (HpLim == 0) goto cklQ; else goto cklS;
       cklQ:
           R1 = _rbTq::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cklS:
           (_cklM::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTq::P64);
           if (_cklM::I64 == 0) goto cklO; else goto cklN;
       cklO:
           call (I64[_rbTq::P64])() args: 8, res: 0, upd: 8;
       cklN:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _cklM::I64;
           R4 = Main.rbTreeOpts88_closure;
           R3 = GHC.Base.Nothing_closure+1;
           R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
           Sp = Sp - 16;
           call Data.OldList.wordsFB_info(R4,
                                          R3,
                                          R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.938029 UTC

[section "data" {
     Main.rbTreeOpts_n13_closure:
         const Options.Applicative.Types.OptShort_static_info;
         const 101;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.938865 UTC

[section "data" {
     Main.rbTreeOpts_n13_closure:
         const Options.Applicative.Types.OptShort_static_info;
         const 101;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.939321 UTC

[section "data" {
     Main.rbTreeOpts_n13_closure:
         const Options.Applicative.Types.OptShort_static_info;
         const 101;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.93998 UTC

[section "data" {
     Main.rbTreeOpts93_closure:
         const :_static_info;
         const Main.rbTreeOpts_n12_closure+2;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.9404 UTC

[section "data" {
     Main.rbTreeOpts93_closure:
         const :_static_info;
         const Main.rbTreeOpts_n12_closure+2;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.940772 UTC

[section "data" {
     Main.rbTreeOpts93_closure:
         const :_static_info;
         const Main.rbTreeOpts_n12_closure+2;
         const GHC.Types.[]_closure+1;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.941535 UTC

[section "data" {
     Main.rbTreeOpts92_closure:
         const :_static_info;
         const Main.rbTreeOpts_n13_closure+1;
         const Main.rbTreeOpts93_closure+2;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.941946 UTC

[section "data" {
     Main.rbTreeOpts92_closure:
         const :_static_info;
         const Main.rbTreeOpts_n13_closure+1;
         const Main.rbTreeOpts93_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.942335 UTC

[section "data" {
     Main.rbTreeOpts92_closure:
         const :_static_info;
         const Main.rbTreeOpts_n13_closure+1;
         const Main.rbTreeOpts93_closure+2;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.943117 UTC

[section "data" {
     Main.rbTreeOpts91_closure:
         const Main.rbTreeOpts91_info;
         const 0;
 },
 Main.rbTreeOpts91_entry() //  [R2]
         { info_tbl: [(ckm8,
                       label: Main.rbTreeOpts91_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckm8:
           _B1::P64 = R2;
           goto ckm6;
       ckm6:
           if ((old + 0) - <highSp> < SpLim) goto ckm9; else goto ckma;
       ckma:
           goto ckm5;
       ckm5:
           if (HpLim == 0) goto ckm9; else goto ckmb;
       ckm9:
           R2 = _B1::P64;
           R1 = Main.rbTreeOpts91_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckmb:
           R3 = _B1::P64;
           R2 = GHC.Read.$fReadWord_closure;
           call Options.Applicative.Builder.auto1_info(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.944751 UTC

{offset
  ckm8:
      _B1::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckm9; else goto ckma;
  ckma:
      if (HpLim == 0) goto ckm9; else goto ckmb;
  ckm9:
      R2 = _B1::P64;
      R1 = Main.rbTreeOpts91_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckmb:
      R3 = _B1::P64;
      R2 = GHC.Read.$fReadWord_closure;
      call Options.Applicative.Builder.auto1_info(R3,
                                                  R2) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:52.945569 UTC

{offset
  ckm8:
      _B1::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckm9; else goto ckma;
  ckma:
      if (HpLim == 0) goto ckm9; else goto ckmb;
  ckm9:
      R2 = _B1::P64;
      R1 = Main.rbTreeOpts91_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckmb:
      R3 = _B1::P64;
      R2 = GHC.Read.$fReadWord_closure;
      call Options.Applicative.Builder.auto1_info(R3,
                                                  R2) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:52.946386 UTC

{offset
  ckm8:
      _B1::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckm9; else goto ckma;
  ckma:
      if (HpLim == 0) goto ckm9; else goto ckmb;
  ckm9:
      R2 = _B1::P64;
      R1 = Main.rbTreeOpts91_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckmb:
      R3 = _B1::P64;
      R2 = GHC.Read.$fReadWord_closure;
      call Options.Applicative.Builder.auto1_info(R3,
                                                  R2) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:52.947252 UTC

{offset
  ckm8:
      _B1::P64 = R2;
      goto ckma;
  ckma:
      if (HpLim == 0) goto ckm9; else goto ckmb;
  ckm9:
      R2 = _B1::P64;
      R1 = Main.rbTreeOpts91_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckmb:
      R3 = _B1::P64;
      R2 = GHC.Read.$fReadWord_closure;
      call Options.Applicative.Builder.auto1_info(R3,
                                                  R2) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:52.947977 UTC

{offset
  ckm8:
      goto ckma;
  ckma:
      if (HpLim == 0) goto ckm9; else goto ckmb;
  ckm9:
      R2 = R2;
      R1 = Main.rbTreeOpts91_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckmb:
      R3 = R2;
      R2 = GHC.Read.$fReadWord_closure;
      call Options.Applicative.Builder.auto1_info(R3,
                                                  R2) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:52.948794 UTC

[(ckm8,
  {GHC.Read.$fReadWord_closure, Main.rbTreeOpts91_closure,
   Options.Applicative.Builder.auto1_closure}),
 (ckm9, {Main.rbTreeOpts91_closure}),
 (ckma,
  {GHC.Read.$fReadWord_closure, Main.rbTreeOpts91_closure,
   Options.Applicative.Builder.auto1_closure}),
 (ckmb,
  {GHC.Read.$fReadWord_closure,
   Options.Applicative.Builder.auto1_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:52.949464 UTC

Main.rbTreeOpts91_entry() //  [R2]
        { info_tbl: [(ckm8,
                      label: Main.rbTreeOpts91_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckm8:
          goto ckma;
      ckma:
          if (HpLim == 0) goto ckm9; else goto ckmb;
      ckm9:
          R2 = R2;
          R1 = Main.rbTreeOpts91_closure;
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
      ckmb:
          R3 = R2;
          R2 = GHC.Read.$fReadWord_closure;
          call Options.Applicative.Builder.auto1_info(R3,
                                                      R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.950413 UTC

Main.rbTreeOpts91_entry() //  [R2]
        { info_tbl: [(ckm8,
                      label: Main.rbTreeOpts91_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckm8:
          if (HpLim == 0) goto ckm9; else goto ckmb;
      ckm9:
          R2 = R2;
          R1 = Main.rbTreeOpts91_closure;
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
      ckmb:
          R3 = R2;
          R2 = GHC.Read.$fReadWord_closure;
          call Options.Applicative.Builder.auto1_info(R3,
                                                      R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.951306 UTC

[section "data" {
     Main.rbTreeOpts91_closure:
         const Main.rbTreeOpts91_info;
         const 0;
 },
 Main.rbTreeOpts91_entry() //  [R2]
         { info_tbl: [(ckm8,
                       label: Main.rbTreeOpts91_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckm8:
           if (HpLim == 0) goto ckm9; else goto ckmb;
       ckm9:
           R2 = R2;
           R1 = Main.rbTreeOpts91_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckmb:
           R3 = R2;
           R2 = GHC.Read.$fReadWord_closure;
           call Options.Applicative.Builder.auto1_info(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.952451 UTC

[section "data" {
     Main.rbTreeOpts91_closure:
         const Main.rbTreeOpts91_info;
         const 0;
 },
 Main.rbTreeOpts91_entry() //  [R2]
         { info_tbl: [(ckm8,
                       label: Main.rbTreeOpts91_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckm8:
           if (HpLim == 0) goto ckm9; else goto ckmb;
       ckm9:
           R2 = R2;
           R1 = Main.rbTreeOpts91_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckmb:
           R3 = R2;
           R2 = GHC.Read.$fReadWord_closure;
           call Options.Applicative.Builder.auto1_info(R3,
                                                       R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.955299 UTC

[section "data" {
     Main.rbTreeOpts90_closure:
         const Options.Applicative.Types.CReader_static_info;
         const Options.Applicative.Types.$fMonoidCompleter4_closure+2;
         const Main.rbTreeOpts91_closure+1;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.955743 UTC

[section "data" {
     Main.rbTreeOpts90_closure:
         const Options.Applicative.Types.CReader_static_info;
         const Options.Applicative.Types.$fMonoidCompleter4_closure+2;
         const Main.rbTreeOpts91_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.956124 UTC

[section "data" {
     Main.rbTreeOpts90_closure:
         const Options.Applicative.Types.CReader_static_info;
         const Options.Applicative.Types.$fMonoidCompleter4_closure+2;
         const Main.rbTreeOpts91_closure+1;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.957475 UTC

[section "data" {
     Main.rbTreeOpts89_closure:
         const Options.Applicative.Types.OptReader_static_info;
         const Main.rbTreeOpts92_closure+2;
         const Main.rbTreeOpts90_closure+1;
         const Options.Applicative.Builder.abortOption3_closure;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.95793 UTC

[section "data" {
     Main.rbTreeOpts89_closure:
         const Options.Applicative.Types.OptReader_static_info;
         const Main.rbTreeOpts92_closure+2;
         const Main.rbTreeOpts90_closure+1;
         const Options.Applicative.Builder.abortOption3_closure;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.958345 UTC

[section "data" {
     Main.rbTreeOpts89_closure:
         const Options.Applicative.Types.OptReader_static_info;
         const Main.rbTreeOpts92_closure+2;
         const Main.rbTreeOpts90_closure+1;
         const Options.Applicative.Builder.abortOption3_closure;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.959351 UTC

[section "data" {
     Main.rbTreeOpts87_closure:
         const Options.Applicative.Types.OptProperties_static_info;
         const Options.Applicative.Types.Visible_closure+3;
         const Main.rbTreeOpts_lvl7_closure;
         const Options.Applicative.Builder.abortOption_var_closure;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.959851 UTC

[section "data" {
     Main.rbTreeOpts87_closure:
         const Options.Applicative.Types.OptProperties_static_info;
         const Options.Applicative.Types.Visible_closure+3;
         const Main.rbTreeOpts_lvl7_closure;
         const Options.Applicative.Builder.abortOption_var_closure;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.960295 UTC

[section "data" {
     Main.rbTreeOpts87_closure:
         const Options.Applicative.Types.OptProperties_static_info;
         const Options.Applicative.Types.Visible_closure+3;
         const Main.rbTreeOpts_lvl7_closure;
         const Options.Applicative.Builder.abortOption_var_closure;
         const GHC.Base.Nothing_closure+1;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.961187 UTC

[section "data" {
     Main.rbTreeOpts86_closure:
         const Options.Applicative.Types.Option_static_info;
         const Main.rbTreeOpts89_closure+1;
         const Main.rbTreeOpts87_closure+1;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.961609 UTC

[section "data" {
     Main.rbTreeOpts86_closure:
         const Options.Applicative.Types.Option_static_info;
         const Main.rbTreeOpts89_closure+1;
         const Main.rbTreeOpts87_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.961988 UTC

[section "data" {
     Main.rbTreeOpts86_closure:
         const Options.Applicative.Types.Option_static_info;
         const Main.rbTreeOpts89_closure+1;
         const Main.rbTreeOpts87_closure+1;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.962749 UTC

[section "data" {
     Main.rbTreeOpts83_closure:
         const GHC.Base.Just_static_info;
         const Main.rbTreeOpts84_closure+1;
         const 3;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.963131 UTC

[section "data" {
     Main.rbTreeOpts83_closure:
         const GHC.Base.Just_static_info;
         const Main.rbTreeOpts84_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.963468 UTC

[section "data" {
     Main.rbTreeOpts83_closure:
         const GHC.Base.Just_static_info;
         const Main.rbTreeOpts84_closure+1;
         const 3;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.964142 UTC

[section "data" {
     Main.rbTreeOpts85_closure:
         const Options.Applicative.Types.OptP_static_info;
         const Main.rbTreeOpts86_closure+1;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.964523 UTC

[section "data" {
     Main.rbTreeOpts85_closure:
         const Options.Applicative.Types.OptP_static_info;
         const Main.rbTreeOpts86_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.964861 UTC

[section "data" {
     Main.rbTreeOpts85_closure:
         const Options.Applicative.Types.OptP_static_info;
         const Main.rbTreeOpts86_closure+1;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.965533 UTC

[section "data" {
     Main.rbTreeOpts82_closure:
         const Options.Applicative.Types.NilP_static_info;
         const Main.rbTreeOpts83_closure+2;
         const 3;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.965911 UTC

[section "data" {
     Main.rbTreeOpts82_closure:
         const Options.Applicative.Types.NilP_static_info;
         const Main.rbTreeOpts83_closure+2;
         const 3;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.966266 UTC

[section "data" {
     Main.rbTreeOpts82_closure:
         const Options.Applicative.Types.NilP_static_info;
         const Main.rbTreeOpts83_closure+2;
         const 3;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.966984 UTC

[section "data" {
     Main.rbTreeOpts81_closure:
         const Options.Applicative.Types.AltP_static_info;
         const Main.rbTreeOpts85_closure+2;
         const Main.rbTreeOpts82_closure+1;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.967404 UTC

[section "data" {
     Main.rbTreeOpts81_closure:
         const Options.Applicative.Types.AltP_static_info;
         const Main.rbTreeOpts85_closure+2;
         const Main.rbTreeOpts82_closure+1;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.967779 UTC

[section "data" {
     Main.rbTreeOpts81_closure:
         const Options.Applicative.Types.AltP_static_info;
         const Main.rbTreeOpts85_closure+2;
         const Main.rbTreeOpts82_closure+1;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.968953 UTC

[section "data" {
     Main.rbTreeOpts80_closure:
         const Main.rbTreeOpts80_info;
         const 0;
         const 0;
         const 0;
 },
 Main.rbTreeOpts80_entry() //  [R1]
         { info_tbl: [(ckmC,
                       label: Main.rbTreeOpts80_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckmC:
           _rbTP::P64 = R1;
           goto ckmx;
       ckmx:
           if ((old + 0) - <highSp> < SpLim) goto ckmD; else goto ckmE;
       ckmE:
           if (HpLim == 0) goto ckmD; else goto ckmF;
       ckmD:
           R1 = _rbTP::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckmF:
           (_ckmz::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTP::P64);
           if (_ckmz::I64 == 0) goto ckmB; else goto ckmA;
       ckmB:
           call (I64[_rbTP::P64])() args: 8, res: 0, upd: 8;
       ckmA:
           I64[(old + 24)] = stg_bh_upd_frame_info;
           I64[(old + 16)] = _ckmz::I64;
           R3 = Main.rbTreeOpts81_closure+4;
           R2 = Main.RBTreeOpts_closure+7;
           call Options.Applicative.Types.$fApplicativeParser_$cfmap_info(R3,
                                                                          R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.971117 UTC

{offset
  ckmC:
      _rbTP::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckmD; else goto ckmE;
  ckmE:
      if (HpLim == 0) goto ckmD; else goto ckmF;
  ckmD:
      R1 = _rbTP::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckmF:
      (_ckmz::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTP::P64);
      if (_ckmz::I64 == 0) goto ckmB; else goto ckmA;
  ckmB:
      call (I64[_rbTP::P64])() args: 8, res: 0, upd: 8;
  ckmA:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckmz::I64;
      R3 = Main.rbTreeOpts81_closure+4;
      R2 = Main.RBTreeOpts_closure+7;
      call Options.Applicative.Types.$fApplicativeParser_$cfmap_info(R3,
                                                                     R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:52.972284 UTC

{offset
  ckmC:
      _rbTP::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckmD; else goto ckmE;
  ckmE:
      if (HpLim == 0) goto ckmD; else goto ckmF;
  ckmD:
      R1 = _rbTP::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckmF:
      (_ckmz::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTP::P64);
      if (_ckmz::I64 == 0) goto ckmB; else goto ckmA;
  ckmB:
      call (I64[_rbTP::P64])() args: 8, res: 0, upd: 8;
  ckmA:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckmz::I64;
      R3 = Main.rbTreeOpts81_closure+4;
      R2 = Main.RBTreeOpts_closure+7;
      call Options.Applicative.Types.$fApplicativeParser_$cfmap_info(R3,
                                                                     R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:52.973492 UTC

{offset
  ckmC:
      _rbTP::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckmD; else goto ckmE;
  ckmE:
      if (HpLim == 0) goto ckmD; else goto ckmF;
  ckmD:
      R1 = _rbTP::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckmF:
      (_ckmz::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTP::P64);
      if (_ckmz::I64 == 0) goto ckmB; else goto ckmA;
  ckmB:
      call (I64[_rbTP::P64])() args: 8, res: 0, upd: 8;
  ckmA:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckmz::I64;
      R3 = Main.rbTreeOpts81_closure+4;
      R2 = Main.RBTreeOpts_closure+7;
      call Options.Applicative.Types.$fApplicativeParser_$cfmap_info(R3,
                                                                     R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:52.974715 UTC

{offset
  ckmC:
      _rbTP::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto ckmD; else goto ckmE;
  ckmE:
      if (HpLim == 0) goto ckmD; else goto ckmF;
  ckmD:
      R1 = _rbTP::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckmF:
      (_ckmz::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTP::P64);
      if (_ckmz::I64 == 0) goto ckmB; else goto ckmA;
  ckmB:
      call (I64[_rbTP::P64])() args: 8, res: 0, upd: 8;
  ckmA:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _ckmz::I64;
      R3 = Main.rbTreeOpts81_closure+4;
      R2 = Main.RBTreeOpts_closure+7;
      Sp = Sp - 16;
      call Options.Applicative.Types.$fApplicativeParser_$cfmap_info(R3,
                                                                     R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:52.975939 UTC

{offset
  ckmC:
      _rbTP::P64 = R1;
      if ((Sp + -16) < SpLim) goto ckmD; else goto ckmE;
  ckmE:
      if (HpLim == 0) goto ckmD; else goto ckmF;
  ckmD:
      R1 = _rbTP::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckmF:
      (_ckmz::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTP::P64);
      if (_ckmz::I64 == 0) goto ckmB; else goto ckmA;
  ckmB:
      call (I64[_rbTP::P64])() args: 8, res: 0, upd: 8;
  ckmA:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _ckmz::I64;
      R3 = Main.rbTreeOpts81_closure+4;
      R2 = Main.RBTreeOpts_closure+7;
      Sp = Sp - 16;
      call Options.Applicative.Types.$fApplicativeParser_$cfmap_info(R3,
                                                                     R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:52.977312 UTC

[(ckmA, {Main.rbTreeOpts81_closure}), (ckmB, {}),
 (ckmC, {Main.rbTreeOpts81_closure}), (ckmD, {}),
 (ckmE, {Main.rbTreeOpts81_closure}),
 (ckmF, {Main.rbTreeOpts81_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:52.977816 UTC

Main.rbTreeOpts80_entry() //  [R1]
        { info_tbl: [(ckmC,
                      label: Main.rbTreeOpts80_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckmC:
          _rbTP::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckmD; else goto ckmE;
      ckmE:
          if (HpLim == 0) goto ckmD; else goto ckmF;
      ckmD:
          R1 = _rbTP::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckmF:
          (_ckmz::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTP::P64);
          if (_ckmz::I64 == 0) goto ckmB; else goto ckmA;
      ckmB:
          call (I64[_rbTP::P64])() args: 8, res: 0, upd: 8;
      ckmA:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _ckmz::I64;
          R3 = Main.rbTreeOpts81_closure+4;
          R2 = Main.RBTreeOpts_closure+7;
          Sp = Sp - 16;
          call Options.Applicative.Types.$fApplicativeParser_$cfmap_info(R3,
                                                                         R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:52.97938 UTC

Main.rbTreeOpts80_entry() //  [R1]
        { info_tbl: [(ckmC,
                      label: Main.rbTreeOpts80_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckmC:
          _rbTP::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckmD; else goto ckmE;
      ckmE:
          if (HpLim == 0) goto ckmD; else goto ckmF;
      ckmD:
          R1 = _rbTP::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckmF:
          (_ckmz::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTP::P64);
          if (_ckmz::I64 == 0) goto ckmB; else goto ckmA;
      ckmB:
          call (I64[_rbTP::P64])() args: 8, res: 0, upd: 8;
      ckmA:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _ckmz::I64;
          R3 = Main.rbTreeOpts81_closure+4;
          R2 = Main.RBTreeOpts_closure+7;
          Sp = Sp - 16;
          call Options.Applicative.Types.$fApplicativeParser_$cfmap_info(R3,
                                                                         R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.980822 UTC

[section "data" {
     Main.rbTreeOpts80_closure:
         const Main.rbTreeOpts80_info;
         const 0;
         const 0;
         const 0;
 },
 Main.rbTreeOpts80_entry() //  [R1]
         { info_tbl: [(ckmC,
                       label: Main.rbTreeOpts80_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckmC:
           _rbTP::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckmD; else goto ckmE;
       ckmE:
           if (HpLim == 0) goto ckmD; else goto ckmF;
       ckmD:
           R1 = _rbTP::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckmF:
           (_ckmz::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTP::P64);
           if (_ckmz::I64 == 0) goto ckmB; else goto ckmA;
       ckmB:
           call (I64[_rbTP::P64])() args: 8, res: 0, upd: 8;
       ckmA:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ckmz::I64;
           R3 = Main.rbTreeOpts81_closure+4;
           R2 = Main.RBTreeOpts_closure+7;
           Sp = Sp - 16;
           call Options.Applicative.Types.$fApplicativeParser_$cfmap_info(R3,
                                                                          R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.982585 UTC

[section "data" {
     Main.rbTreeOpts80_closure:
         const Main.rbTreeOpts80_info;
         const 0;
         const 0;
         const 0;
 },
 Main.rbTreeOpts80_entry() //  [R1]
         { info_tbl: [(ckmC,
                       label: Main.rbTreeOpts80_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckmC:
           _rbTP::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckmD; else goto ckmE;
       ckmE:
           if (HpLim == 0) goto ckmD; else goto ckmF;
       ckmD:
           R1 = _rbTP::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckmF:
           (_ckmz::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rbTP::P64);
           if (_ckmz::I64 == 0) goto ckmB; else goto ckmA;
       ckmB:
           call (I64[_rbTP::P64])() args: 8, res: 0, upd: 8;
       ckmA:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ckmz::I64;
           R3 = Main.rbTreeOpts81_closure+4;
           R2 = Main.RBTreeOpts_closure+7;
           Sp = Sp - 16;
           call Options.Applicative.Types.$fApplicativeParser_$cfmap_info(R3,
                                                                          R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.987323 UTC

[section "data" {
     Main.rbTreeOpts67_closure:
         const Options.Applicative.Types.MultP_static_info;
         const Main.rbTreeOpts80_closure;
         const Main.rbTreeOpts68_closure+4;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.987773 UTC

[section "data" {
     Main.rbTreeOpts67_closure:
         const Options.Applicative.Types.MultP_static_info;
         const Main.rbTreeOpts80_closure;
         const Main.rbTreeOpts68_closure+4;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.988156 UTC

[section "data" {
     Main.rbTreeOpts67_closure:
         const Options.Applicative.Types.MultP_static_info;
         const Main.rbTreeOpts80_closure;
         const Main.rbTreeOpts68_closure+4;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.988945 UTC

[section "data" {
     Main.rbTreeOpts56_closure:
         const Options.Applicative.Types.MultP_static_info;
         const Main.rbTreeOpts67_closure+3;
         const Main.rbTreeOpts57_closure+4;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.989389 UTC

[section "data" {
     Main.rbTreeOpts56_closure:
         const Options.Applicative.Types.MultP_static_info;
         const Main.rbTreeOpts67_closure+3;
         const Main.rbTreeOpts57_closure+4;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.989771 UTC

[section "data" {
     Main.rbTreeOpts56_closure:
         const Options.Applicative.Types.MultP_static_info;
         const Main.rbTreeOpts67_closure+3;
         const Main.rbTreeOpts57_closure+4;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.990555 UTC

[section "data" {
     Main.rbTreeOpts43_closure:
         const Options.Applicative.Types.MultP_static_info;
         const Main.rbTreeOpts56_closure+3;
         const Main.rbTreeOpts44_closure+4;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.99098 UTC

[section "data" {
     Main.rbTreeOpts43_closure:
         const Options.Applicative.Types.MultP_static_info;
         const Main.rbTreeOpts56_closure+3;
         const Main.rbTreeOpts44_closure+4;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.991358 UTC

[section "data" {
     Main.rbTreeOpts43_closure:
         const Options.Applicative.Types.MultP_static_info;
         const Main.rbTreeOpts56_closure+3;
         const Main.rbTreeOpts44_closure+4;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.992138 UTC

[section "data" {
     Main.rbTreeOpts30_closure:
         const Options.Applicative.Types.MultP_static_info;
         const Main.rbTreeOpts43_closure+3;
         const Main.rbTreeOpts31_closure+4;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.992565 UTC

[section "data" {
     Main.rbTreeOpts30_closure:
         const Options.Applicative.Types.MultP_static_info;
         const Main.rbTreeOpts43_closure+3;
         const Main.rbTreeOpts31_closure+4;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.993439 UTC

[section "data" {
     Main.rbTreeOpts30_closure:
         const Options.Applicative.Types.MultP_static_info;
         const Main.rbTreeOpts43_closure+3;
         const Main.rbTreeOpts31_closure+4;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.994214 UTC

[section "data" {
     Main.rbTreeOpts15_closure:
         const Options.Applicative.Types.MultP_static_info;
         const Main.rbTreeOpts30_closure+3;
         const Main.rbTreeOpts16_closure+4;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:52.994636 UTC

[section "data" {
     Main.rbTreeOpts15_closure:
         const Options.Applicative.Types.MultP_static_info;
         const Main.rbTreeOpts30_closure+3;
         const Main.rbTreeOpts16_closure+4;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:52.995019 UTC

[section "data" {
     Main.rbTreeOpts15_closure:
         const Options.Applicative.Types.MultP_static_info;
         const Main.rbTreeOpts30_closure+3;
         const Main.rbTreeOpts16_closure+4;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:52.996067 UTC

[section "data" {
     Main.initGens2_closure:
         const Main.initGens2_info;
         const 0;
 },
 Main.initGens2_entry() //  [R2]
         { info_tbl: [(cknc,
                       label: Main.initGens2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cknc:
           _sjWw::P64 = R2;
           goto ckn3;
       ckn3:
           if ((old + 0) - <highSp> < SpLim) goto cknd; else goto ckne;
       ckne:
           goto ckn2;
       ckn2:
           if (HpLim == 0) goto cknd; else goto cknf;
       cknd:
           R2 = _sjWw::P64;
           R1 = Main.initGens2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cknf:
           I64[(young<ckn5> + 8)] = ckn5;
           R1 = _sjWw::P64;
           if (R1 & 7 != 0) goto ckn5; else goto ckn6;
       ckn6:
           call (I64[R1])(R1) returns to ckn5, args: 8, res: 8, upd: 8;
       ckn5:
           _sjWy::P64 = R1;
           _cknb::P64 = _sjWy::P64 & 7;
           switch [1 .. 2] _cknb::P64 {
               case 1 : goto ckn9;
               case 2 : goto ckna;
           }
       ckna:
           _sjWz::P64 = P64[_sjWy::P64 + 6];
           _sjWA::P64 = P64[_sjWy::P64 + 14];
           I64[(young<cknl> + 8)] = cknl;
           R3 = _sjWz::P64;
           R2 = Control.Monad.Primitive.$fPrimMonadIO_closure;
           I64[(young<cknl> + 16)] = stg_ap_v_info;
           call System.Random.PCG.Fast.Pure.initialize_info(R3,
                                                            R2) returns to cknl, args: 16, res: 8, upd: 8;
       cknl:
           _sjWD::P64 = R1;
           I64[(young<cknn> + 8)] = cknn;
           R2 = _sjWA::P64;
           call Main.initGens2_info(R2) returns to cknn, args: 8, res: 8, upd: 8;
       cknn:
           _sjWG::P64 = R1;
           Hp = Hp + 24;
           if (Hp > HpLim) goto cknu; else goto cknt;
       cknu:
           HpAlloc = 24;
           goto ckns;
       ckns:
           R1 = _sjWG::P64;
           call stg_gc_unpt_r1(R1) returns to cknn, args: 8, res: 8, upd: 8;
       cknt:
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sjWD::P64;
           P64[Hp] = _sjWG::P64;
           _cknp::P64 = Hp - 14;
           R1 = _cknp::P64;
           call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
       ckn9:
           R1 = GHC.Types.[]_closure+1;
           call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:53.000816 UTC

{offset
  cknc:
      _sjWw::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cknd; else goto ckne;
  ckne:
      if (HpLim == 0) goto cknd; else goto cknf;
  cknd:
      R2 = _sjWw::P64;
      R1 = Main.initGens2_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  cknf:
      I64[(young<ckn5> + 8)] = ckn5;
      R1 = _sjWw::P64;
      if (R1 & 7 != 0) goto ckn5; else goto ckn6;
  ckn6:
      call (I64[R1])(R1) returns to ckn5, args: 8, res: 8, upd: 8;
  ckn5:
      _sjWy::P64 = R1;
      _cknb::P64 = _sjWy::P64 & 7;
      switch [1 .. 2] _cknb::P64 {
          case 1 : goto ckn9;
          case 2 : goto ckna;
      }
  ckna:
      _sjWz::P64 = P64[_sjWy::P64 + 6];
      _sjWA::P64 = P64[_sjWy::P64 + 14];
      I64[(young<cknl> + 8)] = cknl;
      R3 = _sjWz::P64;
      R2 = Control.Monad.Primitive.$fPrimMonadIO_closure;
      I64[(young<cknl> + 16)] = stg_ap_v_info;
      call System.Random.PCG.Fast.Pure.initialize_info(R3,
                                                       R2) returns to cknl, args: 16, res: 8, upd: 8;
  cknl:
      _sjWD::P64 = R1;
      I64[(young<cknn> + 8)] = cknn;
      R2 = _sjWA::P64;
      call Main.initGens2_info(R2) returns to cknn, args: 8, res: 8, upd: 8;
  cknn:
      _sjWG::P64 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto cknu; else goto cknt;
  cknu:
      HpAlloc = 24;
      R1 = _sjWG::P64;
      call stg_gc_unpt_r1(R1) returns to cknn, args: 8, res: 8, upd: 8;
  cknt:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _sjWD::P64;
      P64[Hp] = _sjWG::P64;
      _cknp::P64 = Hp - 14;
      R1 = _cknp::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
  ckn9:
      R1 = GHC.Types.[]_closure+1;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:53.003357 UTC

{offset
  cknc:
      _sjWw::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cknd; else goto ckne;
  ckne:
      if (HpLim == 0) goto cknd; else goto cknf;
  cknd:
      R2 = _sjWw::P64;
      R1 = Main.initGens2_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  cknf:
      I64[(young<ckn5> + 8)] = ckn5;
      R1 = _sjWw::P64;
      if (R1 & 7 != 0) goto ckn5; else goto ckn6;
  ckn6:
      call (I64[R1])(R1) returns to ckn5, args: 8, res: 8, upd: 8;
  ckn5:
      _sjWy::P64 = R1;
      _cknb::P64 = _sjWy::P64 & 7;
      switch [1 .. 2] _cknb::P64 {
          case 1 : goto ckn9;
          case 2 : goto ckna;
      }
  ckna:
      _sjWz::P64 = P64[_sjWy::P64 + 6];
      _sjWA::P64 = P64[_sjWy::P64 + 14];
      I64[(young<cknl> + 8)] = cknl;
      R3 = _sjWz::P64;
      R2 = Control.Monad.Primitive.$fPrimMonadIO_closure;
      I64[(young<cknl> + 16)] = stg_ap_v_info;
      call System.Random.PCG.Fast.Pure.initialize_info(R3,
                                                       R2) returns to cknl, args: 16, res: 8, upd: 8;
  cknl:
      _sjWD::P64 = R1;
      I64[(young<cknn> + 8)] = cknn;
      R2 = _sjWA::P64;
      call Main.initGens2_info(R2) returns to cknn, args: 8, res: 8, upd: 8;
  cknn:
      _sjWG::P64 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto cknu; else goto cknt;
  cknu:
      HpAlloc = 24;
      R1 = _sjWG::P64;
      call stg_gc_unpt_r1(R1) returns to cknn, args: 8, res: 8, upd: 8;
  cknt:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _sjWD::P64;
      P64[Hp] = _sjWG::P64;
      _cknp::P64 = Hp - 14;
      R1 = _cknp::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
  ckn9:
      R1 = GHC.Types.[]_closure+1;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:53.005942 UTC

{offset
  cknc:
      _sjWw::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cknd; else goto ckne;
  ckne:
      if (HpLim == 0) goto cknd; else goto cknf;
  cknd:
      R2 = _sjWw::P64;
      R1 = Main.initGens2_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  cknf:
      I64[(young<ckn5> + 8)] = ckn5;
      R1 = _sjWw::P64;
      if (R1 & 7 != 0) goto ckn5; else goto ckn6;
  ckn6:
      call (I64[R1])(R1) returns to ckn5, args: 8, res: 8, upd: 8;
  ckn5:
      _sjWy::P64 = R1;
      _cknb::P64 = _sjWy::P64 & 7;
      if (_cknb::P64 != 1) goto ckna; else goto ckn9;
  ckna:
      _sjWz::P64 = P64[_sjWy::P64 + 6];
      _sjWA::P64 = P64[_sjWy::P64 + 14];
      I64[(young<cknl> + 8)] = cknl;
      R3 = _sjWz::P64;
      R2 = Control.Monad.Primitive.$fPrimMonadIO_closure;
      I64[(young<cknl> + 16)] = stg_ap_v_info;
      call System.Random.PCG.Fast.Pure.initialize_info(R3,
                                                       R2) returns to cknl, args: 16, res: 8, upd: 8;
  cknl:
      _sjWD::P64 = R1;
      I64[(young<cknn> + 8)] = cknn;
      R2 = _sjWA::P64;
      call Main.initGens2_info(R2) returns to cknn, args: 8, res: 8, upd: 8;
  cknn:
      _sjWG::P64 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto cknu; else goto cknt;
  cknu:
      HpAlloc = 24;
      R1 = _sjWG::P64;
      call stg_gc_unpt_r1(R1) returns to cknn, args: 8, res: 8, upd: 8;
  cknt:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _sjWD::P64;
      P64[Hp] = _sjWG::P64;
      _cknp::P64 = Hp - 14;
      R1 = _cknp::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
  ckn9:
      R1 = GHC.Types.[]_closure+1;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:53.008772 UTC

{offset
  cknc:
      _sjWw::P64 = R2;
      if ((Sp + 8) - 32 < SpLim) goto cknd; else goto ckne;
  ckne:
      if (HpLim == 0) goto cknd; else goto cknf;
  cknd:
      R2 = _sjWw::P64;
      R1 = Main.initGens2_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  cknf:
      I64[Sp - 8] = ckn5;
      R1 = _sjWw::P64;
      Sp = Sp - 8;
      if (R1 & 7 != 0) goto ckn5; else goto ckn6;
  ckn6:
      call (I64[R1])(R1) returns to ckn5, args: 8, res: 8, upd: 8;
  ckn5:
      _sjWy::P64 = R1;
      _cknb::P64 = _sjWy::P64 & 7;
      if (_cknb::P64 != 1) goto ckna; else goto ckn9;
  ckna:
      _sjWz::P64 = P64[_sjWy::P64 + 6];
      _sjWA::P64 = P64[_sjWy::P64 + 14];
      I64[Sp - 8] = cknl;
      R3 = _sjWz::P64;
      R2 = Control.Monad.Primitive.$fPrimMonadIO_closure;
      I64[Sp - 16] = stg_ap_v_info;
      P64[Sp] = _sjWA::P64;
      Sp = Sp - 16;
      call System.Random.PCG.Fast.Pure.initialize_info(R3,
                                                       R2) returns to cknl, args: 16, res: 8, upd: 8;
  cknl:
      _sjWA::P64 = P64[Sp + 8];
      _sjWD::P64 = R1;
      I64[Sp] = cknn;
      R2 = _sjWA::P64;
      P64[Sp + 8] = _sjWD::P64;
      call Main.initGens2_info(R2) returns to cknn, args: 8, res: 8, upd: 8;
  cknn:
      _sjWD::P64 = P64[Sp + 8];
      _sjWG::P64 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto cknu; else goto cknt;
  cknu:
      HpAlloc = 24;
      R1 = _sjWG::P64;
      call stg_gc_unpt_r1(R1) returns to cknn, args: 8, res: 8, upd: 8;
  cknt:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _sjWD::P64;
      P64[Hp] = _sjWG::P64;
      _cknp::P64 = Hp - 14;
      R1 = _cknp::P64;
      Sp = Sp + 16;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
  ckn9:
      R1 = GHC.Types.[]_closure+1;
      Sp = Sp + 8;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:53.01164 UTC

{offset
  cknc:
      _sjWw::P64 = R2;
      if ((Sp + -24) < SpLim) goto cknd; else goto ckne;
  ckne:
      if (HpLim == 0) goto cknd; else goto cknf;
  cknd:
      R2 = _sjWw::P64;
      R1 = Main.initGens2_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  cknf:
      I64[Sp - 8] = ckn5;
      R1 = _sjWw::P64;
      Sp = Sp - 8;
      if (R1 & 7 != 0) goto ckn5; else goto ckn6;
  ckn6:
      call (I64[R1])(R1) returns to ckn5, args: 8, res: 8, upd: 8;
  ckn5:
      if (R1 & 7 != 1) goto ckna; else goto ckn9;
  ckna:
      I64[Sp - 8] = cknl;
      R3 = P64[R1 + 6];
      R2 = Control.Monad.Primitive.$fPrimMonadIO_closure;
      I64[Sp - 16] = stg_ap_v_info;
      P64[Sp] = P64[R1 + 14];
      Sp = Sp - 16;
      call System.Random.PCG.Fast.Pure.initialize_info(R3,
                                                       R2) returns to cknl, args: 16, res: 8, upd: 8;
  cknl:
      I64[Sp] = cknn;
      R2 = P64[Sp + 8];
      P64[Sp + 8] = R1;
      call Main.initGens2_info(R2) returns to cknn, args: 8, res: 8, upd: 8;
  cknn:
      Hp = Hp + 24;
      if (Hp > HpLim) goto cknu; else goto cknt;
  cknu:
      HpAlloc = 24;
      R1 = R1;
      call stg_gc_unpt_r1(R1) returns to cknn, args: 8, res: 8, upd: 8;
  cknt:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = P64[Sp + 8];
      P64[Hp] = R1;
      R1 = Hp - 14;
      Sp = Sp + 16;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
  ckn9:
      R1 = GHC.Types.[]_closure+1;
      Sp = Sp + 8;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:53.014445 UTC

[(ckn5,
  {Control.Monad.Primitive.$fPrimMonadIO_closure,
   Main.initGens2_closure}),
 (ckn6,
  {Control.Monad.Primitive.$fPrimMonadIO_closure,
   Main.initGens2_closure}),
 (ckn9, {}),
 (ckna,
  {Control.Monad.Primitive.$fPrimMonadIO_closure,
   Main.initGens2_closure}),
 (cknc,
  {Control.Monad.Primitive.$fPrimMonadIO_closure,
   Main.initGens2_closure}),
 (cknd, {Main.initGens2_closure}),
 (ckne,
  {Control.Monad.Primitive.$fPrimMonadIO_closure,
   Main.initGens2_closure}),
 (cknf,
  {Control.Monad.Primitive.$fPrimMonadIO_closure,
   Main.initGens2_closure}),
 (cknl, {Main.initGens2_closure}), (cknn, {}), (cknt, {}),
 (cknu, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:53.015532 UTC

Main.initGens2_entry() //  [R2]
        { info_tbl: [(ckn5,
                      label: block_ckn5_info
                      rep:StackRep []),
                     (cknc,
                      label: Main.initGens2_info
                      rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} }),
                     (cknl,
                      label: block_cknl_info
                      rep:StackRep [False]),
                     (cknn,
                      label: block_cknn_info
                      rep:StackRep [False])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cknc:
          _sjWw::P64 = R2;
          if ((Sp + -24) < SpLim) goto cknd; else goto ckne;
      ckne:
          if (HpLim == 0) goto cknd; else goto cknf;
      cknd:
          R2 = _sjWw::P64;
          R1 = Main.initGens2_closure;
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
      cknf:
          I64[Sp - 8] = ckn5;
          R1 = _sjWw::P64;
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto ckn5; else goto ckn6;
      ckn6:
          call (I64[R1])(R1) returns to ckn5, args: 8, res: 8, upd: 8;
      ckn5:
          if (R1 & 7 != 1) goto ckna; else goto ckn9;
      ckna:
          I64[Sp - 8] = cknl;
          R3 = P64[R1 + 6];
          R2 = Control.Monad.Primitive.$fPrimMonadIO_closure;
          I64[Sp - 16] = stg_ap_v_info;
          P64[Sp] = P64[R1 + 14];
          Sp = Sp - 16;
          call System.Random.PCG.Fast.Pure.initialize_info(R3,
                                                           R2) returns to cknl, args: 16, res: 8, upd: 8;
      cknl:
          I64[Sp] = cknn;
          R2 = P64[Sp + 8];
          P64[Sp + 8] = R1;
          call Main.initGens2_info(R2) returns to cknn, args: 8, res: 8, upd: 8;
      cknn:
          Hp = Hp + 24;
          if (Hp > HpLim) goto cknu; else goto cknt;
      cknu:
          HpAlloc = 24;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to cknn, args: 8, res: 8, upd: 8;
      cknt:
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = P64[Sp + 8];
          P64[Hp] = R1;
          R1 = Hp - 14;
          Sp = Sp + 16;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
      ckn9:
          R1 = GHC.Types.[]_closure+1;
          Sp = Sp + 8;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:53.018637 UTC

Main.initGens2_entry() //  [R2]
        { info_tbl: [(ckn5,
                      label: block_ckn5_info
                      rep:StackRep []),
                     (cknc,
                      label: Main.initGens2_info
                      rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} }),
                     (cknl,
                      label: block_cknl_info
                      rep:StackRep [False]),
                     (cknn,
                      label: block_cknn_info
                      rep:StackRep [False])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cknc:
          _sjWw::P64 = R2;
          if ((Sp + -24) < SpLim) goto cknd; else goto ckne;
      ckne:
          if (HpLim == 0) goto cknd; else goto cknf;
      cknd:
          R2 = _sjWw::P64;
          R1 = Main.initGens2_closure;
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
      cknf:
          I64[Sp - 8] = ckn5;
          R1 = _sjWw::P64;
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto ckn5; else goto ckn6;
      ckn6:
          call (I64[R1])(R1) returns to ckn5, args: 8, res: 8, upd: 8;
      ckn5:
          if (R1 & 7 != 1) goto ckna; else goto ckn9;
      ckna:
          I64[Sp - 8] = cknl;
          R3 = P64[R1 + 6];
          R2 = Control.Monad.Primitive.$fPrimMonadIO_closure;
          I64[Sp - 16] = stg_ap_v_info;
          P64[Sp] = P64[R1 + 14];
          Sp = Sp - 16;
          call System.Random.PCG.Fast.Pure.initialize_info(R3,
                                                           R2) returns to cknl, args: 16, res: 8, upd: 8;
      cknl:
          I64[Sp] = cknn;
          R2 = P64[Sp + 8];
          P64[Sp + 8] = R1;
          call Main.initGens2_info(R2) returns to cknn, args: 8, res: 8, upd: 8;
      cknn:
          Hp = Hp + 24;
          if (Hp > HpLim) goto cknu; else goto cknt;
      cknu:
          HpAlloc = 24;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to cknn, args: 8, res: 8, upd: 8;
      cknt:
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = P64[Sp + 8];
          P64[Hp] = R1;
          R1 = Hp - 14;
          Sp = Sp + 16;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
      ckn9:
          R1 = GHC.Types.[]_closure+1;
          Sp = Sp + 8;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:53.021702 UTC

[section "data" {
     Main.initGens2_closure:
         const Main.initGens2_info;
         const 0;
 },
 Main.initGens2_entry() //  [R2]
         { info_tbl: [(ckn5,
                       label: block_ckn5_info
                       rep:StackRep []),
                      (cknc,
                       label: Main.initGens2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} }),
                      (cknl,
                       label: block_cknl_info
                       rep:StackRep [False]),
                      (cknn,
                       label: block_cknn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cknc:
           _sjWw::P64 = R2;
           if ((Sp + -24) < SpLim) goto cknd; else goto ckne;
       ckne:
           if (HpLim == 0) goto cknd; else goto cknf;
       cknd:
           R2 = _sjWw::P64;
           R1 = Main.initGens2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cknf:
           I64[Sp - 8] = ckn5;
           R1 = _sjWw::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ckn5; else goto ckn6;
       ckn6:
           call (I64[R1])(R1) returns to ckn5, args: 8, res: 8, upd: 8;
       ckn5:
           if (R1 & 7 != 1) goto ckna; else goto ckn9;
       ckna:
           I64[Sp - 8] = cknl;
           R3 = P64[R1 + 6];
           R2 = Control.Monad.Primitive.$fPrimMonadIO_closure;
           I64[Sp - 16] = stg_ap_v_info;
           P64[Sp] = P64[R1 + 14];
           Sp = Sp - 16;
           call System.Random.PCG.Fast.Pure.initialize_info(R3,
                                                            R2) returns to cknl, args: 16, res: 8, upd: 8;
       cknl:
           I64[Sp] = cknn;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call Main.initGens2_info(R2) returns to cknn, args: 8, res: 8, upd: 8;
       cknn:
           Hp = Hp + 24;
           if (Hp > HpLim) goto cknu; else goto cknt;
       cknu:
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to cknn, args: 8, res: 8, upd: 8;
       cknt:
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
       ckn9:
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 8;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:53.025135 UTC

[section "data" {
     Main.initGens2_closure:
         const Main.initGens2_info;
         const 0;
 },
 Main.initGens2_entry() //  [R2]
         { info_tbl: [(ckn5,
                       label: block_ckn5_info
                       rep:StackRep []),
                      (cknc,
                       label: Main.initGens2_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} }),
                      (cknl,
                       label: block_cknl_info
                       rep:StackRep [False]),
                      (cknn,
                       label: block_cknn_info
                       rep:StackRep [False])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cknc:
           _sjWw::P64 = R2;
           if ((Sp + -24) < SpLim) goto cknd; else goto ckne;
       ckne:
           if (HpLim == 0) goto cknd; else goto cknf;
       cknd:
           R2 = _sjWw::P64;
           R1 = Main.initGens2_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cknf:
           I64[Sp - 8] = ckn5;
           R1 = _sjWw::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ckn5; else goto ckn6;
       ckn6:
           call (I64[R1])(R1) returns to ckn5, args: 8, res: 8, upd: 8;
       ckn5:
           if (R1 & 7 != 1) goto ckna; else goto ckn9;
       ckna:
           I64[Sp - 8] = cknl;
           R3 = P64[R1 + 6];
           R2 = Control.Monad.Primitive.$fPrimMonadIO_closure;
           I64[Sp - 16] = stg_ap_v_info;
           P64[Sp] = P64[R1 + 14];
           Sp = Sp - 16;
           call System.Random.PCG.Fast.Pure.initialize_info(R3,
                                                            R2) returns to cknl, args: 16, res: 8, upd: 8;
       cknl:
           I64[Sp] = cknn;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = R1;
           call Main.initGens2_info(R2) returns to cknn, args: 8, res: 8, upd: 8;
       cknn:
           Hp = Hp + 24;
           if (Hp > HpLim) goto cknu; else goto cknt;
       cknu:
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to cknn, args: 8, res: 8, upd: 8;
       cknt:
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
       ckn9:
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 8;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:53.034307 UTC

[section "data" {
     Main.initGens1_closure:
         const Main.initGens1_info;
         const 0;
 },
 sat_sjWV_entry() //  [R1]
         { info_tbl: [(ckox,
                       label: sat_sjWV_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckox:
           _sjWV::P64 = R1;
           goto ckot;
       ckot:
           if ((old + 0) - <highSp> < SpLim) goto ckoy; else goto ckoz;
       ckoz:
           if (HpLim == 0) goto ckoy; else goto ckoF;
       ckoy:
           R1 = _sjWV::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckoF:
           I64[(old + 24)] = stg_upd_frame_info;
           P64[(old + 16)] = _sjWV::P64;
           _sjWO::P64 = P64[_sjWV::P64 + 16];
           _sjWL::I64 = I64[_sjWV::P64 + 24];
           _sjWP::I64 = I64[_sjWV::P64 + 32];
           _ckov::I64 = _sjWP::I64 == _sjWL::I64;
           _sjWS::I64 = _ckov::I64;
           switch [0 .. 1] _sjWS::I64 {
               case 0 : goto ckoD;
               case 1 : goto ckoE;
           }
       ckoE:
           R1 = []_closure+1;
           call (P64[(old + 24)])(R1) args: 24, res: 0, upd: 24;
       ckoD:
           _ckoH::I64 = _sjWP::I64 + 1;
           _sjWU::I64 = _ckoH::I64;
           R2 = _sjWU::I64;
           R1 = _sjWO::P64;
           call go_sjWO_info(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 go_sjWO_entry() //  [R2, R1]
         { info_tbl: [(ckoK,
                       label: go_sjWO_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckoK:
           _sjWP::I64 = R2;
           _sjWO::P64 = R1;
           goto ckop;
       ckop:
           if ((old + 0) - <highSp> < SpLim) goto ckoO; else goto ckoP;
       ckoP:
           goto ckoo;
       ckoo:
           Hp = Hp + 80;
           if (Hp > HpLim) goto ckoR; else goto ckoQ;
       ckoR:
           HpAlloc = 80;
           goto ckoO;
       ckoO:
           R2 = _sjWP::I64;
           R1 = _sjWO::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckoQ:
           _sjWL::I64 = I64[_sjWO::P64 + 7];
           I64[Hp - 72] = sat_sjWV_info;
           P64[Hp - 56] = _sjWO::P64;
           I64[Hp - 48] = _sjWL::I64;
           I64[Hp - 40] = _sjWP::I64;
           _ckor::P64 = Hp - 72;
           _ckoI::I64 = _sjWP::I64;
           _sjWQ::I64 = _ckoI::I64;
           I64[Hp - 32] = GHC.Word.W64#_con_info;
           I64[Hp - 24] = _sjWQ::I64;
           _ckoM::P64 = Hp - 31;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _ckoM::P64;
           P64[Hp] = _ckor::P64;
           _ckoN::P64 = Hp - 14;
           R1 = _ckoN::P64;
           call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Main.initGens1_entry() //  [R2]
         { info_tbl: [(ckoS,
                       label: Main.initGens1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckoS:
           _sjWI::P64 = R2;
           goto ckoa;
       ckoa:
           if ((old + 0) - <highSp> < SpLim) goto ckoT; else goto ckoU;
       ckoU:
           goto cko9;
       cko9:
           if (HpLim == 0) goto ckoT; else goto ckoV;
       ckoT:
           R2 = _sjWI::P64;
           R1 = Main.initGens1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckoV:
           I64[(young<ckoc> + 8)] = ckoc;
           R1 = _sjWI::P64;
           if (R1 & 7 != 0) goto ckoc; else goto ckod;
       ckod:
           call (I64[R1])(R1) returns to ckoc, args: 8, res: 8, upd: 8;
       ckoc:
           _sjWK::P64 = R1;
           Hp = Hp + 16;
           if (Hp > HpLim) goto ckoY; else goto ckoX;
       ckoY:
           HpAlloc = 16;
           goto ckoW;
       ckoW:
           R1 = _sjWK::P64;
           call stg_gc_unpt_r1(R1) returns to ckoc, args: 8, res: 8, upd: 8;
       ckoX:
           _sjWL::I64 = I64[_sjWK::P64 + 7];
           _ckoh::I64 = %MO_S_Gt_W64(1, _sjWL::I64);
           _sjWM::I64 = _ckoh::I64;
           switch [0 .. 1] _sjWM::I64 {
               case 0 : goto ckp1;
               case 1 : goto ckp6;
           }
       ckp6:
           Hp = Hp - 16;
           R1 = GHC.Types.[]_closure+1;
           call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
       ckp1:
           _ckom::P64 = Hp - 7;
           I64[Hp - 8] = go_sjWO_info;
           I64[Hp] = _sjWL::I64;
           I64[(young<ckoZ> + 8)] = ckoZ;
           R2 = 1;
           R1 = _ckom::P64;
           call go_sjWO_info(R2, R1) returns to ckoZ, args: 8, res: 8, upd: 8;
       ckoZ:
           _sjWW::P64 = R1;
           R2 = _sjWW::P64;
           call Main.initGens2_info(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:53.043195 UTC

{offset
  ckox:
      _sjWV::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckoy; else goto ckoz;
  ckoz:
      if (HpLim == 0) goto ckoy; else goto ckoF;
  ckoy:
      R1 = _sjWV::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckoF:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sjWV::P64;
      _sjWO::P64 = P64[_sjWV::P64 + 16];
      _sjWL::I64 = I64[_sjWV::P64 + 24];
      _sjWP::I64 = I64[_sjWV::P64 + 32];
      _ckov::I64 = _sjWP::I64 == _sjWL::I64;
      _sjWS::I64 = _ckov::I64;
      switch [0 .. 1] _sjWS::I64 {
          case 0 : goto ckoD;
          case 1 : goto ckoE;
      }
  ckoE:
      R1 = []_closure+1;
      call (P64[(old + 24)])(R1) args: 24, res: 0, upd: 24;
  ckoD:
      _ckoH::I64 = _sjWP::I64 + 1;
      _sjWU::I64 = _ckoH::I64;
      R2 = _sjWU::I64;
      R1 = _sjWO::P64;
      call go_sjWO_info(R2, R1) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:53.044748 UTC

{offset
  ckox:
      _sjWV::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckoy; else goto ckoz;
  ckoz:
      if (HpLim == 0) goto ckoy; else goto ckoF;
  ckoy:
      R1 = _sjWV::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckoF:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sjWV::P64;
      _sjWO::P64 = P64[_sjWV::P64 + 16];
      _sjWL::I64 = I64[_sjWV::P64 + 24];
      _sjWP::I64 = I64[_sjWV::P64 + 32];
      _ckov::I64 = _sjWP::I64 == _sjWL::I64;
      _sjWS::I64 = _ckov::I64;
      switch [0 .. 1] _sjWS::I64 {
          case 0 : goto ckoD;
          case 1 : goto ckoE;
      }
  ckoE:
      R1 = []_closure+1;
      call (P64[(old + 24)])(R1) args: 24, res: 0, upd: 24;
  ckoD:
      _ckoH::I64 = _sjWP::I64 + 1;
      _sjWU::I64 = _ckoH::I64;
      R2 = _sjWU::I64;
      R1 = _sjWO::P64;
      call go_sjWO_info(R2, R1) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:53.04628 UTC

{offset
  ckox:
      _sjWV::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckoy; else goto ckoz;
  ckoz:
      if (HpLim == 0) goto ckoy; else goto ckoF;
  ckoy:
      R1 = _sjWV::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckoF:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sjWV::P64;
      _sjWO::P64 = P64[_sjWV::P64 + 16];
      _sjWL::I64 = I64[_sjWV::P64 + 24];
      _sjWP::I64 = I64[_sjWV::P64 + 32];
      _ckov::I64 = _sjWP::I64 == _sjWL::I64;
      _sjWS::I64 = _ckov::I64;
      if (_sjWS::I64 != 0) goto ckoE; else goto ckoD;
  ckoE:
      R1 = []_closure+1;
      call (P64[(old + 24)])(R1) args: 24, res: 0, upd: 24;
  ckoD:
      _ckoH::I64 = _sjWP::I64 + 1;
      _sjWU::I64 = _ckoH::I64;
      R2 = _sjWU::I64;
      R1 = _sjWO::P64;
      call go_sjWO_info(R2, R1) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:53.047804 UTC

{offset
  ckox:
      _sjWV::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto ckoy; else goto ckoz;
  ckoz:
      if (HpLim == 0) goto ckoy; else goto ckoF;
  ckoy:
      R1 = _sjWV::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckoF:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _sjWV::P64;
      _sjWO::P64 = P64[_sjWV::P64 + 16];
      _sjWL::I64 = I64[_sjWV::P64 + 24];
      _sjWP::I64 = I64[_sjWV::P64 + 32];
      _ckov::I64 = _sjWP::I64 == _sjWL::I64;
      _sjWS::I64 = _ckov::I64;
      if (_sjWS::I64 != 0) goto ckoE; else goto ckoD;
  ckoE:
      R1 = []_closure+1;
      Sp = Sp - 16;
      call (P64[Sp])(R1) args: 24, res: 0, upd: 24;
  ckoD:
      _ckoH::I64 = _sjWP::I64 + 1;
      _sjWU::I64 = _ckoH::I64;
      R2 = _sjWU::I64;
      R1 = _sjWO::P64;
      Sp = Sp - 16;
      call go_sjWO_info(R2, R1) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:53.049336 UTC

{offset
  ckox:
      _sjWV::P64 = R1;
      if ((Sp + -16) < SpLim) goto ckoy; else goto ckoz;
  ckoz:
      if (HpLim == 0) goto ckoy; else goto ckoF;
  ckoy:
      R1 = _sjWV::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckoF:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _sjWV::P64;
      _sjWP::I64 = I64[_sjWV::P64 + 32];
      if (_sjWP::I64 == I64[_sjWV::P64 + 24]) goto ckoE; else goto ckoD;
  ckoE:
      R1 = []_closure+1;
      Sp = Sp - 16;
      call (P64[Sp])(R1) args: 24, res: 0, upd: 24;
  ckoD:
      R2 = _sjWP::I64 + 1;
      R1 = P64[_sjWV::P64 + 16];
      Sp = Sp - 16;
      call go_sjWO_info(R2, R1) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:53.051606 UTC

[(ckox, {go_sjWO_closure}), (ckoy, {}), (ckoz, {go_sjWO_closure}),
 (ckoD, {go_sjWO_closure}), (ckoE, {}), (ckoF, {go_sjWO_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:53.052112 UTC

sat_sjWV_entry() //  [R1]
        { info_tbl: [(ckox,
                      label: sat_sjWV_info
                      rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckox:
          _sjWV::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckoy; else goto ckoz;
      ckoz:
          if (HpLim == 0) goto ckoy; else goto ckoF;
      ckoy:
          R1 = _sjWV::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckoF:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _sjWV::P64;
          _sjWP::I64 = I64[_sjWV::P64 + 32];
          if (_sjWP::I64 == I64[_sjWV::P64 + 24]) goto ckoE; else goto ckoD;
      ckoE:
          R1 = []_closure+1;
          Sp = Sp - 16;
          call (P64[Sp])(R1) args: 24, res: 0, upd: 24;
      ckoD:
          R2 = _sjWP::I64 + 1;
          R1 = P64[_sjWV::P64 + 16];
          Sp = Sp - 16;
          call go_sjWO_info(R2, R1) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:53.053617 UTC

sat_sjWV_entry() //  [R1]
        { info_tbl: [(ckox,
                      label: sat_sjWV_info
                      rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckox:
          _sjWV::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckoy; else goto ckoz;
      ckoz:
          if (HpLim == 0) goto ckoy; else goto ckoF;
      ckoy:
          R1 = _sjWV::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckoF:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _sjWV::P64;
          _sjWP::I64 = I64[_sjWV::P64 + 32];
          if (_sjWP::I64 == I64[_sjWV::P64 + 24]) goto ckoE; else goto ckoD;
      ckoE:
          R1 = []_closure+1;
          Sp = Sp - 16;
          call (P64[Sp])(R1) args: 24, res: 0, upd: 24;
      ckoD:
          R2 = _sjWP::I64 + 1;
          R1 = P64[_sjWV::P64 + 16];
          Sp = Sp - 16;
          call go_sjWO_info(R2, R1) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:53.05512 UTC

{offset
  ckoK:
      _sjWP::I64 = R2;
      _sjWO::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckoO; else goto ckoP;
  ckoP:
      Hp = Hp + 80;
      if (Hp > HpLim) goto ckoR; else goto ckoQ;
  ckoR:
      HpAlloc = 80;
      goto ckoO;
  ckoO:
      R2 = _sjWP::I64;
      R1 = _sjWO::P64;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckoQ:
      _sjWL::I64 = I64[_sjWO::P64 + 7];
      I64[Hp - 72] = sat_sjWV_info;
      P64[Hp - 56] = _sjWO::P64;
      I64[Hp - 48] = _sjWL::I64;
      I64[Hp - 40] = _sjWP::I64;
      _ckor::P64 = Hp - 72;
      _ckoI::I64 = _sjWP::I64;
      _sjWQ::I64 = _ckoI::I64;
      I64[Hp - 32] = GHC.Word.W64#_con_info;
      I64[Hp - 24] = _sjWQ::I64;
      _ckoM::P64 = Hp - 31;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _ckoM::P64;
      P64[Hp] = _ckor::P64;
      _ckoN::P64 = Hp - 14;
      R1 = _ckoN::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:53.056717 UTC

{offset
  ckoK:
      _sjWP::I64 = R2;
      _sjWO::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckoO; else goto ckoP;
  ckoP:
      Hp = Hp + 80;
      if (Hp > HpLim) goto ckoR; else goto ckoQ;
  ckoR:
      HpAlloc = 80;
      goto ckoO;
  ckoO:
      R2 = _sjWP::I64;
      R1 = _sjWO::P64;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckoQ:
      _sjWL::I64 = I64[_sjWO::P64 + 7];
      I64[Hp - 72] = sat_sjWV_info;
      P64[Hp - 56] = _sjWO::P64;
      I64[Hp - 48] = _sjWL::I64;
      I64[Hp - 40] = _sjWP::I64;
      _ckor::P64 = Hp - 72;
      _ckoI::I64 = _sjWP::I64;
      _sjWQ::I64 = _ckoI::I64;
      I64[Hp - 32] = GHC.Word.W64#_con_info;
      I64[Hp - 24] = _sjWQ::I64;
      _ckoM::P64 = Hp - 31;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _ckoM::P64;
      P64[Hp] = _ckor::P64;
      _ckoN::P64 = Hp - 14;
      R1 = _ckoN::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:53.058351 UTC

{offset
  ckoK:
      _sjWP::I64 = R2;
      _sjWO::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckoO; else goto ckoP;
  ckoP:
      Hp = Hp + 80;
      if (Hp > HpLim) goto ckoR; else goto ckoQ;
  ckoR:
      HpAlloc = 80;
      goto ckoO;
  ckoO:
      R2 = _sjWP::I64;
      R1 = _sjWO::P64;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckoQ:
      _sjWL::I64 = I64[_sjWO::P64 + 7];
      I64[Hp - 72] = sat_sjWV_info;
      P64[Hp - 56] = _sjWO::P64;
      I64[Hp - 48] = _sjWL::I64;
      I64[Hp - 40] = _sjWP::I64;
      _ckor::P64 = Hp - 72;
      _ckoI::I64 = _sjWP::I64;
      _sjWQ::I64 = _ckoI::I64;
      I64[Hp - 32] = GHC.Word.W64#_con_info;
      I64[Hp - 24] = _sjWQ::I64;
      _ckoM::P64 = Hp - 31;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _ckoM::P64;
      P64[Hp] = _ckor::P64;
      _ckoN::P64 = Hp - 14;
      R1 = _ckoN::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:53.060097 UTC

{offset
  ckoK:
      _sjWP::I64 = R2;
      _sjWO::P64 = R1;
      goto ckoP;
  ckoP:
      Hp = Hp + 80;
      if (Hp > HpLim) goto ckoR; else goto ckoQ;
  ckoR:
      HpAlloc = 80;
      goto ckoO;
  ckoO:
      R2 = _sjWP::I64;
      R1 = _sjWO::P64;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckoQ:
      _sjWL::I64 = I64[_sjWO::P64 + 7];
      I64[Hp - 72] = sat_sjWV_info;
      P64[Hp - 56] = _sjWO::P64;
      I64[Hp - 48] = _sjWL::I64;
      I64[Hp - 40] = _sjWP::I64;
      _ckor::P64 = Hp - 72;
      _ckoI::I64 = _sjWP::I64;
      _sjWQ::I64 = _ckoI::I64;
      I64[Hp - 32] = GHC.Word.W64#_con_info;
      I64[Hp - 24] = _sjWQ::I64;
      _ckoM::P64 = Hp - 31;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _ckoM::P64;
      P64[Hp] = _ckor::P64;
      _ckoN::P64 = Hp - 14;
      R1 = _ckoN::P64;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:53.061617 UTC

{offset
  ckoK:
      goto ckoP;
  ckoP:
      Hp = Hp + 80;
      if (Hp > HpLim) goto ckoR; else goto ckoQ;
  ckoR:
      HpAlloc = 80;
      goto ckoO;
  ckoO:
      R2 = R2;
      R1 = R1;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckoQ:
      _sjWL::I64 = I64[R1 + 7];
      I64[Hp - 72] = sat_sjWV_info;
      P64[Hp - 56] = R1;
      I64[Hp - 48] = _sjWL::I64;
      I64[Hp - 40] = R2;
      I64[Hp - 32] = GHC.Word.W64#_con_info;
      I64[Hp - 24] = R2;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = Hp - 31;
      P64[Hp] = Hp - 72;
      R1 = Hp - 14;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:53.063124 UTC

[(ckoK, {sat_sjWV_closure}), (ckoO, {}),
 (ckoP, {sat_sjWV_closure}), (ckoQ, {sat_sjWV_closure}), (ckoR, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:53.063558 UTC

go_sjWO_entry() //  [R2, R1]
        { info_tbl: [(ckoK,
                      label: go_sjWO_info
                      rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckoK:
          goto ckoP;
      ckoP:
          Hp = Hp + 80;
          if (Hp > HpLim) goto ckoR; else goto ckoQ;
      ckoR:
          HpAlloc = 80;
          goto ckoO;
      ckoO:
          R2 = R2;
          R1 = R1;
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
      ckoQ:
          _sjWL::I64 = I64[R1 + 7];
          I64[Hp - 72] = sat_sjWV_info;
          P64[Hp - 56] = R1;
          I64[Hp - 48] = _sjWL::I64;
          I64[Hp - 40] = R2;
          I64[Hp - 32] = GHC.Word.W64#_con_info;
          I64[Hp - 24] = R2;
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = Hp - 31;
          P64[Hp] = Hp - 72;
          R1 = Hp - 14;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:53.065052 UTC

go_sjWO_entry() //  [R2, R1]
        { info_tbl: [(ckoK,
                      label: go_sjWO_info
                      rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckoK:
          Hp = Hp + 80;
          if (Hp > HpLim) goto ckoR; else goto ckoQ;
      ckoR:
          HpAlloc = 80;
          R2 = R2;
          R1 = R1;
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
      ckoQ:
          _sjWL::I64 = I64[R1 + 7];
          I64[Hp - 72] = sat_sjWV_info;
          P64[Hp - 56] = R1;
          I64[Hp - 48] = _sjWL::I64;
          I64[Hp - 40] = R2;
          I64[Hp - 32] = GHC.Word.W64#_con_info;
          I64[Hp - 24] = R2;
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = Hp - 31;
          P64[Hp] = Hp - 72;
          R1 = Hp - 14;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:53.066485 UTC

{offset
  ckoS:
      _sjWI::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckoT; else goto ckoU;
  ckoU:
      if (HpLim == 0) goto ckoT; else goto ckoV;
  ckoT:
      R2 = _sjWI::P64;
      R1 = Main.initGens1_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckoV:
      I64[(young<ckoc> + 8)] = ckoc;
      R1 = _sjWI::P64;
      if (R1 & 7 != 0) goto ckoc; else goto ckod;
  ckod:
      call (I64[R1])(R1) returns to ckoc, args: 8, res: 8, upd: 8;
  ckoc:
      _sjWK::P64 = R1;
      Hp = Hp + 16;
      if (Hp > HpLim) goto ckoY; else goto ckoX;
  ckoY:
      HpAlloc = 16;
      R1 = _sjWK::P64;
      call stg_gc_unpt_r1(R1) returns to ckoc, args: 8, res: 8, upd: 8;
  ckoX:
      _sjWL::I64 = I64[_sjWK::P64 + 7];
      _ckoh::I64 = %MO_S_Gt_W64(1, _sjWL::I64);
      _sjWM::I64 = _ckoh::I64;
      switch [0 .. 1] _sjWM::I64 {
          case 0 : goto ckp1;
          case 1 : goto ckp6;
      }
  ckp6:
      Hp = Hp - 16;
      R1 = GHC.Types.[]_closure+1;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
  ckp1:
      _ckom::P64 = Hp - 7;
      I64[Hp - 8] = go_sjWO_info;
      I64[Hp] = _sjWL::I64;
      I64[(young<ckoZ> + 8)] = ckoZ;
      R2 = 1;
      R1 = _ckom::P64;
      call go_sjWO_info(R2, R1) returns to ckoZ, args: 8, res: 8, upd: 8;
  ckoZ:
      _sjWW::P64 = R1;
      R2 = _sjWW::P64;
      call Main.initGens2_info(R2) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:53.068723 UTC

{offset
  ckoS:
      _sjWI::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckoT; else goto ckoU;
  ckoU:
      if (HpLim == 0) goto ckoT; else goto ckoV;
  ckoT:
      R2 = _sjWI::P64;
      R1 = Main.initGens1_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckoV:
      I64[(young<ckoc> + 8)] = ckoc;
      R1 = _sjWI::P64;
      if (R1 & 7 != 0) goto ckoc; else goto ckod;
  ckod:
      call (I64[R1])(R1) returns to ckoc, args: 8, res: 8, upd: 8;
  ckoc:
      _sjWK::P64 = R1;
      Hp = Hp + 16;
      if (Hp > HpLim) goto ckoY; else goto ckoX;
  ckoY:
      HpAlloc = 16;
      R1 = _sjWK::P64;
      call stg_gc_unpt_r1(R1) returns to ckoc, args: 8, res: 8, upd: 8;
  ckoX:
      _sjWL::I64 = I64[_sjWK::P64 + 7];
      _ckoh::I64 = %MO_S_Gt_W64(1, _sjWL::I64);
      _sjWM::I64 = _ckoh::I64;
      switch [0 .. 1] _sjWM::I64 {
          case 0 : goto ckp1;
          case 1 : goto ckp6;
      }
  ckp6:
      Hp = Hp - 16;
      R1 = GHC.Types.[]_closure+1;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
  ckp1:
      _ckom::P64 = Hp - 7;
      I64[Hp - 8] = go_sjWO_info;
      I64[Hp] = _sjWL::I64;
      I64[(young<ckoZ> + 8)] = ckoZ;
      R2 = 1;
      R1 = _ckom::P64;
      call go_sjWO_info(R2, R1) returns to ckoZ, args: 8, res: 8, upd: 8;
  ckoZ:
      _sjWW::P64 = R1;
      R2 = _sjWW::P64;
      call Main.initGens2_info(R2) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:53.07095 UTC

{offset
  ckoS:
      _sjWI::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckoT; else goto ckoU;
  ckoU:
      if (HpLim == 0) goto ckoT; else goto ckoV;
  ckoT:
      R2 = _sjWI::P64;
      R1 = Main.initGens1_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckoV:
      I64[(young<ckoc> + 8)] = ckoc;
      R1 = _sjWI::P64;
      if (R1 & 7 != 0) goto ckoc; else goto ckod;
  ckod:
      call (I64[R1])(R1) returns to ckoc, args: 8, res: 8, upd: 8;
  ckoc:
      _sjWK::P64 = R1;
      Hp = Hp + 16;
      if (Hp > HpLim) goto ckoY; else goto ckoX;
  ckoY:
      HpAlloc = 16;
      R1 = _sjWK::P64;
      call stg_gc_unpt_r1(R1) returns to ckoc, args: 8, res: 8, upd: 8;
  ckoX:
      _sjWL::I64 = I64[_sjWK::P64 + 7];
      _ckoh::I64 = %MO_S_Gt_W64(1, _sjWL::I64);
      _sjWM::I64 = _ckoh::I64;
      if (_sjWM::I64 != 0) goto ckp6; else goto ckp1;
  ckp6:
      Hp = Hp - 16;
      R1 = GHC.Types.[]_closure+1;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
  ckp1:
      _ckom::P64 = Hp - 7;
      I64[Hp - 8] = go_sjWO_info;
      I64[Hp] = _sjWL::I64;
      I64[(young<ckoZ> + 8)] = ckoZ;
      R2 = 1;
      R1 = _ckom::P64;
      call go_sjWO_info(R2, R1) returns to ckoZ, args: 8, res: 8, upd: 8;
  ckoZ:
      _sjWW::P64 = R1;
      R2 = _sjWW::P64;
      call Main.initGens2_info(R2) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:53.073323 UTC

{offset
  ckoS:
      _sjWI::P64 = R2;
      if ((Sp + 8) - 16 < SpLim) goto ckoT; else goto ckoU;
  ckoU:
      if (HpLim == 0) goto ckoT; else goto ckoV;
  ckoT:
      R2 = _sjWI::P64;
      R1 = Main.initGens1_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckoV:
      I64[Sp - 8] = ckoc;
      R1 = _sjWI::P64;
      Sp = Sp - 8;
      if (R1 & 7 != 0) goto ckoc; else goto ckod;
  ckod:
      call (I64[R1])(R1) returns to ckoc, args: 8, res: 8, upd: 8;
  ckoc:
      _sjWK::P64 = R1;
      Hp = Hp + 16;
      if (Hp > HpLim) goto ckoY; else goto ckoX;
  ckoY:
      HpAlloc = 16;
      R1 = _sjWK::P64;
      call stg_gc_unpt_r1(R1) returns to ckoc, args: 8, res: 8, upd: 8;
  ckoX:
      _sjWL::I64 = I64[_sjWK::P64 + 7];
      _ckoh::I64 = %MO_S_Gt_W64(1, _sjWL::I64);
      _sjWM::I64 = _ckoh::I64;
      if (_sjWM::I64 != 0) goto ckp6; else goto ckp1;
  ckp6:
      Hp = Hp - 16;
      R1 = GHC.Types.[]_closure+1;
      Sp = Sp + 8;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
  ckp1:
      _ckom::P64 = Hp - 7;
      I64[Hp - 8] = go_sjWO_info;
      I64[Hp] = _sjWL::I64;
      I64[Sp] = ckoZ;
      R2 = 1;
      R1 = _ckom::P64;
      call go_sjWO_info(R2, R1) returns to ckoZ, args: 8, res: 8, upd: 8;
  ckoZ:
      _sjWW::P64 = R1;
      R2 = _sjWW::P64;
      Sp = Sp + 8;
      call Main.initGens2_info(R2) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:53.075544 UTC

{offset
  ckoS:
      _sjWI::P64 = R2;
      if ((Sp + -8) < SpLim) goto ckoT; else goto ckoU;
  ckoU:
      if (HpLim == 0) goto ckoT; else goto ckoV;
  ckoT:
      R2 = _sjWI::P64;
      R1 = Main.initGens1_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckoV:
      I64[Sp - 8] = ckoc;
      R1 = _sjWI::P64;
      Sp = Sp - 8;
      if (R1 & 7 != 0) goto ckoc; else goto ckod;
  ckod:
      call (I64[R1])(R1) returns to ckoc, args: 8, res: 8, upd: 8;
  ckoc:
      Hp = Hp + 16;
      if (Hp > HpLim) goto ckoY; else goto ckoX;
  ckoY:
      HpAlloc = 16;
      R1 = R1;
      call stg_gc_unpt_r1(R1) returns to ckoc, args: 8, res: 8, upd: 8;
  ckoX:
      _sjWL::I64 = I64[R1 + 7];
      if (%MO_S_Gt_W64(1, _sjWL::I64)) goto ckp6; else goto ckp1;
  ckp6:
      Hp = Hp - 16;
      R1 = GHC.Types.[]_closure+1;
      Sp = Sp + 8;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
  ckp1:
      I64[Hp - 8] = go_sjWO_info;
      I64[Hp] = _sjWL::I64;
      I64[Sp] = ckoZ;
      R2 = 1;
      R1 = Hp - 7;
      call go_sjWO_info(R2, R1) returns to ckoZ, args: 8, res: 8, upd: 8;
  ckoZ:
      R2 = R1;
      Sp = Sp + 8;
      call Main.initGens2_info(R2) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:53.077846 UTC

[(ckoc, {Main.initGens2_closure, go_sjWO_closure}),
 (ckod, {Main.initGens2_closure, go_sjWO_closure}),
 (ckoS,
  {Main.initGens2_closure, Main.initGens1_closure, go_sjWO_closure}),
 (ckoT, {Main.initGens1_closure}),
 (ckoU,
  {Main.initGens2_closure, Main.initGens1_closure, go_sjWO_closure}),
 (ckoV, {Main.initGens2_closure, go_sjWO_closure}),
 (ckoX, {Main.initGens2_closure, go_sjWO_closure}),
 (ckoY, {Main.initGens2_closure, go_sjWO_closure}),
 (ckoZ, {Main.initGens2_closure}),
 (ckp1, {Main.initGens2_closure, go_sjWO_closure}), (ckp6, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:53.078976 UTC

Main.initGens1_entry() //  [R2]
        { info_tbl: [(ckoc,
                      label: block_ckoc_info
                      rep:StackRep []),
                     (ckoS,
                      label: Main.initGens1_info
                      rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} }),
                     (ckoZ,
                      label: block_ckoZ_info
                      rep:StackRep [])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckoS:
          _sjWI::P64 = R2;
          if ((Sp + -8) < SpLim) goto ckoT; else goto ckoU;
      ckoU:
          if (HpLim == 0) goto ckoT; else goto ckoV;
      ckoT:
          R2 = _sjWI::P64;
          R1 = Main.initGens1_closure;
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
      ckoV:
          I64[Sp - 8] = ckoc;
          R1 = _sjWI::P64;
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto ckoc; else goto ckod;
      ckod:
          call (I64[R1])(R1) returns to ckoc, args: 8, res: 8, upd: 8;
      ckoc:
          Hp = Hp + 16;
          if (Hp > HpLim) goto ckoY; else goto ckoX;
      ckoY:
          HpAlloc = 16;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to ckoc, args: 8, res: 8, upd: 8;
      ckoX:
          _sjWL::I64 = I64[R1 + 7];
          if (%MO_S_Gt_W64(1, _sjWL::I64)) goto ckp6; else goto ckp1;
      ckp6:
          Hp = Hp - 16;
          R1 = GHC.Types.[]_closure+1;
          Sp = Sp + 8;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
      ckp1:
          I64[Hp - 8] = go_sjWO_info;
          I64[Hp] = _sjWL::I64;
          I64[Sp] = ckoZ;
          R2 = 1;
          R1 = Hp - 7;
          call go_sjWO_info(R2, R1) returns to ckoZ, args: 8, res: 8, upd: 8;
      ckoZ:
          R2 = R1;
          Sp = Sp + 8;
          call Main.initGens2_info(R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:53.081547 UTC

Main.initGens1_entry() //  [R2]
        { info_tbl: [(ckoc,
                      label: block_ckoc_info
                      rep:StackRep []),
                     (ckoS,
                      label: Main.initGens1_info
                      rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} }),
                     (ckoZ,
                      label: block_ckoZ_info
                      rep:StackRep [])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckoS:
          _sjWI::P64 = R2;
          if ((Sp + -8) < SpLim) goto ckoT; else goto ckoU;
      ckoU:
          if (HpLim == 0) goto ckoT; else goto ckoV;
      ckoT:
          R2 = _sjWI::P64;
          R1 = Main.initGens1_closure;
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
      ckoV:
          I64[Sp - 8] = ckoc;
          R1 = _sjWI::P64;
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto ckoc; else goto ckod;
      ckod:
          call (I64[R1])(R1) returns to ckoc, args: 8, res: 8, upd: 8;
      ckoc:
          Hp = Hp + 16;
          if (Hp > HpLim) goto ckoY; else goto ckoX;
      ckoY:
          HpAlloc = 16;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to ckoc, args: 8, res: 8, upd: 8;
      ckoX:
          _sjWL::I64 = I64[R1 + 7];
          if (%MO_S_Gt_W64(1, _sjWL::I64)) goto ckp6; else goto ckp1;
      ckp6:
          Hp = Hp - 16;
          R1 = GHC.Types.[]_closure+1;
          Sp = Sp + 8;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
      ckp1:
          I64[Hp - 8] = go_sjWO_info;
          I64[Hp] = _sjWL::I64;
          I64[Sp] = ckoZ;
          R2 = 1;
          R1 = Hp - 7;
          call go_sjWO_info(R2, R1) returns to ckoZ, args: 8, res: 8, upd: 8;
      ckoZ:
          R2 = R1;
          Sp = Sp + 8;
          call Main.initGens2_info(R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:53.084049 UTC

[section "data" {
     Main.initGens1_closure:
         const Main.initGens1_info;
         const 0;
 },
 sat_sjWV_entry() //  [R1]
         { info_tbl: [(ckox,
                       label: sat_sjWV_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckox:
           _sjWV::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckoy; else goto ckoz;
       ckoz:
           if (HpLim == 0) goto ckoy; else goto ckoF;
       ckoy:
           R1 = _sjWV::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckoF:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sjWV::P64;
           _sjWP::I64 = I64[_sjWV::P64 + 32];
           if (_sjWP::I64 == I64[_sjWV::P64 + 24]) goto ckoE; else goto ckoD;
       ckoE:
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (P64[Sp])(R1) args: 24, res: 0, upd: 24;
       ckoD:
           R2 = _sjWP::I64 + 1;
           R1 = P64[_sjWV::P64 + 16];
           Sp = Sp - 16;
           call go_sjWO_info(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 go_sjWO_entry() //  [R2, R1]
         { info_tbl: [(ckoK,
                       label: go_sjWO_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckoK:
           Hp = Hp + 80;
           if (Hp > HpLim) goto ckoR; else goto ckoQ;
       ckoR:
           HpAlloc = 80;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckoQ:
           _sjWL::I64 = I64[R1 + 7];
           I64[Hp - 72] = sat_sjWV_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = _sjWL::I64;
           I64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Word.W64#_con_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Main.initGens1_entry() //  [R2]
         { info_tbl: [(ckoc,
                       label: block_ckoc_info
                       rep:StackRep []),
                      (ckoS,
                       label: Main.initGens1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} }),
                      (ckoZ,
                       label: block_ckoZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckoS:
           _sjWI::P64 = R2;
           if ((Sp + -8) < SpLim) goto ckoT; else goto ckoU;
       ckoU:
           if (HpLim == 0) goto ckoT; else goto ckoV;
       ckoT:
           R2 = _sjWI::P64;
           R1 = Main.initGens1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckoV:
           I64[Sp - 8] = ckoc;
           R1 = _sjWI::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ckoc; else goto ckod;
       ckod:
           call (I64[R1])(R1) returns to ckoc, args: 8, res: 8, upd: 8;
       ckoc:
           Hp = Hp + 16;
           if (Hp > HpLim) goto ckoY; else goto ckoX;
       ckoY:
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to ckoc, args: 8, res: 8, upd: 8;
       ckoX:
           _sjWL::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(1, _sjWL::I64)) goto ckp6; else goto ckp1;
       ckp6:
           Hp = Hp - 16;
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 8;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
       ckp1:
           I64[Hp - 8] = go_sjWO_info;
           I64[Hp] = _sjWL::I64;
           I64[Sp] = ckoZ;
           R2 = 1;
           R1 = Hp - 7;
           call go_sjWO_info(R2, R1) returns to ckoZ, args: 8, res: 8, upd: 8;
       ckoZ:
           R2 = R1;
           Sp = Sp + 8;
           call Main.initGens2_info(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:53.089574 UTC

[section "data" {
     Main.initGens1_closure:
         const Main.initGens1_info;
         const 0;
 },
 sat_sjWV_entry() //  [R1]
         { info_tbl: [(ckox,
                       label: sat_sjWV_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckox:
           _sjWV::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckoy; else goto ckoz;
       ckoz:
           if (HpLim == 0) goto ckoy; else goto ckoF;
       ckoy:
           R1 = _sjWV::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckoF:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sjWV::P64;
           _sjWP::I64 = I64[_sjWV::P64 + 32];
           if (_sjWP::I64 == I64[_sjWV::P64 + 24]) goto ckoE; else goto ckoD;
       ckoE:
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (P64[Sp])(R1) args: 24, res: 0, upd: 24;
       ckoD:
           R2 = _sjWP::I64 + 1;
           R1 = P64[_sjWV::P64 + 16];
           Sp = Sp - 16;
           call go_sjWO_info(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 go_sjWO_entry() //  [R2, R1]
         { info_tbl: [(ckoK,
                       label: go_sjWO_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckoK:
           Hp = Hp + 80;
           if (Hp > HpLim) goto ckoR; else goto ckoQ;
       ckoR:
           HpAlloc = 80;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckoQ:
           _sjWL::I64 = I64[R1 + 7];
           I64[Hp - 72] = sat_sjWV_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = _sjWL::I64;
           I64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Word.W64#_con_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Main.initGens1_entry() //  [R2]
         { info_tbl: [(ckoc,
                       label: block_ckoc_info
                       rep:StackRep []),
                      (ckoS,
                       label: Main.initGens1_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} }),
                      (ckoZ,
                       label: block_ckoZ_info
                       rep:StackRep [])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckoS:
           _sjWI::P64 = R2;
           if ((Sp + -8) < SpLim) goto ckoT; else goto ckoU;
       ckoU:
           if (HpLim == 0) goto ckoT; else goto ckoV;
       ckoT:
           R2 = _sjWI::P64;
           R1 = Main.initGens1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckoV:
           I64[Sp - 8] = ckoc;
           R1 = _sjWI::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ckoc; else goto ckod;
       ckod:
           call (I64[R1])(R1) returns to ckoc, args: 8, res: 8, upd: 8;
       ckoc:
           Hp = Hp + 16;
           if (Hp > HpLim) goto ckoY; else goto ckoX;
       ckoY:
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to ckoc, args: 8, res: 8, upd: 8;
       ckoX:
           _sjWL::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(1, _sjWL::I64)) goto ckp6; else goto ckp1;
       ckp6:
           Hp = Hp - 16;
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 8;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
       ckp1:
           I64[Hp - 8] = go_sjWO_info;
           I64[Hp] = _sjWL::I64;
           I64[Sp] = ckoZ;
           R2 = 1;
           R1 = Hp - 7;
           call go_sjWO_info(R2, R1) returns to ckoZ, args: 8, res: 8, upd: 8;
       ckoZ:
           R2 = R1;
           Sp = Sp + 8;
           call Main.initGens2_info(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:53.103023 UTC

[section "data" {
     Main.initGens_closure:
         const Main.initGens_info;
         const 0;
 },
 Main.initGens_entry() //  [R2]
         { info_tbl: [(ckpn,
                       label: Main.initGens_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckpn:
           _B2::P64 = R2;
           goto ckpl;
       ckpl:
           if ((old + 0) - <highSp> < SpLim) goto ckpo; else goto ckpp;
       ckpp:
           goto ckpk;
       ckpk:
           if (HpLim == 0) goto ckpo; else goto ckpq;
       ckpo:
           R2 = _B2::P64;
           R1 = Main.initGens_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckpq:
           R2 = _B2::P64;
           call Main.initGens1_info(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:53.105192 UTC

{offset
  ckpn:
      _B2::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckpo; else goto ckpp;
  ckpp:
      if (HpLim == 0) goto ckpo; else goto ckpq;
  ckpo:
      R2 = _B2::P64;
      R1 = Main.initGens_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckpq:
      R2 = _B2::P64;
      call Main.initGens1_info(R2) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:53.105956 UTC

{offset
  ckpn:
      _B2::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckpo; else goto ckpp;
  ckpp:
      if (HpLim == 0) goto ckpo; else goto ckpq;
  ckpo:
      R2 = _B2::P64;
      R1 = Main.initGens_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckpq:
      R2 = _B2::P64;
      call Main.initGens1_info(R2) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:53.106703 UTC

{offset
  ckpn:
      _B2::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckpo; else goto ckpp;
  ckpp:
      if (HpLim == 0) goto ckpo; else goto ckpq;
  ckpo:
      R2 = _B2::P64;
      R1 = Main.initGens_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckpq:
      R2 = _B2::P64;
      call Main.initGens1_info(R2) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:53.107505 UTC

{offset
  ckpn:
      _B2::P64 = R2;
      goto ckpp;
  ckpp:
      if (HpLim == 0) goto ckpo; else goto ckpq;
  ckpo:
      R2 = _B2::P64;
      R1 = Main.initGens_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckpq:
      R2 = _B2::P64;
      call Main.initGens1_info(R2) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:53.108172 UTC

{offset
  ckpn:
      goto ckpp;
  ckpp:
      if (HpLim == 0) goto ckpo; else goto ckpq;
  ckpo:
      R2 = R2;
      R1 = Main.initGens_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckpq:
      R2 = R2;
      call Main.initGens1_info(R2) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:53.108923 UTC

[(ckpn, {Main.initGens1_closure, Main.initGens_closure}),
 (ckpo, {Main.initGens_closure}),
 (ckpp, {Main.initGens1_closure, Main.initGens_closure}),
 (ckpq, {Main.initGens1_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:53.109442 UTC

Main.initGens_entry() //  [R2]
        { info_tbl: [(ckpn,
                      label: Main.initGens_info
                      rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckpn:
          goto ckpp;
      ckpp:
          if (HpLim == 0) goto ckpo; else goto ckpq;
      ckpo:
          R2 = R2;
          R1 = Main.initGens_closure;
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
      ckpq:
          R2 = R2;
          call Main.initGens1_info(R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:53.110294 UTC

Main.initGens_entry() //  [R2]
        { info_tbl: [(ckpn,
                      label: Main.initGens_info
                      rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckpn:
          if (HpLim == 0) goto ckpo; else goto ckpq;
      ckpo:
          R2 = R2;
          R1 = Main.initGens_closure;
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
      ckpq:
          R2 = R2;
          call Main.initGens1_info(R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:53.111131 UTC

[section "data" {
     Main.initGens_closure:
         const Main.initGens_info;
         const 0;
 },
 Main.initGens_entry() //  [R2]
         { info_tbl: [(ckpn,
                       label: Main.initGens_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckpn:
           if (HpLim == 0) goto ckpo; else goto ckpq;
       ckpo:
           R2 = R2;
           R1 = Main.initGens_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckpq:
           R2 = R2;
           call Main.initGens1_info(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:53.112188 UTC

[section "data" {
     Main.initGens_closure:
         const Main.initGens_info;
         const 0;
 },
 Main.initGens_entry() //  [R2]
         { info_tbl: [(ckpn,
                       label: Main.initGens_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckpn:
           if (HpLim == 0) goto ckpo; else goto ckpq;
       ckpo:
           R2 = R2;
           R1 = Main.initGens_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckpq:
           R2 = R2;
           call Main.initGens1_info(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:53.114833 UTC

[section "data" {
     Main.mkRBTree_closure:
         const Main.mkRBTree_info;
         const 0;
 },
 Main.mkRBTree_entry() //  []
         { info_tbl: [(ckpz,
                       label: Main.mkRBTree_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckpz:
           goto ckpx;
       ckpx:
           if ((old + 0) - <highSp> < SpLim) goto ckpA; else goto ckpB;
       ckpB:
           goto ckpw;
       ckpw:
           if (HpLim == 0) goto ckpA; else goto ckpC;
       ckpA:
           R1 = Main.mkRBTree_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ckpC:
           call SkipList.newSL2_info() args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:53.116166 UTC

{offset
  ckpz:
      if ((old + 0) - <highSp> < SpLim) goto ckpA; else goto ckpB;
  ckpB:
      if (HpLim == 0) goto ckpA; else goto ckpC;
  ckpA:
      R1 = Main.mkRBTree_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  ckpC:
      call SkipList.newSL2_info() args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:53.116782 UTC

{offset
  ckpz:
      if ((old + 0) - <highSp> < SpLim) goto ckpA; else goto ckpB;
  ckpB:
      if (HpLim == 0) goto ckpA; else goto ckpC;
  ckpA:
      R1 = Main.mkRBTree_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  ckpC:
      call SkipList.newSL2_info() args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:53.117446 UTC

{offset
  ckpz:
      if ((old + 0) - <highSp> < SpLim) goto ckpA; else goto ckpB;
  ckpB:
      if (HpLim == 0) goto ckpA; else goto ckpC;
  ckpA:
      R1 = Main.mkRBTree_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  ckpC:
      call SkipList.newSL2_info() args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:53.11812 UTC

{offset
  ckpz:
      goto ckpB;
  ckpB:
      if (HpLim == 0) goto ckpA; else goto ckpC;
  ckpA:
      R1 = Main.mkRBTree_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  ckpC:
      call SkipList.newSL2_info() args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:53.118654 UTC

{offset
  ckpz:
      goto ckpB;
  ckpB:
      if (HpLim == 0) goto ckpA; else goto ckpC;
  ckpA:
      R1 = Main.mkRBTree_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  ckpC:
      call SkipList.newSL2_info() args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:53.119319 UTC

[(ckpz, {SkipList.newSL2_closure, Main.mkRBTree_closure}),
 (ckpA, {Main.mkRBTree_closure}),
 (ckpB, {SkipList.newSL2_closure, Main.mkRBTree_closure}),
 (ckpC, {SkipList.newSL2_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:53.119825 UTC

Main.mkRBTree_entry() //  []
        { info_tbl: [(ckpz,
                      label: Main.mkRBTree_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckpz:
          goto ckpB;
      ckpB:
          if (HpLim == 0) goto ckpA; else goto ckpC;
      ckpA:
          R1 = Main.mkRBTree_closure;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
      ckpC:
          call SkipList.newSL2_info() args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:53.12061 UTC

Main.mkRBTree_entry() //  []
        { info_tbl: [(ckpz,
                      label: Main.mkRBTree_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckpz:
          if (HpLim == 0) goto ckpA; else goto ckpC;
      ckpA:
          R1 = Main.mkRBTree_closure;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
      ckpC:
          call SkipList.newSL2_info() args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:53.121369 UTC

[section "data" {
     Main.mkRBTree_closure:
         const Main.mkRBTree_info;
         const 0;
 },
 Main.mkRBTree_entry() //  []
         { info_tbl: [(ckpz,
                       label: Main.mkRBTree_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckpz:
           if (HpLim == 0) goto ckpA; else goto ckpC;
       ckpA:
           R1 = Main.mkRBTree_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ckpC:
           call SkipList.newSL2_info() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:53.122313 UTC

[section "data" {
     Main.mkRBTree_closure:
         const Main.mkRBTree_info;
         const 0;
 },
 Main.mkRBTree_entry() //  []
         { info_tbl: [(ckpz,
                       label: Main.mkRBTree_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckpz:
           if (HpLim == 0) goto ckpA; else goto ckpC;
       ckpA:
           R1 = Main.mkRBTree_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ckpC:
           call SkipList.newSL2_info() args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:53.125143 UTC

[section "data" {
     Main.rbTreeOpts_closure:
         const Options.Applicative.Types.MultP_static_info;
         const Main.rbTreeOpts15_closure+3;
         const Main.rbTreeOpts1_closure+4;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:53.125604 UTC

[section "data" {
     Main.rbTreeOpts_closure:
         const Options.Applicative.Types.MultP_static_info;
         const Main.rbTreeOpts15_closure+3;
         const Main.rbTreeOpts1_closure+4;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:53.125988 UTC

[section "data" {
     Main.rbTreeOpts_closure:
         const Options.Applicative.Types.MultP_static_info;
         const Main.rbTreeOpts15_closure+3;
         const Main.rbTreeOpts1_closure+4;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:53.127115 UTC

[section "data" {
     $wgo_rjVb_closure:
         const $wgo_rjVb_info;
 },
 $wgo_rjVb_entry() //  [R2]
         { info_tbl: [(ckqs,
                       label: $wgo_rjVb_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckqs:
           _sjWX::I64 = R2;
           goto ckqo;
       ckqo:
           if ((old + 0) - <highSp> < SpLim) goto ckqt; else goto ckqu;
       ckqu:
           goto ckqn;
       ckqn:
           if (HpLim == 0) goto ckqt; else goto ckqV;
       ckqt:
           R2 = _sjWX::I64;
           R1 = $wgo_rjVb_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckqV:
           _ckqq::I64 = _sjWX::I64 >> 61;
           _sjX1::I64 = _ckqq::I64;
           _ckqw::I64 = _sjX1::I64;
           _sjX2::I64 = _ckqw::I64;
           _ckqz::I64 = _sjX2::I64 + 22;
           _sjX3::I64 = _ckqz::I64;
           _ckqC::I64 = _sjWX::I64 >> 22;
           _sjWZ::I64 = _ckqC::I64;
           _ckqF::I64 = _sjWZ::I64 ^ _sjWX::I64;
           _sjX0::I64 = _ckqF::I64;
           _ckqI::I64 = _sjX0::I64 >> _sjX3::I64;
           _sjX4::I64 = _ckqI::I64;
           _ckqL::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_sjX4::I64));
           _sjWY::I64 = _ckqL::I64;
           _ckqO::I64 = _sjWY::I64 >= 67296;
           _sjX5::I64 = _ckqO::I64;
           switch [0 .. 1] _sjX5::I64 {
               case 0 : goto ckqT;
               case 1 : goto ckqU;
           }
       ckqU:
           _ckqZ::I64 = _sjWY::I64 % 100000;
           _sjX9::I64 = _ckqZ::I64;
           _ckr2::I64 = _sjWX::I64 * 6364136223846793005;
           _sjX8::I64 = _ckr2::I64;
           R2 = _sjX9::I64;
           R1 = _sjX8::I64;
           call (P64[(old + 8)])(R2, R1) args: 8, res: 0, upd: 8;
       ckqT:
           _ckqX::I64 = _sjWX::I64 * 6364136223846793005;
           _sjX7::I64 = _ckqX::I64;
           _sjWX::I64 = _sjX7::I64;
           goto ckqn;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:53.131159 UTC

{offset
  ckqs:
      _sjWX::I64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckqt; else goto ckqn;
  ckqn:
      if (HpLim == 0) goto ckqt; else goto ckqV;
  ckqt:
      R2 = _sjWX::I64;
      R1 = $wgo_rjVb_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckqV:
      _ckqq::I64 = _sjWX::I64 >> 61;
      _sjX1::I64 = _ckqq::I64;
      _ckqw::I64 = _sjX1::I64;
      _sjX2::I64 = _ckqw::I64;
      _ckqz::I64 = _sjX2::I64 + 22;
      _sjX3::I64 = _ckqz::I64;
      _ckqC::I64 = _sjWX::I64 >> 22;
      _sjWZ::I64 = _ckqC::I64;
      _ckqF::I64 = _sjWZ::I64 ^ _sjWX::I64;
      _sjX0::I64 = _ckqF::I64;
      _ckqI::I64 = _sjX0::I64 >> _sjX3::I64;
      _sjX4::I64 = _ckqI::I64;
      _ckqL::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_sjX4::I64));
      _sjWY::I64 = _ckqL::I64;
      _ckqO::I64 = _sjWY::I64 >= 67296;
      _sjX5::I64 = _ckqO::I64;
      switch [0 .. 1] _sjX5::I64 {
          case 0 : goto ckqT;
          case 1 : goto ckqU;
      }
  ckqU:
      _ckqZ::I64 = _sjWY::I64 % 100000;
      _sjX9::I64 = _ckqZ::I64;
      _ckr2::I64 = _sjWX::I64 * 6364136223846793005;
      _sjX8::I64 = _ckr2::I64;
      R2 = _sjX9::I64;
      R1 = _sjX8::I64;
      call (P64[(old + 8)])(R2, R1) args: 8, res: 0, upd: 8;
  ckqT:
      _ckqX::I64 = _sjWX::I64 * 6364136223846793005;
      _sjX7::I64 = _ckqX::I64;
      _sjWX::I64 = _sjX7::I64;
      goto ckqn;
}


==================== Post common block elimination ====================
2015-11-09 18:21:53.133222 UTC

{offset
  ckqs:
      _sjWX::I64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckqt; else goto ckqn;
  ckqn:
      if (HpLim == 0) goto ckqt; else goto ckqV;
  ckqt:
      R2 = _sjWX::I64;
      R1 = $wgo_rjVb_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckqV:
      _ckqq::I64 = _sjWX::I64 >> 61;
      _sjX1::I64 = _ckqq::I64;
      _ckqw::I64 = _sjX1::I64;
      _sjX2::I64 = _ckqw::I64;
      _ckqz::I64 = _sjX2::I64 + 22;
      _sjX3::I64 = _ckqz::I64;
      _ckqC::I64 = _sjWX::I64 >> 22;
      _sjWZ::I64 = _ckqC::I64;
      _ckqF::I64 = _sjWZ::I64 ^ _sjWX::I64;
      _sjX0::I64 = _ckqF::I64;
      _ckqI::I64 = _sjX0::I64 >> _sjX3::I64;
      _sjX4::I64 = _ckqI::I64;
      _ckqL::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_sjX4::I64));
      _sjWY::I64 = _ckqL::I64;
      _ckqO::I64 = _sjWY::I64 >= 67296;
      _sjX5::I64 = _ckqO::I64;
      switch [0 .. 1] _sjX5::I64 {
          case 0 : goto ckqT;
          case 1 : goto ckqU;
      }
  ckqU:
      _ckqZ::I64 = _sjWY::I64 % 100000;
      _sjX9::I64 = _ckqZ::I64;
      _ckr2::I64 = _sjWX::I64 * 6364136223846793005;
      _sjX8::I64 = _ckr2::I64;
      R2 = _sjX9::I64;
      R1 = _sjX8::I64;
      call (P64[(old + 8)])(R2, R1) args: 8, res: 0, upd: 8;
  ckqT:
      _ckqX::I64 = _sjWX::I64 * 6364136223846793005;
      _sjX7::I64 = _ckqX::I64;
      _sjWX::I64 = _sjX7::I64;
      goto ckqn;
}


==================== Post switch plan ====================
2015-11-09 18:21:53.135345 UTC

{offset
  ckqs:
      _sjWX::I64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckqt; else goto ckqn;
  ckqn:
      if (HpLim == 0) goto ckqt; else goto ckqV;
  ckqt:
      R2 = _sjWX::I64;
      R1 = $wgo_rjVb_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckqV:
      _ckqq::I64 = _sjWX::I64 >> 61;
      _sjX1::I64 = _ckqq::I64;
      _ckqw::I64 = _sjX1::I64;
      _sjX2::I64 = _ckqw::I64;
      _ckqz::I64 = _sjX2::I64 + 22;
      _sjX3::I64 = _ckqz::I64;
      _ckqC::I64 = _sjWX::I64 >> 22;
      _sjWZ::I64 = _ckqC::I64;
      _ckqF::I64 = _sjWZ::I64 ^ _sjWX::I64;
      _sjX0::I64 = _ckqF::I64;
      _ckqI::I64 = _sjX0::I64 >> _sjX3::I64;
      _sjX4::I64 = _ckqI::I64;
      _ckqL::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_sjX4::I64));
      _sjWY::I64 = _ckqL::I64;
      _ckqO::I64 = _sjWY::I64 >= 67296;
      _sjX5::I64 = _ckqO::I64;
      if (_sjX5::I64 != 0) goto ckqU; else goto ckqT;
  ckqU:
      _ckqZ::I64 = _sjWY::I64 % 100000;
      _sjX9::I64 = _ckqZ::I64;
      _ckr2::I64 = _sjWX::I64 * 6364136223846793005;
      _sjX8::I64 = _ckr2::I64;
      R2 = _sjX9::I64;
      R1 = _sjX8::I64;
      call (P64[(old + 8)])(R2, R1) args: 8, res: 0, upd: 8;
  ckqT:
      _ckqX::I64 = _sjWX::I64 * 6364136223846793005;
      _sjX7::I64 = _ckqX::I64;
      _sjWX::I64 = _sjX7::I64;
      goto ckqn;
}


==================== Layout Stack ====================
2015-11-09 18:21:53.13742 UTC

{offset
  ckqs:
      _sjWX::I64 = R2;
      goto ckqn;
  ckqn:
      if (HpLim == 0) goto ckqt; else goto ckqV;
  ckqt:
      R2 = _sjWX::I64;
      R1 = $wgo_rjVb_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckqV:
      _ckqq::I64 = _sjWX::I64 >> 61;
      _sjX1::I64 = _ckqq::I64;
      _ckqw::I64 = _sjX1::I64;
      _sjX2::I64 = _ckqw::I64;
      _ckqz::I64 = _sjX2::I64 + 22;
      _sjX3::I64 = _ckqz::I64;
      _ckqC::I64 = _sjWX::I64 >> 22;
      _sjWZ::I64 = _ckqC::I64;
      _ckqF::I64 = _sjWZ::I64 ^ _sjWX::I64;
      _sjX0::I64 = _ckqF::I64;
      _ckqI::I64 = _sjX0::I64 >> _sjX3::I64;
      _sjX4::I64 = _ckqI::I64;
      _ckqL::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_sjX4::I64));
      _sjWY::I64 = _ckqL::I64;
      _ckqO::I64 = _sjWY::I64 >= 67296;
      _sjX5::I64 = _ckqO::I64;
      if (_sjX5::I64 != 0) goto ckqU; else goto ckqT;
  ckqU:
      _ckqZ::I64 = _sjWY::I64 % 100000;
      _sjX9::I64 = _ckqZ::I64;
      _ckr2::I64 = _sjWX::I64 * 6364136223846793005;
      _sjX8::I64 = _ckr2::I64;
      R2 = _sjX9::I64;
      R1 = _sjX8::I64;
      call (P64[Sp])(R2, R1) args: 8, res: 0, upd: 8;
  ckqT:
      _ckqX::I64 = _sjWX::I64 * 6364136223846793005;
      _sjX7::I64 = _ckqX::I64;
      _sjWX::I64 = _sjX7::I64;
      goto ckqn;
}


==================== Sink assignments ====================
2015-11-09 18:21:53.139449 UTC

{offset
  ckqs:
      _sjWX::I64 = R2;
      goto ckqn;
  ckqn:
      if (HpLim == 0) goto ckqt; else goto ckqV;
  ckqt:
      R2 = _sjWX::I64;
      R1 = $wgo_rjVb_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckqV:
      _sjWY::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32((_sjWX::I64 >> 22) ^ _sjWX::I64 >> (_sjWX::I64 >> 61) + 22));
      if (_sjWY::I64 >= 67296) goto ckqU; else goto ckqT;
  ckqU:
      R2 = _sjWY::I64 % 100000;
      R1 = _sjWX::I64 * 6364136223846793005;
      call (P64[Sp])(R2, R1) args: 8, res: 0, upd: 8;
  ckqT:
      _sjWX::I64 = _sjWX::I64 * 6364136223846793005;
      goto ckqn;
}


==================== CAFEnv ====================
2015-11-09 18:21:53.14095 UTC

[(ckqn, {}), (ckqs, {}), (ckqt, {}), (ckqT, {}), (ckqU, {}),
 (ckqV, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:53.141341 UTC

$wgo_rjVb_entry() //  [R2]
        { info_tbl: [(ckqs,
                      label: $wgo_rjVb_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckqs:
          _sjWX::I64 = R2;
          goto ckqn;
      ckqn:
          if (HpLim == 0) goto ckqt; else goto ckqV;
      ckqt:
          R2 = _sjWX::I64;
          R1 = $wgo_rjVb_closure;
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
      ckqV:
          _sjWY::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32((_sjWX::I64 >> 22) ^ _sjWX::I64 >> (_sjWX::I64 >> 61) + 22));
          if (_sjWY::I64 >= 67296) goto ckqU; else goto ckqT;
      ckqU:
          R2 = _sjWY::I64 % 100000;
          R1 = _sjWX::I64 * 6364136223846793005;
          call (P64[Sp])(R2, R1) args: 8, res: 0, upd: 8;
      ckqT:
          _sjWX::I64 = _sjWX::I64 * 6364136223846793005;
          goto ckqn;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:53.142702 UTC

$wgo_rjVb_entry() //  [R2]
        { info_tbl: [(ckqs,
                      label: $wgo_rjVb_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckqs:
          _sjWX::I64 = R2;
          goto ckqn;
      ckqn:
          if (HpLim == 0) goto ckqt; else goto ckqV;
      ckqt:
          R2 = _sjWX::I64;
          R1 = $wgo_rjVb_closure;
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
      ckqV:
          _sjWY::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32((_sjWX::I64 >> 22) ^ _sjWX::I64 >> (_sjWX::I64 >> 61) + 22));
          if (_sjWY::I64 >= 67296) goto ckqU; else goto ckqT;
      ckqU:
          R2 = _sjWY::I64 % 100000;
          R1 = _sjWX::I64 * 6364136223846793005;
          call (P64[Sp])(R2, R1) args: 8, res: 0, upd: 8;
      ckqT:
          _sjWX::I64 = _sjWX::I64 * 6364136223846793005;
          goto ckqn;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:53.144085 UTC

[section "data" {
     $wgo_rjVb_closure:
         const $wgo_rjVb_info;
 },
 $wgo_rjVb_entry() //  [R2]
         { info_tbl: [(ckqs,
                       label: $wgo_rjVb_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckqs:
           _sjWX::I64 = R2;
           goto ckqn;
       ckqn:
           if (HpLim == 0) goto ckqt; else goto ckqV;
       ckqt:
           R2 = _sjWX::I64;
           R1 = $wgo_rjVb_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckqV:
           _sjWY::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32((_sjWX::I64 >> 22) ^ _sjWX::I64 >> (_sjWX::I64 >> 61) + 22));
           if (_sjWY::I64 >= 67296) goto ckqU; else goto ckqT;
       ckqU:
           R2 = _sjWY::I64 % 100000;
           R1 = _sjWX::I64 * 6364136223846793005;
           call (P64[Sp])(R2, R1) args: 8, res: 0, upd: 8;
       ckqT:
           _sjWX::I64 = _sjWX::I64 * 6364136223846793005;
           goto ckqn;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:53.145612 UTC

[section "data" {
     $wgo_rjVb_closure:
         const $wgo_rjVb_info;
 },
 $wgo_rjVb_entry() //  [R2]
         { info_tbl: [(ckqs,
                       label: $wgo_rjVb_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckqs:
           _sjWX::I64 = R2;
           goto ckqn;
       ckqn:
           if (HpLim == 0) goto ckqt; else goto ckqV;
       ckqt:
           R2 = _sjWX::I64;
           R1 = $wgo_rjVb_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckqV:
           _sjWY::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32((_sjWX::I64 >> 22) ^ _sjWX::I64 >> (_sjWX::I64 >> 61) + 22));
           if (_sjWY::I64 >= 67296) goto ckqU; else goto ckqT;
       ckqU:
           R2 = _sjWY::I64 % 100000;
           R1 = _sjWX::I64 * 6364136223846793005;
           call (P64[Sp])(R2, R1) args: 8, res: 0, upd: 8;
       ckqT:
           _sjWX::I64 = _sjWX::I64 * 6364136223846793005;
           goto ckqn;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:53.150302 UTC

[section "data" {
     lvl12_rjVc_closure:
         const lvl12_rjVc_info;
 },
 lvl12_rjVc_entry() //  []
         { info_tbl: [(ckrj,
                       label: lvl12_rjVc_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckrj:
           goto ckrh;
       ckrh:
           if ((old + 0) - <highSp> < SpLim) goto ckrk; else goto ckrl;
       ckrl:
           goto ckrg;
       ckrg:
           if (HpLim == 0) goto ckrk; else goto ckrm;
       ckrk:
           R1 = lvl12_rjVc_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ckrm:
           R1 = GHC.Tuple.()_closure+1;
           call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:53.151723 UTC

{offset
  ckrj:
      if ((old + 0) - <highSp> < SpLim) goto ckrk; else goto ckrl;
  ckrl:
      if (HpLim == 0) goto ckrk; else goto ckrm;
  ckrk:
      R1 = lvl12_rjVc_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  ckrm:
      R1 = GHC.Tuple.()_closure+1;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:53.152408 UTC

{offset
  ckrj:
      if ((old + 0) - <highSp> < SpLim) goto ckrk; else goto ckrl;
  ckrl:
      if (HpLim == 0) goto ckrk; else goto ckrm;
  ckrk:
      R1 = lvl12_rjVc_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  ckrm:
      R1 = GHC.Tuple.()_closure+1;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:53.153095 UTC

{offset
  ckrj:
      if ((old + 0) - <highSp> < SpLim) goto ckrk; else goto ckrl;
  ckrl:
      if (HpLim == 0) goto ckrk; else goto ckrm;
  ckrk:
      R1 = lvl12_rjVc_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  ckrm:
      R1 = GHC.Tuple.()_closure+1;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:53.153824 UTC

{offset
  ckrj:
      goto ckrl;
  ckrl:
      if (HpLim == 0) goto ckrk; else goto ckrm;
  ckrk:
      R1 = lvl12_rjVc_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  ckrm:
      R1 = GHC.Tuple.()_closure+1;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:53.15441 UTC

{offset
  ckrj:
      goto ckrl;
  ckrl:
      if (HpLim == 0) goto ckrk; else goto ckrm;
  ckrk:
      R1 = lvl12_rjVc_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  ckrm:
      R1 = GHC.Tuple.()_closure+1;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:53.155016 UTC

[(ckrj, {}), (ckrk, {}), (ckrl, {}), (ckrm, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:53.155334 UTC

lvl12_rjVc_entry() //  []
        { info_tbl: [(ckrj,
                      label: lvl12_rjVc_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckrj:
          goto ckrl;
      ckrl:
          if (HpLim == 0) goto ckrk; else goto ckrm;
      ckrk:
          R1 = lvl12_rjVc_closure;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
      ckrm:
          R1 = GHC.Tuple.()_closure+1;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:53.156715 UTC

lvl12_rjVc_entry() //  []
        { info_tbl: [(ckrj,
                      label: lvl12_rjVc_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckrj:
          if (HpLim == 0) goto ckrk; else goto ckrm;
      ckrk:
          R1 = lvl12_rjVc_closure;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
      ckrm:
          R1 = GHC.Tuple.()_closure+1;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:53.157579 UTC

[section "data" {
     lvl12_rjVc_closure:
         const lvl12_rjVc_info;
 },
 lvl12_rjVc_entry() //  []
         { info_tbl: [(ckrj,
                       label: lvl12_rjVc_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckrj:
           if (HpLim == 0) goto ckrk; else goto ckrm;
       ckrk:
           R1 = lvl12_rjVc_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ckrm:
           R1 = GHC.Tuple.()_closure+1;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:53.158503 UTC

[section "data" {
     lvl12_rjVc_closure:
         const lvl12_rjVc_info;
 },
 lvl12_rjVc_entry() //  []
         { info_tbl: [(ckrj,
                       label: lvl12_rjVc_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckrj:
           if (HpLim == 0) goto ckrk; else goto ckrm;
       ckrk:
           R1 = lvl12_rjVc_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ckrm:
           R1 = GHC.Tuple.()_closure+1;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:53.162257 UTC

[section "data" {
     Main.$wa_closure:
         const Main.$wa_info;
         const 0;
 },
 Main.$wa_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 40 updfr_space: Just 8
         }
     {offset
       cksE:
           _rbST::P64 = R1;
           _sjXb::P64 = P64[(old + 40)];
           _sjXc::P64 = P64[(old + 32)];
           _sjXd::I64 = I64[(old + 24)];
           _sjXe::F64 = F64[(old + 16)];
           D1 = _sjXe::F64;
           R4 = _sjXd::I64;
           R3 = _sjXc::P64;
           R2 = _sjXb::P64;
           R1 = _rbST::P64;
           call Main.$wa_info(D1, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Main.$wa_entry() //  [D1, R4, R3, R2]
         { info_tbl: [(cksP,
                       label: Main.$wa_info
                       rep:HeapRep static {
                             Fun {arity: 5 fun_type: ArgGen [False, False, True, True]} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cksP:
           _sjXe::F64 = D1;
           _sjXd::I64 = R4;
           _sjXc::P64 = R3;
           _sjXb::P64 = R2;
           goto cksG;
       cksG:
           if ((old + 0) - <highSp> < SpLim) goto cksQ; else goto cksR;
       cksR:
           goto cksF;
       cksF:
           Hp = Hp + 16;
           if (Hp > HpLim) goto cksT; else goto cksS;
       cksT:
           HpAlloc = 16;
           goto cksQ;
       cksQ:
           R1 = Main.$wa_closure;
           P64[(old + 40)] = _sjXb::P64;
           P64[(old + 32)] = _sjXc::P64;
           I64[(old + 24)] = _sjXd::I64;
           F64[(old + 16)] = _sjXe::F64;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       cksS:
           I64[Hp - 8] = Data.Primitive.ByteArray.MutableByteArray_con_info;
           P64[Hp] = _sjXc::P64;
           _cksO::P64 = Hp - 7;
           _B2::P64 = _cksO::P64;
           goto sjYa;
       sjYa:
           goto ckum;
       ckum:
           if (HpLim == 0) goto ckuo; else goto ckup;
       ckuo:
           I64[(young<ckul> + 8)] = ckul;
           R1 = _B2::P64;
           call stg_gc_unpt_r1(R1) returns to ckul, args: 8, res: 8, upd: 8;
       ckul:
           _B2::P64 = R1;
           goto ckum;
       ckup:
           _sjY6::P64 = _B2::P64;
           goto sjY5;
       sjY5:
           goto ckub;
       ckub:
           if (HpLim == 0) goto ckue; else goto ckuf;
       ckue:
           I64[(young<ckua> + 8)] = ckua;
           R1 = _sjY6::P64;
           call stg_gc_unpt_r1(R1) returns to ckua, args: 8, res: 8, upd: 8;
       ckua:
           _sjY6::P64 = R1;
           goto ckub;
       ckuf:
           I64[(young<ckud> + 8)] = ckud;
           R1 = _sjY6::P64;
           if (R1 & 7 != 0) goto ckud; else goto ckug;
       ckug:
           call (I64[R1])(R1) returns to ckud, args: 8, res: 8, upd: 8;
       ckud:
           _sjY8::P64 = R1;
           _sjY9::P64 = P64[_sjY8::P64 + 7];
           _sjXh::P64 = _sjY9::P64;
           goto sjXg;
       sjXg:
           goto cksV;
       cksV:
           if (HpLim == 0) goto cksY; else goto cksZ;
       cksY:
           I64[(young<cksU> + 8)] = cksU;
           R1 = _sjXh::P64;
           call stg_gc_unpt_r1(R1) returns to cksU, args: 8, res: 8, upd: 8;
       cksU:
           _sjXh::P64 = R1;
           goto cksV;
       cksZ:
           _sjXl::I64 = I64[_sjXh::P64 + 16];
           _sjXl::I64 = _sjXl::I64;
           I64[(young<cksX> + 8)] = cksX;
           R2 = _sjXl::I64;
           call $wgo_rjVb_info(R2) returns to cksX, args: 8, res: 8, upd: 8;
       cksX:
           _sjXo::I64 = R2;
           _sjXn::I64 = R1;
           goto ckt0;
       ckt0:
           I64[_sjXh::P64 + 16] = _sjXn::I64;
           _sjXs::I64 = I64[_sjXh::P64 + 16];
           _sjXs::I64 = _sjXs::I64;
           _ckt6::I64 = _sjXd::I64 - 2;
           _sjXt::I64 = _ckt6::I64;
           _ckt9::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_sjXt::I64));
           _sjXu::I64 = _ckt9::I64;
           I64[(young<cktc> + 8)] = cktc;
           R3 = _sjXs::I64;
           R2 = _sjXu::I64;
           call System.Random.PCG.Fast.Pure.$wbounded_info(R3,
                                                           R2) returns to cktc, args: 8, res: 8, upd: 8;
       cktc:
           _sjXx::I64 = R2;
           _sjXw::I64 = R1;
           goto cktd;
       cktd:
           I64[_sjXh::P64 + 16] = _sjXw::I64;
           _cktk::I64 = 100000;
           (_cktj::F64) = call MO_UF_Conv W64(_cktk::I64);
           _sjXB::F64 = _cktj::F64;
           _ckto::I64 = _sjXo::I64;
           (_cktn::F64) = call MO_UF_Conv W64(_ckto::I64);
           _sjXz::F64 = _cktn::F64;
           _cktr::F64 = %MO_F_Mul_W64(_sjXz::F64, 100.0 :: W64);
           _sjXA::F64 = _cktr::F64;
           _cktu::F64 = %MO_F_Quot_W64(_sjXA::F64, _sjXB::F64);
           _sjXC::F64 = _cktu::F64;
           _cktx::I64 = %MO_F_Le_W64(_sjXC::F64, _sjXe::F64);
           _sjXD::I64 = _cktx::I64;
           switch [0 .. 1] _sjXD::I64 {
               case 0 : goto cktG;
               case 1 : goto cktX;
           }
       cktX:
           I64[(young<cktU> + 8)] = cktU;
           R1 = lvl12_rjVc_closure+1;
           call stg_norec_atomically#(R1) returns to cktU, args: 8, res: 8, upd: 8;
       cktU:
           _sjXU::P64 = R1;
           _sjXX::P64 = P64[_sjXb::P64 + 8];
           _sjXX::P64 = _sjXX::P64;
           I64[(young<cktW> + 8)] = cktW;
           R1 = _sjXX::P64;
           if (R1 & 7 != 0) goto cktW; else goto cktZ;
       cktZ:
           call (I64[R1])(R1) returns to cktW, args: 8, res: 8, upd: 8;
       cktW:
           _sjXY::P64 = R1;
           Hp = Hp + 16;
           if (Hp > HpLim) goto cku5; else goto cku4;
       cku5:
           HpAlloc = 16;
           goto cku3;
       cku3:
           R1 = _sjXY::P64;
           call stg_gc_unpt_r1(R1) returns to cktW, args: 8, res: 8, upd: 8;
       cku4:
           _sjXZ::I64 = I64[_sjXY::P64 + 7];
           _sjY0::I64 = _sjXZ::I64;
           switch [0 .. 18446744073709551615] _sjY0::I64 {
               case 18446744073709551615 : goto cku9;
               default: goto cku8;
           }
       cku9:
           Hp = Hp - 16;
           R1 = GHC.Word.$fEnumWord12_closure;
           call (I64[R1])(R1) args: 8, res: 0, upd: 8;
       cku8:
           _ckuz::I64 = _sjY0::I64 + 1;
           _sjY1::I64 = _ckuz::I64;
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _sjY1::I64;
           _ckuC::P64 = Hp - 7;
           P64[_sjXb::P64 + 8] = _ckuC::P64;
           _ckuD::I64 = dirty_MUT_VAR;
           _ckuE::I64 = BaseReg;
           _ckuF::P64 = _sjXb::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] (_ckuD::I64)(_ckuE::I64, _ckuF::P64);
           _sjXh::P64 = _sjXh::P64;
           goto sjXg;
       cktG:
           I64[(young<cktC> + 8)] = cktC;
           R1 = lvl12_rjVc_closure+1;
           call stg_norec_atomically#(R1) returns to cktC, args: 8, res: 8, upd: 8;
       cktC:
           _sjXH::P64 = R1;
           _sjXK::P64 = P64[_sjXb::P64 + 8];
           _sjXK::P64 = _sjXK::P64;
           I64[(young<cktE> + 8)] = cktE;
           R1 = _sjXK::P64;
           if (R1 & 7 != 0) goto cktE; else goto cktI;
       cktI:
           call (I64[R1])(R1) returns to cktE, args: 8, res: 8, upd: 8;
       cktE:
           _sjXL::P64 = R1;
           Hp = Hp + 16;
           if (Hp > HpLim) goto cktO; else goto cktN;
       cktO:
           HpAlloc = 16;
           goto cktM;
       cktM:
           R1 = _sjXL::P64;
           call stg_gc_unpt_r1(R1) returns to cktE, args: 8, res: 8, upd: 8;
       cktN:
           _sjXM::I64 = I64[_sjXL::P64 + 7];
           _sjXN::I64 = _sjXM::I64;
           switch [0 .. 18446744073709551615] _sjXN::I64 {
               case 18446744073709551615 : goto cktS;
               default: goto cktR;
           }
       cktS:
           Hp = Hp - 16;
           R1 = GHC.Word.$fEnumWord12_closure;
           call (I64[R1])(R1) args: 8, res: 0, upd: 8;
       cktR:
           _ckur::I64 = _sjXN::I64 + 1;
           _sjXO::I64 = _ckur::I64;
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _sjXO::I64;
           _ckuu::P64 = Hp - 7;
           P64[_sjXb::P64 + 8] = _ckuu::P64;
           _ckuv::I64 = dirty_MUT_VAR;
           _ckuw::I64 = BaseReg;
           _ckux::P64 = _sjXb::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] (_ckuv::I64)(_ckuw::I64, _ckux::P64);
           _sjXh::P64 = _sjXh::P64;
           goto sjXg;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:53.177842 UTC

{offset
  cksE:
      _rbST::P64 = R1;
      _sjXb::P64 = P64[(old + 40)];
      _sjXc::P64 = P64[(old + 32)];
      _sjXd::I64 = I64[(old + 24)];
      _sjXe::F64 = F64[(old + 16)];
      D1 = _sjXe::F64;
      R4 = _sjXd::I64;
      R3 = _sjXc::P64;
      R2 = _sjXb::P64;
      R1 = _rbST::P64;
      call Main.$wa_info(D1, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:53.178619 UTC

{offset
  cksE:
      _rbST::P64 = R1;
      _sjXb::P64 = P64[(old + 40)];
      _sjXc::P64 = P64[(old + 32)];
      _sjXd::I64 = I64[(old + 24)];
      _sjXe::F64 = F64[(old + 16)];
      D1 = _sjXe::F64;
      R4 = _sjXd::I64;
      R3 = _sjXc::P64;
      R2 = _sjXb::P64;
      R1 = _rbST::P64;
      call Main.$wa_info(D1, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:53.179387 UTC

{offset
  cksE:
      _rbST::P64 = R1;
      _sjXb::P64 = P64[(old + 40)];
      _sjXc::P64 = P64[(old + 32)];
      _sjXd::I64 = I64[(old + 24)];
      _sjXe::F64 = F64[(old + 16)];
      D1 = _sjXe::F64;
      R4 = _sjXd::I64;
      R3 = _sjXc::P64;
      R2 = _sjXb::P64;
      R1 = _rbST::P64;
      call Main.$wa_info(D1, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:53.180127 UTC

{offset
  cksE:
      _rbST::P64 = R1;
      _sjXb::P64 = P64[Sp];
      _sjXc::P64 = P64[Sp + 8];
      _sjXd::I64 = I64[Sp + 16];
      _sjXe::F64 = F64[Sp + 24];
      D1 = _sjXe::F64;
      R4 = _sjXd::I64;
      R3 = _sjXc::P64;
      R2 = _sjXb::P64;
      R1 = _rbST::P64;
      Sp = Sp + 32;
      call Main.$wa_info(D1, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:53.180881 UTC

{offset
  cksE:
      D1 = F64[Sp + 24];
      R4 = I64[Sp + 16];
      R3 = P64[Sp + 8];
      R2 = P64[Sp];
      R1 = R1;
      Sp = Sp + 32;
      call Main.$wa_info(D1, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:53.181567 UTC

[(cksE, {Main.$wa_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:53.181836 UTC

Main.$wa_slow() //  [R1]
        { info_tbl: []
          stack_info: arg_space: 40 updfr_space: Just 8
        }
    {offset
      cksE:
          D1 = F64[Sp + 24];
          R4 = I64[Sp + 16];
          R3 = P64[Sp + 8];
          R2 = P64[Sp];
          R1 = R1;
          Sp = Sp + 32;
          call Main.$wa_info(D1, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:53.182521 UTC

Main.$wa_slow() //  [R1]
        { info_tbl: []
          stack_info: arg_space: 40 updfr_space: Just 8
        }
    {offset
      cksE:
          D1 = F64[Sp + 24];
          R4 = I64[Sp + 16];
          R3 = P64[Sp + 8];
          R2 = P64[Sp];
          R1 = R1;
          Sp = Sp + 32;
          call Main.$wa_info(D1, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:53.183212 UTC

{offset
  cksP:
      _sjXe::F64 = D1;
      _sjXd::I64 = R4;
      _sjXc::P64 = R3;
      _sjXb::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cksQ; else goto cksR;
  cksR:
      Hp = Hp + 16;
      if (Hp > HpLim) goto cksT; else goto cksS;
  cksT:
      HpAlloc = 16;
      goto cksQ;
  cksQ:
      R1 = Main.$wa_closure;
      P64[(old + 40)] = _sjXb::P64;
      P64[(old + 32)] = _sjXc::P64;
      I64[(old + 24)] = _sjXd::I64;
      F64[(old + 16)] = _sjXe::F64;
      call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
  cksS:
      I64[Hp - 8] = Data.Primitive.ByteArray.MutableByteArray_con_info;
      P64[Hp] = _sjXc::P64;
      _cksO::P64 = Hp - 7;
      _B2::P64 = _cksO::P64;
      goto ckum;
  ckum:
      if (HpLim == 0) goto ckuo; else goto ckup;
  ckuo:
      I64[(young<ckul> + 8)] = ckul;
      R1 = _B2::P64;
      call stg_gc_unpt_r1(R1) returns to ckul, args: 8, res: 8, upd: 8;
  ckul:
      _B2::P64 = R1;
      goto ckum;
  ckup:
      _sjY6::P64 = _B2::P64;
      goto ckub;
  ckub:
      if (HpLim == 0) goto ckue; else goto ckuf;
  ckue:
      I64[(young<ckua> + 8)] = ckua;
      R1 = _sjY6::P64;
      call stg_gc_unpt_r1(R1) returns to ckua, args: 8, res: 8, upd: 8;
  ckua:
      _sjY6::P64 = R1;
      goto ckub;
  ckuf:
      I64[(young<ckud> + 8)] = ckud;
      R1 = _sjY6::P64;
      if (R1 & 7 != 0) goto ckud; else goto ckug;
  ckug:
      call (I64[R1])(R1) returns to ckud, args: 8, res: 8, upd: 8;
  ckud:
      _sjY8::P64 = R1;
      _sjY9::P64 = P64[_sjY8::P64 + 7];
      _sjXh::P64 = _sjY9::P64;
      goto cksV;
  cksV:
      if (HpLim == 0) goto cksY; else goto cksZ;
  cksY:
      I64[(young<cksU> + 8)] = cksU;
      R1 = _sjXh::P64;
      call stg_gc_unpt_r1(R1) returns to cksU, args: 8, res: 8, upd: 8;
  cksU:
      _sjXh::P64 = R1;
      goto cksV;
  cksZ:
      _sjXl::I64 = I64[_sjXh::P64 + 16];
      _sjXl::I64 = _sjXl::I64;
      I64[(young<cksX> + 8)] = cksX;
      R2 = _sjXl::I64;
      call $wgo_rjVb_info(R2) returns to cksX, args: 8, res: 8, upd: 8;
  cksX:
      _sjXo::I64 = R2;
      _sjXn::I64 = R1;
      I64[_sjXh::P64 + 16] = _sjXn::I64;
      _sjXs::I64 = I64[_sjXh::P64 + 16];
      _sjXs::I64 = _sjXs::I64;
      _ckt6::I64 = _sjXd::I64 - 2;
      _sjXt::I64 = _ckt6::I64;
      _ckt9::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_sjXt::I64));
      _sjXu::I64 = _ckt9::I64;
      I64[(young<cktc> + 8)] = cktc;
      R3 = _sjXs::I64;
      R2 = _sjXu::I64;
      call System.Random.PCG.Fast.Pure.$wbounded_info(R3,
                                                      R2) returns to cktc, args: 8, res: 8, upd: 8;
  cktc:
      _sjXx::I64 = R2;
      _sjXw::I64 = R1;
      I64[_sjXh::P64 + 16] = _sjXw::I64;
      _cktk::I64 = 100000;
      (_cktj::F64) = call MO_UF_Conv W64(_cktk::I64);
      _sjXB::F64 = _cktj::F64;
      _ckto::I64 = _sjXo::I64;
      (_cktn::F64) = call MO_UF_Conv W64(_ckto::I64);
      _sjXz::F64 = _cktn::F64;
      _cktr::F64 = %MO_F_Mul_W64(_sjXz::F64, 100.0 :: W64);
      _sjXA::F64 = _cktr::F64;
      _cktu::F64 = %MO_F_Quot_W64(_sjXA::F64, _sjXB::F64);
      _sjXC::F64 = _cktu::F64;
      _cktx::I64 = %MO_F_Le_W64(_sjXC::F64, _sjXe::F64);
      _sjXD::I64 = _cktx::I64;
      switch [0 .. 1] _sjXD::I64 {
          case 0 : goto cktG;
          case 1 : goto cktX;
      }
  cktX:
      I64[(young<cktU> + 8)] = cktU;
      R1 = lvl12_rjVc_closure+1;
      call stg_norec_atomically#(R1) returns to cktU, args: 8, res: 8, upd: 8;
  cktU:
      _sjXU::P64 = R1;
      _sjXX::P64 = P64[_sjXb::P64 + 8];
      _sjXX::P64 = _sjXX::P64;
      I64[(young<cktW> + 8)] = cktW;
      R1 = _sjXX::P64;
      if (R1 & 7 != 0) goto cktW; else goto cktZ;
  cktZ:
      call (I64[R1])(R1) returns to cktW, args: 8, res: 8, upd: 8;
  cktW:
      _sjXY::P64 = R1;
      Hp = Hp + 16;
      if (Hp > HpLim) goto cku5; else goto cku4;
  cku5:
      HpAlloc = 16;
      R1 = _sjXY::P64;
      call stg_gc_unpt_r1(R1) returns to cktW, args: 8, res: 8, upd: 8;
  cku4:
      _sjXZ::I64 = I64[_sjXY::P64 + 7];
      _sjY0::I64 = _sjXZ::I64;
      switch [0 .. 18446744073709551615] _sjY0::I64 {
          case 18446744073709551615 : goto cku9;
          default: goto cku8;
      }
  cku9:
      Hp = Hp - 16;
      R1 = GHC.Word.$fEnumWord12_closure;
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
  cku8:
      _ckuz::I64 = _sjY0::I64 + 1;
      _sjY1::I64 = _ckuz::I64;
      I64[Hp - 8] = GHC.Word.W64#_con_info;
      I64[Hp] = _sjY1::I64;
      _ckuC::P64 = Hp - 7;
      P64[_sjXb::P64 + 8] = _ckuC::P64;
      _ckuD::I64 = dirty_MUT_VAR;
      _ckuE::I64 = BaseReg;
      _ckuF::P64 = _sjXb::P64;
      call "ccall" arg hints:  [PtrHint,
                                PtrHint]  result hints:  [] (_ckuD::I64)(_ckuE::I64, _ckuF::P64);
      _sjXh::P64 = _sjXh::P64;
      goto cksV;
  cktG:
      I64[(young<cktC> + 8)] = cktC;
      R1 = lvl12_rjVc_closure+1;
      call stg_norec_atomically#(R1) returns to cktC, args: 8, res: 8, upd: 8;
  cktC:
      _sjXH::P64 = R1;
      _sjXK::P64 = P64[_sjXb::P64 + 8];
      _sjXK::P64 = _sjXK::P64;
      I64[(young<cktE> + 8)] = cktE;
      R1 = _sjXK::P64;
      if (R1 & 7 != 0) goto cktE; else goto cktI;
  cktI:
      call (I64[R1])(R1) returns to cktE, args: 8, res: 8, upd: 8;
  cktE:
      _sjXL::P64 = R1;
      Hp = Hp + 16;
      if (Hp > HpLim) goto cktO; else goto cktN;
  cktO:
      HpAlloc = 16;
      R1 = _sjXL::P64;
      call stg_gc_unpt_r1(R1) returns to cktE, args: 8, res: 8, upd: 8;
  cktN:
      _sjXM::I64 = I64[_sjXL::P64 + 7];
      _sjXN::I64 = _sjXM::I64;
      switch [0 .. 18446744073709551615] _sjXN::I64 {
          case 18446744073709551615 : goto cktS;
          default: goto cktR;
      }
  cktS:
      Hp = Hp - 16;
      R1 = GHC.Word.$fEnumWord12_closure;
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
  cktR:
      _ckur::I64 = _sjXN::I64 + 1;
      _sjXO::I64 = _ckur::I64;
      I64[Hp - 8] = GHC.Word.W64#_con_info;
      I64[Hp] = _sjXO::I64;
      _ckuu::P64 = Hp - 7;
      P64[_sjXb::P64 + 8] = _ckuu::P64;
      _ckuv::I64 = dirty_MUT_VAR;
      _ckuw::I64 = BaseReg;
      _ckux::P64 = _sjXb::P64;
      call "ccall" arg hints:  [PtrHint,
                                PtrHint]  result hints:  [] (_ckuv::I64)(_ckuw::I64, _ckux::P64);
      _sjXh::P64 = _sjXh::P64;
      goto cksV;
}


==================== Post common block elimination ====================
2015-11-09 18:21:53.191868 UTC

{offset
  cksP:
      _sjXe::F64 = D1;
      _sjXd::I64 = R4;
      _sjXc::P64 = R3;
      _sjXb::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cksQ; else goto cksR;
  cksR:
      Hp = Hp + 16;
      if (Hp > HpLim) goto cksT; else goto cksS;
  cksT:
      HpAlloc = 16;
      goto cksQ;
  cksQ:
      R1 = Main.$wa_closure;
      P64[(old + 40)] = _sjXb::P64;
      P64[(old + 32)] = _sjXc::P64;
      I64[(old + 24)] = _sjXd::I64;
      F64[(old + 16)] = _sjXe::F64;
      call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
  cksS:
      I64[Hp - 8] = Data.Primitive.ByteArray.MutableByteArray_con_info;
      P64[Hp] = _sjXc::P64;
      _cksO::P64 = Hp - 7;
      _B2::P64 = _cksO::P64;
      goto ckum;
  ckum:
      if (HpLim == 0) goto ckuo; else goto ckup;
  ckuo:
      I64[(young<ckul> + 8)] = ckul;
      R1 = _B2::P64;
      call stg_gc_unpt_r1(R1) returns to ckul, args: 8, res: 8, upd: 8;
  ckul:
      _B2::P64 = R1;
      goto ckum;
  ckup:
      _sjY6::P64 = _B2::P64;
      goto ckub;
  ckub:
      if (HpLim == 0) goto ckue; else goto ckuf;
  ckue:
      I64[(young<ckua> + 8)] = ckua;
      R1 = _sjY6::P64;
      call stg_gc_unpt_r1(R1) returns to ckua, args: 8, res: 8, upd: 8;
  ckua:
      _sjY6::P64 = R1;
      goto ckub;
  ckuf:
      I64[(young<ckud> + 8)] = ckud;
      R1 = _sjY6::P64;
      if (R1 & 7 != 0) goto ckud; else goto ckug;
  ckug:
      call (I64[R1])(R1) returns to ckud, args: 8, res: 8, upd: 8;
  ckud:
      _sjY8::P64 = R1;
      _sjY9::P64 = P64[_sjY8::P64 + 7];
      _sjXh::P64 = _sjY9::P64;
      goto cksV;
  cksV:
      if (HpLim == 0) goto cksY; else goto cksZ;
  cksY:
      I64[(young<cksU> + 8)] = cksU;
      R1 = _sjXh::P64;
      call stg_gc_unpt_r1(R1) returns to cksU, args: 8, res: 8, upd: 8;
  cksU:
      _sjXh::P64 = R1;
      goto cksV;
  cksZ:
      _sjXl::I64 = I64[_sjXh::P64 + 16];
      _sjXl::I64 = _sjXl::I64;
      I64[(young<cksX> + 8)] = cksX;
      R2 = _sjXl::I64;
      call $wgo_rjVb_info(R2) returns to cksX, args: 8, res: 8, upd: 8;
  cksX:
      _sjXo::I64 = R2;
      _sjXn::I64 = R1;
      I64[_sjXh::P64 + 16] = _sjXn::I64;
      _sjXs::I64 = I64[_sjXh::P64 + 16];
      _sjXs::I64 = _sjXs::I64;
      _ckt6::I64 = _sjXd::I64 - 2;
      _sjXt::I64 = _ckt6::I64;
      _ckt9::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_sjXt::I64));
      _sjXu::I64 = _ckt9::I64;
      I64[(young<cktc> + 8)] = cktc;
      R3 = _sjXs::I64;
      R2 = _sjXu::I64;
      call System.Random.PCG.Fast.Pure.$wbounded_info(R3,
                                                      R2) returns to cktc, args: 8, res: 8, upd: 8;
  cktc:
      _sjXx::I64 = R2;
      _sjXw::I64 = R1;
      I64[_sjXh::P64 + 16] = _sjXw::I64;
      _cktk::I64 = 100000;
      (_cktj::F64) = call MO_UF_Conv W64(_cktk::I64);
      _sjXB::F64 = _cktj::F64;
      _ckto::I64 = _sjXo::I64;
      (_cktn::F64) = call MO_UF_Conv W64(_ckto::I64);
      _sjXz::F64 = _cktn::F64;
      _cktr::F64 = %MO_F_Mul_W64(_sjXz::F64, 100.0 :: W64);
      _sjXA::F64 = _cktr::F64;
      _cktu::F64 = %MO_F_Quot_W64(_sjXA::F64, _sjXB::F64);
      _sjXC::F64 = _cktu::F64;
      _cktx::I64 = %MO_F_Le_W64(_sjXC::F64, _sjXe::F64);
      _sjXD::I64 = _cktx::I64;
      switch [0 .. 1] _sjXD::I64 {
          case 0 : goto cktG;
          case 1 : goto cktX;
      }
  cktX:
      I64[(young<cktU> + 8)] = cktU;
      R1 = lvl12_rjVc_closure+1;
      call stg_norec_atomically#(R1) returns to cktU, args: 8, res: 8, upd: 8;
  cktU:
      _sjXU::P64 = R1;
      _sjXX::P64 = P64[_sjXb::P64 + 8];
      _sjXX::P64 = _sjXX::P64;
      I64[(young<cktW> + 8)] = cktW;
      R1 = _sjXX::P64;
      if (R1 & 7 != 0) goto cktW; else goto cktZ;
  cktZ:
      call (I64[R1])(R1) returns to cktW, args: 8, res: 8, upd: 8;
  cktW:
      _sjXY::P64 = R1;
      Hp = Hp + 16;
      if (Hp > HpLim) goto cku5; else goto cku4;
  cku5:
      HpAlloc = 16;
      R1 = _sjXY::P64;
      call stg_gc_unpt_r1(R1) returns to cktW, args: 8, res: 8, upd: 8;
  cku4:
      _sjXZ::I64 = I64[_sjXY::P64 + 7];
      _sjY0::I64 = _sjXZ::I64;
      switch [0 .. 18446744073709551615] _sjY0::I64 {
          case 18446744073709551615 : goto cku9;
          default: goto cku8;
      }
  cku8:
      _ckuz::I64 = _sjY0::I64 + 1;
      _sjY1::I64 = _ckuz::I64;
      I64[Hp - 8] = GHC.Word.W64#_con_info;
      I64[Hp] = _sjY1::I64;
      _ckuC::P64 = Hp - 7;
      P64[_sjXb::P64 + 8] = _ckuC::P64;
      _ckuD::I64 = dirty_MUT_VAR;
      _ckuE::I64 = BaseReg;
      _ckuF::P64 = _sjXb::P64;
      call "ccall" arg hints:  [PtrHint,
                                PtrHint]  result hints:  [] (_ckuD::I64)(_ckuE::I64, _ckuF::P64);
      _sjXh::P64 = _sjXh::P64;
      goto cksV;
  cktG:
      I64[(young<cktC> + 8)] = cktC;
      R1 = lvl12_rjVc_closure+1;
      call stg_norec_atomically#(R1) returns to cktC, args: 8, res: 8, upd: 8;
  cktC:
      _sjXH::P64 = R1;
      _sjXK::P64 = P64[_sjXb::P64 + 8];
      _sjXK::P64 = _sjXK::P64;
      I64[(young<cktE> + 8)] = cktE;
      R1 = _sjXK::P64;
      if (R1 & 7 != 0) goto cktE; else goto cktI;
  cktI:
      call (I64[R1])(R1) returns to cktE, args: 8, res: 8, upd: 8;
  cktE:
      _sjXL::P64 = R1;
      Hp = Hp + 16;
      if (Hp > HpLim) goto cktO; else goto cktN;
  cktO:
      HpAlloc = 16;
      R1 = _sjXL::P64;
      call stg_gc_unpt_r1(R1) returns to cktE, args: 8, res: 8, upd: 8;
  cktN:
      _sjXM::I64 = I64[_sjXL::P64 + 7];
      _sjXN::I64 = _sjXM::I64;
      switch [0 .. 18446744073709551615] _sjXN::I64 {
          case 18446744073709551615 : goto cku9;
          default: goto cktR;
      }
  cku9:
      Hp = Hp - 16;
      R1 = GHC.Word.$fEnumWord12_closure;
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
  cktR:
      _ckur::I64 = _sjXN::I64 + 1;
      _sjXO::I64 = _ckur::I64;
      I64[Hp - 8] = GHC.Word.W64#_con_info;
      I64[Hp] = _sjXO::I64;
      _ckuu::P64 = Hp - 7;
      P64[_sjXb::P64 + 8] = _ckuu::P64;
      _ckuv::I64 = dirty_MUT_VAR;
      _ckuw::I64 = BaseReg;
      _ckux::P64 = _sjXb::P64;
      call "ccall" arg hints:  [PtrHint,
                                PtrHint]  result hints:  [] (_ckuv::I64)(_ckuw::I64, _ckux::P64);
      _sjXh::P64 = _sjXh::P64;
      goto cksV;
}


==================== Post switch plan ====================
2015-11-09 18:21:53.200924 UTC

{offset
  cksP:
      _sjXe::F64 = D1;
      _sjXd::I64 = R4;
      _sjXc::P64 = R3;
      _sjXb::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cksQ; else goto cksR;
  cksR:
      Hp = Hp + 16;
      if (Hp > HpLim) goto cksT; else goto cksS;
  cksT:
      HpAlloc = 16;
      goto cksQ;
  cksQ:
      R1 = Main.$wa_closure;
      P64[(old + 40)] = _sjXb::P64;
      P64[(old + 32)] = _sjXc::P64;
      I64[(old + 24)] = _sjXd::I64;
      F64[(old + 16)] = _sjXe::F64;
      call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
  cksS:
      I64[Hp - 8] = Data.Primitive.ByteArray.MutableByteArray_con_info;
      P64[Hp] = _sjXc::P64;
      _cksO::P64 = Hp - 7;
      _B2::P64 = _cksO::P64;
      goto ckum;
  ckum:
      if (HpLim == 0) goto ckuo; else goto ckup;
  ckuo:
      I64[(young<ckul> + 8)] = ckul;
      R1 = _B2::P64;
      call stg_gc_unpt_r1(R1) returns to ckul, args: 8, res: 8, upd: 8;
  ckul:
      _B2::P64 = R1;
      goto ckum;
  ckup:
      _sjY6::P64 = _B2::P64;
      goto ckub;
  ckub:
      if (HpLim == 0) goto ckue; else goto ckuf;
  ckue:
      I64[(young<ckua> + 8)] = ckua;
      R1 = _sjY6::P64;
      call stg_gc_unpt_r1(R1) returns to ckua, args: 8, res: 8, upd: 8;
  ckua:
      _sjY6::P64 = R1;
      goto ckub;
  ckuf:
      I64[(young<ckud> + 8)] = ckud;
      R1 = _sjY6::P64;
      if (R1 & 7 != 0) goto ckud; else goto ckug;
  ckug:
      call (I64[R1])(R1) returns to ckud, args: 8, res: 8, upd: 8;
  ckud:
      _sjY8::P64 = R1;
      _sjY9::P64 = P64[_sjY8::P64 + 7];
      _sjXh::P64 = _sjY9::P64;
      goto cksV;
  cksV:
      if (HpLim == 0) goto cksY; else goto cksZ;
  cksY:
      I64[(young<cksU> + 8)] = cksU;
      R1 = _sjXh::P64;
      call stg_gc_unpt_r1(R1) returns to cksU, args: 8, res: 8, upd: 8;
  cksU:
      _sjXh::P64 = R1;
      goto cksV;
  cksZ:
      _sjXl::I64 = I64[_sjXh::P64 + 16];
      _sjXl::I64 = _sjXl::I64;
      I64[(young<cksX> + 8)] = cksX;
      R2 = _sjXl::I64;
      call $wgo_rjVb_info(R2) returns to cksX, args: 8, res: 8, upd: 8;
  cksX:
      _sjXo::I64 = R2;
      _sjXn::I64 = R1;
      I64[_sjXh::P64 + 16] = _sjXn::I64;
      _sjXs::I64 = I64[_sjXh::P64 + 16];
      _sjXs::I64 = _sjXs::I64;
      _ckt6::I64 = _sjXd::I64 - 2;
      _sjXt::I64 = _ckt6::I64;
      _ckt9::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_sjXt::I64));
      _sjXu::I64 = _ckt9::I64;
      I64[(young<cktc> + 8)] = cktc;
      R3 = _sjXs::I64;
      R2 = _sjXu::I64;
      call System.Random.PCG.Fast.Pure.$wbounded_info(R3,
                                                      R2) returns to cktc, args: 8, res: 8, upd: 8;
  cktc:
      _sjXx::I64 = R2;
      _sjXw::I64 = R1;
      I64[_sjXh::P64 + 16] = _sjXw::I64;
      _cktk::I64 = 100000;
      (_cktj::F64) = call MO_UF_Conv W64(_cktk::I64);
      _sjXB::F64 = _cktj::F64;
      _ckto::I64 = _sjXo::I64;
      (_cktn::F64) = call MO_UF_Conv W64(_ckto::I64);
      _sjXz::F64 = _cktn::F64;
      _cktr::F64 = %MO_F_Mul_W64(_sjXz::F64, 100.0 :: W64);
      _sjXA::F64 = _cktr::F64;
      _cktu::F64 = %MO_F_Quot_W64(_sjXA::F64, _sjXB::F64);
      _sjXC::F64 = _cktu::F64;
      _cktx::I64 = %MO_F_Le_W64(_sjXC::F64, _sjXe::F64);
      _sjXD::I64 = _cktx::I64;
      if (_sjXD::I64 != 0) goto cktX; else goto cktG;
  cktX:
      I64[(young<cktU> + 8)] = cktU;
      R1 = lvl12_rjVc_closure+1;
      call stg_norec_atomically#(R1) returns to cktU, args: 8, res: 8, upd: 8;
  cktU:
      _sjXU::P64 = R1;
      _sjXX::P64 = P64[_sjXb::P64 + 8];
      _sjXX::P64 = _sjXX::P64;
      I64[(young<cktW> + 8)] = cktW;
      R1 = _sjXX::P64;
      if (R1 & 7 != 0) goto cktW; else goto cktZ;
  cktZ:
      call (I64[R1])(R1) returns to cktW, args: 8, res: 8, upd: 8;
  cktW:
      _sjXY::P64 = R1;
      Hp = Hp + 16;
      if (Hp > HpLim) goto cku5; else goto cku4;
  cku5:
      HpAlloc = 16;
      R1 = _sjXY::P64;
      call stg_gc_unpt_r1(R1) returns to cktW, args: 8, res: 8, upd: 8;
  cku4:
      _sjXZ::I64 = I64[_sjXY::P64 + 7];
      _sjY0::I64 = _sjXZ::I64;
      if (_sjY0::I64 != 18446744073709551615) goto cku8; else goto cku9;
  cku8:
      _ckuz::I64 = _sjY0::I64 + 1;
      _sjY1::I64 = _ckuz::I64;
      I64[Hp - 8] = GHC.Word.W64#_con_info;
      I64[Hp] = _sjY1::I64;
      _ckuC::P64 = Hp - 7;
      P64[_sjXb::P64 + 8] = _ckuC::P64;
      _ckuD::I64 = dirty_MUT_VAR;
      _ckuE::I64 = BaseReg;
      _ckuF::P64 = _sjXb::P64;
      call "ccall" arg hints:  [PtrHint,
                                PtrHint]  result hints:  [] (_ckuD::I64)(_ckuE::I64, _ckuF::P64);
      _sjXh::P64 = _sjXh::P64;
      goto cksV;
  cktG:
      I64[(young<cktC> + 8)] = cktC;
      R1 = lvl12_rjVc_closure+1;
      call stg_norec_atomically#(R1) returns to cktC, args: 8, res: 8, upd: 8;
  cktC:
      _sjXH::P64 = R1;
      _sjXK::P64 = P64[_sjXb::P64 + 8];
      _sjXK::P64 = _sjXK::P64;
      I64[(young<cktE> + 8)] = cktE;
      R1 = _sjXK::P64;
      if (R1 & 7 != 0) goto cktE; else goto cktI;
  cktI:
      call (I64[R1])(R1) returns to cktE, args: 8, res: 8, upd: 8;
  cktE:
      _sjXL::P64 = R1;
      Hp = Hp + 16;
      if (Hp > HpLim) goto cktO; else goto cktN;
  cktO:
      HpAlloc = 16;
      R1 = _sjXL::P64;
      call stg_gc_unpt_r1(R1) returns to cktE, args: 8, res: 8, upd: 8;
  cktN:
      _sjXM::I64 = I64[_sjXL::P64 + 7];
      _sjXN::I64 = _sjXM::I64;
      if (_sjXN::I64 != 18446744073709551615) goto cktR; else goto cku9;
  cktR:
      _ckur::I64 = _sjXN::I64 + 1;
      _sjXO::I64 = _ckur::I64;
      I64[Hp - 8] = GHC.Word.W64#_con_info;
      I64[Hp] = _sjXO::I64;
      _ckuu::P64 = Hp - 7;
      P64[_sjXb::P64 + 8] = _ckuu::P64;
      _ckuv::I64 = dirty_MUT_VAR;
      _ckuw::I64 = BaseReg;
      _ckux::P64 = _sjXb::P64;
      call "ccall" arg hints:  [PtrHint,
                                PtrHint]  result hints:  [] (_ckuv::I64)(_ckuw::I64, _ckux::P64);
      _sjXh::P64 = _sjXh::P64;
      goto cksV;
  cku9:
      Hp = Hp - 16;
      R1 = GHC.Word.$fEnumWord12_closure;
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:53.210738 UTC

{offset
  cksP:
      _sjXe::F64 = D1;
      _sjXd::I64 = R4;
      _sjXc::P64 = R3;
      _sjXb::P64 = R2;
      if ((Sp + 8) - 56 < SpLim) goto cksQ; else goto cksR;
  cksR:
      Hp = Hp + 16;
      if (Hp > HpLim) goto cksT; else goto cksS;
  cksT:
      HpAlloc = 16;
      goto cksQ;
  cksQ:
      R1 = Main.$wa_closure;
      P64[Sp - 32] = _sjXb::P64;
      P64[Sp - 24] = _sjXc::P64;
      I64[Sp - 16] = _sjXd::I64;
      F64[Sp - 8] = _sjXe::F64;
      Sp = Sp - 32;
      call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
  cksS:
      I64[Hp - 8] = Data.Primitive.ByteArray.MutableByteArray_con_info;
      P64[Hp] = _sjXc::P64;
      _cksO::P64 = Hp - 7;
      _B2::P64 = _cksO::P64;
      goto ckum;
  ckum:
      if (HpLim == 0) goto ckuo; else goto ckup;
  ckuo:
      I64[Sp - 32] = ckul;
      R1 = _B2::P64;
      P64[Sp - 24] = _sjXb::P64;
      I64[Sp - 16] = _sjXd::I64;
      F64[Sp - 8] = _sjXe::F64;
      Sp = Sp - 32;
      call stg_gc_unpt_r1(R1) returns to ckul, args: 8, res: 8, upd: 8;
  ckul:
      _sjXb::P64 = P64[Sp + 8];
      _sjXd::I64 = I64[Sp + 16];
      _sjXe::F64 = F64[Sp + 24];
      _B2::P64 = R1;
      goto ukuG;
  ukuG:
      Sp = Sp + 32;
      goto ckum;
  ckup:
      _sjY6::P64 = _B2::P64;
      goto ckub;
  ckub:
      if (HpLim == 0) goto ckue; else goto ckuf;
  ckue:
      I64[Sp - 32] = ckua;
      R1 = _sjY6::P64;
      P64[Sp - 24] = _sjXb::P64;
      I64[Sp - 16] = _sjXd::I64;
      F64[Sp - 8] = _sjXe::F64;
      Sp = Sp - 32;
      call stg_gc_unpt_r1(R1) returns to ckua, args: 8, res: 8, upd: 8;
  ckua:
      _sjXb::P64 = P64[Sp + 8];
      _sjXd::I64 = I64[Sp + 16];
      _sjXe::F64 = F64[Sp + 24];
      _sjY6::P64 = R1;
      goto ukuH;
  ukuH:
      Sp = Sp + 32;
      goto ckub;
  ckuf:
      I64[Sp - 32] = ckud;
      R1 = _sjY6::P64;
      P64[Sp - 24] = _sjXb::P64;
      I64[Sp - 16] = _sjXd::I64;
      F64[Sp - 8] = _sjXe::F64;
      Sp = Sp - 32;
      if (R1 & 7 != 0) goto ckud; else goto ckug;
  ckug:
      call (I64[R1])(R1) returns to ckud, args: 8, res: 8, upd: 8;
  ckud:
      _sjXb::P64 = P64[Sp + 8];
      _sjXd::I64 = I64[Sp + 16];
      _sjXe::F64 = F64[Sp + 24];
      _sjY8::P64 = R1;
      _sjY9::P64 = P64[_sjY8::P64 + 7];
      _sjXh::P64 = _sjY9::P64;
      goto cksV;
  cksV:
      if (HpLim == 0) goto cksY; else goto cksZ;
  cksY:
      I64[Sp] = cksU;
      R1 = _sjXh::P64;
      call stg_gc_unpt_r1(R1) returns to cksU, args: 8, res: 8, upd: 8;
  cksU:
      _sjXb::P64 = P64[Sp + 8];
      _sjXd::I64 = I64[Sp + 16];
      _sjXe::F64 = F64[Sp + 24];
      _sjXh::P64 = R1;
      goto cksV;
  cksZ:
      _sjXl::I64 = I64[_sjXh::P64 + 16];
      _sjXl::I64 = _sjXl::I64;
      I64[Sp - 8] = cksX;
      R2 = _sjXl::I64;
      P64[Sp] = _sjXh::P64;
      Sp = Sp - 8;
      call $wgo_rjVb_info(R2) returns to cksX, args: 8, res: 8, upd: 8;
  cksX:
      _sjXb::P64 = P64[Sp + 16];
      _sjXd::I64 = I64[Sp + 24];
      _sjXe::F64 = F64[Sp + 32];
      _sjXh::P64 = P64[Sp + 8];
      _sjXo::I64 = R2;
      _sjXn::I64 = R1;
      I64[_sjXh::P64 + 16] = _sjXn::I64;
      _sjXs::I64 = I64[_sjXh::P64 + 16];
      _sjXs::I64 = _sjXs::I64;
      _ckt6::I64 = _sjXd::I64 - 2;
      _sjXt::I64 = _ckt6::I64;
      _ckt9::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_sjXt::I64));
      _sjXu::I64 = _ckt9::I64;
      I64[Sp - 8] = cktc;
      R3 = _sjXs::I64;
      R2 = _sjXu::I64;
      I64[Sp] = _sjXo::I64;
      Sp = Sp - 8;
      call System.Random.PCG.Fast.Pure.$wbounded_info(R3,
                                                      R2) returns to cktc, args: 8, res: 8, upd: 8;
  cktc:
      _sjXb::P64 = P64[Sp + 24];
      _sjXd::I64 = I64[Sp + 32];
      _sjXe::F64 = F64[Sp + 40];
      _sjXh::P64 = P64[Sp + 16];
      _sjXo::I64 = I64[Sp + 8];
      _sjXx::I64 = R2;
      _sjXw::I64 = R1;
      I64[_sjXh::P64 + 16] = _sjXw::I64;
      _cktk::I64 = 100000;
      (_cktj::F64) = call MO_UF_Conv W64(_cktk::I64);
      _sjXB::F64 = _cktj::F64;
      _ckto::I64 = _sjXo::I64;
      (_cktn::F64) = call MO_UF_Conv W64(_ckto::I64);
      _sjXz::F64 = _cktn::F64;
      _cktr::F64 = %MO_F_Mul_W64(_sjXz::F64, 100.0 :: W64);
      _sjXA::F64 = _cktr::F64;
      _cktu::F64 = %MO_F_Quot_W64(_sjXA::F64, _sjXB::F64);
      _sjXC::F64 = _cktu::F64;
      _cktx::I64 = %MO_F_Le_W64(_sjXC::F64, _sjXe::F64);
      _sjXD::I64 = _cktx::I64;
      if (_sjXD::I64 != 0) goto cktX; else goto cktG;
  cktX:
      I64[Sp + 8] = cktU;
      R1 = lvl12_rjVc_closure+1;
      Sp = Sp + 8;
      call stg_norec_atomically#(R1) returns to cktU, args: 8, res: 8, upd: 8;
  cktU:
      _sjXb::P64 = P64[Sp + 16];
      _sjXd::I64 = I64[Sp + 24];
      _sjXe::F64 = F64[Sp + 32];
      _sjXh::P64 = P64[Sp + 8];
      _sjXU::P64 = R1;
      _sjXX::P64 = P64[_sjXb::P64 + 8];
      _sjXX::P64 = _sjXX::P64;
      I64[Sp] = cktW;
      R1 = _sjXX::P64;
      if (R1 & 7 != 0) goto cktW; else goto cktZ;
  cktZ:
      call (I64[R1])(R1) returns to cktW, args: 8, res: 8, upd: 8;
  cktW:
      _sjXb::P64 = P64[Sp + 16];
      _sjXd::I64 = I64[Sp + 24];
      _sjXe::F64 = F64[Sp + 32];
      _sjXh::P64 = P64[Sp + 8];
      _sjXY::P64 = R1;
      Hp = Hp + 16;
      if (Hp > HpLim) goto cku5; else goto cku4;
  cku5:
      HpAlloc = 16;
      R1 = _sjXY::P64;
      call stg_gc_unpt_r1(R1) returns to cktW, args: 8, res: 8, upd: 8;
  cku4:
      _sjXZ::I64 = I64[_sjXY::P64 + 7];
      _sjY0::I64 = _sjXZ::I64;
      if (_sjY0::I64 != 18446744073709551615) goto cku8; else goto cku9;
  cku8:
      _ckuz::I64 = _sjY0::I64 + 1;
      _sjY1::I64 = _ckuz::I64;
      I64[Hp - 8] = GHC.Word.W64#_con_info;
      I64[Hp] = _sjY1::I64;
      _ckuC::P64 = Hp - 7;
      P64[_sjXb::P64 + 8] = _ckuC::P64;
      _ckuD::I64 = dirty_MUT_VAR;
      _ckuE::I64 = BaseReg;
      _ckuF::P64 = _sjXb::P64;
      call "ccall" arg hints:  [PtrHint,
                                PtrHint]  result hints:  [] (_ckuD::I64)(_ckuE::I64, _ckuF::P64);
      _sjXh::P64 = _sjXh::P64;
      goto ukuI;
  ukuI:
      Sp = Sp + 8;
      goto cksV;
  cktG:
      I64[Sp + 8] = cktC;
      R1 = lvl12_rjVc_closure+1;
      Sp = Sp + 8;
      call stg_norec_atomically#(R1) returns to cktC, args: 8, res: 8, upd: 8;
  cktC:
      _sjXb::P64 = P64[Sp + 16];
      _sjXd::I64 = I64[Sp + 24];
      _sjXe::F64 = F64[Sp + 32];
      _sjXh::P64 = P64[Sp + 8];
      _sjXH::P64 = R1;
      _sjXK::P64 = P64[_sjXb::P64 + 8];
      _sjXK::P64 = _sjXK::P64;
      I64[Sp] = cktE;
      R1 = _sjXK::P64;
      if (R1 & 7 != 0) goto cktE; else goto cktI;
  cktI:
      call (I64[R1])(R1) returns to cktE, args: 8, res: 8, upd: 8;
  cktE:
      _sjXb::P64 = P64[Sp + 16];
      _sjXd::I64 = I64[Sp + 24];
      _sjXe::F64 = F64[Sp + 32];
      _sjXh::P64 = P64[Sp + 8];
      _sjXL::P64 = R1;
      Hp = Hp + 16;
      if (Hp > HpLim) goto cktO; else goto cktN;
  cktO:
      HpAlloc = 16;
      R1 = _sjXL::P64;
      call stg_gc_unpt_r1(R1) returns to cktE, args: 8, res: 8, upd: 8;
  cktN:
      _sjXM::I64 = I64[_sjXL::P64 + 7];
      _sjXN::I64 = _sjXM::I64;
      if (_sjXN::I64 != 18446744073709551615) goto cktR; else goto cku9;
  cktR:
      _ckur::I64 = _sjXN::I64 + 1;
      _sjXO::I64 = _ckur::I64;
      I64[Hp - 8] = GHC.Word.W64#_con_info;
      I64[Hp] = _sjXO::I64;
      _ckuu::P64 = Hp - 7;
      P64[_sjXb::P64 + 8] = _ckuu::P64;
      _ckuv::I64 = dirty_MUT_VAR;
      _ckuw::I64 = BaseReg;
      _ckux::P64 = _sjXb::P64;
      call "ccall" arg hints:  [PtrHint,
                                PtrHint]  result hints:  [] (_ckuv::I64)(_ckuw::I64, _ckux::P64);
      _sjXh::P64 = _sjXh::P64;
      goto ukuJ;
  ukuJ:
      Sp = Sp + 8;
      goto cksV;
  cku9:
      Hp = Hp - 16;
      R1 = GHC.Word.$fEnumWord12_closure;
      Sp = Sp + 40;
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:53.223889 UTC

{offset
  cksP:
      _sjXe::F64 = D1;
      _sjXd::I64 = R4;
      _sjXc::P64 = R3;
      _sjXb::P64 = R2;
      if ((Sp + -48) < SpLim) goto cksQ; else goto cksR;
  cksR:
      Hp = Hp + 16;
      if (Hp > HpLim) goto cksT; else goto cksS;
  cksT:
      HpAlloc = 16;
      goto cksQ;
  cksQ:
      R1 = Main.$wa_closure;
      P64[Sp - 32] = _sjXb::P64;
      P64[Sp - 24] = _sjXc::P64;
      I64[Sp - 16] = _sjXd::I64;
      F64[Sp - 8] = _sjXe::F64;
      Sp = Sp - 32;
      call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
  cksS:
      I64[Hp - 8] = Data.Primitive.ByteArray.MutableByteArray_con_info;
      P64[Hp] = _sjXc::P64;
      _B2::P64 = Hp - 7;
      goto ckum;
  ckum:
      if (HpLim == 0) goto ckuo; else goto ckup;
  ckuo:
      I64[Sp - 32] = ckul;
      R1 = _B2::P64;
      P64[Sp - 24] = _sjXb::P64;
      I64[Sp - 16] = _sjXd::I64;
      F64[Sp - 8] = _sjXe::F64;
      Sp = Sp - 32;
      call stg_gc_unpt_r1(R1) returns to ckul, args: 8, res: 8, upd: 8;
  ckul:
      goto ukuG;
  ukuG:
      _sjXb::P64 = P64[Sp + 8];
      _sjXd::I64 = I64[Sp + 16];
      _sjXe::F64 = F64[Sp + 24];
      Sp = Sp + 32;
      _B2::P64 = R1;
      goto ckum;
  ckup:
      _sjY6::P64 = _B2::P64;
      goto ckub;
  ckub:
      if (HpLim == 0) goto ckue; else goto ckuf;
  ckue:
      I64[Sp - 32] = ckua;
      R1 = _sjY6::P64;
      P64[Sp - 24] = _sjXb::P64;
      I64[Sp - 16] = _sjXd::I64;
      F64[Sp - 8] = _sjXe::F64;
      Sp = Sp - 32;
      call stg_gc_unpt_r1(R1) returns to ckua, args: 8, res: 8, upd: 8;
  ckua:
      goto ukuH;
  ukuH:
      _sjXb::P64 = P64[Sp + 8];
      _sjXd::I64 = I64[Sp + 16];
      _sjXe::F64 = F64[Sp + 24];
      Sp = Sp + 32;
      _sjY6::P64 = R1;
      goto ckub;
  ckuf:
      I64[Sp - 32] = ckud;
      R1 = _sjY6::P64;
      P64[Sp - 24] = _sjXb::P64;
      I64[Sp - 16] = _sjXd::I64;
      F64[Sp - 8] = _sjXe::F64;
      Sp = Sp - 32;
      if (R1 & 7 != 0) goto ckud; else goto ckug;
  ckug:
      call (I64[R1])(R1) returns to ckud, args: 8, res: 8, upd: 8;
  ckud:
      _sjXh::P64 = P64[R1 + 7];
      goto cksV;
  cksV:
      if (HpLim == 0) goto cksY; else goto cksZ;
  cksY:
      I64[Sp] = cksU;
      R1 = _sjXh::P64;
      call stg_gc_unpt_r1(R1) returns to cksU, args: 8, res: 8, upd: 8;
  cksU:
      _sjXh::P64 = R1;
      goto cksV;
  cksZ:
      I64[Sp - 8] = cksX;
      R2 = I64[_sjXh::P64 + 16];
      P64[Sp] = _sjXh::P64;
      Sp = Sp - 8;
      call $wgo_rjVb_info(R2) returns to cksX, args: 8, res: 8, upd: 8;
  cksX:
      _sjXh::P64 = P64[Sp + 8];
      I64[_sjXh::P64 + 16] = R1;
      I64[Sp - 8] = cktc;
      R3 = I64[_sjXh::P64 + 16];
      _sjXo::I64 = R2;
      R2 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[Sp + 24] - 2));
      I64[Sp] = _sjXo::I64;
      Sp = Sp - 8;
      call System.Random.PCG.Fast.Pure.$wbounded_info(R3,
                                                      R2) returns to cktc, args: 8, res: 8, upd: 8;
  cktc:
      _sjXe::F64 = F64[Sp + 40];
      _sjXo::I64 = I64[Sp + 8];
      I64[P64[Sp + 16] + 16] = R1;
      (_cktj::F64) = call MO_UF_Conv W64(100000);
      (_cktn::F64) = call MO_UF_Conv W64(_sjXo::I64);
      if (%MO_F_Le_W64(%MO_F_Quot_W64(%MO_F_Mul_W64(_cktn::F64,
                                                    100.0 :: W64),
                                      _cktj::F64),
                       _sjXe::F64)) goto cktX; else goto cktG;
  cktX:
      I64[Sp + 8] = cktU;
      R1 = lvl12_rjVc_closure+1;
      Sp = Sp + 8;
      call stg_norec_atomically#(R1) returns to cktU, args: 8, res: 8, upd: 8;
  cktU:
      _sjXX::P64 = P64[P64[Sp + 16] + 8];
      I64[Sp] = cktW;
      R1 = _sjXX::P64;
      if (R1 & 7 != 0) goto cktW; else goto cktZ;
  cktZ:
      call (I64[R1])(R1) returns to cktW, args: 8, res: 8, upd: 8;
  cktW:
      Hp = Hp + 16;
      if (Hp > HpLim) goto cku5; else goto cku4;
  cku5:
      HpAlloc = 16;
      R1 = R1;
      call stg_gc_unpt_r1(R1) returns to cktW, args: 8, res: 8, upd: 8;
  cku4:
      _sjY0::I64 = I64[R1 + 7];
      if (_sjY0::I64 != 18446744073709551615) goto cku8; else goto cku9;
  cku8:
      I64[Hp - 8] = GHC.Word.W64#_con_info;
      I64[Hp] = _sjY0::I64 + 1;
      _sjXb::P64 = P64[Sp + 16];
      P64[_sjXb::P64 + 8] = Hp - 7;
      _sjXh::P64 = P64[Sp + 8];
      call "ccall" arg hints:  [PtrHint,
                                PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sjXb::P64);
      goto ukuI;
  ukuI:
      Sp = Sp + 8;
      goto cksV;
  cktG:
      I64[Sp + 8] = cktC;
      R1 = lvl12_rjVc_closure+1;
      Sp = Sp + 8;
      call stg_norec_atomically#(R1) returns to cktC, args: 8, res: 8, upd: 8;
  cktC:
      _sjXK::P64 = P64[P64[Sp + 16] + 8];
      I64[Sp] = cktE;
      R1 = _sjXK::P64;
      if (R1 & 7 != 0) goto cktE; else goto cktI;
  cktI:
      call (I64[R1])(R1) returns to cktE, args: 8, res: 8, upd: 8;
  cktE:
      Hp = Hp + 16;
      if (Hp > HpLim) goto cktO; else goto cktN;
  cktO:
      HpAlloc = 16;
      R1 = R1;
      call stg_gc_unpt_r1(R1) returns to cktE, args: 8, res: 8, upd: 8;
  cktN:
      _sjXN::I64 = I64[R1 + 7];
      if (_sjXN::I64 != 18446744073709551615) goto cktR; else goto cku9;
  cktR:
      I64[Hp - 8] = GHC.Word.W64#_con_info;
      I64[Hp] = _sjXN::I64 + 1;
      _sjXb::P64 = P64[Sp + 16];
      P64[_sjXb::P64 + 8] = Hp - 7;
      _sjXh::P64 = P64[Sp + 8];
      call "ccall" arg hints:  [PtrHint,
                                PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sjXb::P64);
      goto ukuJ;
  ukuJ:
      Sp = Sp + 8;
      goto cksV;
  cku9:
      Hp = Hp - 16;
      R1 = GHC.Word.$fEnumWord12_closure;
      Sp = Sp + 40;
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:53.234057 UTC

[(cksP,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure, Main.$wa_closure}),
 (cksQ, {Main.$wa_closure}),
 (cksR,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure, Main.$wa_closure}),
 (cksS,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure}),
 (cksT, {Main.$wa_closure}),
 (cksU,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure}),
 (cksV,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure}),
 (cksX,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure}),
 (cksY,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure}),
 (cksZ,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure}),
 (cktc,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure}),
 (cktC,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure}),
 (cktE,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure}),
 (cktG,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure}),
 (cktI,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure}),
 (cktN,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure}),
 (cktO,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure}),
 (cktR,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure}),
 (cktU,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure}),
 (cktW,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure}),
 (cktX,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure}),
 (cktZ,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure}),
 (cku4,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure}),
 (cku5,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure}),
 (cku8,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure}),
 (cku9, {GHC.Word.$fEnumWord12_closure}),
 (ckua,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure}),
 (ckub,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure}),
 (ckud,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure}),
 (ckue,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure}),
 (ckuf,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure}),
 (ckug,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure}),
 (ckul,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure}),
 (ckum,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure}),
 (ckuo,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure}),
 (ckup,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure}),
 (ukuG,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure}),
 (ukuH,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure}),
 (ukuI,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure}),
 (ukuJ,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:53.23842 UTC

Main.$wa_entry() //  [D1, R4, R3, R2]
        { info_tbl: [(cksP,
                      label: Main.$wa_info
                      rep:HeapRep static {
                            Fun {arity: 5 fun_type: ArgGen [False, False, True, True]} }),
                     (cksU,
                      label: block_cksU_info
                      rep:StackRep [False, True, True]),
                     (cksX,
                      label: block_cksX_info
                      rep:StackRep [False, False, True, True]),
                     (cktc,
                      label: block_cktc_info
                      rep:StackRep [True, False, False, True, True]),
                     (cktC,
                      label: block_cktC_info
                      rep:StackRep [False, False, True, True]),
                     (cktE,
                      label: block_cktE_info
                      rep:StackRep [False, False, True, True]),
                     (cktU,
                      label: block_cktU_info
                      rep:StackRep [False, False, True, True]),
                     (cktW,
                      label: block_cktW_info
                      rep:StackRep [False, False, True, True]),
                     (ckua,
                      label: block_ckua_info
                      rep:StackRep [False, True, True]),
                     (ckud,
                      label: block_ckud_info
                      rep:StackRep [False, True, True]),
                     (ckul,
                      label: block_ckul_info
                      rep:StackRep [False, True, True])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cksP:
          _sjXe::F64 = D1;
          _sjXd::I64 = R4;
          _sjXc::P64 = R3;
          _sjXb::P64 = R2;
          if ((Sp + -48) < SpLim) goto cksQ; else goto cksR;
      cksR:
          Hp = Hp + 16;
          if (Hp > HpLim) goto cksT; else goto cksS;
      cksT:
          HpAlloc = 16;
          goto cksQ;
      cksQ:
          R1 = Main.$wa_closure;
          P64[Sp - 32] = _sjXb::P64;
          P64[Sp - 24] = _sjXc::P64;
          I64[Sp - 16] = _sjXd::I64;
          F64[Sp - 8] = _sjXe::F64;
          Sp = Sp - 32;
          call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
      cksS:
          I64[Hp - 8] = Data.Primitive.ByteArray.MutableByteArray_con_info;
          P64[Hp] = _sjXc::P64;
          _B2::P64 = Hp - 7;
          goto ckum;
      ckum:
          if (HpLim == 0) goto ckuo; else goto ckup;
      ckuo:
          I64[Sp - 32] = ckul;
          R1 = _B2::P64;
          P64[Sp - 24] = _sjXb::P64;
          I64[Sp - 16] = _sjXd::I64;
          F64[Sp - 8] = _sjXe::F64;
          Sp = Sp - 32;
          call stg_gc_unpt_r1(R1) returns to ckul, args: 8, res: 8, upd: 8;
      ckul:
          goto ukuG;
      ukuG:
          _sjXb::P64 = P64[Sp + 8];
          _sjXd::I64 = I64[Sp + 16];
          _sjXe::F64 = F64[Sp + 24];
          Sp = Sp + 32;
          _B2::P64 = R1;
          goto ckum;
      ckup:
          _sjY6::P64 = _B2::P64;
          goto ckub;
      ckub:
          if (HpLim == 0) goto ckue; else goto ckuf;
      ckue:
          I64[Sp - 32] = ckua;
          R1 = _sjY6::P64;
          P64[Sp - 24] = _sjXb::P64;
          I64[Sp - 16] = _sjXd::I64;
          F64[Sp - 8] = _sjXe::F64;
          Sp = Sp - 32;
          call stg_gc_unpt_r1(R1) returns to ckua, args: 8, res: 8, upd: 8;
      ckua:
          goto ukuH;
      ukuH:
          _sjXb::P64 = P64[Sp + 8];
          _sjXd::I64 = I64[Sp + 16];
          _sjXe::F64 = F64[Sp + 24];
          Sp = Sp + 32;
          _sjY6::P64 = R1;
          goto ckub;
      ckuf:
          I64[Sp - 32] = ckud;
          R1 = _sjY6::P64;
          P64[Sp - 24] = _sjXb::P64;
          I64[Sp - 16] = _sjXd::I64;
          F64[Sp - 8] = _sjXe::F64;
          Sp = Sp - 32;
          if (R1 & 7 != 0) goto ckud; else goto ckug;
      ckug:
          call (I64[R1])(R1) returns to ckud, args: 8, res: 8, upd: 8;
      ckud:
          _sjXh::P64 = P64[R1 + 7];
          goto cksV;
      cksV:
          if (HpLim == 0) goto cksY; else goto cksZ;
      cksY:
          I64[Sp] = cksU;
          R1 = _sjXh::P64;
          call stg_gc_unpt_r1(R1) returns to cksU, args: 8, res: 8, upd: 8;
      cksU:
          _sjXh::P64 = R1;
          goto cksV;
      cksZ:
          I64[Sp - 8] = cksX;
          R2 = I64[_sjXh::P64 + 16];
          P64[Sp] = _sjXh::P64;
          Sp = Sp - 8;
          call $wgo_rjVb_info(R2) returns to cksX, args: 8, res: 8, upd: 8;
      cksX:
          _sjXh::P64 = P64[Sp + 8];
          I64[_sjXh::P64 + 16] = R1;
          I64[Sp - 8] = cktc;
          R3 = I64[_sjXh::P64 + 16];
          _sjXo::I64 = R2;
          R2 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[Sp + 24] - 2));
          I64[Sp] = _sjXo::I64;
          Sp = Sp - 8;
          call System.Random.PCG.Fast.Pure.$wbounded_info(R3,
                                                          R2) returns to cktc, args: 8, res: 8, upd: 8;
      cktc:
          _sjXe::F64 = F64[Sp + 40];
          _sjXo::I64 = I64[Sp + 8];
          I64[P64[Sp + 16] + 16] = R1;
          (_cktj::F64) = call MO_UF_Conv W64(100000);
          (_cktn::F64) = call MO_UF_Conv W64(_sjXo::I64);
          if (%MO_F_Le_W64(%MO_F_Quot_W64(%MO_F_Mul_W64(_cktn::F64,
                                                        100.0 :: W64),
                                          _cktj::F64),
                           _sjXe::F64)) goto cktX; else goto cktG;
      cktX:
          I64[Sp + 8] = cktU;
          R1 = lvl12_rjVc_closure+1;
          Sp = Sp + 8;
          call stg_norec_atomically#(R1) returns to cktU, args: 8, res: 8, upd: 8;
      cktU:
          _sjXX::P64 = P64[P64[Sp + 16] + 8];
          I64[Sp] = cktW;
          R1 = _sjXX::P64;
          if (R1 & 7 != 0) goto cktW; else goto cktZ;
      cktZ:
          call (I64[R1])(R1) returns to cktW, args: 8, res: 8, upd: 8;
      cktW:
          Hp = Hp + 16;
          if (Hp > HpLim) goto cku5; else goto cku4;
      cku5:
          HpAlloc = 16;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to cktW, args: 8, res: 8, upd: 8;
      cku4:
          _sjY0::I64 = I64[R1 + 7];
          if (_sjY0::I64 != 18446744073709551615) goto cku8; else goto cku9;
      cku8:
          I64[Hp - 8] = GHC.Word.W64#_con_info;
          I64[Hp] = _sjY0::I64 + 1;
          _sjXb::P64 = P64[Sp + 16];
          P64[_sjXb::P64 + 8] = Hp - 7;
          _sjXh::P64 = P64[Sp + 8];
          call "ccall" arg hints:  [PtrHint,
                                    PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sjXb::P64);
          goto ukuI;
      ukuI:
          Sp = Sp + 8;
          goto cksV;
      cktG:
          I64[Sp + 8] = cktC;
          R1 = lvl12_rjVc_closure+1;
          Sp = Sp + 8;
          call stg_norec_atomically#(R1) returns to cktC, args: 8, res: 8, upd: 8;
      cktC:
          _sjXK::P64 = P64[P64[Sp + 16] + 8];
          I64[Sp] = cktE;
          R1 = _sjXK::P64;
          if (R1 & 7 != 0) goto cktE; else goto cktI;
      cktI:
          call (I64[R1])(R1) returns to cktE, args: 8, res: 8, upd: 8;
      cktE:
          Hp = Hp + 16;
          if (Hp > HpLim) goto cktO; else goto cktN;
      cktO:
          HpAlloc = 16;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to cktE, args: 8, res: 8, upd: 8;
      cktN:
          _sjXN::I64 = I64[R1 + 7];
          if (_sjXN::I64 != 18446744073709551615) goto cktR; else goto cku9;
      cktR:
          I64[Hp - 8] = GHC.Word.W64#_con_info;
          I64[Hp] = _sjXN::I64 + 1;
          _sjXb::P64 = P64[Sp + 16];
          P64[_sjXb::P64 + 8] = Hp - 7;
          _sjXh::P64 = P64[Sp + 8];
          call "ccall" arg hints:  [PtrHint,
                                    PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sjXb::P64);
          goto ukuJ;
      ukuJ:
          Sp = Sp + 8;
          goto cksV;
      cku9:
          Hp = Hp - 16;
          R1 = GHC.Word.$fEnumWord12_closure;
          Sp = Sp + 40;
          call (I64[R1])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:53.248808 UTC

Main.$wa_entry() //  [D1, R4, R3, R2]
        { info_tbl: [(cksP,
                      label: Main.$wa_info
                      rep:HeapRep static {
                            Fun {arity: 5 fun_type: ArgGen [False, False, True, True]} }),
                     (cksU,
                      label: block_cksU_info
                      rep:StackRep [False, True, True]),
                     (cksX,
                      label: block_cksX_info
                      rep:StackRep [False, False, True, True]),
                     (cktc,
                      label: block_cktc_info
                      rep:StackRep [True, False, False, True, True]),
                     (cktC,
                      label: block_cktC_info
                      rep:StackRep [False, False, True, True]),
                     (cktE,
                      label: block_cktE_info
                      rep:StackRep [False, False, True, True]),
                     (cktU,
                      label: block_cktU_info
                      rep:StackRep [False, False, True, True]),
                     (cktW,
                      label: block_cktW_info
                      rep:StackRep [False, False, True, True]),
                     (ckua,
                      label: block_ckua_info
                      rep:StackRep [False, True, True]),
                     (ckud,
                      label: block_ckud_info
                      rep:StackRep [False, True, True]),
                     (ckul,
                      label: block_ckul_info
                      rep:StackRep [False, True, True])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cksP:
          _sjXe::F64 = D1;
          _sjXd::I64 = R4;
          _sjXc::P64 = R3;
          _sjXb::P64 = R2;
          if ((Sp + -48) < SpLim) goto cksQ; else goto cksR;
      cksR:
          Hp = Hp + 16;
          if (Hp > HpLim) goto cksT; else goto cksS;
      cksT:
          HpAlloc = 16;
          goto cksQ;
      cksQ:
          R1 = Main.$wa_closure;
          P64[Sp - 32] = _sjXb::P64;
          P64[Sp - 24] = _sjXc::P64;
          I64[Sp - 16] = _sjXd::I64;
          F64[Sp - 8] = _sjXe::F64;
          Sp = Sp - 32;
          call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
      cksS:
          I64[Hp - 8] = Data.Primitive.ByteArray.MutableByteArray_con_info;
          P64[Hp] = _sjXc::P64;
          _B2::P64 = Hp - 7;
          goto ckum;
      ckum:
          if (HpLim == 0) goto ckuo; else goto ckup;
      ckuo:
          I64[Sp - 32] = ckul;
          R1 = _B2::P64;
          P64[Sp - 24] = _sjXb::P64;
          I64[Sp - 16] = _sjXd::I64;
          F64[Sp - 8] = _sjXe::F64;
          Sp = Sp - 32;
          call stg_gc_unpt_r1(R1) returns to ckul, args: 8, res: 8, upd: 8;
      ckul:
          _sjXb::P64 = P64[Sp + 8];
          _sjXd::I64 = I64[Sp + 16];
          _sjXe::F64 = F64[Sp + 24];
          Sp = Sp + 32;
          _B2::P64 = R1;
          goto ckum;
      ckup:
          _sjY6::P64 = _B2::P64;
          goto ckub;
      ckub:
          if (HpLim == 0) goto ckue; else goto ckuf;
      ckue:
          I64[Sp - 32] = ckua;
          R1 = _sjY6::P64;
          P64[Sp - 24] = _sjXb::P64;
          I64[Sp - 16] = _sjXd::I64;
          F64[Sp - 8] = _sjXe::F64;
          Sp = Sp - 32;
          call stg_gc_unpt_r1(R1) returns to ckua, args: 8, res: 8, upd: 8;
      ckua:
          _sjXb::P64 = P64[Sp + 8];
          _sjXd::I64 = I64[Sp + 16];
          _sjXe::F64 = F64[Sp + 24];
          Sp = Sp + 32;
          _sjY6::P64 = R1;
          goto ckub;
      ckuf:
          I64[Sp - 32] = ckud;
          R1 = _sjY6::P64;
          P64[Sp - 24] = _sjXb::P64;
          I64[Sp - 16] = _sjXd::I64;
          F64[Sp - 8] = _sjXe::F64;
          Sp = Sp - 32;
          if (R1 & 7 != 0) goto ckud; else goto ckug;
      ckug:
          call (I64[R1])(R1) returns to ckud, args: 8, res: 8, upd: 8;
      ckud:
          _sjXh::P64 = P64[R1 + 7];
          goto cksV;
      cksV:
          if (HpLim == 0) goto cksY; else goto cksZ;
      cksY:
          I64[Sp] = cksU;
          R1 = _sjXh::P64;
          call stg_gc_unpt_r1(R1) returns to cksU, args: 8, res: 8, upd: 8;
      cksU:
          _sjXh::P64 = R1;
          goto cksV;
      cksZ:
          I64[Sp - 8] = cksX;
          R2 = I64[_sjXh::P64 + 16];
          P64[Sp] = _sjXh::P64;
          Sp = Sp - 8;
          call $wgo_rjVb_info(R2) returns to cksX, args: 8, res: 8, upd: 8;
      cksX:
          _sjXh::P64 = P64[Sp + 8];
          I64[_sjXh::P64 + 16] = R1;
          I64[Sp - 8] = cktc;
          R3 = I64[_sjXh::P64 + 16];
          _sjXo::I64 = R2;
          R2 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[Sp + 24] - 2));
          I64[Sp] = _sjXo::I64;
          Sp = Sp - 8;
          call System.Random.PCG.Fast.Pure.$wbounded_info(R3,
                                                          R2) returns to cktc, args: 8, res: 8, upd: 8;
      cktc:
          _sjXe::F64 = F64[Sp + 40];
          _sjXo::I64 = I64[Sp + 8];
          I64[P64[Sp + 16] + 16] = R1;
          (_cktj::F64) = call MO_UF_Conv W64(100000);
          (_cktn::F64) = call MO_UF_Conv W64(_sjXo::I64);
          if (%MO_F_Le_W64(%MO_F_Quot_W64(%MO_F_Mul_W64(_cktn::F64,
                                                        100.0 :: W64),
                                          _cktj::F64),
                           _sjXe::F64)) goto cktX; else goto cktG;
      cktX:
          I64[Sp + 8] = cktU;
          R1 = lvl12_rjVc_closure+1;
          Sp = Sp + 8;
          call stg_norec_atomically#(R1) returns to cktU, args: 8, res: 8, upd: 8;
      cktU:
          _sjXX::P64 = P64[P64[Sp + 16] + 8];
          I64[Sp] = cktW;
          R1 = _sjXX::P64;
          if (R1 & 7 != 0) goto cktW; else goto cktZ;
      cktZ:
          call (I64[R1])(R1) returns to cktW, args: 8, res: 8, upd: 8;
      cktW:
          Hp = Hp + 16;
          if (Hp > HpLim) goto cku5; else goto cku4;
      cku5:
          HpAlloc = 16;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to cktW, args: 8, res: 8, upd: 8;
      cku4:
          _sjY0::I64 = I64[R1 + 7];
          if (_sjY0::I64 == 18446744073709551615) goto cku9; else goto cku8;
      cku8:
          I64[Hp - 8] = GHC.Word.W64#_con_info;
          I64[Hp] = _sjY0::I64 + 1;
          _sjXb::P64 = P64[Sp + 16];
          P64[_sjXb::P64 + 8] = Hp - 7;
          _sjXh::P64 = P64[Sp + 8];
          call "ccall" arg hints:  [PtrHint,
                                    PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sjXb::P64);
          Sp = Sp + 8;
          goto cksV;
      cktG:
          I64[Sp + 8] = cktC;
          R1 = lvl12_rjVc_closure+1;
          Sp = Sp + 8;
          call stg_norec_atomically#(R1) returns to cktC, args: 8, res: 8, upd: 8;
      cktC:
          _sjXK::P64 = P64[P64[Sp + 16] + 8];
          I64[Sp] = cktE;
          R1 = _sjXK::P64;
          if (R1 & 7 != 0) goto cktE; else goto cktI;
      cktI:
          call (I64[R1])(R1) returns to cktE, args: 8, res: 8, upd: 8;
      cktE:
          Hp = Hp + 16;
          if (Hp > HpLim) goto cktO; else goto cktN;
      cktO:
          HpAlloc = 16;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to cktE, args: 8, res: 8, upd: 8;
      cktN:
          _sjXN::I64 = I64[R1 + 7];
          if (_sjXN::I64 == 18446744073709551615) goto cku9; else goto cktR;
      cku9:
          Hp = Hp - 16;
          R1 = GHC.Word.$fEnumWord12_closure;
          Sp = Sp + 40;
          call (I64[R1])(R1) args: 8, res: 0, upd: 8;
      cktR:
          I64[Hp - 8] = GHC.Word.W64#_con_info;
          I64[Hp] = _sjXN::I64 + 1;
          _sjXb::P64 = P64[Sp + 16];
          P64[_sjXb::P64 + 8] = Hp - 7;
          _sjXh::P64 = P64[Sp + 8];
          call "ccall" arg hints:  [PtrHint,
                                    PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sjXb::P64);
          Sp = Sp + 8;
          goto cksV;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:53.259284 UTC

[section "data" {
     Main.$wa_closure:
         const Main.$wa_info;
         const 0;
 },
 Main.$wa_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 40 updfr_space: Just 8
         }
     {offset
       cksE:
           D1 = F64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call Main.$wa_info(D1, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Main.$wa_entry() //  [D1, R4, R3, R2]
         { info_tbl: [(cksP,
                       label: Main.$wa_info
                       rep:HeapRep static {
                             Fun {arity: 5 fun_type: ArgGen [False, False, True, True]} }),
                      (cksU,
                       label: block_cksU_info
                       rep:StackRep [False, True, True]),
                      (cksX,
                       label: block_cksX_info
                       rep:StackRep [False, False, True, True]),
                      (cktc,
                       label: block_cktc_info
                       rep:StackRep [True, False, False, True, True]),
                      (cktC,
                       label: block_cktC_info
                       rep:StackRep [False, False, True, True]),
                      (cktE,
                       label: block_cktE_info
                       rep:StackRep [False, False, True, True]),
                      (cktU,
                       label: block_cktU_info
                       rep:StackRep [False, False, True, True]),
                      (cktW,
                       label: block_cktW_info
                       rep:StackRep [False, False, True, True]),
                      (ckua,
                       label: block_ckua_info
                       rep:StackRep [False, True, True]),
                      (ckud,
                       label: block_ckud_info
                       rep:StackRep [False, True, True]),
                      (ckul,
                       label: block_ckul_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cksP:
           _sjXe::F64 = D1;
           _sjXd::I64 = R4;
           _sjXc::P64 = R3;
           _sjXb::P64 = R2;
           if ((Sp + -48) < SpLim) goto cksQ; else goto cksR;
       cksR:
           Hp = Hp + 16;
           if (Hp > HpLim) goto cksT; else goto cksS;
       cksT:
           HpAlloc = 16;
           goto cksQ;
       cksQ:
           R1 = Main.$wa_closure;
           P64[Sp - 32] = _sjXb::P64;
           P64[Sp - 24] = _sjXc::P64;
           I64[Sp - 16] = _sjXd::I64;
           F64[Sp - 8] = _sjXe::F64;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       cksS:
           I64[Hp - 8] = Data.Primitive.ByteArray.MutableByteArray_con_info;
           P64[Hp] = _sjXc::P64;
           _B2::P64 = Hp - 7;
           goto ckum;
       ckum:
           if (HpLim == 0) goto ckuo; else goto ckup;
       ckuo:
           I64[Sp - 32] = ckul;
           R1 = _B2::P64;
           P64[Sp - 24] = _sjXb::P64;
           I64[Sp - 16] = _sjXd::I64;
           F64[Sp - 8] = _sjXe::F64;
           Sp = Sp - 32;
           call stg_gc_unpt_r1(R1) returns to ckul, args: 8, res: 8, upd: 8;
       ckul:
           _sjXb::P64 = P64[Sp + 8];
           _sjXd::I64 = I64[Sp + 16];
           _sjXe::F64 = F64[Sp + 24];
           Sp = Sp + 32;
           _B2::P64 = R1;
           goto ckum;
       ckup:
           _sjY6::P64 = _B2::P64;
           goto ckub;
       ckub:
           if (HpLim == 0) goto ckue; else goto ckuf;
       ckue:
           I64[Sp - 32] = ckua;
           R1 = _sjY6::P64;
           P64[Sp - 24] = _sjXb::P64;
           I64[Sp - 16] = _sjXd::I64;
           F64[Sp - 8] = _sjXe::F64;
           Sp = Sp - 32;
           call stg_gc_unpt_r1(R1) returns to ckua, args: 8, res: 8, upd: 8;
       ckua:
           _sjXb::P64 = P64[Sp + 8];
           _sjXd::I64 = I64[Sp + 16];
           _sjXe::F64 = F64[Sp + 24];
           Sp = Sp + 32;
           _sjY6::P64 = R1;
           goto ckub;
       ckuf:
           I64[Sp - 32] = ckud;
           R1 = _sjY6::P64;
           P64[Sp - 24] = _sjXb::P64;
           I64[Sp - 16] = _sjXd::I64;
           F64[Sp - 8] = _sjXe::F64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ckud; else goto ckug;
       ckug:
           call (I64[R1])(R1) returns to ckud, args: 8, res: 8, upd: 8;
       ckud:
           _sjXh::P64 = P64[R1 + 7];
           goto cksV;
       cksV:
           if (HpLim == 0) goto cksY; else goto cksZ;
       cksY:
           I64[Sp] = cksU;
           R1 = _sjXh::P64;
           call stg_gc_unpt_r1(R1) returns to cksU, args: 8, res: 8, upd: 8;
       cksU:
           _sjXh::P64 = R1;
           goto cksV;
       cksZ:
           I64[Sp - 8] = cksX;
           R2 = I64[_sjXh::P64 + 16];
           P64[Sp] = _sjXh::P64;
           Sp = Sp - 8;
           call $wgo_rjVb_info(R2) returns to cksX, args: 8, res: 8, upd: 8;
       cksX:
           _sjXh::P64 = P64[Sp + 8];
           I64[_sjXh::P64 + 16] = R1;
           I64[Sp - 8] = cktc;
           R3 = I64[_sjXh::P64 + 16];
           _sjXo::I64 = R2;
           R2 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[Sp + 24] - 2));
           I64[Sp] = _sjXo::I64;
           Sp = Sp - 8;
           call System.Random.PCG.Fast.Pure.$wbounded_info(R3,
                                                           R2) returns to cktc, args: 8, res: 8, upd: 8;
       cktc:
           _sjXe::F64 = F64[Sp + 40];
           _sjXo::I64 = I64[Sp + 8];
           I64[P64[Sp + 16] + 16] = R1;
           (_cktj::F64) = call MO_UF_Conv W64(100000);
           (_cktn::F64) = call MO_UF_Conv W64(_sjXo::I64);
           if (%MO_F_Le_W64(%MO_F_Quot_W64(%MO_F_Mul_W64(_cktn::F64,
                                                         100.0 :: W64),
                                           _cktj::F64),
                            _sjXe::F64)) goto cktX; else goto cktG;
       cktX:
           I64[Sp + 8] = cktU;
           R1 = lvl12_rjVc_closure+1;
           Sp = Sp + 8;
           call stg_norec_atomically#(R1) returns to cktU, args: 8, res: 8, upd: 8;
       cktU:
           _sjXX::P64 = P64[P64[Sp + 16] + 8];
           I64[Sp] = cktW;
           R1 = _sjXX::P64;
           if (R1 & 7 != 0) goto cktW; else goto cktZ;
       cktZ:
           call (I64[R1])(R1) returns to cktW, args: 8, res: 8, upd: 8;
       cktW:
           Hp = Hp + 16;
           if (Hp > HpLim) goto cku5; else goto cku4;
       cku5:
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to cktW, args: 8, res: 8, upd: 8;
       cku4:
           _sjY0::I64 = I64[R1 + 7];
           if (_sjY0::I64 == 18446744073709551615) goto cku9; else goto cku8;
       cku8:
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _sjY0::I64 + 1;
           _sjXb::P64 = P64[Sp + 16];
           P64[_sjXb::P64 + 8] = Hp - 7;
           _sjXh::P64 = P64[Sp + 8];
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sjXb::P64);
           Sp = Sp + 8;
           goto cksV;
       cktG:
           I64[Sp + 8] = cktC;
           R1 = lvl12_rjVc_closure+1;
           Sp = Sp + 8;
           call stg_norec_atomically#(R1) returns to cktC, args: 8, res: 8, upd: 8;
       cktC:
           _sjXK::P64 = P64[P64[Sp + 16] + 8];
           I64[Sp] = cktE;
           R1 = _sjXK::P64;
           if (R1 & 7 != 0) goto cktE; else goto cktI;
       cktI:
           call (I64[R1])(R1) returns to cktE, args: 8, res: 8, upd: 8;
       cktE:
           Hp = Hp + 16;
           if (Hp > HpLim) goto cktO; else goto cktN;
       cktO:
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to cktE, args: 8, res: 8, upd: 8;
       cktN:
           _sjXN::I64 = I64[R1 + 7];
           if (_sjXN::I64 == 18446744073709551615) goto cku9; else goto cktR;
       cku9:
           Hp = Hp - 16;
           R1 = GHC.Word.$fEnumWord12_closure;
           Sp = Sp + 40;
           call (I64[R1])(R1) args: 8, res: 0, upd: 8;
       cktR:
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _sjXN::I64 + 1;
           _sjXb::P64 = P64[Sp + 16];
           P64[_sjXb::P64 + 8] = Hp - 7;
           _sjXh::P64 = P64[Sp + 8];
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sjXb::P64);
           Sp = Sp + 8;
           goto cksV;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:53.270803 UTC

[section "data" {
     Main.$wa_closure:
         const Main.$wa_info;
         const 0;
 },
 Main.$wa_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 40 updfr_space: Just 8
         }
     {offset
       cksE:
           D1 = F64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 32;
           call Main.$wa_info(D1, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 Main.$wa_entry() //  [D1, R4, R3, R2]
         { info_tbl: [(cksP,
                       label: Main.$wa_info
                       rep:HeapRep static {
                             Fun {arity: 5 fun_type: ArgGen [False, False, True, True]} }),
                      (cksU,
                       label: block_cksU_info
                       rep:StackRep [False, True, True]),
                      (cksX,
                       label: block_cksX_info
                       rep:StackRep [False, False, True, True]),
                      (cktc,
                       label: block_cktc_info
                       rep:StackRep [True, False, False, True, True]),
                      (cktC,
                       label: block_cktC_info
                       rep:StackRep [False, False, True, True]),
                      (cktE,
                       label: block_cktE_info
                       rep:StackRep [False, False, True, True]),
                      (cktU,
                       label: block_cktU_info
                       rep:StackRep [False, False, True, True]),
                      (cktW,
                       label: block_cktW_info
                       rep:StackRep [False, False, True, True]),
                      (ckua,
                       label: block_ckua_info
                       rep:StackRep [False, True, True]),
                      (ckud,
                       label: block_ckud_info
                       rep:StackRep [False, True, True]),
                      (ckul,
                       label: block_ckul_info
                       rep:StackRep [False, True, True])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cksP:
           _sjXe::F64 = D1;
           _sjXd::I64 = R4;
           _sjXc::P64 = R3;
           _sjXb::P64 = R2;
           if ((Sp + -48) < SpLim) goto cksQ; else goto cksR;
       cksR:
           Hp = Hp + 16;
           if (Hp > HpLim) goto cksT; else goto cksS;
       cksT:
           HpAlloc = 16;
           goto cksQ;
       cksQ:
           R1 = Main.$wa_closure;
           P64[Sp - 32] = _sjXb::P64;
           P64[Sp - 24] = _sjXc::P64;
           I64[Sp - 16] = _sjXd::I64;
           F64[Sp - 8] = _sjXe::F64;
           Sp = Sp - 32;
           call (stg_gc_fun)(R1) args: 40, res: 0, upd: 8;
       cksS:
           I64[Hp - 8] = Data.Primitive.ByteArray.MutableByteArray_con_info;
           P64[Hp] = _sjXc::P64;
           _B2::P64 = Hp - 7;
           goto ckum;
       ckum:
           if (HpLim == 0) goto ckuo; else goto ckup;
       ckuo:
           I64[Sp - 32] = ckul;
           R1 = _B2::P64;
           P64[Sp - 24] = _sjXb::P64;
           I64[Sp - 16] = _sjXd::I64;
           F64[Sp - 8] = _sjXe::F64;
           Sp = Sp - 32;
           call stg_gc_unpt_r1(R1) returns to ckul, args: 8, res: 8, upd: 8;
       ckul:
           _sjXb::P64 = P64[Sp + 8];
           _sjXd::I64 = I64[Sp + 16];
           _sjXe::F64 = F64[Sp + 24];
           Sp = Sp + 32;
           _B2::P64 = R1;
           goto ckum;
       ckup:
           _sjY6::P64 = _B2::P64;
           goto ckub;
       ckub:
           if (HpLim == 0) goto ckue; else goto ckuf;
       ckue:
           I64[Sp - 32] = ckua;
           R1 = _sjY6::P64;
           P64[Sp - 24] = _sjXb::P64;
           I64[Sp - 16] = _sjXd::I64;
           F64[Sp - 8] = _sjXe::F64;
           Sp = Sp - 32;
           call stg_gc_unpt_r1(R1) returns to ckua, args: 8, res: 8, upd: 8;
       ckua:
           _sjXb::P64 = P64[Sp + 8];
           _sjXd::I64 = I64[Sp + 16];
           _sjXe::F64 = F64[Sp + 24];
           Sp = Sp + 32;
           _sjY6::P64 = R1;
           goto ckub;
       ckuf:
           I64[Sp - 32] = ckud;
           R1 = _sjY6::P64;
           P64[Sp - 24] = _sjXb::P64;
           I64[Sp - 16] = _sjXd::I64;
           F64[Sp - 8] = _sjXe::F64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ckud; else goto ckug;
       ckug:
           call (I64[R1])(R1) returns to ckud, args: 8, res: 8, upd: 8;
       ckud:
           _sjXh::P64 = P64[R1 + 7];
           goto cksV;
       cksV:
           if (HpLim == 0) goto cksY; else goto cksZ;
       cksY:
           I64[Sp] = cksU;
           R1 = _sjXh::P64;
           call stg_gc_unpt_r1(R1) returns to cksU, args: 8, res: 8, upd: 8;
       cksU:
           _sjXh::P64 = R1;
           goto cksV;
       cksZ:
           I64[Sp - 8] = cksX;
           R2 = I64[_sjXh::P64 + 16];
           P64[Sp] = _sjXh::P64;
           Sp = Sp - 8;
           call $wgo_rjVb_info(R2) returns to cksX, args: 8, res: 8, upd: 8;
       cksX:
           _sjXh::P64 = P64[Sp + 8];
           I64[_sjXh::P64 + 16] = R1;
           I64[Sp - 8] = cktc;
           R3 = I64[_sjXh::P64 + 16];
           _sjXo::I64 = R2;
           R2 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[Sp + 24] - 2));
           I64[Sp] = _sjXo::I64;
           Sp = Sp - 8;
           call System.Random.PCG.Fast.Pure.$wbounded_info(R3,
                                                           R2) returns to cktc, args: 8, res: 8, upd: 8;
       cktc:
           _sjXe::F64 = F64[Sp + 40];
           _sjXo::I64 = I64[Sp + 8];
           I64[P64[Sp + 16] + 16] = R1;
           (_cktj::F64) = call MO_UF_Conv W64(100000);
           (_cktn::F64) = call MO_UF_Conv W64(_sjXo::I64);
           if (%MO_F_Le_W64(%MO_F_Quot_W64(%MO_F_Mul_W64(_cktn::F64,
                                                         100.0 :: W64),
                                           _cktj::F64),
                            _sjXe::F64)) goto cktX; else goto cktG;
       cktX:
           I64[Sp + 8] = cktU;
           R1 = lvl12_rjVc_closure+1;
           Sp = Sp + 8;
           call stg_norec_atomically#(R1) returns to cktU, args: 8, res: 8, upd: 8;
       cktU:
           _sjXX::P64 = P64[P64[Sp + 16] + 8];
           I64[Sp] = cktW;
           R1 = _sjXX::P64;
           if (R1 & 7 != 0) goto cktW; else goto cktZ;
       cktZ:
           call (I64[R1])(R1) returns to cktW, args: 8, res: 8, upd: 8;
       cktW:
           Hp = Hp + 16;
           if (Hp > HpLim) goto cku5; else goto cku4;
       cku5:
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to cktW, args: 8, res: 8, upd: 8;
       cku4:
           _sjY0::I64 = I64[R1 + 7];
           if (_sjY0::I64 == 18446744073709551615) goto cku9; else goto cku8;
       cku8:
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _sjY0::I64 + 1;
           _sjXb::P64 = P64[Sp + 16];
           P64[_sjXb::P64 + 8] = Hp - 7;
           _sjXh::P64 = P64[Sp + 8];
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sjXb::P64);
           Sp = Sp + 8;
           goto cksV;
       cktG:
           I64[Sp + 8] = cktC;
           R1 = lvl12_rjVc_closure+1;
           Sp = Sp + 8;
           call stg_norec_atomically#(R1) returns to cktC, args: 8, res: 8, upd: 8;
       cktC:
           _sjXK::P64 = P64[P64[Sp + 16] + 8];
           I64[Sp] = cktE;
           R1 = _sjXK::P64;
           if (R1 & 7 != 0) goto cktE; else goto cktI;
       cktI:
           call (I64[R1])(R1) returns to cktE, args: 8, res: 8, upd: 8;
       cktE:
           Hp = Hp + 16;
           if (Hp > HpLim) goto cktO; else goto cktN;
       cktO:
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to cktE, args: 8, res: 8, upd: 8;
       cktN:
           _sjXN::I64 = I64[R1 + 7];
           if (_sjXN::I64 == 18446744073709551615) goto cku9; else goto cktR;
       cku9:
           Hp = Hp - 16;
           R1 = GHC.Word.$fEnumWord12_closure;
           Sp = Sp + 40;
           call (I64[R1])(R1) args: 8, res: 0, upd: 8;
       cktR:
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _sjXN::I64 + 1;
           _sjXb::P64 = P64[Sp + 16];
           P64[_sjXb::P64 + 8] = Hp - 7;
           _sjXh::P64 = P64[Sp + 8];
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sjXb::P64);
           Sp = Sp + 8;
           goto cksV;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:53.30165 UTC

[section "data" {
     Main.runRSTMEmpty1_closure:
         const Main.runRSTMEmpty1_info;
         const 0;
 },
 Main.runRSTMEmpty1_entry() //  [R6, R5, R4, R3, R2]
         { info_tbl: [(ckvr,
                       label: Main.runRSTMEmpty1_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckvr:
           _sjYg::P64 = R6;
           _sjYf::P64 = R5;
           _sjYe::P64 = R4;
           _sjYd::P64 = R3;
           _sjYc::P64 = R2;
           goto ckvm;
       ckvm:
           if ((old + 0) - <highSp> < SpLim) goto ckvF; else goto ckvG;
       ckvG:
           goto ckvl;
       ckvl:
           if (HpLim == 0) goto ckvF; else goto ckvH;
       ckvF:
           R6 = _sjYg::P64;
           R5 = _sjYf::P64;
           R4 = _sjYe::P64;
           R3 = _sjYd::P64;
           R2 = _sjYc::P64;
           R1 = Main.runRSTMEmpty1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckvH:
           I64[(young<ckvo> + 8)] = ckvo;
           R1 = _sjYc::P64;
           if (R1 & 7 != 0) goto ckvo; else goto ckvp;
       ckvp:
           call (I64[R1])(R1) returns to ckvo, args: 8, res: 8, upd: 8;
       ckvo:
           _sjYi::P64 = R1;
           _sjYj::P64 = P64[_sjYi::P64 + 7];
           I64[(young<ckvu> + 8)] = ckvu;
           R1 = _sjYd::P64;
           if (R1 & 7 != 0) goto ckvu; else goto ckvv;
       ckvv:
           call (I64[R1])(R1) returns to ckvu, args: 8, res: 8, upd: 8;
       ckvu:
           _sjYk::P64 = R1;
           _sjYl::P64 = P64[_sjYk::P64 + 7];
           I64[(young<ckvz> + 8)] = ckvz;
           R1 = _sjYf::P64;
           if (R1 & 7 != 0) goto ckvz; else goto ckvA;
       ckvA:
           call (I64[R1])(R1) returns to ckvz, args: 8, res: 8, upd: 8;
       ckvz:
           _sjYm::P64 = R1;
           _sjYn::I64 = I64[_sjYm::P64 + 7];
           I64[(young<ckvE> + 8)] = ckvE;
           R1 = _sjYg::P64;
           if (R1 & 7 != 0) goto ckvE; else goto ckvL;
       ckvL:
           call (I64[R1])(R1) returns to ckvE, args: 8, res: 8, upd: 8;
       ckvE:
           _sjYo::P64 = R1;
           _sjYp::F64 = F64[_sjYo::P64 + 7];
           D1 = _sjYp::F64;
           R4 = _sjYn::I64;
           R3 = _sjYl::P64;
           R2 = _sjYj::P64;
           call Main.$wa_info(D1, R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:53.306367 UTC

{offset
  ckvr:
      _sjYg::P64 = R6;
      _sjYf::P64 = R5;
      _sjYe::P64 = R4;
      _sjYd::P64 = R3;
      _sjYc::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckvF; else goto ckvG;
  ckvG:
      if (HpLim == 0) goto ckvF; else goto ckvH;
  ckvF:
      R6 = _sjYg::P64;
      R5 = _sjYf::P64;
      R4 = _sjYe::P64;
      R3 = _sjYd::P64;
      R2 = _sjYc::P64;
      R1 = Main.runRSTMEmpty1_closure;
      call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  ckvH:
      I64[(young<ckvo> + 8)] = ckvo;
      R1 = _sjYc::P64;
      if (R1 & 7 != 0) goto ckvo; else goto ckvp;
  ckvp:
      call (I64[R1])(R1) returns to ckvo, args: 8, res: 8, upd: 8;
  ckvo:
      _sjYi::P64 = R1;
      _sjYj::P64 = P64[_sjYi::P64 + 7];
      I64[(young<ckvu> + 8)] = ckvu;
      R1 = _sjYd::P64;
      if (R1 & 7 != 0) goto ckvu; else goto ckvv;
  ckvv:
      call (I64[R1])(R1) returns to ckvu, args: 8, res: 8, upd: 8;
  ckvu:
      _sjYk::P64 = R1;
      _sjYl::P64 = P64[_sjYk::P64 + 7];
      I64[(young<ckvz> + 8)] = ckvz;
      R1 = _sjYf::P64;
      if (R1 & 7 != 0) goto ckvz; else goto ckvA;
  ckvA:
      call (I64[R1])(R1) returns to ckvz, args: 8, res: 8, upd: 8;
  ckvz:
      _sjYm::P64 = R1;
      _sjYn::I64 = I64[_sjYm::P64 + 7];
      I64[(young<ckvE> + 8)] = ckvE;
      R1 = _sjYg::P64;
      if (R1 & 7 != 0) goto ckvE; else goto ckvL;
  ckvL:
      call (I64[R1])(R1) returns to ckvE, args: 8, res: 8, upd: 8;
  ckvE:
      _sjYo::P64 = R1;
      _sjYp::F64 = F64[_sjYo::P64 + 7];
      D1 = _sjYp::F64;
      R4 = _sjYn::I64;
      R3 = _sjYl::P64;
      R2 = _sjYj::P64;
      call Main.$wa_info(D1, R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:53.309021 UTC

{offset
  ckvr:
      _sjYg::P64 = R6;
      _sjYf::P64 = R5;
      _sjYe::P64 = R4;
      _sjYd::P64 = R3;
      _sjYc::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckvF; else goto ckvG;
  ckvG:
      if (HpLim == 0) goto ckvF; else goto ckvH;
  ckvF:
      R6 = _sjYg::P64;
      R5 = _sjYf::P64;
      R4 = _sjYe::P64;
      R3 = _sjYd::P64;
      R2 = _sjYc::P64;
      R1 = Main.runRSTMEmpty1_closure;
      call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  ckvH:
      I64[(young<ckvo> + 8)] = ckvo;
      R1 = _sjYc::P64;
      if (R1 & 7 != 0) goto ckvo; else goto ckvp;
  ckvp:
      call (I64[R1])(R1) returns to ckvo, args: 8, res: 8, upd: 8;
  ckvo:
      _sjYi::P64 = R1;
      _sjYj::P64 = P64[_sjYi::P64 + 7];
      I64[(young<ckvu> + 8)] = ckvu;
      R1 = _sjYd::P64;
      if (R1 & 7 != 0) goto ckvu; else goto ckvv;
  ckvv:
      call (I64[R1])(R1) returns to ckvu, args: 8, res: 8, upd: 8;
  ckvu:
      _sjYk::P64 = R1;
      _sjYl::P64 = P64[_sjYk::P64 + 7];
      I64[(young<ckvz> + 8)] = ckvz;
      R1 = _sjYf::P64;
      if (R1 & 7 != 0) goto ckvz; else goto ckvA;
  ckvA:
      call (I64[R1])(R1) returns to ckvz, args: 8, res: 8, upd: 8;
  ckvz:
      _sjYm::P64 = R1;
      _sjYn::I64 = I64[_sjYm::P64 + 7];
      I64[(young<ckvE> + 8)] = ckvE;
      R1 = _sjYg::P64;
      if (R1 & 7 != 0) goto ckvE; else goto ckvL;
  ckvL:
      call (I64[R1])(R1) returns to ckvE, args: 8, res: 8, upd: 8;
  ckvE:
      _sjYo::P64 = R1;
      _sjYp::F64 = F64[_sjYo::P64 + 7];
      D1 = _sjYp::F64;
      R4 = _sjYn::I64;
      R3 = _sjYl::P64;
      R2 = _sjYj::P64;
      call Main.$wa_info(D1, R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:53.311718 UTC

{offset
  ckvr:
      _sjYg::P64 = R6;
      _sjYf::P64 = R5;
      _sjYe::P64 = R4;
      _sjYd::P64 = R3;
      _sjYc::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckvF; else goto ckvG;
  ckvG:
      if (HpLim == 0) goto ckvF; else goto ckvH;
  ckvF:
      R6 = _sjYg::P64;
      R5 = _sjYf::P64;
      R4 = _sjYe::P64;
      R3 = _sjYd::P64;
      R2 = _sjYc::P64;
      R1 = Main.runRSTMEmpty1_closure;
      call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  ckvH:
      I64[(young<ckvo> + 8)] = ckvo;
      R1 = _sjYc::P64;
      if (R1 & 7 != 0) goto ckvo; else goto ckvp;
  ckvp:
      call (I64[R1])(R1) returns to ckvo, args: 8, res: 8, upd: 8;
  ckvo:
      _sjYi::P64 = R1;
      _sjYj::P64 = P64[_sjYi::P64 + 7];
      I64[(young<ckvu> + 8)] = ckvu;
      R1 = _sjYd::P64;
      if (R1 & 7 != 0) goto ckvu; else goto ckvv;
  ckvv:
      call (I64[R1])(R1) returns to ckvu, args: 8, res: 8, upd: 8;
  ckvu:
      _sjYk::P64 = R1;
      _sjYl::P64 = P64[_sjYk::P64 + 7];
      I64[(young<ckvz> + 8)] = ckvz;
      R1 = _sjYf::P64;
      if (R1 & 7 != 0) goto ckvz; else goto ckvA;
  ckvA:
      call (I64[R1])(R1) returns to ckvz, args: 8, res: 8, upd: 8;
  ckvz:
      _sjYm::P64 = R1;
      _sjYn::I64 = I64[_sjYm::P64 + 7];
      I64[(young<ckvE> + 8)] = ckvE;
      R1 = _sjYg::P64;
      if (R1 & 7 != 0) goto ckvE; else goto ckvL;
  ckvL:
      call (I64[R1])(R1) returns to ckvE, args: 8, res: 8, upd: 8;
  ckvE:
      _sjYo::P64 = R1;
      _sjYp::F64 = F64[_sjYo::P64 + 7];
      D1 = _sjYp::F64;
      R4 = _sjYn::I64;
      R3 = _sjYl::P64;
      R2 = _sjYj::P64;
      call Main.$wa_info(D1, R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:53.314772 UTC

{offset
  ckvr:
      _sjYg::P64 = R6;
      _sjYf::P64 = R5;
      _sjYe::P64 = R4;
      _sjYd::P64 = R3;
      _sjYc::P64 = R2;
      if ((Sp + 8) - 40 < SpLim) goto ckvF; else goto ckvG;
  ckvG:
      if (HpLim == 0) goto ckvF; else goto ckvH;
  ckvF:
      R6 = _sjYg::P64;
      R5 = _sjYf::P64;
      R4 = _sjYe::P64;
      R3 = _sjYd::P64;
      R2 = _sjYc::P64;
      R1 = Main.runRSTMEmpty1_closure;
      call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  ckvH:
      I64[Sp - 32] = ckvo;
      R1 = _sjYc::P64;
      P64[Sp - 24] = _sjYd::P64;
      P64[Sp - 16] = _sjYf::P64;
      P64[Sp - 8] = _sjYg::P64;
      Sp = Sp - 32;
      if (R1 & 7 != 0) goto ckvo; else goto ckvp;
  ckvp:
      call (I64[R1])(R1) returns to ckvo, args: 8, res: 8, upd: 8;
  ckvo:
      _sjYd::P64 = P64[Sp + 8];
      _sjYf::P64 = P64[Sp + 16];
      _sjYg::P64 = P64[Sp + 24];
      _sjYi::P64 = R1;
      _sjYj::P64 = P64[_sjYi::P64 + 7];
      I64[Sp] = ckvu;
      R1 = _sjYd::P64;
      P64[Sp + 8] = _sjYj::P64;
      if (R1 & 7 != 0) goto ckvu; else goto ckvv;
  ckvv:
      call (I64[R1])(R1) returns to ckvu, args: 8, res: 8, upd: 8;
  ckvu:
      _sjYf::P64 = P64[Sp + 16];
      _sjYg::P64 = P64[Sp + 24];
      _sjYj::P64 = P64[Sp + 8];
      _sjYk::P64 = R1;
      _sjYl::P64 = P64[_sjYk::P64 + 7];
      I64[Sp] = ckvz;
      R1 = _sjYf::P64;
      P64[Sp + 16] = _sjYl::P64;
      if (R1 & 7 != 0) goto ckvz; else goto ckvA;
  ckvA:
      call (I64[R1])(R1) returns to ckvz, args: 8, res: 8, upd: 8;
  ckvz:
      _sjYg::P64 = P64[Sp + 24];
      _sjYj::P64 = P64[Sp + 8];
      _sjYl::P64 = P64[Sp + 16];
      _sjYm::P64 = R1;
      _sjYn::I64 = I64[_sjYm::P64 + 7];
      I64[Sp] = ckvE;
      R1 = _sjYg::P64;
      I64[Sp + 24] = _sjYn::I64;
      if (R1 & 7 != 0) goto ckvE; else goto ckvL;
  ckvL:
      call (I64[R1])(R1) returns to ckvE, args: 8, res: 8, upd: 8;
  ckvE:
      _sjYj::P64 = P64[Sp + 8];
      _sjYl::P64 = P64[Sp + 16];
      _sjYn::I64 = I64[Sp + 24];
      _sjYo::P64 = R1;
      _sjYp::F64 = F64[_sjYo::P64 + 7];
      D1 = _sjYp::F64;
      R4 = _sjYn::I64;
      R3 = _sjYl::P64;
      R2 = _sjYj::P64;
      Sp = Sp + 32;
      call Main.$wa_info(D1, R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:53.318486 UTC

{offset
  ckvr:
      _sjYg::P64 = R6;
      _sjYf::P64 = R5;
      _sjYe::P64 = R4;
      _sjYd::P64 = R3;
      _sjYc::P64 = R2;
      if ((Sp + -32) < SpLim) goto ckvF; else goto ckvG;
  ckvG:
      if (HpLim == 0) goto ckvF; else goto ckvH;
  ckvF:
      R6 = _sjYg::P64;
      R5 = _sjYf::P64;
      R4 = _sjYe::P64;
      R3 = _sjYd::P64;
      R2 = _sjYc::P64;
      R1 = Main.runRSTMEmpty1_closure;
      call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  ckvH:
      I64[Sp - 32] = ckvo;
      R1 = _sjYc::P64;
      P64[Sp - 24] = _sjYd::P64;
      P64[Sp - 16] = _sjYf::P64;
      P64[Sp - 8] = _sjYg::P64;
      Sp = Sp - 32;
      if (R1 & 7 != 0) goto ckvo; else goto ckvp;
  ckvp:
      call (I64[R1])(R1) returns to ckvo, args: 8, res: 8, upd: 8;
  ckvo:
      I64[Sp] = ckvu;
      _sjYj::P64 = P64[R1 + 7];
      R1 = P64[Sp + 8];
      P64[Sp + 8] = _sjYj::P64;
      if (R1 & 7 != 0) goto ckvu; else goto ckvv;
  ckvv:
      call (I64[R1])(R1) returns to ckvu, args: 8, res: 8, upd: 8;
  ckvu:
      I64[Sp] = ckvz;
      _sjYl::P64 = P64[R1 + 7];
      R1 = P64[Sp + 16];
      P64[Sp + 16] = _sjYl::P64;
      if (R1 & 7 != 0) goto ckvz; else goto ckvA;
  ckvA:
      call (I64[R1])(R1) returns to ckvz, args: 8, res: 8, upd: 8;
  ckvz:
      I64[Sp] = ckvE;
      _sjYn::I64 = I64[R1 + 7];
      R1 = P64[Sp + 24];
      I64[Sp + 24] = _sjYn::I64;
      if (R1 & 7 != 0) goto ckvE; else goto ckvL;
  ckvL:
      call (I64[R1])(R1) returns to ckvE, args: 8, res: 8, upd: 8;
  ckvE:
      D1 = F64[R1 + 7];
      R4 = I64[Sp + 24];
      R3 = P64[Sp + 16];
      R2 = P64[Sp + 8];
      Sp = Sp + 32;
      call Main.$wa_info(D1, R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:53.321802 UTC

[(ckvo, {Main.$wa_closure}), (ckvp, {Main.$wa_closure}),
 (ckvr, {Main.$wa_closure, Main.runRSTMEmpty1_closure}),
 (ckvu, {Main.$wa_closure}), (ckvv, {Main.$wa_closure}),
 (ckvz, {Main.$wa_closure}), (ckvA, {Main.$wa_closure}),
 (ckvE, {Main.$wa_closure}), (ckvF, {Main.runRSTMEmpty1_closure}),
 (ckvG, {Main.$wa_closure, Main.runRSTMEmpty1_closure}),
 (ckvH, {Main.$wa_closure}), (ckvL, {Main.$wa_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:53.322744 UTC

Main.runRSTMEmpty1_entry() //  [R6, R5, R4, R3, R2]
        { info_tbl: [(ckvo,
                      label: block_ckvo_info
                      rep:StackRep [False, False, False]),
                     (ckvr,
                      label: Main.runRSTMEmpty1_info
                      rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} }),
                     (ckvu,
                      label: block_ckvu_info
                      rep:StackRep [False, False, False]),
                     (ckvz,
                      label: block_ckvz_info
                      rep:StackRep [False, False, False]),
                     (ckvE,
                      label: block_ckvE_info
                      rep:StackRep [False, False, True])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckvr:
          _sjYg::P64 = R6;
          _sjYf::P64 = R5;
          _sjYe::P64 = R4;
          _sjYd::P64 = R3;
          _sjYc::P64 = R2;
          if ((Sp + -32) < SpLim) goto ckvF; else goto ckvG;
      ckvG:
          if (HpLim == 0) goto ckvF; else goto ckvH;
      ckvF:
          R6 = _sjYg::P64;
          R5 = _sjYf::P64;
          R4 = _sjYe::P64;
          R3 = _sjYd::P64;
          R2 = _sjYc::P64;
          R1 = Main.runRSTMEmpty1_closure;
          call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
      ckvH:
          I64[Sp - 32] = ckvo;
          R1 = _sjYc::P64;
          P64[Sp - 24] = _sjYd::P64;
          P64[Sp - 16] = _sjYf::P64;
          P64[Sp - 8] = _sjYg::P64;
          Sp = Sp - 32;
          if (R1 & 7 != 0) goto ckvo; else goto ckvp;
      ckvp:
          call (I64[R1])(R1) returns to ckvo, args: 8, res: 8, upd: 8;
      ckvo:
          I64[Sp] = ckvu;
          _sjYj::P64 = P64[R1 + 7];
          R1 = P64[Sp + 8];
          P64[Sp + 8] = _sjYj::P64;
          if (R1 & 7 != 0) goto ckvu; else goto ckvv;
      ckvv:
          call (I64[R1])(R1) returns to ckvu, args: 8, res: 8, upd: 8;
      ckvu:
          I64[Sp] = ckvz;
          _sjYl::P64 = P64[R1 + 7];
          R1 = P64[Sp + 16];
          P64[Sp + 16] = _sjYl::P64;
          if (R1 & 7 != 0) goto ckvz; else goto ckvA;
      ckvA:
          call (I64[R1])(R1) returns to ckvz, args: 8, res: 8, upd: 8;
      ckvz:
          I64[Sp] = ckvE;
          _sjYn::I64 = I64[R1 + 7];
          R1 = P64[Sp + 24];
          I64[Sp + 24] = _sjYn::I64;
          if (R1 & 7 != 0) goto ckvE; else goto ckvL;
      ckvL:
          call (I64[R1])(R1) returns to ckvE, args: 8, res: 8, upd: 8;
      ckvE:
          D1 = F64[R1 + 7];
          R4 = I64[Sp + 24];
          R3 = P64[Sp + 16];
          R2 = P64[Sp + 8];
          Sp = Sp + 32;
          call Main.$wa_info(D1, R4, R3, R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:53.326551 UTC

Main.runRSTMEmpty1_entry() //  [R6, R5, R4, R3, R2]
        { info_tbl: [(ckvo,
                      label: block_ckvo_info
                      rep:StackRep [False, False, False]),
                     (ckvr,
                      label: Main.runRSTMEmpty1_info
                      rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} }),
                     (ckvu,
                      label: block_ckvu_info
                      rep:StackRep [False, False, False]),
                     (ckvz,
                      label: block_ckvz_info
                      rep:StackRep [False, False, False]),
                     (ckvE,
                      label: block_ckvE_info
                      rep:StackRep [False, False, True])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckvr:
          _sjYg::P64 = R6;
          _sjYf::P64 = R5;
          _sjYe::P64 = R4;
          _sjYd::P64 = R3;
          _sjYc::P64 = R2;
          if ((Sp + -32) < SpLim) goto ckvF; else goto ckvG;
      ckvG:
          if (HpLim == 0) goto ckvF; else goto ckvH;
      ckvF:
          R6 = _sjYg::P64;
          R5 = _sjYf::P64;
          R4 = _sjYe::P64;
          R3 = _sjYd::P64;
          R2 = _sjYc::P64;
          R1 = Main.runRSTMEmpty1_closure;
          call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
      ckvH:
          I64[Sp - 32] = ckvo;
          R1 = _sjYc::P64;
          P64[Sp - 24] = _sjYd::P64;
          P64[Sp - 16] = _sjYf::P64;
          P64[Sp - 8] = _sjYg::P64;
          Sp = Sp - 32;
          if (R1 & 7 != 0) goto ckvo; else goto ckvp;
      ckvp:
          call (I64[R1])(R1) returns to ckvo, args: 8, res: 8, upd: 8;
      ckvo:
          I64[Sp] = ckvu;
          _sjYj::P64 = P64[R1 + 7];
          R1 = P64[Sp + 8];
          P64[Sp + 8] = _sjYj::P64;
          if (R1 & 7 != 0) goto ckvu; else goto ckvv;
      ckvv:
          call (I64[R1])(R1) returns to ckvu, args: 8, res: 8, upd: 8;
      ckvu:
          I64[Sp] = ckvz;
          _sjYl::P64 = P64[R1 + 7];
          R1 = P64[Sp + 16];
          P64[Sp + 16] = _sjYl::P64;
          if (R1 & 7 != 0) goto ckvz; else goto ckvA;
      ckvA:
          call (I64[R1])(R1) returns to ckvz, args: 8, res: 8, upd: 8;
      ckvz:
          I64[Sp] = ckvE;
          _sjYn::I64 = I64[R1 + 7];
          R1 = P64[Sp + 24];
          I64[Sp + 24] = _sjYn::I64;
          if (R1 & 7 != 0) goto ckvE; else goto ckvL;
      ckvL:
          call (I64[R1])(R1) returns to ckvE, args: 8, res: 8, upd: 8;
      ckvE:
          D1 = F64[R1 + 7];
          R4 = I64[Sp + 24];
          R3 = P64[Sp + 16];
          R2 = P64[Sp + 8];
          Sp = Sp + 32;
          call Main.$wa_info(D1, R4, R3, R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:53.330306 UTC

[section "data" {
     Main.runRSTMEmpty1_closure:
         const Main.runRSTMEmpty1_info;
         const 0;
 },
 Main.runRSTMEmpty1_entry() //  [R6, R5, R4, R3, R2]
         { info_tbl: [(ckvo,
                       label: block_ckvo_info
                       rep:StackRep [False, False, False]),
                      (ckvr,
                       label: Main.runRSTMEmpty1_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} }),
                      (ckvu,
                       label: block_ckvu_info
                       rep:StackRep [False, False, False]),
                      (ckvz,
                       label: block_ckvz_info
                       rep:StackRep [False, False, False]),
                      (ckvE,
                       label: block_ckvE_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckvr:
           _sjYg::P64 = R6;
           _sjYf::P64 = R5;
           _sjYe::P64 = R4;
           _sjYd::P64 = R3;
           _sjYc::P64 = R2;
           if ((Sp + -32) < SpLim) goto ckvF; else goto ckvG;
       ckvG:
           if (HpLim == 0) goto ckvF; else goto ckvH;
       ckvF:
           R6 = _sjYg::P64;
           R5 = _sjYf::P64;
           R4 = _sjYe::P64;
           R3 = _sjYd::P64;
           R2 = _sjYc::P64;
           R1 = Main.runRSTMEmpty1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckvH:
           I64[Sp - 32] = ckvo;
           R1 = _sjYc::P64;
           P64[Sp - 24] = _sjYd::P64;
           P64[Sp - 16] = _sjYf::P64;
           P64[Sp - 8] = _sjYg::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ckvo; else goto ckvp;
       ckvp:
           call (I64[R1])(R1) returns to ckvo, args: 8, res: 8, upd: 8;
       ckvo:
           I64[Sp] = ckvu;
           _sjYj::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sjYj::P64;
           if (R1 & 7 != 0) goto ckvu; else goto ckvv;
       ckvv:
           call (I64[R1])(R1) returns to ckvu, args: 8, res: 8, upd: 8;
       ckvu:
           I64[Sp] = ckvz;
           _sjYl::P64 = P64[R1 + 7];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _sjYl::P64;
           if (R1 & 7 != 0) goto ckvz; else goto ckvA;
       ckvA:
           call (I64[R1])(R1) returns to ckvz, args: 8, res: 8, upd: 8;
       ckvz:
           I64[Sp] = ckvE;
           _sjYn::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _sjYn::I64;
           if (R1 & 7 != 0) goto ckvE; else goto ckvL;
       ckvL:
           call (I64[R1])(R1) returns to ckvE, args: 8, res: 8, upd: 8;
       ckvE:
           D1 = F64[R1 + 7];
           R4 = I64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Main.$wa_info(D1, R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:53.334396 UTC

[section "data" {
     Main.runRSTMEmpty1_closure:
         const Main.runRSTMEmpty1_info;
         const 0;
 },
 Main.runRSTMEmpty1_entry() //  [R6, R5, R4, R3, R2]
         { info_tbl: [(ckvo,
                       label: block_ckvo_info
                       rep:StackRep [False, False, False]),
                      (ckvr,
                       label: Main.runRSTMEmpty1_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} }),
                      (ckvu,
                       label: block_ckvu_info
                       rep:StackRep [False, False, False]),
                      (ckvz,
                       label: block_ckvz_info
                       rep:StackRep [False, False, False]),
                      (ckvE,
                       label: block_ckvE_info
                       rep:StackRep [False, False, True])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckvr:
           _sjYg::P64 = R6;
           _sjYf::P64 = R5;
           _sjYe::P64 = R4;
           _sjYd::P64 = R3;
           _sjYc::P64 = R2;
           if ((Sp + -32) < SpLim) goto ckvF; else goto ckvG;
       ckvG:
           if (HpLim == 0) goto ckvF; else goto ckvH;
       ckvF:
           R6 = _sjYg::P64;
           R5 = _sjYf::P64;
           R4 = _sjYe::P64;
           R3 = _sjYd::P64;
           R2 = _sjYc::P64;
           R1 = Main.runRSTMEmpty1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckvH:
           I64[Sp - 32] = ckvo;
           R1 = _sjYc::P64;
           P64[Sp - 24] = _sjYd::P64;
           P64[Sp - 16] = _sjYf::P64;
           P64[Sp - 8] = _sjYg::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ckvo; else goto ckvp;
       ckvp:
           call (I64[R1])(R1) returns to ckvo, args: 8, res: 8, upd: 8;
       ckvo:
           I64[Sp] = ckvu;
           _sjYj::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sjYj::P64;
           if (R1 & 7 != 0) goto ckvu; else goto ckvv;
       ckvv:
           call (I64[R1])(R1) returns to ckvu, args: 8, res: 8, upd: 8;
       ckvu:
           I64[Sp] = ckvz;
           _sjYl::P64 = P64[R1 + 7];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _sjYl::P64;
           if (R1 & 7 != 0) goto ckvz; else goto ckvA;
       ckvA:
           call (I64[R1])(R1) returns to ckvz, args: 8, res: 8, upd: 8;
       ckvz:
           I64[Sp] = ckvE;
           _sjYn::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _sjYn::I64;
           if (R1 & 7 != 0) goto ckvE; else goto ckvL;
       ckvL:
           call (I64[R1])(R1) returns to ckvE, args: 8, res: 8, upd: 8;
       ckvE:
           D1 = F64[R1 + 7];
           R4 = I64[Sp + 24];
           R3 = P64[Sp + 16];
           R2 = P64[Sp + 8];
           Sp = Sp + 32;
           call Main.$wa_info(D1, R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:53.344132 UTC

[section "data" {
     Main.runRSTMEmpty_closure:
         const Main.runRSTMEmpty_info;
         const 0;
 },
 Main.runRSTMEmpty_entry() //  [R6, R5, R4, R3, R2]
         { info_tbl: [(ckvZ,
                       label: Main.runRSTMEmpty_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckvZ:
           _B2::P64 = R6;
           _B3::P64 = R5;
           _B4::P64 = R4;
           _B5::P64 = R3;
           _B6::P64 = R2;
           goto ckvX;
       ckvX:
           if ((old + 0) - <highSp> < SpLim) goto ckw0; else goto ckw1;
       ckw1:
           goto ckvW;
       ckvW:
           if (HpLim == 0) goto ckw0; else goto ckw2;
       ckw0:
           R6 = _B2::P64;
           R5 = _B3::P64;
           R4 = _B4::P64;
           R3 = _B5::P64;
           R2 = _B6::P64;
           R1 = Main.runRSTMEmpty_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckw2:
           R6 = _B2::P64;
           R5 = _B3::P64;
           R4 = _B4::P64;
           R3 = _B5::P64;
           R2 = _B6::P64;
           call Main.runRSTMEmpty1_info(R6,
                                        R5,
                                        R4,
                                        R3,
                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:53.346454 UTC

{offset
  ckvZ:
      _B2::P64 = R6;
      _B3::P64 = R5;
      _B4::P64 = R4;
      _B5::P64 = R3;
      _B6::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckw0; else goto ckw1;
  ckw1:
      if (HpLim == 0) goto ckw0; else goto ckw2;
  ckw0:
      R6 = _B2::P64;
      R5 = _B3::P64;
      R4 = _B4::P64;
      R3 = _B5::P64;
      R2 = _B6::P64;
      R1 = Main.runRSTMEmpty_closure;
      call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  ckw2:
      R6 = _B2::P64;
      R5 = _B3::P64;
      R4 = _B4::P64;
      R3 = _B5::P64;
      R2 = _B6::P64;
      call Main.runRSTMEmpty1_info(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:53.347706 UTC

{offset
  ckvZ:
      _B2::P64 = R6;
      _B3::P64 = R5;
      _B4::P64 = R4;
      _B5::P64 = R3;
      _B6::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckw0; else goto ckw1;
  ckw1:
      if (HpLim == 0) goto ckw0; else goto ckw2;
  ckw0:
      R6 = _B2::P64;
      R5 = _B3::P64;
      R4 = _B4::P64;
      R3 = _B5::P64;
      R2 = _B6::P64;
      R1 = Main.runRSTMEmpty_closure;
      call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  ckw2:
      R6 = _B2::P64;
      R5 = _B3::P64;
      R4 = _B4::P64;
      R3 = _B5::P64;
      R2 = _B6::P64;
      call Main.runRSTMEmpty1_info(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:53.348946 UTC

{offset
  ckvZ:
      _B2::P64 = R6;
      _B3::P64 = R5;
      _B4::P64 = R4;
      _B5::P64 = R3;
      _B6::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckw0; else goto ckw1;
  ckw1:
      if (HpLim == 0) goto ckw0; else goto ckw2;
  ckw0:
      R6 = _B2::P64;
      R5 = _B3::P64;
      R4 = _B4::P64;
      R3 = _B5::P64;
      R2 = _B6::P64;
      R1 = Main.runRSTMEmpty_closure;
      call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  ckw2:
      R6 = _B2::P64;
      R5 = _B3::P64;
      R4 = _B4::P64;
      R3 = _B5::P64;
      R2 = _B6::P64;
      call Main.runRSTMEmpty1_info(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:53.350224 UTC

{offset
  ckvZ:
      _B2::P64 = R6;
      _B3::P64 = R5;
      _B4::P64 = R4;
      _B5::P64 = R3;
      _B6::P64 = R2;
      goto ckw1;
  ckw1:
      if (HpLim == 0) goto ckw0; else goto ckw2;
  ckw0:
      R6 = _B2::P64;
      R5 = _B3::P64;
      R4 = _B4::P64;
      R3 = _B5::P64;
      R2 = _B6::P64;
      R1 = Main.runRSTMEmpty_closure;
      call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  ckw2:
      R6 = _B2::P64;
      R5 = _B3::P64;
      R4 = _B4::P64;
      R3 = _B5::P64;
      R2 = _B6::P64;
      call Main.runRSTMEmpty1_info(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:53.351355 UTC

{offset
  ckvZ:
      goto ckw1;
  ckw1:
      if (HpLim == 0) goto ckw0; else goto ckw2;
  ckw0:
      R6 = R6;
      R5 = R5;
      R4 = R4;
      R3 = R3;
      R2 = R2;
      R1 = Main.runRSTMEmpty_closure;
      call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  ckw2:
      R6 = R6;
      R5 = R5;
      R4 = R4;
      R3 = R3;
      R2 = R2;
      call Main.runRSTMEmpty1_info(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:53.352582 UTC

[(ckvZ, {Main.runRSTMEmpty1_closure, Main.runRSTMEmpty_closure}),
 (ckw0, {Main.runRSTMEmpty_closure}),
 (ckw1, {Main.runRSTMEmpty1_closure, Main.runRSTMEmpty_closure}),
 (ckw2, {Main.runRSTMEmpty1_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:53.353079 UTC

Main.runRSTMEmpty_entry() //  [R6, R5, R4, R3, R2]
        { info_tbl: [(ckvZ,
                      label: Main.runRSTMEmpty_info
                      rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckvZ:
          goto ckw1;
      ckw1:
          if (HpLim == 0) goto ckw0; else goto ckw2;
      ckw0:
          R6 = R6;
          R5 = R5;
          R4 = R4;
          R3 = R3;
          R2 = R2;
          R1 = Main.runRSTMEmpty_closure;
          call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
      ckw2:
          R6 = R6;
          R5 = R5;
          R4 = R4;
          R3 = R3;
          R2 = R2;
          call Main.runRSTMEmpty1_info(R6,
                                       R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:53.354295 UTC

Main.runRSTMEmpty_entry() //  [R6, R5, R4, R3, R2]
        { info_tbl: [(ckvZ,
                      label: Main.runRSTMEmpty_info
                      rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckvZ:
          if (HpLim == 0) goto ckw0; else goto ckw2;
      ckw0:
          R6 = R6;
          R5 = R5;
          R4 = R4;
          R3 = R3;
          R2 = R2;
          R1 = Main.runRSTMEmpty_closure;
          call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
      ckw2:
          R6 = R6;
          R5 = R5;
          R4 = R4;
          R3 = R3;
          R2 = R2;
          call Main.runRSTMEmpty1_info(R6,
                                       R5,
                                       R4,
                                       R3,
                                       R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:53.356159 UTC

[section "data" {
     Main.runRSTMEmpty_closure:
         const Main.runRSTMEmpty_info;
         const 0;
 },
 Main.runRSTMEmpty_entry() //  [R6, R5, R4, R3, R2]
         { info_tbl: [(ckvZ,
                       label: Main.runRSTMEmpty_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckvZ:
           if (HpLim == 0) goto ckw0; else goto ckw2;
       ckw0:
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Main.runRSTMEmpty_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckw2:
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Main.runRSTMEmpty1_info(R6,
                                        R5,
                                        R4,
                                        R3,
                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:53.357618 UTC

[section "data" {
     Main.runRSTMEmpty_closure:
         const Main.runRSTMEmpty_info;
         const 0;
 },
 Main.runRSTMEmpty_entry() //  [R6, R5, R4, R3, R2]
         { info_tbl: [(ckvZ,
                       label: Main.runRSTMEmpty_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckvZ:
           if (HpLim == 0) goto ckw0; else goto ckw2;
       ckw0:
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Main.runRSTMEmpty_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckw2:
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Main.runRSTMEmpty1_info(R6,
                                        R5,
                                        R4,
                                        R3,
                                        R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:53.361124 UTC

[section "data" {
     $wgo1_rjVd_closure:
         const $wgo1_rjVd_info;
 },
 $wgo1_rjVd_entry() //  [R2]
         { info_tbl: [(ckwQ,
                       label: $wgo1_rjVd_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckwQ:
           _sjYq::I64 = R2;
           goto ckwM;
       ckwM:
           if ((old + 0) - <highSp> < SpLim) goto ckwR; else goto ckwS;
       ckwS:
           goto ckwL;
       ckwL:
           if (HpLim == 0) goto ckwR; else goto ckxj;
       ckwR:
           R2 = _sjYq::I64;
           R1 = $wgo1_rjVd_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckxj:
           _ckwO::I64 = _sjYq::I64 >> 61;
           _sjYu::I64 = _ckwO::I64;
           _ckwU::I64 = _sjYu::I64;
           _sjYv::I64 = _ckwU::I64;
           _ckwX::I64 = _sjYv::I64 + 22;
           _sjYw::I64 = _ckwX::I64;
           _ckx0::I64 = _sjYq::I64 >> 22;
           _sjYs::I64 = _ckx0::I64;
           _ckx3::I64 = _sjYs::I64 ^ _sjYq::I64;
           _sjYt::I64 = _ckx3::I64;
           _ckx6::I64 = _sjYt::I64 >> _sjYw::I64;
           _sjYx::I64 = _ckx6::I64;
           _ckx9::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_sjYx::I64));
           _sjYr::I64 = _ckx9::I64;
           _ckxc::I64 = _sjYr::I64 >= 67296;
           _sjYy::I64 = _ckxc::I64;
           switch [0 .. 1] _sjYy::I64 {
               case 0 : goto ckxh;
               case 1 : goto ckxi;
           }
       ckxi:
           _ckxn::I64 = _sjYr::I64 % 100000;
           _sjYC::I64 = _ckxn::I64;
           _ckxq::I64 = _sjYq::I64 * 6364136223846793005;
           _sjYB::I64 = _ckxq::I64;
           R2 = _sjYC::I64;
           R1 = _sjYB::I64;
           call (P64[(old + 8)])(R2, R1) args: 8, res: 0, upd: 8;
       ckxh:
           _ckxl::I64 = _sjYq::I64 * 6364136223846793005;
           _sjYA::I64 = _ckxl::I64;
           _sjYq::I64 = _sjYA::I64;
           goto ckwL;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:53.365172 UTC

{offset
  ckwQ:
      _sjYq::I64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckwR; else goto ckwL;
  ckwL:
      if (HpLim == 0) goto ckwR; else goto ckxj;
  ckwR:
      R2 = _sjYq::I64;
      R1 = $wgo1_rjVd_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckxj:
      _ckwO::I64 = _sjYq::I64 >> 61;
      _sjYu::I64 = _ckwO::I64;
      _ckwU::I64 = _sjYu::I64;
      _sjYv::I64 = _ckwU::I64;
      _ckwX::I64 = _sjYv::I64 + 22;
      _sjYw::I64 = _ckwX::I64;
      _ckx0::I64 = _sjYq::I64 >> 22;
      _sjYs::I64 = _ckx0::I64;
      _ckx3::I64 = _sjYs::I64 ^ _sjYq::I64;
      _sjYt::I64 = _ckx3::I64;
      _ckx6::I64 = _sjYt::I64 >> _sjYw::I64;
      _sjYx::I64 = _ckx6::I64;
      _ckx9::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_sjYx::I64));
      _sjYr::I64 = _ckx9::I64;
      _ckxc::I64 = _sjYr::I64 >= 67296;
      _sjYy::I64 = _ckxc::I64;
      switch [0 .. 1] _sjYy::I64 {
          case 0 : goto ckxh;
          case 1 : goto ckxi;
      }
  ckxi:
      _ckxn::I64 = _sjYr::I64 % 100000;
      _sjYC::I64 = _ckxn::I64;
      _ckxq::I64 = _sjYq::I64 * 6364136223846793005;
      _sjYB::I64 = _ckxq::I64;
      R2 = _sjYC::I64;
      R1 = _sjYB::I64;
      call (P64[(old + 8)])(R2, R1) args: 8, res: 0, upd: 8;
  ckxh:
      _ckxl::I64 = _sjYq::I64 * 6364136223846793005;
      _sjYA::I64 = _ckxl::I64;
      _sjYq::I64 = _sjYA::I64;
      goto ckwL;
}


==================== Post common block elimination ====================
2015-11-09 18:21:53.367275 UTC

{offset
  ckwQ:
      _sjYq::I64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckwR; else goto ckwL;
  ckwL:
      if (HpLim == 0) goto ckwR; else goto ckxj;
  ckwR:
      R2 = _sjYq::I64;
      R1 = $wgo1_rjVd_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckxj:
      _ckwO::I64 = _sjYq::I64 >> 61;
      _sjYu::I64 = _ckwO::I64;
      _ckwU::I64 = _sjYu::I64;
      _sjYv::I64 = _ckwU::I64;
      _ckwX::I64 = _sjYv::I64 + 22;
      _sjYw::I64 = _ckwX::I64;
      _ckx0::I64 = _sjYq::I64 >> 22;
      _sjYs::I64 = _ckx0::I64;
      _ckx3::I64 = _sjYs::I64 ^ _sjYq::I64;
      _sjYt::I64 = _ckx3::I64;
      _ckx6::I64 = _sjYt::I64 >> _sjYw::I64;
      _sjYx::I64 = _ckx6::I64;
      _ckx9::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_sjYx::I64));
      _sjYr::I64 = _ckx9::I64;
      _ckxc::I64 = _sjYr::I64 >= 67296;
      _sjYy::I64 = _ckxc::I64;
      switch [0 .. 1] _sjYy::I64 {
          case 0 : goto ckxh;
          case 1 : goto ckxi;
      }
  ckxi:
      _ckxn::I64 = _sjYr::I64 % 100000;
      _sjYC::I64 = _ckxn::I64;
      _ckxq::I64 = _sjYq::I64 * 6364136223846793005;
      _sjYB::I64 = _ckxq::I64;
      R2 = _sjYC::I64;
      R1 = _sjYB::I64;
      call (P64[(old + 8)])(R2, R1) args: 8, res: 0, upd: 8;
  ckxh:
      _ckxl::I64 = _sjYq::I64 * 6364136223846793005;
      _sjYA::I64 = _ckxl::I64;
      _sjYq::I64 = _sjYA::I64;
      goto ckwL;
}


==================== Post switch plan ====================
2015-11-09 18:21:53.369409 UTC

{offset
  ckwQ:
      _sjYq::I64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckwR; else goto ckwL;
  ckwL:
      if (HpLim == 0) goto ckwR; else goto ckxj;
  ckwR:
      R2 = _sjYq::I64;
      R1 = $wgo1_rjVd_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckxj:
      _ckwO::I64 = _sjYq::I64 >> 61;
      _sjYu::I64 = _ckwO::I64;
      _ckwU::I64 = _sjYu::I64;
      _sjYv::I64 = _ckwU::I64;
      _ckwX::I64 = _sjYv::I64 + 22;
      _sjYw::I64 = _ckwX::I64;
      _ckx0::I64 = _sjYq::I64 >> 22;
      _sjYs::I64 = _ckx0::I64;
      _ckx3::I64 = _sjYs::I64 ^ _sjYq::I64;
      _sjYt::I64 = _ckx3::I64;
      _ckx6::I64 = _sjYt::I64 >> _sjYw::I64;
      _sjYx::I64 = _ckx6::I64;
      _ckx9::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_sjYx::I64));
      _sjYr::I64 = _ckx9::I64;
      _ckxc::I64 = _sjYr::I64 >= 67296;
      _sjYy::I64 = _ckxc::I64;
      if (_sjYy::I64 != 0) goto ckxi; else goto ckxh;
  ckxi:
      _ckxn::I64 = _sjYr::I64 % 100000;
      _sjYC::I64 = _ckxn::I64;
      _ckxq::I64 = _sjYq::I64 * 6364136223846793005;
      _sjYB::I64 = _ckxq::I64;
      R2 = _sjYC::I64;
      R1 = _sjYB::I64;
      call (P64[(old + 8)])(R2, R1) args: 8, res: 0, upd: 8;
  ckxh:
      _ckxl::I64 = _sjYq::I64 * 6364136223846793005;
      _sjYA::I64 = _ckxl::I64;
      _sjYq::I64 = _sjYA::I64;
      goto ckwL;
}


==================== Layout Stack ====================
2015-11-09 18:21:53.371461 UTC

{offset
  ckwQ:
      _sjYq::I64 = R2;
      goto ckwL;
  ckwL:
      if (HpLim == 0) goto ckwR; else goto ckxj;
  ckwR:
      R2 = _sjYq::I64;
      R1 = $wgo1_rjVd_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckxj:
      _ckwO::I64 = _sjYq::I64 >> 61;
      _sjYu::I64 = _ckwO::I64;
      _ckwU::I64 = _sjYu::I64;
      _sjYv::I64 = _ckwU::I64;
      _ckwX::I64 = _sjYv::I64 + 22;
      _sjYw::I64 = _ckwX::I64;
      _ckx0::I64 = _sjYq::I64 >> 22;
      _sjYs::I64 = _ckx0::I64;
      _ckx3::I64 = _sjYs::I64 ^ _sjYq::I64;
      _sjYt::I64 = _ckx3::I64;
      _ckx6::I64 = _sjYt::I64 >> _sjYw::I64;
      _sjYx::I64 = _ckx6::I64;
      _ckx9::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_sjYx::I64));
      _sjYr::I64 = _ckx9::I64;
      _ckxc::I64 = _sjYr::I64 >= 67296;
      _sjYy::I64 = _ckxc::I64;
      if (_sjYy::I64 != 0) goto ckxi; else goto ckxh;
  ckxi:
      _ckxn::I64 = _sjYr::I64 % 100000;
      _sjYC::I64 = _ckxn::I64;
      _ckxq::I64 = _sjYq::I64 * 6364136223846793005;
      _sjYB::I64 = _ckxq::I64;
      R2 = _sjYC::I64;
      R1 = _sjYB::I64;
      call (P64[Sp])(R2, R1) args: 8, res: 0, upd: 8;
  ckxh:
      _ckxl::I64 = _sjYq::I64 * 6364136223846793005;
      _sjYA::I64 = _ckxl::I64;
      _sjYq::I64 = _sjYA::I64;
      goto ckwL;
}


==================== Sink assignments ====================
2015-11-09 18:21:53.373377 UTC

{offset
  ckwQ:
      _sjYq::I64 = R2;
      goto ckwL;
  ckwL:
      if (HpLim == 0) goto ckwR; else goto ckxj;
  ckwR:
      R2 = _sjYq::I64;
      R1 = $wgo1_rjVd_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckxj:
      _sjYr::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32((_sjYq::I64 >> 22) ^ _sjYq::I64 >> (_sjYq::I64 >> 61) + 22));
      if (_sjYr::I64 >= 67296) goto ckxi; else goto ckxh;
  ckxi:
      R2 = _sjYr::I64 % 100000;
      R1 = _sjYq::I64 * 6364136223846793005;
      call (P64[Sp])(R2, R1) args: 8, res: 0, upd: 8;
  ckxh:
      _sjYq::I64 = _sjYq::I64 * 6364136223846793005;
      goto ckwL;
}


==================== CAFEnv ====================
2015-11-09 18:21:53.3749 UTC

[(ckwL, {}), (ckwQ, {}), (ckwR, {}), (ckxh, {}), (ckxi, {}),
 (ckxj, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:53.375283 UTC

$wgo1_rjVd_entry() //  [R2]
        { info_tbl: [(ckwQ,
                      label: $wgo1_rjVd_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckwQ:
          _sjYq::I64 = R2;
          goto ckwL;
      ckwL:
          if (HpLim == 0) goto ckwR; else goto ckxj;
      ckwR:
          R2 = _sjYq::I64;
          R1 = $wgo1_rjVd_closure;
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
      ckxj:
          _sjYr::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32((_sjYq::I64 >> 22) ^ _sjYq::I64 >> (_sjYq::I64 >> 61) + 22));
          if (_sjYr::I64 >= 67296) goto ckxi; else goto ckxh;
      ckxi:
          R2 = _sjYr::I64 % 100000;
          R1 = _sjYq::I64 * 6364136223846793005;
          call (P64[Sp])(R2, R1) args: 8, res: 0, upd: 8;
      ckxh:
          _sjYq::I64 = _sjYq::I64 * 6364136223846793005;
          goto ckwL;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:53.376651 UTC

$wgo1_rjVd_entry() //  [R2]
        { info_tbl: [(ckwQ,
                      label: $wgo1_rjVd_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckwQ:
          _sjYq::I64 = R2;
          goto ckwL;
      ckwL:
          if (HpLim == 0) goto ckwR; else goto ckxj;
      ckwR:
          R2 = _sjYq::I64;
          R1 = $wgo1_rjVd_closure;
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
      ckxj:
          _sjYr::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32((_sjYq::I64 >> 22) ^ _sjYq::I64 >> (_sjYq::I64 >> 61) + 22));
          if (_sjYr::I64 >= 67296) goto ckxi; else goto ckxh;
      ckxi:
          R2 = _sjYr::I64 % 100000;
          R1 = _sjYq::I64 * 6364136223846793005;
          call (P64[Sp])(R2, R1) args: 8, res: 0, upd: 8;
      ckxh:
          _sjYq::I64 = _sjYq::I64 * 6364136223846793005;
          goto ckwL;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:53.378058 UTC

[section "data" {
     $wgo1_rjVd_closure:
         const $wgo1_rjVd_info;
 },
 $wgo1_rjVd_entry() //  [R2]
         { info_tbl: [(ckwQ,
                       label: $wgo1_rjVd_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckwQ:
           _sjYq::I64 = R2;
           goto ckwL;
       ckwL:
           if (HpLim == 0) goto ckwR; else goto ckxj;
       ckwR:
           R2 = _sjYq::I64;
           R1 = $wgo1_rjVd_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckxj:
           _sjYr::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32((_sjYq::I64 >> 22) ^ _sjYq::I64 >> (_sjYq::I64 >> 61) + 22));
           if (_sjYr::I64 >= 67296) goto ckxi; else goto ckxh;
       ckxi:
           R2 = _sjYr::I64 % 100000;
           R1 = _sjYq::I64 * 6364136223846793005;
           call (P64[Sp])(R2, R1) args: 8, res: 0, upd: 8;
       ckxh:
           _sjYq::I64 = _sjYq::I64 * 6364136223846793005;
           goto ckwL;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:53.379618 UTC

[section "data" {
     $wgo1_rjVd_closure:
         const $wgo1_rjVd_info;
 },
 $wgo1_rjVd_entry() //  [R2]
         { info_tbl: [(ckwQ,
                       label: $wgo1_rjVd_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckwQ:
           _sjYq::I64 = R2;
           goto ckwL;
       ckwL:
           if (HpLim == 0) goto ckwR; else goto ckxj;
       ckwR:
           R2 = _sjYq::I64;
           R1 = $wgo1_rjVd_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckxj:
           _sjYr::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32((_sjYq::I64 >> 22) ^ _sjYq::I64 >> (_sjYq::I64 >> 61) + 22));
           if (_sjYr::I64 >= 67296) goto ckxi; else goto ckxh;
       ckxi:
           R2 = _sjYr::I64 % 100000;
           R1 = _sjYq::I64 * 6364136223846793005;
           call (P64[Sp])(R2, R1) args: 8, res: 0, upd: 8;
       ckxh:
           _sjYq::I64 = _sjYq::I64 * 6364136223846793005;
           goto ckwL;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:53.38714 UTC

[section "data" {
     Main.$wa1_closure:
         const Main.$wa1_info;
         const 0;
 },
 Main.$wa1_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 104 updfr_space: Just 8
         }
     {offset
       ckAo:
           _rbSO::P64 = R1;
           _sjYD::P64 = P64[(old + 104)];
           _sjYE::P64 = P64[(old + 96)];
           _sjYF::I64 = I64[(old + 88)];
           _sjYG::I64 = I64[(old + 80)];
           _sjYH::I64 = I64[(old + 72)];
           _sjYI::P64 = P64[(old + 64)];
           _sjYJ::P64 = P64[(old + 56)];
           _sjYK::I64 = I64[(old + 48)];
           _sjYL::I64 = I64[(old + 40)];
           _sjYM::P64 = P64[(old + 32)];
           _sjYN::I64 = I64[(old + 24)];
           _sjYO::F64 = F64[(old + 16)];
           R6 = _sjYH::I64;
           R5 = _sjYG::I64;
           R4 = _sjYF::I64;
           R3 = _sjYE::P64;
           R2 = _sjYD::P64;
           R1 = _rbSO::P64;
           P64[(old + 64)] = _sjYI::P64;
           P64[(old + 56)] = _sjYJ::P64;
           I64[(old + 48)] = _sjYK::I64;
           I64[(old + 40)] = _sjYL::I64;
           P64[(old + 32)] = _sjYM::P64;
           I64[(old + 24)] = _sjYN::I64;
           F64[(old + 16)] = _sjYO::F64;
           call Main.$wa1_info(R6,
                               R5,
                               R4,
                               R3,
                               R2,
                               R1) args: 64, res: 0, upd: 8;
     }
 },
 sat_sjZK_entry() //  [R1]
         { info_tbl: [(ckC1,
                       label: sat_sjZK_info
                       rep:HeapRep 2 ptrs 1 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckC1:
           _sjZK::P64 = R1;
           goto ckBX;
       ckBX:
           if ((old + 0) - <highSp> < SpLim) goto ckC5; else goto ckC6;
       ckC6:
           goto ckBW;
       ckBW:
           Hp = Hp + 16;
           if (Hp > HpLim) goto ckC8; else goto ckC7;
       ckC8:
           HpAlloc = 16;
           goto ckC5;
       ckC5:
           R1 = _sjZK::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ckC7:
           _sjYJ::P64 = P64[_sjZK::P64 + 7];
           _sjZg::P64 = P64[_sjZK::P64 + 15];
           _sjZy::I64 = I64[_sjZK::P64 + 23];
           _ckBZ::I64 = _sjZy::I64 + 1;
           _sjZF::I64 = _ckBZ::I64;
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _sjZF::I64;
           _ckC3::P64 = Hp - 7;
           I64[(young<ckC4> + 8)] = ckC4;
           R5 = _ckC3::P64;
           R4 = _sjYJ::P64;
           R3 = _sjZg::P64;
           R2 = GHC.Classes.$fOrdWord_closure;
           call SkipList.$wa2_info(R5,
                                   R4,
                                   R3,
                                   R2) returns to ckC4, args: 8, res: 8, upd: 8;
       ckC4:
           _sjZJ::P64 = R1;
           R1 = GHC.Tuple.()_closure+1;
           call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sk04_entry() //  [R1]
         { info_tbl: [(ckCj,
                       label: sat_sk04_info
                       rep:HeapRep 3 ptrs 1 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckCj:
           _sk04::P64 = R1;
           goto ckCf;
       ckCf:
           if ((old + 0) - <highSp> < SpLim) goto ckCn; else goto ckCo;
       ckCo:
           goto ckCe;
       ckCe:
           Hp = Hp + 16;
           if (Hp > HpLim) goto ckCq; else goto ckCp;
       ckCq:
           HpAlloc = 16;
           goto ckCn;
       ckCn:
           R1 = _sk04::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ckCp:
           _sjYJ::P64 = P64[_sk04::P64 + 7];
           _sjZd::P64 = P64[_sk04::P64 + 15];
           _sjZg::P64 = P64[_sk04::P64 + 23];
           _sjZy::I64 = I64[_sk04::P64 + 31];
           _ckCh::I64 = _sjZy::I64 + 1;
           _sjZZ::I64 = _ckCh::I64;
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _sjZZ::I64;
           _ckCl::P64 = Hp - 7;
           I64[(young<ckCm> + 8)] = ckCm;
           R6 = _ckCl::P64;
           R5 = _sjZd::P64;
           R4 = _sjYJ::P64;
           R3 = _sjZg::P64;
           R2 = GHC.Classes.$fOrdWord_closure;
           P64[(young<ckCm> + 16)] = GHC.Tuple.()_closure+1;
           call SkipList.$wa4_info(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) returns to ckCm, args: 16, res: 8, upd: 8;
       ckCm:
           _sk03::P64 = R1;
           R1 = GHC.Tuple.()_closure+1;
           call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sk0o_entry() //  [R1]
         { info_tbl: [(ckCB,
                       label: sat_sk0o_info
                       rep:HeapRep 2 ptrs 1 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckCB:
           _sk0o::P64 = R1;
           goto ckCx;
       ckCx:
           if ((old + 0) - <highSp> < SpLim) goto ckCF; else goto ckCG;
       ckCG:
           goto ckCw;
       ckCw:
           Hp = Hp + 16;
           if (Hp > HpLim) goto ckCI; else goto ckCH;
       ckCI:
           HpAlloc = 16;
           goto ckCF;
       ckCF:
           R1 = _sk0o::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ckCH:
           _sjYJ::P64 = P64[_sk0o::P64 + 7];
           _sjZg::P64 = P64[_sk0o::P64 + 15];
           _sjZy::I64 = I64[_sk0o::P64 + 23];
           _ckCz::I64 = _sjZy::I64 + 1;
           _sk0j::I64 = _ckCz::I64;
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _sk0j::I64;
           _ckCD::P64 = Hp - 7;
           I64[(young<ckCE> + 8)] = ckCE;
           R5 = _ckCD::P64;
           R4 = _sjYJ::P64;
           R3 = _sjZg::P64;
           R2 = GHC.Classes.$fOrdWord_closure;
           call SkipList.$wa3_info(R5,
                                   R4,
                                   R3,
                                   R2) returns to ckCE, args: 8, res: 8, upd: 8;
       ckCE:
           _sk0n::P64 = R1;
           R1 = GHC.Tuple.()_closure+1;
           call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Main.$wa1_entry() //  [R6, R5, R4, R3, R2]
         { info_tbl: [(ckCL,
                       label: Main.$wa1_info
                       rep:HeapRep static {
                             Fun {arity: 13
                                  fun_type: ArgGen [False, False, True, True, True, False, False,
                                                    True, True, False, True, True]} })]
           stack_info: arg_space: 64 updfr_space: Just 8
         }
     {offset
       ckCL:
           _sjYH::I64 = R6;
           _sjYG::I64 = R5;
           _sjYF::I64 = R4;
           _sjYE::P64 = R3;
           _sjYD::P64 = R2;
           _sjYI::P64 = P64[(old + 64)];
           _sjYJ::P64 = P64[(old + 56)];
           _sjYK::I64 = I64[(old + 48)];
           _sjYL::I64 = I64[(old + 40)];
           _sjYM::P64 = P64[(old + 32)];
           _sjYN::I64 = I64[(old + 24)];
           _sjYO::F64 = F64[(old + 16)];
           goto ckAq;
       ckAq:
           if ((old + 0) - <highSp> < SpLim) goto ckCM; else goto ckCN;
       ckCN:
           goto ckAp;
       ckAp:
           if (HpLim == 0) goto ckCM; else goto ckCO;
       ckCM:
           R1 = Main.$wa1_closure;
           P64[(old + 104)] = _sjYD::P64;
           P64[(old + 96)] = _sjYE::P64;
           I64[(old + 88)] = _sjYF::I64;
           I64[(old + 80)] = _sjYG::I64;
           I64[(old + 72)] = _sjYH::I64;
           P64[(old + 64)] = _sjYI::P64;
           P64[(old + 56)] = _sjYJ::P64;
           I64[(old + 48)] = _sjYK::I64;
           I64[(old + 40)] = _sjYL::I64;
           P64[(old + 32)] = _sjYM::P64;
           I64[(old + 24)] = _sjYN::I64;
           F64[(old + 16)] = _sjYO::F64;
           call (stg_gc_fun)(R1) args: 104, res: 0, upd: 8;
       ckCO:
           _ckAt::I64 = 100000;
           (_ckAs::F64) = call MO_UF_Conv W64(_ckAt::I64);
           _sjYR::F64 = _ckAs::F64;
           _ckAw::F64 = %MO_F_Quot_W64(_sjYO::F64, 100.0 :: W64);
           _sjYQ::F64 = _ckAw::F64;
           _ckAz::F64 = %MO_F_Mul_W64(_sjYQ::F64, _sjYR::F64);
           _sjYS::F64 = _ckAz::F64;
           I64[(young<ckAC> + 8)] = ckAC;
           D1 = _sjYS::F64;
           R2 = GHC.Real.$fIntegralWord_closure;
           call GHC.Float.$w$cproperFraction_info(D1,
                                                  R2) returns to ckAC, args: 8, res: 8, upd: 8;
       ckAC:
           _sjYV::P64 = R2;
           _sjYU::P64 = R1;
           I64[(young<ckAE> + 8)] = ckAE;
           R1 = _sjYV::P64;
           if (R1 & 7 != 0) goto ckAE; else goto ckAF;
       ckAF:
           call (I64[R1])(R1) returns to ckAE, args: 8, res: 8, upd: 8;
       ckAE:
           _sjYW::P64 = R1;
           _sjYX::F64 = F64[_sjYW::P64 + 7];
           _ckEy::I64 = %MO_F_Lt_W64(_sjYX::F64, 0.0 :: W64);
           _sk0Q::I64 = _ckEy::I64;
           switch [0 .. 1] _sk0Q::I64 {
               case 0 : goto ckEF;
               case 1 : goto ckEN;
           }
       ckEN:
           I64[(young<ckEM> + 8)] = ckEM;
           R1 = _sjYU::P64;
           if (R1 & 7 != 0) goto ckEM; else goto ckEO;
       ckEO:
           call (I64[R1])(R1) returns to ckEM, args: 8, res: 8, upd: 8;
       ckEM:
           _sk0U::P64 = R1;
           _sk0V::I64 = I64[_sk0U::P64 + 7];
           _ckF1::I64 = _sk0V::I64 - 1;
           _sk0W::I64 = _ckF1::I64;
           _sjYZ::I64 = _sk0W::I64;
           goto sjYY;
       ckEF:
           I64[(young<ckED> + 8)] = ckED;
           R1 = _sjYU::P64;
           if (R1 & 7 != 0) goto ckED; else goto ckEG;
       ckEG:
           call (I64[R1])(R1) returns to ckED, args: 8, res: 8, upd: 8;
       ckED:
           _sk0S::P64 = R1;
           _sk0T::I64 = I64[_sk0S::P64 + 7];
           _sjYZ::I64 = _sk0T::I64;
           goto sjYY;
       sjYY:
           goto ckAM;
       ckAM:
           if (HpLim == 0) goto ckCR; else goto ckCS;
       ckCR:
           I64[(young<ckAL> + 8)] = ckAL;
           R1 = _sjYZ::I64;
           call stg_gc_unbx_r1(R1) returns to ckAL, args: 8, res: 8, upd: 8;
       ckAL:
           _sjYZ::I64 = R1;
           goto ckAM;
       ckCS:
           _ckAP::I64 = 100000;
           (_ckAO::F64) = call MO_UF_Conv W64(_ckAP::I64);
           _sjZ4::F64 = _ckAO::F64;
           _ckAS::F64 = %MO_F_Sub_W64(100.0 :: W64, _sjYO::F64);
           _sjZ0::F64 = _ckAS::F64;
           _ckAV::F64 = %MO_F_Quot_W64(_sjZ0::F64, 2.0 :: W64);
           _sjZ1::F64 = _ckAV::F64;
           _ckAY::F64 = %MO_F_Add_W64(_sjZ1::F64, _sjYO::F64);
           _sjZ2::F64 = _ckAY::F64;
           _ckB1::F64 = %MO_F_Quot_W64(_sjZ2::F64, 100.0 :: W64);
           _sjZ3::F64 = _ckB1::F64;
           _ckB4::F64 = %MO_F_Mul_W64(_sjZ3::F64, _sjZ4::F64);
           _sjZ5::F64 = _ckB4::F64;
           I64[(young<ckB7> + 8)] = ckB7;
           D1 = _sjZ5::F64;
           R2 = GHC.Real.$fIntegralWord_closure;
           call GHC.Float.$w$cproperFraction_info(D1,
                                                  R2) returns to ckB7, args: 8, res: 8, upd: 8;
       ckB7:
           _sjZ8::P64 = R2;
           _sjZ7::P64 = R1;
           I64[(young<ckB9> + 8)] = ckB9;
           R1 = _sjZ8::P64;
           if (R1 & 7 != 0) goto ckB9; else goto ckBa;
       ckBa:
           call (I64[R1])(R1) returns to ckB9, args: 8, res: 8, upd: 8;
       ckB9:
           _sjZ9::P64 = R1;
           _sjZa::F64 = F64[_sjZ9::P64 + 7];
           _ckEd::I64 = %MO_F_Lt_W64(_sjZa::F64, 0.0 :: W64);
           _sk0J::I64 = _ckEd::I64;
           switch [0 .. 1] _sk0J::I64 {
               case 0 : goto ckEk;
               case 1 : goto ckEs;
           }
       ckEs:
           I64[(young<ckEr> + 8)] = ckEr;
           R1 = _sjZ7::P64;
           if (R1 & 7 != 0) goto ckEr; else goto ckEt;
       ckEt:
           call (I64[R1])(R1) returns to ckEr, args: 8, res: 8, upd: 8;
       ckEr:
           _sk0N::P64 = R1;
           _sk0O::I64 = I64[_sk0N::P64 + 7];
           _ckF2::I64 = _sk0O::I64 - 1;
           _sk0P::I64 = _ckF2::I64;
           _sjZc::I64 = _sk0P::I64;
           goto sjZb;
       ckEk:
           I64[(young<ckEi> + 8)] = ckEi;
           R1 = _sjZ7::P64;
           if (R1 & 7 != 0) goto ckEi; else goto ckEl;
       ckEl:
           call (I64[R1])(R1) returns to ckEi, args: 8, res: 8, upd: 8;
       ckEi:
           _sk0L::P64 = R1;
           _sk0M::I64 = I64[_sk0L::P64 + 7];
           _sjZc::I64 = _sk0M::I64;
           goto sjZb;
       sjZb:
           goto ckBh;
       ckBh:
           Hp = Hp + 120;
           if (Hp > HpLim) goto ckCX; else goto ckCW;
       ckCX:
           HpAlloc = 120;
           goto ckCV;
       ckCV:
           I64[(young<ckBg> + 8)] = ckBg;
           R1 = _sjZc::I64;
           call stg_gc_unbx_r1(R1) returns to ckBg, args: 8, res: 8, upd: 8;
       ckBg:
           _sjZc::I64 = R1;
           goto ckBh;
       ckCW:
           I64[Hp - 112] = Data.Vector.Primitive.Mutable.MVector_con_info;
           P64[Hp - 104] = _sjYM::P64;
           I64[Hp - 96] = _sjYK::I64;
           I64[Hp - 88] = _sjYL::I64;
           _ckBj::P64 = Hp - 111;
           I64[Hp - 80] = GHC.Types.I#_con_info;
           I64[Hp - 72] = _sjYG::I64;
           _ckBk::P64 = Hp - 79;
           I64[Hp - 64] = GHC.Types.I#_con_info;
           I64[Hp - 56] = _sjYF::I64;
           _ckBl::P64 = Hp - 63;
           I64[Hp - 48] = GHC.Arr.Array_con_info;
           P64[Hp - 40] = _ckBl::P64;
           P64[Hp - 32] = _ckBk::P64;
           P64[Hp - 24] = _sjYI::P64;
           I64[Hp - 16] = _sjYH::I64;
           _ckBm::P64 = Hp - 47;
           I64[Hp - 8] = Data.Primitive.ByteArray.MutableByteArray_con_info;
           P64[Hp] = _sjYE::P64;
           _ckF3::P64 = Hp - 7;
           _B2::P64 = _ckF3::P64;
           goto sk0H;
       sk0H:
           goto ckE9;
       ckE9:
           if (HpLim == 0) goto ckEb; else goto ckEc;
       ckEb:
           I64[(young<ckE8> + 8)] = ckE8;
           R1 = _B2::P64;
           call stg_gc_unpt_r1(R1) returns to ckE8, args: 8, res: 8, upd: 8;
       ckE8:
           _B2::P64 = R1;
           goto ckE9;
       ckEc:
           _sk0D::P64 = _B2::P64;
           goto sk0C;
       sk0C:
           goto ckDW;
       ckDW:
           if (HpLim == 0) goto ckDZ; else goto ckE0;
       ckDZ:
           I64[(young<ckDV> + 8)] = ckDV;
           R1 = _sk0D::P64;
           call stg_gc_unpt_r1(R1) returns to ckDV, args: 8, res: 8, upd: 8;
       ckDV:
           _sk0D::P64 = R1;
           goto ckDW;
       ckE0:
           I64[(young<ckDY> + 8)] = ckDY;
           R1 = _sk0D::P64;
           if (R1 & 7 != 0) goto ckDY; else goto ckE1;
       ckE1:
           call (I64[R1])(R1) returns to ckDY, args: 8, res: 8, upd: 8;
       ckDY:
           _sk0F::P64 = R1;
           _sk0G::P64 = P64[_sk0F::P64 + 7];
           _sjZi::P64 = _sk0G::P64;
           goto sjZh;
       sjZh:
           goto ckBq;
       ckBq:
           if (HpLim == 0) goto ckCY; else goto ckCZ;
       ckCY:
           I64[(young<ckBp> + 8)] = ckBp;
           R1 = _sjZi::P64;
           call stg_gc_unpt_r1(R1) returns to ckBp, args: 8, res: 8, upd: 8;
       ckBp:
           _sjZi::P64 = R1;
           goto ckBq;
       ckCZ:
           _sjZm::I64 = I64[_sjZi::P64 + 16];
           _sjZm::I64 = _sjZm::I64;
           I64[(young<ckBs> + 8)] = ckBs;
           R2 = _sjZm::I64;
           call $wgo1_rjVd_info(R2) returns to ckBs, args: 8, res: 8, upd: 8;
       ckBs:
           _sjZp::I64 = R2;
           _sjZo::I64 = R1;
           goto ckBt;
       ckBt:
           I64[_sjZi::P64 + 16] = _sjZo::I64;
           _sjZt::I64 = I64[_sjZi::P64 + 16];
           _sjZt::I64 = _sjZt::I64;
           _ckBy::I64 = _sjYN::I64 - 2;
           _sjZu::I64 = _ckBy::I64;
           _ckBB::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_sjZu::I64));
           _sjZv::I64 = _ckBB::I64;
           I64[(young<ckBE> + 8)] = ckBE;
           R3 = _sjZt::I64;
           R2 = _sjZv::I64;
           call System.Random.PCG.Fast.Pure.$wbounded_info(R3,
                                                           R2) returns to ckBE, args: 8, res: 8, upd: 8;
       ckBE:
           _sjZy::I64 = R2;
           _sjZx::I64 = R1;
           goto ckBF;
       ckBF:
           Hp = Hp + 40;
           if (Hp > HpLim) goto ckD3; else goto ckD2;
       ckD3:
           HpAlloc = 40;
           goto ckD1;
       ckD1:
           I64[(young<ckBG> + 8)] = ckBG;
           call stg_gc_noregs() returns to ckBG, args: 8, res: 8, upd: 8;
       ckBG:
           goto ckBF;
       ckD2:
           I64[_sjZi::P64 + 16] = _sjZx::I64;
           _ckBK::I64 = _sjZp::I64 <= _sjYZ::I64;
           _sjZA::I64 = _ckBK::I64;
           switch [0 .. 1] _sjZA::I64 {
               case 0 : goto ckDC;
               case 1 : goto ckDG;
           }
       ckDG:
           I64[Hp - 32] = sat_sk0o_info;
           P64[Hp - 24] = _sjYJ::P64;
           P64[Hp - 16] = _ckBm::P64;
           I64[Hp - 8] = _sjZy::I64;
           _ckCu::P64 = Hp - 31;
           Hp = Hp - 8;
           I64[(young<ckDD> + 8)] = ckDD;
           R1 = _ckCu::P64;
           call stg_norec_atomically#(R1) returns to ckDD, args: 8, res: 8, upd: 8;
       ckDD:
           _sk0r::P64 = R1;
           _sk0u::P64 = P64[_sjYD::P64 + 8];
           _sk0u::P64 = _sk0u::P64;
           I64[(young<ckDF> + 8)] = ckDF;
           R1 = _sk0u::P64;
           if (R1 & 7 != 0) goto ckDF; else goto ckDI;
       ckDI:
           call (I64[R1])(R1) returns to ckDF, args: 8, res: 8, upd: 8;
       ckDF:
           _sk0v::P64 = R1;
           Hp = Hp + 16;
           if (Hp > HpLim) goto ckDO; else goto ckDN;
       ckDO:
           HpAlloc = 16;
           goto ckDM;
       ckDM:
           R1 = _sk0v::P64;
           call stg_gc_unpt_r1(R1) returns to ckDF, args: 8, res: 8, upd: 8;
       ckDN:
           _sk0w::I64 = I64[_sk0v::P64 + 7];
           _sk0x::I64 = _sk0w::I64;
           switch [0 .. 18446744073709551615] _sk0x::I64 {
               case 18446744073709551615 : goto ckDS;
               default: goto ckDR;
           }
       ckDS:
           Hp = Hp - 16;
           R1 = GHC.Word.$fEnumWord12_closure;
           call (I64[R1])(R1) args: 8, res: 0, upd: 8;
       ckDR:
           _ckF5::I64 = _sk0x::I64 + 1;
           _sk0y::I64 = _ckF5::I64;
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _sk0y::I64;
           _ckF8::P64 = Hp - 7;
           P64[_sjYD::P64 + 8] = _ckF8::P64;
           _ckF9::I64 = dirty_MUT_VAR;
           _ckFa::I64 = BaseReg;
           _ckFb::P64 = _sjYD::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] (_ckF9::I64)(_ckFa::I64, _ckFb::P64);
           _sjZi::P64 = _sjZi::P64;
           goto sjZh;
       ckDC:
           _ckBP::I64 = _sjZp::I64 <= _sjZc::I64;
           _sjZC::I64 = _ckBP::I64;
           switch [0 .. 1] _sjZC::I64 {
               case 0 : goto ckD8;
               case 1 : goto ckDo;
           }
       ckDo:
           I64[Hp - 32] = sat_sk04_info;
           P64[Hp - 24] = _sjYJ::P64;
           P64[Hp - 16] = _ckBj::P64;
           P64[Hp - 8] = _ckBm::P64;
           I64[Hp] = _sjZy::I64;
           _ckCc::P64 = Hp - 31;
           I64[(young<ckDl> + 8)] = ckDl;
           R1 = _ckCc::P64;
           call stg_norec_atomically#(R1) returns to ckDl, args: 8, res: 8, upd: 8;
       ckDl:
           _sk07::P64 = R1;
           _sk0a::P64 = P64[_sjYD::P64 + 8];
           _sk0a::P64 = _sk0a::P64;
           I64[(young<ckDn> + 8)] = ckDn;
           R1 = _sk0a::P64;
           if (R1 & 7 != 0) goto ckDn; else goto ckDq;
       ckDq:
           call (I64[R1])(R1) returns to ckDn, args: 8, res: 8, upd: 8;
       ckDn:
           _sk0b::P64 = R1;
           Hp = Hp + 16;
           if (Hp > HpLim) goto ckDw; else goto ckDv;
       ckDw:
           HpAlloc = 16;
           goto ckDu;
       ckDu:
           R1 = _sk0b::P64;
           call stg_gc_unpt_r1(R1) returns to ckDn, args: 8, res: 8, upd: 8;
       ckDv:
           _sk0c::I64 = I64[_sk0b::P64 + 7];
           _sk0d::I64 = _sk0c::I64;
           switch [0 .. 18446744073709551615] _sk0d::I64 {
               case 18446744073709551615 : goto ckDA;
               default: goto ckDz;
           }
       ckDA:
           Hp = Hp - 16;
           R1 = GHC.Word.$fEnumWord12_closure;
           call (I64[R1])(R1) args: 8, res: 0, upd: 8;
       ckDz:
           _ckFd::I64 = _sk0d::I64 + 1;
           _sk0e::I64 = _ckFd::I64;
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _sk0e::I64;
           _ckFg::P64 = Hp - 7;
           P64[_sjYD::P64 + 8] = _ckFg::P64;
           _ckFh::I64 = dirty_MUT_VAR;
           _ckFi::I64 = BaseReg;
           _ckFj::P64 = _sjYD::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] (_ckFh::I64)(_ckFi::I64, _ckFj::P64);
           _sjZi::P64 = _sjZi::P64;
           goto sjZh;
       ckD8:
           I64[Hp - 32] = sat_sjZK_info;
           P64[Hp - 24] = _sjYJ::P64;
           P64[Hp - 16] = _ckBm::P64;
           I64[Hp - 8] = _sjZy::I64;
           _ckBU::P64 = Hp - 31;
           Hp = Hp - 8;
           I64[(young<ckD4> + 8)] = ckD4;
           R1 = _ckBU::P64;
           call stg_norec_atomically#(R1) returns to ckD4, args: 8, res: 8, upd: 8;
       ckD4:
           _sjZN::P64 = R1;
           _sjZQ::P64 = P64[_sjYD::P64 + 8];
           _sjZQ::P64 = _sjZQ::P64;
           I64[(young<ckD6> + 8)] = ckD6;
           R1 = _sjZQ::P64;
           if (R1 & 7 != 0) goto ckD6; else goto ckDa;
       ckDa:
           call (I64[R1])(R1) returns to ckD6, args: 8, res: 8, upd: 8;
       ckD6:
           _sjZR::P64 = R1;
           Hp = Hp + 16;
           if (Hp > HpLim) goto ckDg; else goto ckDf;
       ckDg:
           HpAlloc = 16;
           goto ckDe;
       ckDe:
           R1 = _sjZR::P64;
           call stg_gc_unpt_r1(R1) returns to ckD6, args: 8, res: 8, upd: 8;
       ckDf:
           _sjZS::I64 = I64[_sjZR::P64 + 7];
           _sjZT::I64 = _sjZS::I64;
           switch [0 .. 18446744073709551615] _sjZT::I64 {
               case 18446744073709551615 : goto ckDk;
               default: goto ckDj;
           }
       ckDk:
           Hp = Hp - 16;
           R1 = GHC.Word.$fEnumWord12_closure;
           call (I64[R1])(R1) args: 8, res: 0, upd: 8;
       ckDj:
           _ckEU::I64 = _sjZT::I64 + 1;
           _sjZU::I64 = _ckEU::I64;
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _sjZU::I64;
           _ckEX::P64 = Hp - 7;
           P64[_sjYD::P64 + 8] = _ckEX::P64;
           _ckEY::I64 = dirty_MUT_VAR;
           _ckEZ::I64 = BaseReg;
           _ckF0::P64 = _sjYD::P64;
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] (_ckEY::I64)(_ckEZ::I64, _ckF0::P64);
           _sjZi::P64 = _sjZi::P64;
           goto sjZh;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:53.43102 UTC

{offset
  ckAo:
      _rbSO::P64 = R1;
      _sjYD::P64 = P64[(old + 104)];
      _sjYE::P64 = P64[(old + 96)];
      _sjYF::I64 = I64[(old + 88)];
      _sjYG::I64 = I64[(old + 80)];
      _sjYH::I64 = I64[(old + 72)];
      _sjYI::P64 = P64[(old + 64)];
      _sjYJ::P64 = P64[(old + 56)];
      _sjYK::I64 = I64[(old + 48)];
      _sjYL::I64 = I64[(old + 40)];
      _sjYM::P64 = P64[(old + 32)];
      _sjYN::I64 = I64[(old + 24)];
      _sjYO::F64 = F64[(old + 16)];
      R6 = _sjYH::I64;
      R5 = _sjYG::I64;
      R4 = _sjYF::I64;
      R3 = _sjYE::P64;
      R2 = _sjYD::P64;
      R1 = _rbSO::P64;
      P64[(old + 64)] = _sjYI::P64;
      P64[(old + 56)] = _sjYJ::P64;
      I64[(old + 48)] = _sjYK::I64;
      I64[(old + 40)] = _sjYL::I64;
      P64[(old + 32)] = _sjYM::P64;
      I64[(old + 24)] = _sjYN::I64;
      F64[(old + 16)] = _sjYO::F64;
      call Main.$wa1_info(R6,
                          R5,
                          R4,
                          R3,
                          R2,
                          R1) args: 64, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:53.432602 UTC

{offset
  ckAo:
      _rbSO::P64 = R1;
      _sjYD::P64 = P64[(old + 104)];
      _sjYE::P64 = P64[(old + 96)];
      _sjYF::I64 = I64[(old + 88)];
      _sjYG::I64 = I64[(old + 80)];
      _sjYH::I64 = I64[(old + 72)];
      _sjYI::P64 = P64[(old + 64)];
      _sjYJ::P64 = P64[(old + 56)];
      _sjYK::I64 = I64[(old + 48)];
      _sjYL::I64 = I64[(old + 40)];
      _sjYM::P64 = P64[(old + 32)];
      _sjYN::I64 = I64[(old + 24)];
      _sjYO::F64 = F64[(old + 16)];
      R6 = _sjYH::I64;
      R5 = _sjYG::I64;
      R4 = _sjYF::I64;
      R3 = _sjYE::P64;
      R2 = _sjYD::P64;
      R1 = _rbSO::P64;
      P64[(old + 64)] = _sjYI::P64;
      P64[(old + 56)] = _sjYJ::P64;
      I64[(old + 48)] = _sjYK::I64;
      I64[(old + 40)] = _sjYL::I64;
      P64[(old + 32)] = _sjYM::P64;
      I64[(old + 24)] = _sjYN::I64;
      F64[(old + 16)] = _sjYO::F64;
      call Main.$wa1_info(R6,
                          R5,
                          R4,
                          R3,
                          R2,
                          R1) args: 64, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:53.434098 UTC

{offset
  ckAo:
      _rbSO::P64 = R1;
      _sjYD::P64 = P64[(old + 104)];
      _sjYE::P64 = P64[(old + 96)];
      _sjYF::I64 = I64[(old + 88)];
      _sjYG::I64 = I64[(old + 80)];
      _sjYH::I64 = I64[(old + 72)];
      _sjYI::P64 = P64[(old + 64)];
      _sjYJ::P64 = P64[(old + 56)];
      _sjYK::I64 = I64[(old + 48)];
      _sjYL::I64 = I64[(old + 40)];
      _sjYM::P64 = P64[(old + 32)];
      _sjYN::I64 = I64[(old + 24)];
      _sjYO::F64 = F64[(old + 16)];
      R6 = _sjYH::I64;
      R5 = _sjYG::I64;
      R4 = _sjYF::I64;
      R3 = _sjYE::P64;
      R2 = _sjYD::P64;
      R1 = _rbSO::P64;
      P64[(old + 64)] = _sjYI::P64;
      P64[(old + 56)] = _sjYJ::P64;
      I64[(old + 48)] = _sjYK::I64;
      I64[(old + 40)] = _sjYL::I64;
      P64[(old + 32)] = _sjYM::P64;
      I64[(old + 24)] = _sjYN::I64;
      F64[(old + 16)] = _sjYO::F64;
      call Main.$wa1_info(R6,
                          R5,
                          R4,
                          R3,
                          R2,
                          R1) args: 64, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:53.435568 UTC

{offset
  ckAo:
      _rbSO::P64 = R1;
      _sjYD::P64 = P64[Sp];
      _sjYE::P64 = P64[Sp + 8];
      _sjYF::I64 = I64[Sp + 16];
      _sjYG::I64 = I64[Sp + 24];
      _sjYH::I64 = I64[Sp + 32];
      _sjYI::P64 = P64[Sp + 40];
      _sjYJ::P64 = P64[Sp + 48];
      _sjYK::I64 = I64[Sp + 56];
      _sjYL::I64 = I64[Sp + 64];
      _sjYM::P64 = P64[Sp + 72];
      _sjYN::I64 = I64[Sp + 80];
      _sjYO::F64 = F64[Sp + 88];
      R6 = _sjYH::I64;
      R5 = _sjYG::I64;
      R4 = _sjYF::I64;
      R3 = _sjYE::P64;
      R2 = _sjYD::P64;
      R1 = _rbSO::P64;
      Sp = Sp + 40;
      call Main.$wa1_info(R6,
                          R5,
                          R4,
                          R3,
                          R2,
                          R1) args: 64, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:53.436837 UTC

{offset
  ckAo:
      R6 = I64[Sp + 32];
      R5 = I64[Sp + 24];
      R4 = I64[Sp + 16];
      R3 = P64[Sp + 8];
      R2 = P64[Sp];
      R1 = R1;
      Sp = Sp + 40;
      call Main.$wa1_info(R6,
                          R5,
                          R4,
                          R3,
                          R2,
                          R1) args: 64, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:53.437697 UTC

[(ckAo, {Main.$wa1_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:53.437969 UTC

Main.$wa1_slow() //  [R1]
        { info_tbl: []
          stack_info: arg_space: 104 updfr_space: Just 8
        }
    {offset
      ckAo:
          R6 = I64[Sp + 32];
          R5 = I64[Sp + 24];
          R4 = I64[Sp + 16];
          R3 = P64[Sp + 8];
          R2 = P64[Sp];
          R1 = R1;
          Sp = Sp + 40;
          call Main.$wa1_info(R6,
                              R5,
                              R4,
                              R3,
                              R2,
                              R1) args: 64, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:53.438753 UTC

Main.$wa1_slow() //  [R1]
        { info_tbl: []
          stack_info: arg_space: 104 updfr_space: Just 8
        }
    {offset
      ckAo:
          R6 = I64[Sp + 32];
          R5 = I64[Sp + 24];
          R4 = I64[Sp + 16];
          R3 = P64[Sp + 8];
          R2 = P64[Sp];
          R1 = R1;
          Sp = Sp + 40;
          call Main.$wa1_info(R6,
                              R5,
                              R4,
                              R3,
                              R2,
                              R1) args: 64, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:53.439666 UTC

{offset
  ckC1:
      _sjZK::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckC5; else goto ckC6;
  ckC6:
      Hp = Hp + 16;
      if (Hp > HpLim) goto ckC8; else goto ckC7;
  ckC8:
      HpAlloc = 16;
      goto ckC5;
  ckC5:
      R1 = _sjZK::P64;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  ckC7:
      _sjYJ::P64 = P64[_sjZK::P64 + 7];
      _sjZg::P64 = P64[_sjZK::P64 + 15];
      _sjZy::I64 = I64[_sjZK::P64 + 23];
      _ckBZ::I64 = _sjZy::I64 + 1;
      _sjZF::I64 = _ckBZ::I64;
      I64[Hp - 8] = GHC.Types.W#_con_info;
      I64[Hp] = _sjZF::I64;
      _ckC3::P64 = Hp - 7;
      I64[(young<ckC4> + 8)] = ckC4;
      R5 = _ckC3::P64;
      R4 = _sjYJ::P64;
      R3 = _sjZg::P64;
      R2 = GHC.Classes.$fOrdWord_closure;
      call SkipList.$wa2_info(R5,
                              R4,
                              R3,
                              R2) returns to ckC4, args: 8, res: 8, upd: 8;
  ckC4:
      _sjZJ::P64 = R1;
      R1 = GHC.Tuple.()_closure+1;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:53.441258 UTC

{offset
  ckC1:
      _sjZK::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckC5; else goto ckC6;
  ckC6:
      Hp = Hp + 16;
      if (Hp > HpLim) goto ckC8; else goto ckC7;
  ckC8:
      HpAlloc = 16;
      goto ckC5;
  ckC5:
      R1 = _sjZK::P64;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  ckC7:
      _sjYJ::P64 = P64[_sjZK::P64 + 7];
      _sjZg::P64 = P64[_sjZK::P64 + 15];
      _sjZy::I64 = I64[_sjZK::P64 + 23];
      _ckBZ::I64 = _sjZy::I64 + 1;
      _sjZF::I64 = _ckBZ::I64;
      I64[Hp - 8] = GHC.Types.W#_con_info;
      I64[Hp] = _sjZF::I64;
      _ckC3::P64 = Hp - 7;
      I64[(young<ckC4> + 8)] = ckC4;
      R5 = _ckC3::P64;
      R4 = _sjYJ::P64;
      R3 = _sjZg::P64;
      R2 = GHC.Classes.$fOrdWord_closure;
      call SkipList.$wa2_info(R5,
                              R4,
                              R3,
                              R2) returns to ckC4, args: 8, res: 8, upd: 8;
  ckC4:
      _sjZJ::P64 = R1;
      R1 = GHC.Tuple.()_closure+1;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:53.442859 UTC

{offset
  ckC1:
      _sjZK::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckC5; else goto ckC6;
  ckC6:
      Hp = Hp + 16;
      if (Hp > HpLim) goto ckC8; else goto ckC7;
  ckC8:
      HpAlloc = 16;
      goto ckC5;
  ckC5:
      R1 = _sjZK::P64;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  ckC7:
      _sjYJ::P64 = P64[_sjZK::P64 + 7];
      _sjZg::P64 = P64[_sjZK::P64 + 15];
      _sjZy::I64 = I64[_sjZK::P64 + 23];
      _ckBZ::I64 = _sjZy::I64 + 1;
      _sjZF::I64 = _ckBZ::I64;
      I64[Hp - 8] = GHC.Types.W#_con_info;
      I64[Hp] = _sjZF::I64;
      _ckC3::P64 = Hp - 7;
      I64[(young<ckC4> + 8)] = ckC4;
      R5 = _ckC3::P64;
      R4 = _sjYJ::P64;
      R3 = _sjZg::P64;
      R2 = GHC.Classes.$fOrdWord_closure;
      call SkipList.$wa2_info(R5,
                              R4,
                              R3,
                              R2) returns to ckC4, args: 8, res: 8, upd: 8;
  ckC4:
      _sjZJ::P64 = R1;
      R1 = GHC.Tuple.()_closure+1;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:53.444587 UTC

{offset
  ckC1:
      _sjZK::P64 = R1;
      if ((Sp + 8) - 16 < SpLim) goto ckC5; else goto ckC6;
  ckC6:
      Hp = Hp + 16;
      if (Hp > HpLim) goto ckC8; else goto ckC7;
  ckC8:
      HpAlloc = 16;
      goto ckC5;
  ckC5:
      R1 = _sjZK::P64;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  ckC7:
      _sjYJ::P64 = P64[_sjZK::P64 + 7];
      _sjZg::P64 = P64[_sjZK::P64 + 15];
      _sjZy::I64 = I64[_sjZK::P64 + 23];
      _ckBZ::I64 = _sjZy::I64 + 1;
      _sjZF::I64 = _ckBZ::I64;
      I64[Hp - 8] = GHC.Types.W#_con_info;
      I64[Hp] = _sjZF::I64;
      _ckC3::P64 = Hp - 7;
      I64[Sp - 8] = ckC4;
      R5 = _ckC3::P64;
      R4 = _sjYJ::P64;
      R3 = _sjZg::P64;
      R2 = GHC.Classes.$fOrdWord_closure;
      Sp = Sp - 8;
      call SkipList.$wa2_info(R5,
                              R4,
                              R3,
                              R2) returns to ckC4, args: 8, res: 8, upd: 8;
  ckC4:
      _sjZJ::P64 = R1;
      R1 = GHC.Tuple.()_closure+1;
      Sp = Sp + 8;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:53.446225 UTC

{offset
  ckC1:
      _sjZK::P64 = R1;
      if ((Sp + -8) < SpLim) goto ckC5; else goto ckC6;
  ckC6:
      Hp = Hp + 16;
      if (Hp > HpLim) goto ckC8; else goto ckC7;
  ckC8:
      HpAlloc = 16;
      goto ckC5;
  ckC5:
      R1 = _sjZK::P64;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  ckC7:
      _sjYJ::P64 = P64[_sjZK::P64 + 7];
      _sjZg::P64 = P64[_sjZK::P64 + 15];
      _sjZF::I64 = I64[_sjZK::P64 + 23] + 1;
      I64[Hp - 8] = GHC.Types.W#_con_info;
      I64[Hp] = _sjZF::I64;
      I64[Sp - 8] = ckC4;
      R5 = Hp - 7;
      R4 = _sjYJ::P64;
      R3 = _sjZg::P64;
      R2 = GHC.Classes.$fOrdWord_closure;
      Sp = Sp - 8;
      call SkipList.$wa2_info(R5,
                              R4,
                              R3,
                              R2) returns to ckC4, args: 8, res: 8, upd: 8;
  ckC4:
      R1 = GHC.Tuple.()_closure+1;
      Sp = Sp + 8;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:53.447919 UTC

[(ckC1, {SkipList.$wa2_closure}), (ckC4, {}), (ckC5, {}),
 (ckC6, {SkipList.$wa2_closure}), (ckC7, {SkipList.$wa2_closure}),
 (ckC8, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:53.448384 UTC

sat_sjZK_entry() //  [R1]
        { info_tbl: [(ckC1,
                      label: sat_sjZK_info
                      rep:HeapRep 2 ptrs 1 nonptrs {
                            Fun {arity: 1 fun_type: ArgSpec 3} }),
                     (ckC4,
                      label: block_ckC4_info
                      rep:StackRep [])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckC1:
          _sjZK::P64 = R1;
          if ((Sp + -8) < SpLim) goto ckC5; else goto ckC6;
      ckC6:
          Hp = Hp + 16;
          if (Hp > HpLim) goto ckC8; else goto ckC7;
      ckC8:
          HpAlloc = 16;
          goto ckC5;
      ckC5:
          R1 = _sjZK::P64;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
      ckC7:
          _sjYJ::P64 = P64[_sjZK::P64 + 7];
          _sjZg::P64 = P64[_sjZK::P64 + 15];
          _sjZF::I64 = I64[_sjZK::P64 + 23] + 1;
          I64[Hp - 8] = GHC.Types.W#_con_info;
          I64[Hp] = _sjZF::I64;
          I64[Sp - 8] = ckC4;
          R5 = Hp - 7;
          R4 = _sjYJ::P64;
          R3 = _sjZg::P64;
          R2 = GHC.Classes.$fOrdWord_closure;
          Sp = Sp - 8;
          call SkipList.$wa2_info(R5,
                                  R4,
                                  R3,
                                  R2) returns to ckC4, args: 8, res: 8, upd: 8;
      ckC4:
          R1 = GHC.Tuple.()_closure+1;
          Sp = Sp + 8;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:53.450367 UTC

sat_sjZK_entry() //  [R1]
        { info_tbl: [(ckC1,
                      label: sat_sjZK_info
                      rep:HeapRep 2 ptrs 1 nonptrs {
                            Fun {arity: 1 fun_type: ArgSpec 3} }),
                     (ckC4,
                      label: block_ckC4_info
                      rep:StackRep [])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckC1:
          _sjZK::P64 = R1;
          if ((Sp + -8) < SpLim) goto ckC5; else goto ckC6;
      ckC6:
          Hp = Hp + 16;
          if (Hp > HpLim) goto ckC8; else goto ckC7;
      ckC8:
          HpAlloc = 16;
          goto ckC5;
      ckC5:
          R1 = _sjZK::P64;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
      ckC7:
          _sjYJ::P64 = P64[_sjZK::P64 + 7];
          _sjZg::P64 = P64[_sjZK::P64 + 15];
          _sjZF::I64 = I64[_sjZK::P64 + 23] + 1;
          I64[Hp - 8] = GHC.Types.W#_con_info;
          I64[Hp] = _sjZF::I64;
          I64[Sp - 8] = ckC4;
          R5 = Hp - 7;
          R4 = _sjYJ::P64;
          R3 = _sjZg::P64;
          R2 = GHC.Classes.$fOrdWord_closure;
          Sp = Sp - 8;
          call SkipList.$wa2_info(R5,
                                  R4,
                                  R3,
                                  R2) returns to ckC4, args: 8, res: 8, upd: 8;
      ckC4:
          R1 = GHC.Tuple.()_closure+1;
          Sp = Sp + 8;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:53.452289 UTC

{offset
  ckCj:
      _sk04::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckCn; else goto ckCo;
  ckCo:
      Hp = Hp + 16;
      if (Hp > HpLim) goto ckCq; else goto ckCp;
  ckCq:
      HpAlloc = 16;
      goto ckCn;
  ckCn:
      R1 = _sk04::P64;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  ckCp:
      _sjYJ::P64 = P64[_sk04::P64 + 7];
      _sjZd::P64 = P64[_sk04::P64 + 15];
      _sjZg::P64 = P64[_sk04::P64 + 23];
      _sjZy::I64 = I64[_sk04::P64 + 31];
      _ckCh::I64 = _sjZy::I64 + 1;
      _sjZZ::I64 = _ckCh::I64;
      I64[Hp - 8] = GHC.Types.W#_con_info;
      I64[Hp] = _sjZZ::I64;
      _ckCl::P64 = Hp - 7;
      I64[(young<ckCm> + 8)] = ckCm;
      R6 = _ckCl::P64;
      R5 = _sjZd::P64;
      R4 = _sjYJ::P64;
      R3 = _sjZg::P64;
      R2 = GHC.Classes.$fOrdWord_closure;
      P64[(young<ckCm> + 16)] = GHC.Tuple.()_closure+1;
      call SkipList.$wa4_info(R6,
                              R5,
                              R4,
                              R3,
                              R2) returns to ckCm, args: 16, res: 8, upd: 8;
  ckCm:
      _sk03::P64 = R1;
      R1 = GHC.Tuple.()_closure+1;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:53.454054 UTC

{offset
  ckCj:
      _sk04::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckCn; else goto ckCo;
  ckCo:
      Hp = Hp + 16;
      if (Hp > HpLim) goto ckCq; else goto ckCp;
  ckCq:
      HpAlloc = 16;
      goto ckCn;
  ckCn:
      R1 = _sk04::P64;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  ckCp:
      _sjYJ::P64 = P64[_sk04::P64 + 7];
      _sjZd::P64 = P64[_sk04::P64 + 15];
      _sjZg::P64 = P64[_sk04::P64 + 23];
      _sjZy::I64 = I64[_sk04::P64 + 31];
      _ckCh::I64 = _sjZy::I64 + 1;
      _sjZZ::I64 = _ckCh::I64;
      I64[Hp - 8] = GHC.Types.W#_con_info;
      I64[Hp] = _sjZZ::I64;
      _ckCl::P64 = Hp - 7;
      I64[(young<ckCm> + 8)] = ckCm;
      R6 = _ckCl::P64;
      R5 = _sjZd::P64;
      R4 = _sjYJ::P64;
      R3 = _sjZg::P64;
      R2 = GHC.Classes.$fOrdWord_closure;
      P64[(young<ckCm> + 16)] = GHC.Tuple.()_closure+1;
      call SkipList.$wa4_info(R6,
                              R5,
                              R4,
                              R3,
                              R2) returns to ckCm, args: 16, res: 8, upd: 8;
  ckCm:
      _sk03::P64 = R1;
      R1 = GHC.Tuple.()_closure+1;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:53.455834 UTC

{offset
  ckCj:
      _sk04::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckCn; else goto ckCo;
  ckCo:
      Hp = Hp + 16;
      if (Hp > HpLim) goto ckCq; else goto ckCp;
  ckCq:
      HpAlloc = 16;
      goto ckCn;
  ckCn:
      R1 = _sk04::P64;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  ckCp:
      _sjYJ::P64 = P64[_sk04::P64 + 7];
      _sjZd::P64 = P64[_sk04::P64 + 15];
      _sjZg::P64 = P64[_sk04::P64 + 23];
      _sjZy::I64 = I64[_sk04::P64 + 31];
      _ckCh::I64 = _sjZy::I64 + 1;
      _sjZZ::I64 = _ckCh::I64;
      I64[Hp - 8] = GHC.Types.W#_con_info;
      I64[Hp] = _sjZZ::I64;
      _ckCl::P64 = Hp - 7;
      I64[(young<ckCm> + 8)] = ckCm;
      R6 = _ckCl::P64;
      R5 = _sjZd::P64;
      R4 = _sjYJ::P64;
      R3 = _sjZg::P64;
      R2 = GHC.Classes.$fOrdWord_closure;
      P64[(young<ckCm> + 16)] = GHC.Tuple.()_closure+1;
      call SkipList.$wa4_info(R6,
                              R5,
                              R4,
                              R3,
                              R2) returns to ckCm, args: 16, res: 8, upd: 8;
  ckCm:
      _sk03::P64 = R1;
      R1 = GHC.Tuple.()_closure+1;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:53.457808 UTC

{offset
  ckCj:
      _sk04::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto ckCn; else goto ckCo;
  ckCo:
      Hp = Hp + 16;
      if (Hp > HpLim) goto ckCq; else goto ckCp;
  ckCq:
      HpAlloc = 16;
      goto ckCn;
  ckCn:
      R1 = _sk04::P64;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  ckCp:
      _sjYJ::P64 = P64[_sk04::P64 + 7];
      _sjZd::P64 = P64[_sk04::P64 + 15];
      _sjZg::P64 = P64[_sk04::P64 + 23];
      _sjZy::I64 = I64[_sk04::P64 + 31];
      _ckCh::I64 = _sjZy::I64 + 1;
      _sjZZ::I64 = _ckCh::I64;
      I64[Hp - 8] = GHC.Types.W#_con_info;
      I64[Hp] = _sjZZ::I64;
      _ckCl::P64 = Hp - 7;
      I64[Sp - 8] = ckCm;
      R6 = _ckCl::P64;
      R5 = _sjZd::P64;
      R4 = _sjYJ::P64;
      R3 = _sjZg::P64;
      R2 = GHC.Classes.$fOrdWord_closure;
      P64[Sp - 16] = GHC.Tuple.()_closure+1;
      Sp = Sp - 16;
      call SkipList.$wa4_info(R6,
                              R5,
                              R4,
                              R3,
                              R2) returns to ckCm, args: 16, res: 8, upd: 8;
  ckCm:
      _sk03::P64 = R1;
      R1 = GHC.Tuple.()_closure+1;
      Sp = Sp + 8;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:53.459674 UTC

{offset
  ckCj:
      _sk04::P64 = R1;
      if ((Sp + -16) < SpLim) goto ckCn; else goto ckCo;
  ckCo:
      Hp = Hp + 16;
      if (Hp > HpLim) goto ckCq; else goto ckCp;
  ckCq:
      HpAlloc = 16;
      goto ckCn;
  ckCn:
      R1 = _sk04::P64;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  ckCp:
      _sjYJ::P64 = P64[_sk04::P64 + 7];
      _sjZd::P64 = P64[_sk04::P64 + 15];
      _sjZg::P64 = P64[_sk04::P64 + 23];
      _sjZZ::I64 = I64[_sk04::P64 + 31] + 1;
      I64[Hp - 8] = GHC.Types.W#_con_info;
      I64[Hp] = _sjZZ::I64;
      I64[Sp - 8] = ckCm;
      R6 = Hp - 7;
      R5 = _sjZd::P64;
      R4 = _sjYJ::P64;
      R3 = _sjZg::P64;
      R2 = GHC.Classes.$fOrdWord_closure;
      P64[Sp - 16] = GHC.Tuple.()_closure+1;
      Sp = Sp - 16;
      call SkipList.$wa4_info(R6,
                              R5,
                              R4,
                              R3,
                              R2) returns to ckCm, args: 16, res: 8, upd: 8;
  ckCm:
      R1 = GHC.Tuple.()_closure+1;
      Sp = Sp + 8;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:53.462358 UTC

[(ckCj, {SkipList.$wa4_closure}), (ckCm, {}), (ckCn, {}),
 (ckCo, {SkipList.$wa4_closure}), (ckCp, {SkipList.$wa4_closure}),
 (ckCq, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:53.462842 UTC

sat_sk04_entry() //  [R1]
        { info_tbl: [(ckCj,
                      label: sat_sk04_info
                      rep:HeapRep 3 ptrs 1 nonptrs {
                            Fun {arity: 1 fun_type: ArgSpec 3} }),
                     (ckCm,
                      label: block_ckCm_info
                      rep:StackRep [])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckCj:
          _sk04::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckCn; else goto ckCo;
      ckCo:
          Hp = Hp + 16;
          if (Hp > HpLim) goto ckCq; else goto ckCp;
      ckCq:
          HpAlloc = 16;
          goto ckCn;
      ckCn:
          R1 = _sk04::P64;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
      ckCp:
          _sjYJ::P64 = P64[_sk04::P64 + 7];
          _sjZd::P64 = P64[_sk04::P64 + 15];
          _sjZg::P64 = P64[_sk04::P64 + 23];
          _sjZZ::I64 = I64[_sk04::P64 + 31] + 1;
          I64[Hp - 8] = GHC.Types.W#_con_info;
          I64[Hp] = _sjZZ::I64;
          I64[Sp - 8] = ckCm;
          R6 = Hp - 7;
          R5 = _sjZd::P64;
          R4 = _sjYJ::P64;
          R3 = _sjZg::P64;
          R2 = GHC.Classes.$fOrdWord_closure;
          P64[Sp - 16] = GHC.Tuple.()_closure+1;
          Sp = Sp - 16;
          call SkipList.$wa4_info(R6,
                                  R5,
                                  R4,
                                  R3,
                                  R2) returns to ckCm, args: 16, res: 8, upd: 8;
      ckCm:
          R1 = GHC.Tuple.()_closure+1;
          Sp = Sp + 8;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:53.464956 UTC

sat_sk04_entry() //  [R1]
        { info_tbl: [(ckCj,
                      label: sat_sk04_info
                      rep:HeapRep 3 ptrs 1 nonptrs {
                            Fun {arity: 1 fun_type: ArgSpec 3} }),
                     (ckCm,
                      label: block_ckCm_info
                      rep:StackRep [])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckCj:
          _sk04::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckCn; else goto ckCo;
      ckCo:
          Hp = Hp + 16;
          if (Hp > HpLim) goto ckCq; else goto ckCp;
      ckCq:
          HpAlloc = 16;
          goto ckCn;
      ckCn:
          R1 = _sk04::P64;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
      ckCp:
          _sjYJ::P64 = P64[_sk04::P64 + 7];
          _sjZd::P64 = P64[_sk04::P64 + 15];
          _sjZg::P64 = P64[_sk04::P64 + 23];
          _sjZZ::I64 = I64[_sk04::P64 + 31] + 1;
          I64[Hp - 8] = GHC.Types.W#_con_info;
          I64[Hp] = _sjZZ::I64;
          I64[Sp - 8] = ckCm;
          R6 = Hp - 7;
          R5 = _sjZd::P64;
          R4 = _sjYJ::P64;
          R3 = _sjZg::P64;
          R2 = GHC.Classes.$fOrdWord_closure;
          P64[Sp - 16] = GHC.Tuple.()_closure+1;
          Sp = Sp - 16;
          call SkipList.$wa4_info(R6,
                                  R5,
                                  R4,
                                  R3,
                                  R2) returns to ckCm, args: 16, res: 8, upd: 8;
      ckCm:
          R1 = GHC.Tuple.()_closure+1;
          Sp = Sp + 8;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:53.467092 UTC

{offset
  ckCB:
      _sk0o::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckCF; else goto ckCG;
  ckCG:
      Hp = Hp + 16;
      if (Hp > HpLim) goto ckCI; else goto ckCH;
  ckCI:
      HpAlloc = 16;
      goto ckCF;
  ckCF:
      R1 = _sk0o::P64;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  ckCH:
      _sjYJ::P64 = P64[_sk0o::P64 + 7];
      _sjZg::P64 = P64[_sk0o::P64 + 15];
      _sjZy::I64 = I64[_sk0o::P64 + 23];
      _ckCz::I64 = _sjZy::I64 + 1;
      _sk0j::I64 = _ckCz::I64;
      I64[Hp - 8] = GHC.Types.W#_con_info;
      I64[Hp] = _sk0j::I64;
      _ckCD::P64 = Hp - 7;
      I64[(young<ckCE> + 8)] = ckCE;
      R5 = _ckCD::P64;
      R4 = _sjYJ::P64;
      R3 = _sjZg::P64;
      R2 = GHC.Classes.$fOrdWord_closure;
      call SkipList.$wa3_info(R5,
                              R4,
                              R3,
                              R2) returns to ckCE, args: 8, res: 8, upd: 8;
  ckCE:
      _sk0n::P64 = R1;
      R1 = GHC.Tuple.()_closure+1;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:53.468664 UTC

{offset
  ckCB:
      _sk0o::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckCF; else goto ckCG;
  ckCG:
      Hp = Hp + 16;
      if (Hp > HpLim) goto ckCI; else goto ckCH;
  ckCI:
      HpAlloc = 16;
      goto ckCF;
  ckCF:
      R1 = _sk0o::P64;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  ckCH:
      _sjYJ::P64 = P64[_sk0o::P64 + 7];
      _sjZg::P64 = P64[_sk0o::P64 + 15];
      _sjZy::I64 = I64[_sk0o::P64 + 23];
      _ckCz::I64 = _sjZy::I64 + 1;
      _sk0j::I64 = _ckCz::I64;
      I64[Hp - 8] = GHC.Types.W#_con_info;
      I64[Hp] = _sk0j::I64;
      _ckCD::P64 = Hp - 7;
      I64[(young<ckCE> + 8)] = ckCE;
      R5 = _ckCD::P64;
      R4 = _sjYJ::P64;
      R3 = _sjZg::P64;
      R2 = GHC.Classes.$fOrdWord_closure;
      call SkipList.$wa3_info(R5,
                              R4,
                              R3,
                              R2) returns to ckCE, args: 8, res: 8, upd: 8;
  ckCE:
      _sk0n::P64 = R1;
      R1 = GHC.Tuple.()_closure+1;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:53.470309 UTC

{offset
  ckCB:
      _sk0o::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckCF; else goto ckCG;
  ckCG:
      Hp = Hp + 16;
      if (Hp > HpLim) goto ckCI; else goto ckCH;
  ckCI:
      HpAlloc = 16;
      goto ckCF;
  ckCF:
      R1 = _sk0o::P64;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  ckCH:
      _sjYJ::P64 = P64[_sk0o::P64 + 7];
      _sjZg::P64 = P64[_sk0o::P64 + 15];
      _sjZy::I64 = I64[_sk0o::P64 + 23];
      _ckCz::I64 = _sjZy::I64 + 1;
      _sk0j::I64 = _ckCz::I64;
      I64[Hp - 8] = GHC.Types.W#_con_info;
      I64[Hp] = _sk0j::I64;
      _ckCD::P64 = Hp - 7;
      I64[(young<ckCE> + 8)] = ckCE;
      R5 = _ckCD::P64;
      R4 = _sjYJ::P64;
      R3 = _sjZg::P64;
      R2 = GHC.Classes.$fOrdWord_closure;
      call SkipList.$wa3_info(R5,
                              R4,
                              R3,
                              R2) returns to ckCE, args: 8, res: 8, upd: 8;
  ckCE:
      _sk0n::P64 = R1;
      R1 = GHC.Tuple.()_closure+1;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:53.472085 UTC

{offset
  ckCB:
      _sk0o::P64 = R1;
      if ((Sp + 8) - 16 < SpLim) goto ckCF; else goto ckCG;
  ckCG:
      Hp = Hp + 16;
      if (Hp > HpLim) goto ckCI; else goto ckCH;
  ckCI:
      HpAlloc = 16;
      goto ckCF;
  ckCF:
      R1 = _sk0o::P64;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  ckCH:
      _sjYJ::P64 = P64[_sk0o::P64 + 7];
      _sjZg::P64 = P64[_sk0o::P64 + 15];
      _sjZy::I64 = I64[_sk0o::P64 + 23];
      _ckCz::I64 = _sjZy::I64 + 1;
      _sk0j::I64 = _ckCz::I64;
      I64[Hp - 8] = GHC.Types.W#_con_info;
      I64[Hp] = _sk0j::I64;
      _ckCD::P64 = Hp - 7;
      I64[Sp - 8] = ckCE;
      R5 = _ckCD::P64;
      R4 = _sjYJ::P64;
      R3 = _sjZg::P64;
      R2 = GHC.Classes.$fOrdWord_closure;
      Sp = Sp - 8;
      call SkipList.$wa3_info(R5,
                              R4,
                              R3,
                              R2) returns to ckCE, args: 8, res: 8, upd: 8;
  ckCE:
      _sk0n::P64 = R1;
      R1 = GHC.Tuple.()_closure+1;
      Sp = Sp + 8;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:53.473745 UTC

{offset
  ckCB:
      _sk0o::P64 = R1;
      if ((Sp + -8) < SpLim) goto ckCF; else goto ckCG;
  ckCG:
      Hp = Hp + 16;
      if (Hp > HpLim) goto ckCI; else goto ckCH;
  ckCI:
      HpAlloc = 16;
      goto ckCF;
  ckCF:
      R1 = _sk0o::P64;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  ckCH:
      _sjYJ::P64 = P64[_sk0o::P64 + 7];
      _sjZg::P64 = P64[_sk0o::P64 + 15];
      _sk0j::I64 = I64[_sk0o::P64 + 23] + 1;
      I64[Hp - 8] = GHC.Types.W#_con_info;
      I64[Hp] = _sk0j::I64;
      I64[Sp - 8] = ckCE;
      R5 = Hp - 7;
      R4 = _sjYJ::P64;
      R3 = _sjZg::P64;
      R2 = GHC.Classes.$fOrdWord_closure;
      Sp = Sp - 8;
      call SkipList.$wa3_info(R5,
                              R4,
                              R3,
                              R2) returns to ckCE, args: 8, res: 8, upd: 8;
  ckCE:
      R1 = GHC.Tuple.()_closure+1;
      Sp = Sp + 8;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:53.475415 UTC

[(ckCB, {SkipList.$wa3_closure}), (ckCE, {}), (ckCF, {}),
 (ckCG, {SkipList.$wa3_closure}), (ckCH, {SkipList.$wa3_closure}),
 (ckCI, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:53.475885 UTC

sat_sk0o_entry() //  [R1]
        { info_tbl: [(ckCB,
                      label: sat_sk0o_info
                      rep:HeapRep 2 ptrs 1 nonptrs {
                            Fun {arity: 1 fun_type: ArgSpec 3} }),
                     (ckCE,
                      label: block_ckCE_info
                      rep:StackRep [])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckCB:
          _sk0o::P64 = R1;
          if ((Sp + -8) < SpLim) goto ckCF; else goto ckCG;
      ckCG:
          Hp = Hp + 16;
          if (Hp > HpLim) goto ckCI; else goto ckCH;
      ckCI:
          HpAlloc = 16;
          goto ckCF;
      ckCF:
          R1 = _sk0o::P64;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
      ckCH:
          _sjYJ::P64 = P64[_sk0o::P64 + 7];
          _sjZg::P64 = P64[_sk0o::P64 + 15];
          _sk0j::I64 = I64[_sk0o::P64 + 23] + 1;
          I64[Hp - 8] = GHC.Types.W#_con_info;
          I64[Hp] = _sk0j::I64;
          I64[Sp - 8] = ckCE;
          R5 = Hp - 7;
          R4 = _sjYJ::P64;
          R3 = _sjZg::P64;
          R2 = GHC.Classes.$fOrdWord_closure;
          Sp = Sp - 8;
          call SkipList.$wa3_info(R5,
                                  R4,
                                  R3,
                                  R2) returns to ckCE, args: 8, res: 8, upd: 8;
      ckCE:
          R1 = GHC.Tuple.()_closure+1;
          Sp = Sp + 8;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:53.477876 UTC

sat_sk0o_entry() //  [R1]
        { info_tbl: [(ckCB,
                      label: sat_sk0o_info
                      rep:HeapRep 2 ptrs 1 nonptrs {
                            Fun {arity: 1 fun_type: ArgSpec 3} }),
                     (ckCE,
                      label: block_ckCE_info
                      rep:StackRep [])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckCB:
          _sk0o::P64 = R1;
          if ((Sp + -8) < SpLim) goto ckCF; else goto ckCG;
      ckCG:
          Hp = Hp + 16;
          if (Hp > HpLim) goto ckCI; else goto ckCH;
      ckCI:
          HpAlloc = 16;
          goto ckCF;
      ckCF:
          R1 = _sk0o::P64;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
      ckCH:
          _sjYJ::P64 = P64[_sk0o::P64 + 7];
          _sjZg::P64 = P64[_sk0o::P64 + 15];
          _sk0j::I64 = I64[_sk0o::P64 + 23] + 1;
          I64[Hp - 8] = GHC.Types.W#_con_info;
          I64[Hp] = _sk0j::I64;
          I64[Sp - 8] = ckCE;
          R5 = Hp - 7;
          R4 = _sjYJ::P64;
          R3 = _sjZg::P64;
          R2 = GHC.Classes.$fOrdWord_closure;
          Sp = Sp - 8;
          call SkipList.$wa3_info(R5,
                                  R4,
                                  R3,
                                  R2) returns to ckCE, args: 8, res: 8, upd: 8;
      ckCE:
          R1 = GHC.Tuple.()_closure+1;
          Sp = Sp + 8;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:53.479923 UTC

{offset
  ckCL:
      _sjYH::I64 = R6;
      _sjYG::I64 = R5;
      _sjYF::I64 = R4;
      _sjYE::P64 = R3;
      _sjYD::P64 = R2;
      _sjYI::P64 = P64[(old + 64)];
      _sjYJ::P64 = P64[(old + 56)];
      _sjYK::I64 = I64[(old + 48)];
      _sjYL::I64 = I64[(old + 40)];
      _sjYM::P64 = P64[(old + 32)];
      _sjYN::I64 = I64[(old + 24)];
      _sjYO::F64 = F64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto ckCM; else goto ckCN;
  ckCN:
      if (HpLim == 0) goto ckCM; else goto ckCO;
  ckCM:
      R1 = Main.$wa1_closure;
      P64[(old + 104)] = _sjYD::P64;
      P64[(old + 96)] = _sjYE::P64;
      I64[(old + 88)] = _sjYF::I64;
      I64[(old + 80)] = _sjYG::I64;
      I64[(old + 72)] = _sjYH::I64;
      P64[(old + 64)] = _sjYI::P64;
      P64[(old + 56)] = _sjYJ::P64;
      I64[(old + 48)] = _sjYK::I64;
      I64[(old + 40)] = _sjYL::I64;
      P64[(old + 32)] = _sjYM::P64;
      I64[(old + 24)] = _sjYN::I64;
      F64[(old + 16)] = _sjYO::F64;
      call (stg_gc_fun)(R1) args: 104, res: 0, upd: 8;
  ckCO:
      _ckAt::I64 = 100000;
      (_ckAs::F64) = call MO_UF_Conv W64(_ckAt::I64);
      _sjYR::F64 = _ckAs::F64;
      _ckAw::F64 = %MO_F_Quot_W64(_sjYO::F64, 100.0 :: W64);
      _sjYQ::F64 = _ckAw::F64;
      _ckAz::F64 = %MO_F_Mul_W64(_sjYQ::F64, _sjYR::F64);
      _sjYS::F64 = _ckAz::F64;
      I64[(young<ckAC> + 8)] = ckAC;
      D1 = _sjYS::F64;
      R2 = GHC.Real.$fIntegralWord_closure;
      call GHC.Float.$w$cproperFraction_info(D1,
                                             R2) returns to ckAC, args: 8, res: 8, upd: 8;
  ckAC:
      _sjYV::P64 = R2;
      _sjYU::P64 = R1;
      I64[(young<ckAE> + 8)] = ckAE;
      R1 = _sjYV::P64;
      if (R1 & 7 != 0) goto ckAE; else goto ckAF;
  ckAF:
      call (I64[R1])(R1) returns to ckAE, args: 8, res: 8, upd: 8;
  ckAE:
      _sjYW::P64 = R1;
      _sjYX::F64 = F64[_sjYW::P64 + 7];
      _ckEy::I64 = %MO_F_Lt_W64(_sjYX::F64, 0.0 :: W64);
      _sk0Q::I64 = _ckEy::I64;
      switch [0 .. 1] _sk0Q::I64 {
          case 0 : goto ckEF;
          case 1 : goto ckEN;
      }
  ckEN:
      I64[(young<ckEM> + 8)] = ckEM;
      R1 = _sjYU::P64;
      if (R1 & 7 != 0) goto ckEM; else goto ckEO;
  ckEO:
      call (I64[R1])(R1) returns to ckEM, args: 8, res: 8, upd: 8;
  ckEM:
      _sk0U::P64 = R1;
      _sk0V::I64 = I64[_sk0U::P64 + 7];
      _ckF1::I64 = _sk0V::I64 - 1;
      _sk0W::I64 = _ckF1::I64;
      _sjYZ::I64 = _sk0W::I64;
      goto ckAM;
  ckEF:
      I64[(young<ckED> + 8)] = ckED;
      R1 = _sjYU::P64;
      if (R1 & 7 != 0) goto ckED; else goto ckEG;
  ckEG:
      call (I64[R1])(R1) returns to ckED, args: 8, res: 8, upd: 8;
  ckED:
      _sk0S::P64 = R1;
      _sk0T::I64 = I64[_sk0S::P64 + 7];
      _sjYZ::I64 = _sk0T::I64;
      goto ckAM;
  ckAM:
      if (HpLim == 0) goto ckCR; else goto ckCS;
  ckCR:
      I64[(young<ckAL> + 8)] = ckAL;
      R1 = _sjYZ::I64;
      call stg_gc_unbx_r1(R1) returns to ckAL, args: 8, res: 8, upd: 8;
  ckAL:
      _sjYZ::I64 = R1;
      goto ckAM;
  ckCS:
      _ckAP::I64 = 100000;
      (_ckAO::F64) = call MO_UF_Conv W64(_ckAP::I64);
      _sjZ4::F64 = _ckAO::F64;
      _ckAS::F64 = %MO_F_Sub_W64(100.0 :: W64, _sjYO::F64);
      _sjZ0::F64 = _ckAS::F64;
      _ckAV::F64 = %MO_F_Quot_W64(_sjZ0::F64, 2.0 :: W64);
      _sjZ1::F64 = _ckAV::F64;
      _ckAY::F64 = %MO_F_Add_W64(_sjZ1::F64, _sjYO::F64);
      _sjZ2::F64 = _ckAY::F64;
      _ckB1::F64 = %MO_F_Quot_W64(_sjZ2::F64, 100.0 :: W64);
      _sjZ3::F64 = _ckB1::F64;
      _ckB4::F64 = %MO_F_Mul_W64(_sjZ3::F64, _sjZ4::F64);
      _sjZ5::F64 = _ckB4::F64;
      I64[(young<ckB7> + 8)] = ckB7;
      D1 = _sjZ5::F64;
      R2 = GHC.Real.$fIntegralWord_closure;
      call GHC.Float.$w$cproperFraction_info(D1,
                                             R2) returns to ckB7, args: 8, res: 8, upd: 8;
  ckB7:
      _sjZ8::P64 = R2;
      _sjZ7::P64 = R1;
      I64[(young<ckB9> + 8)] = ckB9;
      R1 = _sjZ8::P64;
      if (R1 & 7 != 0) goto ckB9; else goto ckBa;
  ckBa:
      call (I64[R1])(R1) returns to ckB9, args: 8, res: 8, upd: 8;
  ckB9:
      _sjZ9::P64 = R1;
      _sjZa::F64 = F64[_sjZ9::P64 + 7];
      _ckEd::I64 = %MO_F_Lt_W64(_sjZa::F64, 0.0 :: W64);
      _sk0J::I64 = _ckEd::I64;
      switch [0 .. 1] _sk0J::I64 {
          case 0 : goto ckEk;
          case 1 : goto ckEs;
      }
  ckEs:
      I64[(young<ckEr> + 8)] = ckEr;
      R1 = _sjZ7::P64;
      if (R1 & 7 != 0) goto ckEr; else goto ckEt;
  ckEt:
      call (I64[R1])(R1) returns to ckEr, args: 8, res: 8, upd: 8;
  ckEr:
      _sk0N::P64 = R1;
      _sk0O::I64 = I64[_sk0N::P64 + 7];
      _ckF2::I64 = _sk0O::I64 - 1;
      _sk0P::I64 = _ckF2::I64;
      _sjZc::I64 = _sk0P::I64;
      goto ckBh;
  ckEk:
      I64[(young<ckEi> + 8)] = ckEi;
      R1 = _sjZ7::P64;
      if (R1 & 7 != 0) goto ckEi; else goto ckEl;
  ckEl:
      call (I64[R1])(R1) returns to ckEi, args: 8, res: 8, upd: 8;
  ckEi:
      _sk0L::P64 = R1;
      _sk0M::I64 = I64[_sk0L::P64 + 7];
      _sjZc::I64 = _sk0M::I64;
      goto ckBh;
  ckBh:
      Hp = Hp + 120;
      if (Hp > HpLim) goto ckCX; else goto ckCW;
  ckCX:
      HpAlloc = 120;
      I64[(young<ckBg> + 8)] = ckBg;
      R1 = _sjZc::I64;
      call stg_gc_unbx_r1(R1) returns to ckBg, args: 8, res: 8, upd: 8;
  ckBg:
      _sjZc::I64 = R1;
      goto ckBh;
  ckCW:
      I64[Hp - 112] = Data.Vector.Primitive.Mutable.MVector_con_info;
      P64[Hp - 104] = _sjYM::P64;
      I64[Hp - 96] = _sjYK::I64;
      I64[Hp - 88] = _sjYL::I64;
      _ckBj::P64 = Hp - 111;
      I64[Hp - 80] = GHC.Types.I#_con_info;
      I64[Hp - 72] = _sjYG::I64;
      _ckBk::P64 = Hp - 79;
      I64[Hp - 64] = GHC.Types.I#_con_info;
      I64[Hp - 56] = _sjYF::I64;
      _ckBl::P64 = Hp - 63;
      I64[Hp - 48] = GHC.Arr.Array_con_info;
      P64[Hp - 40] = _ckBl::P64;
      P64[Hp - 32] = _ckBk::P64;
      P64[Hp - 24] = _sjYI::P64;
      I64[Hp - 16] = _sjYH::I64;
      _ckBm::P64 = Hp - 47;
      I64[Hp - 8] = Data.Primitive.ByteArray.MutableByteArray_con_info;
      P64[Hp] = _sjYE::P64;
      _ckF3::P64 = Hp - 7;
      _B2::P64 = _ckF3::P64;
      goto ckE9;
  ckE9:
      if (HpLim == 0) goto ckEb; else goto ckEc;
  ckEb:
      I64[(young<ckE8> + 8)] = ckE8;
      R1 = _B2::P64;
      call stg_gc_unpt_r1(R1) returns to ckE8, args: 8, res: 8, upd: 8;
  ckE8:
      _B2::P64 = R1;
      goto ckE9;
  ckEc:
      _sk0D::P64 = _B2::P64;
      goto ckDW;
  ckDW:
      if (HpLim == 0) goto ckDZ; else goto ckE0;
  ckDZ:
      I64[(young<ckDV> + 8)] = ckDV;
      R1 = _sk0D::P64;
      call stg_gc_unpt_r1(R1) returns to ckDV, args: 8, res: 8, upd: 8;
  ckDV:
      _sk0D::P64 = R1;
      goto ckDW;
  ckE0:
      I64[(young<ckDY> + 8)] = ckDY;
      R1 = _sk0D::P64;
      if (R1 & 7 != 0) goto ckDY; else goto ckE1;
  ckE1:
      call (I64[R1])(R1) returns to ckDY, args: 8, res: 8, upd: 8;
  ckDY:
      _sk0F::P64 = R1;
      _sk0G::P64 = P64[_sk0F::P64 + 7];
      _sjZi::P64 = _sk0G::P64;
      goto ckBq;
  ckBq:
      if (HpLim == 0) goto ckCY; else goto ckCZ;
  ckCY:
      I64[(young<ckBp> + 8)] = ckBp;
      R1 = _sjZi::P64;
      call stg_gc_unpt_r1(R1) returns to ckBp, args: 8, res: 8, upd: 8;
  ckBp:
      _sjZi::P64 = R1;
      goto ckBq;
  ckCZ:
      _sjZm::I64 = I64[_sjZi::P64 + 16];
      _sjZm::I64 = _sjZm::I64;
      I64[(young<ckBs> + 8)] = ckBs;
      R2 = _sjZm::I64;
      call $wgo1_rjVd_info(R2) returns to ckBs, args: 8, res: 8, upd: 8;
  ckBs:
      _sjZp::I64 = R2;
      _sjZo::I64 = R1;
      I64[_sjZi::P64 + 16] = _sjZo::I64;
      _sjZt::I64 = I64[_sjZi::P64 + 16];
      _sjZt::I64 = _sjZt::I64;
      _ckBy::I64 = _sjYN::I64 - 2;
      _sjZu::I64 = _ckBy::I64;
      _ckBB::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_sjZu::I64));
      _sjZv::I64 = _ckBB::I64;
      I64[(young<ckBE> + 8)] = ckBE;
      R3 = _sjZt::I64;
      R2 = _sjZv::I64;
      call System.Random.PCG.Fast.Pure.$wbounded_info(R3,
                                                      R2) returns to ckBE, args: 8, res: 8, upd: 8;
  ckBE:
      _sjZy::I64 = R2;
      _sjZx::I64 = R1;
      goto ckBF;
  ckBF:
      Hp = Hp + 40;
      if (Hp > HpLim) goto ckD3; else goto ckD2;
  ckD3:
      HpAlloc = 40;
      I64[(young<ckBG> + 8)] = ckBG;
      call stg_gc_noregs() returns to ckBG, args: 8, res: 8, upd: 8;
  ckBG:
      goto ckBF;
  ckD2:
      I64[_sjZi::P64 + 16] = _sjZx::I64;
      _ckBK::I64 = _sjZp::I64 <= _sjYZ::I64;
      _sjZA::I64 = _ckBK::I64;
      switch [0 .. 1] _sjZA::I64 {
          case 0 : goto ckDC;
          case 1 : goto ckDG;
      }
  ckDG:
      I64[Hp - 32] = sat_sk0o_info;
      P64[Hp - 24] = _sjYJ::P64;
      P64[Hp - 16] = _ckBm::P64;
      I64[Hp - 8] = _sjZy::I64;
      _ckCu::P64 = Hp - 31;
      Hp = Hp - 8;
      I64[(young<ckDD> + 8)] = ckDD;
      R1 = _ckCu::P64;
      call stg_norec_atomically#(R1) returns to ckDD, args: 8, res: 8, upd: 8;
  ckDD:
      _sk0r::P64 = R1;
      _sk0u::P64 = P64[_sjYD::P64 + 8];
      _sk0u::P64 = _sk0u::P64;
      I64[(young<ckDF> + 8)] = ckDF;
      R1 = _sk0u::P64;
      if (R1 & 7 != 0) goto ckDF; else goto ckDI;
  ckDI:
      call (I64[R1])(R1) returns to ckDF, args: 8, res: 8, upd: 8;
  ckDF:
      _sk0v::P64 = R1;
      Hp = Hp + 16;
      if (Hp > HpLim) goto ckDO; else goto ckDN;
  ckDO:
      HpAlloc = 16;
      R1 = _sk0v::P64;
      call stg_gc_unpt_r1(R1) returns to ckDF, args: 8, res: 8, upd: 8;
  ckDN:
      _sk0w::I64 = I64[_sk0v::P64 + 7];
      _sk0x::I64 = _sk0w::I64;
      switch [0 .. 18446744073709551615] _sk0x::I64 {
          case 18446744073709551615 : goto ckDS;
          default: goto ckDR;
      }
  ckDS:
      Hp = Hp - 16;
      R1 = GHC.Word.$fEnumWord12_closure;
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
  ckDR:
      _ckF5::I64 = _sk0x::I64 + 1;
      _sk0y::I64 = _ckF5::I64;
      I64[Hp - 8] = GHC.Word.W64#_con_info;
      I64[Hp] = _sk0y::I64;
      _ckF8::P64 = Hp - 7;
      P64[_sjYD::P64 + 8] = _ckF8::P64;
      _ckF9::I64 = dirty_MUT_VAR;
      _ckFa::I64 = BaseReg;
      _ckFb::P64 = _sjYD::P64;
      call "ccall" arg hints:  [PtrHint,
                                PtrHint]  result hints:  [] (_ckF9::I64)(_ckFa::I64, _ckFb::P64);
      _sjZi::P64 = _sjZi::P64;
      goto ckBq;
  ckDC:
      _ckBP::I64 = _sjZp::I64 <= _sjZc::I64;
      _sjZC::I64 = _ckBP::I64;
      switch [0 .. 1] _sjZC::I64 {
          case 0 : goto ckD8;
          case 1 : goto ckDo;
      }
  ckDo:
      I64[Hp - 32] = sat_sk04_info;
      P64[Hp - 24] = _sjYJ::P64;
      P64[Hp - 16] = _ckBj::P64;
      P64[Hp - 8] = _ckBm::P64;
      I64[Hp] = _sjZy::I64;
      _ckCc::P64 = Hp - 31;
      I64[(young<ckDl> + 8)] = ckDl;
      R1 = _ckCc::P64;
      call stg_norec_atomically#(R1) returns to ckDl, args: 8, res: 8, upd: 8;
  ckDl:
      _sk07::P64 = R1;
      _sk0a::P64 = P64[_sjYD::P64 + 8];
      _sk0a::P64 = _sk0a::P64;
      I64[(young<ckDn> + 8)] = ckDn;
      R1 = _sk0a::P64;
      if (R1 & 7 != 0) goto ckDn; else goto ckDq;
  ckDq:
      call (I64[R1])(R1) returns to ckDn, args: 8, res: 8, upd: 8;
  ckDn:
      _sk0b::P64 = R1;
      Hp = Hp + 16;
      if (Hp > HpLim) goto ckDw; else goto ckDv;
  ckDw:
      HpAlloc = 16;
      R1 = _sk0b::P64;
      call stg_gc_unpt_r1(R1) returns to ckDn, args: 8, res: 8, upd: 8;
  ckDv:
      _sk0c::I64 = I64[_sk0b::P64 + 7];
      _sk0d::I64 = _sk0c::I64;
      switch [0 .. 18446744073709551615] _sk0d::I64 {
          case 18446744073709551615 : goto ckDA;
          default: goto ckDz;
      }
  ckDA:
      Hp = Hp - 16;
      R1 = GHC.Word.$fEnumWord12_closure;
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
  ckDz:
      _ckFd::I64 = _sk0d::I64 + 1;
      _sk0e::I64 = _ckFd::I64;
      I64[Hp - 8] = GHC.Word.W64#_con_info;
      I64[Hp] = _sk0e::I64;
      _ckFg::P64 = Hp - 7;
      P64[_sjYD::P64 + 8] = _ckFg::P64;
      _ckFh::I64 = dirty_MUT_VAR;
      _ckFi::I64 = BaseReg;
      _ckFj::P64 = _sjYD::P64;
      call "ccall" arg hints:  [PtrHint,
                                PtrHint]  result hints:  [] (_ckFh::I64)(_ckFi::I64, _ckFj::P64);
      _sjZi::P64 = _sjZi::P64;
      goto ckBq;
  ckD8:
      I64[Hp - 32] = sat_sjZK_info;
      P64[Hp - 24] = _sjYJ::P64;
      P64[Hp - 16] = _ckBm::P64;
      I64[Hp - 8] = _sjZy::I64;
      _ckBU::P64 = Hp - 31;
      Hp = Hp - 8;
      I64[(young<ckD4> + 8)] = ckD4;
      R1 = _ckBU::P64;
      call stg_norec_atomically#(R1) returns to ckD4, args: 8, res: 8, upd: 8;
  ckD4:
      _sjZN::P64 = R1;
      _sjZQ::P64 = P64[_sjYD::P64 + 8];
      _sjZQ::P64 = _sjZQ::P64;
      I64[(young<ckD6> + 8)] = ckD6;
      R1 = _sjZQ::P64;
      if (R1 & 7 != 0) goto ckD6; else goto ckDa;
  ckDa:
      call (I64[R1])(R1) returns to ckD6, args: 8, res: 8, upd: 8;
  ckD6:
      _sjZR::P64 = R1;
      Hp = Hp + 16;
      if (Hp > HpLim) goto ckDg; else goto ckDf;
  ckDg:
      HpAlloc = 16;
      R1 = _sjZR::P64;
      call stg_gc_unpt_r1(R1) returns to ckD6, args: 8, res: 8, upd: 8;
  ckDf:
      _sjZS::I64 = I64[_sjZR::P64 + 7];
      _sjZT::I64 = _sjZS::I64;
      switch [0 .. 18446744073709551615] _sjZT::I64 {
          case 18446744073709551615 : goto ckDk;
          default: goto ckDj;
      }
  ckDk:
      Hp = Hp - 16;
      R1 = GHC.Word.$fEnumWord12_closure;
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
  ckDj:
      _ckEU::I64 = _sjZT::I64 + 1;
      _sjZU::I64 = _ckEU::I64;
      I64[Hp - 8] = GHC.Word.W64#_con_info;
      I64[Hp] = _sjZU::I64;
      _ckEX::P64 = Hp - 7;
      P64[_sjYD::P64 + 8] = _ckEX::P64;
      _ckEY::I64 = dirty_MUT_VAR;
      _ckEZ::I64 = BaseReg;
      _ckF0::P64 = _sjYD::P64;
      call "ccall" arg hints:  [PtrHint,
                                PtrHint]  result hints:  [] (_ckEY::I64)(_ckEZ::I64, _ckF0::P64);
      _sjZi::P64 = _sjZi::P64;
      goto ckBq;
}


==================== Post common block elimination ====================
2015-11-09 18:21:53.498254 UTC

{offset
  ckCL:
      _sjYH::I64 = R6;
      _sjYG::I64 = R5;
      _sjYF::I64 = R4;
      _sjYE::P64 = R3;
      _sjYD::P64 = R2;
      _sjYI::P64 = P64[(old + 64)];
      _sjYJ::P64 = P64[(old + 56)];
      _sjYK::I64 = I64[(old + 48)];
      _sjYL::I64 = I64[(old + 40)];
      _sjYM::P64 = P64[(old + 32)];
      _sjYN::I64 = I64[(old + 24)];
      _sjYO::F64 = F64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto ckCM; else goto ckCN;
  ckCN:
      if (HpLim == 0) goto ckCM; else goto ckCO;
  ckCM:
      R1 = Main.$wa1_closure;
      P64[(old + 104)] = _sjYD::P64;
      P64[(old + 96)] = _sjYE::P64;
      I64[(old + 88)] = _sjYF::I64;
      I64[(old + 80)] = _sjYG::I64;
      I64[(old + 72)] = _sjYH::I64;
      P64[(old + 64)] = _sjYI::P64;
      P64[(old + 56)] = _sjYJ::P64;
      I64[(old + 48)] = _sjYK::I64;
      I64[(old + 40)] = _sjYL::I64;
      P64[(old + 32)] = _sjYM::P64;
      I64[(old + 24)] = _sjYN::I64;
      F64[(old + 16)] = _sjYO::F64;
      call (stg_gc_fun)(R1) args: 104, res: 0, upd: 8;
  ckCO:
      _ckAt::I64 = 100000;
      (_ckAs::F64) = call MO_UF_Conv W64(_ckAt::I64);
      _sjYR::F64 = _ckAs::F64;
      _ckAw::F64 = %MO_F_Quot_W64(_sjYO::F64, 100.0 :: W64);
      _sjYQ::F64 = _ckAw::F64;
      _ckAz::F64 = %MO_F_Mul_W64(_sjYQ::F64, _sjYR::F64);
      _sjYS::F64 = _ckAz::F64;
      I64[(young<ckAC> + 8)] = ckAC;
      D1 = _sjYS::F64;
      R2 = GHC.Real.$fIntegralWord_closure;
      call GHC.Float.$w$cproperFraction_info(D1,
                                             R2) returns to ckAC, args: 8, res: 8, upd: 8;
  ckAC:
      _sjYV::P64 = R2;
      _sjYU::P64 = R1;
      I64[(young<ckAE> + 8)] = ckAE;
      R1 = _sjYV::P64;
      if (R1 & 7 != 0) goto ckAE; else goto ckAF;
  ckAF:
      call (I64[R1])(R1) returns to ckAE, args: 8, res: 8, upd: 8;
  ckAE:
      _sjYW::P64 = R1;
      _sjYX::F64 = F64[_sjYW::P64 + 7];
      _ckEy::I64 = %MO_F_Lt_W64(_sjYX::F64, 0.0 :: W64);
      _sk0Q::I64 = _ckEy::I64;
      switch [0 .. 1] _sk0Q::I64 {
          case 0 : goto ckEF;
          case 1 : goto ckEN;
      }
  ckEN:
      I64[(young<ckEM> + 8)] = ckEM;
      R1 = _sjYU::P64;
      if (R1 & 7 != 0) goto ckEM; else goto ckEO;
  ckEO:
      call (I64[R1])(R1) returns to ckEM, args: 8, res: 8, upd: 8;
  ckEM:
      _sk0U::P64 = R1;
      _sk0V::I64 = I64[_sk0U::P64 + 7];
      _ckF1::I64 = _sk0V::I64 - 1;
      _sk0W::I64 = _ckF1::I64;
      _sjYZ::I64 = _sk0W::I64;
      goto ckAM;
  ckEF:
      I64[(young<ckED> + 8)] = ckED;
      R1 = _sjYU::P64;
      if (R1 & 7 != 0) goto ckED; else goto ckEG;
  ckEG:
      call (I64[R1])(R1) returns to ckED, args: 8, res: 8, upd: 8;
  ckED:
      _sk0S::P64 = R1;
      _sk0T::I64 = I64[_sk0S::P64 + 7];
      _sjYZ::I64 = _sk0T::I64;
      goto ckAM;
  ckAM:
      if (HpLim == 0) goto ckCR; else goto ckCS;
  ckCR:
      I64[(young<ckAL> + 8)] = ckAL;
      R1 = _sjYZ::I64;
      call stg_gc_unbx_r1(R1) returns to ckAL, args: 8, res: 8, upd: 8;
  ckAL:
      _sjYZ::I64 = R1;
      goto ckAM;
  ckCS:
      _ckAP::I64 = 100000;
      (_ckAO::F64) = call MO_UF_Conv W64(_ckAP::I64);
      _sjZ4::F64 = _ckAO::F64;
      _ckAS::F64 = %MO_F_Sub_W64(100.0 :: W64, _sjYO::F64);
      _sjZ0::F64 = _ckAS::F64;
      _ckAV::F64 = %MO_F_Quot_W64(_sjZ0::F64, 2.0 :: W64);
      _sjZ1::F64 = _ckAV::F64;
      _ckAY::F64 = %MO_F_Add_W64(_sjZ1::F64, _sjYO::F64);
      _sjZ2::F64 = _ckAY::F64;
      _ckB1::F64 = %MO_F_Quot_W64(_sjZ2::F64, 100.0 :: W64);
      _sjZ3::F64 = _ckB1::F64;
      _ckB4::F64 = %MO_F_Mul_W64(_sjZ3::F64, _sjZ4::F64);
      _sjZ5::F64 = _ckB4::F64;
      I64[(young<ckB7> + 8)] = ckB7;
      D1 = _sjZ5::F64;
      R2 = GHC.Real.$fIntegralWord_closure;
      call GHC.Float.$w$cproperFraction_info(D1,
                                             R2) returns to ckB7, args: 8, res: 8, upd: 8;
  ckB7:
      _sjZ8::P64 = R2;
      _sjZ7::P64 = R1;
      I64[(young<ckB9> + 8)] = ckB9;
      R1 = _sjZ8::P64;
      if (R1 & 7 != 0) goto ckB9; else goto ckBa;
  ckBa:
      call (I64[R1])(R1) returns to ckB9, args: 8, res: 8, upd: 8;
  ckB9:
      _sjZ9::P64 = R1;
      _sjZa::F64 = F64[_sjZ9::P64 + 7];
      _ckEd::I64 = %MO_F_Lt_W64(_sjZa::F64, 0.0 :: W64);
      _sk0J::I64 = _ckEd::I64;
      switch [0 .. 1] _sk0J::I64 {
          case 0 : goto ckEk;
          case 1 : goto ckEs;
      }
  ckEs:
      I64[(young<ckEr> + 8)] = ckEr;
      R1 = _sjZ7::P64;
      if (R1 & 7 != 0) goto ckEr; else goto ckEt;
  ckEt:
      call (I64[R1])(R1) returns to ckEr, args: 8, res: 8, upd: 8;
  ckEr:
      _sk0N::P64 = R1;
      _sk0O::I64 = I64[_sk0N::P64 + 7];
      _ckF2::I64 = _sk0O::I64 - 1;
      _sk0P::I64 = _ckF2::I64;
      _sjZc::I64 = _sk0P::I64;
      goto ckBh;
  ckEk:
      I64[(young<ckEi> + 8)] = ckEi;
      R1 = _sjZ7::P64;
      if (R1 & 7 != 0) goto ckEi; else goto ckEl;
  ckEl:
      call (I64[R1])(R1) returns to ckEi, args: 8, res: 8, upd: 8;
  ckEi:
      _sk0L::P64 = R1;
      _sk0M::I64 = I64[_sk0L::P64 + 7];
      _sjZc::I64 = _sk0M::I64;
      goto ckBh;
  ckBh:
      Hp = Hp + 120;
      if (Hp > HpLim) goto ckCX; else goto ckCW;
  ckCX:
      HpAlloc = 120;
      I64[(young<ckBg> + 8)] = ckBg;
      R1 = _sjZc::I64;
      call stg_gc_unbx_r1(R1) returns to ckBg, args: 8, res: 8, upd: 8;
  ckBg:
      _sjZc::I64 = R1;
      goto ckBh;
  ckCW:
      I64[Hp - 112] = Data.Vector.Primitive.Mutable.MVector_con_info;
      P64[Hp - 104] = _sjYM::P64;
      I64[Hp - 96] = _sjYK::I64;
      I64[Hp - 88] = _sjYL::I64;
      _ckBj::P64 = Hp - 111;
      I64[Hp - 80] = GHC.Types.I#_con_info;
      I64[Hp - 72] = _sjYG::I64;
      _ckBk::P64 = Hp - 79;
      I64[Hp - 64] = GHC.Types.I#_con_info;
      I64[Hp - 56] = _sjYF::I64;
      _ckBl::P64 = Hp - 63;
      I64[Hp - 48] = GHC.Arr.Array_con_info;
      P64[Hp - 40] = _ckBl::P64;
      P64[Hp - 32] = _ckBk::P64;
      P64[Hp - 24] = _sjYI::P64;
      I64[Hp - 16] = _sjYH::I64;
      _ckBm::P64 = Hp - 47;
      I64[Hp - 8] = Data.Primitive.ByteArray.MutableByteArray_con_info;
      P64[Hp] = _sjYE::P64;
      _ckF3::P64 = Hp - 7;
      _B2::P64 = _ckF3::P64;
      goto ckE9;
  ckE9:
      if (HpLim == 0) goto ckEb; else goto ckEc;
  ckEb:
      I64[(young<ckE8> + 8)] = ckE8;
      R1 = _B2::P64;
      call stg_gc_unpt_r1(R1) returns to ckE8, args: 8, res: 8, upd: 8;
  ckE8:
      _B2::P64 = R1;
      goto ckE9;
  ckEc:
      _sk0D::P64 = _B2::P64;
      goto ckDW;
  ckDW:
      if (HpLim == 0) goto ckDZ; else goto ckE0;
  ckDZ:
      I64[(young<ckDV> + 8)] = ckDV;
      R1 = _sk0D::P64;
      call stg_gc_unpt_r1(R1) returns to ckDV, args: 8, res: 8, upd: 8;
  ckDV:
      _sk0D::P64 = R1;
      goto ckDW;
  ckE0:
      I64[(young<ckDY> + 8)] = ckDY;
      R1 = _sk0D::P64;
      if (R1 & 7 != 0) goto ckDY; else goto ckE1;
  ckE1:
      call (I64[R1])(R1) returns to ckDY, args: 8, res: 8, upd: 8;
  ckDY:
      _sk0F::P64 = R1;
      _sk0G::P64 = P64[_sk0F::P64 + 7];
      _sjZi::P64 = _sk0G::P64;
      goto ckBq;
  ckBq:
      if (HpLim == 0) goto ckCY; else goto ckCZ;
  ckCY:
      I64[(young<ckBp> + 8)] = ckBp;
      R1 = _sjZi::P64;
      call stg_gc_unpt_r1(R1) returns to ckBp, args: 8, res: 8, upd: 8;
  ckBp:
      _sjZi::P64 = R1;
      goto ckBq;
  ckCZ:
      _sjZm::I64 = I64[_sjZi::P64 + 16];
      _sjZm::I64 = _sjZm::I64;
      I64[(young<ckBs> + 8)] = ckBs;
      R2 = _sjZm::I64;
      call $wgo1_rjVd_info(R2) returns to ckBs, args: 8, res: 8, upd: 8;
  ckBs:
      _sjZp::I64 = R2;
      _sjZo::I64 = R1;
      I64[_sjZi::P64 + 16] = _sjZo::I64;
      _sjZt::I64 = I64[_sjZi::P64 + 16];
      _sjZt::I64 = _sjZt::I64;
      _ckBy::I64 = _sjYN::I64 - 2;
      _sjZu::I64 = _ckBy::I64;
      _ckBB::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_sjZu::I64));
      _sjZv::I64 = _ckBB::I64;
      I64[(young<ckBE> + 8)] = ckBE;
      R3 = _sjZt::I64;
      R2 = _sjZv::I64;
      call System.Random.PCG.Fast.Pure.$wbounded_info(R3,
                                                      R2) returns to ckBE, args: 8, res: 8, upd: 8;
  ckBE:
      _sjZy::I64 = R2;
      _sjZx::I64 = R1;
      goto ckBF;
  ckBF:
      Hp = Hp + 40;
      if (Hp > HpLim) goto ckD3; else goto ckD2;
  ckD3:
      HpAlloc = 40;
      I64[(young<ckBG> + 8)] = ckBG;
      call stg_gc_noregs() returns to ckBG, args: 8, res: 8, upd: 8;
  ckBG:
      goto ckBF;
  ckD2:
      I64[_sjZi::P64 + 16] = _sjZx::I64;
      _ckBK::I64 = _sjZp::I64 <= _sjYZ::I64;
      _sjZA::I64 = _ckBK::I64;
      switch [0 .. 1] _sjZA::I64 {
          case 0 : goto ckDC;
          case 1 : goto ckDG;
      }
  ckDG:
      I64[Hp - 32] = sat_sk0o_info;
      P64[Hp - 24] = _sjYJ::P64;
      P64[Hp - 16] = _ckBm::P64;
      I64[Hp - 8] = _sjZy::I64;
      _ckCu::P64 = Hp - 31;
      Hp = Hp - 8;
      I64[(young<ckDD> + 8)] = ckDD;
      R1 = _ckCu::P64;
      call stg_norec_atomically#(R1) returns to ckDD, args: 8, res: 8, upd: 8;
  ckDD:
      _sk0r::P64 = R1;
      _sk0u::P64 = P64[_sjYD::P64 + 8];
      _sk0u::P64 = _sk0u::P64;
      I64[(young<ckDF> + 8)] = ckDF;
      R1 = _sk0u::P64;
      if (R1 & 7 != 0) goto ckDF; else goto ckDI;
  ckDI:
      call (I64[R1])(R1) returns to ckDF, args: 8, res: 8, upd: 8;
  ckDF:
      _sk0v::P64 = R1;
      Hp = Hp + 16;
      if (Hp > HpLim) goto ckDO; else goto ckDN;
  ckDO:
      HpAlloc = 16;
      R1 = _sk0v::P64;
      call stg_gc_unpt_r1(R1) returns to ckDF, args: 8, res: 8, upd: 8;
  ckDN:
      _sk0w::I64 = I64[_sk0v::P64 + 7];
      _sk0x::I64 = _sk0w::I64;
      switch [0 .. 18446744073709551615] _sk0x::I64 {
          case 18446744073709551615 : goto ckDS;
          default: goto ckDR;
      }
  ckDR:
      _ckF5::I64 = _sk0x::I64 + 1;
      _sk0y::I64 = _ckF5::I64;
      I64[Hp - 8] = GHC.Word.W64#_con_info;
      I64[Hp] = _sk0y::I64;
      _ckF8::P64 = Hp - 7;
      P64[_sjYD::P64 + 8] = _ckF8::P64;
      _ckF9::I64 = dirty_MUT_VAR;
      _ckFa::I64 = BaseReg;
      _ckFb::P64 = _sjYD::P64;
      call "ccall" arg hints:  [PtrHint,
                                PtrHint]  result hints:  [] (_ckF9::I64)(_ckFa::I64, _ckFb::P64);
      _sjZi::P64 = _sjZi::P64;
      goto ckBq;
  ckDC:
      _ckBP::I64 = _sjZp::I64 <= _sjZc::I64;
      _sjZC::I64 = _ckBP::I64;
      switch [0 .. 1] _sjZC::I64 {
          case 0 : goto ckD8;
          case 1 : goto ckDo;
      }
  ckDo:
      I64[Hp - 32] = sat_sk04_info;
      P64[Hp - 24] = _sjYJ::P64;
      P64[Hp - 16] = _ckBj::P64;
      P64[Hp - 8] = _ckBm::P64;
      I64[Hp] = _sjZy::I64;
      _ckCc::P64 = Hp - 31;
      I64[(young<ckDl> + 8)] = ckDl;
      R1 = _ckCc::P64;
      call stg_norec_atomically#(R1) returns to ckDl, args: 8, res: 8, upd: 8;
  ckDl:
      _sk07::P64 = R1;
      _sk0a::P64 = P64[_sjYD::P64 + 8];
      _sk0a::P64 = _sk0a::P64;
      I64[(young<ckDn> + 8)] = ckDn;
      R1 = _sk0a::P64;
      if (R1 & 7 != 0) goto ckDn; else goto ckDq;
  ckDq:
      call (I64[R1])(R1) returns to ckDn, args: 8, res: 8, upd: 8;
  ckDn:
      _sk0b::P64 = R1;
      Hp = Hp + 16;
      if (Hp > HpLim) goto ckDw; else goto ckDv;
  ckDw:
      HpAlloc = 16;
      R1 = _sk0b::P64;
      call stg_gc_unpt_r1(R1) returns to ckDn, args: 8, res: 8, upd: 8;
  ckDv:
      _sk0c::I64 = I64[_sk0b::P64 + 7];
      _sk0d::I64 = _sk0c::I64;
      switch [0 .. 18446744073709551615] _sk0d::I64 {
          case 18446744073709551615 : goto ckDS;
          default: goto ckDz;
      }
  ckDz:
      _ckFd::I64 = _sk0d::I64 + 1;
      _sk0e::I64 = _ckFd::I64;
      I64[Hp - 8] = GHC.Word.W64#_con_info;
      I64[Hp] = _sk0e::I64;
      _ckFg::P64 = Hp - 7;
      P64[_sjYD::P64 + 8] = _ckFg::P64;
      _ckFh::I64 = dirty_MUT_VAR;
      _ckFi::I64 = BaseReg;
      _ckFj::P64 = _sjYD::P64;
      call "ccall" arg hints:  [PtrHint,
                                PtrHint]  result hints:  [] (_ckFh::I64)(_ckFi::I64, _ckFj::P64);
      _sjZi::P64 = _sjZi::P64;
      goto ckBq;
  ckD8:
      I64[Hp - 32] = sat_sjZK_info;
      P64[Hp - 24] = _sjYJ::P64;
      P64[Hp - 16] = _ckBm::P64;
      I64[Hp - 8] = _sjZy::I64;
      _ckBU::P64 = Hp - 31;
      Hp = Hp - 8;
      I64[(young<ckD4> + 8)] = ckD4;
      R1 = _ckBU::P64;
      call stg_norec_atomically#(R1) returns to ckD4, args: 8, res: 8, upd: 8;
  ckD4:
      _sjZN::P64 = R1;
      _sjZQ::P64 = P64[_sjYD::P64 + 8];
      _sjZQ::P64 = _sjZQ::P64;
      I64[(young<ckD6> + 8)] = ckD6;
      R1 = _sjZQ::P64;
      if (R1 & 7 != 0) goto ckD6; else goto ckDa;
  ckDa:
      call (I64[R1])(R1) returns to ckD6, args: 8, res: 8, upd: 8;
  ckD6:
      _sjZR::P64 = R1;
      Hp = Hp + 16;
      if (Hp > HpLim) goto ckDg; else goto ckDf;
  ckDg:
      HpAlloc = 16;
      R1 = _sjZR::P64;
      call stg_gc_unpt_r1(R1) returns to ckD6, args: 8, res: 8, upd: 8;
  ckDf:
      _sjZS::I64 = I64[_sjZR::P64 + 7];
      _sjZT::I64 = _sjZS::I64;
      switch [0 .. 18446744073709551615] _sjZT::I64 {
          case 18446744073709551615 : goto ckDS;
          default: goto ckDj;
      }
  ckDS:
      Hp = Hp - 16;
      R1 = GHC.Word.$fEnumWord12_closure;
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
  ckDj:
      _ckEU::I64 = _sjZT::I64 + 1;
      _sjZU::I64 = _ckEU::I64;
      I64[Hp - 8] = GHC.Word.W64#_con_info;
      I64[Hp] = _sjZU::I64;
      _ckEX::P64 = Hp - 7;
      P64[_sjYD::P64 + 8] = _ckEX::P64;
      _ckEY::I64 = dirty_MUT_VAR;
      _ckEZ::I64 = BaseReg;
      _ckF0::P64 = _sjYD::P64;
      call "ccall" arg hints:  [PtrHint,
                                PtrHint]  result hints:  [] (_ckEY::I64)(_ckEZ::I64, _ckF0::P64);
      _sjZi::P64 = _sjZi::P64;
      goto ckBq;
}


==================== Post switch plan ====================
2015-11-09 18:21:53.517919 UTC

{offset
  ckCL:
      _sjYH::I64 = R6;
      _sjYG::I64 = R5;
      _sjYF::I64 = R4;
      _sjYE::P64 = R3;
      _sjYD::P64 = R2;
      _sjYI::P64 = P64[(old + 64)];
      _sjYJ::P64 = P64[(old + 56)];
      _sjYK::I64 = I64[(old + 48)];
      _sjYL::I64 = I64[(old + 40)];
      _sjYM::P64 = P64[(old + 32)];
      _sjYN::I64 = I64[(old + 24)];
      _sjYO::F64 = F64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto ckCM; else goto ckCN;
  ckCN:
      if (HpLim == 0) goto ckCM; else goto ckCO;
  ckCM:
      R1 = Main.$wa1_closure;
      P64[(old + 104)] = _sjYD::P64;
      P64[(old + 96)] = _sjYE::P64;
      I64[(old + 88)] = _sjYF::I64;
      I64[(old + 80)] = _sjYG::I64;
      I64[(old + 72)] = _sjYH::I64;
      P64[(old + 64)] = _sjYI::P64;
      P64[(old + 56)] = _sjYJ::P64;
      I64[(old + 48)] = _sjYK::I64;
      I64[(old + 40)] = _sjYL::I64;
      P64[(old + 32)] = _sjYM::P64;
      I64[(old + 24)] = _sjYN::I64;
      F64[(old + 16)] = _sjYO::F64;
      call (stg_gc_fun)(R1) args: 104, res: 0, upd: 8;
  ckCO:
      _ckAt::I64 = 100000;
      (_ckAs::F64) = call MO_UF_Conv W64(_ckAt::I64);
      _sjYR::F64 = _ckAs::F64;
      _ckAw::F64 = %MO_F_Quot_W64(_sjYO::F64, 100.0 :: W64);
      _sjYQ::F64 = _ckAw::F64;
      _ckAz::F64 = %MO_F_Mul_W64(_sjYQ::F64, _sjYR::F64);
      _sjYS::F64 = _ckAz::F64;
      I64[(young<ckAC> + 8)] = ckAC;
      D1 = _sjYS::F64;
      R2 = GHC.Real.$fIntegralWord_closure;
      call GHC.Float.$w$cproperFraction_info(D1,
                                             R2) returns to ckAC, args: 8, res: 8, upd: 8;
  ckAC:
      _sjYV::P64 = R2;
      _sjYU::P64 = R1;
      I64[(young<ckAE> + 8)] = ckAE;
      R1 = _sjYV::P64;
      if (R1 & 7 != 0) goto ckAE; else goto ckAF;
  ckAF:
      call (I64[R1])(R1) returns to ckAE, args: 8, res: 8, upd: 8;
  ckAE:
      _sjYW::P64 = R1;
      _sjYX::F64 = F64[_sjYW::P64 + 7];
      _ckEy::I64 = %MO_F_Lt_W64(_sjYX::F64, 0.0 :: W64);
      _sk0Q::I64 = _ckEy::I64;
      if (_sk0Q::I64 != 0) goto ckEN; else goto ckEF;
  ckEN:
      I64[(young<ckEM> + 8)] = ckEM;
      R1 = _sjYU::P64;
      if (R1 & 7 != 0) goto ckEM; else goto ckEO;
  ckEO:
      call (I64[R1])(R1) returns to ckEM, args: 8, res: 8, upd: 8;
  ckEM:
      _sk0U::P64 = R1;
      _sk0V::I64 = I64[_sk0U::P64 + 7];
      _ckF1::I64 = _sk0V::I64 - 1;
      _sk0W::I64 = _ckF1::I64;
      _sjYZ::I64 = _sk0W::I64;
      goto ckAM;
  ckEF:
      I64[(young<ckED> + 8)] = ckED;
      R1 = _sjYU::P64;
      if (R1 & 7 != 0) goto ckED; else goto ckEG;
  ckEG:
      call (I64[R1])(R1) returns to ckED, args: 8, res: 8, upd: 8;
  ckED:
      _sk0S::P64 = R1;
      _sk0T::I64 = I64[_sk0S::P64 + 7];
      _sjYZ::I64 = _sk0T::I64;
      goto ckAM;
  ckAM:
      if (HpLim == 0) goto ckCR; else goto ckCS;
  ckCR:
      I64[(young<ckAL> + 8)] = ckAL;
      R1 = _sjYZ::I64;
      call stg_gc_unbx_r1(R1) returns to ckAL, args: 8, res: 8, upd: 8;
  ckAL:
      _sjYZ::I64 = R1;
      goto ckAM;
  ckCS:
      _ckAP::I64 = 100000;
      (_ckAO::F64) = call MO_UF_Conv W64(_ckAP::I64);
      _sjZ4::F64 = _ckAO::F64;
      _ckAS::F64 = %MO_F_Sub_W64(100.0 :: W64, _sjYO::F64);
      _sjZ0::F64 = _ckAS::F64;
      _ckAV::F64 = %MO_F_Quot_W64(_sjZ0::F64, 2.0 :: W64);
      _sjZ1::F64 = _ckAV::F64;
      _ckAY::F64 = %MO_F_Add_W64(_sjZ1::F64, _sjYO::F64);
      _sjZ2::F64 = _ckAY::F64;
      _ckB1::F64 = %MO_F_Quot_W64(_sjZ2::F64, 100.0 :: W64);
      _sjZ3::F64 = _ckB1::F64;
      _ckB4::F64 = %MO_F_Mul_W64(_sjZ3::F64, _sjZ4::F64);
      _sjZ5::F64 = _ckB4::F64;
      I64[(young<ckB7> + 8)] = ckB7;
      D1 = _sjZ5::F64;
      R2 = GHC.Real.$fIntegralWord_closure;
      call GHC.Float.$w$cproperFraction_info(D1,
                                             R2) returns to ckB7, args: 8, res: 8, upd: 8;
  ckB7:
      _sjZ8::P64 = R2;
      _sjZ7::P64 = R1;
      I64[(young<ckB9> + 8)] = ckB9;
      R1 = _sjZ8::P64;
      if (R1 & 7 != 0) goto ckB9; else goto ckBa;
  ckBa:
      call (I64[R1])(R1) returns to ckB9, args: 8, res: 8, upd: 8;
  ckB9:
      _sjZ9::P64 = R1;
      _sjZa::F64 = F64[_sjZ9::P64 + 7];
      _ckEd::I64 = %MO_F_Lt_W64(_sjZa::F64, 0.0 :: W64);
      _sk0J::I64 = _ckEd::I64;
      if (_sk0J::I64 != 0) goto ckEs; else goto ckEk;
  ckEs:
      I64[(young<ckEr> + 8)] = ckEr;
      R1 = _sjZ7::P64;
      if (R1 & 7 != 0) goto ckEr; else goto ckEt;
  ckEt:
      call (I64[R1])(R1) returns to ckEr, args: 8, res: 8, upd: 8;
  ckEr:
      _sk0N::P64 = R1;
      _sk0O::I64 = I64[_sk0N::P64 + 7];
      _ckF2::I64 = _sk0O::I64 - 1;
      _sk0P::I64 = _ckF2::I64;
      _sjZc::I64 = _sk0P::I64;
      goto ckBh;
  ckEk:
      I64[(young<ckEi> + 8)] = ckEi;
      R1 = _sjZ7::P64;
      if (R1 & 7 != 0) goto ckEi; else goto ckEl;
  ckEl:
      call (I64[R1])(R1) returns to ckEi, args: 8, res: 8, upd: 8;
  ckEi:
      _sk0L::P64 = R1;
      _sk0M::I64 = I64[_sk0L::P64 + 7];
      _sjZc::I64 = _sk0M::I64;
      goto ckBh;
  ckBh:
      Hp = Hp + 120;
      if (Hp > HpLim) goto ckCX; else goto ckCW;
  ckCX:
      HpAlloc = 120;
      I64[(young<ckBg> + 8)] = ckBg;
      R1 = _sjZc::I64;
      call stg_gc_unbx_r1(R1) returns to ckBg, args: 8, res: 8, upd: 8;
  ckBg:
      _sjZc::I64 = R1;
      goto ckBh;
  ckCW:
      I64[Hp - 112] = Data.Vector.Primitive.Mutable.MVector_con_info;
      P64[Hp - 104] = _sjYM::P64;
      I64[Hp - 96] = _sjYK::I64;
      I64[Hp - 88] = _sjYL::I64;
      _ckBj::P64 = Hp - 111;
      I64[Hp - 80] = GHC.Types.I#_con_info;
      I64[Hp - 72] = _sjYG::I64;
      _ckBk::P64 = Hp - 79;
      I64[Hp - 64] = GHC.Types.I#_con_info;
      I64[Hp - 56] = _sjYF::I64;
      _ckBl::P64 = Hp - 63;
      I64[Hp - 48] = GHC.Arr.Array_con_info;
      P64[Hp - 40] = _ckBl::P64;
      P64[Hp - 32] = _ckBk::P64;
      P64[Hp - 24] = _sjYI::P64;
      I64[Hp - 16] = _sjYH::I64;
      _ckBm::P64 = Hp - 47;
      I64[Hp - 8] = Data.Primitive.ByteArray.MutableByteArray_con_info;
      P64[Hp] = _sjYE::P64;
      _ckF3::P64 = Hp - 7;
      _B2::P64 = _ckF3::P64;
      goto ckE9;
  ckE9:
      if (HpLim == 0) goto ckEb; else goto ckEc;
  ckEb:
      I64[(young<ckE8> + 8)] = ckE8;
      R1 = _B2::P64;
      call stg_gc_unpt_r1(R1) returns to ckE8, args: 8, res: 8, upd: 8;
  ckE8:
      _B2::P64 = R1;
      goto ckE9;
  ckEc:
      _sk0D::P64 = _B2::P64;
      goto ckDW;
  ckDW:
      if (HpLim == 0) goto ckDZ; else goto ckE0;
  ckDZ:
      I64[(young<ckDV> + 8)] = ckDV;
      R1 = _sk0D::P64;
      call stg_gc_unpt_r1(R1) returns to ckDV, args: 8, res: 8, upd: 8;
  ckDV:
      _sk0D::P64 = R1;
      goto ckDW;
  ckE0:
      I64[(young<ckDY> + 8)] = ckDY;
      R1 = _sk0D::P64;
      if (R1 & 7 != 0) goto ckDY; else goto ckE1;
  ckE1:
      call (I64[R1])(R1) returns to ckDY, args: 8, res: 8, upd: 8;
  ckDY:
      _sk0F::P64 = R1;
      _sk0G::P64 = P64[_sk0F::P64 + 7];
      _sjZi::P64 = _sk0G::P64;
      goto ckBq;
  ckBq:
      if (HpLim == 0) goto ckCY; else goto ckCZ;
  ckCY:
      I64[(young<ckBp> + 8)] = ckBp;
      R1 = _sjZi::P64;
      call stg_gc_unpt_r1(R1) returns to ckBp, args: 8, res: 8, upd: 8;
  ckBp:
      _sjZi::P64 = R1;
      goto ckBq;
  ckCZ:
      _sjZm::I64 = I64[_sjZi::P64 + 16];
      _sjZm::I64 = _sjZm::I64;
      I64[(young<ckBs> + 8)] = ckBs;
      R2 = _sjZm::I64;
      call $wgo1_rjVd_info(R2) returns to ckBs, args: 8, res: 8, upd: 8;
  ckBs:
      _sjZp::I64 = R2;
      _sjZo::I64 = R1;
      I64[_sjZi::P64 + 16] = _sjZo::I64;
      _sjZt::I64 = I64[_sjZi::P64 + 16];
      _sjZt::I64 = _sjZt::I64;
      _ckBy::I64 = _sjYN::I64 - 2;
      _sjZu::I64 = _ckBy::I64;
      _ckBB::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_sjZu::I64));
      _sjZv::I64 = _ckBB::I64;
      I64[(young<ckBE> + 8)] = ckBE;
      R3 = _sjZt::I64;
      R2 = _sjZv::I64;
      call System.Random.PCG.Fast.Pure.$wbounded_info(R3,
                                                      R2) returns to ckBE, args: 8, res: 8, upd: 8;
  ckBE:
      _sjZy::I64 = R2;
      _sjZx::I64 = R1;
      goto ckBF;
  ckBF:
      Hp = Hp + 40;
      if (Hp > HpLim) goto ckD3; else goto ckD2;
  ckD3:
      HpAlloc = 40;
      I64[(young<ckBG> + 8)] = ckBG;
      call stg_gc_noregs() returns to ckBG, args: 8, res: 8, upd: 8;
  ckBG:
      goto ckBF;
  ckD2:
      I64[_sjZi::P64 + 16] = _sjZx::I64;
      _ckBK::I64 = _sjZp::I64 <= _sjYZ::I64;
      _sjZA::I64 = _ckBK::I64;
      if (_sjZA::I64 != 0) goto ckDG; else goto ckDC;
  ckDG:
      I64[Hp - 32] = sat_sk0o_info;
      P64[Hp - 24] = _sjYJ::P64;
      P64[Hp - 16] = _ckBm::P64;
      I64[Hp - 8] = _sjZy::I64;
      _ckCu::P64 = Hp - 31;
      Hp = Hp - 8;
      I64[(young<ckDD> + 8)] = ckDD;
      R1 = _ckCu::P64;
      call stg_norec_atomically#(R1) returns to ckDD, args: 8, res: 8, upd: 8;
  ckDD:
      _sk0r::P64 = R1;
      _sk0u::P64 = P64[_sjYD::P64 + 8];
      _sk0u::P64 = _sk0u::P64;
      I64[(young<ckDF> + 8)] = ckDF;
      R1 = _sk0u::P64;
      if (R1 & 7 != 0) goto ckDF; else goto ckDI;
  ckDI:
      call (I64[R1])(R1) returns to ckDF, args: 8, res: 8, upd: 8;
  ckDF:
      _sk0v::P64 = R1;
      Hp = Hp + 16;
      if (Hp > HpLim) goto ckDO; else goto ckDN;
  ckDO:
      HpAlloc = 16;
      R1 = _sk0v::P64;
      call stg_gc_unpt_r1(R1) returns to ckDF, args: 8, res: 8, upd: 8;
  ckDN:
      _sk0w::I64 = I64[_sk0v::P64 + 7];
      _sk0x::I64 = _sk0w::I64;
      if (_sk0x::I64 != 18446744073709551615) goto ckDR; else goto ckDS;
  ckDR:
      _ckF5::I64 = _sk0x::I64 + 1;
      _sk0y::I64 = _ckF5::I64;
      I64[Hp - 8] = GHC.Word.W64#_con_info;
      I64[Hp] = _sk0y::I64;
      _ckF8::P64 = Hp - 7;
      P64[_sjYD::P64 + 8] = _ckF8::P64;
      _ckF9::I64 = dirty_MUT_VAR;
      _ckFa::I64 = BaseReg;
      _ckFb::P64 = _sjYD::P64;
      call "ccall" arg hints:  [PtrHint,
                                PtrHint]  result hints:  [] (_ckF9::I64)(_ckFa::I64, _ckFb::P64);
      _sjZi::P64 = _sjZi::P64;
      goto ckBq;
  ckDC:
      _ckBP::I64 = _sjZp::I64 <= _sjZc::I64;
      _sjZC::I64 = _ckBP::I64;
      if (_sjZC::I64 != 0) goto ckDo; else goto ckD8;
  ckDo:
      I64[Hp - 32] = sat_sk04_info;
      P64[Hp - 24] = _sjYJ::P64;
      P64[Hp - 16] = _ckBj::P64;
      P64[Hp - 8] = _ckBm::P64;
      I64[Hp] = _sjZy::I64;
      _ckCc::P64 = Hp - 31;
      I64[(young<ckDl> + 8)] = ckDl;
      R1 = _ckCc::P64;
      call stg_norec_atomically#(R1) returns to ckDl, args: 8, res: 8, upd: 8;
  ckDl:
      _sk07::P64 = R1;
      _sk0a::P64 = P64[_sjYD::P64 + 8];
      _sk0a::P64 = _sk0a::P64;
      I64[(young<ckDn> + 8)] = ckDn;
      R1 = _sk0a::P64;
      if (R1 & 7 != 0) goto ckDn; else goto ckDq;
  ckDq:
      call (I64[R1])(R1) returns to ckDn, args: 8, res: 8, upd: 8;
  ckDn:
      _sk0b::P64 = R1;
      Hp = Hp + 16;
      if (Hp > HpLim) goto ckDw; else goto ckDv;
  ckDw:
      HpAlloc = 16;
      R1 = _sk0b::P64;
      call stg_gc_unpt_r1(R1) returns to ckDn, args: 8, res: 8, upd: 8;
  ckDv:
      _sk0c::I64 = I64[_sk0b::P64 + 7];
      _sk0d::I64 = _sk0c::I64;
      if (_sk0d::I64 != 18446744073709551615) goto ckDz; else goto ckDS;
  ckDz:
      _ckFd::I64 = _sk0d::I64 + 1;
      _sk0e::I64 = _ckFd::I64;
      I64[Hp - 8] = GHC.Word.W64#_con_info;
      I64[Hp] = _sk0e::I64;
      _ckFg::P64 = Hp - 7;
      P64[_sjYD::P64 + 8] = _ckFg::P64;
      _ckFh::I64 = dirty_MUT_VAR;
      _ckFi::I64 = BaseReg;
      _ckFj::P64 = _sjYD::P64;
      call "ccall" arg hints:  [PtrHint,
                                PtrHint]  result hints:  [] (_ckFh::I64)(_ckFi::I64, _ckFj::P64);
      _sjZi::P64 = _sjZi::P64;
      goto ckBq;
  ckD8:
      I64[Hp - 32] = sat_sjZK_info;
      P64[Hp - 24] = _sjYJ::P64;
      P64[Hp - 16] = _ckBm::P64;
      I64[Hp - 8] = _sjZy::I64;
      _ckBU::P64 = Hp - 31;
      Hp = Hp - 8;
      I64[(young<ckD4> + 8)] = ckD4;
      R1 = _ckBU::P64;
      call stg_norec_atomically#(R1) returns to ckD4, args: 8, res: 8, upd: 8;
  ckD4:
      _sjZN::P64 = R1;
      _sjZQ::P64 = P64[_sjYD::P64 + 8];
      _sjZQ::P64 = _sjZQ::P64;
      I64[(young<ckD6> + 8)] = ckD6;
      R1 = _sjZQ::P64;
      if (R1 & 7 != 0) goto ckD6; else goto ckDa;
  ckDa:
      call (I64[R1])(R1) returns to ckD6, args: 8, res: 8, upd: 8;
  ckD6:
      _sjZR::P64 = R1;
      Hp = Hp + 16;
      if (Hp > HpLim) goto ckDg; else goto ckDf;
  ckDg:
      HpAlloc = 16;
      R1 = _sjZR::P64;
      call stg_gc_unpt_r1(R1) returns to ckD6, args: 8, res: 8, upd: 8;
  ckDf:
      _sjZS::I64 = I64[_sjZR::P64 + 7];
      _sjZT::I64 = _sjZS::I64;
      if (_sjZT::I64 != 18446744073709551615) goto ckDj; else goto ckDS;
  ckDj:
      _ckEU::I64 = _sjZT::I64 + 1;
      _sjZU::I64 = _ckEU::I64;
      I64[Hp - 8] = GHC.Word.W64#_con_info;
      I64[Hp] = _sjZU::I64;
      _ckEX::P64 = Hp - 7;
      P64[_sjYD::P64 + 8] = _ckEX::P64;
      _ckEY::I64 = dirty_MUT_VAR;
      _ckEZ::I64 = BaseReg;
      _ckF0::P64 = _sjYD::P64;
      call "ccall" arg hints:  [PtrHint,
                                PtrHint]  result hints:  [] (_ckEY::I64)(_ckEZ::I64, _ckF0::P64);
      _sjZi::P64 = _sjZi::P64;
      goto ckBq;
  ckDS:
      Hp = Hp - 16;
      R1 = GHC.Word.$fEnumWord12_closure;
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:53.540149 UTC

{offset
  ckCL:
      _sjYH::I64 = R6;
      _sjYG::I64 = R5;
      _sjYF::I64 = R4;
      _sjYE::P64 = R3;
      _sjYD::P64 = R2;
      _sjYI::P64 = P64[Sp];
      _sjYJ::P64 = P64[Sp + 8];
      _sjYK::I64 = I64[Sp + 16];
      _sjYL::I64 = I64[Sp + 24];
      _sjYM::P64 = P64[Sp + 32];
      _sjYN::I64 = I64[Sp + 40];
      _sjYO::F64 = F64[Sp + 48];
      if ((Sp + 64) - 120 < SpLim) goto ckCM; else goto ckCN;
  ckCN:
      if (HpLim == 0) goto ckCM; else goto ckCO;
  ckCM:
      R1 = Main.$wa1_closure;
      P64[Sp - 40] = _sjYD::P64;
      P64[Sp - 32] = _sjYE::P64;
      I64[Sp - 24] = _sjYF::I64;
      I64[Sp - 16] = _sjYG::I64;
      I64[Sp - 8] = _sjYH::I64;
      Sp = Sp - 40;
      call (stg_gc_fun)(R1) args: 104, res: 0, upd: 8;
  ckCO:
      _ckAt::I64 = 100000;
      (_ckAs::F64) = call MO_UF_Conv W64(_ckAt::I64);
      _sjYR::F64 = _ckAs::F64;
      _ckAw::F64 = %MO_F_Quot_W64(_sjYO::F64, 100.0 :: W64);
      _sjYQ::F64 = _ckAw::F64;
      _ckAz::F64 = %MO_F_Mul_W64(_sjYQ::F64, _sjYR::F64);
      _sjYS::F64 = _ckAz::F64;
      I64[Sp - 48] = ckAC;
      D1 = _sjYS::F64;
      R2 = GHC.Real.$fIntegralWord_closure;
      P64[Sp - 40] = _sjYD::P64;
      P64[Sp - 32] = _sjYE::P64;
      I64[Sp - 24] = _sjYF::I64;
      I64[Sp - 16] = _sjYG::I64;
      I64[Sp - 8] = _sjYH::I64;
      Sp = Sp - 48;
      call GHC.Float.$w$cproperFraction_info(D1,
                                             R2) returns to ckAC, args: 8, res: 8, upd: 8;
  ckAC:
      _sjYD::P64 = P64[Sp + 8];
      _sjYE::P64 = P64[Sp + 16];
      _sjYF::I64 = I64[Sp + 24];
      _sjYG::I64 = I64[Sp + 32];
      _sjYH::I64 = I64[Sp + 40];
      _sjYI::P64 = P64[Sp + 48];
      _sjYJ::P64 = P64[Sp + 56];
      _sjYK::I64 = I64[Sp + 64];
      _sjYL::I64 = I64[Sp + 72];
      _sjYM::P64 = P64[Sp + 80];
      _sjYN::I64 = I64[Sp + 88];
      _sjYO::F64 = F64[Sp + 96];
      _sjYV::P64 = R2;
      _sjYU::P64 = R1;
      I64[Sp - 8] = ckAE;
      R1 = _sjYV::P64;
      P64[Sp] = _sjYU::P64;
      Sp = Sp - 8;
      if (R1 & 7 != 0) goto ckAE; else goto ckAF;
  ckAF:
      call (I64[R1])(R1) returns to ckAE, args: 8, res: 8, upd: 8;
  ckAE:
      _sjYD::P64 = P64[Sp + 16];
      _sjYE::P64 = P64[Sp + 24];
      _sjYF::I64 = I64[Sp + 32];
      _sjYG::I64 = I64[Sp + 40];
      _sjYH::I64 = I64[Sp + 48];
      _sjYI::P64 = P64[Sp + 56];
      _sjYJ::P64 = P64[Sp + 64];
      _sjYK::I64 = I64[Sp + 72];
      _sjYL::I64 = I64[Sp + 80];
      _sjYM::P64 = P64[Sp + 88];
      _sjYN::I64 = I64[Sp + 96];
      _sjYO::F64 = F64[Sp + 104];
      _sjYU::P64 = P64[Sp + 8];
      _sjYW::P64 = R1;
      _sjYX::F64 = F64[_sjYW::P64 + 7];
      _ckEy::I64 = %MO_F_Lt_W64(_sjYX::F64, 0.0 :: W64);
      _sk0Q::I64 = _ckEy::I64;
      if (_sk0Q::I64 != 0) goto ckEN; else goto ckEF;
  ckEN:
      I64[Sp + 8] = ckEM;
      R1 = _sjYU::P64;
      Sp = Sp + 8;
      if (R1 & 7 != 0) goto ckEM; else goto ckEO;
  ckEO:
      call (I64[R1])(R1) returns to ckEM, args: 8, res: 8, upd: 8;
  ckEM:
      _sjYD::P64 = P64[Sp + 8];
      _sjYE::P64 = P64[Sp + 16];
      _sjYF::I64 = I64[Sp + 24];
      _sjYG::I64 = I64[Sp + 32];
      _sjYH::I64 = I64[Sp + 40];
      _sjYI::P64 = P64[Sp + 48];
      _sjYJ::P64 = P64[Sp + 56];
      _sjYK::I64 = I64[Sp + 64];
      _sjYL::I64 = I64[Sp + 72];
      _sjYM::P64 = P64[Sp + 80];
      _sjYN::I64 = I64[Sp + 88];
      _sjYO::F64 = F64[Sp + 96];
      _sk0U::P64 = R1;
      _sk0V::I64 = I64[_sk0U::P64 + 7];
      _ckF1::I64 = _sk0V::I64 - 1;
      _sk0W::I64 = _ckF1::I64;
      _sjYZ::I64 = _sk0W::I64;
      goto ckAM;
  ckEF:
      I64[Sp + 8] = ckED;
      R1 = _sjYU::P64;
      Sp = Sp + 8;
      if (R1 & 7 != 0) goto ckED; else goto ckEG;
  ckEG:
      call (I64[R1])(R1) returns to ckED, args: 8, res: 8, upd: 8;
  ckED:
      _sjYD::P64 = P64[Sp + 8];
      _sjYE::P64 = P64[Sp + 16];
      _sjYF::I64 = I64[Sp + 24];
      _sjYG::I64 = I64[Sp + 32];
      _sjYH::I64 = I64[Sp + 40];
      _sjYI::P64 = P64[Sp + 48];
      _sjYJ::P64 = P64[Sp + 56];
      _sjYK::I64 = I64[Sp + 64];
      _sjYL::I64 = I64[Sp + 72];
      _sjYM::P64 = P64[Sp + 80];
      _sjYN::I64 = I64[Sp + 88];
      _sjYO::F64 = F64[Sp + 96];
      _sk0S::P64 = R1;
      _sk0T::I64 = I64[_sk0S::P64 + 7];
      _sjYZ::I64 = _sk0T::I64;
      goto ckAM;
  ckAM:
      if (HpLim == 0) goto ckCR; else goto ckCS;
  ckCR:
      I64[Sp] = ckAL;
      R1 = _sjYZ::I64;
      call stg_gc_unbx_r1(R1) returns to ckAL, args: 8, res: 8, upd: 8;
  ckAL:
      _sjYD::P64 = P64[Sp + 8];
      _sjYE::P64 = P64[Sp + 16];
      _sjYF::I64 = I64[Sp + 24];
      _sjYG::I64 = I64[Sp + 32];
      _sjYH::I64 = I64[Sp + 40];
      _sjYI::P64 = P64[Sp + 48];
      _sjYJ::P64 = P64[Sp + 56];
      _sjYK::I64 = I64[Sp + 64];
      _sjYL::I64 = I64[Sp + 72];
      _sjYM::P64 = P64[Sp + 80];
      _sjYN::I64 = I64[Sp + 88];
      _sjYO::F64 = F64[Sp + 96];
      _sjYZ::I64 = R1;
      goto ckAM;
  ckCS:
      _ckAP::I64 = 100000;
      (_ckAO::F64) = call MO_UF_Conv W64(_ckAP::I64);
      _sjZ4::F64 = _ckAO::F64;
      _ckAS::F64 = %MO_F_Sub_W64(100.0 :: W64, _sjYO::F64);
      _sjZ0::F64 = _ckAS::F64;
      _ckAV::F64 = %MO_F_Quot_W64(_sjZ0::F64, 2.0 :: W64);
      _sjZ1::F64 = _ckAV::F64;
      _ckAY::F64 = %MO_F_Add_W64(_sjZ1::F64, _sjYO::F64);
      _sjZ2::F64 = _ckAY::F64;
      _ckB1::F64 = %MO_F_Quot_W64(_sjZ2::F64, 100.0 :: W64);
      _sjZ3::F64 = _ckB1::F64;
      _ckB4::F64 = %MO_F_Mul_W64(_sjZ3::F64, _sjZ4::F64);
      _sjZ5::F64 = _ckB4::F64;
      I64[Sp] = ckB7;
      D1 = _sjZ5::F64;
      R2 = GHC.Real.$fIntegralWord_closure;
      I64[Sp + 96] = _sjYZ::I64;
      call GHC.Float.$w$cproperFraction_info(D1,
                                             R2) returns to ckB7, args: 8, res: 8, upd: 8;
  ckB7:
      _sjYD::P64 = P64[Sp + 8];
      _sjYE::P64 = P64[Sp + 16];
      _sjYF::I64 = I64[Sp + 24];
      _sjYG::I64 = I64[Sp + 32];
      _sjYH::I64 = I64[Sp + 40];
      _sjYI::P64 = P64[Sp + 48];
      _sjYJ::P64 = P64[Sp + 56];
      _sjYK::I64 = I64[Sp + 64];
      _sjYL::I64 = I64[Sp + 72];
      _sjYM::P64 = P64[Sp + 80];
      _sjYN::I64 = I64[Sp + 88];
      _sjYZ::I64 = I64[Sp + 96];
      _sjZ8::P64 = R2;
      _sjZ7::P64 = R1;
      I64[Sp - 8] = ckB9;
      R1 = _sjZ8::P64;
      P64[Sp] = _sjZ7::P64;
      Sp = Sp - 8;
      if (R1 & 7 != 0) goto ckB9; else goto ckBa;
  ckBa:
      call (I64[R1])(R1) returns to ckB9, args: 8, res: 8, upd: 8;
  ckB9:
      _sjYD::P64 = P64[Sp + 16];
      _sjYE::P64 = P64[Sp + 24];
      _sjYF::I64 = I64[Sp + 32];
      _sjYG::I64 = I64[Sp + 40];
      _sjYH::I64 = I64[Sp + 48];
      _sjYI::P64 = P64[Sp + 56];
      _sjYJ::P64 = P64[Sp + 64];
      _sjYK::I64 = I64[Sp + 72];
      _sjYL::I64 = I64[Sp + 80];
      _sjYM::P64 = P64[Sp + 88];
      _sjYN::I64 = I64[Sp + 96];
      _sjYZ::I64 = I64[Sp + 104];
      _sjZ7::P64 = P64[Sp + 8];
      _sjZ9::P64 = R1;
      _sjZa::F64 = F64[_sjZ9::P64 + 7];
      _ckEd::I64 = %MO_F_Lt_W64(_sjZa::F64, 0.0 :: W64);
      _sk0J::I64 = _ckEd::I64;
      if (_sk0J::I64 != 0) goto ckEs; else goto ckEk;
  ckEs:
      I64[Sp + 8] = ckEr;
      R1 = _sjZ7::P64;
      Sp = Sp + 8;
      if (R1 & 7 != 0) goto ckEr; else goto ckEt;
  ckEt:
      call (I64[R1])(R1) returns to ckEr, args: 8, res: 8, upd: 8;
  ckEr:
      _sjYD::P64 = P64[Sp + 8];
      _sjYE::P64 = P64[Sp + 16];
      _sjYF::I64 = I64[Sp + 24];
      _sjYG::I64 = I64[Sp + 32];
      _sjYH::I64 = I64[Sp + 40];
      _sjYI::P64 = P64[Sp + 48];
      _sjYJ::P64 = P64[Sp + 56];
      _sjYK::I64 = I64[Sp + 64];
      _sjYL::I64 = I64[Sp + 72];
      _sjYM::P64 = P64[Sp + 80];
      _sjYN::I64 = I64[Sp + 88];
      _sjYZ::I64 = I64[Sp + 96];
      _sk0N::P64 = R1;
      _sk0O::I64 = I64[_sk0N::P64 + 7];
      _ckF2::I64 = _sk0O::I64 - 1;
      _sk0P::I64 = _ckF2::I64;
      _sjZc::I64 = _sk0P::I64;
      goto ckBh;
  ckEk:
      I64[Sp + 8] = ckEi;
      R1 = _sjZ7::P64;
      Sp = Sp + 8;
      if (R1 & 7 != 0) goto ckEi; else goto ckEl;
  ckEl:
      call (I64[R1])(R1) returns to ckEi, args: 8, res: 8, upd: 8;
  ckEi:
      _sjYD::P64 = P64[Sp + 8];
      _sjYE::P64 = P64[Sp + 16];
      _sjYF::I64 = I64[Sp + 24];
      _sjYG::I64 = I64[Sp + 32];
      _sjYH::I64 = I64[Sp + 40];
      _sjYI::P64 = P64[Sp + 48];
      _sjYJ::P64 = P64[Sp + 56];
      _sjYK::I64 = I64[Sp + 64];
      _sjYL::I64 = I64[Sp + 72];
      _sjYM::P64 = P64[Sp + 80];
      _sjYN::I64 = I64[Sp + 88];
      _sjYZ::I64 = I64[Sp + 96];
      _sk0L::P64 = R1;
      _sk0M::I64 = I64[_sk0L::P64 + 7];
      _sjZc::I64 = _sk0M::I64;
      goto ckBh;
  ckBh:
      Hp = Hp + 120;
      if (Hp > HpLim) goto ckCX; else goto ckCW;
  ckCX:
      HpAlloc = 120;
      I64[Sp] = ckBg;
      R1 = _sjZc::I64;
      call stg_gc_unbx_r1(R1) returns to ckBg, args: 8, res: 8, upd: 8;
  ckBg:
      _sjYD::P64 = P64[Sp + 8];
      _sjYE::P64 = P64[Sp + 16];
      _sjYF::I64 = I64[Sp + 24];
      _sjYG::I64 = I64[Sp + 32];
      _sjYH::I64 = I64[Sp + 40];
      _sjYI::P64 = P64[Sp + 48];
      _sjYJ::P64 = P64[Sp + 56];
      _sjYK::I64 = I64[Sp + 64];
      _sjYL::I64 = I64[Sp + 72];
      _sjYM::P64 = P64[Sp + 80];
      _sjYN::I64 = I64[Sp + 88];
      _sjYZ::I64 = I64[Sp + 96];
      _sjZc::I64 = R1;
      goto ckBh;
  ckCW:
      I64[Hp - 112] = Data.Vector.Primitive.Mutable.MVector_con_info;
      P64[Hp - 104] = _sjYM::P64;
      I64[Hp - 96] = _sjYK::I64;
      I64[Hp - 88] = _sjYL::I64;
      _ckBj::P64 = Hp - 111;
      I64[Hp - 80] = GHC.Types.I#_con_info;
      I64[Hp - 72] = _sjYG::I64;
      _ckBk::P64 = Hp - 79;
      I64[Hp - 64] = GHC.Types.I#_con_info;
      I64[Hp - 56] = _sjYF::I64;
      _ckBl::P64 = Hp - 63;
      I64[Hp - 48] = GHC.Arr.Array_con_info;
      P64[Hp - 40] = _ckBl::P64;
      P64[Hp - 32] = _ckBk::P64;
      P64[Hp - 24] = _sjYI::P64;
      I64[Hp - 16] = _sjYH::I64;
      _ckBm::P64 = Hp - 47;
      I64[Hp - 8] = Data.Primitive.ByteArray.MutableByteArray_con_info;
      P64[Hp] = _sjYE::P64;
      _ckF3::P64 = Hp - 7;
      _B2::P64 = _ckF3::P64;
      goto ckE9;
  ckE9:
      if (HpLim == 0) goto ckEb; else goto ckEc;
  ckEb:
      I64[Sp] = ckE8;
      R1 = _B2::P64;
      I64[Sp + 64] = _sjZc::I64;
      P64[Sp + 72] = _ckBm::P64;
      P64[Sp + 80] = _ckBj::P64;
      call stg_gc_unpt_r1(R1) returns to ckE8, args: 8, res: 8, upd: 8;
  ckE8:
      _ckBj::P64 = P64[Sp + 80];
      _ckBm::P64 = P64[Sp + 72];
      _sjYD::P64 = P64[Sp + 8];
      _sjYJ::P64 = P64[Sp + 56];
      _sjYN::I64 = I64[Sp + 88];
      _sjYZ::I64 = I64[Sp + 96];
      _sjZc::I64 = I64[Sp + 64];
      _B2::P64 = R1;
      goto ckE9;
  ckEc:
      _sk0D::P64 = _B2::P64;
      goto ckDW;
  ckDW:
      if (HpLim == 0) goto ckDZ; else goto ckE0;
  ckDZ:
      I64[Sp] = ckDV;
      R1 = _sk0D::P64;
      I64[Sp + 64] = _sjZc::I64;
      P64[Sp + 72] = _ckBm::P64;
      P64[Sp + 80] = _ckBj::P64;
      call stg_gc_unpt_r1(R1) returns to ckDV, args: 8, res: 8, upd: 8;
  ckDV:
      _ckBj::P64 = P64[Sp + 80];
      _ckBm::P64 = P64[Sp + 72];
      _sjYD::P64 = P64[Sp + 8];
      _sjYJ::P64 = P64[Sp + 56];
      _sjYN::I64 = I64[Sp + 88];
      _sjYZ::I64 = I64[Sp + 96];
      _sjZc::I64 = I64[Sp + 64];
      _sk0D::P64 = R1;
      goto ckDW;
  ckE0:
      I64[Sp] = ckDY;
      R1 = _sk0D::P64;
      I64[Sp + 64] = _sjZc::I64;
      P64[Sp + 72] = _ckBm::P64;
      P64[Sp + 80] = _ckBj::P64;
      if (R1 & 7 != 0) goto ckDY; else goto ckE1;
  ckE1:
      call (I64[R1])(R1) returns to ckDY, args: 8, res: 8, upd: 8;
  ckDY:
      _ckBj::P64 = P64[Sp + 80];
      _ckBm::P64 = P64[Sp + 72];
      _sjYD::P64 = P64[Sp + 8];
      _sjYJ::P64 = P64[Sp + 56];
      _sjYN::I64 = I64[Sp + 88];
      _sjYZ::I64 = I64[Sp + 96];
      _sjZc::I64 = I64[Sp + 64];
      _sk0F::P64 = R1;
      _sk0G::P64 = P64[_sk0F::P64 + 7];
      _sjZi::P64 = _sk0G::P64;
      goto ckBq;
  ckBq:
      if (HpLim == 0) goto ckCY; else goto ckCZ;
  ckCY:
      I64[Sp] = ckBp;
      R1 = _sjZi::P64;
      call stg_gc_unpt_r1(R1) returns to ckBp, args: 8, res: 8, upd: 8;
  ckBp:
      _ckBj::P64 = P64[Sp + 80];
      _ckBm::P64 = P64[Sp + 72];
      _sjYD::P64 = P64[Sp + 8];
      _sjYJ::P64 = P64[Sp + 56];
      _sjYN::I64 = I64[Sp + 88];
      _sjYZ::I64 = I64[Sp + 96];
      _sjZc::I64 = I64[Sp + 64];
      _sjZi::P64 = R1;
      goto ckBq;
  ckCZ:
      _sjZm::I64 = I64[_sjZi::P64 + 16];
      _sjZm::I64 = _sjZm::I64;
      I64[Sp] = ckBs;
      R2 = _sjZm::I64;
      P64[Sp + 48] = _sjZi::P64;
      call $wgo1_rjVd_info(R2) returns to ckBs, args: 8, res: 8, upd: 8;
  ckBs:
      _ckBj::P64 = P64[Sp + 80];
      _ckBm::P64 = P64[Sp + 72];
      _sjYD::P64 = P64[Sp + 8];
      _sjYJ::P64 = P64[Sp + 56];
      _sjYN::I64 = I64[Sp + 88];
      _sjYZ::I64 = I64[Sp + 96];
      _sjZc::I64 = I64[Sp + 64];
      _sjZi::P64 = P64[Sp + 48];
      _sjZp::I64 = R2;
      _sjZo::I64 = R1;
      I64[_sjZi::P64 + 16] = _sjZo::I64;
      _sjZt::I64 = I64[_sjZi::P64 + 16];
      _sjZt::I64 = _sjZt::I64;
      _ckBy::I64 = _sjYN::I64 - 2;
      _sjZu::I64 = _ckBy::I64;
      _ckBB::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_sjZu::I64));
      _sjZv::I64 = _ckBB::I64;
      I64[Sp] = ckBE;
      R3 = _sjZt::I64;
      R2 = _sjZv::I64;
      I64[Sp + 40] = _sjZp::I64;
      call System.Random.PCG.Fast.Pure.$wbounded_info(R3,
                                                      R2) returns to ckBE, args: 8, res: 8, upd: 8;
  ckBE:
      _ckBj::P64 = P64[Sp + 80];
      _ckBm::P64 = P64[Sp + 72];
      _sjYD::P64 = P64[Sp + 8];
      _sjYJ::P64 = P64[Sp + 56];
      _sjYN::I64 = I64[Sp + 88];
      _sjYZ::I64 = I64[Sp + 96];
      _sjZc::I64 = I64[Sp + 64];
      _sjZi::P64 = P64[Sp + 48];
      _sjZp::I64 = I64[Sp + 40];
      _sjZy::I64 = R2;
      _sjZx::I64 = R1;
      goto ckBF;
  ckBF:
      Hp = Hp + 40;
      if (Hp > HpLim) goto ckD3; else goto ckD2;
  ckD3:
      HpAlloc = 40;
      I64[Sp] = ckBG;
      I64[Sp + 24] = _sjZy::I64;
      I64[Sp + 32] = _sjZx::I64;
      call stg_gc_noregs() returns to ckBG, args: 8, res: 8, upd: 8;
  ckBG:
      _ckBj::P64 = P64[Sp + 80];
      _ckBm::P64 = P64[Sp + 72];
      _sjYD::P64 = P64[Sp + 8];
      _sjYJ::P64 = P64[Sp + 56];
      _sjYN::I64 = I64[Sp + 88];
      _sjYZ::I64 = I64[Sp + 96];
      _sjZc::I64 = I64[Sp + 64];
      _sjZi::P64 = P64[Sp + 48];
      _sjZp::I64 = I64[Sp + 40];
      _sjZx::I64 = I64[Sp + 32];
      _sjZy::I64 = I64[Sp + 24];
      goto ckBF;
  ckD2:
      I64[_sjZi::P64 + 16] = _sjZx::I64;
      _ckBK::I64 = _sjZp::I64 <= _sjYZ::I64;
      _sjZA::I64 = _ckBK::I64;
      if (_sjZA::I64 != 0) goto ckDG; else goto ckDC;
  ckDG:
      I64[Hp - 32] = sat_sk0o_info;
      P64[Hp - 24] = _sjYJ::P64;
      P64[Hp - 16] = _ckBm::P64;
      I64[Hp - 8] = _sjZy::I64;
      _ckCu::P64 = Hp - 31;
      Hp = Hp - 8;
      I64[Sp] = ckDD;
      R1 = _ckCu::P64;
      call stg_norec_atomically#(R1) returns to ckDD, args: 8, res: 8, upd: 8;
  ckDD:
      _ckBj::P64 = P64[Sp + 80];
      _ckBm::P64 = P64[Sp + 72];
      _sjYD::P64 = P64[Sp + 8];
      _sjYJ::P64 = P64[Sp + 56];
      _sjYN::I64 = I64[Sp + 88];
      _sjYZ::I64 = I64[Sp + 96];
      _sjZc::I64 = I64[Sp + 64];
      _sjZi::P64 = P64[Sp + 48];
      _sk0r::P64 = R1;
      _sk0u::P64 = P64[_sjYD::P64 + 8];
      _sk0u::P64 = _sk0u::P64;
      I64[Sp] = ckDF;
      R1 = _sk0u::P64;
      if (R1 & 7 != 0) goto ckDF; else goto ckDI;
  ckDI:
      call (I64[R1])(R1) returns to ckDF, args: 8, res: 8, upd: 8;
  ckDF:
      _ckBj::P64 = P64[Sp + 80];
      _ckBm::P64 = P64[Sp + 72];
      _sjYD::P64 = P64[Sp + 8];
      _sjYJ::P64 = P64[Sp + 56];
      _sjYN::I64 = I64[Sp + 88];
      _sjYZ::I64 = I64[Sp + 96];
      _sjZc::I64 = I64[Sp + 64];
      _sjZi::P64 = P64[Sp + 48];
      _sk0v::P64 = R1;
      Hp = Hp + 16;
      if (Hp > HpLim) goto ckDO; else goto ckDN;
  ckDO:
      HpAlloc = 16;
      R1 = _sk0v::P64;
      call stg_gc_unpt_r1(R1) returns to ckDF, args: 8, res: 8, upd: 8;
  ckDN:
      _sk0w::I64 = I64[_sk0v::P64 + 7];
      _sk0x::I64 = _sk0w::I64;
      if (_sk0x::I64 != 18446744073709551615) goto ckDR; else goto ckDS;
  ckDR:
      _ckF5::I64 = _sk0x::I64 + 1;
      _sk0y::I64 = _ckF5::I64;
      I64[Hp - 8] = GHC.Word.W64#_con_info;
      I64[Hp] = _sk0y::I64;
      _ckF8::P64 = Hp - 7;
      P64[_sjYD::P64 + 8] = _ckF8::P64;
      _ckF9::I64 = dirty_MUT_VAR;
      _ckFa::I64 = BaseReg;
      _ckFb::P64 = _sjYD::P64;
      call "ccall" arg hints:  [PtrHint,
                                PtrHint]  result hints:  [] (_ckF9::I64)(_ckFa::I64, _ckFb::P64);
      _sjZi::P64 = _sjZi::P64;
      goto ckBq;
  ckDC:
      _ckBP::I64 = _sjZp::I64 <= _sjZc::I64;
      _sjZC::I64 = _ckBP::I64;
      if (_sjZC::I64 != 0) goto ckDo; else goto ckD8;
  ckDo:
      I64[Hp - 32] = sat_sk04_info;
      P64[Hp - 24] = _sjYJ::P64;
      P64[Hp - 16] = _ckBj::P64;
      P64[Hp - 8] = _ckBm::P64;
      I64[Hp] = _sjZy::I64;
      _ckCc::P64 = Hp - 31;
      I64[Sp] = ckDl;
      R1 = _ckCc::P64;
      call stg_norec_atomically#(R1) returns to ckDl, args: 8, res: 8, upd: 8;
  ckDl:
      _ckBj::P64 = P64[Sp + 80];
      _ckBm::P64 = P64[Sp + 72];
      _sjYD::P64 = P64[Sp + 8];
      _sjYJ::P64 = P64[Sp + 56];
      _sjYN::I64 = I64[Sp + 88];
      _sjYZ::I64 = I64[Sp + 96];
      _sjZc::I64 = I64[Sp + 64];
      _sjZi::P64 = P64[Sp + 48];
      _sk07::P64 = R1;
      _sk0a::P64 = P64[_sjYD::P64 + 8];
      _sk0a::P64 = _sk0a::P64;
      I64[Sp] = ckDn;
      R1 = _sk0a::P64;
      if (R1 & 7 != 0) goto ckDn; else goto ckDq;
  ckDq:
      call (I64[R1])(R1) returns to ckDn, args: 8, res: 8, upd: 8;
  ckDn:
      _ckBj::P64 = P64[Sp + 80];
      _ckBm::P64 = P64[Sp + 72];
      _sjYD::P64 = P64[Sp + 8];
      _sjYJ::P64 = P64[Sp + 56];
      _sjYN::I64 = I64[Sp + 88];
      _sjYZ::I64 = I64[Sp + 96];
      _sjZc::I64 = I64[Sp + 64];
      _sjZi::P64 = P64[Sp + 48];
      _sk0b::P64 = R1;
      Hp = Hp + 16;
      if (Hp > HpLim) goto ckDw; else goto ckDv;
  ckDw:
      HpAlloc = 16;
      R1 = _sk0b::P64;
      call stg_gc_unpt_r1(R1) returns to ckDn, args: 8, res: 8, upd: 8;
  ckDv:
      _sk0c::I64 = I64[_sk0b::P64 + 7];
      _sk0d::I64 = _sk0c::I64;
      if (_sk0d::I64 != 18446744073709551615) goto ckDz; else goto ckDS;
  ckDz:
      _ckFd::I64 = _sk0d::I64 + 1;
      _sk0e::I64 = _ckFd::I64;
      I64[Hp - 8] = GHC.Word.W64#_con_info;
      I64[Hp] = _sk0e::I64;
      _ckFg::P64 = Hp - 7;
      P64[_sjYD::P64 + 8] = _ckFg::P64;
      _ckFh::I64 = dirty_MUT_VAR;
      _ckFi::I64 = BaseReg;
      _ckFj::P64 = _sjYD::P64;
      call "ccall" arg hints:  [PtrHint,
                                PtrHint]  result hints:  [] (_ckFh::I64)(_ckFi::I64, _ckFj::P64);
      _sjZi::P64 = _sjZi::P64;
      goto ckBq;
  ckD8:
      I64[Hp - 32] = sat_sjZK_info;
      P64[Hp - 24] = _sjYJ::P64;
      P64[Hp - 16] = _ckBm::P64;
      I64[Hp - 8] = _sjZy::I64;
      _ckBU::P64 = Hp - 31;
      Hp = Hp - 8;
      I64[Sp] = ckD4;
      R1 = _ckBU::P64;
      call stg_norec_atomically#(R1) returns to ckD4, args: 8, res: 8, upd: 8;
  ckD4:
      _ckBj::P64 = P64[Sp + 80];
      _ckBm::P64 = P64[Sp + 72];
      _sjYD::P64 = P64[Sp + 8];
      _sjYJ::P64 = P64[Sp + 56];
      _sjYN::I64 = I64[Sp + 88];
      _sjYZ::I64 = I64[Sp + 96];
      _sjZc::I64 = I64[Sp + 64];
      _sjZi::P64 = P64[Sp + 48];
      _sjZN::P64 = R1;
      _sjZQ::P64 = P64[_sjYD::P64 + 8];
      _sjZQ::P64 = _sjZQ::P64;
      I64[Sp] = ckD6;
      R1 = _sjZQ::P64;
      if (R1 & 7 != 0) goto ckD6; else goto ckDa;
  ckDa:
      call (I64[R1])(R1) returns to ckD6, args: 8, res: 8, upd: 8;
  ckD6:
      _ckBj::P64 = P64[Sp + 80];
      _ckBm::P64 = P64[Sp + 72];
      _sjYD::P64 = P64[Sp + 8];
      _sjYJ::P64 = P64[Sp + 56];
      _sjYN::I64 = I64[Sp + 88];
      _sjYZ::I64 = I64[Sp + 96];
      _sjZc::I64 = I64[Sp + 64];
      _sjZi::P64 = P64[Sp + 48];
      _sjZR::P64 = R1;
      Hp = Hp + 16;
      if (Hp > HpLim) goto ckDg; else goto ckDf;
  ckDg:
      HpAlloc = 16;
      R1 = _sjZR::P64;
      call stg_gc_unpt_r1(R1) returns to ckD6, args: 8, res: 8, upd: 8;
  ckDf:
      _sjZS::I64 = I64[_sjZR::P64 + 7];
      _sjZT::I64 = _sjZS::I64;
      if (_sjZT::I64 != 18446744073709551615) goto ckDj; else goto ckDS;
  ckDj:
      _ckEU::I64 = _sjZT::I64 + 1;
      _sjZU::I64 = _ckEU::I64;
      I64[Hp - 8] = GHC.Word.W64#_con_info;
      I64[Hp] = _sjZU::I64;
      _ckEX::P64 = Hp - 7;
      P64[_sjYD::P64 + 8] = _ckEX::P64;
      _ckEY::I64 = dirty_MUT_VAR;
      _ckEZ::I64 = BaseReg;
      _ckF0::P64 = _sjYD::P64;
      call "ccall" arg hints:  [PtrHint,
                                PtrHint]  result hints:  [] (_ckEY::I64)(_ckEZ::I64, _ckF0::P64);
      _sjZi::P64 = _sjZi::P64;
      goto ckBq;
  ckDS:
      Hp = Hp - 16;
      R1 = GHC.Word.$fEnumWord12_closure;
      Sp = Sp + 104;
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:53.571701 UTC

{offset
  ckCL:
      _sjYH::I64 = R6;
      _sjYG::I64 = R5;
      _sjYF::I64 = R4;
      _sjYE::P64 = R3;
      _sjYD::P64 = R2;
      if ((Sp + -56) < SpLim) goto ckCM; else goto ckCN;
  ckCN:
      if (HpLim == 0) goto ckCM; else goto ckCO;
  ckCM:
      R1 = Main.$wa1_closure;
      P64[Sp - 40] = _sjYD::P64;
      P64[Sp - 32] = _sjYE::P64;
      I64[Sp - 24] = _sjYF::I64;
      I64[Sp - 16] = _sjYG::I64;
      I64[Sp - 8] = _sjYH::I64;
      Sp = Sp - 40;
      call (stg_gc_fun)(R1) args: 104, res: 0, upd: 8;
  ckCO:
      _sjYO::F64 = F64[Sp + 48];
      (_ckAs::F64) = call MO_UF_Conv W64(100000);
      I64[Sp - 48] = ckAC;
      D1 = %MO_F_Mul_W64(%MO_F_Quot_W64(_sjYO::F64, 100.0 :: W64),
                         _ckAs::F64);
      R2 = GHC.Real.$fIntegralWord_closure;
      P64[Sp - 40] = _sjYD::P64;
      P64[Sp - 32] = _sjYE::P64;
      I64[Sp - 24] = _sjYF::I64;
      I64[Sp - 16] = _sjYG::I64;
      I64[Sp - 8] = _sjYH::I64;
      Sp = Sp - 48;
      call GHC.Float.$w$cproperFraction_info(D1,
                                             R2) returns to ckAC, args: 8, res: 8, upd: 8;
  ckAC:
      I64[Sp - 8] = ckAE;
      _sjYU::P64 = R1;
      R1 = R2;
      P64[Sp] = _sjYU::P64;
      Sp = Sp - 8;
      if (R1 & 7 != 0) goto ckAE; else goto ckAF;
  ckAF:
      call (I64[R1])(R1) returns to ckAE, args: 8, res: 8, upd: 8;
  ckAE:
      _sjYU::P64 = P64[Sp + 8];
      if (%MO_F_Lt_W64(F64[R1 + 7],
                       0.0 :: W64)) goto ckEN; else goto ckEF;
  ckEN:
      I64[Sp + 8] = ckEM;
      R1 = _sjYU::P64;
      Sp = Sp + 8;
      if (R1 & 7 != 0) goto ckEM; else goto ckEO;
  ckEO:
      call (I64[R1])(R1) returns to ckEM, args: 8, res: 8, upd: 8;
  ckEM:
      _sjYO::F64 = F64[Sp + 96];
      _sjYZ::I64 = I64[R1 + 7] - 1;
      goto ckAM;
  ckEF:
      I64[Sp + 8] = ckED;
      R1 = _sjYU::P64;
      Sp = Sp + 8;
      if (R1 & 7 != 0) goto ckED; else goto ckEG;
  ckEG:
      call (I64[R1])(R1) returns to ckED, args: 8, res: 8, upd: 8;
  ckED:
      _sjYO::F64 = F64[Sp + 96];
      _sjYZ::I64 = I64[R1 + 7];
      goto ckAM;
  ckAM:
      if (HpLim == 0) goto ckCR; else goto ckCS;
  ckCR:
      I64[Sp] = ckAL;
      R1 = _sjYZ::I64;
      call stg_gc_unbx_r1(R1) returns to ckAL, args: 8, res: 8, upd: 8;
  ckAL:
      _sjYO::F64 = F64[Sp + 96];
      _sjYZ::I64 = R1;
      goto ckAM;
  ckCS:
      (_ckAO::F64) = call MO_UF_Conv W64(100000);
      I64[Sp] = ckB7;
      D1 = %MO_F_Mul_W64(%MO_F_Quot_W64(%MO_F_Add_W64(%MO_F_Quot_W64(%MO_F_Sub_W64(100.0 :: W64,
                                                                                   _sjYO::F64),
                                                                     2.0 :: W64),
                                                      _sjYO::F64),
                                        100.0 :: W64),
                         _ckAO::F64);
      R2 = GHC.Real.$fIntegralWord_closure;
      I64[Sp + 96] = _sjYZ::I64;
      call GHC.Float.$w$cproperFraction_info(D1,
                                             R2) returns to ckB7, args: 8, res: 8, upd: 8;
  ckB7:
      I64[Sp - 8] = ckB9;
      _sjZ7::P64 = R1;
      R1 = R2;
      P64[Sp] = _sjZ7::P64;
      Sp = Sp - 8;
      if (R1 & 7 != 0) goto ckB9; else goto ckBa;
  ckBa:
      call (I64[R1])(R1) returns to ckB9, args: 8, res: 8, upd: 8;
  ckB9:
      _sjZ7::P64 = P64[Sp + 8];
      if (%MO_F_Lt_W64(F64[R1 + 7],
                       0.0 :: W64)) goto ckEs; else goto ckEk;
  ckEs:
      I64[Sp + 8] = ckEr;
      R1 = _sjZ7::P64;
      Sp = Sp + 8;
      if (R1 & 7 != 0) goto ckEr; else goto ckEt;
  ckEt:
      call (I64[R1])(R1) returns to ckEr, args: 8, res: 8, upd: 8;
  ckEr:
      _sjYE::P64 = P64[Sp + 16];
      _sjYF::I64 = I64[Sp + 24];
      _sjYG::I64 = I64[Sp + 32];
      _sjYH::I64 = I64[Sp + 40];
      _sjYI::P64 = P64[Sp + 48];
      _sjYK::I64 = I64[Sp + 64];
      _sjYL::I64 = I64[Sp + 72];
      _sjYM::P64 = P64[Sp + 80];
      _sjZc::I64 = I64[R1 + 7] - 1;
      goto ckBh;
  ckEk:
      I64[Sp + 8] = ckEi;
      R1 = _sjZ7::P64;
      Sp = Sp + 8;
      if (R1 & 7 != 0) goto ckEi; else goto ckEl;
  ckEl:
      call (I64[R1])(R1) returns to ckEi, args: 8, res: 8, upd: 8;
  ckEi:
      _sjYE::P64 = P64[Sp + 16];
      _sjYF::I64 = I64[Sp + 24];
      _sjYG::I64 = I64[Sp + 32];
      _sjYH::I64 = I64[Sp + 40];
      _sjYI::P64 = P64[Sp + 48];
      _sjYK::I64 = I64[Sp + 64];
      _sjYL::I64 = I64[Sp + 72];
      _sjYM::P64 = P64[Sp + 80];
      _sjZc::I64 = I64[R1 + 7];
      goto ckBh;
  ckBh:
      Hp = Hp + 120;
      if (Hp > HpLim) goto ckCX; else goto ckCW;
  ckCX:
      HpAlloc = 120;
      I64[Sp] = ckBg;
      R1 = _sjZc::I64;
      call stg_gc_unbx_r1(R1) returns to ckBg, args: 8, res: 8, upd: 8;
  ckBg:
      _sjYE::P64 = P64[Sp + 16];
      _sjYF::I64 = I64[Sp + 24];
      _sjYG::I64 = I64[Sp + 32];
      _sjYH::I64 = I64[Sp + 40];
      _sjYI::P64 = P64[Sp + 48];
      _sjYK::I64 = I64[Sp + 64];
      _sjYL::I64 = I64[Sp + 72];
      _sjYM::P64 = P64[Sp + 80];
      _sjZc::I64 = R1;
      goto ckBh;
  ckCW:
      I64[Hp - 112] = Data.Vector.Primitive.Mutable.MVector_con_info;
      P64[Hp - 104] = _sjYM::P64;
      I64[Hp - 96] = _sjYK::I64;
      I64[Hp - 88] = _sjYL::I64;
      I64[Hp - 80] = GHC.Types.I#_con_info;
      I64[Hp - 72] = _sjYG::I64;
      I64[Hp - 64] = GHC.Types.I#_con_info;
      I64[Hp - 56] = _sjYF::I64;
      I64[Hp - 48] = GHC.Arr.Array_con_info;
      P64[Hp - 40] = Hp - 63;
      P64[Hp - 32] = Hp - 79;
      P64[Hp - 24] = _sjYI::P64;
      I64[Hp - 16] = _sjYH::I64;
      I64[Hp - 8] = Data.Primitive.ByteArray.MutableByteArray_con_info;
      P64[Hp] = _sjYE::P64;
      _ckBj::P64 = Hp - 111;
      _ckBm::P64 = Hp - 47;
      _B2::P64 = Hp - 7;
      goto ckE9;
  ckE9:
      if (HpLim == 0) goto ckEb; else goto ckEc;
  ckEb:
      I64[Sp] = ckE8;
      R1 = _B2::P64;
      I64[Sp + 64] = _sjZc::I64;
      P64[Sp + 72] = _ckBm::P64;
      P64[Sp + 80] = _ckBj::P64;
      call stg_gc_unpt_r1(R1) returns to ckE8, args: 8, res: 8, upd: 8;
  ckE8:
      _ckBj::P64 = P64[Sp + 80];
      _ckBm::P64 = P64[Sp + 72];
      _sjZc::I64 = I64[Sp + 64];
      _B2::P64 = R1;
      goto ckE9;
  ckEc:
      _sk0D::P64 = _B2::P64;
      goto ckDW;
  ckDW:
      if (HpLim == 0) goto ckDZ; else goto ckE0;
  ckDZ:
      I64[Sp] = ckDV;
      R1 = _sk0D::P64;
      I64[Sp + 64] = _sjZc::I64;
      P64[Sp + 72] = _ckBm::P64;
      P64[Sp + 80] = _ckBj::P64;
      call stg_gc_unpt_r1(R1) returns to ckDV, args: 8, res: 8, upd: 8;
  ckDV:
      _ckBj::P64 = P64[Sp + 80];
      _ckBm::P64 = P64[Sp + 72];
      _sjZc::I64 = I64[Sp + 64];
      _sk0D::P64 = R1;
      goto ckDW;
  ckE0:
      I64[Sp] = ckDY;
      R1 = _sk0D::P64;
      I64[Sp + 64] = _sjZc::I64;
      P64[Sp + 72] = _ckBm::P64;
      P64[Sp + 80] = _ckBj::P64;
      if (R1 & 7 != 0) goto ckDY; else goto ckE1;
  ckE1:
      call (I64[R1])(R1) returns to ckDY, args: 8, res: 8, upd: 8;
  ckDY:
      _sjZi::P64 = P64[R1 + 7];
      goto ckBq;
  ckBq:
      if (HpLim == 0) goto ckCY; else goto ckCZ;
  ckCY:
      I64[Sp] = ckBp;
      R1 = _sjZi::P64;
      call stg_gc_unpt_r1(R1) returns to ckBp, args: 8, res: 8, upd: 8;
  ckBp:
      _sjZi::P64 = R1;
      goto ckBq;
  ckCZ:
      I64[Sp] = ckBs;
      R2 = I64[_sjZi::P64 + 16];
      P64[Sp + 48] = _sjZi::P64;
      call $wgo1_rjVd_info(R2) returns to ckBs, args: 8, res: 8, upd: 8;
  ckBs:
      _sjZi::P64 = P64[Sp + 48];
      I64[_sjZi::P64 + 16] = R1;
      I64[Sp] = ckBE;
      R3 = I64[_sjZi::P64 + 16];
      _sjZp::I64 = R2;
      R2 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[Sp + 88] - 2));
      I64[Sp + 40] = _sjZp::I64;
      call System.Random.PCG.Fast.Pure.$wbounded_info(R3,
                                                      R2) returns to ckBE, args: 8, res: 8, upd: 8;
  ckBE:
      _ckBj::P64 = P64[Sp + 80];
      _ckBm::P64 = P64[Sp + 72];
      _sjYJ::P64 = P64[Sp + 56];
      _sjYZ::I64 = I64[Sp + 96];
      _sjZc::I64 = I64[Sp + 64];
      _sjZi::P64 = P64[Sp + 48];
      _sjZp::I64 = I64[Sp + 40];
      _sjZy::I64 = R2;
      _sjZx::I64 = R1;
      goto ckBF;
  ckBF:
      Hp = Hp + 40;
      if (Hp > HpLim) goto ckD3; else goto ckD2;
  ckD3:
      HpAlloc = 40;
      I64[Sp] = ckBG;
      I64[Sp + 24] = _sjZy::I64;
      I64[Sp + 32] = _sjZx::I64;
      call stg_gc_noregs() returns to ckBG, args: 8, res: 8, upd: 8;
  ckBG:
      _ckBj::P64 = P64[Sp + 80];
      _ckBm::P64 = P64[Sp + 72];
      _sjYJ::P64 = P64[Sp + 56];
      _sjYZ::I64 = I64[Sp + 96];
      _sjZc::I64 = I64[Sp + 64];
      _sjZi::P64 = P64[Sp + 48];
      _sjZp::I64 = I64[Sp + 40];
      _sjZx::I64 = I64[Sp + 32];
      _sjZy::I64 = I64[Sp + 24];
      goto ckBF;
  ckD2:
      I64[_sjZi::P64 + 16] = _sjZx::I64;
      if (_sjZp::I64 <= _sjYZ::I64) goto ckDG; else goto ckDC;
  ckDG:
      I64[Hp - 32] = sat_sk0o_info;
      P64[Hp - 24] = _sjYJ::P64;
      P64[Hp - 16] = _ckBm::P64;
      I64[Hp - 8] = _sjZy::I64;
      _ckCu::P64 = Hp - 31;
      Hp = Hp - 8;
      I64[Sp] = ckDD;
      R1 = _ckCu::P64;
      call stg_norec_atomically#(R1) returns to ckDD, args: 8, res: 8, upd: 8;
  ckDD:
      _sk0u::P64 = P64[P64[Sp + 8] + 8];
      I64[Sp] = ckDF;
      R1 = _sk0u::P64;
      if (R1 & 7 != 0) goto ckDF; else goto ckDI;
  ckDI:
      call (I64[R1])(R1) returns to ckDF, args: 8, res: 8, upd: 8;
  ckDF:
      Hp = Hp + 16;
      if (Hp > HpLim) goto ckDO; else goto ckDN;
  ckDO:
      HpAlloc = 16;
      R1 = R1;
      call stg_gc_unpt_r1(R1) returns to ckDF, args: 8, res: 8, upd: 8;
  ckDN:
      _sk0x::I64 = I64[R1 + 7];
      if (_sk0x::I64 != 18446744073709551615) goto ckDR; else goto ckDS;
  ckDR:
      I64[Hp - 8] = GHC.Word.W64#_con_info;
      I64[Hp] = _sk0x::I64 + 1;
      _sjYD::P64 = P64[Sp + 8];
      P64[_sjYD::P64 + 8] = Hp - 7;
      _sjZi::P64 = P64[Sp + 48];
      call "ccall" arg hints:  [PtrHint,
                                PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sjYD::P64);
      goto ckBq;
  ckDC:
      if (_sjZp::I64 <= _sjZc::I64) goto ckDo; else goto ckD8;
  ckDo:
      I64[Hp - 32] = sat_sk04_info;
      P64[Hp - 24] = _sjYJ::P64;
      P64[Hp - 16] = _ckBj::P64;
      P64[Hp - 8] = _ckBm::P64;
      I64[Hp] = _sjZy::I64;
      I64[Sp] = ckDl;
      R1 = Hp - 31;
      call stg_norec_atomically#(R1) returns to ckDl, args: 8, res: 8, upd: 8;
  ckDl:
      _sk0a::P64 = P64[P64[Sp + 8] + 8];
      I64[Sp] = ckDn;
      R1 = _sk0a::P64;
      if (R1 & 7 != 0) goto ckDn; else goto ckDq;
  ckDq:
      call (I64[R1])(R1) returns to ckDn, args: 8, res: 8, upd: 8;
  ckDn:
      Hp = Hp + 16;
      if (Hp > HpLim) goto ckDw; else goto ckDv;
  ckDw:
      HpAlloc = 16;
      R1 = R1;
      call stg_gc_unpt_r1(R1) returns to ckDn, args: 8, res: 8, upd: 8;
  ckDv:
      _sk0d::I64 = I64[R1 + 7];
      if (_sk0d::I64 != 18446744073709551615) goto ckDz; else goto ckDS;
  ckDz:
      I64[Hp - 8] = GHC.Word.W64#_con_info;
      I64[Hp] = _sk0d::I64 + 1;
      _sjYD::P64 = P64[Sp + 8];
      P64[_sjYD::P64 + 8] = Hp - 7;
      _sjZi::P64 = P64[Sp + 48];
      call "ccall" arg hints:  [PtrHint,
                                PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sjYD::P64);
      goto ckBq;
  ckD8:
      I64[Hp - 32] = sat_sjZK_info;
      P64[Hp - 24] = _sjYJ::P64;
      P64[Hp - 16] = _ckBm::P64;
      I64[Hp - 8] = _sjZy::I64;
      _ckBU::P64 = Hp - 31;
      Hp = Hp - 8;
      I64[Sp] = ckD4;
      R1 = _ckBU::P64;
      call stg_norec_atomically#(R1) returns to ckD4, args: 8, res: 8, upd: 8;
  ckD4:
      _sjZQ::P64 = P64[P64[Sp + 8] + 8];
      I64[Sp] = ckD6;
      R1 = _sjZQ::P64;
      if (R1 & 7 != 0) goto ckD6; else goto ckDa;
  ckDa:
      call (I64[R1])(R1) returns to ckD6, args: 8, res: 8, upd: 8;
  ckD6:
      Hp = Hp + 16;
      if (Hp > HpLim) goto ckDg; else goto ckDf;
  ckDg:
      HpAlloc = 16;
      R1 = R1;
      call stg_gc_unpt_r1(R1) returns to ckD6, args: 8, res: 8, upd: 8;
  ckDf:
      _sjZT::I64 = I64[R1 + 7];
      if (_sjZT::I64 != 18446744073709551615) goto ckDj; else goto ckDS;
  ckDj:
      I64[Hp - 8] = GHC.Word.W64#_con_info;
      I64[Hp] = _sjZT::I64 + 1;
      _sjYD::P64 = P64[Sp + 8];
      P64[_sjYD::P64 + 8] = Hp - 7;
      _sjZi::P64 = P64[Sp + 48];
      call "ccall" arg hints:  [PtrHint,
                                PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sjYD::P64);
      goto ckBq;
  ckDS:
      Hp = Hp - 16;
      R1 = GHC.Word.$fEnumWord12_closure;
      Sp = Sp + 104;
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:53.595427 UTC

[(ckAC,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Real.$fIntegralWord_closure,
   GHC.Float.$w$cproperFraction_closure,
   GHC.Word.$fEnumWord12_closure, sat_sjZK_closure, sat_sk04_closure,
   sat_sk0o_closure}),
 (ckAE,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Real.$fIntegralWord_closure,
   GHC.Float.$w$cproperFraction_closure,
   GHC.Word.$fEnumWord12_closure, sat_sjZK_closure, sat_sk04_closure,
   sat_sk0o_closure}),
 (ckAF,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Real.$fIntegralWord_closure,
   GHC.Float.$w$cproperFraction_closure,
   GHC.Word.$fEnumWord12_closure, sat_sjZK_closure, sat_sk04_closure,
   sat_sk0o_closure}),
 (ckAL,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Real.$fIntegralWord_closure,
   GHC.Float.$w$cproperFraction_closure,
   GHC.Word.$fEnumWord12_closure, sat_sjZK_closure, sat_sk04_closure,
   sat_sk0o_closure}),
 (ckAM,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Real.$fIntegralWord_closure,
   GHC.Float.$w$cproperFraction_closure,
   GHC.Word.$fEnumWord12_closure, sat_sjZK_closure, sat_sk04_closure,
   sat_sk0o_closure}),
 (ckB7,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure, sat_sjZK_closure, sat_sk04_closure,
   sat_sk0o_closure}),
 (ckB9,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure, sat_sjZK_closure, sat_sk04_closure,
   sat_sk0o_closure}),
 (ckBa,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure, sat_sjZK_closure, sat_sk04_closure,
   sat_sk0o_closure}),
 (ckBg,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure, sat_sjZK_closure, sat_sk04_closure,
   sat_sk0o_closure}),
 (ckBh,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure, sat_sjZK_closure, sat_sk04_closure,
   sat_sk0o_closure}),
 (ckBp,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure, sat_sjZK_closure, sat_sk04_closure,
   sat_sk0o_closure}),
 (ckBq,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure, sat_sjZK_closure, sat_sk04_closure,
   sat_sk0o_closure}),
 (ckBs,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure, sat_sjZK_closure, sat_sk04_closure,
   sat_sk0o_closure}),
 (ckBE,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure, sat_sjZK_closure, sat_sk04_closure,
   sat_sk0o_closure}),
 (ckBF,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure, sat_sjZK_closure, sat_sk04_closure,
   sat_sk0o_closure}),
 (ckBG,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure, sat_sjZK_closure, sat_sk04_closure,
   sat_sk0o_closure}),
 (ckCL,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Real.$fIntegralWord_closure,
   GHC.Float.$w$cproperFraction_closure,
   GHC.Word.$fEnumWord12_closure, Main.$wa1_closure, sat_sjZK_closure,
   sat_sk04_closure, sat_sk0o_closure}),
 (ckCM, {Main.$wa1_closure}),
 (ckCN,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Real.$fIntegralWord_closure,
   GHC.Float.$w$cproperFraction_closure,
   GHC.Word.$fEnumWord12_closure, Main.$wa1_closure, sat_sjZK_closure,
   sat_sk04_closure, sat_sk0o_closure}),
 (ckCO,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Real.$fIntegralWord_closure,
   GHC.Float.$w$cproperFraction_closure,
   GHC.Word.$fEnumWord12_closure, sat_sjZK_closure, sat_sk04_closure,
   sat_sk0o_closure}),
 (ckCR,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Real.$fIntegralWord_closure,
   GHC.Float.$w$cproperFraction_closure,
   GHC.Word.$fEnumWord12_closure, sat_sjZK_closure, sat_sk04_closure,
   sat_sk0o_closure}),
 (ckCS,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Real.$fIntegralWord_closure,
   GHC.Float.$w$cproperFraction_closure,
   GHC.Word.$fEnumWord12_closure, sat_sjZK_closure, sat_sk04_closure,
   sat_sk0o_closure}),
 (ckCW,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure, sat_sjZK_closure, sat_sk04_closure,
   sat_sk0o_closure}),
 (ckCX,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure, sat_sjZK_closure, sat_sk04_closure,
   sat_sk0o_closure}),
 (ckCY,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure, sat_sjZK_closure, sat_sk04_closure,
   sat_sk0o_closure}),
 (ckCZ,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure, sat_sjZK_closure, sat_sk04_closure,
   sat_sk0o_closure}),
 (ckD2,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure, sat_sjZK_closure, sat_sk04_closure,
   sat_sk0o_closure}),
 (ckD3,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure, sat_sjZK_closure, sat_sk04_closure,
   sat_sk0o_closure}),
 (ckD4,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure, sat_sjZK_closure, sat_sk04_closure,
   sat_sk0o_closure}),
 (ckD6,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure, sat_sjZK_closure, sat_sk04_closure,
   sat_sk0o_closure}),
 (ckD8,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure, sat_sjZK_closure, sat_sk04_closure,
   sat_sk0o_closure}),
 (ckDa,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure, sat_sjZK_closure, sat_sk04_closure,
   sat_sk0o_closure}),
 (ckDf,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure, sat_sjZK_closure, sat_sk04_closure,
   sat_sk0o_closure}),
 (ckDg,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure, sat_sjZK_closure, sat_sk04_closure,
   sat_sk0o_closure}),
 (ckDj,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure, sat_sjZK_closure, sat_sk04_closure,
   sat_sk0o_closure}),
 (ckDl,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure, sat_sjZK_closure, sat_sk04_closure,
   sat_sk0o_closure}),
 (ckDn,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure, sat_sjZK_closure, sat_sk04_closure,
   sat_sk0o_closure}),
 (ckDo,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure, sat_sjZK_closure, sat_sk04_closure,
   sat_sk0o_closure}),
 (ckDq,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure, sat_sjZK_closure, sat_sk04_closure,
   sat_sk0o_closure}),
 (ckDv,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure, sat_sjZK_closure, sat_sk04_closure,
   sat_sk0o_closure}),
 (ckDw,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure, sat_sjZK_closure, sat_sk04_closure,
   sat_sk0o_closure}),
 (ckDz,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure, sat_sjZK_closure, sat_sk04_closure,
   sat_sk0o_closure}),
 (ckDC,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure, sat_sjZK_closure, sat_sk04_closure,
   sat_sk0o_closure}),
 (ckDD,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure, sat_sjZK_closure, sat_sk04_closure,
   sat_sk0o_closure}),
 (ckDF,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure, sat_sjZK_closure, sat_sk04_closure,
   sat_sk0o_closure}),
 (ckDG,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure, sat_sjZK_closure, sat_sk04_closure,
   sat_sk0o_closure}),
 (ckDI,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure, sat_sjZK_closure, sat_sk04_closure,
   sat_sk0o_closure}),
 (ckDN,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure, sat_sjZK_closure, sat_sk04_closure,
   sat_sk0o_closure}),
 (ckDO,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure, sat_sjZK_closure, sat_sk04_closure,
   sat_sk0o_closure}),
 (ckDR,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure, sat_sjZK_closure, sat_sk04_closure,
   sat_sk0o_closure}),
 (ckDS, {GHC.Word.$fEnumWord12_closure}),
 (ckDV,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure, sat_sjZK_closure, sat_sk04_closure,
   sat_sk0o_closure}),
 (ckDW,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure, sat_sjZK_closure, sat_sk04_closure,
   sat_sk0o_closure}),
 (ckDY,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure, sat_sjZK_closure, sat_sk04_closure,
   sat_sk0o_closure}),
 (ckDZ,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure, sat_sjZK_closure, sat_sk04_closure,
   sat_sk0o_closure}),
 (ckE0,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure, sat_sjZK_closure, sat_sk04_closure,
   sat_sk0o_closure}),
 (ckE1,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure, sat_sjZK_closure, sat_sk04_closure,
   sat_sk0o_closure}),
 (ckE8,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure, sat_sjZK_closure, sat_sk04_closure,
   sat_sk0o_closure}),
 (ckE9,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure, sat_sjZK_closure, sat_sk04_closure,
   sat_sk0o_closure}),
 (ckEb,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure, sat_sjZK_closure, sat_sk04_closure,
   sat_sk0o_closure}),
 (ckEc,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure, sat_sjZK_closure, sat_sk04_closure,
   sat_sk0o_closure}),
 (ckEi,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure, sat_sjZK_closure, sat_sk04_closure,
   sat_sk0o_closure}),
 (ckEk,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure, sat_sjZK_closure, sat_sk04_closure,
   sat_sk0o_closure}),
 (ckEl,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure, sat_sjZK_closure, sat_sk04_closure,
   sat_sk0o_closure}),
 (ckEr,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure, sat_sjZK_closure, sat_sk04_closure,
   sat_sk0o_closure}),
 (ckEs,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure, sat_sjZK_closure, sat_sk04_closure,
   sat_sk0o_closure}),
 (ckEt,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Word.$fEnumWord12_closure, sat_sjZK_closure, sat_sk04_closure,
   sat_sk0o_closure}),
 (ckED,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Real.$fIntegralWord_closure,
   GHC.Float.$w$cproperFraction_closure,
   GHC.Word.$fEnumWord12_closure, sat_sjZK_closure, sat_sk04_closure,
   sat_sk0o_closure}),
 (ckEF,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Real.$fIntegralWord_closure,
   GHC.Float.$w$cproperFraction_closure,
   GHC.Word.$fEnumWord12_closure, sat_sjZK_closure, sat_sk04_closure,
   sat_sk0o_closure}),
 (ckEG,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Real.$fIntegralWord_closure,
   GHC.Float.$w$cproperFraction_closure,
   GHC.Word.$fEnumWord12_closure, sat_sjZK_closure, sat_sk04_closure,
   sat_sk0o_closure}),
 (ckEM,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Real.$fIntegralWord_closure,
   GHC.Float.$w$cproperFraction_closure,
   GHC.Word.$fEnumWord12_closure, sat_sjZK_closure, sat_sk04_closure,
   sat_sk0o_closure}),
 (ckEN,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Real.$fIntegralWord_closure,
   GHC.Float.$w$cproperFraction_closure,
   GHC.Word.$fEnumWord12_closure, sat_sjZK_closure, sat_sk04_closure,
   sat_sk0o_closure}),
 (ckEO,
  {System.Random.PCG.Fast.Pure.$wbounded_closure,
   GHC.Real.$fIntegralWord_closure,
   GHC.Float.$w$cproperFraction_closure,
   GHC.Word.$fEnumWord12_closure, sat_sjZK_closure, sat_sk04_closure,
   sat_sk0o_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:53.610453 UTC

Main.$wa1_entry() //  [R6, R5, R4, R3, R2]
        { info_tbl: [(ckAC,
                      label: block_ckAC_info
                      rep:StackRep [False, False, True, True, True, False, False, True,
                                    True, False, True, True]),
                     (ckAE,
                      label: block_ckAE_info
                      rep:StackRep [False, False, False, True, True, True, False, False,
                                    True, True, False, True, True]),
                     (ckAL,
                      label: block_ckAL_info
                      rep:StackRep [False, False, True, True, True, False, False, True,
                                    True, False, True, True]),
                     (ckB7,
                      label: block_ckB7_info
                      rep:StackRep [False, False, True, True, True, False, False, True,
                                    True, False, True, True]),
                     (ckB9,
                      label: block_ckB9_info
                      rep:StackRep [False, False, False, True, True, True, False, False,
                                    True, True, False, True, True]),
                     (ckBg,
                      label: block_ckBg_info
                      rep:StackRep [False, False, True, True, True, False, False, True,
                                    True, False, True, True]),
                     (ckBp,
                      label: block_ckBp_info
                      rep:StackRep [False, True, True, True, True, True, False, True,
                                    False, False, True, True]),
                     (ckBs,
                      label: block_ckBs_info
                      rep:StackRep [False, True, True, True, True, False, False, True,
                                    False, False, True, True]),
                     (ckBE,
                      label: block_ckBE_info
                      rep:StackRep [False, True, True, True, True, False, False, True,
                                    False, False, True, True]),
                     (ckBG,
                      label: block_ckBG_info
                      rep:StackRep [False, True, True, True, True, False, False, True,
                                    False, False, True, True]),
                     (ckCL,
                      label: Main.$wa1_info
                      rep:HeapRep static {
                            Fun {arity: 13
                                 fun_type: ArgGen [False, False, True, True, True, False, False,
                                                   True, True, False, True, True]} }),
                     (ckD4,
                      label: block_ckD4_info
                      rep:StackRep [False, True, True, True, True, False, False, True,
                                    False, False, True, True]),
                     (ckD6,
                      label: block_ckD6_info
                      rep:StackRep [False, True, True, True, True, False, False, True,
                                    False, False, True, True]),
                     (ckDl,
                      label: block_ckDl_info
                      rep:StackRep [False, True, True, True, True, False, False, True,
                                    False, False, True, True]),
                     (ckDn,
                      label: block_ckDn_info
                      rep:StackRep [False, True, True, True, True, False, False, True,
                                    False, False, True, True]),
                     (ckDD,
                      label: block_ckDD_info
                      rep:StackRep [False, True, True, True, True, False, False, True,
                                    False, False, True, True]),
                     (ckDF,
                      label: block_ckDF_info
                      rep:StackRep [False, True, True, True, True, False, False, True,
                                    False, False, True, True]),
                     (ckDV,
                      label: block_ckDV_info
                      rep:StackRep [False, True, True, True, True, True, False, True,
                                    False, False, True, True]),
                     (ckDY,
                      label: block_ckDY_info
                      rep:StackRep [False, True, True, True, True, True, False, True,
                                    False, False, True, True]),
                     (ckE8,
                      label: block_ckE8_info
                      rep:StackRep [False, True, True, True, True, True, False, True,
                                    False, False, True, True]),
                     (ckEi,
                      label: block_ckEi_info
                      rep:StackRep [False, False, True, True, True, False, False, True,
                                    True, False, True, True]),
                     (ckEr,
                      label: block_ckEr_info
                      rep:StackRep [False, False, True, True, True, False, False, True,
                                    True, False, True, True]),
                     (ckED,
                      label: block_ckED_info
                      rep:StackRep [False, False, True, True, True, False, False, True,
                                    True, False, True, True]),
                     (ckEM,
                      label: block_ckEM_info
                      rep:StackRep [False, False, True, True, True, False, False, True,
                                    True, False, True, True])]
          stack_info: arg_space: 64 updfr_space: Just 8
        }
    {offset
      ckCL:
          _sjYH::I64 = R6;
          _sjYG::I64 = R5;
          _sjYF::I64 = R4;
          _sjYE::P64 = R3;
          _sjYD::P64 = R2;
          if ((Sp + -56) < SpLim) goto ckCM; else goto ckCN;
      ckCN:
          if (HpLim == 0) goto ckCM; else goto ckCO;
      ckCM:
          R1 = Main.$wa1_closure;
          P64[Sp - 40] = _sjYD::P64;
          P64[Sp - 32] = _sjYE::P64;
          I64[Sp - 24] = _sjYF::I64;
          I64[Sp - 16] = _sjYG::I64;
          I64[Sp - 8] = _sjYH::I64;
          Sp = Sp - 40;
          call (stg_gc_fun)(R1) args: 104, res: 0, upd: 8;
      ckCO:
          _sjYO::F64 = F64[Sp + 48];
          (_ckAs::F64) = call MO_UF_Conv W64(100000);
          I64[Sp - 48] = ckAC;
          D1 = %MO_F_Mul_W64(%MO_F_Quot_W64(_sjYO::F64, 100.0 :: W64),
                             _ckAs::F64);
          R2 = GHC.Real.$fIntegralWord_closure;
          P64[Sp - 40] = _sjYD::P64;
          P64[Sp - 32] = _sjYE::P64;
          I64[Sp - 24] = _sjYF::I64;
          I64[Sp - 16] = _sjYG::I64;
          I64[Sp - 8] = _sjYH::I64;
          Sp = Sp - 48;
          call GHC.Float.$w$cproperFraction_info(D1,
                                                 R2) returns to ckAC, args: 8, res: 8, upd: 8;
      ckAC:
          I64[Sp - 8] = ckAE;
          _sjYU::P64 = R1;
          R1 = R2;
          P64[Sp] = _sjYU::P64;
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto ckAE; else goto ckAF;
      ckAF:
          call (I64[R1])(R1) returns to ckAE, args: 8, res: 8, upd: 8;
      ckAE:
          _sjYU::P64 = P64[Sp + 8];
          if (%MO_F_Lt_W64(F64[R1 + 7],
                           0.0 :: W64)) goto ckEN; else goto ckEF;
      ckEN:
          I64[Sp + 8] = ckEM;
          R1 = _sjYU::P64;
          Sp = Sp + 8;
          if (R1 & 7 != 0) goto ckEM; else goto ckEO;
      ckEO:
          call (I64[R1])(R1) returns to ckEM, args: 8, res: 8, upd: 8;
      ckEM:
          _sjYO::F64 = F64[Sp + 96];
          _sjYZ::I64 = I64[R1 + 7] - 1;
          goto ckAM;
      ckEF:
          I64[Sp + 8] = ckED;
          R1 = _sjYU::P64;
          Sp = Sp + 8;
          if (R1 & 7 != 0) goto ckED; else goto ckEG;
      ckEG:
          call (I64[R1])(R1) returns to ckED, args: 8, res: 8, upd: 8;
      ckED:
          _sjYO::F64 = F64[Sp + 96];
          _sjYZ::I64 = I64[R1 + 7];
          goto ckAM;
      ckAM:
          if (HpLim == 0) goto ckCR; else goto ckCS;
      ckCR:
          I64[Sp] = ckAL;
          R1 = _sjYZ::I64;
          call stg_gc_unbx_r1(R1) returns to ckAL, args: 8, res: 8, upd: 8;
      ckAL:
          _sjYO::F64 = F64[Sp + 96];
          _sjYZ::I64 = R1;
          goto ckAM;
      ckCS:
          (_ckAO::F64) = call MO_UF_Conv W64(100000);
          I64[Sp] = ckB7;
          D1 = %MO_F_Mul_W64(%MO_F_Quot_W64(%MO_F_Add_W64(%MO_F_Quot_W64(%MO_F_Sub_W64(100.0 :: W64,
                                                                                       _sjYO::F64),
                                                                         2.0 :: W64),
                                                          _sjYO::F64),
                                            100.0 :: W64),
                             _ckAO::F64);
          R2 = GHC.Real.$fIntegralWord_closure;
          I64[Sp + 96] = _sjYZ::I64;
          call GHC.Float.$w$cproperFraction_info(D1,
                                                 R2) returns to ckB7, args: 8, res: 8, upd: 8;
      ckB7:
          I64[Sp - 8] = ckB9;
          _sjZ7::P64 = R1;
          R1 = R2;
          P64[Sp] = _sjZ7::P64;
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto ckB9; else goto ckBa;
      ckBa:
          call (I64[R1])(R1) returns to ckB9, args: 8, res: 8, upd: 8;
      ckB9:
          _sjZ7::P64 = P64[Sp + 8];
          if (%MO_F_Lt_W64(F64[R1 + 7],
                           0.0 :: W64)) goto ckEs; else goto ckEk;
      ckEs:
          I64[Sp + 8] = ckEr;
          R1 = _sjZ7::P64;
          Sp = Sp + 8;
          if (R1 & 7 != 0) goto ckEr; else goto ckEt;
      ckEt:
          call (I64[R1])(R1) returns to ckEr, args: 8, res: 8, upd: 8;
      ckEr:
          _sjYE::P64 = P64[Sp + 16];
          _sjYF::I64 = I64[Sp + 24];
          _sjYG::I64 = I64[Sp + 32];
          _sjYH::I64 = I64[Sp + 40];
          _sjYI::P64 = P64[Sp + 48];
          _sjYK::I64 = I64[Sp + 64];
          _sjYL::I64 = I64[Sp + 72];
          _sjYM::P64 = P64[Sp + 80];
          _sjZc::I64 = I64[R1 + 7] - 1;
          goto ckBh;
      ckEk:
          I64[Sp + 8] = ckEi;
          R1 = _sjZ7::P64;
          Sp = Sp + 8;
          if (R1 & 7 != 0) goto ckEi; else goto ckEl;
      ckEl:
          call (I64[R1])(R1) returns to ckEi, args: 8, res: 8, upd: 8;
      ckEi:
          _sjYE::P64 = P64[Sp + 16];
          _sjYF::I64 = I64[Sp + 24];
          _sjYG::I64 = I64[Sp + 32];
          _sjYH::I64 = I64[Sp + 40];
          _sjYI::P64 = P64[Sp + 48];
          _sjYK::I64 = I64[Sp + 64];
          _sjYL::I64 = I64[Sp + 72];
          _sjYM::P64 = P64[Sp + 80];
          _sjZc::I64 = I64[R1 + 7];
          goto ckBh;
      ckBh:
          Hp = Hp + 120;
          if (Hp > HpLim) goto ckCX; else goto ckCW;
      ckCX:
          HpAlloc = 120;
          I64[Sp] = ckBg;
          R1 = _sjZc::I64;
          call stg_gc_unbx_r1(R1) returns to ckBg, args: 8, res: 8, upd: 8;
      ckBg:
          _sjYE::P64 = P64[Sp + 16];
          _sjYF::I64 = I64[Sp + 24];
          _sjYG::I64 = I64[Sp + 32];
          _sjYH::I64 = I64[Sp + 40];
          _sjYI::P64 = P64[Sp + 48];
          _sjYK::I64 = I64[Sp + 64];
          _sjYL::I64 = I64[Sp + 72];
          _sjYM::P64 = P64[Sp + 80];
          _sjZc::I64 = R1;
          goto ckBh;
      ckCW:
          I64[Hp - 112] = Data.Vector.Primitive.Mutable.MVector_con_info;
          P64[Hp - 104] = _sjYM::P64;
          I64[Hp - 96] = _sjYK::I64;
          I64[Hp - 88] = _sjYL::I64;
          I64[Hp - 80] = GHC.Types.I#_con_info;
          I64[Hp - 72] = _sjYG::I64;
          I64[Hp - 64] = GHC.Types.I#_con_info;
          I64[Hp - 56] = _sjYF::I64;
          I64[Hp - 48] = GHC.Arr.Array_con_info;
          P64[Hp - 40] = Hp - 63;
          P64[Hp - 32] = Hp - 79;
          P64[Hp - 24] = _sjYI::P64;
          I64[Hp - 16] = _sjYH::I64;
          I64[Hp - 8] = Data.Primitive.ByteArray.MutableByteArray_con_info;
          P64[Hp] = _sjYE::P64;
          _ckBj::P64 = Hp - 111;
          _ckBm::P64 = Hp - 47;
          _B2::P64 = Hp - 7;
          goto ckE9;
      ckE9:
          if (HpLim == 0) goto ckEb; else goto ckEc;
      ckEb:
          I64[Sp] = ckE8;
          R1 = _B2::P64;
          I64[Sp + 64] = _sjZc::I64;
          P64[Sp + 72] = _ckBm::P64;
          P64[Sp + 80] = _ckBj::P64;
          call stg_gc_unpt_r1(R1) returns to ckE8, args: 8, res: 8, upd: 8;
      ckE8:
          _ckBj::P64 = P64[Sp + 80];
          _ckBm::P64 = P64[Sp + 72];
          _sjZc::I64 = I64[Sp + 64];
          _B2::P64 = R1;
          goto ckE9;
      ckEc:
          _sk0D::P64 = _B2::P64;
          goto ckDW;
      ckDW:
          if (HpLim == 0) goto ckDZ; else goto ckE0;
      ckDZ:
          I64[Sp] = ckDV;
          R1 = _sk0D::P64;
          I64[Sp + 64] = _sjZc::I64;
          P64[Sp + 72] = _ckBm::P64;
          P64[Sp + 80] = _ckBj::P64;
          call stg_gc_unpt_r1(R1) returns to ckDV, args: 8, res: 8, upd: 8;
      ckDV:
          _ckBj::P64 = P64[Sp + 80];
          _ckBm::P64 = P64[Sp + 72];
          _sjZc::I64 = I64[Sp + 64];
          _sk0D::P64 = R1;
          goto ckDW;
      ckE0:
          I64[Sp] = ckDY;
          R1 = _sk0D::P64;
          I64[Sp + 64] = _sjZc::I64;
          P64[Sp + 72] = _ckBm::P64;
          P64[Sp + 80] = _ckBj::P64;
          if (R1 & 7 != 0) goto ckDY; else goto ckE1;
      ckE1:
          call (I64[R1])(R1) returns to ckDY, args: 8, res: 8, upd: 8;
      ckDY:
          _sjZi::P64 = P64[R1 + 7];
          goto ckBq;
      ckBq:
          if (HpLim == 0) goto ckCY; else goto ckCZ;
      ckCY:
          I64[Sp] = ckBp;
          R1 = _sjZi::P64;
          call stg_gc_unpt_r1(R1) returns to ckBp, args: 8, res: 8, upd: 8;
      ckBp:
          _sjZi::P64 = R1;
          goto ckBq;
      ckCZ:
          I64[Sp] = ckBs;
          R2 = I64[_sjZi::P64 + 16];
          P64[Sp + 48] = _sjZi::P64;
          call $wgo1_rjVd_info(R2) returns to ckBs, args: 8, res: 8, upd: 8;
      ckBs:
          _sjZi::P64 = P64[Sp + 48];
          I64[_sjZi::P64 + 16] = R1;
          I64[Sp] = ckBE;
          R3 = I64[_sjZi::P64 + 16];
          _sjZp::I64 = R2;
          R2 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[Sp + 88] - 2));
          I64[Sp + 40] = _sjZp::I64;
          call System.Random.PCG.Fast.Pure.$wbounded_info(R3,
                                                          R2) returns to ckBE, args: 8, res: 8, upd: 8;
      ckBE:
          _ckBj::P64 = P64[Sp + 80];
          _ckBm::P64 = P64[Sp + 72];
          _sjYJ::P64 = P64[Sp + 56];
          _sjYZ::I64 = I64[Sp + 96];
          _sjZc::I64 = I64[Sp + 64];
          _sjZi::P64 = P64[Sp + 48];
          _sjZp::I64 = I64[Sp + 40];
          _sjZy::I64 = R2;
          _sjZx::I64 = R1;
          goto ckBF;
      ckBF:
          Hp = Hp + 40;
          if (Hp > HpLim) goto ckD3; else goto ckD2;
      ckD3:
          HpAlloc = 40;
          I64[Sp] = ckBG;
          I64[Sp + 24] = _sjZy::I64;
          I64[Sp + 32] = _sjZx::I64;
          call stg_gc_noregs() returns to ckBG, args: 8, res: 8, upd: 8;
      ckBG:
          _ckBj::P64 = P64[Sp + 80];
          _ckBm::P64 = P64[Sp + 72];
          _sjYJ::P64 = P64[Sp + 56];
          _sjYZ::I64 = I64[Sp + 96];
          _sjZc::I64 = I64[Sp + 64];
          _sjZi::P64 = P64[Sp + 48];
          _sjZp::I64 = I64[Sp + 40];
          _sjZx::I64 = I64[Sp + 32];
          _sjZy::I64 = I64[Sp + 24];
          goto ckBF;
      ckD2:
          I64[_sjZi::P64 + 16] = _sjZx::I64;
          if (_sjZp::I64 <= _sjYZ::I64) goto ckDG; else goto ckDC;
      ckDG:
          I64[Hp - 32] = sat_sk0o_info;
          P64[Hp - 24] = _sjYJ::P64;
          P64[Hp - 16] = _ckBm::P64;
          I64[Hp - 8] = _sjZy::I64;
          _ckCu::P64 = Hp - 31;
          Hp = Hp - 8;
          I64[Sp] = ckDD;
          R1 = _ckCu::P64;
          call stg_norec_atomically#(R1) returns to ckDD, args: 8, res: 8, upd: 8;
      ckDD:
          _sk0u::P64 = P64[P64[Sp + 8] + 8];
          I64[Sp] = ckDF;
          R1 = _sk0u::P64;
          if (R1 & 7 != 0) goto ckDF; else goto ckDI;
      ckDI:
          call (I64[R1])(R1) returns to ckDF, args: 8, res: 8, upd: 8;
      ckDF:
          Hp = Hp + 16;
          if (Hp > HpLim) goto ckDO; else goto ckDN;
      ckDO:
          HpAlloc = 16;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to ckDF, args: 8, res: 8, upd: 8;
      ckDN:
          _sk0x::I64 = I64[R1 + 7];
          if (_sk0x::I64 != 18446744073709551615) goto ckDR; else goto ckDS;
      ckDR:
          I64[Hp - 8] = GHC.Word.W64#_con_info;
          I64[Hp] = _sk0x::I64 + 1;
          _sjYD::P64 = P64[Sp + 8];
          P64[_sjYD::P64 + 8] = Hp - 7;
          _sjZi::P64 = P64[Sp + 48];
          call "ccall" arg hints:  [PtrHint,
                                    PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sjYD::P64);
          goto ckBq;
      ckDC:
          if (_sjZp::I64 <= _sjZc::I64) goto ckDo; else goto ckD8;
      ckDo:
          I64[Hp - 32] = sat_sk04_info;
          P64[Hp - 24] = _sjYJ::P64;
          P64[Hp - 16] = _ckBj::P64;
          P64[Hp - 8] = _ckBm::P64;
          I64[Hp] = _sjZy::I64;
          I64[Sp] = ckDl;
          R1 = Hp - 31;
          call stg_norec_atomically#(R1) returns to ckDl, args: 8, res: 8, upd: 8;
      ckDl:
          _sk0a::P64 = P64[P64[Sp + 8] + 8];
          I64[Sp] = ckDn;
          R1 = _sk0a::P64;
          if (R1 & 7 != 0) goto ckDn; else goto ckDq;
      ckDq:
          call (I64[R1])(R1) returns to ckDn, args: 8, res: 8, upd: 8;
      ckDn:
          Hp = Hp + 16;
          if (Hp > HpLim) goto ckDw; else goto ckDv;
      ckDw:
          HpAlloc = 16;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to ckDn, args: 8, res: 8, upd: 8;
      ckDv:
          _sk0d::I64 = I64[R1 + 7];
          if (_sk0d::I64 != 18446744073709551615) goto ckDz; else goto ckDS;
      ckDz:
          I64[Hp - 8] = GHC.Word.W64#_con_info;
          I64[Hp] = _sk0d::I64 + 1;
          _sjYD::P64 = P64[Sp + 8];
          P64[_sjYD::P64 + 8] = Hp - 7;
          _sjZi::P64 = P64[Sp + 48];
          call "ccall" arg hints:  [PtrHint,
                                    PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sjYD::P64);
          goto ckBq;
      ckD8:
          I64[Hp - 32] = sat_sjZK_info;
          P64[Hp - 24] = _sjYJ::P64;
          P64[Hp - 16] = _ckBm::P64;
          I64[Hp - 8] = _sjZy::I64;
          _ckBU::P64 = Hp - 31;
          Hp = Hp - 8;
          I64[Sp] = ckD4;
          R1 = _ckBU::P64;
          call stg_norec_atomically#(R1) returns to ckD4, args: 8, res: 8, upd: 8;
      ckD4:
          _sjZQ::P64 = P64[P64[Sp + 8] + 8];
          I64[Sp] = ckD6;
          R1 = _sjZQ::P64;
          if (R1 & 7 != 0) goto ckD6; else goto ckDa;
      ckDa:
          call (I64[R1])(R1) returns to ckD6, args: 8, res: 8, upd: 8;
      ckD6:
          Hp = Hp + 16;
          if (Hp > HpLim) goto ckDg; else goto ckDf;
      ckDg:
          HpAlloc = 16;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to ckD6, args: 8, res: 8, upd: 8;
      ckDf:
          _sjZT::I64 = I64[R1 + 7];
          if (_sjZT::I64 != 18446744073709551615) goto ckDj; else goto ckDS;
      ckDj:
          I64[Hp - 8] = GHC.Word.W64#_con_info;
          I64[Hp] = _sjZT::I64 + 1;
          _sjYD::P64 = P64[Sp + 8];
          P64[_sjYD::P64 + 8] = Hp - 7;
          _sjZi::P64 = P64[Sp + 48];
          call "ccall" arg hints:  [PtrHint,
                                    PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sjYD::P64);
          goto ckBq;
      ckDS:
          Hp = Hp - 16;
          R1 = GHC.Word.$fEnumWord12_closure;
          Sp = Sp + 104;
          call (I64[R1])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:53.63517 UTC

Main.$wa1_entry() //  [R6, R5, R4, R3, R2]
        { info_tbl: [(ckAC,
                      label: block_ckAC_info
                      rep:StackRep [False, False, True, True, True, False, False, True,
                                    True, False, True, True]),
                     (ckAE,
                      label: block_ckAE_info
                      rep:StackRep [False, False, False, True, True, True, False, False,
                                    True, True, False, True, True]),
                     (ckAL,
                      label: block_ckAL_info
                      rep:StackRep [False, False, True, True, True, False, False, True,
                                    True, False, True, True]),
                     (ckB7,
                      label: block_ckB7_info
                      rep:StackRep [False, False, True, True, True, False, False, True,
                                    True, False, True, True]),
                     (ckB9,
                      label: block_ckB9_info
                      rep:StackRep [False, False, False, True, True, True, False, False,
                                    True, True, False, True, True]),
                     (ckBg,
                      label: block_ckBg_info
                      rep:StackRep [False, False, True, True, True, False, False, True,
                                    True, False, True, True]),
                     (ckBp,
                      label: block_ckBp_info
                      rep:StackRep [False, True, True, True, True, True, False, True,
                                    False, False, True, True]),
                     (ckBs,
                      label: block_ckBs_info
                      rep:StackRep [False, True, True, True, True, False, False, True,
                                    False, False, True, True]),
                     (ckBE,
                      label: block_ckBE_info
                      rep:StackRep [False, True, True, True, True, False, False, True,
                                    False, False, True, True]),
                     (ckBG,
                      label: block_ckBG_info
                      rep:StackRep [False, True, True, True, True, False, False, True,
                                    False, False, True, True]),
                     (ckCL,
                      label: Main.$wa1_info
                      rep:HeapRep static {
                            Fun {arity: 13
                                 fun_type: ArgGen [False, False, True, True, True, False, False,
                                                   True, True, False, True, True]} }),
                     (ckD4,
                      label: block_ckD4_info
                      rep:StackRep [False, True, True, True, True, False, False, True,
                                    False, False, True, True]),
                     (ckD6,
                      label: block_ckD6_info
                      rep:StackRep [False, True, True, True, True, False, False, True,
                                    False, False, True, True]),
                     (ckDl,
                      label: block_ckDl_info
                      rep:StackRep [False, True, True, True, True, False, False, True,
                                    False, False, True, True]),
                     (ckDn,
                      label: block_ckDn_info
                      rep:StackRep [False, True, True, True, True, False, False, True,
                                    False, False, True, True]),
                     (ckDD,
                      label: block_ckDD_info
                      rep:StackRep [False, True, True, True, True, False, False, True,
                                    False, False, True, True]),
                     (ckDF,
                      label: block_ckDF_info
                      rep:StackRep [False, True, True, True, True, False, False, True,
                                    False, False, True, True]),
                     (ckDV,
                      label: block_ckDV_info
                      rep:StackRep [False, True, True, True, True, True, False, True,
                                    False, False, True, True]),
                     (ckDY,
                      label: block_ckDY_info
                      rep:StackRep [False, True, True, True, True, True, False, True,
                                    False, False, True, True]),
                     (ckE8,
                      label: block_ckE8_info
                      rep:StackRep [False, True, True, True, True, True, False, True,
                                    False, False, True, True]),
                     (ckEi,
                      label: block_ckEi_info
                      rep:StackRep [False, False, True, True, True, False, False, True,
                                    True, False, True, True]),
                     (ckEr,
                      label: block_ckEr_info
                      rep:StackRep [False, False, True, True, True, False, False, True,
                                    True, False, True, True]),
                     (ckED,
                      label: block_ckED_info
                      rep:StackRep [False, False, True, True, True, False, False, True,
                                    True, False, True, True]),
                     (ckEM,
                      label: block_ckEM_info
                      rep:StackRep [False, False, True, True, True, False, False, True,
                                    True, False, True, True])]
          stack_info: arg_space: 64 updfr_space: Just 8
        }
    {offset
      ckCL:
          _sjYH::I64 = R6;
          _sjYG::I64 = R5;
          _sjYF::I64 = R4;
          _sjYE::P64 = R3;
          _sjYD::P64 = R2;
          if ((Sp + -56) < SpLim) goto ckCM; else goto ckCN;
      ckCN:
          if (HpLim == 0) goto ckCM; else goto ckCO;
      ckCM:
          R1 = Main.$wa1_closure;
          P64[Sp - 40] = _sjYD::P64;
          P64[Sp - 32] = _sjYE::P64;
          I64[Sp - 24] = _sjYF::I64;
          I64[Sp - 16] = _sjYG::I64;
          I64[Sp - 8] = _sjYH::I64;
          Sp = Sp - 40;
          call (stg_gc_fun)(R1) args: 104, res: 0, upd: 8;
      ckCO:
          _sjYO::F64 = F64[Sp + 48];
          (_ckAs::F64) = call MO_UF_Conv W64(100000);
          I64[Sp - 48] = ckAC;
          D1 = %MO_F_Mul_W64(%MO_F_Quot_W64(_sjYO::F64, 100.0 :: W64),
                             _ckAs::F64);
          R2 = GHC.Real.$fIntegralWord_closure;
          P64[Sp - 40] = _sjYD::P64;
          P64[Sp - 32] = _sjYE::P64;
          I64[Sp - 24] = _sjYF::I64;
          I64[Sp - 16] = _sjYG::I64;
          I64[Sp - 8] = _sjYH::I64;
          Sp = Sp - 48;
          call GHC.Float.$w$cproperFraction_info(D1,
                                                 R2) returns to ckAC, args: 8, res: 8, upd: 8;
      ckAC:
          I64[Sp - 8] = ckAE;
          _sjYU::P64 = R1;
          R1 = R2;
          P64[Sp] = _sjYU::P64;
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto ckAE; else goto ckAF;
      ckAF:
          call (I64[R1])(R1) returns to ckAE, args: 8, res: 8, upd: 8;
      ckAE:
          _sjYU::P64 = P64[Sp + 8];
          if (%MO_F_Lt_W64(F64[R1 + 7],
                           0.0 :: W64)) goto ckEN; else goto ckEF;
      ckEN:
          I64[Sp + 8] = ckEM;
          R1 = _sjYU::P64;
          Sp = Sp + 8;
          if (R1 & 7 != 0) goto ckEM; else goto ckEO;
      ckEO:
          call (I64[R1])(R1) returns to ckEM, args: 8, res: 8, upd: 8;
      ckEM:
          _sjYO::F64 = F64[Sp + 96];
          _sjYZ::I64 = I64[R1 + 7] - 1;
          goto ckAM;
      ckEF:
          I64[Sp + 8] = ckED;
          R1 = _sjYU::P64;
          Sp = Sp + 8;
          if (R1 & 7 != 0) goto ckED; else goto ckEG;
      ckEG:
          call (I64[R1])(R1) returns to ckED, args: 8, res: 8, upd: 8;
      ckED:
          _sjYO::F64 = F64[Sp + 96];
          _sjYZ::I64 = I64[R1 + 7];
          goto ckAM;
      ckAM:
          if (HpLim == 0) goto ckCR; else goto ckCS;
      ckCR:
          I64[Sp] = ckAL;
          R1 = _sjYZ::I64;
          call stg_gc_unbx_r1(R1) returns to ckAL, args: 8, res: 8, upd: 8;
      ckAL:
          _sjYO::F64 = F64[Sp + 96];
          _sjYZ::I64 = R1;
          goto ckAM;
      ckCS:
          (_ckAO::F64) = call MO_UF_Conv W64(100000);
          I64[Sp] = ckB7;
          D1 = %MO_F_Mul_W64(%MO_F_Quot_W64(%MO_F_Add_W64(%MO_F_Quot_W64(%MO_F_Sub_W64(100.0 :: W64,
                                                                                       _sjYO::F64),
                                                                         2.0 :: W64),
                                                          _sjYO::F64),
                                            100.0 :: W64),
                             _ckAO::F64);
          R2 = GHC.Real.$fIntegralWord_closure;
          I64[Sp + 96] = _sjYZ::I64;
          call GHC.Float.$w$cproperFraction_info(D1,
                                                 R2) returns to ckB7, args: 8, res: 8, upd: 8;
      ckB7:
          I64[Sp - 8] = ckB9;
          _sjZ7::P64 = R1;
          R1 = R2;
          P64[Sp] = _sjZ7::P64;
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto ckB9; else goto ckBa;
      ckBa:
          call (I64[R1])(R1) returns to ckB9, args: 8, res: 8, upd: 8;
      ckB9:
          _sjZ7::P64 = P64[Sp + 8];
          if (%MO_F_Lt_W64(F64[R1 + 7],
                           0.0 :: W64)) goto ckEs; else goto ckEk;
      ckEs:
          I64[Sp + 8] = ckEr;
          R1 = _sjZ7::P64;
          Sp = Sp + 8;
          if (R1 & 7 != 0) goto ckEr; else goto ckEt;
      ckEt:
          call (I64[R1])(R1) returns to ckEr, args: 8, res: 8, upd: 8;
      ckEr:
          _sjYE::P64 = P64[Sp + 16];
          _sjYF::I64 = I64[Sp + 24];
          _sjYG::I64 = I64[Sp + 32];
          _sjYH::I64 = I64[Sp + 40];
          _sjYI::P64 = P64[Sp + 48];
          _sjYK::I64 = I64[Sp + 64];
          _sjYL::I64 = I64[Sp + 72];
          _sjYM::P64 = P64[Sp + 80];
          _sjZc::I64 = I64[R1 + 7] - 1;
          goto ckBh;
      ckEk:
          I64[Sp + 8] = ckEi;
          R1 = _sjZ7::P64;
          Sp = Sp + 8;
          if (R1 & 7 != 0) goto ckEi; else goto ckEl;
      ckEl:
          call (I64[R1])(R1) returns to ckEi, args: 8, res: 8, upd: 8;
      ckEi:
          _sjYE::P64 = P64[Sp + 16];
          _sjYF::I64 = I64[Sp + 24];
          _sjYG::I64 = I64[Sp + 32];
          _sjYH::I64 = I64[Sp + 40];
          _sjYI::P64 = P64[Sp + 48];
          _sjYK::I64 = I64[Sp + 64];
          _sjYL::I64 = I64[Sp + 72];
          _sjYM::P64 = P64[Sp + 80];
          _sjZc::I64 = I64[R1 + 7];
          goto ckBh;
      ckBh:
          Hp = Hp + 120;
          if (Hp > HpLim) goto ckCX; else goto ckCW;
      ckCX:
          HpAlloc = 120;
          I64[Sp] = ckBg;
          R1 = _sjZc::I64;
          call stg_gc_unbx_r1(R1) returns to ckBg, args: 8, res: 8, upd: 8;
      ckBg:
          _sjYE::P64 = P64[Sp + 16];
          _sjYF::I64 = I64[Sp + 24];
          _sjYG::I64 = I64[Sp + 32];
          _sjYH::I64 = I64[Sp + 40];
          _sjYI::P64 = P64[Sp + 48];
          _sjYK::I64 = I64[Sp + 64];
          _sjYL::I64 = I64[Sp + 72];
          _sjYM::P64 = P64[Sp + 80];
          _sjZc::I64 = R1;
          goto ckBh;
      ckCW:
          I64[Hp - 112] = Data.Vector.Primitive.Mutable.MVector_con_info;
          P64[Hp - 104] = _sjYM::P64;
          I64[Hp - 96] = _sjYK::I64;
          I64[Hp - 88] = _sjYL::I64;
          I64[Hp - 80] = GHC.Types.I#_con_info;
          I64[Hp - 72] = _sjYG::I64;
          I64[Hp - 64] = GHC.Types.I#_con_info;
          I64[Hp - 56] = _sjYF::I64;
          I64[Hp - 48] = GHC.Arr.Array_con_info;
          P64[Hp - 40] = Hp - 63;
          P64[Hp - 32] = Hp - 79;
          P64[Hp - 24] = _sjYI::P64;
          I64[Hp - 16] = _sjYH::I64;
          I64[Hp - 8] = Data.Primitive.ByteArray.MutableByteArray_con_info;
          P64[Hp] = _sjYE::P64;
          _ckBj::P64 = Hp - 111;
          _ckBm::P64 = Hp - 47;
          _B2::P64 = Hp - 7;
          goto ckE9;
      ckE9:
          if (HpLim == 0) goto ckEb; else goto ckEc;
      ckEb:
          I64[Sp] = ckE8;
          R1 = _B2::P64;
          I64[Sp + 64] = _sjZc::I64;
          P64[Sp + 72] = _ckBm::P64;
          P64[Sp + 80] = _ckBj::P64;
          call stg_gc_unpt_r1(R1) returns to ckE8, args: 8, res: 8, upd: 8;
      ckE8:
          _ckBj::P64 = P64[Sp + 80];
          _ckBm::P64 = P64[Sp + 72];
          _sjZc::I64 = I64[Sp + 64];
          _B2::P64 = R1;
          goto ckE9;
      ckEc:
          _sk0D::P64 = _B2::P64;
          goto ckDW;
      ckDW:
          if (HpLim == 0) goto ckDZ; else goto ckE0;
      ckDZ:
          I64[Sp] = ckDV;
          R1 = _sk0D::P64;
          I64[Sp + 64] = _sjZc::I64;
          P64[Sp + 72] = _ckBm::P64;
          P64[Sp + 80] = _ckBj::P64;
          call stg_gc_unpt_r1(R1) returns to ckDV, args: 8, res: 8, upd: 8;
      ckDV:
          _ckBj::P64 = P64[Sp + 80];
          _ckBm::P64 = P64[Sp + 72];
          _sjZc::I64 = I64[Sp + 64];
          _sk0D::P64 = R1;
          goto ckDW;
      ckE0:
          I64[Sp] = ckDY;
          R1 = _sk0D::P64;
          I64[Sp + 64] = _sjZc::I64;
          P64[Sp + 72] = _ckBm::P64;
          P64[Sp + 80] = _ckBj::P64;
          if (R1 & 7 != 0) goto ckDY; else goto ckE1;
      ckE1:
          call (I64[R1])(R1) returns to ckDY, args: 8, res: 8, upd: 8;
      ckDY:
          _sjZi::P64 = P64[R1 + 7];
          goto ckBq;
      ckBq:
          if (HpLim == 0) goto ckCY; else goto ckCZ;
      ckCY:
          I64[Sp] = ckBp;
          R1 = _sjZi::P64;
          call stg_gc_unpt_r1(R1) returns to ckBp, args: 8, res: 8, upd: 8;
      ckBp:
          _sjZi::P64 = R1;
          goto ckBq;
      ckCZ:
          I64[Sp] = ckBs;
          R2 = I64[_sjZi::P64 + 16];
          P64[Sp + 48] = _sjZi::P64;
          call $wgo1_rjVd_info(R2) returns to ckBs, args: 8, res: 8, upd: 8;
      ckBs:
          _sjZi::P64 = P64[Sp + 48];
          I64[_sjZi::P64 + 16] = R1;
          I64[Sp] = ckBE;
          R3 = I64[_sjZi::P64 + 16];
          _sjZp::I64 = R2;
          R2 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[Sp + 88] - 2));
          I64[Sp + 40] = _sjZp::I64;
          call System.Random.PCG.Fast.Pure.$wbounded_info(R3,
                                                          R2) returns to ckBE, args: 8, res: 8, upd: 8;
      ckBE:
          _ckBj::P64 = P64[Sp + 80];
          _ckBm::P64 = P64[Sp + 72];
          _sjYJ::P64 = P64[Sp + 56];
          _sjYZ::I64 = I64[Sp + 96];
          _sjZc::I64 = I64[Sp + 64];
          _sjZi::P64 = P64[Sp + 48];
          _sjZp::I64 = I64[Sp + 40];
          _sjZy::I64 = R2;
          _sjZx::I64 = R1;
          goto ckBF;
      ckBF:
          Hp = Hp + 40;
          if (Hp > HpLim) goto ckD3; else goto ckD2;
      ckD3:
          HpAlloc = 40;
          I64[Sp] = ckBG;
          I64[Sp + 24] = _sjZy::I64;
          I64[Sp + 32] = _sjZx::I64;
          call stg_gc_noregs() returns to ckBG, args: 8, res: 8, upd: 8;
      ckBG:
          _ckBj::P64 = P64[Sp + 80];
          _ckBm::P64 = P64[Sp + 72];
          _sjYJ::P64 = P64[Sp + 56];
          _sjYZ::I64 = I64[Sp + 96];
          _sjZc::I64 = I64[Sp + 64];
          _sjZi::P64 = P64[Sp + 48];
          _sjZp::I64 = I64[Sp + 40];
          _sjZx::I64 = I64[Sp + 32];
          _sjZy::I64 = I64[Sp + 24];
          goto ckBF;
      ckD2:
          I64[_sjZi::P64 + 16] = _sjZx::I64;
          if (_sjZp::I64 <= _sjYZ::I64) goto ckDG; else goto ckDC;
      ckDG:
          I64[Hp - 32] = sat_sk0o_info;
          P64[Hp - 24] = _sjYJ::P64;
          P64[Hp - 16] = _ckBm::P64;
          I64[Hp - 8] = _sjZy::I64;
          _ckCu::P64 = Hp - 31;
          Hp = Hp - 8;
          I64[Sp] = ckDD;
          R1 = _ckCu::P64;
          call stg_norec_atomically#(R1) returns to ckDD, args: 8, res: 8, upd: 8;
      ckDD:
          _sk0u::P64 = P64[P64[Sp + 8] + 8];
          I64[Sp] = ckDF;
          R1 = _sk0u::P64;
          if (R1 & 7 != 0) goto ckDF; else goto ckDI;
      ckDI:
          call (I64[R1])(R1) returns to ckDF, args: 8, res: 8, upd: 8;
      ckDF:
          Hp = Hp + 16;
          if (Hp > HpLim) goto ckDO; else goto ckDN;
      ckDO:
          HpAlloc = 16;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to ckDF, args: 8, res: 8, upd: 8;
      ckDN:
          _sk0x::I64 = I64[R1 + 7];
          if (_sk0x::I64 == 18446744073709551615) goto ckDS; else goto ckDR;
      ckDR:
          I64[Hp - 8] = GHC.Word.W64#_con_info;
          I64[Hp] = _sk0x::I64 + 1;
          _sjYD::P64 = P64[Sp + 8];
          P64[_sjYD::P64 + 8] = Hp - 7;
          _sjZi::P64 = P64[Sp + 48];
          call "ccall" arg hints:  [PtrHint,
                                    PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sjYD::P64);
          goto ckBq;
      ckDC:
          if (_sjZp::I64 <= _sjZc::I64) goto ckDo; else goto ckD8;
      ckDo:
          I64[Hp - 32] = sat_sk04_info;
          P64[Hp - 24] = _sjYJ::P64;
          P64[Hp - 16] = _ckBj::P64;
          P64[Hp - 8] = _ckBm::P64;
          I64[Hp] = _sjZy::I64;
          I64[Sp] = ckDl;
          R1 = Hp - 31;
          call stg_norec_atomically#(R1) returns to ckDl, args: 8, res: 8, upd: 8;
      ckDl:
          _sk0a::P64 = P64[P64[Sp + 8] + 8];
          I64[Sp] = ckDn;
          R1 = _sk0a::P64;
          if (R1 & 7 != 0) goto ckDn; else goto ckDq;
      ckDq:
          call (I64[R1])(R1) returns to ckDn, args: 8, res: 8, upd: 8;
      ckDn:
          Hp = Hp + 16;
          if (Hp > HpLim) goto ckDw; else goto ckDv;
      ckDw:
          HpAlloc = 16;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to ckDn, args: 8, res: 8, upd: 8;
      ckDv:
          _sk0d::I64 = I64[R1 + 7];
          if (_sk0d::I64 == 18446744073709551615) goto ckDS; else goto ckDz;
      ckDz:
          I64[Hp - 8] = GHC.Word.W64#_con_info;
          I64[Hp] = _sk0d::I64 + 1;
          _sjYD::P64 = P64[Sp + 8];
          P64[_sjYD::P64 + 8] = Hp - 7;
          _sjZi::P64 = P64[Sp + 48];
          call "ccall" arg hints:  [PtrHint,
                                    PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sjYD::P64);
          goto ckBq;
      ckD8:
          I64[Hp - 32] = sat_sjZK_info;
          P64[Hp - 24] = _sjYJ::P64;
          P64[Hp - 16] = _ckBm::P64;
          I64[Hp - 8] = _sjZy::I64;
          _ckBU::P64 = Hp - 31;
          Hp = Hp - 8;
          I64[Sp] = ckD4;
          R1 = _ckBU::P64;
          call stg_norec_atomically#(R1) returns to ckD4, args: 8, res: 8, upd: 8;
      ckD4:
          _sjZQ::P64 = P64[P64[Sp + 8] + 8];
          I64[Sp] = ckD6;
          R1 = _sjZQ::P64;
          if (R1 & 7 != 0) goto ckD6; else goto ckDa;
      ckDa:
          call (I64[R1])(R1) returns to ckD6, args: 8, res: 8, upd: 8;
      ckD6:
          Hp = Hp + 16;
          if (Hp > HpLim) goto ckDg; else goto ckDf;
      ckDg:
          HpAlloc = 16;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to ckD6, args: 8, res: 8, upd: 8;
      ckDf:
          _sjZT::I64 = I64[R1 + 7];
          if (_sjZT::I64 == 18446744073709551615) goto ckDS; else goto ckDj;
      ckDS:
          Hp = Hp - 16;
          R1 = GHC.Word.$fEnumWord12_closure;
          Sp = Sp + 104;
          call (I64[R1])(R1) args: 8, res: 0, upd: 8;
      ckDj:
          I64[Hp - 8] = GHC.Word.W64#_con_info;
          I64[Hp] = _sjZT::I64 + 1;
          _sjYD::P64 = P64[Sp + 8];
          P64[_sjYD::P64 + 8] = Hp - 7;
          _sjZi::P64 = P64[Sp + 48];
          call "ccall" arg hints:  [PtrHint,
                                    PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sjYD::P64);
          goto ckBq;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:53.660557 UTC

[section "data" {
     Main.$wa1_closure:
         const Main.$wa1_info;
         const 0;
 },
 Main.$wa1_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 104 updfr_space: Just 8
         }
     {offset
       ckAo:
           R6 = I64[Sp + 32];
           R5 = I64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Main.$wa1_info(R6,
                               R5,
                               R4,
                               R3,
                               R2,
                               R1) args: 64, res: 0, upd: 8;
     }
 },
 sat_sjZK_entry() //  [R1]
         { info_tbl: [(ckC1,
                       label: sat_sjZK_info
                       rep:HeapRep 2 ptrs 1 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} }),
                      (ckC4,
                       label: block_ckC4_info
                       rep:StackRep [])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckC1:
           _sjZK::P64 = R1;
           if ((Sp + -8) < SpLim) goto ckC5; else goto ckC6;
       ckC6:
           Hp = Hp + 16;
           if (Hp > HpLim) goto ckC8; else goto ckC7;
       ckC8:
           HpAlloc = 16;
           goto ckC5;
       ckC5:
           R1 = _sjZK::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ckC7:
           _sjYJ::P64 = P64[_sjZK::P64 + 7];
           _sjZg::P64 = P64[_sjZK::P64 + 15];
           _sjZF::I64 = I64[_sjZK::P64 + 23] + 1;
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _sjZF::I64;
           I64[Sp - 8] = ckC4;
           R5 = Hp - 7;
           R4 = _sjYJ::P64;
           R3 = _sjZg::P64;
           R2 = GHC.Classes.$fOrdWord_closure;
           Sp = Sp - 8;
           call SkipList.$wa2_info(R5,
                                   R4,
                                   R3,
                                   R2) returns to ckC4, args: 8, res: 8, upd: 8;
       ckC4:
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sk04_entry() //  [R1]
         { info_tbl: [(ckCj,
                       label: sat_sk04_info
                       rep:HeapRep 3 ptrs 1 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} }),
                      (ckCm,
                       label: block_ckCm_info
                       rep:StackRep [])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckCj:
           _sk04::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckCn; else goto ckCo;
       ckCo:
           Hp = Hp + 16;
           if (Hp > HpLim) goto ckCq; else goto ckCp;
       ckCq:
           HpAlloc = 16;
           goto ckCn;
       ckCn:
           R1 = _sk04::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ckCp:
           _sjYJ::P64 = P64[_sk04::P64 + 7];
           _sjZd::P64 = P64[_sk04::P64 + 15];
           _sjZg::P64 = P64[_sk04::P64 + 23];
           _sjZZ::I64 = I64[_sk04::P64 + 31] + 1;
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _sjZZ::I64;
           I64[Sp - 8] = ckCm;
           R6 = Hp - 7;
           R5 = _sjZd::P64;
           R4 = _sjYJ::P64;
           R3 = _sjZg::P64;
           R2 = GHC.Classes.$fOrdWord_closure;
           P64[Sp - 16] = GHC.Tuple.()_closure+1;
           Sp = Sp - 16;
           call SkipList.$wa4_info(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) returns to ckCm, args: 16, res: 8, upd: 8;
       ckCm:
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sk0o_entry() //  [R1]
         { info_tbl: [(ckCB,
                       label: sat_sk0o_info
                       rep:HeapRep 2 ptrs 1 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} }),
                      (ckCE,
                       label: block_ckCE_info
                       rep:StackRep [])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckCB:
           _sk0o::P64 = R1;
           if ((Sp + -8) < SpLim) goto ckCF; else goto ckCG;
       ckCG:
           Hp = Hp + 16;
           if (Hp > HpLim) goto ckCI; else goto ckCH;
       ckCI:
           HpAlloc = 16;
           goto ckCF;
       ckCF:
           R1 = _sk0o::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ckCH:
           _sjYJ::P64 = P64[_sk0o::P64 + 7];
           _sjZg::P64 = P64[_sk0o::P64 + 15];
           _sk0j::I64 = I64[_sk0o::P64 + 23] + 1;
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _sk0j::I64;
           I64[Sp - 8] = ckCE;
           R5 = Hp - 7;
           R4 = _sjYJ::P64;
           R3 = _sjZg::P64;
           R2 = GHC.Classes.$fOrdWord_closure;
           Sp = Sp - 8;
           call SkipList.$wa3_info(R5,
                                   R4,
                                   R3,
                                   R2) returns to ckCE, args: 8, res: 8, upd: 8;
       ckCE:
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section "relreadonly" {
     ukFk_srtd:
         const Sk8q_srt+24;
         const 33;
         const 8338276361;
 },
 Main.$wa1_entry() //  [R6, R5, R4, R3, R2]
         { info_tbl: [(ckAC,
                       label: block_ckAC_info
                       rep:StackRep [False, False, True, True, True, False, False, True,
                                     True, False, True, True]),
                      (ckAE,
                       label: block_ckAE_info
                       rep:StackRep [False, False, False, True, True, True, False, False,
                                     True, True, False, True, True]),
                      (ckAL,
                       label: block_ckAL_info
                       rep:StackRep [False, False, True, True, True, False, False, True,
                                     True, False, True, True]),
                      (ckB7,
                       label: block_ckB7_info
                       rep:StackRep [False, False, True, True, True, False, False, True,
                                     True, False, True, True]),
                      (ckB9,
                       label: block_ckB9_info
                       rep:StackRep [False, False, False, True, True, True, False, False,
                                     True, True, False, True, True]),
                      (ckBg,
                       label: block_ckBg_info
                       rep:StackRep [False, False, True, True, True, False, False, True,
                                     True, False, True, True]),
                      (ckBp,
                       label: block_ckBp_info
                       rep:StackRep [False, True, True, True, True, True, False, True,
                                     False, False, True, True]),
                      (ckBs,
                       label: block_ckBs_info
                       rep:StackRep [False, True, True, True, True, False, False, True,
                                     False, False, True, True]),
                      (ckBE,
                       label: block_ckBE_info
                       rep:StackRep [False, True, True, True, True, False, False, True,
                                     False, False, True, True]),
                      (ckBG,
                       label: block_ckBG_info
                       rep:StackRep [False, True, True, True, True, False, False, True,
                                     False, False, True, True]),
                      (ckCL,
                       label: Main.$wa1_info
                       rep:HeapRep static {
                             Fun {arity: 13
                                  fun_type: ArgGen [False, False, True, True, True, False, False,
                                                    True, True, False, True, True]} }),
                      (ckD4,
                       label: block_ckD4_info
                       rep:StackRep [False, True, True, True, True, False, False, True,
                                     False, False, True, True]),
                      (ckD6,
                       label: block_ckD6_info
                       rep:StackRep [False, True, True, True, True, False, False, True,
                                     False, False, True, True]),
                      (ckDl,
                       label: block_ckDl_info
                       rep:StackRep [False, True, True, True, True, False, False, True,
                                     False, False, True, True]),
                      (ckDn,
                       label: block_ckDn_info
                       rep:StackRep [False, True, True, True, True, False, False, True,
                                     False, False, True, True]),
                      (ckDD,
                       label: block_ckDD_info
                       rep:StackRep [False, True, True, True, True, False, False, True,
                                     False, False, True, True]),
                      (ckDF,
                       label: block_ckDF_info
                       rep:StackRep [False, True, True, True, True, False, False, True,
                                     False, False, True, True]),
                      (ckDV,
                       label: block_ckDV_info
                       rep:StackRep [False, True, True, True, True, True, False, True,
                                     False, False, True, True]),
                      (ckDY,
                       label: block_ckDY_info
                       rep:StackRep [False, True, True, True, True, True, False, True,
                                     False, False, True, True]),
                      (ckE8,
                       label: block_ckE8_info
                       rep:StackRep [False, True, True, True, True, True, False, True,
                                     False, False, True, True]),
                      (ckEi,
                       label: block_ckEi_info
                       rep:StackRep [False, False, True, True, True, False, False, True,
                                     True, False, True, True]),
                      (ckEr,
                       label: block_ckEr_info
                       rep:StackRep [False, False, True, True, True, False, False, True,
                                     True, False, True, True]),
                      (ckED,
                       label: block_ckED_info
                       rep:StackRep [False, False, True, True, True, False, False, True,
                                     True, False, True, True]),
                      (ckEM,
                       label: block_ckEM_info
                       rep:StackRep [False, False, True, True, True, False, False, True,
                                     True, False, True, True])]
           stack_info: arg_space: 64 updfr_space: Just 8
         }
     {offset
       ckCL:
           _sjYH::I64 = R6;
           _sjYG::I64 = R5;
           _sjYF::I64 = R4;
           _sjYE::P64 = R3;
           _sjYD::P64 = R2;
           if ((Sp + -56) < SpLim) goto ckCM; else goto ckCN;
       ckCN:
           if (HpLim == 0) goto ckCM; else goto ckCO;
       ckCM:
           R1 = Main.$wa1_closure;
           P64[Sp - 40] = _sjYD::P64;
           P64[Sp - 32] = _sjYE::P64;
           I64[Sp - 24] = _sjYF::I64;
           I64[Sp - 16] = _sjYG::I64;
           I64[Sp - 8] = _sjYH::I64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 104, res: 0, upd: 8;
       ckCO:
           _sjYO::F64 = F64[Sp + 48];
           (_ckAs::F64) = call MO_UF_Conv W64(100000);
           I64[Sp - 48] = ckAC;
           D1 = %MO_F_Mul_W64(%MO_F_Quot_W64(_sjYO::F64, 100.0 :: W64),
                              _ckAs::F64);
           R2 = GHC.Real.$fIntegralWord_closure;
           P64[Sp - 40] = _sjYD::P64;
           P64[Sp - 32] = _sjYE::P64;
           I64[Sp - 24] = _sjYF::I64;
           I64[Sp - 16] = _sjYG::I64;
           I64[Sp - 8] = _sjYH::I64;
           Sp = Sp - 48;
           call GHC.Float.$w$cproperFraction_info(D1,
                                                  R2) returns to ckAC, args: 8, res: 8, upd: 8;
       ckAC:
           I64[Sp - 8] = ckAE;
           _sjYU::P64 = R1;
           R1 = R2;
           P64[Sp] = _sjYU::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ckAE; else goto ckAF;
       ckAF:
           call (I64[R1])(R1) returns to ckAE, args: 8, res: 8, upd: 8;
       ckAE:
           _sjYU::P64 = P64[Sp + 8];
           if (%MO_F_Lt_W64(F64[R1 + 7],
                            0.0 :: W64)) goto ckEN; else goto ckEF;
       ckEN:
           I64[Sp + 8] = ckEM;
           R1 = _sjYU::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ckEM; else goto ckEO;
       ckEO:
           call (I64[R1])(R1) returns to ckEM, args: 8, res: 8, upd: 8;
       ckEM:
           _sjYO::F64 = F64[Sp + 96];
           _sjYZ::I64 = I64[R1 + 7] - 1;
           goto ckAM;
       ckEF:
           I64[Sp + 8] = ckED;
           R1 = _sjYU::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ckED; else goto ckEG;
       ckEG:
           call (I64[R1])(R1) returns to ckED, args: 8, res: 8, upd: 8;
       ckED:
           _sjYO::F64 = F64[Sp + 96];
           _sjYZ::I64 = I64[R1 + 7];
           goto ckAM;
       ckAM:
           if (HpLim == 0) goto ckCR; else goto ckCS;
       ckCR:
           I64[Sp] = ckAL;
           R1 = _sjYZ::I64;
           call stg_gc_unbx_r1(R1) returns to ckAL, args: 8, res: 8, upd: 8;
       ckAL:
           _sjYO::F64 = F64[Sp + 96];
           _sjYZ::I64 = R1;
           goto ckAM;
       ckCS:
           (_ckAO::F64) = call MO_UF_Conv W64(100000);
           I64[Sp] = ckB7;
           D1 = %MO_F_Mul_W64(%MO_F_Quot_W64(%MO_F_Add_W64(%MO_F_Quot_W64(%MO_F_Sub_W64(100.0 :: W64,
                                                                                        _sjYO::F64),
                                                                          2.0 :: W64),
                                                           _sjYO::F64),
                                             100.0 :: W64),
                              _ckAO::F64);
           R2 = GHC.Real.$fIntegralWord_closure;
           I64[Sp + 96] = _sjYZ::I64;
           call GHC.Float.$w$cproperFraction_info(D1,
                                                  R2) returns to ckB7, args: 8, res: 8, upd: 8;
       ckB7:
           I64[Sp - 8] = ckB9;
           _sjZ7::P64 = R1;
           R1 = R2;
           P64[Sp] = _sjZ7::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ckB9; else goto ckBa;
       ckBa:
           call (I64[R1])(R1) returns to ckB9, args: 8, res: 8, upd: 8;
       ckB9:
           _sjZ7::P64 = P64[Sp + 8];
           if (%MO_F_Lt_W64(F64[R1 + 7],
                            0.0 :: W64)) goto ckEs; else goto ckEk;
       ckEs:
           I64[Sp + 8] = ckEr;
           R1 = _sjZ7::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ckEr; else goto ckEt;
       ckEt:
           call (I64[R1])(R1) returns to ckEr, args: 8, res: 8, upd: 8;
       ckEr:
           _sjYE::P64 = P64[Sp + 16];
           _sjYF::I64 = I64[Sp + 24];
           _sjYG::I64 = I64[Sp + 32];
           _sjYH::I64 = I64[Sp + 40];
           _sjYI::P64 = P64[Sp + 48];
           _sjYK::I64 = I64[Sp + 64];
           _sjYL::I64 = I64[Sp + 72];
           _sjYM::P64 = P64[Sp + 80];
           _sjZc::I64 = I64[R1 + 7] - 1;
           goto ckBh;
       ckEk:
           I64[Sp + 8] = ckEi;
           R1 = _sjZ7::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ckEi; else goto ckEl;
       ckEl:
           call (I64[R1])(R1) returns to ckEi, args: 8, res: 8, upd: 8;
       ckEi:
           _sjYE::P64 = P64[Sp + 16];
           _sjYF::I64 = I64[Sp + 24];
           _sjYG::I64 = I64[Sp + 32];
           _sjYH::I64 = I64[Sp + 40];
           _sjYI::P64 = P64[Sp + 48];
           _sjYK::I64 = I64[Sp + 64];
           _sjYL::I64 = I64[Sp + 72];
           _sjYM::P64 = P64[Sp + 80];
           _sjZc::I64 = I64[R1 + 7];
           goto ckBh;
       ckBh:
           Hp = Hp + 120;
           if (Hp > HpLim) goto ckCX; else goto ckCW;
       ckCX:
           HpAlloc = 120;
           I64[Sp] = ckBg;
           R1 = _sjZc::I64;
           call stg_gc_unbx_r1(R1) returns to ckBg, args: 8, res: 8, upd: 8;
       ckBg:
           _sjYE::P64 = P64[Sp + 16];
           _sjYF::I64 = I64[Sp + 24];
           _sjYG::I64 = I64[Sp + 32];
           _sjYH::I64 = I64[Sp + 40];
           _sjYI::P64 = P64[Sp + 48];
           _sjYK::I64 = I64[Sp + 64];
           _sjYL::I64 = I64[Sp + 72];
           _sjYM::P64 = P64[Sp + 80];
           _sjZc::I64 = R1;
           goto ckBh;
       ckCW:
           I64[Hp - 112] = Data.Vector.Primitive.Mutable.MVector_con_info;
           P64[Hp - 104] = _sjYM::P64;
           I64[Hp - 96] = _sjYK::I64;
           I64[Hp - 88] = _sjYL::I64;
           I64[Hp - 80] = GHC.Types.I#_con_info;
           I64[Hp - 72] = _sjYG::I64;
           I64[Hp - 64] = GHC.Types.I#_con_info;
           I64[Hp - 56] = _sjYF::I64;
           I64[Hp - 48] = GHC.Arr.Array_con_info;
           P64[Hp - 40] = Hp - 63;
           P64[Hp - 32] = Hp - 79;
           P64[Hp - 24] = _sjYI::P64;
           I64[Hp - 16] = _sjYH::I64;
           I64[Hp - 8] = Data.Primitive.ByteArray.MutableByteArray_con_info;
           P64[Hp] = _sjYE::P64;
           _ckBj::P64 = Hp - 111;
           _ckBm::P64 = Hp - 47;
           _B2::P64 = Hp - 7;
           goto ckE9;
       ckE9:
           if (HpLim == 0) goto ckEb; else goto ckEc;
       ckEb:
           I64[Sp] = ckE8;
           R1 = _B2::P64;
           I64[Sp + 64] = _sjZc::I64;
           P64[Sp + 72] = _ckBm::P64;
           P64[Sp + 80] = _ckBj::P64;
           call stg_gc_unpt_r1(R1) returns to ckE8, args: 8, res: 8, upd: 8;
       ckE8:
           _ckBj::P64 = P64[Sp + 80];
           _ckBm::P64 = P64[Sp + 72];
           _sjZc::I64 = I64[Sp + 64];
           _B2::P64 = R1;
           goto ckE9;
       ckEc:
           _sk0D::P64 = _B2::P64;
           goto ckDW;
       ckDW:
           if (HpLim == 0) goto ckDZ; else goto ckE0;
       ckDZ:
           I64[Sp] = ckDV;
           R1 = _sk0D::P64;
           I64[Sp + 64] = _sjZc::I64;
           P64[Sp + 72] = _ckBm::P64;
           P64[Sp + 80] = _ckBj::P64;
           call stg_gc_unpt_r1(R1) returns to ckDV, args: 8, res: 8, upd: 8;
       ckDV:
           _ckBj::P64 = P64[Sp + 80];
           _ckBm::P64 = P64[Sp + 72];
           _sjZc::I64 = I64[Sp + 64];
           _sk0D::P64 = R1;
           goto ckDW;
       ckE0:
           I64[Sp] = ckDY;
           R1 = _sk0D::P64;
           I64[Sp + 64] = _sjZc::I64;
           P64[Sp + 72] = _ckBm::P64;
           P64[Sp + 80] = _ckBj::P64;
           if (R1 & 7 != 0) goto ckDY; else goto ckE1;
       ckE1:
           call (I64[R1])(R1) returns to ckDY, args: 8, res: 8, upd: 8;
       ckDY:
           _sjZi::P64 = P64[R1 + 7];
           goto ckBq;
       ckBq:
           if (HpLim == 0) goto ckCY; else goto ckCZ;
       ckCY:
           I64[Sp] = ckBp;
           R1 = _sjZi::P64;
           call stg_gc_unpt_r1(R1) returns to ckBp, args: 8, res: 8, upd: 8;
       ckBp:
           _sjZi::P64 = R1;
           goto ckBq;
       ckCZ:
           I64[Sp] = ckBs;
           R2 = I64[_sjZi::P64 + 16];
           P64[Sp + 48] = _sjZi::P64;
           call $wgo1_rjVd_info(R2) returns to ckBs, args: 8, res: 8, upd: 8;
       ckBs:
           _sjZi::P64 = P64[Sp + 48];
           I64[_sjZi::P64 + 16] = R1;
           I64[Sp] = ckBE;
           R3 = I64[_sjZi::P64 + 16];
           _sjZp::I64 = R2;
           R2 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[Sp + 88] - 2));
           I64[Sp + 40] = _sjZp::I64;
           call System.Random.PCG.Fast.Pure.$wbounded_info(R3,
                                                           R2) returns to ckBE, args: 8, res: 8, upd: 8;
       ckBE:
           _ckBj::P64 = P64[Sp + 80];
           _ckBm::P64 = P64[Sp + 72];
           _sjYJ::P64 = P64[Sp + 56];
           _sjYZ::I64 = I64[Sp + 96];
           _sjZc::I64 = I64[Sp + 64];
           _sjZi::P64 = P64[Sp + 48];
           _sjZp::I64 = I64[Sp + 40];
           _sjZy::I64 = R2;
           _sjZx::I64 = R1;
           goto ckBF;
       ckBF:
           Hp = Hp + 40;
           if (Hp > HpLim) goto ckD3; else goto ckD2;
       ckD3:
           HpAlloc = 40;
           I64[Sp] = ckBG;
           I64[Sp + 24] = _sjZy::I64;
           I64[Sp + 32] = _sjZx::I64;
           call stg_gc_noregs() returns to ckBG, args: 8, res: 8, upd: 8;
       ckBG:
           _ckBj::P64 = P64[Sp + 80];
           _ckBm::P64 = P64[Sp + 72];
           _sjYJ::P64 = P64[Sp + 56];
           _sjYZ::I64 = I64[Sp + 96];
           _sjZc::I64 = I64[Sp + 64];
           _sjZi::P64 = P64[Sp + 48];
           _sjZp::I64 = I64[Sp + 40];
           _sjZx::I64 = I64[Sp + 32];
           _sjZy::I64 = I64[Sp + 24];
           goto ckBF;
       ckD2:
           I64[_sjZi::P64 + 16] = _sjZx::I64;
           if (_sjZp::I64 <= _sjYZ::I64) goto ckDG; else goto ckDC;
       ckDG:
           I64[Hp - 32] = sat_sk0o_info;
           P64[Hp - 24] = _sjYJ::P64;
           P64[Hp - 16] = _ckBm::P64;
           I64[Hp - 8] = _sjZy::I64;
           _ckCu::P64 = Hp - 31;
           Hp = Hp - 8;
           I64[Sp] = ckDD;
           R1 = _ckCu::P64;
           call stg_norec_atomically#(R1) returns to ckDD, args: 8, res: 8, upd: 8;
       ckDD:
           _sk0u::P64 = P64[P64[Sp + 8] + 8];
           I64[Sp] = ckDF;
           R1 = _sk0u::P64;
           if (R1 & 7 != 0) goto ckDF; else goto ckDI;
       ckDI:
           call (I64[R1])(R1) returns to ckDF, args: 8, res: 8, upd: 8;
       ckDF:
           Hp = Hp + 16;
           if (Hp > HpLim) goto ckDO; else goto ckDN;
       ckDO:
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to ckDF, args: 8, res: 8, upd: 8;
       ckDN:
           _sk0x::I64 = I64[R1 + 7];
           if (_sk0x::I64 == 18446744073709551615) goto ckDS; else goto ckDR;
       ckDR:
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _sk0x::I64 + 1;
           _sjYD::P64 = P64[Sp + 8];
           P64[_sjYD::P64 + 8] = Hp - 7;
           _sjZi::P64 = P64[Sp + 48];
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sjYD::P64);
           goto ckBq;
       ckDC:
           if (_sjZp::I64 <= _sjZc::I64) goto ckDo; else goto ckD8;
       ckDo:
           I64[Hp - 32] = sat_sk04_info;
           P64[Hp - 24] = _sjYJ::P64;
           P64[Hp - 16] = _ckBj::P64;
           P64[Hp - 8] = _ckBm::P64;
           I64[Hp] = _sjZy::I64;
           I64[Sp] = ckDl;
           R1 = Hp - 31;
           call stg_norec_atomically#(R1) returns to ckDl, args: 8, res: 8, upd: 8;
       ckDl:
           _sk0a::P64 = P64[P64[Sp + 8] + 8];
           I64[Sp] = ckDn;
           R1 = _sk0a::P64;
           if (R1 & 7 != 0) goto ckDn; else goto ckDq;
       ckDq:
           call (I64[R1])(R1) returns to ckDn, args: 8, res: 8, upd: 8;
       ckDn:
           Hp = Hp + 16;
           if (Hp > HpLim) goto ckDw; else goto ckDv;
       ckDw:
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to ckDn, args: 8, res: 8, upd: 8;
       ckDv:
           _sk0d::I64 = I64[R1 + 7];
           if (_sk0d::I64 == 18446744073709551615) goto ckDS; else goto ckDz;
       ckDz:
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _sk0d::I64 + 1;
           _sjYD::P64 = P64[Sp + 8];
           P64[_sjYD::P64 + 8] = Hp - 7;
           _sjZi::P64 = P64[Sp + 48];
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sjYD::P64);
           goto ckBq;
       ckD8:
           I64[Hp - 32] = sat_sjZK_info;
           P64[Hp - 24] = _sjYJ::P64;
           P64[Hp - 16] = _ckBm::P64;
           I64[Hp - 8] = _sjZy::I64;
           _ckBU::P64 = Hp - 31;
           Hp = Hp - 8;
           I64[Sp] = ckD4;
           R1 = _ckBU::P64;
           call stg_norec_atomically#(R1) returns to ckD4, args: 8, res: 8, upd: 8;
       ckD4:
           _sjZQ::P64 = P64[P64[Sp + 8] + 8];
           I64[Sp] = ckD6;
           R1 = _sjZQ::P64;
           if (R1 & 7 != 0) goto ckD6; else goto ckDa;
       ckDa:
           call (I64[R1])(R1) returns to ckD6, args: 8, res: 8, upd: 8;
       ckD6:
           Hp = Hp + 16;
           if (Hp > HpLim) goto ckDg; else goto ckDf;
       ckDg:
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to ckD6, args: 8, res: 8, upd: 8;
       ckDf:
           _sjZT::I64 = I64[R1 + 7];
           if (_sjZT::I64 == 18446744073709551615) goto ckDS; else goto ckDj;
       ckDS:
           Hp = Hp - 16;
           R1 = GHC.Word.$fEnumWord12_closure;
           Sp = Sp + 104;
           call (I64[R1])(R1) args: 8, res: 0, upd: 8;
       ckDj:
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _sjZT::I64 + 1;
           _sjYD::P64 = P64[Sp + 8];
           P64[_sjYD::P64 + 8] = Hp - 7;
           _sjZi::P64 = P64[Sp + 48];
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sjYD::P64);
           goto ckBq;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:53.694511 UTC

[section "data" {
     Main.$wa1_closure:
         const Main.$wa1_info;
         const 0;
 },
 Main.$wa1_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 104 updfr_space: Just 8
         }
     {offset
       ckAo:
           R6 = I64[Sp + 32];
           R5 = I64[Sp + 24];
           R4 = I64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Main.$wa1_info(R6,
                               R5,
                               R4,
                               R3,
                               R2,
                               R1) args: 64, res: 0, upd: 8;
     }
 },
 sat_sjZK_entry() //  [R1]
         { info_tbl: [(ckC1,
                       label: sat_sjZK_info
                       rep:HeapRep 2 ptrs 1 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} }),
                      (ckC4,
                       label: block_ckC4_info
                       rep:StackRep [])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckC1:
           _sjZK::P64 = R1;
           if ((Sp + -8) < SpLim) goto ckC5; else goto ckC6;
       ckC6:
           Hp = Hp + 16;
           if (Hp > HpLim) goto ckC8; else goto ckC7;
       ckC8:
           HpAlloc = 16;
           goto ckC5;
       ckC5:
           R1 = _sjZK::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ckC7:
           _sjYJ::P64 = P64[_sjZK::P64 + 7];
           _sjZg::P64 = P64[_sjZK::P64 + 15];
           _sjZF::I64 = I64[_sjZK::P64 + 23] + 1;
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _sjZF::I64;
           I64[Sp - 8] = ckC4;
           R5 = Hp - 7;
           R4 = _sjYJ::P64;
           R3 = _sjZg::P64;
           R2 = GHC.Classes.$fOrdWord_closure;
           Sp = Sp - 8;
           call SkipList.$wa2_info(R5,
                                   R4,
                                   R3,
                                   R2) returns to ckC4, args: 8, res: 8, upd: 8;
       ckC4:
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sk04_entry() //  [R1]
         { info_tbl: [(ckCj,
                       label: sat_sk04_info
                       rep:HeapRep 3 ptrs 1 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} }),
                      (ckCm,
                       label: block_ckCm_info
                       rep:StackRep [])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckCj:
           _sk04::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckCn; else goto ckCo;
       ckCo:
           Hp = Hp + 16;
           if (Hp > HpLim) goto ckCq; else goto ckCp;
       ckCq:
           HpAlloc = 16;
           goto ckCn;
       ckCn:
           R1 = _sk04::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ckCp:
           _sjYJ::P64 = P64[_sk04::P64 + 7];
           _sjZd::P64 = P64[_sk04::P64 + 15];
           _sjZg::P64 = P64[_sk04::P64 + 23];
           _sjZZ::I64 = I64[_sk04::P64 + 31] + 1;
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _sjZZ::I64;
           I64[Sp - 8] = ckCm;
           R6 = Hp - 7;
           R5 = _sjZd::P64;
           R4 = _sjYJ::P64;
           R3 = _sjZg::P64;
           R2 = GHC.Classes.$fOrdWord_closure;
           P64[Sp - 16] = GHC.Tuple.()_closure+1;
           Sp = Sp - 16;
           call SkipList.$wa4_info(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) returns to ckCm, args: 16, res: 8, upd: 8;
       ckCm:
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sk0o_entry() //  [R1]
         { info_tbl: [(ckCB,
                       label: sat_sk0o_info
                       rep:HeapRep 2 ptrs 1 nonptrs {
                             Fun {arity: 1 fun_type: ArgSpec 3} }),
                      (ckCE,
                       label: block_ckCE_info
                       rep:StackRep [])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckCB:
           _sk0o::P64 = R1;
           if ((Sp + -8) < SpLim) goto ckCF; else goto ckCG;
       ckCG:
           Hp = Hp + 16;
           if (Hp > HpLim) goto ckCI; else goto ckCH;
       ckCI:
           HpAlloc = 16;
           goto ckCF;
       ckCF:
           R1 = _sk0o::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ckCH:
           _sjYJ::P64 = P64[_sk0o::P64 + 7];
           _sjZg::P64 = P64[_sk0o::P64 + 15];
           _sk0j::I64 = I64[_sk0o::P64 + 23] + 1;
           I64[Hp - 8] = GHC.Types.W#_con_info;
           I64[Hp] = _sk0j::I64;
           I64[Sp - 8] = ckCE;
           R5 = Hp - 7;
           R4 = _sjYJ::P64;
           R3 = _sjZg::P64;
           R2 = GHC.Classes.$fOrdWord_closure;
           Sp = Sp - 8;
           call SkipList.$wa3_info(R5,
                                   R4,
                                   R3,
                                   R2) returns to ckCE, args: 8, res: 8, upd: 8;
       ckCE:
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 8;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section "relreadonly" {
     ukFk_srtd:
         const Sk8q_srt+24;
         const 33;
         const 8338276361;
 },
 Main.$wa1_entry() //  [R6, R5, R4, R3, R2]
         { info_tbl: [(ckAC,
                       label: block_ckAC_info
                       rep:StackRep [False, False, True, True, True, False, False, True,
                                     True, False, True, True]),
                      (ckAE,
                       label: block_ckAE_info
                       rep:StackRep [False, False, False, True, True, True, False, False,
                                     True, True, False, True, True]),
                      (ckAL,
                       label: block_ckAL_info
                       rep:StackRep [False, False, True, True, True, False, False, True,
                                     True, False, True, True]),
                      (ckB7,
                       label: block_ckB7_info
                       rep:StackRep [False, False, True, True, True, False, False, True,
                                     True, False, True, True]),
                      (ckB9,
                       label: block_ckB9_info
                       rep:StackRep [False, False, False, True, True, True, False, False,
                                     True, True, False, True, True]),
                      (ckBg,
                       label: block_ckBg_info
                       rep:StackRep [False, False, True, True, True, False, False, True,
                                     True, False, True, True]),
                      (ckBp,
                       label: block_ckBp_info
                       rep:StackRep [False, True, True, True, True, True, False, True,
                                     False, False, True, True]),
                      (ckBs,
                       label: block_ckBs_info
                       rep:StackRep [False, True, True, True, True, False, False, True,
                                     False, False, True, True]),
                      (ckBE,
                       label: block_ckBE_info
                       rep:StackRep [False, True, True, True, True, False, False, True,
                                     False, False, True, True]),
                      (ckBG,
                       label: block_ckBG_info
                       rep:StackRep [False, True, True, True, True, False, False, True,
                                     False, False, True, True]),
                      (ckCL,
                       label: Main.$wa1_info
                       rep:HeapRep static {
                             Fun {arity: 13
                                  fun_type: ArgGen [False, False, True, True, True, False, False,
                                                    True, True, False, True, True]} }),
                      (ckD4,
                       label: block_ckD4_info
                       rep:StackRep [False, True, True, True, True, False, False, True,
                                     False, False, True, True]),
                      (ckD6,
                       label: block_ckD6_info
                       rep:StackRep [False, True, True, True, True, False, False, True,
                                     False, False, True, True]),
                      (ckDl,
                       label: block_ckDl_info
                       rep:StackRep [False, True, True, True, True, False, False, True,
                                     False, False, True, True]),
                      (ckDn,
                       label: block_ckDn_info
                       rep:StackRep [False, True, True, True, True, False, False, True,
                                     False, False, True, True]),
                      (ckDD,
                       label: block_ckDD_info
                       rep:StackRep [False, True, True, True, True, False, False, True,
                                     False, False, True, True]),
                      (ckDF,
                       label: block_ckDF_info
                       rep:StackRep [False, True, True, True, True, False, False, True,
                                     False, False, True, True]),
                      (ckDV,
                       label: block_ckDV_info
                       rep:StackRep [False, True, True, True, True, True, False, True,
                                     False, False, True, True]),
                      (ckDY,
                       label: block_ckDY_info
                       rep:StackRep [False, True, True, True, True, True, False, True,
                                     False, False, True, True]),
                      (ckE8,
                       label: block_ckE8_info
                       rep:StackRep [False, True, True, True, True, True, False, True,
                                     False, False, True, True]),
                      (ckEi,
                       label: block_ckEi_info
                       rep:StackRep [False, False, True, True, True, False, False, True,
                                     True, False, True, True]),
                      (ckEr,
                       label: block_ckEr_info
                       rep:StackRep [False, False, True, True, True, False, False, True,
                                     True, False, True, True]),
                      (ckED,
                       label: block_ckED_info
                       rep:StackRep [False, False, True, True, True, False, False, True,
                                     True, False, True, True]),
                      (ckEM,
                       label: block_ckEM_info
                       rep:StackRep [False, False, True, True, True, False, False, True,
                                     True, False, True, True])]
           stack_info: arg_space: 64 updfr_space: Just 8
         }
     {offset
       ckCL:
           _sjYH::I64 = R6;
           _sjYG::I64 = R5;
           _sjYF::I64 = R4;
           _sjYE::P64 = R3;
           _sjYD::P64 = R2;
           if ((Sp + -56) < SpLim) goto ckCM; else goto ckCN;
       ckCN:
           if (HpLim == 0) goto ckCM; else goto ckCO;
       ckCM:
           R1 = Main.$wa1_closure;
           P64[Sp - 40] = _sjYD::P64;
           P64[Sp - 32] = _sjYE::P64;
           I64[Sp - 24] = _sjYF::I64;
           I64[Sp - 16] = _sjYG::I64;
           I64[Sp - 8] = _sjYH::I64;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 104, res: 0, upd: 8;
       ckCO:
           _sjYO::F64 = F64[Sp + 48];
           (_ckAs::F64) = call MO_UF_Conv W64(100000);
           I64[Sp - 48] = ckAC;
           D1 = %MO_F_Mul_W64(%MO_F_Quot_W64(_sjYO::F64, 100.0 :: W64),
                              _ckAs::F64);
           R2 = GHC.Real.$fIntegralWord_closure;
           P64[Sp - 40] = _sjYD::P64;
           P64[Sp - 32] = _sjYE::P64;
           I64[Sp - 24] = _sjYF::I64;
           I64[Sp - 16] = _sjYG::I64;
           I64[Sp - 8] = _sjYH::I64;
           Sp = Sp - 48;
           call GHC.Float.$w$cproperFraction_info(D1,
                                                  R2) returns to ckAC, args: 8, res: 8, upd: 8;
       ckAC:
           I64[Sp - 8] = ckAE;
           _sjYU::P64 = R1;
           R1 = R2;
           P64[Sp] = _sjYU::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ckAE; else goto ckAF;
       ckAF:
           call (I64[R1])(R1) returns to ckAE, args: 8, res: 8, upd: 8;
       ckAE:
           _sjYU::P64 = P64[Sp + 8];
           if (%MO_F_Lt_W64(F64[R1 + 7],
                            0.0 :: W64)) goto ckEN; else goto ckEF;
       ckEN:
           I64[Sp + 8] = ckEM;
           R1 = _sjYU::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ckEM; else goto ckEO;
       ckEO:
           call (I64[R1])(R1) returns to ckEM, args: 8, res: 8, upd: 8;
       ckEM:
           _sjYO::F64 = F64[Sp + 96];
           _sjYZ::I64 = I64[R1 + 7] - 1;
           goto ckAM;
       ckEF:
           I64[Sp + 8] = ckED;
           R1 = _sjYU::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ckED; else goto ckEG;
       ckEG:
           call (I64[R1])(R1) returns to ckED, args: 8, res: 8, upd: 8;
       ckED:
           _sjYO::F64 = F64[Sp + 96];
           _sjYZ::I64 = I64[R1 + 7];
           goto ckAM;
       ckAM:
           if (HpLim == 0) goto ckCR; else goto ckCS;
       ckCR:
           I64[Sp] = ckAL;
           R1 = _sjYZ::I64;
           call stg_gc_unbx_r1(R1) returns to ckAL, args: 8, res: 8, upd: 8;
       ckAL:
           _sjYO::F64 = F64[Sp + 96];
           _sjYZ::I64 = R1;
           goto ckAM;
       ckCS:
           (_ckAO::F64) = call MO_UF_Conv W64(100000);
           I64[Sp] = ckB7;
           D1 = %MO_F_Mul_W64(%MO_F_Quot_W64(%MO_F_Add_W64(%MO_F_Quot_W64(%MO_F_Sub_W64(100.0 :: W64,
                                                                                        _sjYO::F64),
                                                                          2.0 :: W64),
                                                           _sjYO::F64),
                                             100.0 :: W64),
                              _ckAO::F64);
           R2 = GHC.Real.$fIntegralWord_closure;
           I64[Sp + 96] = _sjYZ::I64;
           call GHC.Float.$w$cproperFraction_info(D1,
                                                  R2) returns to ckB7, args: 8, res: 8, upd: 8;
       ckB7:
           I64[Sp - 8] = ckB9;
           _sjZ7::P64 = R1;
           R1 = R2;
           P64[Sp] = _sjZ7::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ckB9; else goto ckBa;
       ckBa:
           call (I64[R1])(R1) returns to ckB9, args: 8, res: 8, upd: 8;
       ckB9:
           _sjZ7::P64 = P64[Sp + 8];
           if (%MO_F_Lt_W64(F64[R1 + 7],
                            0.0 :: W64)) goto ckEs; else goto ckEk;
       ckEs:
           I64[Sp + 8] = ckEr;
           R1 = _sjZ7::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ckEr; else goto ckEt;
       ckEt:
           call (I64[R1])(R1) returns to ckEr, args: 8, res: 8, upd: 8;
       ckEr:
           _sjYE::P64 = P64[Sp + 16];
           _sjYF::I64 = I64[Sp + 24];
           _sjYG::I64 = I64[Sp + 32];
           _sjYH::I64 = I64[Sp + 40];
           _sjYI::P64 = P64[Sp + 48];
           _sjYK::I64 = I64[Sp + 64];
           _sjYL::I64 = I64[Sp + 72];
           _sjYM::P64 = P64[Sp + 80];
           _sjZc::I64 = I64[R1 + 7] - 1;
           goto ckBh;
       ckEk:
           I64[Sp + 8] = ckEi;
           R1 = _sjZ7::P64;
           Sp = Sp + 8;
           if (R1 & 7 != 0) goto ckEi; else goto ckEl;
       ckEl:
           call (I64[R1])(R1) returns to ckEi, args: 8, res: 8, upd: 8;
       ckEi:
           _sjYE::P64 = P64[Sp + 16];
           _sjYF::I64 = I64[Sp + 24];
           _sjYG::I64 = I64[Sp + 32];
           _sjYH::I64 = I64[Sp + 40];
           _sjYI::P64 = P64[Sp + 48];
           _sjYK::I64 = I64[Sp + 64];
           _sjYL::I64 = I64[Sp + 72];
           _sjYM::P64 = P64[Sp + 80];
           _sjZc::I64 = I64[R1 + 7];
           goto ckBh;
       ckBh:
           Hp = Hp + 120;
           if (Hp > HpLim) goto ckCX; else goto ckCW;
       ckCX:
           HpAlloc = 120;
           I64[Sp] = ckBg;
           R1 = _sjZc::I64;
           call stg_gc_unbx_r1(R1) returns to ckBg, args: 8, res: 8, upd: 8;
       ckBg:
           _sjYE::P64 = P64[Sp + 16];
           _sjYF::I64 = I64[Sp + 24];
           _sjYG::I64 = I64[Sp + 32];
           _sjYH::I64 = I64[Sp + 40];
           _sjYI::P64 = P64[Sp + 48];
           _sjYK::I64 = I64[Sp + 64];
           _sjYL::I64 = I64[Sp + 72];
           _sjYM::P64 = P64[Sp + 80];
           _sjZc::I64 = R1;
           goto ckBh;
       ckCW:
           I64[Hp - 112] = Data.Vector.Primitive.Mutable.MVector_con_info;
           P64[Hp - 104] = _sjYM::P64;
           I64[Hp - 96] = _sjYK::I64;
           I64[Hp - 88] = _sjYL::I64;
           I64[Hp - 80] = GHC.Types.I#_con_info;
           I64[Hp - 72] = _sjYG::I64;
           I64[Hp - 64] = GHC.Types.I#_con_info;
           I64[Hp - 56] = _sjYF::I64;
           I64[Hp - 48] = GHC.Arr.Array_con_info;
           P64[Hp - 40] = Hp - 63;
           P64[Hp - 32] = Hp - 79;
           P64[Hp - 24] = _sjYI::P64;
           I64[Hp - 16] = _sjYH::I64;
           I64[Hp - 8] = Data.Primitive.ByteArray.MutableByteArray_con_info;
           P64[Hp] = _sjYE::P64;
           _ckBj::P64 = Hp - 111;
           _ckBm::P64 = Hp - 47;
           _B2::P64 = Hp - 7;
           goto ckE9;
       ckE9:
           if (HpLim == 0) goto ckEb; else goto ckEc;
       ckEb:
           I64[Sp] = ckE8;
           R1 = _B2::P64;
           I64[Sp + 64] = _sjZc::I64;
           P64[Sp + 72] = _ckBm::P64;
           P64[Sp + 80] = _ckBj::P64;
           call stg_gc_unpt_r1(R1) returns to ckE8, args: 8, res: 8, upd: 8;
       ckE8:
           _ckBj::P64 = P64[Sp + 80];
           _ckBm::P64 = P64[Sp + 72];
           _sjZc::I64 = I64[Sp + 64];
           _B2::P64 = R1;
           goto ckE9;
       ckEc:
           _sk0D::P64 = _B2::P64;
           goto ckDW;
       ckDW:
           if (HpLim == 0) goto ckDZ; else goto ckE0;
       ckDZ:
           I64[Sp] = ckDV;
           R1 = _sk0D::P64;
           I64[Sp + 64] = _sjZc::I64;
           P64[Sp + 72] = _ckBm::P64;
           P64[Sp + 80] = _ckBj::P64;
           call stg_gc_unpt_r1(R1) returns to ckDV, args: 8, res: 8, upd: 8;
       ckDV:
           _ckBj::P64 = P64[Sp + 80];
           _ckBm::P64 = P64[Sp + 72];
           _sjZc::I64 = I64[Sp + 64];
           _sk0D::P64 = R1;
           goto ckDW;
       ckE0:
           I64[Sp] = ckDY;
           R1 = _sk0D::P64;
           I64[Sp + 64] = _sjZc::I64;
           P64[Sp + 72] = _ckBm::P64;
           P64[Sp + 80] = _ckBj::P64;
           if (R1 & 7 != 0) goto ckDY; else goto ckE1;
       ckE1:
           call (I64[R1])(R1) returns to ckDY, args: 8, res: 8, upd: 8;
       ckDY:
           _sjZi::P64 = P64[R1 + 7];
           goto ckBq;
       ckBq:
           if (HpLim == 0) goto ckCY; else goto ckCZ;
       ckCY:
           I64[Sp] = ckBp;
           R1 = _sjZi::P64;
           call stg_gc_unpt_r1(R1) returns to ckBp, args: 8, res: 8, upd: 8;
       ckBp:
           _sjZi::P64 = R1;
           goto ckBq;
       ckCZ:
           I64[Sp] = ckBs;
           R2 = I64[_sjZi::P64 + 16];
           P64[Sp + 48] = _sjZi::P64;
           call $wgo1_rjVd_info(R2) returns to ckBs, args: 8, res: 8, upd: 8;
       ckBs:
           _sjZi::P64 = P64[Sp + 48];
           I64[_sjZi::P64 + 16] = R1;
           I64[Sp] = ckBE;
           R3 = I64[_sjZi::P64 + 16];
           _sjZp::I64 = R2;
           R2 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(I64[Sp + 88] - 2));
           I64[Sp + 40] = _sjZp::I64;
           call System.Random.PCG.Fast.Pure.$wbounded_info(R3,
                                                           R2) returns to ckBE, args: 8, res: 8, upd: 8;
       ckBE:
           _ckBj::P64 = P64[Sp + 80];
           _ckBm::P64 = P64[Sp + 72];
           _sjYJ::P64 = P64[Sp + 56];
           _sjYZ::I64 = I64[Sp + 96];
           _sjZc::I64 = I64[Sp + 64];
           _sjZi::P64 = P64[Sp + 48];
           _sjZp::I64 = I64[Sp + 40];
           _sjZy::I64 = R2;
           _sjZx::I64 = R1;
           goto ckBF;
       ckBF:
           Hp = Hp + 40;
           if (Hp > HpLim) goto ckD3; else goto ckD2;
       ckD3:
           HpAlloc = 40;
           I64[Sp] = ckBG;
           I64[Sp + 24] = _sjZy::I64;
           I64[Sp + 32] = _sjZx::I64;
           call stg_gc_noregs() returns to ckBG, args: 8, res: 8, upd: 8;
       ckBG:
           _ckBj::P64 = P64[Sp + 80];
           _ckBm::P64 = P64[Sp + 72];
           _sjYJ::P64 = P64[Sp + 56];
           _sjYZ::I64 = I64[Sp + 96];
           _sjZc::I64 = I64[Sp + 64];
           _sjZi::P64 = P64[Sp + 48];
           _sjZp::I64 = I64[Sp + 40];
           _sjZx::I64 = I64[Sp + 32];
           _sjZy::I64 = I64[Sp + 24];
           goto ckBF;
       ckD2:
           I64[_sjZi::P64 + 16] = _sjZx::I64;
           if (_sjZp::I64 <= _sjYZ::I64) goto ckDG; else goto ckDC;
       ckDG:
           I64[Hp - 32] = sat_sk0o_info;
           P64[Hp - 24] = _sjYJ::P64;
           P64[Hp - 16] = _ckBm::P64;
           I64[Hp - 8] = _sjZy::I64;
           _ckCu::P64 = Hp - 31;
           Hp = Hp - 8;
           I64[Sp] = ckDD;
           R1 = _ckCu::P64;
           call stg_norec_atomically#(R1) returns to ckDD, args: 8, res: 8, upd: 8;
       ckDD:
           _sk0u::P64 = P64[P64[Sp + 8] + 8];
           I64[Sp] = ckDF;
           R1 = _sk0u::P64;
           if (R1 & 7 != 0) goto ckDF; else goto ckDI;
       ckDI:
           call (I64[R1])(R1) returns to ckDF, args: 8, res: 8, upd: 8;
       ckDF:
           Hp = Hp + 16;
           if (Hp > HpLim) goto ckDO; else goto ckDN;
       ckDO:
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to ckDF, args: 8, res: 8, upd: 8;
       ckDN:
           _sk0x::I64 = I64[R1 + 7];
           if (_sk0x::I64 == 18446744073709551615) goto ckDS; else goto ckDR;
       ckDR:
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _sk0x::I64 + 1;
           _sjYD::P64 = P64[Sp + 8];
           P64[_sjYD::P64 + 8] = Hp - 7;
           _sjZi::P64 = P64[Sp + 48];
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sjYD::P64);
           goto ckBq;
       ckDC:
           if (_sjZp::I64 <= _sjZc::I64) goto ckDo; else goto ckD8;
       ckDo:
           I64[Hp - 32] = sat_sk04_info;
           P64[Hp - 24] = _sjYJ::P64;
           P64[Hp - 16] = _ckBj::P64;
           P64[Hp - 8] = _ckBm::P64;
           I64[Hp] = _sjZy::I64;
           I64[Sp] = ckDl;
           R1 = Hp - 31;
           call stg_norec_atomically#(R1) returns to ckDl, args: 8, res: 8, upd: 8;
       ckDl:
           _sk0a::P64 = P64[P64[Sp + 8] + 8];
           I64[Sp] = ckDn;
           R1 = _sk0a::P64;
           if (R1 & 7 != 0) goto ckDn; else goto ckDq;
       ckDq:
           call (I64[R1])(R1) returns to ckDn, args: 8, res: 8, upd: 8;
       ckDn:
           Hp = Hp + 16;
           if (Hp > HpLim) goto ckDw; else goto ckDv;
       ckDw:
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to ckDn, args: 8, res: 8, upd: 8;
       ckDv:
           _sk0d::I64 = I64[R1 + 7];
           if (_sk0d::I64 == 18446744073709551615) goto ckDS; else goto ckDz;
       ckDz:
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _sk0d::I64 + 1;
           _sjYD::P64 = P64[Sp + 8];
           P64[_sjYD::P64 + 8] = Hp - 7;
           _sjZi::P64 = P64[Sp + 48];
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sjYD::P64);
           goto ckBq;
       ckD8:
           I64[Hp - 32] = sat_sjZK_info;
           P64[Hp - 24] = _sjYJ::P64;
           P64[Hp - 16] = _ckBm::P64;
           I64[Hp - 8] = _sjZy::I64;
           _ckBU::P64 = Hp - 31;
           Hp = Hp - 8;
           I64[Sp] = ckD4;
           R1 = _ckBU::P64;
           call stg_norec_atomically#(R1) returns to ckD4, args: 8, res: 8, upd: 8;
       ckD4:
           _sjZQ::P64 = P64[P64[Sp + 8] + 8];
           I64[Sp] = ckD6;
           R1 = _sjZQ::P64;
           if (R1 & 7 != 0) goto ckD6; else goto ckDa;
       ckDa:
           call (I64[R1])(R1) returns to ckD6, args: 8, res: 8, upd: 8;
       ckD6:
           Hp = Hp + 16;
           if (Hp > HpLim) goto ckDg; else goto ckDf;
       ckDg:
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to ckD6, args: 8, res: 8, upd: 8;
       ckDf:
           _sjZT::I64 = I64[R1 + 7];
           if (_sjZT::I64 == 18446744073709551615) goto ckDS; else goto ckDj;
       ckDS:
           Hp = Hp - 16;
           R1 = GHC.Word.$fEnumWord12_closure;
           Sp = Sp + 104;
           call (I64[R1])(R1) args: 8, res: 0, upd: 8;
       ckDj:
           I64[Hp - 8] = GHC.Word.W64#_con_info;
           I64[Hp] = _sjZT::I64 + 1;
           _sjYD::P64 = P64[Sp + 8];
           P64[_sjYD::P64 + 8] = Hp - 7;
           _sjZi::P64 = P64[Sp + 48];
           call "ccall" arg hints:  [PtrHint,
                                     PtrHint]  result hints:  [] dirty_MUT_VAR(BaseReg, _sjYD::P64);
           goto ckBq;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:53.775386 UTC

[section "data" {
     Main.runRSTMSingle1_closure:
         const Main.runRSTMSingle1_info;
         const 0;
 },
 Main.runRSTMSingle1_entry() //  [R6, R5, R4, R3, R2]
         { info_tbl: [(ckGR,
                       label: Main.runRSTMSingle1_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckGR:
           _sk11::P64 = R6;
           _sk10::P64 = R5;
           _sk0Z::P64 = R4;
           _sk0Y::P64 = R3;
           _sk0X::P64 = R2;
           goto ckGM;
       ckGM:
           if ((old + 0) - <highSp> < SpLim) goto ckHy; else goto ckHz;
       ckHz:
           goto ckGL;
       ckGL:
           if (HpLim == 0) goto ckHy; else goto ckHA;
       ckHy:
           R6 = _sk11::P64;
           R5 = _sk10::P64;
           R4 = _sk0Z::P64;
           R3 = _sk0Y::P64;
           R2 = _sk0X::P64;
           R1 = Main.runRSTMSingle1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckHA:
           I64[(young<ckGO> + 8)] = ckGO;
           R1 = _sk0X::P64;
           if (R1 & 7 != 0) goto ckGO; else goto ckGP;
       ckGP:
           call (I64[R1])(R1) returns to ckGO, args: 8, res: 8, upd: 8;
       ckGO:
           _sk13::P64 = R1;
           _sk14::P64 = P64[_sk13::P64 + 7];
           I64[(young<ckGU> + 8)] = ckGU;
           R1 = _sk0Y::P64;
           if (R1 & 7 != 0) goto ckGU; else goto ckGV;
       ckGV:
           call (I64[R1])(R1) returns to ckGU, args: 8, res: 8, upd: 8;
       ckGU:
           _sk15::P64 = R1;
           _sk16::P64 = P64[_sk15::P64 + 7];
           I64[(young<ckGZ> + 8)] = ckGZ;
           R1 = _sk0Z::P64;
           if (R1 & 7 != 0) goto ckGZ; else goto ckH0;
       ckH0:
           call (I64[R1])(R1) returns to ckGZ, args: 8, res: 8, upd: 8;
       ckGZ:
           _sk17::P64 = R1;
           _sk18::P64 = P64[_sk17::P64 + 7];
           _sk19::P64 = P64[_sk17::P64 + 15];
           _sk1a::P64 = P64[_sk17::P64 + 23];
           I64[(young<ckH4> + 8)] = ckH4;
           R1 = _sk18::P64;
           if (R1 & 7 != 0) goto ckH4; else goto ckH5;
       ckH5:
           call (I64[R1])(R1) returns to ckH4, args: 8, res: 8, upd: 8;
       ckH4:
           _sk1b::P64 = R1;
           _sk1c::P64 = P64[_sk1b::P64 + 7];
           _sk1d::P64 = P64[_sk1b::P64 + 15];
           _sk1f::P64 = P64[_sk1b::P64 + 23];
           _sk1e::I64 = I64[_sk1b::P64 + 31];
           I64[(young<ckH9> + 8)] = ckH9;
           R1 = _sk1c::P64;
           if (R1 & 7 != 0) goto ckH9; else goto ckHa;
       ckHa:
           call (I64[R1])(R1) returns to ckH9, args: 8, res: 8, upd: 8;
       ckH9:
           _sk1g::P64 = R1;
           _sk1h::I64 = I64[_sk1g::P64 + 7];
           I64[(young<ckHe> + 8)] = ckHe;
           R1 = _sk1d::P64;
           if (R1 & 7 != 0) goto ckHe; else goto ckHf;
       ckHf:
           call (I64[R1])(R1) returns to ckHe, args: 8, res: 8, upd: 8;
       ckHe:
           _sk1i::P64 = R1;
           _sk1j::I64 = I64[_sk1i::P64 + 7];
           I64[(young<ckHj> + 8)] = ckHj;
           R1 = _sk19::P64;
           if (R1 & 7 != 0) goto ckHj; else goto ckHk;
       ckHk:
           call (I64[R1])(R1) returns to ckHj, args: 8, res: 8, upd: 8;
       ckHj:
           _sk1k::P64 = R1;
           _sk1l::P64 = P64[_sk1k::P64 + 7];
           I64[(young<ckHo> + 8)] = ckHo;
           R1 = _sk1a::P64;
           call stg_ap_0_fast(R1) returns to ckHo, args: 8, res: 8, upd: 8;
       ckHo:
           _sk1m::P64 = R1;
           _sk1p::P64 = P64[_sk1m::P64 + 7];
           _sk1n::I64 = I64[_sk1m::P64 + 15];
           _sk1o::I64 = I64[_sk1m::P64 + 23];
           I64[(young<ckHs> + 8)] = ckHs;
           R1 = _sk10::P64;
           if (R1 & 7 != 0) goto ckHs; else goto ckHt;
       ckHt:
           call (I64[R1])(R1) returns to ckHs, args: 8, res: 8, upd: 8;
       ckHs:
           _sk1q::P64 = R1;
           _sk1r::I64 = I64[_sk1q::P64 + 7];
           I64[(young<ckHx> + 8)] = ckHx;
           R1 = _sk11::P64;
           if (R1 & 7 != 0) goto ckHx; else goto ckHK;
       ckHK:
           call (I64[R1])(R1) returns to ckHx, args: 8, res: 8, upd: 8;
       ckHx:
           _sk1s::P64 = R1;
           _sk1t::F64 = F64[_sk1s::P64 + 7];
           R6 = _sk1e::I64;
           R5 = _sk1j::I64;
           R4 = _sk1h::I64;
           R3 = _sk16::P64;
           R2 = _sk14::P64;
           P64[(old + 64)] = _sk1f::P64;
           P64[(old + 56)] = _sk1l::P64;
           I64[(old + 48)] = _sk1n::I64;
           I64[(old + 40)] = _sk1o::I64;
           P64[(old + 32)] = _sk1p::P64;
           I64[(old + 24)] = _sk1r::I64;
           F64[(old + 16)] = _sk1t::F64;
           call Main.$wa1_info(R6, R5, R4, R3, R2) args: 64, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:53.784608 UTC

{offset
  ckGR:
      _sk11::P64 = R6;
      _sk10::P64 = R5;
      _sk0Z::P64 = R4;
      _sk0Y::P64 = R3;
      _sk0X::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckHy; else goto ckHz;
  ckHz:
      if (HpLim == 0) goto ckHy; else goto ckHA;
  ckHy:
      R6 = _sk11::P64;
      R5 = _sk10::P64;
      R4 = _sk0Z::P64;
      R3 = _sk0Y::P64;
      R2 = _sk0X::P64;
      R1 = Main.runRSTMSingle1_closure;
      call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  ckHA:
      I64[(young<ckGO> + 8)] = ckGO;
      R1 = _sk0X::P64;
      if (R1 & 7 != 0) goto ckGO; else goto ckGP;
  ckGP:
      call (I64[R1])(R1) returns to ckGO, args: 8, res: 8, upd: 8;
  ckGO:
      _sk13::P64 = R1;
      _sk14::P64 = P64[_sk13::P64 + 7];
      I64[(young<ckGU> + 8)] = ckGU;
      R1 = _sk0Y::P64;
      if (R1 & 7 != 0) goto ckGU; else goto ckGV;
  ckGV:
      call (I64[R1])(R1) returns to ckGU, args: 8, res: 8, upd: 8;
  ckGU:
      _sk15::P64 = R1;
      _sk16::P64 = P64[_sk15::P64 + 7];
      I64[(young<ckGZ> + 8)] = ckGZ;
      R1 = _sk0Z::P64;
      if (R1 & 7 != 0) goto ckGZ; else goto ckH0;
  ckH0:
      call (I64[R1])(R1) returns to ckGZ, args: 8, res: 8, upd: 8;
  ckGZ:
      _sk17::P64 = R1;
      _sk18::P64 = P64[_sk17::P64 + 7];
      _sk19::P64 = P64[_sk17::P64 + 15];
      _sk1a::P64 = P64[_sk17::P64 + 23];
      I64[(young<ckH4> + 8)] = ckH4;
      R1 = _sk18::P64;
      if (R1 & 7 != 0) goto ckH4; else goto ckH5;
  ckH5:
      call (I64[R1])(R1) returns to ckH4, args: 8, res: 8, upd: 8;
  ckH4:
      _sk1b::P64 = R1;
      _sk1c::P64 = P64[_sk1b::P64 + 7];
      _sk1d::P64 = P64[_sk1b::P64 + 15];
      _sk1f::P64 = P64[_sk1b::P64 + 23];
      _sk1e::I64 = I64[_sk1b::P64 + 31];
      I64[(young<ckH9> + 8)] = ckH9;
      R1 = _sk1c::P64;
      if (R1 & 7 != 0) goto ckH9; else goto ckHa;
  ckHa:
      call (I64[R1])(R1) returns to ckH9, args: 8, res: 8, upd: 8;
  ckH9:
      _sk1g::P64 = R1;
      _sk1h::I64 = I64[_sk1g::P64 + 7];
      I64[(young<ckHe> + 8)] = ckHe;
      R1 = _sk1d::P64;
      if (R1 & 7 != 0) goto ckHe; else goto ckHf;
  ckHf:
      call (I64[R1])(R1) returns to ckHe, args: 8, res: 8, upd: 8;
  ckHe:
      _sk1i::P64 = R1;
      _sk1j::I64 = I64[_sk1i::P64 + 7];
      I64[(young<ckHj> + 8)] = ckHj;
      R1 = _sk19::P64;
      if (R1 & 7 != 0) goto ckHj; else goto ckHk;
  ckHk:
      call (I64[R1])(R1) returns to ckHj, args: 8, res: 8, upd: 8;
  ckHj:
      _sk1k::P64 = R1;
      _sk1l::P64 = P64[_sk1k::P64 + 7];
      I64[(young<ckHo> + 8)] = ckHo;
      R1 = _sk1a::P64;
      call stg_ap_0_fast(R1) returns to ckHo, args: 8, res: 8, upd: 8;
  ckHo:
      _sk1m::P64 = R1;
      _sk1p::P64 = P64[_sk1m::P64 + 7];
      _sk1n::I64 = I64[_sk1m::P64 + 15];
      _sk1o::I64 = I64[_sk1m::P64 + 23];
      I64[(young<ckHs> + 8)] = ckHs;
      R1 = _sk10::P64;
      if (R1 & 7 != 0) goto ckHs; else goto ckHt;
  ckHt:
      call (I64[R1])(R1) returns to ckHs, args: 8, res: 8, upd: 8;
  ckHs:
      _sk1q::P64 = R1;
      _sk1r::I64 = I64[_sk1q::P64 + 7];
      I64[(young<ckHx> + 8)] = ckHx;
      R1 = _sk11::P64;
      if (R1 & 7 != 0) goto ckHx; else goto ckHK;
  ckHK:
      call (I64[R1])(R1) returns to ckHx, args: 8, res: 8, upd: 8;
  ckHx:
      _sk1s::P64 = R1;
      _sk1t::F64 = F64[_sk1s::P64 + 7];
      R6 = _sk1e::I64;
      R5 = _sk1j::I64;
      R4 = _sk1h::I64;
      R3 = _sk16::P64;
      R2 = _sk14::P64;
      P64[(old + 64)] = _sk1f::P64;
      P64[(old + 56)] = _sk1l::P64;
      I64[(old + 48)] = _sk1n::I64;
      I64[(old + 40)] = _sk1o::I64;
      P64[(old + 32)] = _sk1p::P64;
      I64[(old + 24)] = _sk1r::I64;
      F64[(old + 16)] = _sk1t::F64;
      call Main.$wa1_info(R6, R5, R4, R3, R2) args: 64, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:53.790151 UTC

{offset
  ckGR:
      _sk11::P64 = R6;
      _sk10::P64 = R5;
      _sk0Z::P64 = R4;
      _sk0Y::P64 = R3;
      _sk0X::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckHy; else goto ckHz;
  ckHz:
      if (HpLim == 0) goto ckHy; else goto ckHA;
  ckHy:
      R6 = _sk11::P64;
      R5 = _sk10::P64;
      R4 = _sk0Z::P64;
      R3 = _sk0Y::P64;
      R2 = _sk0X::P64;
      R1 = Main.runRSTMSingle1_closure;
      call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  ckHA:
      I64[(young<ckGO> + 8)] = ckGO;
      R1 = _sk0X::P64;
      if (R1 & 7 != 0) goto ckGO; else goto ckGP;
  ckGP:
      call (I64[R1])(R1) returns to ckGO, args: 8, res: 8, upd: 8;
  ckGO:
      _sk13::P64 = R1;
      _sk14::P64 = P64[_sk13::P64 + 7];
      I64[(young<ckGU> + 8)] = ckGU;
      R1 = _sk0Y::P64;
      if (R1 & 7 != 0) goto ckGU; else goto ckGV;
  ckGV:
      call (I64[R1])(R1) returns to ckGU, args: 8, res: 8, upd: 8;
  ckGU:
      _sk15::P64 = R1;
      _sk16::P64 = P64[_sk15::P64 + 7];
      I64[(young<ckGZ> + 8)] = ckGZ;
      R1 = _sk0Z::P64;
      if (R1 & 7 != 0) goto ckGZ; else goto ckH0;
  ckH0:
      call (I64[R1])(R1) returns to ckGZ, args: 8, res: 8, upd: 8;
  ckGZ:
      _sk17::P64 = R1;
      _sk18::P64 = P64[_sk17::P64 + 7];
      _sk19::P64 = P64[_sk17::P64 + 15];
      _sk1a::P64 = P64[_sk17::P64 + 23];
      I64[(young<ckH4> + 8)] = ckH4;
      R1 = _sk18::P64;
      if (R1 & 7 != 0) goto ckH4; else goto ckH5;
  ckH5:
      call (I64[R1])(R1) returns to ckH4, args: 8, res: 8, upd: 8;
  ckH4:
      _sk1b::P64 = R1;
      _sk1c::P64 = P64[_sk1b::P64 + 7];
      _sk1d::P64 = P64[_sk1b::P64 + 15];
      _sk1f::P64 = P64[_sk1b::P64 + 23];
      _sk1e::I64 = I64[_sk1b::P64 + 31];
      I64[(young<ckH9> + 8)] = ckH9;
      R1 = _sk1c::P64;
      if (R1 & 7 != 0) goto ckH9; else goto ckHa;
  ckHa:
      call (I64[R1])(R1) returns to ckH9, args: 8, res: 8, upd: 8;
  ckH9:
      _sk1g::P64 = R1;
      _sk1h::I64 = I64[_sk1g::P64 + 7];
      I64[(young<ckHe> + 8)] = ckHe;
      R1 = _sk1d::P64;
      if (R1 & 7 != 0) goto ckHe; else goto ckHf;
  ckHf:
      call (I64[R1])(R1) returns to ckHe, args: 8, res: 8, upd: 8;
  ckHe:
      _sk1i::P64 = R1;
      _sk1j::I64 = I64[_sk1i::P64 + 7];
      I64[(young<ckHj> + 8)] = ckHj;
      R1 = _sk19::P64;
      if (R1 & 7 != 0) goto ckHj; else goto ckHk;
  ckHk:
      call (I64[R1])(R1) returns to ckHj, args: 8, res: 8, upd: 8;
  ckHj:
      _sk1k::P64 = R1;
      _sk1l::P64 = P64[_sk1k::P64 + 7];
      I64[(young<ckHo> + 8)] = ckHo;
      R1 = _sk1a::P64;
      call stg_ap_0_fast(R1) returns to ckHo, args: 8, res: 8, upd: 8;
  ckHo:
      _sk1m::P64 = R1;
      _sk1p::P64 = P64[_sk1m::P64 + 7];
      _sk1n::I64 = I64[_sk1m::P64 + 15];
      _sk1o::I64 = I64[_sk1m::P64 + 23];
      I64[(young<ckHs> + 8)] = ckHs;
      R1 = _sk10::P64;
      if (R1 & 7 != 0) goto ckHs; else goto ckHt;
  ckHt:
      call (I64[R1])(R1) returns to ckHs, args: 8, res: 8, upd: 8;
  ckHs:
      _sk1q::P64 = R1;
      _sk1r::I64 = I64[_sk1q::P64 + 7];
      I64[(young<ckHx> + 8)] = ckHx;
      R1 = _sk11::P64;
      if (R1 & 7 != 0) goto ckHx; else goto ckHK;
  ckHK:
      call (I64[R1])(R1) returns to ckHx, args: 8, res: 8, upd: 8;
  ckHx:
      _sk1s::P64 = R1;
      _sk1t::F64 = F64[_sk1s::P64 + 7];
      R6 = _sk1e::I64;
      R5 = _sk1j::I64;
      R4 = _sk1h::I64;
      R3 = _sk16::P64;
      R2 = _sk14::P64;
      P64[(old + 64)] = _sk1f::P64;
      P64[(old + 56)] = _sk1l::P64;
      I64[(old + 48)] = _sk1n::I64;
      I64[(old + 40)] = _sk1o::I64;
      P64[(old + 32)] = _sk1p::P64;
      I64[(old + 24)] = _sk1r::I64;
      F64[(old + 16)] = _sk1t::F64;
      call Main.$wa1_info(R6, R5, R4, R3, R2) args: 64, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:53.79578 UTC

{offset
  ckGR:
      _sk11::P64 = R6;
      _sk10::P64 = R5;
      _sk0Z::P64 = R4;
      _sk0Y::P64 = R3;
      _sk0X::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckHy; else goto ckHz;
  ckHz:
      if (HpLim == 0) goto ckHy; else goto ckHA;
  ckHy:
      R6 = _sk11::P64;
      R5 = _sk10::P64;
      R4 = _sk0Z::P64;
      R3 = _sk0Y::P64;
      R2 = _sk0X::P64;
      R1 = Main.runRSTMSingle1_closure;
      call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  ckHA:
      I64[(young<ckGO> + 8)] = ckGO;
      R1 = _sk0X::P64;
      if (R1 & 7 != 0) goto ckGO; else goto ckGP;
  ckGP:
      call (I64[R1])(R1) returns to ckGO, args: 8, res: 8, upd: 8;
  ckGO:
      _sk13::P64 = R1;
      _sk14::P64 = P64[_sk13::P64 + 7];
      I64[(young<ckGU> + 8)] = ckGU;
      R1 = _sk0Y::P64;
      if (R1 & 7 != 0) goto ckGU; else goto ckGV;
  ckGV:
      call (I64[R1])(R1) returns to ckGU, args: 8, res: 8, upd: 8;
  ckGU:
      _sk15::P64 = R1;
      _sk16::P64 = P64[_sk15::P64 + 7];
      I64[(young<ckGZ> + 8)] = ckGZ;
      R1 = _sk0Z::P64;
      if (R1 & 7 != 0) goto ckGZ; else goto ckH0;
  ckH0:
      call (I64[R1])(R1) returns to ckGZ, args: 8, res: 8, upd: 8;
  ckGZ:
      _sk17::P64 = R1;
      _sk18::P64 = P64[_sk17::P64 + 7];
      _sk19::P64 = P64[_sk17::P64 + 15];
      _sk1a::P64 = P64[_sk17::P64 + 23];
      I64[(young<ckH4> + 8)] = ckH4;
      R1 = _sk18::P64;
      if (R1 & 7 != 0) goto ckH4; else goto ckH5;
  ckH5:
      call (I64[R1])(R1) returns to ckH4, args: 8, res: 8, upd: 8;
  ckH4:
      _sk1b::P64 = R1;
      _sk1c::P64 = P64[_sk1b::P64 + 7];
      _sk1d::P64 = P64[_sk1b::P64 + 15];
      _sk1f::P64 = P64[_sk1b::P64 + 23];
      _sk1e::I64 = I64[_sk1b::P64 + 31];
      I64[(young<ckH9> + 8)] = ckH9;
      R1 = _sk1c::P64;
      if (R1 & 7 != 0) goto ckH9; else goto ckHa;
  ckHa:
      call (I64[R1])(R1) returns to ckH9, args: 8, res: 8, upd: 8;
  ckH9:
      _sk1g::P64 = R1;
      _sk1h::I64 = I64[_sk1g::P64 + 7];
      I64[(young<ckHe> + 8)] = ckHe;
      R1 = _sk1d::P64;
      if (R1 & 7 != 0) goto ckHe; else goto ckHf;
  ckHf:
      call (I64[R1])(R1) returns to ckHe, args: 8, res: 8, upd: 8;
  ckHe:
      _sk1i::P64 = R1;
      _sk1j::I64 = I64[_sk1i::P64 + 7];
      I64[(young<ckHj> + 8)] = ckHj;
      R1 = _sk19::P64;
      if (R1 & 7 != 0) goto ckHj; else goto ckHk;
  ckHk:
      call (I64[R1])(R1) returns to ckHj, args: 8, res: 8, upd: 8;
  ckHj:
      _sk1k::P64 = R1;
      _sk1l::P64 = P64[_sk1k::P64 + 7];
      I64[(young<ckHo> + 8)] = ckHo;
      R1 = _sk1a::P64;
      call stg_ap_0_fast(R1) returns to ckHo, args: 8, res: 8, upd: 8;
  ckHo:
      _sk1m::P64 = R1;
      _sk1p::P64 = P64[_sk1m::P64 + 7];
      _sk1n::I64 = I64[_sk1m::P64 + 15];
      _sk1o::I64 = I64[_sk1m::P64 + 23];
      I64[(young<ckHs> + 8)] = ckHs;
      R1 = _sk10::P64;
      if (R1 & 7 != 0) goto ckHs; else goto ckHt;
  ckHt:
      call (I64[R1])(R1) returns to ckHs, args: 8, res: 8, upd: 8;
  ckHs:
      _sk1q::P64 = R1;
      _sk1r::I64 = I64[_sk1q::P64 + 7];
      I64[(young<ckHx> + 8)] = ckHx;
      R1 = _sk11::P64;
      if (R1 & 7 != 0) goto ckHx; else goto ckHK;
  ckHK:
      call (I64[R1])(R1) returns to ckHx, args: 8, res: 8, upd: 8;
  ckHx:
      _sk1s::P64 = R1;
      _sk1t::F64 = F64[_sk1s::P64 + 7];
      R6 = _sk1e::I64;
      R5 = _sk1j::I64;
      R4 = _sk1h::I64;
      R3 = _sk16::P64;
      R2 = _sk14::P64;
      P64[(old + 64)] = _sk1f::P64;
      P64[(old + 56)] = _sk1l::P64;
      I64[(old + 48)] = _sk1n::I64;
      I64[(old + 40)] = _sk1o::I64;
      P64[(old + 32)] = _sk1p::P64;
      I64[(old + 24)] = _sk1r::I64;
      F64[(old + 16)] = _sk1t::F64;
      call Main.$wa1_info(R6, R5, R4, R3, R2) args: 64, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:53.802168 UTC

{offset
  ckGR:
      _sk11::P64 = R6;
      _sk10::P64 = R5;
      _sk0Z::P64 = R4;
      _sk0Y::P64 = R3;
      _sk0X::P64 = R2;
      if ((Sp + 8) - 104 < SpLim) goto ckHy; else goto ckHz;
  ckHz:
      if (HpLim == 0) goto ckHy; else goto ckHA;
  ckHy:
      R6 = _sk11::P64;
      R5 = _sk10::P64;
      R4 = _sk0Z::P64;
      R3 = _sk0Y::P64;
      R2 = _sk0X::P64;
      R1 = Main.runRSTMSingle1_closure;
      call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  ckHA:
      I64[Sp - 40] = ckGO;
      R1 = _sk0X::P64;
      P64[Sp - 32] = _sk0Y::P64;
      P64[Sp - 24] = _sk0Z::P64;
      P64[Sp - 16] = _sk10::P64;
      P64[Sp - 8] = _sk11::P64;
      Sp = Sp - 40;
      if (R1 & 7 != 0) goto ckGO; else goto ckGP;
  ckGP:
      call (I64[R1])(R1) returns to ckGO, args: 8, res: 8, upd: 8;
  ckGO:
      _sk0Y::P64 = P64[Sp + 8];
      _sk0Z::P64 = P64[Sp + 16];
      _sk10::P64 = P64[Sp + 24];
      _sk11::P64 = P64[Sp + 32];
      _sk13::P64 = R1;
      _sk14::P64 = P64[_sk13::P64 + 7];
      I64[Sp] = ckGU;
      R1 = _sk0Y::P64;
      P64[Sp + 8] = _sk14::P64;
      if (R1 & 7 != 0) goto ckGU; else goto ckGV;
  ckGV:
      call (I64[R1])(R1) returns to ckGU, args: 8, res: 8, upd: 8;
  ckGU:
      _sk0Z::P64 = P64[Sp + 16];
      _sk10::P64 = P64[Sp + 24];
      _sk11::P64 = P64[Sp + 32];
      _sk14::P64 = P64[Sp + 8];
      _sk15::P64 = R1;
      _sk16::P64 = P64[_sk15::P64 + 7];
      I64[Sp] = ckGZ;
      R1 = _sk0Z::P64;
      P64[Sp + 16] = _sk16::P64;
      if (R1 & 7 != 0) goto ckGZ; else goto ckH0;
  ckH0:
      call (I64[R1])(R1) returns to ckGZ, args: 8, res: 8, upd: 8;
  ckGZ:
      _sk10::P64 = P64[Sp + 24];
      _sk11::P64 = P64[Sp + 32];
      _sk14::P64 = P64[Sp + 8];
      _sk16::P64 = P64[Sp + 16];
      _sk17::P64 = R1;
      _sk18::P64 = P64[_sk17::P64 + 7];
      _sk19::P64 = P64[_sk17::P64 + 15];
      _sk1a::P64 = P64[_sk17::P64 + 23];
      I64[Sp - 16] = ckH4;
      R1 = _sk18::P64;
      P64[Sp - 8] = _sk1a::P64;
      P64[Sp] = _sk19::P64;
      Sp = Sp - 16;
      if (R1 & 7 != 0) goto ckH4; else goto ckH5;
  ckH5:
      call (I64[R1])(R1) returns to ckH4, args: 8, res: 8, upd: 8;
  ckH4:
      _sk10::P64 = P64[Sp + 40];
      _sk11::P64 = P64[Sp + 48];
      _sk14::P64 = P64[Sp + 24];
      _sk16::P64 = P64[Sp + 32];
      _sk19::P64 = P64[Sp + 16];
      _sk1a::P64 = P64[Sp + 8];
      _sk1b::P64 = R1;
      _sk1c::P64 = P64[_sk1b::P64 + 7];
      _sk1d::P64 = P64[_sk1b::P64 + 15];
      _sk1f::P64 = P64[_sk1b::P64 + 23];
      _sk1e::I64 = I64[_sk1b::P64 + 31];
      I64[Sp - 24] = ckH9;
      R1 = _sk1c::P64;
      I64[Sp - 16] = _sk1e::I64;
      P64[Sp - 8] = _sk1f::P64;
      P64[Sp] = _sk1d::P64;
      Sp = Sp - 24;
      if (R1 & 7 != 0) goto ckH9; else goto ckHa;
  ckHa:
      call (I64[R1])(R1) returns to ckH9, args: 8, res: 8, upd: 8;
  ckH9:
      _sk10::P64 = P64[Sp + 64];
      _sk11::P64 = P64[Sp + 72];
      _sk14::P64 = P64[Sp + 48];
      _sk16::P64 = P64[Sp + 56];
      _sk19::P64 = P64[Sp + 40];
      _sk1a::P64 = P64[Sp + 32];
      _sk1d::P64 = P64[Sp + 24];
      _sk1e::I64 = I64[Sp + 8];
      _sk1f::P64 = P64[Sp + 16];
      _sk1g::P64 = R1;
      _sk1h::I64 = I64[_sk1g::P64 + 7];
      I64[Sp] = ckHe;
      R1 = _sk1d::P64;
      I64[Sp + 24] = _sk1h::I64;
      if (R1 & 7 != 0) goto ckHe; else goto ckHf;
  ckHf:
      call (I64[R1])(R1) returns to ckHe, args: 8, res: 8, upd: 8;
  ckHe:
      _sk10::P64 = P64[Sp + 64];
      _sk11::P64 = P64[Sp + 72];
      _sk14::P64 = P64[Sp + 48];
      _sk16::P64 = P64[Sp + 56];
      _sk19::P64 = P64[Sp + 40];
      _sk1a::P64 = P64[Sp + 32];
      _sk1e::I64 = I64[Sp + 8];
      _sk1f::P64 = P64[Sp + 16];
      _sk1h::I64 = I64[Sp + 24];
      _sk1i::P64 = R1;
      _sk1j::I64 = I64[_sk1i::P64 + 7];
      I64[Sp] = ckHj;
      R1 = _sk19::P64;
      I64[Sp + 40] = _sk1j::I64;
      if (R1 & 7 != 0) goto ckHj; else goto ckHk;
  ckHk:
      call (I64[R1])(R1) returns to ckHj, args: 8, res: 8, upd: 8;
  ckHj:
      _sk10::P64 = P64[Sp + 64];
      _sk11::P64 = P64[Sp + 72];
      _sk14::P64 = P64[Sp + 48];
      _sk16::P64 = P64[Sp + 56];
      _sk1a::P64 = P64[Sp + 32];
      _sk1e::I64 = I64[Sp + 8];
      _sk1f::P64 = P64[Sp + 16];
      _sk1h::I64 = I64[Sp + 24];
      _sk1j::I64 = I64[Sp + 40];
      _sk1k::P64 = R1;
      _sk1l::P64 = P64[_sk1k::P64 + 7];
      I64[Sp] = ckHo;
      R1 = _sk1a::P64;
      P64[Sp + 32] = _sk1l::P64;
      call stg_ap_0_fast(R1) returns to ckHo, args: 8, res: 8, upd: 8;
  ckHo:
      _sk10::P64 = P64[Sp + 64];
      _sk11::P64 = P64[Sp + 72];
      _sk14::P64 = P64[Sp + 48];
      _sk16::P64 = P64[Sp + 56];
      _sk1e::I64 = I64[Sp + 8];
      _sk1f::P64 = P64[Sp + 16];
      _sk1h::I64 = I64[Sp + 24];
      _sk1j::I64 = I64[Sp + 40];
      _sk1l::P64 = P64[Sp + 32];
      _sk1m::P64 = R1;
      _sk1p::P64 = P64[_sk1m::P64 + 7];
      _sk1n::I64 = I64[_sk1m::P64 + 15];
      _sk1o::I64 = I64[_sk1m::P64 + 23];
      I64[Sp - 16] = ckHs;
      R1 = _sk10::P64;
      P64[Sp - 8] = _sk1p::P64;
      I64[Sp] = _sk1o::I64;
      I64[Sp + 64] = _sk1n::I64;
      Sp = Sp - 16;
      if (R1 & 7 != 0) goto ckHs; else goto ckHt;
  ckHt:
      call (I64[R1])(R1) returns to ckHs, args: 8, res: 8, upd: 8;
  ckHs:
      _sk11::P64 = P64[Sp + 88];
      _sk14::P64 = P64[Sp + 64];
      _sk16::P64 = P64[Sp + 72];
      _sk1e::I64 = I64[Sp + 24];
      _sk1f::P64 = P64[Sp + 32];
      _sk1h::I64 = I64[Sp + 40];
      _sk1j::I64 = I64[Sp + 56];
      _sk1l::P64 = P64[Sp + 48];
      _sk1n::I64 = I64[Sp + 80];
      _sk1o::I64 = I64[Sp + 16];
      _sk1p::P64 = P64[Sp + 8];
      _sk1q::P64 = R1;
      _sk1r::I64 = I64[_sk1q::P64 + 7];
      I64[Sp] = ckHx;
      R1 = _sk11::P64;
      I64[Sp + 88] = _sk1r::I64;
      if (R1 & 7 != 0) goto ckHx; else goto ckHK;
  ckHK:
      call (I64[R1])(R1) returns to ckHx, args: 8, res: 8, upd: 8;
  ckHx:
      _sk14::P64 = P64[Sp + 64];
      _sk16::P64 = P64[Sp + 72];
      _sk1e::I64 = I64[Sp + 24];
      _sk1f::P64 = P64[Sp + 32];
      _sk1h::I64 = I64[Sp + 40];
      _sk1j::I64 = I64[Sp + 56];
      _sk1l::P64 = P64[Sp + 48];
      _sk1n::I64 = I64[Sp + 80];
      _sk1o::I64 = I64[Sp + 16];
      _sk1p::P64 = P64[Sp + 8];
      _sk1r::I64 = I64[Sp + 88];
      _sk1s::P64 = R1;
      _sk1t::F64 = F64[_sk1s::P64 + 7];
      R6 = _sk1e::I64;
      R5 = _sk1j::I64;
      R4 = _sk1h::I64;
      R3 = _sk16::P64;
      R2 = _sk14::P64;
      P64[Sp + 40] = _sk1f::P64;
      I64[Sp + 56] = _sk1n::I64;
      I64[Sp + 64] = _sk1o::I64;
      P64[Sp + 72] = _sk1p::P64;
      I64[Sp + 80] = _sk1r::I64;
      F64[Sp + 88] = _sk1t::F64;
      Sp = Sp + 40;
      call Main.$wa1_info(R6, R5, R4, R3, R2) args: 64, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:53.812942 UTC

{offset
  ckGR:
      _sk11::P64 = R6;
      _sk10::P64 = R5;
      _sk0Z::P64 = R4;
      _sk0Y::P64 = R3;
      _sk0X::P64 = R2;
      if ((Sp + -96) < SpLim) goto ckHy; else goto ckHz;
  ckHz:
      if (HpLim == 0) goto ckHy; else goto ckHA;
  ckHy:
      R6 = _sk11::P64;
      R5 = _sk10::P64;
      R4 = _sk0Z::P64;
      R3 = _sk0Y::P64;
      R2 = _sk0X::P64;
      R1 = Main.runRSTMSingle1_closure;
      call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  ckHA:
      I64[Sp - 40] = ckGO;
      R1 = _sk0X::P64;
      P64[Sp - 32] = _sk0Y::P64;
      P64[Sp - 24] = _sk0Z::P64;
      P64[Sp - 16] = _sk10::P64;
      P64[Sp - 8] = _sk11::P64;
      Sp = Sp - 40;
      if (R1 & 7 != 0) goto ckGO; else goto ckGP;
  ckGP:
      call (I64[R1])(R1) returns to ckGO, args: 8, res: 8, upd: 8;
  ckGO:
      I64[Sp] = ckGU;
      _sk14::P64 = P64[R1 + 7];
      R1 = P64[Sp + 8];
      P64[Sp + 8] = _sk14::P64;
      if (R1 & 7 != 0) goto ckGU; else goto ckGV;
  ckGV:
      call (I64[R1])(R1) returns to ckGU, args: 8, res: 8, upd: 8;
  ckGU:
      I64[Sp] = ckGZ;
      _sk16::P64 = P64[R1 + 7];
      R1 = P64[Sp + 16];
      P64[Sp + 16] = _sk16::P64;
      if (R1 & 7 != 0) goto ckGZ; else goto ckH0;
  ckH0:
      call (I64[R1])(R1) returns to ckGZ, args: 8, res: 8, upd: 8;
  ckGZ:
      I64[Sp - 16] = ckH4;
      _sk19::P64 = P64[R1 + 15];
      _sk1a::P64 = P64[R1 + 23];
      R1 = P64[R1 + 7];
      P64[Sp - 8] = _sk1a::P64;
      P64[Sp] = _sk19::P64;
      Sp = Sp - 16;
      if (R1 & 7 != 0) goto ckH4; else goto ckH5;
  ckH5:
      call (I64[R1])(R1) returns to ckH4, args: 8, res: 8, upd: 8;
  ckH4:
      I64[Sp - 24] = ckH9;
      _sk1d::P64 = P64[R1 + 15];
      _sk1f::P64 = P64[R1 + 23];
      _sk1e::I64 = I64[R1 + 31];
      R1 = P64[R1 + 7];
      I64[Sp - 16] = _sk1e::I64;
      P64[Sp - 8] = _sk1f::P64;
      P64[Sp] = _sk1d::P64;
      Sp = Sp - 24;
      if (R1 & 7 != 0) goto ckH9; else goto ckHa;
  ckHa:
      call (I64[R1])(R1) returns to ckH9, args: 8, res: 8, upd: 8;
  ckH9:
      I64[Sp] = ckHe;
      _sk1h::I64 = I64[R1 + 7];
      R1 = P64[Sp + 24];
      I64[Sp + 24] = _sk1h::I64;
      if (R1 & 7 != 0) goto ckHe; else goto ckHf;
  ckHf:
      call (I64[R1])(R1) returns to ckHe, args: 8, res: 8, upd: 8;
  ckHe:
      I64[Sp] = ckHj;
      _sk1j::I64 = I64[R1 + 7];
      R1 = P64[Sp + 40];
      I64[Sp + 40] = _sk1j::I64;
      if (R1 & 7 != 0) goto ckHj; else goto ckHk;
  ckHk:
      call (I64[R1])(R1) returns to ckHj, args: 8, res: 8, upd: 8;
  ckHj:
      I64[Sp] = ckHo;
      _sk1l::P64 = P64[R1 + 7];
      R1 = P64[Sp + 32];
      P64[Sp + 32] = _sk1l::P64;
      call stg_ap_0_fast(R1) returns to ckHo, args: 8, res: 8, upd: 8;
  ckHo:
      I64[Sp - 16] = ckHs;
      _sk1p::P64 = P64[R1 + 7];
      _sk1n::I64 = I64[R1 + 15];
      _sk1o::I64 = I64[R1 + 23];
      R1 = P64[Sp + 64];
      P64[Sp - 8] = _sk1p::P64;
      I64[Sp] = _sk1o::I64;
      I64[Sp + 64] = _sk1n::I64;
      Sp = Sp - 16;
      if (R1 & 7 != 0) goto ckHs; else goto ckHt;
  ckHt:
      call (I64[R1])(R1) returns to ckHs, args: 8, res: 8, upd: 8;
  ckHs:
      I64[Sp] = ckHx;
      _sk1r::I64 = I64[R1 + 7];
      R1 = P64[Sp + 88];
      I64[Sp + 88] = _sk1r::I64;
      if (R1 & 7 != 0) goto ckHx; else goto ckHK;
  ckHK:
      call (I64[R1])(R1) returns to ckHx, args: 8, res: 8, upd: 8;
  ckHx:
      R6 = I64[Sp + 24];
      R5 = I64[Sp + 56];
      R4 = I64[Sp + 40];
      R3 = P64[Sp + 72];
      R2 = P64[Sp + 64];
      P64[Sp + 40] = P64[Sp + 32];
      I64[Sp + 56] = I64[Sp + 80];
      I64[Sp + 64] = I64[Sp + 16];
      P64[Sp + 72] = P64[Sp + 8];
      I64[Sp + 80] = I64[Sp + 88];
      F64[Sp + 88] = F64[R1 + 7];
      Sp = Sp + 40;
      call Main.$wa1_info(R6, R5, R4, R3, R2) args: 64, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:53.820631 UTC

[(ckGO, {Main.$wa1_closure}), (ckGP, {Main.$wa1_closure}),
 (ckGR, {Main.$wa1_closure, Main.runRSTMSingle1_closure}),
 (ckGU, {Main.$wa1_closure}), (ckGV, {Main.$wa1_closure}),
 (ckGZ, {Main.$wa1_closure}), (ckH0, {Main.$wa1_closure}),
 (ckH4, {Main.$wa1_closure}), (ckH5, {Main.$wa1_closure}),
 (ckH9, {Main.$wa1_closure}), (ckHa, {Main.$wa1_closure}),
 (ckHe, {Main.$wa1_closure}), (ckHf, {Main.$wa1_closure}),
 (ckHj, {Main.$wa1_closure}), (ckHk, {Main.$wa1_closure}),
 (ckHo, {Main.$wa1_closure}), (ckHs, {Main.$wa1_closure}),
 (ckHt, {Main.$wa1_closure}), (ckHx, {Main.$wa1_closure}),
 (ckHy, {Main.runRSTMSingle1_closure}),
 (ckHz, {Main.$wa1_closure, Main.runRSTMSingle1_closure}),
 (ckHA, {Main.$wa1_closure}), (ckHK, {Main.$wa1_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:53.822181 UTC

Main.runRSTMSingle1_entry() //  [R6, R5, R4, R3, R2]
        { info_tbl: [(ckGO,
                      label: block_ckGO_info
                      rep:StackRep [False, False, False, False]),
                     (ckGR,
                      label: Main.runRSTMSingle1_info
                      rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} }),
                     (ckGU,
                      label: block_ckGU_info
                      rep:StackRep [False, False, False, False]),
                     (ckGZ,
                      label: block_ckGZ_info
                      rep:StackRep [False, False, False, False]),
                     (ckH4,
                      label: block_ckH4_info
                      rep:StackRep [False, False, False, False, False, False]),
                     (ckH9,
                      label: block_ckH9_info
                      rep:StackRep [True, False, False, False, False, False, False,
                                    False, False]),
                     (ckHe,
                      label: block_ckHe_info
                      rep:StackRep [True, False, True, False, False, False, False, False,
                                    False]),
                     (ckHj,
                      label: block_ckHj_info
                      rep:StackRep [True, False, True, False, True, False, False, False,
                                    False]),
                     (ckHo,
                      label: block_ckHo_info
                      rep:StackRep [True, False, True, False, True, False, False, False,
                                    False]),
                     (ckHs,
                      label: block_ckHs_info
                      rep:StackRep [False, True, True, False, True, False, True, False,
                                    False, True, False]),
                     (ckHx,
                      label: block_ckHx_info
                      rep:StackRep [False, True, True, False, True, False, True, False,
                                    False, True, True])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckGR:
          _sk11::P64 = R6;
          _sk10::P64 = R5;
          _sk0Z::P64 = R4;
          _sk0Y::P64 = R3;
          _sk0X::P64 = R2;
          if ((Sp + -96) < SpLim) goto ckHy; else goto ckHz;
      ckHz:
          if (HpLim == 0) goto ckHy; else goto ckHA;
      ckHy:
          R6 = _sk11::P64;
          R5 = _sk10::P64;
          R4 = _sk0Z::P64;
          R3 = _sk0Y::P64;
          R2 = _sk0X::P64;
          R1 = Main.runRSTMSingle1_closure;
          call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
      ckHA:
          I64[Sp - 40] = ckGO;
          R1 = _sk0X::P64;
          P64[Sp - 32] = _sk0Y::P64;
          P64[Sp - 24] = _sk0Z::P64;
          P64[Sp - 16] = _sk10::P64;
          P64[Sp - 8] = _sk11::P64;
          Sp = Sp - 40;
          if (R1 & 7 != 0) goto ckGO; else goto ckGP;
      ckGP:
          call (I64[R1])(R1) returns to ckGO, args: 8, res: 8, upd: 8;
      ckGO:
          I64[Sp] = ckGU;
          _sk14::P64 = P64[R1 + 7];
          R1 = P64[Sp + 8];
          P64[Sp + 8] = _sk14::P64;
          if (R1 & 7 != 0) goto ckGU; else goto ckGV;
      ckGV:
          call (I64[R1])(R1) returns to ckGU, args: 8, res: 8, upd: 8;
      ckGU:
          I64[Sp] = ckGZ;
          _sk16::P64 = P64[R1 + 7];
          R1 = P64[Sp + 16];
          P64[Sp + 16] = _sk16::P64;
          if (R1 & 7 != 0) goto ckGZ; else goto ckH0;
      ckH0:
          call (I64[R1])(R1) returns to ckGZ, args: 8, res: 8, upd: 8;
      ckGZ:
          I64[Sp - 16] = ckH4;
          _sk19::P64 = P64[R1 + 15];
          _sk1a::P64 = P64[R1 + 23];
          R1 = P64[R1 + 7];
          P64[Sp - 8] = _sk1a::P64;
          P64[Sp] = _sk19::P64;
          Sp = Sp - 16;
          if (R1 & 7 != 0) goto ckH4; else goto ckH5;
      ckH5:
          call (I64[R1])(R1) returns to ckH4, args: 8, res: 8, upd: 8;
      ckH4:
          I64[Sp - 24] = ckH9;
          _sk1d::P64 = P64[R1 + 15];
          _sk1f::P64 = P64[R1 + 23];
          _sk1e::I64 = I64[R1 + 31];
          R1 = P64[R1 + 7];
          I64[Sp - 16] = _sk1e::I64;
          P64[Sp - 8] = _sk1f::P64;
          P64[Sp] = _sk1d::P64;
          Sp = Sp - 24;
          if (R1 & 7 != 0) goto ckH9; else goto ckHa;
      ckHa:
          call (I64[R1])(R1) returns to ckH9, args: 8, res: 8, upd: 8;
      ckH9:
          I64[Sp] = ckHe;
          _sk1h::I64 = I64[R1 + 7];
          R1 = P64[Sp + 24];
          I64[Sp + 24] = _sk1h::I64;
          if (R1 & 7 != 0) goto ckHe; else goto ckHf;
      ckHf:
          call (I64[R1])(R1) returns to ckHe, args: 8, res: 8, upd: 8;
      ckHe:
          I64[Sp] = ckHj;
          _sk1j::I64 = I64[R1 + 7];
          R1 = P64[Sp + 40];
          I64[Sp + 40] = _sk1j::I64;
          if (R1 & 7 != 0) goto ckHj; else goto ckHk;
      ckHk:
          call (I64[R1])(R1) returns to ckHj, args: 8, res: 8, upd: 8;
      ckHj:
          I64[Sp] = ckHo;
          _sk1l::P64 = P64[R1 + 7];
          R1 = P64[Sp + 32];
          P64[Sp + 32] = _sk1l::P64;
          call stg_ap_0_fast(R1) returns to ckHo, args: 8, res: 8, upd: 8;
      ckHo:
          I64[Sp - 16] = ckHs;
          _sk1p::P64 = P64[R1 + 7];
          _sk1n::I64 = I64[R1 + 15];
          _sk1o::I64 = I64[R1 + 23];
          R1 = P64[Sp + 64];
          P64[Sp - 8] = _sk1p::P64;
          I64[Sp] = _sk1o::I64;
          I64[Sp + 64] = _sk1n::I64;
          Sp = Sp - 16;
          if (R1 & 7 != 0) goto ckHs; else goto ckHt;
      ckHt:
          call (I64[R1])(R1) returns to ckHs, args: 8, res: 8, upd: 8;
      ckHs:
          I64[Sp] = ckHx;
          _sk1r::I64 = I64[R1 + 7];
          R1 = P64[Sp + 88];
          I64[Sp + 88] = _sk1r::I64;
          if (R1 & 7 != 0) goto ckHx; else goto ckHK;
      ckHK:
          call (I64[R1])(R1) returns to ckHx, args: 8, res: 8, upd: 8;
      ckHx:
          R6 = I64[Sp + 24];
          R5 = I64[Sp + 56];
          R4 = I64[Sp + 40];
          R3 = P64[Sp + 72];
          R2 = P64[Sp + 64];
          P64[Sp + 40] = P64[Sp + 32];
          I64[Sp + 56] = I64[Sp + 80];
          I64[Sp + 64] = I64[Sp + 16];
          P64[Sp + 72] = P64[Sp + 8];
          I64[Sp + 80] = I64[Sp + 88];
          F64[Sp + 88] = F64[R1 + 7];
          Sp = Sp + 40;
          call Main.$wa1_info(R6, R5, R4, R3, R2) args: 64, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:53.831736 UTC

Main.runRSTMSingle1_entry() //  [R6, R5, R4, R3, R2]
        { info_tbl: [(ckGO,
                      label: block_ckGO_info
                      rep:StackRep [False, False, False, False]),
                     (ckGR,
                      label: Main.runRSTMSingle1_info
                      rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} }),
                     (ckGU,
                      label: block_ckGU_info
                      rep:StackRep [False, False, False, False]),
                     (ckGZ,
                      label: block_ckGZ_info
                      rep:StackRep [False, False, False, False]),
                     (ckH4,
                      label: block_ckH4_info
                      rep:StackRep [False, False, False, False, False, False]),
                     (ckH9,
                      label: block_ckH9_info
                      rep:StackRep [True, False, False, False, False, False, False,
                                    False, False]),
                     (ckHe,
                      label: block_ckHe_info
                      rep:StackRep [True, False, True, False, False, False, False, False,
                                    False]),
                     (ckHj,
                      label: block_ckHj_info
                      rep:StackRep [True, False, True, False, True, False, False, False,
                                    False]),
                     (ckHo,
                      label: block_ckHo_info
                      rep:StackRep [True, False, True, False, True, False, False, False,
                                    False]),
                     (ckHs,
                      label: block_ckHs_info
                      rep:StackRep [False, True, True, False, True, False, True, False,
                                    False, True, False]),
                     (ckHx,
                      label: block_ckHx_info
                      rep:StackRep [False, True, True, False, True, False, True, False,
                                    False, True, True])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckGR:
          _sk11::P64 = R6;
          _sk10::P64 = R5;
          _sk0Z::P64 = R4;
          _sk0Y::P64 = R3;
          _sk0X::P64 = R2;
          if ((Sp + -96) < SpLim) goto ckHy; else goto ckHz;
      ckHz:
          if (HpLim == 0) goto ckHy; else goto ckHA;
      ckHy:
          R6 = _sk11::P64;
          R5 = _sk10::P64;
          R4 = _sk0Z::P64;
          R3 = _sk0Y::P64;
          R2 = _sk0X::P64;
          R1 = Main.runRSTMSingle1_closure;
          call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
      ckHA:
          I64[Sp - 40] = ckGO;
          R1 = _sk0X::P64;
          P64[Sp - 32] = _sk0Y::P64;
          P64[Sp - 24] = _sk0Z::P64;
          P64[Sp - 16] = _sk10::P64;
          P64[Sp - 8] = _sk11::P64;
          Sp = Sp - 40;
          if (R1 & 7 != 0) goto ckGO; else goto ckGP;
      ckGP:
          call (I64[R1])(R1) returns to ckGO, args: 8, res: 8, upd: 8;
      ckGO:
          I64[Sp] = ckGU;
          _sk14::P64 = P64[R1 + 7];
          R1 = P64[Sp + 8];
          P64[Sp + 8] = _sk14::P64;
          if (R1 & 7 != 0) goto ckGU; else goto ckGV;
      ckGV:
          call (I64[R1])(R1) returns to ckGU, args: 8, res: 8, upd: 8;
      ckGU:
          I64[Sp] = ckGZ;
          _sk16::P64 = P64[R1 + 7];
          R1 = P64[Sp + 16];
          P64[Sp + 16] = _sk16::P64;
          if (R1 & 7 != 0) goto ckGZ; else goto ckH0;
      ckH0:
          call (I64[R1])(R1) returns to ckGZ, args: 8, res: 8, upd: 8;
      ckGZ:
          I64[Sp - 16] = ckH4;
          _sk19::P64 = P64[R1 + 15];
          _sk1a::P64 = P64[R1 + 23];
          R1 = P64[R1 + 7];
          P64[Sp - 8] = _sk1a::P64;
          P64[Sp] = _sk19::P64;
          Sp = Sp - 16;
          if (R1 & 7 != 0) goto ckH4; else goto ckH5;
      ckH5:
          call (I64[R1])(R1) returns to ckH4, args: 8, res: 8, upd: 8;
      ckH4:
          I64[Sp - 24] = ckH9;
          _sk1d::P64 = P64[R1 + 15];
          _sk1f::P64 = P64[R1 + 23];
          _sk1e::I64 = I64[R1 + 31];
          R1 = P64[R1 + 7];
          I64[Sp - 16] = _sk1e::I64;
          P64[Sp - 8] = _sk1f::P64;
          P64[Sp] = _sk1d::P64;
          Sp = Sp - 24;
          if (R1 & 7 != 0) goto ckH9; else goto ckHa;
      ckHa:
          call (I64[R1])(R1) returns to ckH9, args: 8, res: 8, upd: 8;
      ckH9:
          I64[Sp] = ckHe;
          _sk1h::I64 = I64[R1 + 7];
          R1 = P64[Sp + 24];
          I64[Sp + 24] = _sk1h::I64;
          if (R1 & 7 != 0) goto ckHe; else goto ckHf;
      ckHf:
          call (I64[R1])(R1) returns to ckHe, args: 8, res: 8, upd: 8;
      ckHe:
          I64[Sp] = ckHj;
          _sk1j::I64 = I64[R1 + 7];
          R1 = P64[Sp + 40];
          I64[Sp + 40] = _sk1j::I64;
          if (R1 & 7 != 0) goto ckHj; else goto ckHk;
      ckHk:
          call (I64[R1])(R1) returns to ckHj, args: 8, res: 8, upd: 8;
      ckHj:
          I64[Sp] = ckHo;
          _sk1l::P64 = P64[R1 + 7];
          R1 = P64[Sp + 32];
          P64[Sp + 32] = _sk1l::P64;
          call stg_ap_0_fast(R1) returns to ckHo, args: 8, res: 8, upd: 8;
      ckHo:
          I64[Sp - 16] = ckHs;
          _sk1p::P64 = P64[R1 + 7];
          _sk1n::I64 = I64[R1 + 15];
          _sk1o::I64 = I64[R1 + 23];
          R1 = P64[Sp + 64];
          P64[Sp - 8] = _sk1p::P64;
          I64[Sp] = _sk1o::I64;
          I64[Sp + 64] = _sk1n::I64;
          Sp = Sp - 16;
          if (R1 & 7 != 0) goto ckHs; else goto ckHt;
      ckHt:
          call (I64[R1])(R1) returns to ckHs, args: 8, res: 8, upd: 8;
      ckHs:
          I64[Sp] = ckHx;
          _sk1r::I64 = I64[R1 + 7];
          R1 = P64[Sp + 88];
          I64[Sp + 88] = _sk1r::I64;
          if (R1 & 7 != 0) goto ckHx; else goto ckHK;
      ckHK:
          call (I64[R1])(R1) returns to ckHx, args: 8, res: 8, upd: 8;
      ckHx:
          R6 = I64[Sp + 24];
          R5 = I64[Sp + 56];
          R4 = I64[Sp + 40];
          R3 = P64[Sp + 72];
          R2 = P64[Sp + 64];
          P64[Sp + 40] = P64[Sp + 32];
          I64[Sp + 56] = I64[Sp + 80];
          I64[Sp + 64] = I64[Sp + 16];
          P64[Sp + 72] = P64[Sp + 8];
          I64[Sp + 80] = I64[Sp + 88];
          F64[Sp + 88] = F64[R1 + 7];
          Sp = Sp + 40;
          call Main.$wa1_info(R6, R5, R4, R3, R2) args: 64, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:53.84031 UTC

[section "data" {
     Main.runRSTMSingle1_closure:
         const Main.runRSTMSingle1_info;
         const 0;
 },
 Main.runRSTMSingle1_entry() //  [R6, R5, R4, R3, R2]
         { info_tbl: [(ckGO,
                       label: block_ckGO_info
                       rep:StackRep [False, False, False, False]),
                      (ckGR,
                       label: Main.runRSTMSingle1_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} }),
                      (ckGU,
                       label: block_ckGU_info
                       rep:StackRep [False, False, False, False]),
                      (ckGZ,
                       label: block_ckGZ_info
                       rep:StackRep [False, False, False, False]),
                      (ckH4,
                       label: block_ckH4_info
                       rep:StackRep [False, False, False, False, False, False]),
                      (ckH9,
                       label: block_ckH9_info
                       rep:StackRep [True, False, False, False, False, False, False,
                                     False, False]),
                      (ckHe,
                       label: block_ckHe_info
                       rep:StackRep [True, False, True, False, False, False, False, False,
                                     False]),
                      (ckHj,
                       label: block_ckHj_info
                       rep:StackRep [True, False, True, False, True, False, False, False,
                                     False]),
                      (ckHo,
                       label: block_ckHo_info
                       rep:StackRep [True, False, True, False, True, False, False, False,
                                     False]),
                      (ckHs,
                       label: block_ckHs_info
                       rep:StackRep [False, True, True, False, True, False, True, False,
                                     False, True, False]),
                      (ckHx,
                       label: block_ckHx_info
                       rep:StackRep [False, True, True, False, True, False, True, False,
                                     False, True, True])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckGR:
           _sk11::P64 = R6;
           _sk10::P64 = R5;
           _sk0Z::P64 = R4;
           _sk0Y::P64 = R3;
           _sk0X::P64 = R2;
           if ((Sp + -96) < SpLim) goto ckHy; else goto ckHz;
       ckHz:
           if (HpLim == 0) goto ckHy; else goto ckHA;
       ckHy:
           R6 = _sk11::P64;
           R5 = _sk10::P64;
           R4 = _sk0Z::P64;
           R3 = _sk0Y::P64;
           R2 = _sk0X::P64;
           R1 = Main.runRSTMSingle1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckHA:
           I64[Sp - 40] = ckGO;
           R1 = _sk0X::P64;
           P64[Sp - 32] = _sk0Y::P64;
           P64[Sp - 24] = _sk0Z::P64;
           P64[Sp - 16] = _sk10::P64;
           P64[Sp - 8] = _sk11::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ckGO; else goto ckGP;
       ckGP:
           call (I64[R1])(R1) returns to ckGO, args: 8, res: 8, upd: 8;
       ckGO:
           I64[Sp] = ckGU;
           _sk14::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sk14::P64;
           if (R1 & 7 != 0) goto ckGU; else goto ckGV;
       ckGV:
           call (I64[R1])(R1) returns to ckGU, args: 8, res: 8, upd: 8;
       ckGU:
           I64[Sp] = ckGZ;
           _sk16::P64 = P64[R1 + 7];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _sk16::P64;
           if (R1 & 7 != 0) goto ckGZ; else goto ckH0;
       ckH0:
           call (I64[R1])(R1) returns to ckGZ, args: 8, res: 8, upd: 8;
       ckGZ:
           I64[Sp - 16] = ckH4;
           _sk19::P64 = P64[R1 + 15];
           _sk1a::P64 = P64[R1 + 23];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _sk1a::P64;
           P64[Sp] = _sk19::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ckH4; else goto ckH5;
       ckH5:
           call (I64[R1])(R1) returns to ckH4, args: 8, res: 8, upd: 8;
       ckH4:
           I64[Sp - 24] = ckH9;
           _sk1d::P64 = P64[R1 + 15];
           _sk1f::P64 = P64[R1 + 23];
           _sk1e::I64 = I64[R1 + 31];
           R1 = P64[R1 + 7];
           I64[Sp - 16] = _sk1e::I64;
           P64[Sp - 8] = _sk1f::P64;
           P64[Sp] = _sk1d::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ckH9; else goto ckHa;
       ckHa:
           call (I64[R1])(R1) returns to ckH9, args: 8, res: 8, upd: 8;
       ckH9:
           I64[Sp] = ckHe;
           _sk1h::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _sk1h::I64;
           if (R1 & 7 != 0) goto ckHe; else goto ckHf;
       ckHf:
           call (I64[R1])(R1) returns to ckHe, args: 8, res: 8, upd: 8;
       ckHe:
           I64[Sp] = ckHj;
           _sk1j::I64 = I64[R1 + 7];
           R1 = P64[Sp + 40];
           I64[Sp + 40] = _sk1j::I64;
           if (R1 & 7 != 0) goto ckHj; else goto ckHk;
       ckHk:
           call (I64[R1])(R1) returns to ckHj, args: 8, res: 8, upd: 8;
       ckHj:
           I64[Sp] = ckHo;
           _sk1l::P64 = P64[R1 + 7];
           R1 = P64[Sp + 32];
           P64[Sp + 32] = _sk1l::P64;
           call stg_ap_0_fast(R1) returns to ckHo, args: 8, res: 8, upd: 8;
       ckHo:
           I64[Sp - 16] = ckHs;
           _sk1p::P64 = P64[R1 + 7];
           _sk1n::I64 = I64[R1 + 15];
           _sk1o::I64 = I64[R1 + 23];
           R1 = P64[Sp + 64];
           P64[Sp - 8] = _sk1p::P64;
           I64[Sp] = _sk1o::I64;
           I64[Sp + 64] = _sk1n::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ckHs; else goto ckHt;
       ckHt:
           call (I64[R1])(R1) returns to ckHs, args: 8, res: 8, upd: 8;
       ckHs:
           I64[Sp] = ckHx;
           _sk1r::I64 = I64[R1 + 7];
           R1 = P64[Sp + 88];
           I64[Sp + 88] = _sk1r::I64;
           if (R1 & 7 != 0) goto ckHx; else goto ckHK;
       ckHK:
           call (I64[R1])(R1) returns to ckHx, args: 8, res: 8, upd: 8;
       ckHx:
           R6 = I64[Sp + 24];
           R5 = I64[Sp + 56];
           R4 = I64[Sp + 40];
           R3 = P64[Sp + 72];
           R2 = P64[Sp + 64];
           P64[Sp + 40] = P64[Sp + 32];
           I64[Sp + 56] = I64[Sp + 80];
           I64[Sp + 64] = I64[Sp + 16];
           P64[Sp + 72] = P64[Sp + 8];
           I64[Sp + 80] = I64[Sp + 88];
           F64[Sp + 88] = F64[R1 + 7];
           Sp = Sp + 40;
           call Main.$wa1_info(R6, R5, R4, R3, R2) args: 64, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:53.849205 UTC

[section "data" {
     Main.runRSTMSingle1_closure:
         const Main.runRSTMSingle1_info;
         const 0;
 },
 Main.runRSTMSingle1_entry() //  [R6, R5, R4, R3, R2]
         { info_tbl: [(ckGO,
                       label: block_ckGO_info
                       rep:StackRep [False, False, False, False]),
                      (ckGR,
                       label: Main.runRSTMSingle1_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} }),
                      (ckGU,
                       label: block_ckGU_info
                       rep:StackRep [False, False, False, False]),
                      (ckGZ,
                       label: block_ckGZ_info
                       rep:StackRep [False, False, False, False]),
                      (ckH4,
                       label: block_ckH4_info
                       rep:StackRep [False, False, False, False, False, False]),
                      (ckH9,
                       label: block_ckH9_info
                       rep:StackRep [True, False, False, False, False, False, False,
                                     False, False]),
                      (ckHe,
                       label: block_ckHe_info
                       rep:StackRep [True, False, True, False, False, False, False, False,
                                     False]),
                      (ckHj,
                       label: block_ckHj_info
                       rep:StackRep [True, False, True, False, True, False, False, False,
                                     False]),
                      (ckHo,
                       label: block_ckHo_info
                       rep:StackRep [True, False, True, False, True, False, False, False,
                                     False]),
                      (ckHs,
                       label: block_ckHs_info
                       rep:StackRep [False, True, True, False, True, False, True, False,
                                     False, True, False]),
                      (ckHx,
                       label: block_ckHx_info
                       rep:StackRep [False, True, True, False, True, False, True, False,
                                     False, True, True])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckGR:
           _sk11::P64 = R6;
           _sk10::P64 = R5;
           _sk0Z::P64 = R4;
           _sk0Y::P64 = R3;
           _sk0X::P64 = R2;
           if ((Sp + -96) < SpLim) goto ckHy; else goto ckHz;
       ckHz:
           if (HpLim == 0) goto ckHy; else goto ckHA;
       ckHy:
           R6 = _sk11::P64;
           R5 = _sk10::P64;
           R4 = _sk0Z::P64;
           R3 = _sk0Y::P64;
           R2 = _sk0X::P64;
           R1 = Main.runRSTMSingle1_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckHA:
           I64[Sp - 40] = ckGO;
           R1 = _sk0X::P64;
           P64[Sp - 32] = _sk0Y::P64;
           P64[Sp - 24] = _sk0Z::P64;
           P64[Sp - 16] = _sk10::P64;
           P64[Sp - 8] = _sk11::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ckGO; else goto ckGP;
       ckGP:
           call (I64[R1])(R1) returns to ckGO, args: 8, res: 8, upd: 8;
       ckGO:
           I64[Sp] = ckGU;
           _sk14::P64 = P64[R1 + 7];
           R1 = P64[Sp + 8];
           P64[Sp + 8] = _sk14::P64;
           if (R1 & 7 != 0) goto ckGU; else goto ckGV;
       ckGV:
           call (I64[R1])(R1) returns to ckGU, args: 8, res: 8, upd: 8;
       ckGU:
           I64[Sp] = ckGZ;
           _sk16::P64 = P64[R1 + 7];
           R1 = P64[Sp + 16];
           P64[Sp + 16] = _sk16::P64;
           if (R1 & 7 != 0) goto ckGZ; else goto ckH0;
       ckH0:
           call (I64[R1])(R1) returns to ckGZ, args: 8, res: 8, upd: 8;
       ckGZ:
           I64[Sp - 16] = ckH4;
           _sk19::P64 = P64[R1 + 15];
           _sk1a::P64 = P64[R1 + 23];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _sk1a::P64;
           P64[Sp] = _sk19::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ckH4; else goto ckH5;
       ckH5:
           call (I64[R1])(R1) returns to ckH4, args: 8, res: 8, upd: 8;
       ckH4:
           I64[Sp - 24] = ckH9;
           _sk1d::P64 = P64[R1 + 15];
           _sk1f::P64 = P64[R1 + 23];
           _sk1e::I64 = I64[R1 + 31];
           R1 = P64[R1 + 7];
           I64[Sp - 16] = _sk1e::I64;
           P64[Sp - 8] = _sk1f::P64;
           P64[Sp] = _sk1d::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ckH9; else goto ckHa;
       ckHa:
           call (I64[R1])(R1) returns to ckH9, args: 8, res: 8, upd: 8;
       ckH9:
           I64[Sp] = ckHe;
           _sk1h::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _sk1h::I64;
           if (R1 & 7 != 0) goto ckHe; else goto ckHf;
       ckHf:
           call (I64[R1])(R1) returns to ckHe, args: 8, res: 8, upd: 8;
       ckHe:
           I64[Sp] = ckHj;
           _sk1j::I64 = I64[R1 + 7];
           R1 = P64[Sp + 40];
           I64[Sp + 40] = _sk1j::I64;
           if (R1 & 7 != 0) goto ckHj; else goto ckHk;
       ckHk:
           call (I64[R1])(R1) returns to ckHj, args: 8, res: 8, upd: 8;
       ckHj:
           I64[Sp] = ckHo;
           _sk1l::P64 = P64[R1 + 7];
           R1 = P64[Sp + 32];
           P64[Sp + 32] = _sk1l::P64;
           call stg_ap_0_fast(R1) returns to ckHo, args: 8, res: 8, upd: 8;
       ckHo:
           I64[Sp - 16] = ckHs;
           _sk1p::P64 = P64[R1 + 7];
           _sk1n::I64 = I64[R1 + 15];
           _sk1o::I64 = I64[R1 + 23];
           R1 = P64[Sp + 64];
           P64[Sp - 8] = _sk1p::P64;
           I64[Sp] = _sk1o::I64;
           I64[Sp + 64] = _sk1n::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ckHs; else goto ckHt;
       ckHt:
           call (I64[R1])(R1) returns to ckHs, args: 8, res: 8, upd: 8;
       ckHs:
           I64[Sp] = ckHx;
           _sk1r::I64 = I64[R1 + 7];
           R1 = P64[Sp + 88];
           I64[Sp + 88] = _sk1r::I64;
           if (R1 & 7 != 0) goto ckHx; else goto ckHK;
       ckHK:
           call (I64[R1])(R1) returns to ckHx, args: 8, res: 8, upd: 8;
       ckHx:
           R6 = I64[Sp + 24];
           R5 = I64[Sp + 56];
           R4 = I64[Sp + 40];
           R3 = P64[Sp + 72];
           R2 = P64[Sp + 64];
           P64[Sp + 40] = P64[Sp + 32];
           I64[Sp + 56] = I64[Sp + 80];
           I64[Sp + 64] = I64[Sp + 16];
           P64[Sp + 72] = P64[Sp + 8];
           I64[Sp + 80] = I64[Sp + 88];
           F64[Sp + 88] = F64[R1 + 7];
           Sp = Sp + 40;
           call Main.$wa1_info(R6, R5, R4, R3, R2) args: 64, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:53.869639 UTC

[section "data" {
     Main.runRSTMSingle_closure:
         const Main.runRSTMSingle_info;
         const 0;
 },
 Main.runRSTMSingle_entry() //  [R6, R5, R4, R3, R2]
         { info_tbl: [(ckI4,
                       label: Main.runRSTMSingle_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckI4:
           _B2::P64 = R6;
           _B3::P64 = R5;
           _B4::P64 = R4;
           _B5::P64 = R3;
           _B6::P64 = R2;
           goto ckI2;
       ckI2:
           if ((old + 0) - <highSp> < SpLim) goto ckI5; else goto ckI6;
       ckI6:
           goto ckI1;
       ckI1:
           if (HpLim == 0) goto ckI5; else goto ckI7;
       ckI5:
           R6 = _B2::P64;
           R5 = _B3::P64;
           R4 = _B4::P64;
           R3 = _B5::P64;
           R2 = _B6::P64;
           R1 = Main.runRSTMSingle_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckI7:
           R6 = _B2::P64;
           R5 = _B3::P64;
           R4 = _B4::P64;
           R3 = _B5::P64;
           R2 = _B6::P64;
           call Main.runRSTMSingle1_info(R6,
                                         R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:53.87204 UTC

{offset
  ckI4:
      _B2::P64 = R6;
      _B3::P64 = R5;
      _B4::P64 = R4;
      _B5::P64 = R3;
      _B6::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckI5; else goto ckI6;
  ckI6:
      if (HpLim == 0) goto ckI5; else goto ckI7;
  ckI5:
      R6 = _B2::P64;
      R5 = _B3::P64;
      R4 = _B4::P64;
      R3 = _B5::P64;
      R2 = _B6::P64;
      R1 = Main.runRSTMSingle_closure;
      call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  ckI7:
      R6 = _B2::P64;
      R5 = _B3::P64;
      R4 = _B4::P64;
      R3 = _B5::P64;
      R2 = _B6::P64;
      call Main.runRSTMSingle1_info(R6,
                                    R5,
                                    R4,
                                    R3,
                                    R2) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:53.87325 UTC

{offset
  ckI4:
      _B2::P64 = R6;
      _B3::P64 = R5;
      _B4::P64 = R4;
      _B5::P64 = R3;
      _B6::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckI5; else goto ckI6;
  ckI6:
      if (HpLim == 0) goto ckI5; else goto ckI7;
  ckI5:
      R6 = _B2::P64;
      R5 = _B3::P64;
      R4 = _B4::P64;
      R3 = _B5::P64;
      R2 = _B6::P64;
      R1 = Main.runRSTMSingle_closure;
      call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  ckI7:
      R6 = _B2::P64;
      R5 = _B3::P64;
      R4 = _B4::P64;
      R3 = _B5::P64;
      R2 = _B6::P64;
      call Main.runRSTMSingle1_info(R6,
                                    R5,
                                    R4,
                                    R3,
                                    R2) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:53.874485 UTC

{offset
  ckI4:
      _B2::P64 = R6;
      _B3::P64 = R5;
      _B4::P64 = R4;
      _B5::P64 = R3;
      _B6::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckI5; else goto ckI6;
  ckI6:
      if (HpLim == 0) goto ckI5; else goto ckI7;
  ckI5:
      R6 = _B2::P64;
      R5 = _B3::P64;
      R4 = _B4::P64;
      R3 = _B5::P64;
      R2 = _B6::P64;
      R1 = Main.runRSTMSingle_closure;
      call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  ckI7:
      R6 = _B2::P64;
      R5 = _B3::P64;
      R4 = _B4::P64;
      R3 = _B5::P64;
      R2 = _B6::P64;
      call Main.runRSTMSingle1_info(R6,
                                    R5,
                                    R4,
                                    R3,
                                    R2) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:53.875752 UTC

{offset
  ckI4:
      _B2::P64 = R6;
      _B3::P64 = R5;
      _B4::P64 = R4;
      _B5::P64 = R3;
      _B6::P64 = R2;
      goto ckI6;
  ckI6:
      if (HpLim == 0) goto ckI5; else goto ckI7;
  ckI5:
      R6 = _B2::P64;
      R5 = _B3::P64;
      R4 = _B4::P64;
      R3 = _B5::P64;
      R2 = _B6::P64;
      R1 = Main.runRSTMSingle_closure;
      call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  ckI7:
      R6 = _B2::P64;
      R5 = _B3::P64;
      R4 = _B4::P64;
      R3 = _B5::P64;
      R2 = _B6::P64;
      call Main.runRSTMSingle1_info(R6,
                                    R5,
                                    R4,
                                    R3,
                                    R2) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:53.876883 UTC

{offset
  ckI4:
      goto ckI6;
  ckI6:
      if (HpLim == 0) goto ckI5; else goto ckI7;
  ckI5:
      R6 = R6;
      R5 = R5;
      R4 = R4;
      R3 = R3;
      R2 = R2;
      R1 = Main.runRSTMSingle_closure;
      call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  ckI7:
      R6 = R6;
      R5 = R5;
      R4 = R4;
      R3 = R3;
      R2 = R2;
      call Main.runRSTMSingle1_info(R6,
                                    R5,
                                    R4,
                                    R3,
                                    R2) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:53.87816 UTC

[(ckI4, {Main.runRSTMSingle1_closure, Main.runRSTMSingle_closure}),
 (ckI5, {Main.runRSTMSingle_closure}),
 (ckI6, {Main.runRSTMSingle1_closure, Main.runRSTMSingle_closure}),
 (ckI7, {Main.runRSTMSingle1_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:53.878664 UTC

Main.runRSTMSingle_entry() //  [R6, R5, R4, R3, R2]
        { info_tbl: [(ckI4,
                      label: Main.runRSTMSingle_info
                      rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckI4:
          goto ckI6;
      ckI6:
          if (HpLim == 0) goto ckI5; else goto ckI7;
      ckI5:
          R6 = R6;
          R5 = R5;
          R4 = R4;
          R3 = R3;
          R2 = R2;
          R1 = Main.runRSTMSingle_closure;
          call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
      ckI7:
          R6 = R6;
          R5 = R5;
          R4 = R4;
          R3 = R3;
          R2 = R2;
          call Main.runRSTMSingle1_info(R6,
                                        R5,
                                        R4,
                                        R3,
                                        R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:53.879888 UTC

Main.runRSTMSingle_entry() //  [R6, R5, R4, R3, R2]
        { info_tbl: [(ckI4,
                      label: Main.runRSTMSingle_info
                      rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckI4:
          if (HpLim == 0) goto ckI5; else goto ckI7;
      ckI5:
          R6 = R6;
          R5 = R5;
          R4 = R4;
          R3 = R3;
          R2 = R2;
          R1 = Main.runRSTMSingle_closure;
          call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
      ckI7:
          R6 = R6;
          R5 = R5;
          R4 = R4;
          R3 = R3;
          R2 = R2;
          call Main.runRSTMSingle1_info(R6,
                                        R5,
                                        R4,
                                        R3,
                                        R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:53.881096 UTC

[section "data" {
     Main.runRSTMSingle_closure:
         const Main.runRSTMSingle_info;
         const 0;
 },
 Main.runRSTMSingle_entry() //  [R6, R5, R4, R3, R2]
         { info_tbl: [(ckI4,
                       label: Main.runRSTMSingle_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckI4:
           if (HpLim == 0) goto ckI5; else goto ckI7;
       ckI5:
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Main.runRSTMSingle_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckI7:
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Main.runRSTMSingle1_info(R6,
                                         R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:53.882536 UTC

[section "data" {
     Main.runRSTMSingle_closure:
         const Main.runRSTMSingle_info;
         const 0;
 },
 Main.runRSTMSingle_entry() //  [R6, R5, R4, R3, R2]
         { info_tbl: [(ckI4,
                       label: Main.runRSTMSingle_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckI4:
           if (HpLim == 0) goto ckI5; else goto ckI7;
       ckI5:
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Main.runRSTMSingle_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckI7:
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Main.runRSTMSingle1_info(R6,
                                         R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:53.88578 UTC

[section "data" {
     Main.runRSTMSingle'_closure:
         const Main.runRSTMSingle'_info;
         const 0;
 },
 Main.runRSTMSingle'_entry() //  [R6, R5, R4, R3, R2]
         { info_tbl: [(ckIg,
                       label: Main.runRSTMSingle'_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckIg:
           _B2::P64 = R6;
           _B3::P64 = R5;
           _B4::P64 = R4;
           _B5::P64 = R3;
           _B6::P64 = R2;
           goto ckIe;
       ckIe:
           if ((old + 0) - <highSp> < SpLim) goto ckIh; else goto ckIi;
       ckIi:
           goto ckId;
       ckId:
           if (HpLim == 0) goto ckIh; else goto ckIj;
       ckIh:
           R6 = _B2::P64;
           R5 = _B3::P64;
           R4 = _B4::P64;
           R3 = _B5::P64;
           R2 = _B6::P64;
           R1 = Main.runRSTMSingle'_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckIj:
           R6 = _B2::P64;
           R5 = _B3::P64;
           R4 = _B4::P64;
           R3 = _B5::P64;
           R2 = _B6::P64;
           call Main.runRSTMSingle'1_info(R6,
                                          R5,
                                          R4,
                                          R3,
                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:53.888066 UTC

{offset
  ckIg:
      _B2::P64 = R6;
      _B3::P64 = R5;
      _B4::P64 = R4;
      _B5::P64 = R3;
      _B6::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckIh; else goto ckIi;
  ckIi:
      if (HpLim == 0) goto ckIh; else goto ckIj;
  ckIh:
      R6 = _B2::P64;
      R5 = _B3::P64;
      R4 = _B4::P64;
      R3 = _B5::P64;
      R2 = _B6::P64;
      R1 = Main.runRSTMSingle'_closure;
      call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  ckIj:
      R6 = _B2::P64;
      R5 = _B3::P64;
      R4 = _B4::P64;
      R3 = _B5::P64;
      R2 = _B6::P64;
      call Main.runRSTMSingle'1_info(R6,
                                     R5,
                                     R4,
                                     R3,
                                     R2) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:53.889292 UTC

{offset
  ckIg:
      _B2::P64 = R6;
      _B3::P64 = R5;
      _B4::P64 = R4;
      _B5::P64 = R3;
      _B6::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckIh; else goto ckIi;
  ckIi:
      if (HpLim == 0) goto ckIh; else goto ckIj;
  ckIh:
      R6 = _B2::P64;
      R5 = _B3::P64;
      R4 = _B4::P64;
      R3 = _B5::P64;
      R2 = _B6::P64;
      R1 = Main.runRSTMSingle'_closure;
      call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  ckIj:
      R6 = _B2::P64;
      R5 = _B3::P64;
      R4 = _B4::P64;
      R3 = _B5::P64;
      R2 = _B6::P64;
      call Main.runRSTMSingle'1_info(R6,
                                     R5,
                                     R4,
                                     R3,
                                     R2) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:53.891102 UTC

{offset
  ckIg:
      _B2::P64 = R6;
      _B3::P64 = R5;
      _B4::P64 = R4;
      _B5::P64 = R3;
      _B6::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckIh; else goto ckIi;
  ckIi:
      if (HpLim == 0) goto ckIh; else goto ckIj;
  ckIh:
      R6 = _B2::P64;
      R5 = _B3::P64;
      R4 = _B4::P64;
      R3 = _B5::P64;
      R2 = _B6::P64;
      R1 = Main.runRSTMSingle'_closure;
      call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  ckIj:
      R6 = _B2::P64;
      R5 = _B3::P64;
      R4 = _B4::P64;
      R3 = _B5::P64;
      R2 = _B6::P64;
      call Main.runRSTMSingle'1_info(R6,
                                     R5,
                                     R4,
                                     R3,
                                     R2) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:53.89235 UTC

{offset
  ckIg:
      _B2::P64 = R6;
      _B3::P64 = R5;
      _B4::P64 = R4;
      _B5::P64 = R3;
      _B6::P64 = R2;
      goto ckIi;
  ckIi:
      if (HpLim == 0) goto ckIh; else goto ckIj;
  ckIh:
      R6 = _B2::P64;
      R5 = _B3::P64;
      R4 = _B4::P64;
      R3 = _B5::P64;
      R2 = _B6::P64;
      R1 = Main.runRSTMSingle'_closure;
      call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  ckIj:
      R6 = _B2::P64;
      R5 = _B3::P64;
      R4 = _B4::P64;
      R3 = _B5::P64;
      R2 = _B6::P64;
      call Main.runRSTMSingle'1_info(R6,
                                     R5,
                                     R4,
                                     R3,
                                     R2) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:53.893475 UTC

{offset
  ckIg:
      goto ckIi;
  ckIi:
      if (HpLim == 0) goto ckIh; else goto ckIj;
  ckIh:
      R6 = R6;
      R5 = R5;
      R4 = R4;
      R3 = R3;
      R2 = R2;
      R1 = Main.runRSTMSingle'_closure;
      call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  ckIj:
      R6 = R6;
      R5 = R5;
      R4 = R4;
      R3 = R3;
      R2 = R2;
      call Main.runRSTMSingle'1_info(R6,
                                     R5,
                                     R4,
                                     R3,
                                     R2) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:53.894716 UTC

[(ckIg,
  {Main.runRSTMSingle'1_closure, Main.runRSTMSingle'_closure}),
 (ckIh, {Main.runRSTMSingle'_closure}),
 (ckIi,
  {Main.runRSTMSingle'1_closure, Main.runRSTMSingle'_closure}),
 (ckIj, {Main.runRSTMSingle'1_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:53.895237 UTC

Main.runRSTMSingle'_entry() //  [R6, R5, R4, R3, R2]
        { info_tbl: [(ckIg,
                      label: Main.runRSTMSingle'_info
                      rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckIg:
          goto ckIi;
      ckIi:
          if (HpLim == 0) goto ckIh; else goto ckIj;
      ckIh:
          R6 = R6;
          R5 = R5;
          R4 = R4;
          R3 = R3;
          R2 = R2;
          R1 = Main.runRSTMSingle'_closure;
          call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
      ckIj:
          R6 = R6;
          R5 = R5;
          R4 = R4;
          R3 = R3;
          R2 = R2;
          call Main.runRSTMSingle'1_info(R6,
                                         R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:53.896424 UTC

Main.runRSTMSingle'_entry() //  [R6, R5, R4, R3, R2]
        { info_tbl: [(ckIg,
                      label: Main.runRSTMSingle'_info
                      rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckIg:
          if (HpLim == 0) goto ckIh; else goto ckIj;
      ckIh:
          R6 = R6;
          R5 = R5;
          R4 = R4;
          R3 = R3;
          R2 = R2;
          R1 = Main.runRSTMSingle'_closure;
          call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
      ckIj:
          R6 = R6;
          R5 = R5;
          R4 = R4;
          R3 = R3;
          R2 = R2;
          call Main.runRSTMSingle'1_info(R6,
                                         R5,
                                         R4,
                                         R3,
                                         R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:53.897617 UTC

[section "data" {
     Main.runRSTMSingle'_closure:
         const Main.runRSTMSingle'_info;
         const 0;
 },
 Main.runRSTMSingle'_entry() //  [R6, R5, R4, R3, R2]
         { info_tbl: [(ckIg,
                       label: Main.runRSTMSingle'_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckIg:
           if (HpLim == 0) goto ckIh; else goto ckIj;
       ckIh:
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Main.runRSTMSingle'_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckIj:
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Main.runRSTMSingle'1_info(R6,
                                          R5,
                                          R4,
                                          R3,
                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:53.899187 UTC

[section "data" {
     Main.runRSTMSingle'_closure:
         const Main.runRSTMSingle'_info;
         const 0;
 },
 Main.runRSTMSingle'_entry() //  [R6, R5, R4, R3, R2]
         { info_tbl: [(ckIg,
                       label: Main.runRSTMSingle'_info
                       rep:HeapRep static { Fun {arity: 6 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckIg:
           if (HpLim == 0) goto ckIh; else goto ckIj;
       ckIh:
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Main.runRSTMSingle'_closure;
           call (stg_gc_fun)(R6, R5, R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckIj:
           R6 = R6;
           R5 = R5;
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Main.runRSTMSingle'1_info(R6,
                                          R5,
                                          R4,
                                          R3,
                                          R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:53.902326 UTC

[section "data" {
     Main.samples_closure:
         const Main.samples_info;
         const 0;
 },
 Main.samples_entry() //  [R4, R3, R2]
         { info_tbl: [(ckIs,
                       label: Main.samples_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckIs:
           _B2::P64 = R4;
           _B3::P64 = R3;
           _B4::P64 = R2;
           goto ckIq;
       ckIq:
           if ((old + 0) - <highSp> < SpLim) goto ckIt; else goto ckIu;
       ckIu:
           goto ckIp;
       ckIp:
           if (HpLim == 0) goto ckIt; else goto ckIv;
       ckIt:
           R4 = _B2::P64;
           R3 = _B3::P64;
           R2 = _B4::P64;
           R1 = Main.samples_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckIv:
           R4 = _B2::P64;
           R3 = _B3::P64;
           R2 = _B4::P64;
           call Main.samples1_info(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:53.904204 UTC

{offset
  ckIs:
      _B2::P64 = R4;
      _B3::P64 = R3;
      _B4::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckIt; else goto ckIu;
  ckIu:
      if (HpLim == 0) goto ckIt; else goto ckIv;
  ckIt:
      R4 = _B2::P64;
      R3 = _B3::P64;
      R2 = _B4::P64;
      R1 = Main.samples_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  ckIv:
      R4 = _B2::P64;
      R3 = _B3::P64;
      R2 = _B4::P64;
      call Main.samples1_info(R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:53.905156 UTC

{offset
  ckIs:
      _B2::P64 = R4;
      _B3::P64 = R3;
      _B4::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckIt; else goto ckIu;
  ckIu:
      if (HpLim == 0) goto ckIt; else goto ckIv;
  ckIt:
      R4 = _B2::P64;
      R3 = _B3::P64;
      R2 = _B4::P64;
      R1 = Main.samples_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  ckIv:
      R4 = _B2::P64;
      R3 = _B3::P64;
      R2 = _B4::P64;
      call Main.samples1_info(R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:53.906119 UTC

{offset
  ckIs:
      _B2::P64 = R4;
      _B3::P64 = R3;
      _B4::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckIt; else goto ckIu;
  ckIu:
      if (HpLim == 0) goto ckIt; else goto ckIv;
  ckIt:
      R4 = _B2::P64;
      R3 = _B3::P64;
      R2 = _B4::P64;
      R1 = Main.samples_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  ckIv:
      R4 = _B2::P64;
      R3 = _B3::P64;
      R2 = _B4::P64;
      call Main.samples1_info(R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:53.907147 UTC

{offset
  ckIs:
      _B2::P64 = R4;
      _B3::P64 = R3;
      _B4::P64 = R2;
      goto ckIu;
  ckIu:
      if (HpLim == 0) goto ckIt; else goto ckIv;
  ckIt:
      R4 = _B2::P64;
      R3 = _B3::P64;
      R2 = _B4::P64;
      R1 = Main.samples_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  ckIv:
      R4 = _B2::P64;
      R3 = _B3::P64;
      R2 = _B4::P64;
      call Main.samples1_info(R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:53.908011 UTC

{offset
  ckIs:
      goto ckIu;
  ckIu:
      if (HpLim == 0) goto ckIt; else goto ckIv;
  ckIt:
      R4 = R4;
      R3 = R3;
      R2 = R2;
      R1 = Main.samples_closure;
      call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
  ckIv:
      R4 = R4;
      R3 = R3;
      R2 = R2;
      call Main.samples1_info(R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:53.908972 UTC

[(ckIs, {Main.samples1_closure, Main.samples_closure}),
 (ckIt, {Main.samples_closure}),
 (ckIu, {Main.samples1_closure, Main.samples_closure}),
 (ckIv, {Main.samples1_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:53.909489 UTC

Main.samples_entry() //  [R4, R3, R2]
        { info_tbl: [(ckIs,
                      label: Main.samples_info
                      rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckIs:
          goto ckIu;
      ckIu:
          if (HpLim == 0) goto ckIt; else goto ckIv;
      ckIt:
          R4 = R4;
          R3 = R3;
          R2 = R2;
          R1 = Main.samples_closure;
          call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
      ckIv:
          R4 = R4;
          R3 = R3;
          R2 = R2;
          call Main.samples1_info(R4, R3, R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:53.910482 UTC

Main.samples_entry() //  [R4, R3, R2]
        { info_tbl: [(ckIs,
                      label: Main.samples_info
                      rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckIs:
          if (HpLim == 0) goto ckIt; else goto ckIv;
      ckIt:
          R4 = R4;
          R3 = R3;
          R2 = R2;
          R1 = Main.samples_closure;
          call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
      ckIv:
          R4 = R4;
          R3 = R3;
          R2 = R2;
          call Main.samples1_info(R4, R3, R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:53.91145 UTC

[section "data" {
     Main.samples_closure:
         const Main.samples_info;
         const 0;
 },
 Main.samples_entry() //  [R4, R3, R2]
         { info_tbl: [(ckIs,
                       label: Main.samples_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckIs:
           if (HpLim == 0) goto ckIt; else goto ckIv;
       ckIt:
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Main.samples_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckIv:
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Main.samples1_info(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:53.912672 UTC

[section "data" {
     Main.samples_closure:
         const Main.samples_info;
         const 0;
 },
 Main.samples_entry() //  [R4, R3, R2]
         { info_tbl: [(ckIs,
                       label: Main.samples_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 23} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckIs:
           if (HpLim == 0) goto ckIt; else goto ckIv;
       ckIt:
           R4 = R4;
           R3 = R3;
           R2 = R2;
           R1 = Main.samples_closure;
           call (stg_gc_fun)(R4, R3, R2, R1) args: 8, res: 0, upd: 8;
       ckIv:
           R4 = R4;
           R3 = R3;
           R2 = R2;
           call Main.samples1_info(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:53.915558 UTC

[section "data" {
     Main._atomicGroups_closure:
         const Main._atomicGroups_info;
 },
 Main._atomicGroups_entry() //  [R2]
         { info_tbl: [(ckIK,
                       label: Main._atomicGroups_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckIK:
           _sk1u::P64 = R2;
           goto ckIF;
       ckIF:
           if ((old + 0) - <highSp> < SpLim) goto ckIL; else goto ckIM;
       ckIM:
           goto ckIE;
       ckIE:
           if (HpLim == 0) goto ckIL; else goto ckIN;
       ckIL:
           R2 = _sk1u::P64;
           R1 = Main._atomicGroups_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckIN:
           I64[(young<ckIH> + 8)] = ckIH;
           R1 = _sk1u::P64;
           if (R1 & 7 != 0) goto ckIH; else goto ckII;
       ckII:
           call (I64[R1])(R1) returns to ckIH, args: 8, res: 8, upd: 8;
       ckIH:
           _sk1v::P64 = R1;
           _sk1w::P64 = P64[_sk1v::P64 + 7];
           _sk1x::P64 = P64[_sk1v::P64 + 15];
           _sk1y::P64 = P64[_sk1v::P64 + 23];
           _sk1z::P64 = P64[_sk1v::P64 + 31];
           _sk1A::P64 = P64[_sk1v::P64 + 39];
           _sk1B::P64 = P64[_sk1v::P64 + 47];
           _sk1C::P64 = P64[_sk1v::P64 + 55];
           R1 = _sk1A::P64 & (-8);
           call (I64[R1])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:53.918215 UTC

{offset
  ckIK:
      _sk1u::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckIL; else goto ckIM;
  ckIM:
      if (HpLim == 0) goto ckIL; else goto ckIN;
  ckIL:
      R2 = _sk1u::P64;
      R1 = Main._atomicGroups_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckIN:
      I64[(young<ckIH> + 8)] = ckIH;
      R1 = _sk1u::P64;
      if (R1 & 7 != 0) goto ckIH; else goto ckII;
  ckII:
      call (I64[R1])(R1) returns to ckIH, args: 8, res: 8, upd: 8;
  ckIH:
      _sk1v::P64 = R1;
      _sk1w::P64 = P64[_sk1v::P64 + 7];
      _sk1x::P64 = P64[_sk1v::P64 + 15];
      _sk1y::P64 = P64[_sk1v::P64 + 23];
      _sk1z::P64 = P64[_sk1v::P64 + 31];
      _sk1A::P64 = P64[_sk1v::P64 + 39];
      _sk1B::P64 = P64[_sk1v::P64 + 47];
      _sk1C::P64 = P64[_sk1v::P64 + 55];
      R1 = _sk1A::P64 & (-8);
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:53.920309 UTC

{offset
  ckIK:
      _sk1u::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckIL; else goto ckIM;
  ckIM:
      if (HpLim == 0) goto ckIL; else goto ckIN;
  ckIL:
      R2 = _sk1u::P64;
      R1 = Main._atomicGroups_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckIN:
      I64[(young<ckIH> + 8)] = ckIH;
      R1 = _sk1u::P64;
      if (R1 & 7 != 0) goto ckIH; else goto ckII;
  ckII:
      call (I64[R1])(R1) returns to ckIH, args: 8, res: 8, upd: 8;
  ckIH:
      _sk1v::P64 = R1;
      _sk1w::P64 = P64[_sk1v::P64 + 7];
      _sk1x::P64 = P64[_sk1v::P64 + 15];
      _sk1y::P64 = P64[_sk1v::P64 + 23];
      _sk1z::P64 = P64[_sk1v::P64 + 31];
      _sk1A::P64 = P64[_sk1v::P64 + 39];
      _sk1B::P64 = P64[_sk1v::P64 + 47];
      _sk1C::P64 = P64[_sk1v::P64 + 55];
      R1 = _sk1A::P64 & (-8);
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:53.921826 UTC

{offset
  ckIK:
      _sk1u::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckIL; else goto ckIM;
  ckIM:
      if (HpLim == 0) goto ckIL; else goto ckIN;
  ckIL:
      R2 = _sk1u::P64;
      R1 = Main._atomicGroups_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckIN:
      I64[(young<ckIH> + 8)] = ckIH;
      R1 = _sk1u::P64;
      if (R1 & 7 != 0) goto ckIH; else goto ckII;
  ckII:
      call (I64[R1])(R1) returns to ckIH, args: 8, res: 8, upd: 8;
  ckIH:
      _sk1v::P64 = R1;
      _sk1w::P64 = P64[_sk1v::P64 + 7];
      _sk1x::P64 = P64[_sk1v::P64 + 15];
      _sk1y::P64 = P64[_sk1v::P64 + 23];
      _sk1z::P64 = P64[_sk1v::P64 + 31];
      _sk1A::P64 = P64[_sk1v::P64 + 39];
      _sk1B::P64 = P64[_sk1v::P64 + 47];
      _sk1C::P64 = P64[_sk1v::P64 + 55];
      R1 = _sk1A::P64 & (-8);
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:53.923484 UTC

{offset
  ckIK:
      _sk1u::P64 = R2;
      if ((Sp + 8) - 16 < SpLim) goto ckIL; else goto ckIM;
  ckIM:
      if (HpLim == 0) goto ckIL; else goto ckIN;
  ckIL:
      R2 = _sk1u::P64;
      R1 = Main._atomicGroups_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckIN:
      I64[Sp - 8] = ckIH;
      R1 = _sk1u::P64;
      Sp = Sp - 8;
      if (R1 & 7 != 0) goto ckIH; else goto ckII;
  ckII:
      call (I64[R1])(R1) returns to ckIH, args: 8, res: 8, upd: 8;
  ckIH:
      _sk1v::P64 = R1;
      _sk1w::P64 = P64[_sk1v::P64 + 7];
      _sk1x::P64 = P64[_sk1v::P64 + 15];
      _sk1y::P64 = P64[_sk1v::P64 + 23];
      _sk1z::P64 = P64[_sk1v::P64 + 31];
      _sk1A::P64 = P64[_sk1v::P64 + 39];
      _sk1B::P64 = P64[_sk1v::P64 + 47];
      _sk1C::P64 = P64[_sk1v::P64 + 55];
      R1 = _sk1A::P64 & (-8);
      Sp = Sp + 8;
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:53.924992 UTC

{offset
  ckIK:
      _sk1u::P64 = R2;
      if ((Sp + -8) < SpLim) goto ckIL; else goto ckIM;
  ckIM:
      if (HpLim == 0) goto ckIL; else goto ckIN;
  ckIL:
      R2 = _sk1u::P64;
      R1 = Main._atomicGroups_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckIN:
      I64[Sp - 8] = ckIH;
      R1 = _sk1u::P64;
      Sp = Sp - 8;
      if (R1 & 7 != 0) goto ckIH; else goto ckII;
  ckII:
      call (I64[R1])(R1) returns to ckIH, args: 8, res: 8, upd: 8;
  ckIH:
      R1 = P64[R1 + 39] & (-8);
      Sp = Sp + 8;
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:53.926288 UTC

[(ckIH, {}), (ckII, {}), (ckIK, {}), (ckIL, {}), (ckIM, {}),
 (ckIN, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:53.926675 UTC

Main._atomicGroups_entry() //  [R2]
        { info_tbl: [(ckIH,
                      label: block_ckIH_info
                      rep:StackRep []),
                     (ckIK,
                      label: Main._atomicGroups_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckIK:
          _sk1u::P64 = R2;
          if ((Sp + -8) < SpLim) goto ckIL; else goto ckIM;
      ckIM:
          if (HpLim == 0) goto ckIL; else goto ckIN;
      ckIL:
          R2 = _sk1u::P64;
          R1 = Main._atomicGroups_closure;
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
      ckIN:
          I64[Sp - 8] = ckIH;
          R1 = _sk1u::P64;
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto ckIH; else goto ckII;
      ckII:
          call (I64[R1])(R1) returns to ckIH, args: 8, res: 8, upd: 8;
      ckIH:
          R1 = P64[R1 + 39] & (-8);
          Sp = Sp + 8;
          call (I64[R1])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:53.928183 UTC

Main._atomicGroups_entry() //  [R2]
        { info_tbl: [(ckIH,
                      label: block_ckIH_info
                      rep:StackRep []),
                     (ckIK,
                      label: Main._atomicGroups_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckIK:
          _sk1u::P64 = R2;
          if ((Sp + -8) < SpLim) goto ckIL; else goto ckIM;
      ckIM:
          if (HpLim == 0) goto ckIL; else goto ckIN;
      ckIL:
          R2 = _sk1u::P64;
          R1 = Main._atomicGroups_closure;
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
      ckIN:
          I64[Sp - 8] = ckIH;
          R1 = _sk1u::P64;
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto ckIH; else goto ckII;
      ckII:
          call (I64[R1])(R1) returns to ckIH, args: 8, res: 8, upd: 8;
      ckIH:
          R1 = P64[R1 + 39] & (-8);
          Sp = Sp + 8;
          call (I64[R1])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:53.929704 UTC

[section "data" {
     Main._atomicGroups_closure:
         const Main._atomicGroups_info;
 },
 Main._atomicGroups_entry() //  [R2]
         { info_tbl: [(ckIH,
                       label: block_ckIH_info
                       rep:StackRep []),
                      (ckIK,
                       label: Main._atomicGroups_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckIK:
           _sk1u::P64 = R2;
           if ((Sp + -8) < SpLim) goto ckIL; else goto ckIM;
       ckIM:
           if (HpLim == 0) goto ckIL; else goto ckIN;
       ckIL:
           R2 = _sk1u::P64;
           R1 = Main._atomicGroups_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckIN:
           I64[Sp - 8] = ckIH;
           R1 = _sk1u::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ckIH; else goto ckII;
       ckII:
           call (I64[R1])(R1) returns to ckIH, args: 8, res: 8, upd: 8;
       ckIH:
           R1 = P64[R1 + 39] & (-8);
           Sp = Sp + 8;
           call (I64[R1])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:53.93133 UTC

[section "data" {
     Main._atomicGroups_closure:
         const Main._atomicGroups_info;
 },
 Main._atomicGroups_entry() //  [R2]
         { info_tbl: [(ckIH,
                       label: block_ckIH_info
                       rep:StackRep []),
                      (ckIK,
                       label: Main._atomicGroups_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckIK:
           _sk1u::P64 = R2;
           if ((Sp + -8) < SpLim) goto ckIL; else goto ckIM;
       ckIM:
           if (HpLim == 0) goto ckIL; else goto ckIN;
       ckIL:
           R2 = _sk1u::P64;
           R1 = Main._atomicGroups_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckIN:
           I64[Sp - 8] = ckIH;
           R1 = _sk1u::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ckIH; else goto ckII;
       ckII:
           call (I64[R1])(R1) returns to ckIH, args: 8, res: 8, upd: 8;
       ckIH:
           R1 = P64[R1 + 39] & (-8);
           Sp = Sp + 8;
           call (I64[R1])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:53.935625 UTC

[section "data" {
     Main._entries_closure:
         const Main._entries_info;
 },
 Main._entries_entry() //  [R2]
         { info_tbl: [(ckJ7,
                       label: Main._entries_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckJ7:
           _sk1D::P64 = R2;
           goto ckJ2;
       ckJ2:
           if ((old + 0) - <highSp> < SpLim) goto ckJ8; else goto ckJ9;
       ckJ9:
           goto ckJ1;
       ckJ1:
           if (HpLim == 0) goto ckJ8; else goto ckJa;
       ckJ8:
           R2 = _sk1D::P64;
           R1 = Main._entries_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckJa:
           I64[(young<ckJ4> + 8)] = ckJ4;
           R1 = _sk1D::P64;
           if (R1 & 7 != 0) goto ckJ4; else goto ckJ5;
       ckJ5:
           call (I64[R1])(R1) returns to ckJ4, args: 8, res: 8, upd: 8;
       ckJ4:
           _sk1E::P64 = R1;
           _sk1F::P64 = P64[_sk1E::P64 + 7];
           _sk1G::P64 = P64[_sk1E::P64 + 15];
           _sk1H::P64 = P64[_sk1E::P64 + 23];
           _sk1I::P64 = P64[_sk1E::P64 + 31];
           _sk1J::P64 = P64[_sk1E::P64 + 39];
           _sk1K::P64 = P64[_sk1E::P64 + 47];
           _sk1L::P64 = P64[_sk1E::P64 + 55];
           R1 = _sk1F::P64 & (-8);
           call (I64[R1])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:53.938274 UTC

{offset
  ckJ7:
      _sk1D::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckJ8; else goto ckJ9;
  ckJ9:
      if (HpLim == 0) goto ckJ8; else goto ckJa;
  ckJ8:
      R2 = _sk1D::P64;
      R1 = Main._entries_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckJa:
      I64[(young<ckJ4> + 8)] = ckJ4;
      R1 = _sk1D::P64;
      if (R1 & 7 != 0) goto ckJ4; else goto ckJ5;
  ckJ5:
      call (I64[R1])(R1) returns to ckJ4, args: 8, res: 8, upd: 8;
  ckJ4:
      _sk1E::P64 = R1;
      _sk1F::P64 = P64[_sk1E::P64 + 7];
      _sk1G::P64 = P64[_sk1E::P64 + 15];
      _sk1H::P64 = P64[_sk1E::P64 + 23];
      _sk1I::P64 = P64[_sk1E::P64 + 31];
      _sk1J::P64 = P64[_sk1E::P64 + 39];
      _sk1K::P64 = P64[_sk1E::P64 + 47];
      _sk1L::P64 = P64[_sk1E::P64 + 55];
      R1 = _sk1F::P64 & (-8);
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:53.939859 UTC

{offset
  ckJ7:
      _sk1D::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckJ8; else goto ckJ9;
  ckJ9:
      if (HpLim == 0) goto ckJ8; else goto ckJa;
  ckJ8:
      R2 = _sk1D::P64;
      R1 = Main._entries_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckJa:
      I64[(young<ckJ4> + 8)] = ckJ4;
      R1 = _sk1D::P64;
      if (R1 & 7 != 0) goto ckJ4; else goto ckJ5;
  ckJ5:
      call (I64[R1])(R1) returns to ckJ4, args: 8, res: 8, upd: 8;
  ckJ4:
      _sk1E::P64 = R1;
      _sk1F::P64 = P64[_sk1E::P64 + 7];
      _sk1G::P64 = P64[_sk1E::P64 + 15];
      _sk1H::P64 = P64[_sk1E::P64 + 23];
      _sk1I::P64 = P64[_sk1E::P64 + 31];
      _sk1J::P64 = P64[_sk1E::P64 + 39];
      _sk1K::P64 = P64[_sk1E::P64 + 47];
      _sk1L::P64 = P64[_sk1E::P64 + 55];
      R1 = _sk1F::P64 & (-8);
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:53.941349 UTC

{offset
  ckJ7:
      _sk1D::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckJ8; else goto ckJ9;
  ckJ9:
      if (HpLim == 0) goto ckJ8; else goto ckJa;
  ckJ8:
      R2 = _sk1D::P64;
      R1 = Main._entries_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckJa:
      I64[(young<ckJ4> + 8)] = ckJ4;
      R1 = _sk1D::P64;
      if (R1 & 7 != 0) goto ckJ4; else goto ckJ5;
  ckJ5:
      call (I64[R1])(R1) returns to ckJ4, args: 8, res: 8, upd: 8;
  ckJ4:
      _sk1E::P64 = R1;
      _sk1F::P64 = P64[_sk1E::P64 + 7];
      _sk1G::P64 = P64[_sk1E::P64 + 15];
      _sk1H::P64 = P64[_sk1E::P64 + 23];
      _sk1I::P64 = P64[_sk1E::P64 + 31];
      _sk1J::P64 = P64[_sk1E::P64 + 39];
      _sk1K::P64 = P64[_sk1E::P64 + 47];
      _sk1L::P64 = P64[_sk1E::P64 + 55];
      R1 = _sk1F::P64 & (-8);
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:53.943009 UTC

{offset
  ckJ7:
      _sk1D::P64 = R2;
      if ((Sp + 8) - 16 < SpLim) goto ckJ8; else goto ckJ9;
  ckJ9:
      if (HpLim == 0) goto ckJ8; else goto ckJa;
  ckJ8:
      R2 = _sk1D::P64;
      R1 = Main._entries_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckJa:
      I64[Sp - 8] = ckJ4;
      R1 = _sk1D::P64;
      Sp = Sp - 8;
      if (R1 & 7 != 0) goto ckJ4; else goto ckJ5;
  ckJ5:
      call (I64[R1])(R1) returns to ckJ4, args: 8, res: 8, upd: 8;
  ckJ4:
      _sk1E::P64 = R1;
      _sk1F::P64 = P64[_sk1E::P64 + 7];
      _sk1G::P64 = P64[_sk1E::P64 + 15];
      _sk1H::P64 = P64[_sk1E::P64 + 23];
      _sk1I::P64 = P64[_sk1E::P64 + 31];
      _sk1J::P64 = P64[_sk1E::P64 + 39];
      _sk1K::P64 = P64[_sk1E::P64 + 47];
      _sk1L::P64 = P64[_sk1E::P64 + 55];
      R1 = _sk1F::P64 & (-8);
      Sp = Sp + 8;
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:53.944536 UTC

{offset
  ckJ7:
      _sk1D::P64 = R2;
      if ((Sp + -8) < SpLim) goto ckJ8; else goto ckJ9;
  ckJ9:
      if (HpLim == 0) goto ckJ8; else goto ckJa;
  ckJ8:
      R2 = _sk1D::P64;
      R1 = Main._entries_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckJa:
      I64[Sp - 8] = ckJ4;
      R1 = _sk1D::P64;
      Sp = Sp - 8;
      if (R1 & 7 != 0) goto ckJ4; else goto ckJ5;
  ckJ5:
      call (I64[R1])(R1) returns to ckJ4, args: 8, res: 8, upd: 8;
  ckJ4:
      R1 = P64[R1 + 7] & (-8);
      Sp = Sp + 8;
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:53.945796 UTC

[(ckJ4, {}), (ckJ5, {}), (ckJ7, {}), (ckJ8, {}), (ckJ9, {}),
 (ckJa, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:53.946176 UTC

Main._entries_entry() //  [R2]
        { info_tbl: [(ckJ4,
                      label: block_ckJ4_info
                      rep:StackRep []),
                     (ckJ7,
                      label: Main._entries_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckJ7:
          _sk1D::P64 = R2;
          if ((Sp + -8) < SpLim) goto ckJ8; else goto ckJ9;
      ckJ9:
          if (HpLim == 0) goto ckJ8; else goto ckJa;
      ckJ8:
          R2 = _sk1D::P64;
          R1 = Main._entries_closure;
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
      ckJa:
          I64[Sp - 8] = ckJ4;
          R1 = _sk1D::P64;
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto ckJ4; else goto ckJ5;
      ckJ5:
          call (I64[R1])(R1) returns to ckJ4, args: 8, res: 8, upd: 8;
      ckJ4:
          R1 = P64[R1 + 7] & (-8);
          Sp = Sp + 8;
          call (I64[R1])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:53.947642 UTC

Main._entries_entry() //  [R2]
        { info_tbl: [(ckJ4,
                      label: block_ckJ4_info
                      rep:StackRep []),
                     (ckJ7,
                      label: Main._entries_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckJ7:
          _sk1D::P64 = R2;
          if ((Sp + -8) < SpLim) goto ckJ8; else goto ckJ9;
      ckJ9:
          if (HpLim == 0) goto ckJ8; else goto ckJa;
      ckJ8:
          R2 = _sk1D::P64;
          R1 = Main._entries_closure;
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
      ckJa:
          I64[Sp - 8] = ckJ4;
          R1 = _sk1D::P64;
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto ckJ4; else goto ckJ5;
      ckJ5:
          call (I64[R1])(R1) returns to ckJ4, args: 8, res: 8, upd: 8;
      ckJ4:
          R1 = P64[R1 + 7] & (-8);
          Sp = Sp + 8;
          call (I64[R1])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:53.949115 UTC

[section "data" {
     Main._entries_closure:
         const Main._entries_info;
 },
 Main._entries_entry() //  [R2]
         { info_tbl: [(ckJ4,
                       label: block_ckJ4_info
                       rep:StackRep []),
                      (ckJ7,
                       label: Main._entries_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckJ7:
           _sk1D::P64 = R2;
           if ((Sp + -8) < SpLim) goto ckJ8; else goto ckJ9;
       ckJ9:
           if (HpLim == 0) goto ckJ8; else goto ckJa;
       ckJ8:
           R2 = _sk1D::P64;
           R1 = Main._entries_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckJa:
           I64[Sp - 8] = ckJ4;
           R1 = _sk1D::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ckJ4; else goto ckJ5;
       ckJ5:
           call (I64[R1])(R1) returns to ckJ4, args: 8, res: 8, upd: 8;
       ckJ4:
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[R1])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:53.950697 UTC

[section "data" {
     Main._entries_closure:
         const Main._entries_info;
 },
 Main._entries_entry() //  [R2]
         { info_tbl: [(ckJ4,
                       label: block_ckJ4_info
                       rep:StackRep []),
                      (ckJ7,
                       label: Main._entries_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckJ7:
           _sk1D::P64 = R2;
           if ((Sp + -8) < SpLim) goto ckJ8; else goto ckJ9;
       ckJ9:
           if (HpLim == 0) goto ckJ8; else goto ckJa;
       ckJ8:
           R2 = _sk1D::P64;
           R1 = Main._entries_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckJa:
           I64[Sp - 8] = ckJ4;
           R1 = _sk1D::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ckJ4; else goto ckJ5;
       ckJ5:
           call (I64[R1])(R1) returns to ckJ4, args: 8, res: 8, upd: 8;
       ckJ4:
           R1 = P64[R1 + 7] & (-8);
           Sp = Sp + 8;
           call (I64[R1])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:53.954957 UTC

[section "data" {
     Main._initOnly_closure:
         const Main._initOnly_info;
 },
 Main._initOnly_entry() //  [R2]
         { info_tbl: [(ckJu,
                       label: Main._initOnly_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckJu:
           _sk1M::P64 = R2;
           goto ckJp;
       ckJp:
           if ((old + 0) - <highSp> < SpLim) goto ckJv; else goto ckJw;
       ckJw:
           goto ckJo;
       ckJo:
           if (HpLim == 0) goto ckJv; else goto ckJx;
       ckJv:
           R2 = _sk1M::P64;
           R1 = Main._initOnly_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckJx:
           I64[(young<ckJr> + 8)] = ckJr;
           R1 = _sk1M::P64;
           if (R1 & 7 != 0) goto ckJr; else goto ckJs;
       ckJs:
           call (I64[R1])(R1) returns to ckJr, args: 8, res: 8, upd: 8;
       ckJr:
           _sk1N::P64 = R1;
           _sk1O::P64 = P64[_sk1N::P64 + 7];
           _sk1P::P64 = P64[_sk1N::P64 + 15];
           _sk1Q::P64 = P64[_sk1N::P64 + 23];
           _sk1R::P64 = P64[_sk1N::P64 + 31];
           _sk1S::P64 = P64[_sk1N::P64 + 39];
           _sk1T::P64 = P64[_sk1N::P64 + 47];
           _sk1U::P64 = P64[_sk1N::P64 + 55];
           R1 = _sk1Q::P64 & (-8);
           call (I64[R1])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:53.957632 UTC

{offset
  ckJu:
      _sk1M::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckJv; else goto ckJw;
  ckJw:
      if (HpLim == 0) goto ckJv; else goto ckJx;
  ckJv:
      R2 = _sk1M::P64;
      R1 = Main._initOnly_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckJx:
      I64[(young<ckJr> + 8)] = ckJr;
      R1 = _sk1M::P64;
      if (R1 & 7 != 0) goto ckJr; else goto ckJs;
  ckJs:
      call (I64[R1])(R1) returns to ckJr, args: 8, res: 8, upd: 8;
  ckJr:
      _sk1N::P64 = R1;
      _sk1O::P64 = P64[_sk1N::P64 + 7];
      _sk1P::P64 = P64[_sk1N::P64 + 15];
      _sk1Q::P64 = P64[_sk1N::P64 + 23];
      _sk1R::P64 = P64[_sk1N::P64 + 31];
      _sk1S::P64 = P64[_sk1N::P64 + 39];
      _sk1T::P64 = P64[_sk1N::P64 + 47];
      _sk1U::P64 = P64[_sk1N::P64 + 55];
      R1 = _sk1Q::P64 & (-8);
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:53.959849 UTC

{offset
  ckJu:
      _sk1M::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckJv; else goto ckJw;
  ckJw:
      if (HpLim == 0) goto ckJv; else goto ckJx;
  ckJv:
      R2 = _sk1M::P64;
      R1 = Main._initOnly_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckJx:
      I64[(young<ckJr> + 8)] = ckJr;
      R1 = _sk1M::P64;
      if (R1 & 7 != 0) goto ckJr; else goto ckJs;
  ckJs:
      call (I64[R1])(R1) returns to ckJr, args: 8, res: 8, upd: 8;
  ckJr:
      _sk1N::P64 = R1;
      _sk1O::P64 = P64[_sk1N::P64 + 7];
      _sk1P::P64 = P64[_sk1N::P64 + 15];
      _sk1Q::P64 = P64[_sk1N::P64 + 23];
      _sk1R::P64 = P64[_sk1N::P64 + 31];
      _sk1S::P64 = P64[_sk1N::P64 + 39];
      _sk1T::P64 = P64[_sk1N::P64 + 47];
      _sk1U::P64 = P64[_sk1N::P64 + 55];
      R1 = _sk1Q::P64 & (-8);
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:53.961337 UTC

{offset
  ckJu:
      _sk1M::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckJv; else goto ckJw;
  ckJw:
      if (HpLim == 0) goto ckJv; else goto ckJx;
  ckJv:
      R2 = _sk1M::P64;
      R1 = Main._initOnly_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckJx:
      I64[(young<ckJr> + 8)] = ckJr;
      R1 = _sk1M::P64;
      if (R1 & 7 != 0) goto ckJr; else goto ckJs;
  ckJs:
      call (I64[R1])(R1) returns to ckJr, args: 8, res: 8, upd: 8;
  ckJr:
      _sk1N::P64 = R1;
      _sk1O::P64 = P64[_sk1N::P64 + 7];
      _sk1P::P64 = P64[_sk1N::P64 + 15];
      _sk1Q::P64 = P64[_sk1N::P64 + 23];
      _sk1R::P64 = P64[_sk1N::P64 + 31];
      _sk1S::P64 = P64[_sk1N::P64 + 39];
      _sk1T::P64 = P64[_sk1N::P64 + 47];
      _sk1U::P64 = P64[_sk1N::P64 + 55];
      R1 = _sk1Q::P64 & (-8);
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:53.962985 UTC

{offset
  ckJu:
      _sk1M::P64 = R2;
      if ((Sp + 8) - 16 < SpLim) goto ckJv; else goto ckJw;
  ckJw:
      if (HpLim == 0) goto ckJv; else goto ckJx;
  ckJv:
      R2 = _sk1M::P64;
      R1 = Main._initOnly_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckJx:
      I64[Sp - 8] = ckJr;
      R1 = _sk1M::P64;
      Sp = Sp - 8;
      if (R1 & 7 != 0) goto ckJr; else goto ckJs;
  ckJs:
      call (I64[R1])(R1) returns to ckJr, args: 8, res: 8, upd: 8;
  ckJr:
      _sk1N::P64 = R1;
      _sk1O::P64 = P64[_sk1N::P64 + 7];
      _sk1P::P64 = P64[_sk1N::P64 + 15];
      _sk1Q::P64 = P64[_sk1N::P64 + 23];
      _sk1R::P64 = P64[_sk1N::P64 + 31];
      _sk1S::P64 = P64[_sk1N::P64 + 39];
      _sk1T::P64 = P64[_sk1N::P64 + 47];
      _sk1U::P64 = P64[_sk1N::P64 + 55];
      R1 = _sk1Q::P64 & (-8);
      Sp = Sp + 8;
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:53.964517 UTC

{offset
  ckJu:
      _sk1M::P64 = R2;
      if ((Sp + -8) < SpLim) goto ckJv; else goto ckJw;
  ckJw:
      if (HpLim == 0) goto ckJv; else goto ckJx;
  ckJv:
      R2 = _sk1M::P64;
      R1 = Main._initOnly_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckJx:
      I64[Sp - 8] = ckJr;
      R1 = _sk1M::P64;
      Sp = Sp - 8;
      if (R1 & 7 != 0) goto ckJr; else goto ckJs;
  ckJs:
      call (I64[R1])(R1) returns to ckJr, args: 8, res: 8, upd: 8;
  ckJr:
      R1 = P64[R1 + 23] & (-8);
      Sp = Sp + 8;
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:53.965808 UTC

[(ckJr, {}), (ckJs, {}), (ckJu, {}), (ckJv, {}), (ckJw, {}),
 (ckJx, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:53.966194 UTC

Main._initOnly_entry() //  [R2]
        { info_tbl: [(ckJr,
                      label: block_ckJr_info
                      rep:StackRep []),
                     (ckJu,
                      label: Main._initOnly_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckJu:
          _sk1M::P64 = R2;
          if ((Sp + -8) < SpLim) goto ckJv; else goto ckJw;
      ckJw:
          if (HpLim == 0) goto ckJv; else goto ckJx;
      ckJv:
          R2 = _sk1M::P64;
          R1 = Main._initOnly_closure;
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
      ckJx:
          I64[Sp - 8] = ckJr;
          R1 = _sk1M::P64;
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto ckJr; else goto ckJs;
      ckJs:
          call (I64[R1])(R1) returns to ckJr, args: 8, res: 8, upd: 8;
      ckJr:
          R1 = P64[R1 + 23] & (-8);
          Sp = Sp + 8;
          call (I64[R1])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:53.967714 UTC

Main._initOnly_entry() //  [R2]
        { info_tbl: [(ckJr,
                      label: block_ckJr_info
                      rep:StackRep []),
                     (ckJu,
                      label: Main._initOnly_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckJu:
          _sk1M::P64 = R2;
          if ((Sp + -8) < SpLim) goto ckJv; else goto ckJw;
      ckJw:
          if (HpLim == 0) goto ckJv; else goto ckJx;
      ckJv:
          R2 = _sk1M::P64;
          R1 = Main._initOnly_closure;
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
      ckJx:
          I64[Sp - 8] = ckJr;
          R1 = _sk1M::P64;
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto ckJr; else goto ckJs;
      ckJs:
          call (I64[R1])(R1) returns to ckJr, args: 8, res: 8, upd: 8;
      ckJr:
          R1 = P64[R1 + 23] & (-8);
          Sp = Sp + 8;
          call (I64[R1])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:53.969218 UTC

[section "data" {
     Main._initOnly_closure:
         const Main._initOnly_info;
 },
 Main._initOnly_entry() //  [R2]
         { info_tbl: [(ckJr,
                       label: block_ckJr_info
                       rep:StackRep []),
                      (ckJu,
                       label: Main._initOnly_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckJu:
           _sk1M::P64 = R2;
           if ((Sp + -8) < SpLim) goto ckJv; else goto ckJw;
       ckJw:
           if (HpLim == 0) goto ckJv; else goto ckJx;
       ckJv:
           R2 = _sk1M::P64;
           R1 = Main._initOnly_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckJx:
           I64[Sp - 8] = ckJr;
           R1 = _sk1M::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ckJr; else goto ckJs;
       ckJs:
           call (I64[R1])(R1) returns to ckJr, args: 8, res: 8, upd: 8;
       ckJr:
           R1 = P64[R1 + 23] & (-8);
           Sp = Sp + 8;
           call (I64[R1])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:53.97085 UTC

[section "data" {
     Main._initOnly_closure:
         const Main._initOnly_info;
 },
 Main._initOnly_entry() //  [R2]
         { info_tbl: [(ckJr,
                       label: block_ckJr_info
                       rep:StackRep []),
                      (ckJu,
                       label: Main._initOnly_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckJu:
           _sk1M::P64 = R2;
           if ((Sp + -8) < SpLim) goto ckJv; else goto ckJw;
       ckJw:
           if (HpLim == 0) goto ckJv; else goto ckJx;
       ckJv:
           R2 = _sk1M::P64;
           R1 = Main._initOnly_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckJx:
           I64[Sp - 8] = ckJr;
           R1 = _sk1M::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ckJr; else goto ckJs;
       ckJs:
           call (I64[R1])(R1) returns to ckJr, args: 8, res: 8, upd: 8;
       ckJr:
           R1 = P64[R1 + 23] & (-8);
           Sp = Sp + 8;
           call (I64[R1])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:53.975117 UTC

[section "data" {
     Main._mix_closure:
         const Main._mix_info;
 },
 Main._mix_entry() //  [R2]
         { info_tbl: [(ckJR,
                       label: Main._mix_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckJR:
           _sk1V::P64 = R2;
           goto ckJM;
       ckJM:
           if ((old + 0) - <highSp> < SpLim) goto ckJS; else goto ckJT;
       ckJT:
           goto ckJL;
       ckJL:
           if (HpLim == 0) goto ckJS; else goto ckJU;
       ckJS:
           R2 = _sk1V::P64;
           R1 = Main._mix_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckJU:
           I64[(young<ckJO> + 8)] = ckJO;
           R1 = _sk1V::P64;
           if (R1 & 7 != 0) goto ckJO; else goto ckJP;
       ckJP:
           call (I64[R1])(R1) returns to ckJO, args: 8, res: 8, upd: 8;
       ckJO:
           _sk1W::P64 = R1;
           _sk1X::P64 = P64[_sk1W::P64 + 7];
           _sk1Y::P64 = P64[_sk1W::P64 + 15];
           _sk1Z::P64 = P64[_sk1W::P64 + 23];
           _sk20::P64 = P64[_sk1W::P64 + 31];
           _sk21::P64 = P64[_sk1W::P64 + 39];
           _sk22::P64 = P64[_sk1W::P64 + 47];
           _sk23::P64 = P64[_sk1W::P64 + 55];
           R1 = _sk22::P64 & (-8);
           call (I64[R1])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:53.977767 UTC

{offset
  ckJR:
      _sk1V::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckJS; else goto ckJT;
  ckJT:
      if (HpLim == 0) goto ckJS; else goto ckJU;
  ckJS:
      R2 = _sk1V::P64;
      R1 = Main._mix_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckJU:
      I64[(young<ckJO> + 8)] = ckJO;
      R1 = _sk1V::P64;
      if (R1 & 7 != 0) goto ckJO; else goto ckJP;
  ckJP:
      call (I64[R1])(R1) returns to ckJO, args: 8, res: 8, upd: 8;
  ckJO:
      _sk1W::P64 = R1;
      _sk1X::P64 = P64[_sk1W::P64 + 7];
      _sk1Y::P64 = P64[_sk1W::P64 + 15];
      _sk1Z::P64 = P64[_sk1W::P64 + 23];
      _sk20::P64 = P64[_sk1W::P64 + 31];
      _sk21::P64 = P64[_sk1W::P64 + 39];
      _sk22::P64 = P64[_sk1W::P64 + 47];
      _sk23::P64 = P64[_sk1W::P64 + 55];
      R1 = _sk22::P64 & (-8);
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:53.979287 UTC

{offset
  ckJR:
      _sk1V::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckJS; else goto ckJT;
  ckJT:
      if (HpLim == 0) goto ckJS; else goto ckJU;
  ckJS:
      R2 = _sk1V::P64;
      R1 = Main._mix_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckJU:
      I64[(young<ckJO> + 8)] = ckJO;
      R1 = _sk1V::P64;
      if (R1 & 7 != 0) goto ckJO; else goto ckJP;
  ckJP:
      call (I64[R1])(R1) returns to ckJO, args: 8, res: 8, upd: 8;
  ckJO:
      _sk1W::P64 = R1;
      _sk1X::P64 = P64[_sk1W::P64 + 7];
      _sk1Y::P64 = P64[_sk1W::P64 + 15];
      _sk1Z::P64 = P64[_sk1W::P64 + 23];
      _sk20::P64 = P64[_sk1W::P64 + 31];
      _sk21::P64 = P64[_sk1W::P64 + 39];
      _sk22::P64 = P64[_sk1W::P64 + 47];
      _sk23::P64 = P64[_sk1W::P64 + 55];
      R1 = _sk22::P64 & (-8);
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:53.98081 UTC

{offset
  ckJR:
      _sk1V::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckJS; else goto ckJT;
  ckJT:
      if (HpLim == 0) goto ckJS; else goto ckJU;
  ckJS:
      R2 = _sk1V::P64;
      R1 = Main._mix_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckJU:
      I64[(young<ckJO> + 8)] = ckJO;
      R1 = _sk1V::P64;
      if (R1 & 7 != 0) goto ckJO; else goto ckJP;
  ckJP:
      call (I64[R1])(R1) returns to ckJO, args: 8, res: 8, upd: 8;
  ckJO:
      _sk1W::P64 = R1;
      _sk1X::P64 = P64[_sk1W::P64 + 7];
      _sk1Y::P64 = P64[_sk1W::P64 + 15];
      _sk1Z::P64 = P64[_sk1W::P64 + 23];
      _sk20::P64 = P64[_sk1W::P64 + 31];
      _sk21::P64 = P64[_sk1W::P64 + 39];
      _sk22::P64 = P64[_sk1W::P64 + 47];
      _sk23::P64 = P64[_sk1W::P64 + 55];
      R1 = _sk22::P64 & (-8);
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:53.982475 UTC

{offset
  ckJR:
      _sk1V::P64 = R2;
      if ((Sp + 8) - 16 < SpLim) goto ckJS; else goto ckJT;
  ckJT:
      if (HpLim == 0) goto ckJS; else goto ckJU;
  ckJS:
      R2 = _sk1V::P64;
      R1 = Main._mix_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckJU:
      I64[Sp - 8] = ckJO;
      R1 = _sk1V::P64;
      Sp = Sp - 8;
      if (R1 & 7 != 0) goto ckJO; else goto ckJP;
  ckJP:
      call (I64[R1])(R1) returns to ckJO, args: 8, res: 8, upd: 8;
  ckJO:
      _sk1W::P64 = R1;
      _sk1X::P64 = P64[_sk1W::P64 + 7];
      _sk1Y::P64 = P64[_sk1W::P64 + 15];
      _sk1Z::P64 = P64[_sk1W::P64 + 23];
      _sk20::P64 = P64[_sk1W::P64 + 31];
      _sk21::P64 = P64[_sk1W::P64 + 39];
      _sk22::P64 = P64[_sk1W::P64 + 47];
      _sk23::P64 = P64[_sk1W::P64 + 55];
      R1 = _sk22::P64 & (-8);
      Sp = Sp + 8;
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:53.984011 UTC

{offset
  ckJR:
      _sk1V::P64 = R2;
      if ((Sp + -8) < SpLim) goto ckJS; else goto ckJT;
  ckJT:
      if (HpLim == 0) goto ckJS; else goto ckJU;
  ckJS:
      R2 = _sk1V::P64;
      R1 = Main._mix_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckJU:
      I64[Sp - 8] = ckJO;
      R1 = _sk1V::P64;
      Sp = Sp - 8;
      if (R1 & 7 != 0) goto ckJO; else goto ckJP;
  ckJP:
      call (I64[R1])(R1) returns to ckJO, args: 8, res: 8, upd: 8;
  ckJO:
      R1 = P64[R1 + 47] & (-8);
      Sp = Sp + 8;
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:53.985279 UTC

[(ckJO, {}), (ckJP, {}), (ckJR, {}), (ckJS, {}), (ckJT, {}),
 (ckJU, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:53.985665 UTC

Main._mix_entry() //  [R2]
        { info_tbl: [(ckJO,
                      label: block_ckJO_info
                      rep:StackRep []),
                     (ckJR,
                      label: Main._mix_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckJR:
          _sk1V::P64 = R2;
          if ((Sp + -8) < SpLim) goto ckJS; else goto ckJT;
      ckJT:
          if (HpLim == 0) goto ckJS; else goto ckJU;
      ckJS:
          R2 = _sk1V::P64;
          R1 = Main._mix_closure;
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
      ckJU:
          I64[Sp - 8] = ckJO;
          R1 = _sk1V::P64;
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto ckJO; else goto ckJP;
      ckJP:
          call (I64[R1])(R1) returns to ckJO, args: 8, res: 8, upd: 8;
      ckJO:
          R1 = P64[R1 + 47] & (-8);
          Sp = Sp + 8;
          call (I64[R1])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:53.987184 UTC

Main._mix_entry() //  [R2]
        { info_tbl: [(ckJO,
                      label: block_ckJO_info
                      rep:StackRep []),
                     (ckJR,
                      label: Main._mix_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckJR:
          _sk1V::P64 = R2;
          if ((Sp + -8) < SpLim) goto ckJS; else goto ckJT;
      ckJT:
          if (HpLim == 0) goto ckJS; else goto ckJU;
      ckJS:
          R2 = _sk1V::P64;
          R1 = Main._mix_closure;
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
      ckJU:
          I64[Sp - 8] = ckJO;
          R1 = _sk1V::P64;
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto ckJO; else goto ckJP;
      ckJP:
          call (I64[R1])(R1) returns to ckJO, args: 8, res: 8, upd: 8;
      ckJO:
          R1 = P64[R1 + 47] & (-8);
          Sp = Sp + 8;
          call (I64[R1])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:53.988664 UTC

[section "data" {
     Main._mix_closure:
         const Main._mix_info;
 },
 Main._mix_entry() //  [R2]
         { info_tbl: [(ckJO,
                       label: block_ckJO_info
                       rep:StackRep []),
                      (ckJR,
                       label: Main._mix_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckJR:
           _sk1V::P64 = R2;
           if ((Sp + -8) < SpLim) goto ckJS; else goto ckJT;
       ckJT:
           if (HpLim == 0) goto ckJS; else goto ckJU;
       ckJS:
           R2 = _sk1V::P64;
           R1 = Main._mix_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckJU:
           I64[Sp - 8] = ckJO;
           R1 = _sk1V::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ckJO; else goto ckJP;
       ckJP:
           call (I64[R1])(R1) returns to ckJO, args: 8, res: 8, upd: 8;
       ckJO:
           R1 = P64[R1 + 47] & (-8);
           Sp = Sp + 8;
           call (I64[R1])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:53.990308 UTC

[section "data" {
     Main._mix_closure:
         const Main._mix_info;
 },
 Main._mix_entry() //  [R2]
         { info_tbl: [(ckJO,
                       label: block_ckJO_info
                       rep:StackRep []),
                      (ckJR,
                       label: Main._mix_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckJR:
           _sk1V::P64 = R2;
           if ((Sp + -8) < SpLim) goto ckJS; else goto ckJT;
       ckJT:
           if (HpLim == 0) goto ckJS; else goto ckJU;
       ckJS:
           R2 = _sk1V::P64;
           R1 = Main._mix_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckJU:
           I64[Sp - 8] = ckJO;
           R1 = _sk1V::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ckJO; else goto ckJP;
       ckJP:
           call (I64[R1])(R1) returns to ckJO, args: 8, res: 8, upd: 8;
       ckJO:
           R1 = P64[R1 + 47] & (-8);
           Sp = Sp + 8;
           call (I64[R1])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:53.994605 UTC

[section "data" {
     Main._threads_closure:
         const Main._threads_info;
 },
 Main._threads_entry() //  [R2]
         { info_tbl: [(ckKe,
                       label: Main._threads_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckKe:
           _sk24::P64 = R2;
           goto ckK9;
       ckK9:
           if ((old + 0) - <highSp> < SpLim) goto ckKf; else goto ckKg;
       ckKg:
           goto ckK8;
       ckK8:
           if (HpLim == 0) goto ckKf; else goto ckKh;
       ckKf:
           R2 = _sk24::P64;
           R1 = Main._threads_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckKh:
           I64[(young<ckKb> + 8)] = ckKb;
           R1 = _sk24::P64;
           if (R1 & 7 != 0) goto ckKb; else goto ckKc;
       ckKc:
           call (I64[R1])(R1) returns to ckKb, args: 8, res: 8, upd: 8;
       ckKb:
           _sk25::P64 = R1;
           _sk26::P64 = P64[_sk25::P64 + 7];
           _sk27::P64 = P64[_sk25::P64 + 15];
           _sk28::P64 = P64[_sk25::P64 + 23];
           _sk29::P64 = P64[_sk25::P64 + 31];
           _sk2a::P64 = P64[_sk25::P64 + 39];
           _sk2b::P64 = P64[_sk25::P64 + 47];
           _sk2c::P64 = P64[_sk25::P64 + 55];
           R1 = _sk27::P64 & (-8);
           call (I64[R1])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:53.997816 UTC

{offset
  ckKe:
      _sk24::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckKf; else goto ckKg;
  ckKg:
      if (HpLim == 0) goto ckKf; else goto ckKh;
  ckKf:
      R2 = _sk24::P64;
      R1 = Main._threads_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckKh:
      I64[(young<ckKb> + 8)] = ckKb;
      R1 = _sk24::P64;
      if (R1 & 7 != 0) goto ckKb; else goto ckKc;
  ckKc:
      call (I64[R1])(R1) returns to ckKb, args: 8, res: 8, upd: 8;
  ckKb:
      _sk25::P64 = R1;
      _sk26::P64 = P64[_sk25::P64 + 7];
      _sk27::P64 = P64[_sk25::P64 + 15];
      _sk28::P64 = P64[_sk25::P64 + 23];
      _sk29::P64 = P64[_sk25::P64 + 31];
      _sk2a::P64 = P64[_sk25::P64 + 39];
      _sk2b::P64 = P64[_sk25::P64 + 47];
      _sk2c::P64 = P64[_sk25::P64 + 55];
      R1 = _sk27::P64 & (-8);
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:53.999398 UTC

{offset
  ckKe:
      _sk24::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckKf; else goto ckKg;
  ckKg:
      if (HpLim == 0) goto ckKf; else goto ckKh;
  ckKf:
      R2 = _sk24::P64;
      R1 = Main._threads_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckKh:
      I64[(young<ckKb> + 8)] = ckKb;
      R1 = _sk24::P64;
      if (R1 & 7 != 0) goto ckKb; else goto ckKc;
  ckKc:
      call (I64[R1])(R1) returns to ckKb, args: 8, res: 8, upd: 8;
  ckKb:
      _sk25::P64 = R1;
      _sk26::P64 = P64[_sk25::P64 + 7];
      _sk27::P64 = P64[_sk25::P64 + 15];
      _sk28::P64 = P64[_sk25::P64 + 23];
      _sk29::P64 = P64[_sk25::P64 + 31];
      _sk2a::P64 = P64[_sk25::P64 + 39];
      _sk2b::P64 = P64[_sk25::P64 + 47];
      _sk2c::P64 = P64[_sk25::P64 + 55];
      R1 = _sk27::P64 & (-8);
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:54.000842 UTC

{offset
  ckKe:
      _sk24::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckKf; else goto ckKg;
  ckKg:
      if (HpLim == 0) goto ckKf; else goto ckKh;
  ckKf:
      R2 = _sk24::P64;
      R1 = Main._threads_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckKh:
      I64[(young<ckKb> + 8)] = ckKb;
      R1 = _sk24::P64;
      if (R1 & 7 != 0) goto ckKb; else goto ckKc;
  ckKc:
      call (I64[R1])(R1) returns to ckKb, args: 8, res: 8, upd: 8;
  ckKb:
      _sk25::P64 = R1;
      _sk26::P64 = P64[_sk25::P64 + 7];
      _sk27::P64 = P64[_sk25::P64 + 15];
      _sk28::P64 = P64[_sk25::P64 + 23];
      _sk29::P64 = P64[_sk25::P64 + 31];
      _sk2a::P64 = P64[_sk25::P64 + 39];
      _sk2b::P64 = P64[_sk25::P64 + 47];
      _sk2c::P64 = P64[_sk25::P64 + 55];
      R1 = _sk27::P64 & (-8);
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:54.002488 UTC

{offset
  ckKe:
      _sk24::P64 = R2;
      if ((Sp + 8) - 16 < SpLim) goto ckKf; else goto ckKg;
  ckKg:
      if (HpLim == 0) goto ckKf; else goto ckKh;
  ckKf:
      R2 = _sk24::P64;
      R1 = Main._threads_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckKh:
      I64[Sp - 8] = ckKb;
      R1 = _sk24::P64;
      Sp = Sp - 8;
      if (R1 & 7 != 0) goto ckKb; else goto ckKc;
  ckKc:
      call (I64[R1])(R1) returns to ckKb, args: 8, res: 8, upd: 8;
  ckKb:
      _sk25::P64 = R1;
      _sk26::P64 = P64[_sk25::P64 + 7];
      _sk27::P64 = P64[_sk25::P64 + 15];
      _sk28::P64 = P64[_sk25::P64 + 23];
      _sk29::P64 = P64[_sk25::P64 + 31];
      _sk2a::P64 = P64[_sk25::P64 + 39];
      _sk2b::P64 = P64[_sk25::P64 + 47];
      _sk2c::P64 = P64[_sk25::P64 + 55];
      R1 = _sk27::P64 & (-8);
      Sp = Sp + 8;
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:54.004002 UTC

{offset
  ckKe:
      _sk24::P64 = R2;
      if ((Sp + -8) < SpLim) goto ckKf; else goto ckKg;
  ckKg:
      if (HpLim == 0) goto ckKf; else goto ckKh;
  ckKf:
      R2 = _sk24::P64;
      R1 = Main._threads_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckKh:
      I64[Sp - 8] = ckKb;
      R1 = _sk24::P64;
      Sp = Sp - 8;
      if (R1 & 7 != 0) goto ckKb; else goto ckKc;
  ckKc:
      call (I64[R1])(R1) returns to ckKb, args: 8, res: 8, upd: 8;
  ckKb:
      R1 = P64[R1 + 15] & (-8);
      Sp = Sp + 8;
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:54.005269 UTC

[(ckKb, {}), (ckKc, {}), (ckKe, {}), (ckKf, {}), (ckKg, {}),
 (ckKh, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:54.005651 UTC

Main._threads_entry() //  [R2]
        { info_tbl: [(ckKb,
                      label: block_ckKb_info
                      rep:StackRep []),
                     (ckKe,
                      label: Main._threads_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckKe:
          _sk24::P64 = R2;
          if ((Sp + -8) < SpLim) goto ckKf; else goto ckKg;
      ckKg:
          if (HpLim == 0) goto ckKf; else goto ckKh;
      ckKf:
          R2 = _sk24::P64;
          R1 = Main._threads_closure;
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
      ckKh:
          I64[Sp - 8] = ckKb;
          R1 = _sk24::P64;
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto ckKb; else goto ckKc;
      ckKc:
          call (I64[R1])(R1) returns to ckKb, args: 8, res: 8, upd: 8;
      ckKb:
          R1 = P64[R1 + 15] & (-8);
          Sp = Sp + 8;
          call (I64[R1])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:54.007146 UTC

Main._threads_entry() //  [R2]
        { info_tbl: [(ckKb,
                      label: block_ckKb_info
                      rep:StackRep []),
                     (ckKe,
                      label: Main._threads_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckKe:
          _sk24::P64 = R2;
          if ((Sp + -8) < SpLim) goto ckKf; else goto ckKg;
      ckKg:
          if (HpLim == 0) goto ckKf; else goto ckKh;
      ckKf:
          R2 = _sk24::P64;
          R1 = Main._threads_closure;
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
      ckKh:
          I64[Sp - 8] = ckKb;
          R1 = _sk24::P64;
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto ckKb; else goto ckKc;
      ckKc:
          call (I64[R1])(R1) returns to ckKb, args: 8, res: 8, upd: 8;
      ckKb:
          R1 = P64[R1 + 15] & (-8);
          Sp = Sp + 8;
          call (I64[R1])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:54.008618 UTC

[section "data" {
     Main._threads_closure:
         const Main._threads_info;
 },
 Main._threads_entry() //  [R2]
         { info_tbl: [(ckKb,
                       label: block_ckKb_info
                       rep:StackRep []),
                      (ckKe,
                       label: Main._threads_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckKe:
           _sk24::P64 = R2;
           if ((Sp + -8) < SpLim) goto ckKf; else goto ckKg;
       ckKg:
           if (HpLim == 0) goto ckKf; else goto ckKh;
       ckKf:
           R2 = _sk24::P64;
           R1 = Main._threads_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckKh:
           I64[Sp - 8] = ckKb;
           R1 = _sk24::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ckKb; else goto ckKc;
       ckKc:
           call (I64[R1])(R1) returns to ckKb, args: 8, res: 8, upd: 8;
       ckKb:
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[R1])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:54.010274 UTC

[section "data" {
     Main._threads_closure:
         const Main._threads_info;
 },
 Main._threads_entry() //  [R2]
         { info_tbl: [(ckKb,
                       label: block_ckKb_info
                       rep:StackRep []),
                      (ckKe,
                       label: Main._threads_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckKe:
           _sk24::P64 = R2;
           if ((Sp + -8) < SpLim) goto ckKf; else goto ckKg;
       ckKg:
           if (HpLim == 0) goto ckKf; else goto ckKh;
       ckKf:
           R2 = _sk24::P64;
           R1 = Main._threads_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckKh:
           I64[Sp - 8] = ckKb;
           R1 = _sk24::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ckKb; else goto ckKc;
       ckKc:
           call (I64[R1])(R1) returns to ckKb, args: 8, res: 8, upd: 8;
       ckKb:
           R1 = P64[R1 + 15] & (-8);
           Sp = Sp + 8;
           call (I64[R1])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:54.014541 UTC

[section "data" {
     Main._throughput_closure:
         const Main._throughput_info;
 },
 Main._throughput_entry() //  [R2]
         { info_tbl: [(ckKB,
                       label: Main._throughput_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckKB:
           _sk2d::P64 = R2;
           goto ckKw;
       ckKw:
           if ((old + 0) - <highSp> < SpLim) goto ckKC; else goto ckKD;
       ckKD:
           goto ckKv;
       ckKv:
           if (HpLim == 0) goto ckKC; else goto ckKE;
       ckKC:
           R2 = _sk2d::P64;
           R1 = Main._throughput_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckKE:
           I64[(young<ckKy> + 8)] = ckKy;
           R1 = _sk2d::P64;
           if (R1 & 7 != 0) goto ckKy; else goto ckKz;
       ckKz:
           call (I64[R1])(R1) returns to ckKy, args: 8, res: 8, upd: 8;
       ckKy:
           _sk2e::P64 = R1;
           _sk2f::P64 = P64[_sk2e::P64 + 7];
           _sk2g::P64 = P64[_sk2e::P64 + 15];
           _sk2h::P64 = P64[_sk2e::P64 + 23];
           _sk2i::P64 = P64[_sk2e::P64 + 31];
           _sk2j::P64 = P64[_sk2e::P64 + 39];
           _sk2k::P64 = P64[_sk2e::P64 + 47];
           _sk2l::P64 = P64[_sk2e::P64 + 55];
           R1 = _sk2l::P64 & (-8);
           call (I64[R1])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:54.017201 UTC

{offset
  ckKB:
      _sk2d::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckKC; else goto ckKD;
  ckKD:
      if (HpLim == 0) goto ckKC; else goto ckKE;
  ckKC:
      R2 = _sk2d::P64;
      R1 = Main._throughput_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckKE:
      I64[(young<ckKy> + 8)] = ckKy;
      R1 = _sk2d::P64;
      if (R1 & 7 != 0) goto ckKy; else goto ckKz;
  ckKz:
      call (I64[R1])(R1) returns to ckKy, args: 8, res: 8, upd: 8;
  ckKy:
      _sk2e::P64 = R1;
      _sk2f::P64 = P64[_sk2e::P64 + 7];
      _sk2g::P64 = P64[_sk2e::P64 + 15];
      _sk2h::P64 = P64[_sk2e::P64 + 23];
      _sk2i::P64 = P64[_sk2e::P64 + 31];
      _sk2j::P64 = P64[_sk2e::P64 + 39];
      _sk2k::P64 = P64[_sk2e::P64 + 47];
      _sk2l::P64 = P64[_sk2e::P64 + 55];
      R1 = _sk2l::P64 & (-8);
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:54.018693 UTC

{offset
  ckKB:
      _sk2d::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckKC; else goto ckKD;
  ckKD:
      if (HpLim == 0) goto ckKC; else goto ckKE;
  ckKC:
      R2 = _sk2d::P64;
      R1 = Main._throughput_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckKE:
      I64[(young<ckKy> + 8)] = ckKy;
      R1 = _sk2d::P64;
      if (R1 & 7 != 0) goto ckKy; else goto ckKz;
  ckKz:
      call (I64[R1])(R1) returns to ckKy, args: 8, res: 8, upd: 8;
  ckKy:
      _sk2e::P64 = R1;
      _sk2f::P64 = P64[_sk2e::P64 + 7];
      _sk2g::P64 = P64[_sk2e::P64 + 15];
      _sk2h::P64 = P64[_sk2e::P64 + 23];
      _sk2i::P64 = P64[_sk2e::P64 + 31];
      _sk2j::P64 = P64[_sk2e::P64 + 39];
      _sk2k::P64 = P64[_sk2e::P64 + 47];
      _sk2l::P64 = P64[_sk2e::P64 + 55];
      R1 = _sk2l::P64 & (-8);
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:54.020228 UTC

{offset
  ckKB:
      _sk2d::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckKC; else goto ckKD;
  ckKD:
      if (HpLim == 0) goto ckKC; else goto ckKE;
  ckKC:
      R2 = _sk2d::P64;
      R1 = Main._throughput_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckKE:
      I64[(young<ckKy> + 8)] = ckKy;
      R1 = _sk2d::P64;
      if (R1 & 7 != 0) goto ckKy; else goto ckKz;
  ckKz:
      call (I64[R1])(R1) returns to ckKy, args: 8, res: 8, upd: 8;
  ckKy:
      _sk2e::P64 = R1;
      _sk2f::P64 = P64[_sk2e::P64 + 7];
      _sk2g::P64 = P64[_sk2e::P64 + 15];
      _sk2h::P64 = P64[_sk2e::P64 + 23];
      _sk2i::P64 = P64[_sk2e::P64 + 31];
      _sk2j::P64 = P64[_sk2e::P64 + 39];
      _sk2k::P64 = P64[_sk2e::P64 + 47];
      _sk2l::P64 = P64[_sk2e::P64 + 55];
      R1 = _sk2l::P64 & (-8);
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:54.021901 UTC

{offset
  ckKB:
      _sk2d::P64 = R2;
      if ((Sp + 8) - 16 < SpLim) goto ckKC; else goto ckKD;
  ckKD:
      if (HpLim == 0) goto ckKC; else goto ckKE;
  ckKC:
      R2 = _sk2d::P64;
      R1 = Main._throughput_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckKE:
      I64[Sp - 8] = ckKy;
      R1 = _sk2d::P64;
      Sp = Sp - 8;
      if (R1 & 7 != 0) goto ckKy; else goto ckKz;
  ckKz:
      call (I64[R1])(R1) returns to ckKy, args: 8, res: 8, upd: 8;
  ckKy:
      _sk2e::P64 = R1;
      _sk2f::P64 = P64[_sk2e::P64 + 7];
      _sk2g::P64 = P64[_sk2e::P64 + 15];
      _sk2h::P64 = P64[_sk2e::P64 + 23];
      _sk2i::P64 = P64[_sk2e::P64 + 31];
      _sk2j::P64 = P64[_sk2e::P64 + 39];
      _sk2k::P64 = P64[_sk2e::P64 + 47];
      _sk2l::P64 = P64[_sk2e::P64 + 55];
      R1 = _sk2l::P64 & (-8);
      Sp = Sp + 8;
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:54.023464 UTC

{offset
  ckKB:
      _sk2d::P64 = R2;
      if ((Sp + -8) < SpLim) goto ckKC; else goto ckKD;
  ckKD:
      if (HpLim == 0) goto ckKC; else goto ckKE;
  ckKC:
      R2 = _sk2d::P64;
      R1 = Main._throughput_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckKE:
      I64[Sp - 8] = ckKy;
      R1 = _sk2d::P64;
      Sp = Sp - 8;
      if (R1 & 7 != 0) goto ckKy; else goto ckKz;
  ckKz:
      call (I64[R1])(R1) returns to ckKy, args: 8, res: 8, upd: 8;
  ckKy:
      R1 = P64[R1 + 55] & (-8);
      Sp = Sp + 8;
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:54.024726 UTC

[(ckKy, {}), (ckKz, {}), (ckKB, {}), (ckKC, {}), (ckKD, {}),
 (ckKE, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:54.025113 UTC

Main._throughput_entry() //  [R2]
        { info_tbl: [(ckKy,
                      label: block_ckKy_info
                      rep:StackRep []),
                     (ckKB,
                      label: Main._throughput_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckKB:
          _sk2d::P64 = R2;
          if ((Sp + -8) < SpLim) goto ckKC; else goto ckKD;
      ckKD:
          if (HpLim == 0) goto ckKC; else goto ckKE;
      ckKC:
          R2 = _sk2d::P64;
          R1 = Main._throughput_closure;
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
      ckKE:
          I64[Sp - 8] = ckKy;
          R1 = _sk2d::P64;
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto ckKy; else goto ckKz;
      ckKz:
          call (I64[R1])(R1) returns to ckKy, args: 8, res: 8, upd: 8;
      ckKy:
          R1 = P64[R1 + 55] & (-8);
          Sp = Sp + 8;
          call (I64[R1])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:54.026588 UTC

Main._throughput_entry() //  [R2]
        { info_tbl: [(ckKy,
                      label: block_ckKy_info
                      rep:StackRep []),
                     (ckKB,
                      label: Main._throughput_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckKB:
          _sk2d::P64 = R2;
          if ((Sp + -8) < SpLim) goto ckKC; else goto ckKD;
      ckKD:
          if (HpLim == 0) goto ckKC; else goto ckKE;
      ckKC:
          R2 = _sk2d::P64;
          R1 = Main._throughput_closure;
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
      ckKE:
          I64[Sp - 8] = ckKy;
          R1 = _sk2d::P64;
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto ckKy; else goto ckKz;
      ckKz:
          call (I64[R1])(R1) returns to ckKy, args: 8, res: 8, upd: 8;
      ckKy:
          R1 = P64[R1 + 55] & (-8);
          Sp = Sp + 8;
          call (I64[R1])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:54.02809 UTC

[section "data" {
     Main._throughput_closure:
         const Main._throughput_info;
 },
 Main._throughput_entry() //  [R2]
         { info_tbl: [(ckKy,
                       label: block_ckKy_info
                       rep:StackRep []),
                      (ckKB,
                       label: Main._throughput_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckKB:
           _sk2d::P64 = R2;
           if ((Sp + -8) < SpLim) goto ckKC; else goto ckKD;
       ckKD:
           if (HpLim == 0) goto ckKC; else goto ckKE;
       ckKC:
           R2 = _sk2d::P64;
           R1 = Main._throughput_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckKE:
           I64[Sp - 8] = ckKy;
           R1 = _sk2d::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ckKy; else goto ckKz;
       ckKz:
           call (I64[R1])(R1) returns to ckKy, args: 8, res: 8, upd: 8;
       ckKy:
           R1 = P64[R1 + 55] & (-8);
           Sp = Sp + 8;
           call (I64[R1])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:54.029738 UTC

[section "data" {
     Main._throughput_closure:
         const Main._throughput_info;
 },
 Main._throughput_entry() //  [R2]
         { info_tbl: [(ckKy,
                       label: block_ckKy_info
                       rep:StackRep []),
                      (ckKB,
                       label: Main._throughput_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckKB:
           _sk2d::P64 = R2;
           if ((Sp + -8) < SpLim) goto ckKC; else goto ckKD;
       ckKD:
           if (HpLim == 0) goto ckKC; else goto ckKE;
       ckKC:
           R2 = _sk2d::P64;
           R1 = Main._throughput_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckKE:
           I64[Sp - 8] = ckKy;
           R1 = _sk2d::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ckKy; else goto ckKz;
       ckKz:
           call (I64[R1])(R1) returns to ckKy, args: 8, res: 8, upd: 8;
       ckKy:
           R1 = P64[R1 + 55] & (-8);
           Sp = Sp + 8;
           call (I64[R1])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:54.034013 UTC

[section "data" {
     Main._withoutTM_closure:
         const Main._withoutTM_info;
 },
 Main._withoutTM_entry() //  [R2]
         { info_tbl: [(ckKY,
                       label: Main._withoutTM_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckKY:
           _sk2m::P64 = R2;
           goto ckKT;
       ckKT:
           if ((old + 0) - <highSp> < SpLim) goto ckKZ; else goto ckL0;
       ckL0:
           goto ckKS;
       ckKS:
           if (HpLim == 0) goto ckKZ; else goto ckL1;
       ckKZ:
           R2 = _sk2m::P64;
           R1 = Main._withoutTM_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckL1:
           I64[(young<ckKV> + 8)] = ckKV;
           R1 = _sk2m::P64;
           if (R1 & 7 != 0) goto ckKV; else goto ckKW;
       ckKW:
           call (I64[R1])(R1) returns to ckKV, args: 8, res: 8, upd: 8;
       ckKV:
           _sk2n::P64 = R1;
           _sk2o::P64 = P64[_sk2n::P64 + 7];
           _sk2p::P64 = P64[_sk2n::P64 + 15];
           _sk2q::P64 = P64[_sk2n::P64 + 23];
           _sk2r::P64 = P64[_sk2n::P64 + 31];
           _sk2s::P64 = P64[_sk2n::P64 + 39];
           _sk2t::P64 = P64[_sk2n::P64 + 47];
           _sk2u::P64 = P64[_sk2n::P64 + 55];
           R1 = _sk2r::P64 & (-8);
           call (I64[R1])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:54.037265 UTC

{offset
  ckKY:
      _sk2m::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckKZ; else goto ckL0;
  ckL0:
      if (HpLim == 0) goto ckKZ; else goto ckL1;
  ckKZ:
      R2 = _sk2m::P64;
      R1 = Main._withoutTM_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckL1:
      I64[(young<ckKV> + 8)] = ckKV;
      R1 = _sk2m::P64;
      if (R1 & 7 != 0) goto ckKV; else goto ckKW;
  ckKW:
      call (I64[R1])(R1) returns to ckKV, args: 8, res: 8, upd: 8;
  ckKV:
      _sk2n::P64 = R1;
      _sk2o::P64 = P64[_sk2n::P64 + 7];
      _sk2p::P64 = P64[_sk2n::P64 + 15];
      _sk2q::P64 = P64[_sk2n::P64 + 23];
      _sk2r::P64 = P64[_sk2n::P64 + 31];
      _sk2s::P64 = P64[_sk2n::P64 + 39];
      _sk2t::P64 = P64[_sk2n::P64 + 47];
      _sk2u::P64 = P64[_sk2n::P64 + 55];
      R1 = _sk2r::P64 & (-8);
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:54.038761 UTC

{offset
  ckKY:
      _sk2m::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckKZ; else goto ckL0;
  ckL0:
      if (HpLim == 0) goto ckKZ; else goto ckL1;
  ckKZ:
      R2 = _sk2m::P64;
      R1 = Main._withoutTM_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckL1:
      I64[(young<ckKV> + 8)] = ckKV;
      R1 = _sk2m::P64;
      if (R1 & 7 != 0) goto ckKV; else goto ckKW;
  ckKW:
      call (I64[R1])(R1) returns to ckKV, args: 8, res: 8, upd: 8;
  ckKV:
      _sk2n::P64 = R1;
      _sk2o::P64 = P64[_sk2n::P64 + 7];
      _sk2p::P64 = P64[_sk2n::P64 + 15];
      _sk2q::P64 = P64[_sk2n::P64 + 23];
      _sk2r::P64 = P64[_sk2n::P64 + 31];
      _sk2s::P64 = P64[_sk2n::P64 + 39];
      _sk2t::P64 = P64[_sk2n::P64 + 47];
      _sk2u::P64 = P64[_sk2n::P64 + 55];
      R1 = _sk2r::P64 & (-8);
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:54.040377 UTC

{offset
  ckKY:
      _sk2m::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckKZ; else goto ckL0;
  ckL0:
      if (HpLim == 0) goto ckKZ; else goto ckL1;
  ckKZ:
      R2 = _sk2m::P64;
      R1 = Main._withoutTM_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckL1:
      I64[(young<ckKV> + 8)] = ckKV;
      R1 = _sk2m::P64;
      if (R1 & 7 != 0) goto ckKV; else goto ckKW;
  ckKW:
      call (I64[R1])(R1) returns to ckKV, args: 8, res: 8, upd: 8;
  ckKV:
      _sk2n::P64 = R1;
      _sk2o::P64 = P64[_sk2n::P64 + 7];
      _sk2p::P64 = P64[_sk2n::P64 + 15];
      _sk2q::P64 = P64[_sk2n::P64 + 23];
      _sk2r::P64 = P64[_sk2n::P64 + 31];
      _sk2s::P64 = P64[_sk2n::P64 + 39];
      _sk2t::P64 = P64[_sk2n::P64 + 47];
      _sk2u::P64 = P64[_sk2n::P64 + 55];
      R1 = _sk2r::P64 & (-8);
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:54.04202 UTC

{offset
  ckKY:
      _sk2m::P64 = R2;
      if ((Sp + 8) - 16 < SpLim) goto ckKZ; else goto ckL0;
  ckL0:
      if (HpLim == 0) goto ckKZ; else goto ckL1;
  ckKZ:
      R2 = _sk2m::P64;
      R1 = Main._withoutTM_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckL1:
      I64[Sp - 8] = ckKV;
      R1 = _sk2m::P64;
      Sp = Sp - 8;
      if (R1 & 7 != 0) goto ckKV; else goto ckKW;
  ckKW:
      call (I64[R1])(R1) returns to ckKV, args: 8, res: 8, upd: 8;
  ckKV:
      _sk2n::P64 = R1;
      _sk2o::P64 = P64[_sk2n::P64 + 7];
      _sk2p::P64 = P64[_sk2n::P64 + 15];
      _sk2q::P64 = P64[_sk2n::P64 + 23];
      _sk2r::P64 = P64[_sk2n::P64 + 31];
      _sk2s::P64 = P64[_sk2n::P64 + 39];
      _sk2t::P64 = P64[_sk2n::P64 + 47];
      _sk2u::P64 = P64[_sk2n::P64 + 55];
      R1 = _sk2r::P64 & (-8);
      Sp = Sp + 8;
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:54.043565 UTC

{offset
  ckKY:
      _sk2m::P64 = R2;
      if ((Sp + -8) < SpLim) goto ckKZ; else goto ckL0;
  ckL0:
      if (HpLim == 0) goto ckKZ; else goto ckL1;
  ckKZ:
      R2 = _sk2m::P64;
      R1 = Main._withoutTM_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckL1:
      I64[Sp - 8] = ckKV;
      R1 = _sk2m::P64;
      Sp = Sp - 8;
      if (R1 & 7 != 0) goto ckKV; else goto ckKW;
  ckKW:
      call (I64[R1])(R1) returns to ckKV, args: 8, res: 8, upd: 8;
  ckKV:
      R1 = P64[R1 + 31] & (-8);
      Sp = Sp + 8;
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:54.044816 UTC

[(ckKV, {}), (ckKW, {}), (ckKY, {}), (ckKZ, {}), (ckL0, {}),
 (ckL1, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:54.045212 UTC

Main._withoutTM_entry() //  [R2]
        { info_tbl: [(ckKV,
                      label: block_ckKV_info
                      rep:StackRep []),
                     (ckKY,
                      label: Main._withoutTM_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckKY:
          _sk2m::P64 = R2;
          if ((Sp + -8) < SpLim) goto ckKZ; else goto ckL0;
      ckL0:
          if (HpLim == 0) goto ckKZ; else goto ckL1;
      ckKZ:
          R2 = _sk2m::P64;
          R1 = Main._withoutTM_closure;
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
      ckL1:
          I64[Sp - 8] = ckKV;
          R1 = _sk2m::P64;
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto ckKV; else goto ckKW;
      ckKW:
          call (I64[R1])(R1) returns to ckKV, args: 8, res: 8, upd: 8;
      ckKV:
          R1 = P64[R1 + 31] & (-8);
          Sp = Sp + 8;
          call (I64[R1])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:54.046674 UTC

Main._withoutTM_entry() //  [R2]
        { info_tbl: [(ckKV,
                      label: block_ckKV_info
                      rep:StackRep []),
                     (ckKY,
                      label: Main._withoutTM_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckKY:
          _sk2m::P64 = R2;
          if ((Sp + -8) < SpLim) goto ckKZ; else goto ckL0;
      ckL0:
          if (HpLim == 0) goto ckKZ; else goto ckL1;
      ckKZ:
          R2 = _sk2m::P64;
          R1 = Main._withoutTM_closure;
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
      ckL1:
          I64[Sp - 8] = ckKV;
          R1 = _sk2m::P64;
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto ckKV; else goto ckKW;
      ckKW:
          call (I64[R1])(R1) returns to ckKV, args: 8, res: 8, upd: 8;
      ckKV:
          R1 = P64[R1 + 31] & (-8);
          Sp = Sp + 8;
          call (I64[R1])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:54.048158 UTC

[section "data" {
     Main._withoutTM_closure:
         const Main._withoutTM_info;
 },
 Main._withoutTM_entry() //  [R2]
         { info_tbl: [(ckKV,
                       label: block_ckKV_info
                       rep:StackRep []),
                      (ckKY,
                       label: Main._withoutTM_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckKY:
           _sk2m::P64 = R2;
           if ((Sp + -8) < SpLim) goto ckKZ; else goto ckL0;
       ckL0:
           if (HpLim == 0) goto ckKZ; else goto ckL1;
       ckKZ:
           R2 = _sk2m::P64;
           R1 = Main._withoutTM_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckL1:
           I64[Sp - 8] = ckKV;
           R1 = _sk2m::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ckKV; else goto ckKW;
       ckKW:
           call (I64[R1])(R1) returns to ckKV, args: 8, res: 8, upd: 8;
       ckKV:
           R1 = P64[R1 + 31] & (-8);
           Sp = Sp + 8;
           call (I64[R1])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:54.049774 UTC

[section "data" {
     Main._withoutTM_closure:
         const Main._withoutTM_info;
 },
 Main._withoutTM_entry() //  [R2]
         { info_tbl: [(ckKV,
                       label: block_ckKV_info
                       rep:StackRep []),
                      (ckKY,
                       label: Main._withoutTM_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckKY:
           _sk2m::P64 = R2;
           if ((Sp + -8) < SpLim) goto ckKZ; else goto ckL0;
       ckL0:
           if (HpLim == 0) goto ckKZ; else goto ckL1;
       ckKZ:
           R2 = _sk2m::P64;
           R1 = Main._withoutTM_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckL1:
           I64[Sp - 8] = ckKV;
           R1 = _sk2m::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ckKV; else goto ckKW;
       ckKW:
           call (I64[R1])(R1) returns to ckKV, args: 8, res: 8, upd: 8;
       ckKV:
           R1 = P64[R1 + 31] & (-8);
           Sp = Sp + 8;
           call (I64[R1])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:54.054278 UTC

[section "data" {
     a5_rjVe_closure:
         const a5_rjVe_info;
 },
 a5_rjVe_entry() //  [R2]
         { info_tbl: [(ckLv,
                       label: a5_rjVe_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckLv:
           _sk2v::P64 = R2;
           goto ckLm;
       ckLm:
           if ((old + 0) - <highSp> < SpLim) goto ckLw; else goto ckLx;
       ckLx:
           goto ckLl;
       ckLl:
           if (HpLim == 0) goto ckLw; else goto ckLy;
       ckLw:
           R2 = _sk2v::P64;
           R1 = a5_rjVe_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckLy:
           I64[(young<ckLo> + 8)] = ckLo;
           R1 = _sk2v::P64;
           if (R1 & 7 != 0) goto ckLo; else goto ckLp;
       ckLp:
           call (I64[R1])(R1) returns to ckLo, args: 8, res: 8, upd: 8;
       ckLo:
           _sk2x::P64 = R1;
           _ckLu::P64 = _sk2x::P64 & 7;
           switch [1 .. 2] _ckLu::P64 {
               case 1 : goto ckLs;
               case 2 : goto ckLt;
           }
       ckLt:
           _sk2y::P64 = P64[_sk2x::P64 + 6];
           _sk2z::P64 = P64[_sk2x::P64 + 14];
           I64[(young<ckLE> + 8)] = ckLE;
           R1 = _sk2y::P64;
           if (R1 & 7 != 0) goto ckLE; else goto ckLF;
       ckLF:
           call (I64[R1])(R1) returns to ckLE, args: 8, res: 8, upd: 8;
       ckLE:
           _sk2A::P64 = R1;
           _sk2B::P64 = P64[_sk2A::P64 + 7];
           _sk2E::P64 = P64[_sk2B::P64 + 8];
           _sk2E::P64 = _sk2E::P64;
           I64[(young<ckLJ> + 8)] = ckLJ;
           R2 = _sk2z::P64;
           call a5_rjVe_info(R2) returns to ckLJ, args: 8, res: 8, upd: 8;
       ckLJ:
           _sk2H::P64 = R1;
           Hp = Hp + 24;
           if (Hp > HpLim) goto ckLQ; else goto ckLP;
       ckLQ:
           HpAlloc = 24;
           goto ckLO;
       ckLO:
           R1 = _sk2H::P64;
           call stg_gc_unpt_r1(R1) returns to ckLJ, args: 8, res: 8, upd: 8;
       ckLP:
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sk2E::P64;
           P64[Hp] = _sk2H::P64;
           _ckLL::P64 = Hp - 14;
           R1 = _ckLL::P64;
           call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
       ckLs:
           R1 = GHC.Types.[]_closure+1;
           call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:54.058938 UTC

{offset
  ckLv:
      _sk2v::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckLw; else goto ckLx;
  ckLx:
      if (HpLim == 0) goto ckLw; else goto ckLy;
  ckLw:
      R2 = _sk2v::P64;
      R1 = a5_rjVe_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckLy:
      I64[(young<ckLo> + 8)] = ckLo;
      R1 = _sk2v::P64;
      if (R1 & 7 != 0) goto ckLo; else goto ckLp;
  ckLp:
      call (I64[R1])(R1) returns to ckLo, args: 8, res: 8, upd: 8;
  ckLo:
      _sk2x::P64 = R1;
      _ckLu::P64 = _sk2x::P64 & 7;
      switch [1 .. 2] _ckLu::P64 {
          case 1 : goto ckLs;
          case 2 : goto ckLt;
      }
  ckLt:
      _sk2y::P64 = P64[_sk2x::P64 + 6];
      _sk2z::P64 = P64[_sk2x::P64 + 14];
      I64[(young<ckLE> + 8)] = ckLE;
      R1 = _sk2y::P64;
      if (R1 & 7 != 0) goto ckLE; else goto ckLF;
  ckLF:
      call (I64[R1])(R1) returns to ckLE, args: 8, res: 8, upd: 8;
  ckLE:
      _sk2A::P64 = R1;
      _sk2B::P64 = P64[_sk2A::P64 + 7];
      _sk2E::P64 = P64[_sk2B::P64 + 8];
      _sk2E::P64 = _sk2E::P64;
      I64[(young<ckLJ> + 8)] = ckLJ;
      R2 = _sk2z::P64;
      call a5_rjVe_info(R2) returns to ckLJ, args: 8, res: 8, upd: 8;
  ckLJ:
      _sk2H::P64 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto ckLQ; else goto ckLP;
  ckLQ:
      HpAlloc = 24;
      R1 = _sk2H::P64;
      call stg_gc_unpt_r1(R1) returns to ckLJ, args: 8, res: 8, upd: 8;
  ckLP:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _sk2E::P64;
      P64[Hp] = _sk2H::P64;
      _ckLL::P64 = Hp - 14;
      R1 = _ckLL::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
  ckLs:
      R1 = GHC.Types.[]_closure+1;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:54.061645 UTC

{offset
  ckLv:
      _sk2v::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckLw; else goto ckLx;
  ckLx:
      if (HpLim == 0) goto ckLw; else goto ckLy;
  ckLw:
      R2 = _sk2v::P64;
      R1 = a5_rjVe_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckLy:
      I64[(young<ckLo> + 8)] = ckLo;
      R1 = _sk2v::P64;
      if (R1 & 7 != 0) goto ckLo; else goto ckLp;
  ckLp:
      call (I64[R1])(R1) returns to ckLo, args: 8, res: 8, upd: 8;
  ckLo:
      _sk2x::P64 = R1;
      _ckLu::P64 = _sk2x::P64 & 7;
      switch [1 .. 2] _ckLu::P64 {
          case 1 : goto ckLs;
          case 2 : goto ckLt;
      }
  ckLt:
      _sk2y::P64 = P64[_sk2x::P64 + 6];
      _sk2z::P64 = P64[_sk2x::P64 + 14];
      I64[(young<ckLE> + 8)] = ckLE;
      R1 = _sk2y::P64;
      if (R1 & 7 != 0) goto ckLE; else goto ckLF;
  ckLF:
      call (I64[R1])(R1) returns to ckLE, args: 8, res: 8, upd: 8;
  ckLE:
      _sk2A::P64 = R1;
      _sk2B::P64 = P64[_sk2A::P64 + 7];
      _sk2E::P64 = P64[_sk2B::P64 + 8];
      _sk2E::P64 = _sk2E::P64;
      I64[(young<ckLJ> + 8)] = ckLJ;
      R2 = _sk2z::P64;
      call a5_rjVe_info(R2) returns to ckLJ, args: 8, res: 8, upd: 8;
  ckLJ:
      _sk2H::P64 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto ckLQ; else goto ckLP;
  ckLQ:
      HpAlloc = 24;
      R1 = _sk2H::P64;
      call stg_gc_unpt_r1(R1) returns to ckLJ, args: 8, res: 8, upd: 8;
  ckLP:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _sk2E::P64;
      P64[Hp] = _sk2H::P64;
      _ckLL::P64 = Hp - 14;
      R1 = _ckLL::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
  ckLs:
      R1 = GHC.Types.[]_closure+1;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:54.064368 UTC

{offset
  ckLv:
      _sk2v::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckLw; else goto ckLx;
  ckLx:
      if (HpLim == 0) goto ckLw; else goto ckLy;
  ckLw:
      R2 = _sk2v::P64;
      R1 = a5_rjVe_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckLy:
      I64[(young<ckLo> + 8)] = ckLo;
      R1 = _sk2v::P64;
      if (R1 & 7 != 0) goto ckLo; else goto ckLp;
  ckLp:
      call (I64[R1])(R1) returns to ckLo, args: 8, res: 8, upd: 8;
  ckLo:
      _sk2x::P64 = R1;
      _ckLu::P64 = _sk2x::P64 & 7;
      if (_ckLu::P64 != 1) goto ckLt; else goto ckLs;
  ckLt:
      _sk2y::P64 = P64[_sk2x::P64 + 6];
      _sk2z::P64 = P64[_sk2x::P64 + 14];
      I64[(young<ckLE> + 8)] = ckLE;
      R1 = _sk2y::P64;
      if (R1 & 7 != 0) goto ckLE; else goto ckLF;
  ckLF:
      call (I64[R1])(R1) returns to ckLE, args: 8, res: 8, upd: 8;
  ckLE:
      _sk2A::P64 = R1;
      _sk2B::P64 = P64[_sk2A::P64 + 7];
      _sk2E::P64 = P64[_sk2B::P64 + 8];
      _sk2E::P64 = _sk2E::P64;
      I64[(young<ckLJ> + 8)] = ckLJ;
      R2 = _sk2z::P64;
      call a5_rjVe_info(R2) returns to ckLJ, args: 8, res: 8, upd: 8;
  ckLJ:
      _sk2H::P64 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto ckLQ; else goto ckLP;
  ckLQ:
      HpAlloc = 24;
      R1 = _sk2H::P64;
      call stg_gc_unpt_r1(R1) returns to ckLJ, args: 8, res: 8, upd: 8;
  ckLP:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _sk2E::P64;
      P64[Hp] = _sk2H::P64;
      _ckLL::P64 = Hp - 14;
      R1 = _ckLL::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
  ckLs:
      R1 = GHC.Types.[]_closure+1;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:54.067375 UTC

{offset
  ckLv:
      _sk2v::P64 = R2;
      if ((Sp + 8) - 24 < SpLim) goto ckLw; else goto ckLx;
  ckLx:
      if (HpLim == 0) goto ckLw; else goto ckLy;
  ckLw:
      R2 = _sk2v::P64;
      R1 = a5_rjVe_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckLy:
      I64[Sp - 8] = ckLo;
      R1 = _sk2v::P64;
      Sp = Sp - 8;
      if (R1 & 7 != 0) goto ckLo; else goto ckLp;
  ckLp:
      call (I64[R1])(R1) returns to ckLo, args: 8, res: 8, upd: 8;
  ckLo:
      _sk2x::P64 = R1;
      _ckLu::P64 = _sk2x::P64 & 7;
      if (_ckLu::P64 != 1) goto ckLt; else goto ckLs;
  ckLt:
      _sk2y::P64 = P64[_sk2x::P64 + 6];
      _sk2z::P64 = P64[_sk2x::P64 + 14];
      I64[Sp - 8] = ckLE;
      R1 = _sk2y::P64;
      P64[Sp] = _sk2z::P64;
      Sp = Sp - 8;
      if (R1 & 7 != 0) goto ckLE; else goto ckLF;
  ckLF:
      call (I64[R1])(R1) returns to ckLE, args: 8, res: 8, upd: 8;
  ckLE:
      _sk2z::P64 = P64[Sp + 8];
      _sk2A::P64 = R1;
      _sk2B::P64 = P64[_sk2A::P64 + 7];
      _sk2E::P64 = P64[_sk2B::P64 + 8];
      _sk2E::P64 = _sk2E::P64;
      I64[Sp] = ckLJ;
      R2 = _sk2z::P64;
      P64[Sp + 8] = _sk2E::P64;
      call a5_rjVe_info(R2) returns to ckLJ, args: 8, res: 8, upd: 8;
  ckLJ:
      _sk2E::P64 = P64[Sp + 8];
      _sk2H::P64 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto ckLQ; else goto ckLP;
  ckLQ:
      HpAlloc = 24;
      R1 = _sk2H::P64;
      call stg_gc_unpt_r1(R1) returns to ckLJ, args: 8, res: 8, upd: 8;
  ckLP:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _sk2E::P64;
      P64[Hp] = _sk2H::P64;
      _ckLL::P64 = Hp - 14;
      R1 = _ckLL::P64;
      Sp = Sp + 16;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
  ckLs:
      R1 = GHC.Types.[]_closure+1;
      Sp = Sp + 8;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:54.070347 UTC

{offset
  ckLv:
      _sk2v::P64 = R2;
      if ((Sp + -16) < SpLim) goto ckLw; else goto ckLx;
  ckLx:
      if (HpLim == 0) goto ckLw; else goto ckLy;
  ckLw:
      R2 = _sk2v::P64;
      R1 = a5_rjVe_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckLy:
      I64[Sp - 8] = ckLo;
      R1 = _sk2v::P64;
      Sp = Sp - 8;
      if (R1 & 7 != 0) goto ckLo; else goto ckLp;
  ckLp:
      call (I64[R1])(R1) returns to ckLo, args: 8, res: 8, upd: 8;
  ckLo:
      if (R1 & 7 != 1) goto ckLt; else goto ckLs;
  ckLt:
      I64[Sp - 8] = ckLE;
      _sk2z::P64 = P64[R1 + 14];
      R1 = P64[R1 + 6];
      P64[Sp] = _sk2z::P64;
      Sp = Sp - 8;
      if (R1 & 7 != 0) goto ckLE; else goto ckLF;
  ckLF:
      call (I64[R1])(R1) returns to ckLE, args: 8, res: 8, upd: 8;
  ckLE:
      _sk2E::P64 = P64[P64[R1 + 7] + 8];
      I64[Sp] = ckLJ;
      R2 = P64[Sp + 8];
      P64[Sp + 8] = _sk2E::P64;
      call a5_rjVe_info(R2) returns to ckLJ, args: 8, res: 8, upd: 8;
  ckLJ:
      Hp = Hp + 24;
      if (Hp > HpLim) goto ckLQ; else goto ckLP;
  ckLQ:
      HpAlloc = 24;
      R1 = R1;
      call stg_gc_unpt_r1(R1) returns to ckLJ, args: 8, res: 8, upd: 8;
  ckLP:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = P64[Sp + 8];
      P64[Hp] = R1;
      R1 = Hp - 14;
      Sp = Sp + 16;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
  ckLs:
      R1 = GHC.Types.[]_closure+1;
      Sp = Sp + 8;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:54.073213 UTC

[(ckLo, {}), (ckLp, {}), (ckLs, {}), (ckLt, {}), (ckLv, {}),
 (ckLw, {}), (ckLx, {}), (ckLy, {}), (ckLE, {}), (ckLF, {}),
 (ckLJ, {}), (ckLP, {}), (ckLQ, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:54.073806 UTC

a5_rjVe_entry() //  [R2]
        { info_tbl: [(ckLo,
                      label: block_ckLo_info
                      rep:StackRep []),
                     (ckLv,
                      label: a5_rjVe_info
                      rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} }),
                     (ckLE,
                      label: block_ckLE_info
                      rep:StackRep [False]),
                     (ckLJ,
                      label: block_ckLJ_info
                      rep:StackRep [False])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckLv:
          _sk2v::P64 = R2;
          if ((Sp + -16) < SpLim) goto ckLw; else goto ckLx;
      ckLx:
          if (HpLim == 0) goto ckLw; else goto ckLy;
      ckLw:
          R2 = _sk2v::P64;
          R1 = a5_rjVe_closure;
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
      ckLy:
          I64[Sp - 8] = ckLo;
          R1 = _sk2v::P64;
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto ckLo; else goto ckLp;
      ckLp:
          call (I64[R1])(R1) returns to ckLo, args: 8, res: 8, upd: 8;
      ckLo:
          if (R1 & 7 != 1) goto ckLt; else goto ckLs;
      ckLt:
          I64[Sp - 8] = ckLE;
          _sk2z::P64 = P64[R1 + 14];
          R1 = P64[R1 + 6];
          P64[Sp] = _sk2z::P64;
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto ckLE; else goto ckLF;
      ckLF:
          call (I64[R1])(R1) returns to ckLE, args: 8, res: 8, upd: 8;
      ckLE:
          _sk2E::P64 = P64[P64[R1 + 7] + 8];
          I64[Sp] = ckLJ;
          R2 = P64[Sp + 8];
          P64[Sp + 8] = _sk2E::P64;
          call a5_rjVe_info(R2) returns to ckLJ, args: 8, res: 8, upd: 8;
      ckLJ:
          Hp = Hp + 24;
          if (Hp > HpLim) goto ckLQ; else goto ckLP;
      ckLQ:
          HpAlloc = 24;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to ckLJ, args: 8, res: 8, upd: 8;
      ckLP:
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = P64[Sp + 8];
          P64[Hp] = R1;
          R1 = Hp - 14;
          Sp = Sp + 16;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
      ckLs:
          R1 = GHC.Types.[]_closure+1;
          Sp = Sp + 8;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:54.076924 UTC

a5_rjVe_entry() //  [R2]
        { info_tbl: [(ckLo,
                      label: block_ckLo_info
                      rep:StackRep []),
                     (ckLv,
                      label: a5_rjVe_info
                      rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} }),
                     (ckLE,
                      label: block_ckLE_info
                      rep:StackRep [False]),
                     (ckLJ,
                      label: block_ckLJ_info
                      rep:StackRep [False])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckLv:
          _sk2v::P64 = R2;
          if ((Sp + -16) < SpLim) goto ckLw; else goto ckLx;
      ckLx:
          if (HpLim == 0) goto ckLw; else goto ckLy;
      ckLw:
          R2 = _sk2v::P64;
          R1 = a5_rjVe_closure;
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
      ckLy:
          I64[Sp - 8] = ckLo;
          R1 = _sk2v::P64;
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto ckLo; else goto ckLp;
      ckLp:
          call (I64[R1])(R1) returns to ckLo, args: 8, res: 8, upd: 8;
      ckLo:
          if (R1 & 7 != 1) goto ckLt; else goto ckLs;
      ckLt:
          I64[Sp - 8] = ckLE;
          _sk2z::P64 = P64[R1 + 14];
          R1 = P64[R1 + 6];
          P64[Sp] = _sk2z::P64;
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto ckLE; else goto ckLF;
      ckLF:
          call (I64[R1])(R1) returns to ckLE, args: 8, res: 8, upd: 8;
      ckLE:
          _sk2E::P64 = P64[P64[R1 + 7] + 8];
          I64[Sp] = ckLJ;
          R2 = P64[Sp + 8];
          P64[Sp + 8] = _sk2E::P64;
          call a5_rjVe_info(R2) returns to ckLJ, args: 8, res: 8, upd: 8;
      ckLJ:
          Hp = Hp + 24;
          if (Hp > HpLim) goto ckLQ; else goto ckLP;
      ckLQ:
          HpAlloc = 24;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to ckLJ, args: 8, res: 8, upd: 8;
      ckLP:
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = P64[Sp + 8];
          P64[Hp] = R1;
          R1 = Hp - 14;
          Sp = Sp + 16;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
      ckLs:
          R1 = GHC.Types.[]_closure+1;
          Sp = Sp + 8;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:54.08014 UTC

[section "data" {
     a5_rjVe_closure:
         const a5_rjVe_info;
 },
 a5_rjVe_entry() //  [R2]
         { info_tbl: [(ckLo,
                       label: block_ckLo_info
                       rep:StackRep []),
                      (ckLv,
                       label: a5_rjVe_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} }),
                      (ckLE,
                       label: block_ckLE_info
                       rep:StackRep [False]),
                      (ckLJ,
                       label: block_ckLJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckLv:
           _sk2v::P64 = R2;
           if ((Sp + -16) < SpLim) goto ckLw; else goto ckLx;
       ckLx:
           if (HpLim == 0) goto ckLw; else goto ckLy;
       ckLw:
           R2 = _sk2v::P64;
           R1 = a5_rjVe_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckLy:
           I64[Sp - 8] = ckLo;
           R1 = _sk2v::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ckLo; else goto ckLp;
       ckLp:
           call (I64[R1])(R1) returns to ckLo, args: 8, res: 8, upd: 8;
       ckLo:
           if (R1 & 7 != 1) goto ckLt; else goto ckLs;
       ckLt:
           I64[Sp - 8] = ckLE;
           _sk2z::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sk2z::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ckLE; else goto ckLF;
       ckLF:
           call (I64[R1])(R1) returns to ckLE, args: 8, res: 8, upd: 8;
       ckLE:
           _sk2E::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = ckLJ;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = _sk2E::P64;
           call a5_rjVe_info(R2) returns to ckLJ, args: 8, res: 8, upd: 8;
       ckLJ:
           Hp = Hp + 24;
           if (Hp > HpLim) goto ckLQ; else goto ckLP;
       ckLQ:
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to ckLJ, args: 8, res: 8, upd: 8;
       ckLP:
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
       ckLs:
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 8;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:54.083378 UTC

[section "data" {
     a5_rjVe_closure:
         const a5_rjVe_info;
 },
 a5_rjVe_entry() //  [R2]
         { info_tbl: [(ckLo,
                       label: block_ckLo_info
                       rep:StackRep []),
                      (ckLv,
                       label: a5_rjVe_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 5} }),
                      (ckLE,
                       label: block_ckLE_info
                       rep:StackRep [False]),
                      (ckLJ,
                       label: block_ckLJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckLv:
           _sk2v::P64 = R2;
           if ((Sp + -16) < SpLim) goto ckLw; else goto ckLx;
       ckLx:
           if (HpLim == 0) goto ckLw; else goto ckLy;
       ckLw:
           R2 = _sk2v::P64;
           R1 = a5_rjVe_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckLy:
           I64[Sp - 8] = ckLo;
           R1 = _sk2v::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ckLo; else goto ckLp;
       ckLp:
           call (I64[R1])(R1) returns to ckLo, args: 8, res: 8, upd: 8;
       ckLo:
           if (R1 & 7 != 1) goto ckLt; else goto ckLs;
       ckLt:
           I64[Sp - 8] = ckLE;
           _sk2z::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sk2z::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ckLE; else goto ckLF;
       ckLF:
           call (I64[R1])(R1) returns to ckLE, args: 8, res: 8, upd: 8;
       ckLE:
           _sk2E::P64 = P64[P64[R1 + 7] + 8];
           I64[Sp] = ckLJ;
           R2 = P64[Sp + 8];
           P64[Sp + 8] = _sk2E::P64;
           call a5_rjVe_info(R2) returns to ckLJ, args: 8, res: 8, upd: 8;
       ckLJ:
           Hp = Hp + 24;
           if (Hp > HpLim) goto ckLQ; else goto ckLP;
       ckLQ:
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to ckLJ, args: 8, res: 8, upd: 8;
       ckLP:
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = R1;
           R1 = Hp - 14;
           Sp = Sp + 16;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
       ckLs:
           R1 = GHC.Types.[]_closure+1;
           Sp = Sp + 8;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:54.092274 UTC

[section "data" {
     lvl13_rjVf_closure:
         const lvl13_rjVf_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ckM6_str:
         I8[] [98,101,110,99,104,100,97,116,97,58]
 },
 lvl13_rjVf_entry() //  [R1]
         { info_tbl: [(ckM7,
                       label: lvl13_rjVf_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckM7:
           _rjVf::P64 = R1;
           goto ckM1;
       ckM1:
           if ((old + 0) - <highSp> < SpLim) goto ckM8; else goto ckM9;
       ckM9:
           if (HpLim == 0) goto ckM8; else goto ckMa;
       ckM8:
           R1 = _rjVf::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckMa:
           (_ckM3::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjVf::P64);
           if (_ckM3::I64 == 0) goto ckM5; else goto ckM4;
       ckM5:
           call (I64[_rjVf::P64])() args: 8, res: 0, upd: 8;
       ckM4:
           I64[(old + 24)] = stg_bh_upd_frame_info;
           I64[(old + 16)] = _ckM3::I64;
           R2 = ckM6_str;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:54.094461 UTC

{offset
  ckM7:
      _rjVf::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckM8; else goto ckM9;
  ckM9:
      if (HpLim == 0) goto ckM8; else goto ckMa;
  ckM8:
      R1 = _rjVf::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckMa:
      (_ckM3::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjVf::P64);
      if (_ckM3::I64 == 0) goto ckM5; else goto ckM4;
  ckM5:
      call (I64[_rjVf::P64])() args: 8, res: 0, upd: 8;
  ckM4:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckM3::I64;
      R2 = ckM6_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:54.095574 UTC

{offset
  ckM7:
      _rjVf::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckM8; else goto ckM9;
  ckM9:
      if (HpLim == 0) goto ckM8; else goto ckMa;
  ckM8:
      R1 = _rjVf::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckMa:
      (_ckM3::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjVf::P64);
      if (_ckM3::I64 == 0) goto ckM5; else goto ckM4;
  ckM5:
      call (I64[_rjVf::P64])() args: 8, res: 0, upd: 8;
  ckM4:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckM3::I64;
      R2 = ckM6_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:54.096702 UTC

{offset
  ckM7:
      _rjVf::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckM8; else goto ckM9;
  ckM9:
      if (HpLim == 0) goto ckM8; else goto ckMa;
  ckM8:
      R1 = _rjVf::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckMa:
      (_ckM3::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjVf::P64);
      if (_ckM3::I64 == 0) goto ckM5; else goto ckM4;
  ckM5:
      call (I64[_rjVf::P64])() args: 8, res: 0, upd: 8;
  ckM4:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckM3::I64;
      R2 = ckM6_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:54.097883 UTC

{offset
  ckM7:
      _rjVf::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto ckM8; else goto ckM9;
  ckM9:
      if (HpLim == 0) goto ckM8; else goto ckMa;
  ckM8:
      R1 = _rjVf::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckMa:
      (_ckM3::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjVf::P64);
      if (_ckM3::I64 == 0) goto ckM5; else goto ckM4;
  ckM5:
      call (I64[_rjVf::P64])() args: 8, res: 0, upd: 8;
  ckM4:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _ckM3::I64;
      R2 = ckM6_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:54.099014 UTC

{offset
  ckM7:
      _rjVf::P64 = R1;
      if ((Sp + -16) < SpLim) goto ckM8; else goto ckM9;
  ckM9:
      if (HpLim == 0) goto ckM8; else goto ckMa;
  ckM8:
      R1 = _rjVf::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckMa:
      (_ckM3::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjVf::P64);
      if (_ckM3::I64 == 0) goto ckM5; else goto ckM4;
  ckM5:
      call (I64[_rjVf::P64])() args: 8, res: 0, upd: 8;
  ckM4:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _ckM3::I64;
      R2 = ckM6_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:54.100387 UTC

[(ckM4, {}), (ckM5, {}), (ckM7, {}), (ckM8, {}), (ckM9, {}),
 (ckMa, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:54.100774 UTC

lvl13_rjVf_entry() //  [R1]
        { info_tbl: [(ckM7,
                      label: lvl13_rjVf_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckM7:
          _rjVf::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckM8; else goto ckM9;
      ckM9:
          if (HpLim == 0) goto ckM8; else goto ckMa;
      ckM8:
          R1 = _rjVf::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckMa:
          (_ckM3::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjVf::P64);
          if (_ckM3::I64 == 0) goto ckM5; else goto ckM4;
      ckM5:
          call (I64[_rjVf::P64])() args: 8, res: 0, upd: 8;
      ckM4:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _ckM3::I64;
          R2 = ckM6_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:54.10216 UTC

lvl13_rjVf_entry() //  [R1]
        { info_tbl: [(ckM7,
                      label: lvl13_rjVf_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckM7:
          _rjVf::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckM8; else goto ckM9;
      ckM9:
          if (HpLim == 0) goto ckM8; else goto ckMa;
      ckM8:
          R1 = _rjVf::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckMa:
          (_ckM3::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjVf::P64);
          if (_ckM3::I64 == 0) goto ckM5; else goto ckM4;
      ckM5:
          call (I64[_rjVf::P64])() args: 8, res: 0, upd: 8;
      ckM4:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _ckM3::I64;
          R2 = ckM6_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:54.103538 UTC

[section "data" {
     lvl13_rjVf_closure:
         const lvl13_rjVf_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ckM6_str:
         I8[] [98,101,110,99,104,100,97,116,97,58]
 },
 lvl13_rjVf_entry() //  [R1]
         { info_tbl: [(ckM7,
                       label: lvl13_rjVf_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckM7:
           _rjVf::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckM8; else goto ckM9;
       ckM9:
           if (HpLim == 0) goto ckM8; else goto ckMa;
       ckM8:
           R1 = _rjVf::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckMa:
           (_ckM3::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjVf::P64);
           if (_ckM3::I64 == 0) goto ckM5; else goto ckM4;
       ckM5:
           call (I64[_rjVf::P64])() args: 8, res: 0, upd: 8;
       ckM4:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ckM3::I64;
           R2 = ckM6_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:54.105256 UTC

[section "data" {
     lvl13_rjVf_closure:
         const lvl13_rjVf_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ckM6_str:
         I8[] [98,101,110,99,104,100,97,116,97,58]
 },
 lvl13_rjVf_entry() //  [R1]
         { info_tbl: [(ckM7,
                       label: lvl13_rjVf_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckM7:
           _rjVf::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckM8; else goto ckM9;
       ckM9:
           if (HpLim == 0) goto ckM8; else goto ckMa;
       ckM8:
           R1 = _rjVf::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckMa:
           (_ckM3::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjVf::P64);
           if (_ckM3::I64 == 0) goto ckM5; else goto ckM4;
       ckM5:
           call (I64[_rjVf::P64])() args: 8, res: 0, upd: 8;
       ckM4:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ckM3::I64;
           R2 = ckM6_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:54.10989 UTC

[section "data" {
     lvl14_rjVg_closure:
         const GHC.Types.C#_static_info;
         const 32;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:54.11027 UTC

[section "data" {
     lvl14_rjVg_closure:
         const GHC.Types.C#_static_info;
         const 32;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:54.110582 UTC

[section "data" {
     lvl14_rjVg_closure:
         const GHC.Types.C#_static_info;
         const 32;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:54.111133 UTC

[section "data" {
     lvl15_rjVh_closure:
         const lvl15_rjVh_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ckMp_str:
         I8[] [114,117,110,45,116,105,109,101]
 },
 lvl15_rjVh_entry() //  [R1]
         { info_tbl: [(ckMq,
                       label: lvl15_rjVh_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckMq:
           _rjVh::P64 = R1;
           goto ckMk;
       ckMk:
           if ((old + 0) - <highSp> < SpLim) goto ckMr; else goto ckMs;
       ckMs:
           if (HpLim == 0) goto ckMr; else goto ckMt;
       ckMr:
           R1 = _rjVh::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckMt:
           (_ckMm::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjVh::P64);
           if (_ckMm::I64 == 0) goto ckMo; else goto ckMn;
       ckMo:
           call (I64[_rjVh::P64])() args: 8, res: 0, upd: 8;
       ckMn:
           I64[(old + 24)] = stg_bh_upd_frame_info;
           I64[(old + 16)] = _ckMm::I64;
           R2 = ckMp_str;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:54.113226 UTC

{offset
  ckMq:
      _rjVh::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckMr; else goto ckMs;
  ckMs:
      if (HpLim == 0) goto ckMr; else goto ckMt;
  ckMr:
      R1 = _rjVh::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckMt:
      (_ckMm::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjVh::P64);
      if (_ckMm::I64 == 0) goto ckMo; else goto ckMn;
  ckMo:
      call (I64[_rjVh::P64])() args: 8, res: 0, upd: 8;
  ckMn:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckMm::I64;
      R2 = ckMp_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:54.114313 UTC

{offset
  ckMq:
      _rjVh::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckMr; else goto ckMs;
  ckMs:
      if (HpLim == 0) goto ckMr; else goto ckMt;
  ckMr:
      R1 = _rjVh::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckMt:
      (_ckMm::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjVh::P64);
      if (_ckMm::I64 == 0) goto ckMo; else goto ckMn;
  ckMo:
      call (I64[_rjVh::P64])() args: 8, res: 0, upd: 8;
  ckMn:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckMm::I64;
      R2 = ckMp_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:54.115444 UTC

{offset
  ckMq:
      _rjVh::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckMr; else goto ckMs;
  ckMs:
      if (HpLim == 0) goto ckMr; else goto ckMt;
  ckMr:
      R1 = _rjVh::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckMt:
      (_ckMm::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjVh::P64);
      if (_ckMm::I64 == 0) goto ckMo; else goto ckMn;
  ckMo:
      call (I64[_rjVh::P64])() args: 8, res: 0, upd: 8;
  ckMn:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckMm::I64;
      R2 = ckMp_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:54.11662 UTC

{offset
  ckMq:
      _rjVh::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto ckMr; else goto ckMs;
  ckMs:
      if (HpLim == 0) goto ckMr; else goto ckMt;
  ckMr:
      R1 = _rjVh::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckMt:
      (_ckMm::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjVh::P64);
      if (_ckMm::I64 == 0) goto ckMo; else goto ckMn;
  ckMo:
      call (I64[_rjVh::P64])() args: 8, res: 0, upd: 8;
  ckMn:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _ckMm::I64;
      R2 = ckMp_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:54.117794 UTC

{offset
  ckMq:
      _rjVh::P64 = R1;
      if ((Sp + -16) < SpLim) goto ckMr; else goto ckMs;
  ckMs:
      if (HpLim == 0) goto ckMr; else goto ckMt;
  ckMr:
      R1 = _rjVh::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckMt:
      (_ckMm::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjVh::P64);
      if (_ckMm::I64 == 0) goto ckMo; else goto ckMn;
  ckMo:
      call (I64[_rjVh::P64])() args: 8, res: 0, upd: 8;
  ckMn:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _ckMm::I64;
      R2 = ckMp_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:54.119096 UTC

[(ckMn, {}), (ckMo, {}), (ckMq, {}), (ckMr, {}), (ckMs, {}),
 (ckMt, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:54.119482 UTC

lvl15_rjVh_entry() //  [R1]
        { info_tbl: [(ckMq,
                      label: lvl15_rjVh_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckMq:
          _rjVh::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckMr; else goto ckMs;
      ckMs:
          if (HpLim == 0) goto ckMr; else goto ckMt;
      ckMr:
          R1 = _rjVh::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckMt:
          (_ckMm::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjVh::P64);
          if (_ckMm::I64 == 0) goto ckMo; else goto ckMn;
      ckMo:
          call (I64[_rjVh::P64])() args: 8, res: 0, upd: 8;
      ckMn:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _ckMm::I64;
          R2 = ckMp_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:54.121383 UTC

lvl15_rjVh_entry() //  [R1]
        { info_tbl: [(ckMq,
                      label: lvl15_rjVh_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckMq:
          _rjVh::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckMr; else goto ckMs;
      ckMs:
          if (HpLim == 0) goto ckMr; else goto ckMt;
      ckMr:
          R1 = _rjVh::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckMt:
          (_ckMm::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjVh::P64);
          if (_ckMm::I64 == 0) goto ckMo; else goto ckMn;
      ckMo:
          call (I64[_rjVh::P64])() args: 8, res: 0, upd: 8;
      ckMn:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _ckMm::I64;
          R2 = ckMp_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:54.122797 UTC

[section "data" {
     lvl15_rjVh_closure:
         const lvl15_rjVh_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ckMp_str:
         I8[] [114,117,110,45,116,105,109,101]
 },
 lvl15_rjVh_entry() //  [R1]
         { info_tbl: [(ckMq,
                       label: lvl15_rjVh_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckMq:
           _rjVh::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckMr; else goto ckMs;
       ckMs:
           if (HpLim == 0) goto ckMr; else goto ckMt;
       ckMr:
           R1 = _rjVh::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckMt:
           (_ckMm::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjVh::P64);
           if (_ckMm::I64 == 0) goto ckMo; else goto ckMn;
       ckMo:
           call (I64[_rjVh::P64])() args: 8, res: 0, upd: 8;
       ckMn:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ckMm::I64;
           R2 = ckMp_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:54.124523 UTC

[section "data" {
     lvl15_rjVh_closure:
         const lvl15_rjVh_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ckMp_str:
         I8[] [114,117,110,45,116,105,109,101]
 },
 lvl15_rjVh_entry() //  [R1]
         { info_tbl: [(ckMq,
                       label: lvl15_rjVh_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckMq:
           _rjVh::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckMr; else goto ckMs;
       ckMs:
           if (HpLim == 0) goto ckMr; else goto ckMt;
       ckMr:
           R1 = _rjVh::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckMt:
           (_ckMm::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjVh::P64);
           if (_ckMm::I64 == 0) goto ckMo; else goto ckMn;
       ckMo:
           call (I64[_rjVh::P64])() args: 8, res: 0, upd: 8;
       ckMn:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ckMm::I64;
           R2 = ckMp_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:54.129115 UTC

[section "data" {
     lvl16_rjVi_closure:
         const lvl16_rjVi_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ckMG_str:
         I8[] [110,111,45,107,105,108,108,45,116,105,109,101]
 },
 lvl16_rjVi_entry() //  [R1]
         { info_tbl: [(ckMH,
                       label: lvl16_rjVi_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckMH:
           _rjVi::P64 = R1;
           goto ckMB;
       ckMB:
           if ((old + 0) - <highSp> < SpLim) goto ckMI; else goto ckMJ;
       ckMJ:
           if (HpLim == 0) goto ckMI; else goto ckMK;
       ckMI:
           R1 = _rjVi::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckMK:
           (_ckMD::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjVi::P64);
           if (_ckMD::I64 == 0) goto ckMF; else goto ckME;
       ckMF:
           call (I64[_rjVi::P64])() args: 8, res: 0, upd: 8;
       ckME:
           I64[(old + 24)] = stg_bh_upd_frame_info;
           I64[(old + 16)] = _ckMD::I64;
           R2 = ckMG_str;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:54.131234 UTC

{offset
  ckMH:
      _rjVi::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckMI; else goto ckMJ;
  ckMJ:
      if (HpLim == 0) goto ckMI; else goto ckMK;
  ckMI:
      R1 = _rjVi::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckMK:
      (_ckMD::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjVi::P64);
      if (_ckMD::I64 == 0) goto ckMF; else goto ckME;
  ckMF:
      call (I64[_rjVi::P64])() args: 8, res: 0, upd: 8;
  ckME:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckMD::I64;
      R2 = ckMG_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:54.132338 UTC

{offset
  ckMH:
      _rjVi::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckMI; else goto ckMJ;
  ckMJ:
      if (HpLim == 0) goto ckMI; else goto ckMK;
  ckMI:
      R1 = _rjVi::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckMK:
      (_ckMD::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjVi::P64);
      if (_ckMD::I64 == 0) goto ckMF; else goto ckME;
  ckMF:
      call (I64[_rjVi::P64])() args: 8, res: 0, upd: 8;
  ckME:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckMD::I64;
      R2 = ckMG_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:54.133456 UTC

{offset
  ckMH:
      _rjVi::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckMI; else goto ckMJ;
  ckMJ:
      if (HpLim == 0) goto ckMI; else goto ckMK;
  ckMI:
      R1 = _rjVi::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckMK:
      (_ckMD::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjVi::P64);
      if (_ckMD::I64 == 0) goto ckMF; else goto ckME;
  ckMF:
      call (I64[_rjVi::P64])() args: 8, res: 0, upd: 8;
  ckME:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckMD::I64;
      R2 = ckMG_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:54.1346 UTC

{offset
  ckMH:
      _rjVi::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto ckMI; else goto ckMJ;
  ckMJ:
      if (HpLim == 0) goto ckMI; else goto ckMK;
  ckMI:
      R1 = _rjVi::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckMK:
      (_ckMD::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjVi::P64);
      if (_ckMD::I64 == 0) goto ckMF; else goto ckME;
  ckMF:
      call (I64[_rjVi::P64])() args: 8, res: 0, upd: 8;
  ckME:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _ckMD::I64;
      R2 = ckMG_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:54.135754 UTC

{offset
  ckMH:
      _rjVi::P64 = R1;
      if ((Sp + -16) < SpLim) goto ckMI; else goto ckMJ;
  ckMJ:
      if (HpLim == 0) goto ckMI; else goto ckMK;
  ckMI:
      R1 = _rjVi::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckMK:
      (_ckMD::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjVi::P64);
      if (_ckMD::I64 == 0) goto ckMF; else goto ckME;
  ckMF:
      call (I64[_rjVi::P64])() args: 8, res: 0, upd: 8;
  ckME:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _ckMD::I64;
      R2 = ckMG_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:54.137041 UTC

[(ckME, {}), (ckMF, {}), (ckMH, {}), (ckMI, {}), (ckMJ, {}),
 (ckMK, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:54.137424 UTC

lvl16_rjVi_entry() //  [R1]
        { info_tbl: [(ckMH,
                      label: lvl16_rjVi_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckMH:
          _rjVi::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckMI; else goto ckMJ;
      ckMJ:
          if (HpLim == 0) goto ckMI; else goto ckMK;
      ckMI:
          R1 = _rjVi::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckMK:
          (_ckMD::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjVi::P64);
          if (_ckMD::I64 == 0) goto ckMF; else goto ckME;
      ckMF:
          call (I64[_rjVi::P64])() args: 8, res: 0, upd: 8;
      ckME:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _ckMD::I64;
          R2 = ckMG_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:54.138791 UTC

lvl16_rjVi_entry() //  [R1]
        { info_tbl: [(ckMH,
                      label: lvl16_rjVi_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckMH:
          _rjVi::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckMI; else goto ckMJ;
      ckMJ:
          if (HpLim == 0) goto ckMI; else goto ckMK;
      ckMI:
          R1 = _rjVi::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckMK:
          (_ckMD::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjVi::P64);
          if (_ckMD::I64 == 0) goto ckMF; else goto ckME;
      ckMF:
          call (I64[_rjVi::P64])() args: 8, res: 0, upd: 8;
      ckME:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _ckMD::I64;
          R2 = ckMG_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:54.140255 UTC

[section "data" {
     lvl16_rjVi_closure:
         const lvl16_rjVi_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ckMG_str:
         I8[] [110,111,45,107,105,108,108,45,116,105,109,101]
 },
 lvl16_rjVi_entry() //  [R1]
         { info_tbl: [(ckMH,
                       label: lvl16_rjVi_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckMH:
           _rjVi::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckMI; else goto ckMJ;
       ckMJ:
           if (HpLim == 0) goto ckMI; else goto ckMK;
       ckMI:
           R1 = _rjVi::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckMK:
           (_ckMD::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjVi::P64);
           if (_ckMD::I64 == 0) goto ckMF; else goto ckME;
       ckMF:
           call (I64[_rjVi::P64])() args: 8, res: 0, upd: 8;
       ckME:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ckMD::I64;
           R2 = ckMG_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:54.141936 UTC

[section "data" {
     lvl16_rjVi_closure:
         const lvl16_rjVi_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ckMG_str:
         I8[] [110,111,45,107,105,108,108,45,116,105,109,101]
 },
 lvl16_rjVi_entry() //  [R1]
         { info_tbl: [(ckMH,
                       label: lvl16_rjVi_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckMH:
           _rjVi::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckMI; else goto ckMJ;
       ckMJ:
           if (HpLim == 0) goto ckMI; else goto ckMK;
       ckMI:
           R1 = _rjVi::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckMK:
           (_ckMD::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjVi::P64);
           if (_ckMD::I64 == 0) goto ckMF; else goto ckME;
       ckMF:
           call (I64[_rjVi::P64])() args: 8, res: 0, upd: 8;
       ckME:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ckMD::I64;
           R2 = ckMG_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:54.146505 UTC

[section "data" {
     lvl17_rjVj_closure:
         const lvl17_rjVj_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ckMX_str:
         I8[] [116,114,97,110,115,97,99,116,105,111,110,115]
 },
 lvl17_rjVj_entry() //  [R1]
         { info_tbl: [(ckMY,
                       label: lvl17_rjVj_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckMY:
           _rjVj::P64 = R1;
           goto ckMS;
       ckMS:
           if ((old + 0) - <highSp> < SpLim) goto ckMZ; else goto ckN0;
       ckN0:
           if (HpLim == 0) goto ckMZ; else goto ckN1;
       ckMZ:
           R1 = _rjVj::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckN1:
           (_ckMU::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjVj::P64);
           if (_ckMU::I64 == 0) goto ckMW; else goto ckMV;
       ckMW:
           call (I64[_rjVj::P64])() args: 8, res: 0, upd: 8;
       ckMV:
           I64[(old + 24)] = stg_bh_upd_frame_info;
           I64[(old + 16)] = _ckMU::I64;
           R2 = ckMX_str;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:54.148617 UTC

{offset
  ckMY:
      _rjVj::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckMZ; else goto ckN0;
  ckN0:
      if (HpLim == 0) goto ckMZ; else goto ckN1;
  ckMZ:
      R1 = _rjVj::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckN1:
      (_ckMU::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjVj::P64);
      if (_ckMU::I64 == 0) goto ckMW; else goto ckMV;
  ckMW:
      call (I64[_rjVj::P64])() args: 8, res: 0, upd: 8;
  ckMV:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckMU::I64;
      R2 = ckMX_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:54.149738 UTC

{offset
  ckMY:
      _rjVj::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckMZ; else goto ckN0;
  ckN0:
      if (HpLim == 0) goto ckMZ; else goto ckN1;
  ckMZ:
      R1 = _rjVj::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckN1:
      (_ckMU::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjVj::P64);
      if (_ckMU::I64 == 0) goto ckMW; else goto ckMV;
  ckMW:
      call (I64[_rjVj::P64])() args: 8, res: 0, upd: 8;
  ckMV:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckMU::I64;
      R2 = ckMX_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:54.150848 UTC

{offset
  ckMY:
      _rjVj::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckMZ; else goto ckN0;
  ckN0:
      if (HpLim == 0) goto ckMZ; else goto ckN1;
  ckMZ:
      R1 = _rjVj::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckN1:
      (_ckMU::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjVj::P64);
      if (_ckMU::I64 == 0) goto ckMW; else goto ckMV;
  ckMW:
      call (I64[_rjVj::P64])() args: 8, res: 0, upd: 8;
  ckMV:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckMU::I64;
      R2 = ckMX_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:54.152006 UTC

{offset
  ckMY:
      _rjVj::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto ckMZ; else goto ckN0;
  ckN0:
      if (HpLim == 0) goto ckMZ; else goto ckN1;
  ckMZ:
      R1 = _rjVj::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckN1:
      (_ckMU::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjVj::P64);
      if (_ckMU::I64 == 0) goto ckMW; else goto ckMV;
  ckMW:
      call (I64[_rjVj::P64])() args: 8, res: 0, upd: 8;
  ckMV:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _ckMU::I64;
      R2 = ckMX_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:54.15313 UTC

{offset
  ckMY:
      _rjVj::P64 = R1;
      if ((Sp + -16) < SpLim) goto ckMZ; else goto ckN0;
  ckN0:
      if (HpLim == 0) goto ckMZ; else goto ckN1;
  ckMZ:
      R1 = _rjVj::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckN1:
      (_ckMU::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjVj::P64);
      if (_ckMU::I64 == 0) goto ckMW; else goto ckMV;
  ckMW:
      call (I64[_rjVj::P64])() args: 8, res: 0, upd: 8;
  ckMV:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _ckMU::I64;
      R2 = ckMX_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:54.154407 UTC

[(ckMV, {}), (ckMW, {}), (ckMY, {}), (ckMZ, {}), (ckN0, {}),
 (ckN1, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:54.155312 UTC

lvl17_rjVj_entry() //  [R1]
        { info_tbl: [(ckMY,
                      label: lvl17_rjVj_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckMY:
          _rjVj::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckMZ; else goto ckN0;
      ckN0:
          if (HpLim == 0) goto ckMZ; else goto ckN1;
      ckMZ:
          R1 = _rjVj::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckN1:
          (_ckMU::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjVj::P64);
          if (_ckMU::I64 == 0) goto ckMW; else goto ckMV;
      ckMW:
          call (I64[_rjVj::P64])() args: 8, res: 0, upd: 8;
      ckMV:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _ckMU::I64;
          R2 = ckMX_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:54.156668 UTC

lvl17_rjVj_entry() //  [R1]
        { info_tbl: [(ckMY,
                      label: lvl17_rjVj_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckMY:
          _rjVj::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckMZ; else goto ckN0;
      ckN0:
          if (HpLim == 0) goto ckMZ; else goto ckN1;
      ckMZ:
          R1 = _rjVj::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckN1:
          (_ckMU::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjVj::P64);
          if (_ckMU::I64 == 0) goto ckMW; else goto ckMV;
      ckMW:
          call (I64[_rjVj::P64])() args: 8, res: 0, upd: 8;
      ckMV:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _ckMU::I64;
          R2 = ckMX_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:54.158065 UTC

[section "data" {
     lvl17_rjVj_closure:
         const lvl17_rjVj_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ckMX_str:
         I8[] [116,114,97,110,115,97,99,116,105,111,110,115]
 },
 lvl17_rjVj_entry() //  [R1]
         { info_tbl: [(ckMY,
                       label: lvl17_rjVj_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckMY:
           _rjVj::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckMZ; else goto ckN0;
       ckN0:
           if (HpLim == 0) goto ckMZ; else goto ckN1;
       ckMZ:
           R1 = _rjVj::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckN1:
           (_ckMU::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjVj::P64);
           if (_ckMU::I64 == 0) goto ckMW; else goto ckMV;
       ckMW:
           call (I64[_rjVj::P64])() args: 8, res: 0, upd: 8;
       ckMV:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ckMU::I64;
           R2 = ckMX_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:54.15985 UTC

[section "data" {
     lvl17_rjVj_closure:
         const lvl17_rjVj_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ckMX_str:
         I8[] [116,114,97,110,115,97,99,116,105,111,110,115]
 },
 lvl17_rjVj_entry() //  [R1]
         { info_tbl: [(ckMY,
                       label: lvl17_rjVj_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckMY:
           _rjVj::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckMZ; else goto ckN0;
       ckN0:
           if (HpLim == 0) goto ckMZ; else goto ckN1;
       ckMZ:
           R1 = _rjVj::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckN1:
           (_ckMU::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjVj::P64);
           if (_ckMU::I64 == 0) goto ckMW; else goto ckMV;
       ckMW:
           call (I64[_rjVj::P64])() args: 8, res: 0, upd: 8;
       ckMV:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ckMU::I64;
           R2 = ckMX_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:54.164555 UTC

[section "data" {
     $wgo2_rjVk_closure:
         const $wgo2_rjVk_info;
 },
 $wgo2_rjVk_entry() //  [R3, R2]
         { info_tbl: [(ckNv,
                       label: $wgo2_rjVk_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckNv:
           _sk2K::I64 = R3;
           _sk2J::P64 = R2;
           goto ckNm;
       ckNm:
           if ((old + 0) - <highSp> < SpLim) goto ckNw; else goto ckNx;
       ckNx:
           goto ckNl;
       ckNl:
           if (HpLim == 0) goto ckNw; else goto ckNy;
       ckNw:
           R3 = _sk2K::I64;
           R2 = _sk2J::P64;
           R1 = $wgo2_rjVk_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ckNy:
           I64[(young<ckNo> + 8)] = ckNo;
           R1 = _sk2J::P64;
           if (R1 & 7 != 0) goto ckNo; else goto ckNp;
       ckNp:
           call (I64[R1])(R1) returns to ckNo, args: 8, res: 8, upd: 8;
       ckNo:
           _sk2L::P64 = R1;
           _ckNu::P64 = _sk2L::P64 & 7;
           switch [1 .. 2] _ckNu::P64 {
               case 1 : goto ckNs;
               case 2 : goto ckNt;
           }
       ckNt:
           _sk2M::P64 = P64[_sk2L::P64 + 6];
           _sk2N::P64 = P64[_sk2L::P64 + 14];
           I64[(young<ckNE> + 8)] = ckNE;
           R1 = _sk2M::P64;
           if (R1 & 7 != 0) goto ckNE; else goto ckNG;
       ckNG:
           call (I64[R1])(R1) returns to ckNE, args: 8, res: 8, upd: 8;
       ckNE:
           _sk2O::P64 = R1;
           _sk2P::I64 = I64[_sk2O::P64 + 7];
           _ckNL::I64 = _sk2K::I64 + _sk2P::I64;
           _sk2Q::I64 = _ckNL::I64;
           _sk2K::I64 = _sk2Q::I64;
           _sk2J::P64 = _sk2N::P64;
           goto ckNl;
       ckNs:
           R1 = _sk2K::I64;
           call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:54.168231 UTC

{offset
  ckNv:
      _sk2K::I64 = R3;
      _sk2J::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckNw; else goto ckNl;
  ckNl:
      if (HpLim == 0) goto ckNw; else goto ckNy;
  ckNw:
      R3 = _sk2K::I64;
      R2 = _sk2J::P64;
      R1 = $wgo2_rjVk_closure;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  ckNy:
      I64[(young<ckNo> + 8)] = ckNo;
      R1 = _sk2J::P64;
      if (R1 & 7 != 0) goto ckNo; else goto ckNp;
  ckNp:
      call (I64[R1])(R1) returns to ckNo, args: 8, res: 8, upd: 8;
  ckNo:
      _sk2L::P64 = R1;
      _ckNu::P64 = _sk2L::P64 & 7;
      switch [1 .. 2] _ckNu::P64 {
          case 1 : goto ckNs;
          case 2 : goto ckNt;
      }
  ckNt:
      _sk2M::P64 = P64[_sk2L::P64 + 6];
      _sk2N::P64 = P64[_sk2L::P64 + 14];
      I64[(young<ckNE> + 8)] = ckNE;
      R1 = _sk2M::P64;
      if (R1 & 7 != 0) goto ckNE; else goto ckNG;
  ckNG:
      call (I64[R1])(R1) returns to ckNE, args: 8, res: 8, upd: 8;
  ckNE:
      _sk2O::P64 = R1;
      _sk2P::I64 = I64[_sk2O::P64 + 7];
      _ckNL::I64 = _sk2K::I64 + _sk2P::I64;
      _sk2Q::I64 = _ckNL::I64;
      _sk2K::I64 = _sk2Q::I64;
      _sk2J::P64 = _sk2N::P64;
      goto ckNl;
  ckNs:
      R1 = _sk2K::I64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:54.170329 UTC

{offset
  ckNv:
      _sk2K::I64 = R3;
      _sk2J::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckNw; else goto ckNl;
  ckNl:
      if (HpLim == 0) goto ckNw; else goto ckNy;
  ckNw:
      R3 = _sk2K::I64;
      R2 = _sk2J::P64;
      R1 = $wgo2_rjVk_closure;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  ckNy:
      I64[(young<ckNo> + 8)] = ckNo;
      R1 = _sk2J::P64;
      if (R1 & 7 != 0) goto ckNo; else goto ckNp;
  ckNp:
      call (I64[R1])(R1) returns to ckNo, args: 8, res: 8, upd: 8;
  ckNo:
      _sk2L::P64 = R1;
      _ckNu::P64 = _sk2L::P64 & 7;
      switch [1 .. 2] _ckNu::P64 {
          case 1 : goto ckNs;
          case 2 : goto ckNt;
      }
  ckNt:
      _sk2M::P64 = P64[_sk2L::P64 + 6];
      _sk2N::P64 = P64[_sk2L::P64 + 14];
      I64[(young<ckNE> + 8)] = ckNE;
      R1 = _sk2M::P64;
      if (R1 & 7 != 0) goto ckNE; else goto ckNG;
  ckNG:
      call (I64[R1])(R1) returns to ckNE, args: 8, res: 8, upd: 8;
  ckNE:
      _sk2O::P64 = R1;
      _sk2P::I64 = I64[_sk2O::P64 + 7];
      _ckNL::I64 = _sk2K::I64 + _sk2P::I64;
      _sk2Q::I64 = _ckNL::I64;
      _sk2K::I64 = _sk2Q::I64;
      _sk2J::P64 = _sk2N::P64;
      goto ckNl;
  ckNs:
      R1 = _sk2K::I64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:54.172436 UTC

{offset
  ckNv:
      _sk2K::I64 = R3;
      _sk2J::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckNw; else goto ckNl;
  ckNl:
      if (HpLim == 0) goto ckNw; else goto ckNy;
  ckNw:
      R3 = _sk2K::I64;
      R2 = _sk2J::P64;
      R1 = $wgo2_rjVk_closure;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  ckNy:
      I64[(young<ckNo> + 8)] = ckNo;
      R1 = _sk2J::P64;
      if (R1 & 7 != 0) goto ckNo; else goto ckNp;
  ckNp:
      call (I64[R1])(R1) returns to ckNo, args: 8, res: 8, upd: 8;
  ckNo:
      _sk2L::P64 = R1;
      _ckNu::P64 = _sk2L::P64 & 7;
      if (_ckNu::P64 != 1) goto ckNt; else goto ckNs;
  ckNt:
      _sk2M::P64 = P64[_sk2L::P64 + 6];
      _sk2N::P64 = P64[_sk2L::P64 + 14];
      I64[(young<ckNE> + 8)] = ckNE;
      R1 = _sk2M::P64;
      if (R1 & 7 != 0) goto ckNE; else goto ckNG;
  ckNG:
      call (I64[R1])(R1) returns to ckNE, args: 8, res: 8, upd: 8;
  ckNE:
      _sk2O::P64 = R1;
      _sk2P::I64 = I64[_sk2O::P64 + 7];
      _ckNL::I64 = _sk2K::I64 + _sk2P::I64;
      _sk2Q::I64 = _ckNL::I64;
      _sk2K::I64 = _sk2Q::I64;
      _sk2J::P64 = _sk2N::P64;
      goto ckNl;
  ckNs:
      R1 = _sk2K::I64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:54.174753 UTC

{offset
  ckNv:
      _sk2K::I64 = R3;
      _sk2J::P64 = R2;
      if ((Sp + 8) - 32 < SpLim) goto ckNw; else goto ckNl;
  ckNl:
      if (HpLim == 0) goto ckNw; else goto ckNy;
  ckNw:
      R3 = _sk2K::I64;
      R2 = _sk2J::P64;
      R1 = $wgo2_rjVk_closure;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  ckNy:
      I64[Sp - 16] = ckNo;
      R1 = _sk2J::P64;
      I64[Sp - 8] = _sk2K::I64;
      Sp = Sp - 16;
      if (R1 & 7 != 0) goto ckNo; else goto ckNp;
  ckNp:
      call (I64[R1])(R1) returns to ckNo, args: 8, res: 8, upd: 8;
  ckNo:
      _sk2K::I64 = I64[Sp + 8];
      _sk2L::P64 = R1;
      _ckNu::P64 = _sk2L::P64 & 7;
      if (_ckNu::P64 != 1) goto ckNt; else goto ckNs;
  ckNt:
      _sk2M::P64 = P64[_sk2L::P64 + 6];
      _sk2N::P64 = P64[_sk2L::P64 + 14];
      I64[Sp - 8] = ckNE;
      R1 = _sk2M::P64;
      P64[Sp] = _sk2N::P64;
      Sp = Sp - 8;
      if (R1 & 7 != 0) goto ckNE; else goto ckNG;
  ckNG:
      call (I64[R1])(R1) returns to ckNE, args: 8, res: 8, upd: 8;
  ckNE:
      _sk2K::I64 = I64[Sp + 16];
      _sk2N::P64 = P64[Sp + 8];
      _sk2O::P64 = R1;
      _sk2P::I64 = I64[_sk2O::P64 + 7];
      _ckNL::I64 = _sk2K::I64 + _sk2P::I64;
      _sk2Q::I64 = _ckNL::I64;
      _sk2K::I64 = _sk2Q::I64;
      _sk2J::P64 = _sk2N::P64;
      goto ukNM;
  ukNM:
      Sp = Sp + 24;
      goto ckNl;
  ckNs:
      R1 = _sk2K::I64;
      Sp = Sp + 16;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:54.177214 UTC

{offset
  ckNv:
      _sk2K::I64 = R3;
      _sk2J::P64 = R2;
      if ((Sp + -24) < SpLim) goto ckNw; else goto ckNl;
  ckNl:
      if (HpLim == 0) goto ckNw; else goto ckNy;
  ckNw:
      R3 = _sk2K::I64;
      R2 = _sk2J::P64;
      R1 = $wgo2_rjVk_closure;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  ckNy:
      I64[Sp - 16] = ckNo;
      R1 = _sk2J::P64;
      I64[Sp - 8] = _sk2K::I64;
      Sp = Sp - 16;
      if (R1 & 7 != 0) goto ckNo; else goto ckNp;
  ckNp:
      call (I64[R1])(R1) returns to ckNo, args: 8, res: 8, upd: 8;
  ckNo:
      if (R1 & 7 != 1) goto ckNt; else goto ckNs;
  ckNt:
      I64[Sp - 8] = ckNE;
      _sk2N::P64 = P64[R1 + 14];
      R1 = P64[R1 + 6];
      P64[Sp] = _sk2N::P64;
      Sp = Sp - 8;
      if (R1 & 7 != 0) goto ckNE; else goto ckNG;
  ckNG:
      call (I64[R1])(R1) returns to ckNE, args: 8, res: 8, upd: 8;
  ckNE:
      goto ukNM;
  ukNM:
      _sk2K::I64 = I64[Sp + 16] + I64[R1 + 7];
      _sk2J::P64 = P64[Sp + 8];
      Sp = Sp + 24;
      goto ckNl;
  ckNs:
      R1 = I64[Sp + 8];
      Sp = Sp + 16;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:54.179621 UTC

[(ckNl, {}), (ckNo, {}), (ckNp, {}), (ckNs, {}), (ckNt, {}),
 (ckNv, {}), (ckNw, {}), (ckNy, {}), (ckNE, {}), (ckNG, {}),
 (ukNM, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:54.180142 UTC

$wgo2_rjVk_entry() //  [R3, R2]
        { info_tbl: [(ckNo,
                      label: block_ckNo_info
                      rep:StackRep [True]),
                     (ckNv,
                      label: $wgo2_rjVk_info
                      rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} }),
                     (ckNE,
                      label: block_ckNE_info
                      rep:StackRep [False, True])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckNv:
          _sk2K::I64 = R3;
          _sk2J::P64 = R2;
          if ((Sp + -24) < SpLim) goto ckNw; else goto ckNl;
      ckNl:
          if (HpLim == 0) goto ckNw; else goto ckNy;
      ckNw:
          R3 = _sk2K::I64;
          R2 = _sk2J::P64;
          R1 = $wgo2_rjVk_closure;
          call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
      ckNy:
          I64[Sp - 16] = ckNo;
          R1 = _sk2J::P64;
          I64[Sp - 8] = _sk2K::I64;
          Sp = Sp - 16;
          if (R1 & 7 != 0) goto ckNo; else goto ckNp;
      ckNp:
          call (I64[R1])(R1) returns to ckNo, args: 8, res: 8, upd: 8;
      ckNo:
          if (R1 & 7 != 1) goto ckNt; else goto ckNs;
      ckNt:
          I64[Sp - 8] = ckNE;
          _sk2N::P64 = P64[R1 + 14];
          R1 = P64[R1 + 6];
          P64[Sp] = _sk2N::P64;
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto ckNE; else goto ckNG;
      ckNG:
          call (I64[R1])(R1) returns to ckNE, args: 8, res: 8, upd: 8;
      ckNE:
          goto ukNM;
      ukNM:
          _sk2K::I64 = I64[Sp + 16] + I64[R1 + 7];
          _sk2J::P64 = P64[Sp + 8];
          Sp = Sp + 24;
          goto ckNl;
      ckNs:
          R1 = I64[Sp + 8];
          Sp = Sp + 16;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:54.182668 UTC

$wgo2_rjVk_entry() //  [R3, R2]
        { info_tbl: [(ckNo,
                      label: block_ckNo_info
                      rep:StackRep [True]),
                     (ckNv,
                      label: $wgo2_rjVk_info
                      rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} }),
                     (ckNE,
                      label: block_ckNE_info
                      rep:StackRep [False, True])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckNv:
          _sk2K::I64 = R3;
          _sk2J::P64 = R2;
          if ((Sp + -24) < SpLim) goto ckNw; else goto ckNl;
      ckNl:
          if (HpLim == 0) goto ckNw; else goto ckNy;
      ckNw:
          R3 = _sk2K::I64;
          R2 = _sk2J::P64;
          R1 = $wgo2_rjVk_closure;
          call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
      ckNy:
          I64[Sp - 16] = ckNo;
          R1 = _sk2J::P64;
          I64[Sp - 8] = _sk2K::I64;
          Sp = Sp - 16;
          if (R1 & 7 != 0) goto ckNo; else goto ckNp;
      ckNp:
          call (I64[R1])(R1) returns to ckNo, args: 8, res: 8, upd: 8;
      ckNo:
          if (R1 & 7 != 1) goto ckNt; else goto ckNs;
      ckNt:
          I64[Sp - 8] = ckNE;
          _sk2N::P64 = P64[R1 + 14];
          R1 = P64[R1 + 6];
          P64[Sp] = _sk2N::P64;
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto ckNE; else goto ckNG;
      ckNG:
          call (I64[R1])(R1) returns to ckNE, args: 8, res: 8, upd: 8;
      ckNE:
          _sk2K::I64 = I64[Sp + 16] + I64[R1 + 7];
          _sk2J::P64 = P64[Sp + 8];
          Sp = Sp + 24;
          goto ckNl;
      ckNs:
          R1 = I64[Sp + 8];
          Sp = Sp + 16;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:54.185177 UTC

[section "data" {
     $wgo2_rjVk_closure:
         const $wgo2_rjVk_info;
 },
 $wgo2_rjVk_entry() //  [R3, R2]
         { info_tbl: [(ckNo,
                       label: block_ckNo_info
                       rep:StackRep [True]),
                      (ckNv,
                       label: $wgo2_rjVk_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} }),
                      (ckNE,
                       label: block_ckNE_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckNv:
           _sk2K::I64 = R3;
           _sk2J::P64 = R2;
           if ((Sp + -24) < SpLim) goto ckNw; else goto ckNl;
       ckNl:
           if (HpLim == 0) goto ckNw; else goto ckNy;
       ckNw:
           R3 = _sk2K::I64;
           R2 = _sk2J::P64;
           R1 = $wgo2_rjVk_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ckNy:
           I64[Sp - 16] = ckNo;
           R1 = _sk2J::P64;
           I64[Sp - 8] = _sk2K::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ckNo; else goto ckNp;
       ckNp:
           call (I64[R1])(R1) returns to ckNo, args: 8, res: 8, upd: 8;
       ckNo:
           if (R1 & 7 != 1) goto ckNt; else goto ckNs;
       ckNt:
           I64[Sp - 8] = ckNE;
           _sk2N::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sk2N::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ckNE; else goto ckNG;
       ckNG:
           call (I64[R1])(R1) returns to ckNE, args: 8, res: 8, upd: 8;
       ckNE:
           _sk2K::I64 = I64[Sp + 16] + I64[R1 + 7];
           _sk2J::P64 = P64[Sp + 8];
           Sp = Sp + 24;
           goto ckNl;
       ckNs:
           R1 = I64[Sp + 8];
           Sp = Sp + 16;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:54.187869 UTC

[section "data" {
     $wgo2_rjVk_closure:
         const $wgo2_rjVk_info;
 },
 $wgo2_rjVk_entry() //  [R3, R2]
         { info_tbl: [(ckNo,
                       label: block_ckNo_info
                       rep:StackRep [True]),
                      (ckNv,
                       label: $wgo2_rjVk_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 14} }),
                      (ckNE,
                       label: block_ckNE_info
                       rep:StackRep [False, True])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckNv:
           _sk2K::I64 = R3;
           _sk2J::P64 = R2;
           if ((Sp + -24) < SpLim) goto ckNw; else goto ckNl;
       ckNl:
           if (HpLim == 0) goto ckNw; else goto ckNy;
       ckNw:
           R3 = _sk2K::I64;
           R2 = _sk2J::P64;
           R1 = $wgo2_rjVk_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ckNy:
           I64[Sp - 16] = ckNo;
           R1 = _sk2J::P64;
           I64[Sp - 8] = _sk2K::I64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ckNo; else goto ckNp;
       ckNp:
           call (I64[R1])(R1) returns to ckNo, args: 8, res: 8, upd: 8;
       ckNo:
           if (R1 & 7 != 1) goto ckNt; else goto ckNs;
       ckNt:
           I64[Sp - 8] = ckNE;
           _sk2N::P64 = P64[R1 + 14];
           R1 = P64[R1 + 6];
           P64[Sp] = _sk2N::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto ckNE; else goto ckNG;
       ckNG:
           call (I64[R1])(R1) returns to ckNE, args: 8, res: 8, upd: 8;
       ckNE:
           _sk2K::I64 = I64[Sp + 16] + I64[R1 + 7];
           _sk2J::P64 = P64[Sp + 8];
           Sp = Sp + 24;
           goto ckNl;
       ckNs:
           R1 = I64[Sp + 8];
           Sp = Sp + 16;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:54.1948 UTC

[section "data" {
     lvl18_rjVl_closure:
         const lvl18_rjVl_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ckO3_str:
         I8[] [112,114,111,103]
 },
 lvl18_rjVl_entry() //  [R1]
         { info_tbl: [(ckO4,
                       label: lvl18_rjVl_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckO4:
           _rjVl::P64 = R1;
           goto ckNY;
       ckNY:
           if ((old + 0) - <highSp> < SpLim) goto ckO5; else goto ckO6;
       ckO6:
           if (HpLim == 0) goto ckO5; else goto ckO7;
       ckO5:
           R1 = _rjVl::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckO7:
           (_ckO0::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjVl::P64);
           if (_ckO0::I64 == 0) goto ckO2; else goto ckO1;
       ckO2:
           call (I64[_rjVl::P64])() args: 8, res: 0, upd: 8;
       ckO1:
           I64[(old + 24)] = stg_bh_upd_frame_info;
           I64[(old + 16)] = _ckO0::I64;
           R2 = ckO3_str;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:54.196925 UTC

{offset
  ckO4:
      _rjVl::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckO5; else goto ckO6;
  ckO6:
      if (HpLim == 0) goto ckO5; else goto ckO7;
  ckO5:
      R1 = _rjVl::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckO7:
      (_ckO0::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjVl::P64);
      if (_ckO0::I64 == 0) goto ckO2; else goto ckO1;
  ckO2:
      call (I64[_rjVl::P64])() args: 8, res: 0, upd: 8;
  ckO1:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckO0::I64;
      R2 = ckO3_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:54.198063 UTC

{offset
  ckO4:
      _rjVl::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckO5; else goto ckO6;
  ckO6:
      if (HpLim == 0) goto ckO5; else goto ckO7;
  ckO5:
      R1 = _rjVl::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckO7:
      (_ckO0::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjVl::P64);
      if (_ckO0::I64 == 0) goto ckO2; else goto ckO1;
  ckO2:
      call (I64[_rjVl::P64])() args: 8, res: 0, upd: 8;
  ckO1:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckO0::I64;
      R2 = ckO3_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:54.199234 UTC

{offset
  ckO4:
      _rjVl::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckO5; else goto ckO6;
  ckO6:
      if (HpLim == 0) goto ckO5; else goto ckO7;
  ckO5:
      R1 = _rjVl::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckO7:
      (_ckO0::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjVl::P64);
      if (_ckO0::I64 == 0) goto ckO2; else goto ckO1;
  ckO2:
      call (I64[_rjVl::P64])() args: 8, res: 0, upd: 8;
  ckO1:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckO0::I64;
      R2 = ckO3_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:54.200395 UTC

{offset
  ckO4:
      _rjVl::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto ckO5; else goto ckO6;
  ckO6:
      if (HpLim == 0) goto ckO5; else goto ckO7;
  ckO5:
      R1 = _rjVl::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckO7:
      (_ckO0::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjVl::P64);
      if (_ckO0::I64 == 0) goto ckO2; else goto ckO1;
  ckO2:
      call (I64[_rjVl::P64])() args: 8, res: 0, upd: 8;
  ckO1:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _ckO0::I64;
      R2 = ckO3_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:54.201531 UTC

{offset
  ckO4:
      _rjVl::P64 = R1;
      if ((Sp + -16) < SpLim) goto ckO5; else goto ckO6;
  ckO6:
      if (HpLim == 0) goto ckO5; else goto ckO7;
  ckO5:
      R1 = _rjVl::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckO7:
      (_ckO0::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjVl::P64);
      if (_ckO0::I64 == 0) goto ckO2; else goto ckO1;
  ckO2:
      call (I64[_rjVl::P64])() args: 8, res: 0, upd: 8;
  ckO1:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _ckO0::I64;
      R2 = ckO3_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:54.202817 UTC

[(ckO1, {}), (ckO2, {}), (ckO4, {}), (ckO5, {}), (ckO6, {}),
 (ckO7, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:54.203841 UTC

lvl18_rjVl_entry() //  [R1]
        { info_tbl: [(ckO4,
                      label: lvl18_rjVl_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckO4:
          _rjVl::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckO5; else goto ckO6;
      ckO6:
          if (HpLim == 0) goto ckO5; else goto ckO7;
      ckO5:
          R1 = _rjVl::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckO7:
          (_ckO0::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjVl::P64);
          if (_ckO0::I64 == 0) goto ckO2; else goto ckO1;
      ckO2:
          call (I64[_rjVl::P64])() args: 8, res: 0, upd: 8;
      ckO1:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _ckO0::I64;
          R2 = ckO3_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:54.205183 UTC

lvl18_rjVl_entry() //  [R1]
        { info_tbl: [(ckO4,
                      label: lvl18_rjVl_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckO4:
          _rjVl::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckO5; else goto ckO6;
      ckO6:
          if (HpLim == 0) goto ckO5; else goto ckO7;
      ckO5:
          R1 = _rjVl::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckO7:
          (_ckO0::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjVl::P64);
          if (_ckO0::I64 == 0) goto ckO2; else goto ckO1;
      ckO2:
          call (I64[_rjVl::P64])() args: 8, res: 0, upd: 8;
      ckO1:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _ckO0::I64;
          R2 = ckO3_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:54.206554 UTC

[section "data" {
     lvl18_rjVl_closure:
         const lvl18_rjVl_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ckO3_str:
         I8[] [112,114,111,103]
 },
 lvl18_rjVl_entry() //  [R1]
         { info_tbl: [(ckO4,
                       label: lvl18_rjVl_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckO4:
           _rjVl::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckO5; else goto ckO6;
       ckO6:
           if (HpLim == 0) goto ckO5; else goto ckO7;
       ckO5:
           R1 = _rjVl::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckO7:
           (_ckO0::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjVl::P64);
           if (_ckO0::I64 == 0) goto ckO2; else goto ckO1;
       ckO2:
           call (I64[_rjVl::P64])() args: 8, res: 0, upd: 8;
       ckO1:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ckO0::I64;
           R2 = ckO3_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:54.208283 UTC

[section "data" {
     lvl18_rjVl_closure:
         const lvl18_rjVl_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ckO3_str:
         I8[] [112,114,111,103]
 },
 lvl18_rjVl_entry() //  [R1]
         { info_tbl: [(ckO4,
                       label: lvl18_rjVl_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckO4:
           _rjVl::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckO5; else goto ckO6;
       ckO6:
           if (HpLim == 0) goto ckO5; else goto ckO7;
       ckO5:
           R1 = _rjVl::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckO7:
           (_ckO0::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjVl::P64);
           if (_ckO0::I64 == 0) goto ckO2; else goto ckO1;
       ckO2:
           call (I64[_rjVl::P64])() args: 8, res: 0, upd: 8;
       ckO1:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ckO0::I64;
           R2 = ckO3_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:54.213001 UTC

[section "data" {
     a6_rjVm_closure:
         const a6_rjVm_info;
 },
 a6_rjVm_entry() //  []
         { info_tbl: [(ckOl,
                       label: a6_rjVm_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckOl:
           goto ckOg;
       ckOg:
           if ((old + 0) - <highSp> < SpLim) goto ckOm; else goto ckOn;
       ckOn:
           goto ckOf;
       ckOf:
           if (HpLim == 0) goto ckOm; else goto ckOo;
       ckOm:
           R1 = a6_rjVm_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ckOo:
           I64[(young<ckOi> + 8)] = ckOi;
           R1 = lvl_rjUX_closure+1;
           call stg_newMutVar#(R1) returns to ckOi, args: 8, res: 8, upd: 8;
       ckOi:
           _sk2U::P64 = R1;
           Hp = Hp + 16;
           if (Hp > HpLim) goto ckOr; else goto ckOq;
       ckOr:
           HpAlloc = 16;
           goto ckOp;
       ckOp:
           R1 = _sk2U::P64;
           call stg_gc_unpt_r1(R1) returns to ckOi, args: 8, res: 8, upd: 8;
       ckOq:
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = _sk2U::P64;
           _ckOk::P64 = Hp - 7;
           R1 = _ckOk::P64;
           call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:54.215445 UTC

{offset
  ckOl:
      if ((old + 0) - <highSp> < SpLim) goto ckOm; else goto ckOn;
  ckOn:
      if (HpLim == 0) goto ckOm; else goto ckOo;
  ckOm:
      R1 = a6_rjVm_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  ckOo:
      I64[(young<ckOi> + 8)] = ckOi;
      R1 = lvl_rjUX_closure+1;
      call stg_newMutVar#(R1) returns to ckOi, args: 8, res: 8, upd: 8;
  ckOi:
      _sk2U::P64 = R1;
      Hp = Hp + 16;
      if (Hp > HpLim) goto ckOr; else goto ckOq;
  ckOr:
      HpAlloc = 16;
      R1 = _sk2U::P64;
      call stg_gc_unpt_r1(R1) returns to ckOi, args: 8, res: 8, upd: 8;
  ckOq:
      I64[Hp - 8] = GHC.STRef.STRef_con_info;
      P64[Hp] = _sk2U::P64;
      _ckOk::P64 = Hp - 7;
      R1 = _ckOk::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:54.216768 UTC

{offset
  ckOl:
      if ((old + 0) - <highSp> < SpLim) goto ckOm; else goto ckOn;
  ckOn:
      if (HpLim == 0) goto ckOm; else goto ckOo;
  ckOm:
      R1 = a6_rjVm_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  ckOo:
      I64[(young<ckOi> + 8)] = ckOi;
      R1 = lvl_rjUX_closure+1;
      call stg_newMutVar#(R1) returns to ckOi, args: 8, res: 8, upd: 8;
  ckOi:
      _sk2U::P64 = R1;
      Hp = Hp + 16;
      if (Hp > HpLim) goto ckOr; else goto ckOq;
  ckOr:
      HpAlloc = 16;
      R1 = _sk2U::P64;
      call stg_gc_unpt_r1(R1) returns to ckOi, args: 8, res: 8, upd: 8;
  ckOq:
      I64[Hp - 8] = GHC.STRef.STRef_con_info;
      P64[Hp] = _sk2U::P64;
      _ckOk::P64 = Hp - 7;
      R1 = _ckOk::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:54.218127 UTC

{offset
  ckOl:
      if ((old + 0) - <highSp> < SpLim) goto ckOm; else goto ckOn;
  ckOn:
      if (HpLim == 0) goto ckOm; else goto ckOo;
  ckOm:
      R1 = a6_rjVm_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  ckOo:
      I64[(young<ckOi> + 8)] = ckOi;
      R1 = lvl_rjUX_closure+1;
      call stg_newMutVar#(R1) returns to ckOi, args: 8, res: 8, upd: 8;
  ckOi:
      _sk2U::P64 = R1;
      Hp = Hp + 16;
      if (Hp > HpLim) goto ckOr; else goto ckOq;
  ckOr:
      HpAlloc = 16;
      R1 = _sk2U::P64;
      call stg_gc_unpt_r1(R1) returns to ckOi, args: 8, res: 8, upd: 8;
  ckOq:
      I64[Hp - 8] = GHC.STRef.STRef_con_info;
      P64[Hp] = _sk2U::P64;
      _ckOk::P64 = Hp - 7;
      R1 = _ckOk::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:54.219736 UTC

{offset
  ckOl:
      if ((Sp + 8) - 16 < SpLim) goto ckOm; else goto ckOn;
  ckOn:
      if (HpLim == 0) goto ckOm; else goto ckOo;
  ckOm:
      R1 = a6_rjVm_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  ckOo:
      I64[Sp - 8] = ckOi;
      R1 = lvl_rjUX_closure+1;
      Sp = Sp - 8;
      call stg_newMutVar#(R1) returns to ckOi, args: 8, res: 8, upd: 8;
  ckOi:
      _sk2U::P64 = R1;
      Hp = Hp + 16;
      if (Hp > HpLim) goto ckOr; else goto ckOq;
  ckOr:
      HpAlloc = 16;
      R1 = _sk2U::P64;
      call stg_gc_unpt_r1(R1) returns to ckOi, args: 8, res: 8, upd: 8;
  ckOq:
      I64[Hp - 8] = GHC.STRef.STRef_con_info;
      P64[Hp] = _sk2U::P64;
      _ckOk::P64 = Hp - 7;
      R1 = _ckOk::P64;
      Sp = Sp + 8;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:54.221101 UTC

{offset
  ckOl:
      if ((Sp + -8) < SpLim) goto ckOm; else goto ckOn;
  ckOn:
      if (HpLim == 0) goto ckOm; else goto ckOo;
  ckOm:
      R1 = a6_rjVm_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  ckOo:
      I64[Sp - 8] = ckOi;
      R1 = lvl_rjUX_closure+1;
      Sp = Sp - 8;
      call stg_newMutVar#(R1) returns to ckOi, args: 8, res: 8, upd: 8;
  ckOi:
      Hp = Hp + 16;
      if (Hp > HpLim) goto ckOr; else goto ckOq;
  ckOr:
      HpAlloc = 16;
      R1 = R1;
      call stg_gc_unpt_r1(R1) returns to ckOi, args: 8, res: 8, upd: 8;
  ckOq:
      I64[Hp - 8] = GHC.STRef.STRef_con_info;
      P64[Hp] = R1;
      R1 = Hp - 7;
      Sp = Sp + 8;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:54.222523 UTC

[(ckOi, {}), (ckOl, {}), (ckOm, {}), (ckOn, {}), (ckOo, {}),
 (ckOq, {}), (ckOr, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:54.222941 UTC

a6_rjVm_entry() //  []
        { info_tbl: [(ckOi,
                      label: block_ckOi_info
                      rep:StackRep []),
                     (ckOl,
                      label: a6_rjVm_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckOl:
          if ((Sp + -8) < SpLim) goto ckOm; else goto ckOn;
      ckOn:
          if (HpLim == 0) goto ckOm; else goto ckOo;
      ckOm:
          R1 = a6_rjVm_closure;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
      ckOo:
          I64[Sp - 8] = ckOi;
          R1 = lvl_rjUX_closure+1;
          Sp = Sp - 8;
          call stg_newMutVar#(R1) returns to ckOi, args: 8, res: 8, upd: 8;
      ckOi:
          Hp = Hp + 16;
          if (Hp > HpLim) goto ckOr; else goto ckOq;
      ckOr:
          HpAlloc = 16;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to ckOi, args: 8, res: 8, upd: 8;
      ckOq:
          I64[Hp - 8] = GHC.STRef.STRef_con_info;
          P64[Hp] = R1;
          R1 = Hp - 7;
          Sp = Sp + 8;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:54.224573 UTC

a6_rjVm_entry() //  []
        { info_tbl: [(ckOi,
                      label: block_ckOi_info
                      rep:StackRep []),
                     (ckOl,
                      label: a6_rjVm_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckOl:
          if ((Sp + -8) < SpLim) goto ckOm; else goto ckOn;
      ckOn:
          if (HpLim == 0) goto ckOm; else goto ckOo;
      ckOm:
          R1 = a6_rjVm_closure;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
      ckOo:
          I64[Sp - 8] = ckOi;
          R1 = lvl_rjUX_closure+1;
          Sp = Sp - 8;
          call stg_newMutVar#(R1) returns to ckOi, args: 8, res: 8, upd: 8;
      ckOi:
          Hp = Hp + 16;
          if (Hp > HpLim) goto ckOr; else goto ckOq;
      ckOr:
          HpAlloc = 16;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to ckOi, args: 8, res: 8, upd: 8;
      ckOq:
          I64[Hp - 8] = GHC.STRef.STRef_con_info;
          P64[Hp] = R1;
          R1 = Hp - 7;
          Sp = Sp + 8;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:54.226208 UTC

[section "data" {
     a6_rjVm_closure:
         const a6_rjVm_info;
 },
 a6_rjVm_entry() //  []
         { info_tbl: [(ckOi,
                       label: block_ckOi_info
                       rep:StackRep []),
                      (ckOl,
                       label: a6_rjVm_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckOl:
           if ((Sp + -8) < SpLim) goto ckOm; else goto ckOn;
       ckOn:
           if (HpLim == 0) goto ckOm; else goto ckOo;
       ckOm:
           R1 = a6_rjVm_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ckOo:
           I64[Sp - 8] = ckOi;
           R1 = lvl_rjUX_closure+1;
           Sp = Sp - 8;
           call stg_newMutVar#(R1) returns to ckOi, args: 8, res: 8, upd: 8;
       ckOi:
           Hp = Hp + 16;
           if (Hp > HpLim) goto ckOr; else goto ckOq;
       ckOr:
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to ckOi, args: 8, res: 8, upd: 8;
       ckOq:
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:54.227984 UTC

[section "data" {
     a6_rjVm_closure:
         const a6_rjVm_info;
 },
 a6_rjVm_entry() //  []
         { info_tbl: [(ckOi,
                       label: block_ckOi_info
                       rep:StackRep []),
                      (ckOl,
                       label: a6_rjVm_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckOl:
           if ((Sp + -8) < SpLim) goto ckOm; else goto ckOn;
       ckOn:
           if (HpLim == 0) goto ckOm; else goto ckOo;
       ckOm:
           R1 = a6_rjVm_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ckOo:
           I64[Sp - 8] = ckOi;
           R1 = lvl_rjUX_closure+1;
           Sp = Sp - 8;
           call stg_newMutVar#(R1) returns to ckOi, args: 8, res: 8, upd: 8;
       ckOi:
           Hp = Hp + 16;
           if (Hp > HpLim) goto ckOr; else goto ckOq;
       ckOr:
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to ckOi, args: 8, res: 8, upd: 8;
       ckOq:
           I64[Hp - 8] = GHC.STRef.STRef_con_info;
           P64[Hp] = R1;
           R1 = Hp - 7;
           Sp = Sp + 8;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:54.232528 UTC

[section "data" {
     lvl19_rjVn_closure:
         const :_static_info;
         const a6_rjVm_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:54.232995 UTC

[section "data" {
     lvl19_rjVn_closure:
         const :_static_info;
         const a6_rjVm_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:54.23338 UTC

[section "data" {
     lvl19_rjVn_closure:
         const :_static_info;
         const a6_rjVm_closure+1;
         const GHC.Types.[]_closure+1;
         const 3;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:54.234259 UTC

[section "data" {
     $wxs_rjVo_closure:
         const $wxs_rjVo_info;
 },
 sat_sk2Z_entry() //  [R1]
         { info_tbl: [(ckOV,
                       label: sat_sk2Z_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckOV:
           _sk2Z::P64 = R1;
           goto ckOR;
       ckOR:
           if ((old + 0) - <highSp> < SpLim) goto ckOW; else goto ckOX;
       ckOX:
           if (HpLim == 0) goto ckOW; else goto ckOY;
       ckOW:
           R1 = _sk2Z::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckOY:
           I64[(old + 24)] = stg_upd_frame_info;
           P64[(old + 16)] = _sk2Z::P64;
           _sk2X::I64 = I64[_sk2Z::P64 + 16];
           _ckOT::I64 = _sk2X::I64 - 1;
           _sk2Y::I64 = _ckOT::I64;
           R2 = _sk2Y::I64;
           call $wxs_rjVo_info(R2) args: 24, res: 0, upd: 24;
     }
 },
 $wxs_rjVo_entry() //  [R2]
         { info_tbl: [(ckP2,
                       label: $wxs_rjVo_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckP2:
           _sk2W::I64 = R2;
           goto ckOL;
       ckOL:
           if ((old + 0) - <highSp> < SpLim) goto ckP3; else goto ckP4;
       ckP4:
           goto ckOK;
       ckOK:
           Hp = Hp + 48;
           if (Hp > HpLim) goto ckP6; else goto ckP5;
       ckP6:
           HpAlloc = 48;
           goto ckP3;
       ckP3:
           R2 = _sk2W::I64;
           R1 = $wxs_rjVo_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckP5:
           _sk2X::I64 = _sk2W::I64;
           switch [-9223372036854775808 .. 9223372036854775807] _sk2X::I64 {
               case 1 : goto ckP1;
               default: goto ckP0;
           }
       ckP1:
           Hp = Hp - 48;
           R1 = lvl19_rjVn_closure+2;
           call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
       ckP0:
           I64[Hp - 40] = sat_sk2Z_info;
           I64[Hp - 24] = _sk2X::I64;
           _ckOP::P64 = Hp - 40;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = a6_rjVm_closure+1;
           P64[Hp] = _ckOP::P64;
           _ckP7::P64 = Hp - 14;
           R1 = _ckP7::P64;
           call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:54.238484 UTC

{offset
  ckOV:
      _sk2Z::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckOW; else goto ckOX;
  ckOX:
      if (HpLim == 0) goto ckOW; else goto ckOY;
  ckOW:
      R1 = _sk2Z::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckOY:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sk2Z::P64;
      _sk2X::I64 = I64[_sk2Z::P64 + 16];
      _ckOT::I64 = _sk2X::I64 - 1;
      _sk2Y::I64 = _ckOT::I64;
      R2 = _sk2Y::I64;
      call $wxs_rjVo_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:54.239454 UTC

{offset
  ckOV:
      _sk2Z::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckOW; else goto ckOX;
  ckOX:
      if (HpLim == 0) goto ckOW; else goto ckOY;
  ckOW:
      R1 = _sk2Z::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckOY:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sk2Z::P64;
      _sk2X::I64 = I64[_sk2Z::P64 + 16];
      _ckOT::I64 = _sk2X::I64 - 1;
      _sk2Y::I64 = _ckOT::I64;
      R2 = _sk2Y::I64;
      call $wxs_rjVo_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:54.24105 UTC

{offset
  ckOV:
      _sk2Z::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckOW; else goto ckOX;
  ckOX:
      if (HpLim == 0) goto ckOW; else goto ckOY;
  ckOW:
      R1 = _sk2Z::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckOY:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sk2Z::P64;
      _sk2X::I64 = I64[_sk2Z::P64 + 16];
      _ckOT::I64 = _sk2X::I64 - 1;
      _sk2Y::I64 = _ckOT::I64;
      R2 = _sk2Y::I64;
      call $wxs_rjVo_info(R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:54.242045 UTC

{offset
  ckOV:
      _sk2Z::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto ckOW; else goto ckOX;
  ckOX:
      if (HpLim == 0) goto ckOW; else goto ckOY;
  ckOW:
      R1 = _sk2Z::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckOY:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _sk2Z::P64;
      _sk2X::I64 = I64[_sk2Z::P64 + 16];
      _ckOT::I64 = _sk2X::I64 - 1;
      _sk2Y::I64 = _ckOT::I64;
      R2 = _sk2Y::I64;
      Sp = Sp - 16;
      call $wxs_rjVo_info(R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:54.243023 UTC

{offset
  ckOV:
      _sk2Z::P64 = R1;
      if ((Sp + -16) < SpLim) goto ckOW; else goto ckOX;
  ckOX:
      if (HpLim == 0) goto ckOW; else goto ckOY;
  ckOW:
      R1 = _sk2Z::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckOY:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _sk2Z::P64;
      R2 = I64[_sk2Z::P64 + 16] - 1;
      Sp = Sp - 16;
      call $wxs_rjVo_info(R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:54.244027 UTC

[(ckOV, {}), (ckOW, {}), (ckOX, {}), (ckOY, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:54.244346 UTC

sat_sk2Z_entry() //  [R1]
        { info_tbl: [(ckOV,
                      label: sat_sk2Z_info
                      rep:HeapRep 1 nonptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckOV:
          _sk2Z::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckOW; else goto ckOX;
      ckOX:
          if (HpLim == 0) goto ckOW; else goto ckOY;
      ckOW:
          R1 = _sk2Z::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckOY:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _sk2Z::P64;
          R2 = I64[_sk2Z::P64 + 16] - 1;
          Sp = Sp - 16;
          call $wxs_rjVo_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:54.245419 UTC

sat_sk2Z_entry() //  [R1]
        { info_tbl: [(ckOV,
                      label: sat_sk2Z_info
                      rep:HeapRep 1 nonptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckOV:
          _sk2Z::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckOW; else goto ckOX;
      ckOX:
          if (HpLim == 0) goto ckOW; else goto ckOY;
      ckOW:
          R1 = _sk2Z::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckOY:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _sk2Z::P64;
          R2 = I64[_sk2Z::P64 + 16] - 1;
          Sp = Sp - 16;
          call $wxs_rjVo_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:54.246508 UTC

{offset
  ckP2:
      _sk2W::I64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckP3; else goto ckP4;
  ckP4:
      Hp = Hp + 48;
      if (Hp > HpLim) goto ckP6; else goto ckP5;
  ckP6:
      HpAlloc = 48;
      goto ckP3;
  ckP3:
      R2 = _sk2W::I64;
      R1 = $wxs_rjVo_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckP5:
      _sk2X::I64 = _sk2W::I64;
      switch [-9223372036854775808 .. 9223372036854775807] _sk2X::I64 {
          case 1 : goto ckP1;
          default: goto ckP0;
      }
  ckP1:
      Hp = Hp - 48;
      R1 = lvl19_rjVn_closure+2;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
  ckP0:
      I64[Hp - 40] = sat_sk2Z_info;
      I64[Hp - 24] = _sk2X::I64;
      _ckOP::P64 = Hp - 40;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = a6_rjVm_closure+1;
      P64[Hp] = _ckOP::P64;
      _ckP7::P64 = Hp - 14;
      R1 = _ckP7::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:54.248092 UTC

{offset
  ckP2:
      _sk2W::I64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckP3; else goto ckP4;
  ckP4:
      Hp = Hp + 48;
      if (Hp > HpLim) goto ckP6; else goto ckP5;
  ckP6:
      HpAlloc = 48;
      goto ckP3;
  ckP3:
      R2 = _sk2W::I64;
      R1 = $wxs_rjVo_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckP5:
      _sk2X::I64 = _sk2W::I64;
      switch [-9223372036854775808 .. 9223372036854775807] _sk2X::I64 {
          case 1 : goto ckP1;
          default: goto ckP0;
      }
  ckP1:
      Hp = Hp - 48;
      R1 = lvl19_rjVn_closure+2;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
  ckP0:
      I64[Hp - 40] = sat_sk2Z_info;
      I64[Hp - 24] = _sk2X::I64;
      _ckOP::P64 = Hp - 40;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = a6_rjVm_closure+1;
      P64[Hp] = _ckOP::P64;
      _ckP7::P64 = Hp - 14;
      R1 = _ckP7::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:54.249721 UTC

{offset
  ckP2:
      _sk2W::I64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto ckP3; else goto ckP4;
  ckP4:
      Hp = Hp + 48;
      if (Hp > HpLim) goto ckP6; else goto ckP5;
  ckP6:
      HpAlloc = 48;
      goto ckP3;
  ckP3:
      R2 = _sk2W::I64;
      R1 = $wxs_rjVo_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckP5:
      _sk2X::I64 = _sk2W::I64;
      if (_sk2X::I64 != 1) goto ckP0; else goto ckP1;
  ckP0:
      I64[Hp - 40] = sat_sk2Z_info;
      I64[Hp - 24] = _sk2X::I64;
      _ckOP::P64 = Hp - 40;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = a6_rjVm_closure+1;
      P64[Hp] = _ckOP::P64;
      _ckP7::P64 = Hp - 14;
      R1 = _ckP7::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
  ckP1:
      Hp = Hp - 48;
      R1 = lvl19_rjVn_closure+2;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:54.251291 UTC

{offset
  ckP2:
      _sk2W::I64 = R2;
      goto ckP4;
  ckP4:
      Hp = Hp + 48;
      if (Hp > HpLim) goto ckP6; else goto ckP5;
  ckP6:
      HpAlloc = 48;
      goto ckP3;
  ckP3:
      R2 = _sk2W::I64;
      R1 = $wxs_rjVo_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckP5:
      _sk2X::I64 = _sk2W::I64;
      if (_sk2X::I64 != 1) goto ckP0; else goto ckP1;
  ckP0:
      I64[Hp - 40] = sat_sk2Z_info;
      I64[Hp - 24] = _sk2X::I64;
      _ckOP::P64 = Hp - 40;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = a6_rjVm_closure+1;
      P64[Hp] = _ckOP::P64;
      _ckP7::P64 = Hp - 14;
      R1 = _ckP7::P64;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
  ckP1:
      Hp = Hp - 48;
      R1 = lvl19_rjVn_closure+2;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:54.252718 UTC

{offset
  ckP2:
      goto ckP4;
  ckP4:
      Hp = Hp + 48;
      if (Hp > HpLim) goto ckP6; else goto ckP5;
  ckP6:
      HpAlloc = 48;
      goto ckP3;
  ckP3:
      R2 = R2;
      R1 = $wxs_rjVo_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckP5:
      if (R2 != 1) goto ckP0; else goto ckP1;
  ckP0:
      I64[Hp - 40] = sat_sk2Z_info;
      I64[Hp - 24] = R2;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = a6_rjVm_closure+1;
      P64[Hp] = Hp - 40;
      R1 = Hp - 14;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
  ckP1:
      Hp = Hp - 48;
      R1 = lvl19_rjVn_closure+2;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:54.254188 UTC

[(ckP0, {sat_sk2Z_closure}), (ckP1, {}),
 (ckP2, {sat_sk2Z_closure}), (ckP3, {}), (ckP4, {sat_sk2Z_closure}),
 (ckP5, {sat_sk2Z_closure}), (ckP6, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:54.254716 UTC

$wxs_rjVo_entry() //  [R2]
        { info_tbl: [(ckP2,
                      label: $wxs_rjVo_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckP2:
          goto ckP4;
      ckP4:
          Hp = Hp + 48;
          if (Hp > HpLim) goto ckP6; else goto ckP5;
      ckP6:
          HpAlloc = 48;
          goto ckP3;
      ckP3:
          R2 = R2;
          R1 = $wxs_rjVo_closure;
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
      ckP5:
          if (R2 != 1) goto ckP0; else goto ckP1;
      ckP0:
          I64[Hp - 40] = sat_sk2Z_info;
          I64[Hp - 24] = R2;
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = a6_rjVm_closure+1;
          P64[Hp] = Hp - 40;
          R1 = Hp - 14;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
      ckP1:
          Hp = Hp - 48;
          R1 = lvl19_rjVn_closure+2;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:54.256264 UTC

$wxs_rjVo_entry() //  [R2]
        { info_tbl: [(ckP2,
                      label: $wxs_rjVo_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckP2:
          Hp = Hp + 48;
          if (Hp > HpLim) goto ckP6; else goto ckP5;
      ckP6:
          HpAlloc = 48;
          R2 = R2;
          R1 = $wxs_rjVo_closure;
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
      ckP5:
          if (R2 != 1) goto ckP0; else goto ckP1;
      ckP0:
          I64[Hp - 40] = sat_sk2Z_info;
          I64[Hp - 24] = R2;
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = a6_rjVm_closure+1;
          P64[Hp] = Hp - 40;
          R1 = Hp - 14;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
      ckP1:
          Hp = Hp - 48;
          R1 = lvl19_rjVn_closure+2;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:54.257737 UTC

[section "data" {
     $wxs_rjVo_closure:
         const $wxs_rjVo_info;
 },
 sat_sk2Z_entry() //  [R1]
         { info_tbl: [(ckOV,
                       label: sat_sk2Z_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckOV:
           _sk2Z::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckOW; else goto ckOX;
       ckOX:
           if (HpLim == 0) goto ckOW; else goto ckOY;
       ckOW:
           R1 = _sk2Z::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckOY:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sk2Z::P64;
           R2 = I64[_sk2Z::P64 + 16] - 1;
           Sp = Sp - 16;
           call $wxs_rjVo_info(R2) args: 24, res: 0, upd: 24;
     }
 },
 $wxs_rjVo_entry() //  [R2]
         { info_tbl: [(ckP2,
                       label: $wxs_rjVo_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckP2:
           Hp = Hp + 48;
           if (Hp > HpLim) goto ckP6; else goto ckP5;
       ckP6:
           HpAlloc = 48;
           R2 = R2;
           R1 = $wxs_rjVo_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckP5:
           if (R2 != 1) goto ckP0; else goto ckP1;
       ckP0:
           I64[Hp - 40] = sat_sk2Z_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = a6_rjVm_closure+1;
           P64[Hp] = Hp - 40;
           R1 = Hp - 14;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
       ckP1:
           Hp = Hp - 48;
           R1 = lvl19_rjVn_closure+2;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:54.260391 UTC

[section "data" {
     $wxs_rjVo_closure:
         const $wxs_rjVo_info;
 },
 sat_sk2Z_entry() //  [R1]
         { info_tbl: [(ckOV,
                       label: sat_sk2Z_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckOV:
           _sk2Z::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckOW; else goto ckOX;
       ckOX:
           if (HpLim == 0) goto ckOW; else goto ckOY;
       ckOW:
           R1 = _sk2Z::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckOY:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sk2Z::P64;
           R2 = I64[_sk2Z::P64 + 16] - 1;
           Sp = Sp - 16;
           call $wxs_rjVo_info(R2) args: 24, res: 0, upd: 24;
     }
 },
 $wxs_rjVo_entry() //  [R2]
         { info_tbl: [(ckP2,
                       label: $wxs_rjVo_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckP2:
           Hp = Hp + 48;
           if (Hp > HpLim) goto ckP6; else goto ckP5;
       ckP6:
           HpAlloc = 48;
           R2 = R2;
           R1 = $wxs_rjVo_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckP5:
           if (R2 != 1) goto ckP0; else goto ckP1;
       ckP0:
           I64[Hp - 40] = sat_sk2Z_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = a6_rjVm_closure+1;
           P64[Hp] = Hp - 40;
           R1 = Hp - 14;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
       ckP1:
           Hp = Hp - 48;
           R1 = lvl19_rjVn_closure+2;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:54.266764 UTC

[section "data" {
     lvl20_rjVp_closure:
         const Options.Applicative.Types.MultP_static_info;
         const Options.Applicative.Extra.helper_closure;
         const Main.rbTreeOpts_closure+3;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:54.267254 UTC

[section "data" {
     lvl20_rjVp_closure:
         const Options.Applicative.Types.MultP_static_info;
         const Options.Applicative.Extra.helper_closure;
         const Main.rbTreeOpts_closure+3;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:54.267648 UTC

[section "data" {
     lvl20_rjVp_closure:
         const Options.Applicative.Types.MultP_static_info;
         const Options.Applicative.Extra.helper_closure;
         const Main.rbTreeOpts_closure+3;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:54.268348 UTC

[section "data" {
     lvl21_rjVq_closure:
         const lvl21_rjVq_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ckPp_str:
         I8[] [82,66,84,114,101,101,32,98,101,110,99,104,109,97,114,107,46]
 },
 lvl21_rjVq_entry() //  [R1]
         { info_tbl: [(ckPq,
                       label: lvl21_rjVq_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckPq:
           _rjVq::P64 = R1;
           goto ckPk;
       ckPk:
           if ((old + 0) - <highSp> < SpLim) goto ckPr; else goto ckPs;
       ckPs:
           if (HpLim == 0) goto ckPr; else goto ckPt;
       ckPr:
           R1 = _rjVq::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckPt:
           (_ckPm::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjVq::P64);
           if (_ckPm::I64 == 0) goto ckPo; else goto ckPn;
       ckPo:
           call (I64[_rjVq::P64])() args: 8, res: 0, upd: 8;
       ckPn:
           I64[(old + 24)] = stg_bh_upd_frame_info;
           I64[(old + 16)] = _ckPm::I64;
           R2 = ckPp_str;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:54.270488 UTC

{offset
  ckPq:
      _rjVq::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckPr; else goto ckPs;
  ckPs:
      if (HpLim == 0) goto ckPr; else goto ckPt;
  ckPr:
      R1 = _rjVq::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckPt:
      (_ckPm::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjVq::P64);
      if (_ckPm::I64 == 0) goto ckPo; else goto ckPn;
  ckPo:
      call (I64[_rjVq::P64])() args: 8, res: 0, upd: 8;
  ckPn:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckPm::I64;
      R2 = ckPp_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:54.271588 UTC

{offset
  ckPq:
      _rjVq::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckPr; else goto ckPs;
  ckPs:
      if (HpLim == 0) goto ckPr; else goto ckPt;
  ckPr:
      R1 = _rjVq::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckPt:
      (_ckPm::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjVq::P64);
      if (_ckPm::I64 == 0) goto ckPo; else goto ckPn;
  ckPo:
      call (I64[_rjVq::P64])() args: 8, res: 0, upd: 8;
  ckPn:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckPm::I64;
      R2 = ckPp_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:54.273232 UTC

{offset
  ckPq:
      _rjVq::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckPr; else goto ckPs;
  ckPs:
      if (HpLim == 0) goto ckPr; else goto ckPt;
  ckPr:
      R1 = _rjVq::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckPt:
      (_ckPm::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjVq::P64);
      if (_ckPm::I64 == 0) goto ckPo; else goto ckPn;
  ckPo:
      call (I64[_rjVq::P64])() args: 8, res: 0, upd: 8;
  ckPn:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckPm::I64;
      R2 = ckPp_str;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:54.274375 UTC

{offset
  ckPq:
      _rjVq::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto ckPr; else goto ckPs;
  ckPs:
      if (HpLim == 0) goto ckPr; else goto ckPt;
  ckPr:
      R1 = _rjVq::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckPt:
      (_ckPm::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjVq::P64);
      if (_ckPm::I64 == 0) goto ckPo; else goto ckPn;
  ckPo:
      call (I64[_rjVq::P64])() args: 8, res: 0, upd: 8;
  ckPn:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _ckPm::I64;
      R2 = ckPp_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:54.27551 UTC

{offset
  ckPq:
      _rjVq::P64 = R1;
      if ((Sp + -16) < SpLim) goto ckPr; else goto ckPs;
  ckPs:
      if (HpLim == 0) goto ckPr; else goto ckPt;
  ckPr:
      R1 = _rjVq::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckPt:
      (_ckPm::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjVq::P64);
      if (_ckPm::I64 == 0) goto ckPo; else goto ckPn;
  ckPo:
      call (I64[_rjVq::P64])() args: 8, res: 0, upd: 8;
  ckPn:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _ckPm::I64;
      R2 = ckPp_str;
      Sp = Sp - 16;
      call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:54.276793 UTC

[(ckPn, {}), (ckPo, {}), (ckPq, {}), (ckPr, {}), (ckPs, {}),
 (ckPt, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:54.27722 UTC

lvl21_rjVq_entry() //  [R1]
        { info_tbl: [(ckPq,
                      label: lvl21_rjVq_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckPq:
          _rjVq::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckPr; else goto ckPs;
      ckPs:
          if (HpLim == 0) goto ckPr; else goto ckPt;
      ckPr:
          R1 = _rjVq::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckPt:
          (_ckPm::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjVq::P64);
          if (_ckPm::I64 == 0) goto ckPo; else goto ckPn;
      ckPo:
          call (I64[_rjVq::P64])() args: 8, res: 0, upd: 8;
      ckPn:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _ckPm::I64;
          R2 = ckPp_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:54.278602 UTC

lvl21_rjVq_entry() //  [R1]
        { info_tbl: [(ckPq,
                      label: lvl21_rjVq_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckPq:
          _rjVq::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckPr; else goto ckPs;
      ckPs:
          if (HpLim == 0) goto ckPr; else goto ckPt;
      ckPr:
          R1 = _rjVq::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckPt:
          (_ckPm::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjVq::P64);
          if (_ckPm::I64 == 0) goto ckPo; else goto ckPn;
      ckPo:
          call (I64[_rjVq::P64])() args: 8, res: 0, upd: 8;
      ckPn:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _ckPm::I64;
          R2 = ckPp_str;
          Sp = Sp - 16;
          call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:54.28008 UTC

[section "data" {
     lvl21_rjVq_closure:
         const lvl21_rjVq_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ckPp_str:
         I8[] [82,66,84,114,101,101,32,98,101,110,99,104,109,97,114,107,46]
 },
 lvl21_rjVq_entry() //  [R1]
         { info_tbl: [(ckPq,
                       label: lvl21_rjVq_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckPq:
           _rjVq::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckPr; else goto ckPs;
       ckPs:
           if (HpLim == 0) goto ckPr; else goto ckPt;
       ckPr:
           R1 = _rjVq::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckPt:
           (_ckPm::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjVq::P64);
           if (_ckPm::I64 == 0) goto ckPo; else goto ckPn;
       ckPo:
           call (I64[_rjVq::P64])() args: 8, res: 0, upd: 8;
       ckPn:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ckPm::I64;
           R2 = ckPp_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:54.281774 UTC

[section "data" {
     lvl21_rjVq_closure:
         const lvl21_rjVq_info;
         const 0;
         const 0;
         const 0;
 },
 section "readonly" {
     ckPp_str:
         I8[] [82,66,84,114,101,101,32,98,101,110,99,104,109,97,114,107,46]
 },
 lvl21_rjVq_entry() //  [R1]
         { info_tbl: [(ckPq,
                       label: lvl21_rjVq_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckPq:
           _rjVq::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckPr; else goto ckPs;
       ckPs:
           if (HpLim == 0) goto ckPr; else goto ckPt;
       ckPr:
           R1 = _rjVq::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckPt:
           (_ckPm::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjVq::P64);
           if (_ckPm::I64 == 0) goto ckPo; else goto ckPn;
       ckPo:
           call (I64[_rjVq::P64])() args: 8, res: 0, upd: 8;
       ckPn:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ckPm::I64;
           R2 = ckPp_str;
           Sp = Sp - 16;
           call GHC.CString.unpackCString#_info(R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:54.286421 UTC

[section "data" {
     lvl22_rjVr_closure:
         const lvl22_rjVr_info;
         const 0;
         const 0;
         const 0;
 },
 lvl22_rjVr_entry() //  [R1]
         { info_tbl: [(ckPG,
                       label: lvl22_rjVr_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckPG:
           _rjVr::P64 = R1;
           goto ckPB;
       ckPB:
           if ((old + 0) - <highSp> < SpLim) goto ckPH; else goto ckPI;
       ckPI:
           if (HpLim == 0) goto ckPH; else goto ckPJ;
       ckPH:
           R1 = _rjVr::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckPJ:
           (_ckPD::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjVr::P64);
           if (_ckPD::I64 == 0) goto ckPF; else goto ckPE;
       ckPF:
           call (I64[_rjVr::P64])() args: 8, res: 0, upd: 8;
       ckPE:
           I64[(old + 24)] = stg_bh_upd_frame_info;
           I64[(old + 16)] = _ckPD::I64;
           R4 = lvl21_rjVq_closure;
           R3 = GHC.Base.Nothing_closure+1;
           R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
           call Data.OldList.wordsFB_info(R4,
                                          R3,
                                          R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:54.288677 UTC

{offset
  ckPG:
      _rjVr::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckPH; else goto ckPI;
  ckPI:
      if (HpLim == 0) goto ckPH; else goto ckPJ;
  ckPH:
      R1 = _rjVr::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckPJ:
      (_ckPD::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjVr::P64);
      if (_ckPD::I64 == 0) goto ckPF; else goto ckPE;
  ckPF:
      call (I64[_rjVr::P64])() args: 8, res: 0, upd: 8;
  ckPE:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckPD::I64;
      R4 = lvl21_rjVq_closure;
      R3 = GHC.Base.Nothing_closure+1;
      R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
      call Data.OldList.wordsFB_info(R4,
                                     R3,
                                     R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:54.289909 UTC

{offset
  ckPG:
      _rjVr::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckPH; else goto ckPI;
  ckPI:
      if (HpLim == 0) goto ckPH; else goto ckPJ;
  ckPH:
      R1 = _rjVr::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckPJ:
      (_ckPD::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjVr::P64);
      if (_ckPD::I64 == 0) goto ckPF; else goto ckPE;
  ckPF:
      call (I64[_rjVr::P64])() args: 8, res: 0, upd: 8;
  ckPE:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckPD::I64;
      R4 = lvl21_rjVq_closure;
      R3 = GHC.Base.Nothing_closure+1;
      R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
      call Data.OldList.wordsFB_info(R4,
                                     R3,
                                     R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:54.291185 UTC

{offset
  ckPG:
      _rjVr::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckPH; else goto ckPI;
  ckPI:
      if (HpLim == 0) goto ckPH; else goto ckPJ;
  ckPH:
      R1 = _rjVr::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckPJ:
      (_ckPD::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjVr::P64);
      if (_ckPD::I64 == 0) goto ckPF; else goto ckPE;
  ckPF:
      call (I64[_rjVr::P64])() args: 8, res: 0, upd: 8;
  ckPE:
      I64[(old + 24)] = stg_bh_upd_frame_info;
      I64[(old + 16)] = _ckPD::I64;
      R4 = lvl21_rjVq_closure;
      R3 = GHC.Base.Nothing_closure+1;
      R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
      call Data.OldList.wordsFB_info(R4,
                                     R3,
                                     R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:54.292471 UTC

{offset
  ckPG:
      _rjVr::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto ckPH; else goto ckPI;
  ckPI:
      if (HpLim == 0) goto ckPH; else goto ckPJ;
  ckPH:
      R1 = _rjVr::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckPJ:
      (_ckPD::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjVr::P64);
      if (_ckPD::I64 == 0) goto ckPF; else goto ckPE;
  ckPF:
      call (I64[_rjVr::P64])() args: 8, res: 0, upd: 8;
  ckPE:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _ckPD::I64;
      R4 = lvl21_rjVq_closure;
      R3 = GHC.Base.Nothing_closure+1;
      R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
      Sp = Sp - 16;
      call Data.OldList.wordsFB_info(R4,
                                     R3,
                                     R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:54.293739 UTC

{offset
  ckPG:
      _rjVr::P64 = R1;
      if ((Sp + -16) < SpLim) goto ckPH; else goto ckPI;
  ckPI:
      if (HpLim == 0) goto ckPH; else goto ckPJ;
  ckPH:
      R1 = _rjVr::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckPJ:
      (_ckPD::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjVr::P64);
      if (_ckPD::I64 == 0) goto ckPF; else goto ckPE;
  ckPF:
      call (I64[_rjVr::P64])() args: 8, res: 0, upd: 8;
  ckPE:
      I64[Sp - 16] = stg_bh_upd_frame_info;
      I64[Sp - 8] = _ckPD::I64;
      R4 = lvl21_rjVq_closure;
      R3 = GHC.Base.Nothing_closure+1;
      R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
      Sp = Sp - 16;
      call Data.OldList.wordsFB_info(R4,
                                     R3,
                                     R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:54.295154 UTC

[(ckPE,
  {Options.Applicative.Help.Chunk.paragraph1_closure,
   lvl21_rjVq_closure}),
 (ckPF, {}),
 (ckPG,
  {Options.Applicative.Help.Chunk.paragraph1_closure,
   lvl21_rjVq_closure}),
 (ckPH, {}),
 (ckPI,
  {Options.Applicative.Help.Chunk.paragraph1_closure,
   lvl21_rjVq_closure}),
 (ckPJ,
  {Options.Applicative.Help.Chunk.paragraph1_closure,
   lvl21_rjVq_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:54.295875 UTC

lvl22_rjVr_entry() //  [R1]
        { info_tbl: [(ckPG,
                      label: lvl22_rjVr_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckPG:
          _rjVr::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckPH; else goto ckPI;
      ckPI:
          if (HpLim == 0) goto ckPH; else goto ckPJ;
      ckPH:
          R1 = _rjVr::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckPJ:
          (_ckPD::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjVr::P64);
          if (_ckPD::I64 == 0) goto ckPF; else goto ckPE;
      ckPF:
          call (I64[_rjVr::P64])() args: 8, res: 0, upd: 8;
      ckPE:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _ckPD::I64;
          R4 = lvl21_rjVq_closure;
          R3 = GHC.Base.Nothing_closure+1;
          R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
          Sp = Sp - 16;
          call Data.OldList.wordsFB_info(R4,
                                         R3,
                                         R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:54.29743 UTC

lvl22_rjVr_entry() //  [R1]
        { info_tbl: [(ckPG,
                      label: lvl22_rjVr_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckPG:
          _rjVr::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckPH; else goto ckPI;
      ckPI:
          if (HpLim == 0) goto ckPH; else goto ckPJ;
      ckPH:
          R1 = _rjVr::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckPJ:
          (_ckPD::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjVr::P64);
          if (_ckPD::I64 == 0) goto ckPF; else goto ckPE;
      ckPF:
          call (I64[_rjVr::P64])() args: 8, res: 0, upd: 8;
      ckPE:
          I64[Sp - 16] = stg_bh_upd_frame_info;
          I64[Sp - 8] = _ckPD::I64;
          R4 = lvl21_rjVq_closure;
          R3 = GHC.Base.Nothing_closure+1;
          R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
          Sp = Sp - 16;
          call Data.OldList.wordsFB_info(R4,
                                         R3,
                                         R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:54.298954 UTC

[section "data" {
     lvl22_rjVr_closure:
         const lvl22_rjVr_info;
         const 0;
         const 0;
         const 0;
 },
 lvl22_rjVr_entry() //  [R1]
         { info_tbl: [(ckPG,
                       label: lvl22_rjVr_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckPG:
           _rjVr::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckPH; else goto ckPI;
       ckPI:
           if (HpLim == 0) goto ckPH; else goto ckPJ;
       ckPH:
           R1 = _rjVr::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckPJ:
           (_ckPD::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjVr::P64);
           if (_ckPD::I64 == 0) goto ckPF; else goto ckPE;
       ckPF:
           call (I64[_rjVr::P64])() args: 8, res: 0, upd: 8;
       ckPE:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ckPD::I64;
           R4 = lvl21_rjVq_closure;
           R3 = GHC.Base.Nothing_closure+1;
           R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
           Sp = Sp - 16;
           call Data.OldList.wordsFB_info(R4,
                                          R3,
                                          R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:54.300877 UTC

[section "data" {
     lvl22_rjVr_closure:
         const lvl22_rjVr_info;
         const 0;
         const 0;
         const 0;
 },
 lvl22_rjVr_entry() //  [R1]
         { info_tbl: [(ckPG,
                       label: lvl22_rjVr_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckPG:
           _rjVr::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckPH; else goto ckPI;
       ckPI:
           if (HpLim == 0) goto ckPH; else goto ckPJ;
       ckPH:
           R1 = _rjVr::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckPJ:
           (_ckPD::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _rjVr::P64);
           if (_ckPD::I64 == 0) goto ckPF; else goto ckPE;
       ckPF:
           call (I64[_rjVr::P64])() args: 8, res: 0, upd: 8;
       ckPE:
           I64[Sp - 16] = stg_bh_upd_frame_info;
           I64[Sp - 8] = _ckPD::I64;
           R4 = lvl21_rjVq_closure;
           R3 = GHC.Base.Nothing_closure+1;
           R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
           Sp = Sp - 16;
           call Data.OldList.wordsFB_info(R4,
                                          R3,
                                          R2) args: 24, res: 0, upd: 24;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:54.309818 UTC

[section "data" {
     Main.main1_closure:
         const Main.main1_info;
         const 0;
 },
 sat_sk37_entry() //  [R1]
         { info_tbl: [(ckRI,
                       label: sat_sk37_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckRI:
           _sk37::P64 = R1;
           goto ckRG;
       ckRG:
           if ((old + 0) - <highSp> < SpLim) goto ckRJ; else goto ckRK;
       ckRK:
           if (HpLim == 0) goto ckRJ; else goto ckRL;
       ckRJ:
           R1 = _sk37::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckRL:
           I64[(old + 24)] = stg_upd_frame_info;
           P64[(old + 16)] = _sk37::P64;
           _sk33::P64 = P64[_sk37::P64 + 16];
           R4 = _sk33::P64;
           R3 = GHC.Base.Nothing_closure+1;
           R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
           call Data.OldList.wordsFB_info(R4,
                                          R3,
                                          R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sk3R_entry() //  [R1]
         { info_tbl: [(ckSS,
                       label: sat_sk3R_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckSS:
           _sk3R::P64 = R1;
           goto ckSN;
       ckSN:
           if ((old + 0) - <highSp> < SpLim) goto ckSW; else goto ckSX;
       ckSX:
           goto ckSM;
       ckSM:
           if (HpLim == 0) goto ckSW; else goto ckSY;
       ckSW:
           R1 = _sk3R::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ckSY:
           _sk3D::P64 = P64[_sk3R::P64 + 7];
           _sk3I::P64 = P64[_sk3R::P64 + 15];
           I64[(young<ckSP> + 8)] = ckSP;
           R1 = _sk3D::P64;
           if (R1 & 7 != 0) goto ckSP; else goto ckSQ;
       ckSQ:
           call (I64[R1])(R1) returns to ckSP, args: 8, res: 8, upd: 8;
       ckSP:
           _sk3L::P64 = R1;
           _sk3M::P64 = P64[_sk3L::P64 + 7];
           _sk3N::P64 = P64[_sk3L::P64 + 15];
           _sk3O::P64 = P64[_sk3L::P64 + 23];
           I64[(young<ckSV> + 8)] = ckSV;
           R1 = _sk3N::P64;
           if (R1 & 7 != 0) goto ckSV; else goto ckT0;
       ckT0:
           call (I64[R1])(R1) returns to ckSV, args: 8, res: 8, upd: 8;
       ckSV:
           _sk3P::P64 = R1;
           _sk3Q::P64 = P64[_sk3P::P64 + 7];
           R6 = _sk3I::P64;
           R5 = _sk3O::P64;
           R4 = _sk3Q::P64;
           R3 = _sk3M::P64;
           R2 = GHC.Classes.$fOrdWord_closure;
           P64[(old + 16)] = GHC.Tuple.()_closure+1;
           call SkipList.$wa4_info(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 16, res: 0, upd: 8;
     }
 },
 a7_sk3E_entry() //  [R2, R1]
         { info_tbl: [(ckTP,
                       label: a7_sk3E_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckTP:
           _sk3F::P64 = R2;
           _sk3E::P64 = R1;
           goto ckSC;
       ckSC:
           if ((old + 0) - <highSp> < SpLim) goto ckTQ; else goto ckTR;
       ckTR:
           goto ckSB;
       ckSB:
           if (HpLim == 0) goto ckTQ; else goto ckTS;
       ckTQ:
           R2 = _sk3F::P64;
           R1 = _sk3E::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckTS:
           _sk3D::P64 = P64[_sk3E::P64 + 6];
           I64[(young<ckSE> + 8)] = ckSE;
           R1 = _sk3F::P64;
           if (R1 & 7 != 0) goto ckSE; else goto ckSF;
       ckSF:
           call (I64[R1])(R1) returns to ckSE, args: 8, res: 8, upd: 8;
       ckSE:
           _sk3H::P64 = R1;
           _ckTO::P64 = _sk3H::P64 & 7;
           switch [1 .. 2] _ckTO::P64 {
               case 1 : goto ckTM;
               case 2 : goto ckTN;
           }
       ckTN:
           Hp = Hp + 24;
           if (Hp > HpLim) goto ckTY; else goto ckTX;
       ckTY:
           HpAlloc = 24;
           goto ckTW;
       ckTW:
           R1 = _sk3H::P64;
           call stg_gc_unpt_r1(R1) returns to ckSE, args: 8, res: 8, upd: 8;
       ckTX:
           _sk3I::P64 = P64[_sk3H::P64 + 6];
           _sk3J::P64 = P64[_sk3H::P64 + 14];
           I64[Hp - 16] = sat_sk3R_info;
           P64[Hp - 8] = _sk3D::P64;
           P64[Hp] = _sk3I::P64;
           _ckSK::P64 = Hp - 15;
           I64[(young<ckTV> + 8)] = ckTV;
           R1 = _ckSK::P64;
           call stg_norec_atomically#(R1) returns to ckTV, args: 8, res: 8, upd: 8;
       ckTV:
           _sk3U::P64 = R1;
           R2 = _sk3J::P64;
           R1 = _sk3E::P64;
           call a7_sk3E_info(R2, R1) args: 8, res: 0, upd: 8;
       ckTM:
           R1 = GHC.Tuple.()_closure+1;
           call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sk4r_entry() //  [R1]
         { info_tbl: [(ckVA,
                       label: sat_sk4r_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckVA:
           _sk4r::P64 = R1;
           goto ckVv;
       ckVv:
           if ((old + 0) - <highSp> < SpLim) goto ckVB; else goto ckVC;
       ckVC:
           if (HpLim == 0) goto ckVB; else goto ckVD;
       ckVB:
           R1 = _sk4r::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckVD:
           I64[(old + 24)] = stg_upd_frame_info;
           P64[(old + 16)] = _sk4r::P64;
           _sk3x::I64 = I64[_sk4r::P64 + 16];
           I64[(young<ckVx> + 8)] = ckVx;
           R3 = GHC.Types.[]_closure+1;
           R2 = _sk3x::I64;
           call GHC.Show.$wshowWord_info(R3,
                                         R2) returns to ckVx, args: 8, res: 8, upd: 24;
       ckVx:
           _sk4p::P64 = R2;
           _sk4o::P64 = R1;
           Hp = Hp + 24;
           if (Hp > HpLim) goto ckVG; else goto ckVF;
       ckVG:
           HpAlloc = 24;
           goto ckVE;
       ckVE:
           R2 = _sk4p::P64;
           R1 = _sk4o::P64;
           call stg_gc_pp(R2, R1) returns to ckVx, args: 8, res: 8, upd: 24;
       ckVF:
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sk4o::P64;
           P64[Hp] = _sk4p::P64;
           _ckVz::P64 = Hp - 14;
           R3 = GHC.Types.[]_closure+1;
           R2 = _ckVz::P64;
           call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sk4t_entry() //  [R1]
         { info_tbl: [(ckVI,
                       label: sat_sk4t_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckVI:
           _sk4t::P64 = R1;
           goto ckVr;
       ckVr:
           if ((old + 0) - <highSp> < SpLim) goto ckVJ; else goto ckVK;
       ckVK:
           Hp = Hp + 48;
           if (Hp > HpLim) goto ckVM; else goto ckVL;
       ckVM:
           HpAlloc = 48;
           goto ckVJ;
       ckVJ:
           R1 = _sk4t::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckVL:
           I64[(old + 24)] = stg_upd_frame_info;
           P64[(old + 16)] = _sk4t::P64;
           _sk3x::I64 = I64[_sk4t::P64 + 16];
           I64[Hp - 40] = sat_sk4r_info;
           I64[Hp - 24] = _sk3x::I64;
           _ckVt::P64 = Hp - 40;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl14_rjVg_closure+1;
           P64[Hp] = _ckVt::P64;
           _ckVH::P64 = Hp - 14;
           R3 = _ckVH::P64;
           R2 = Main.rbTreeOpts94_closure;
           call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sk4v_entry() //  [R1]
         { info_tbl: [(ckVP,
                       label: sat_sk4v_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckVP:
           _sk4v::P64 = R1;
           goto ckVl;
       ckVl:
           if ((old + 0) - <highSp> < SpLim) goto ckVQ; else goto ckVR;
       ckVR:
           if (HpLim == 0) goto ckVQ; else goto ckVS;
       ckVQ:
           R1 = _sk4v::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckVS:
           I64[(old + 24)] = stg_upd_frame_info;
           P64[(old + 16)] = _sk4v::P64;
           _sk3m::I64 = I64[_sk4v::P64 + 16];
           _sk3x::I64 = I64[_sk4v::P64 + 24];
           I64[(young<ckVn> + 8)] = ckVn;
           R4 = GHC.Types.[]_closure+1;
           R3 = _sk3m::I64;
           R2 = 0;
           call GHC.Show.$wshowSignedInt_info(R4,
                                              R3,
                                              R2) returns to ckVn, args: 8, res: 8, upd: 24;
       ckVn:
           _sk4l::P64 = R2;
           _sk4k::P64 = R1;
           Hp = Hp + 72;
           if (Hp > HpLim) goto ckVV; else goto ckVU;
       ckVV:
           HpAlloc = 72;
           goto ckVT;
       ckVT:
           R2 = _sk4l::P64;
           R1 = _sk4k::P64;
           call stg_gc_pp(R2, R1) returns to ckVn, args: 8, res: 8, upd: 24;
       ckVU:
           I64[Hp - 64] = sat_sk4t_info;
           I64[Hp - 48] = _sk3x::I64;
           _ckVp::P64 = Hp - 64;
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = lvl14_rjVg_closure+1;
           P64[Hp - 24] = _ckVp::P64;
           _ckVN::P64 = Hp - 38;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sk4k::P64;
           P64[Hp] = _sk4l::P64;
           _ckVO::P64 = Hp - 14;
           R3 = _ckVN::P64;
           R2 = _ckVO::P64;
           call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sk4x_entry() //  [R1]
         { info_tbl: [(ckVX,
                       label: sat_sk4x_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckVX:
           _sk4x::P64 = R1;
           goto ckVh;
       ckVh:
           if ((old + 0) - <highSp> < SpLim) goto ckVY; else goto ckVZ;
       ckVZ:
           Hp = Hp + 56;
           if (Hp > HpLim) goto ckW1; else goto ckW0;
       ckW1:
           HpAlloc = 56;
           goto ckVY;
       ckVY:
           R1 = _sk4x::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckW0:
           I64[(old + 24)] = stg_upd_frame_info;
           P64[(old + 16)] = _sk4x::P64;
           _sk3m::I64 = I64[_sk4x::P64 + 16];
           _sk3x::I64 = I64[_sk4x::P64 + 24];
           I64[Hp - 48] = sat_sk4v_info;
           I64[Hp - 32] = _sk3m::I64;
           I64[Hp - 24] = _sk3x::I64;
           _ckVj::P64 = Hp - 48;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl14_rjVg_closure+1;
           P64[Hp] = _ckVj::P64;
           _ckVW::P64 = Hp - 14;
           R3 = _ckVW::P64;
           R2 = Main.rbTreeOpts79_closure;
           call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sk4z_entry() //  [R1]
         { info_tbl: [(ckW3,
                       label: sat_sk4z_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckW3:
           _sk4z::P64 = R1;
           goto ckVd;
       ckVd:
           if ((old + 0) - <highSp> < SpLim) goto ckW4; else goto ckW5;
       ckW5:
           Hp = Hp + 56;
           if (Hp > HpLim) goto ckW7; else goto ckW6;
       ckW7:
           HpAlloc = 56;
           goto ckW4;
       ckW4:
           R1 = _sk4z::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckW6:
           I64[(old + 24)] = stg_upd_frame_info;
           P64[(old + 16)] = _sk4z::P64;
           _sk33::P64 = P64[_sk4z::P64 + 16];
           _sk3m::I64 = I64[_sk4z::P64 + 24];
           _sk3x::I64 = I64[_sk4z::P64 + 32];
           I64[Hp - 48] = sat_sk4x_info;
           I64[Hp - 32] = _sk3m::I64;
           I64[Hp - 24] = _sk3x::I64;
           _ckVf::P64 = Hp - 48;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl14_rjVg_closure+1;
           P64[Hp] = _ckVf::P64;
           _ckW2::P64 = Hp - 14;
           R3 = _ckW2::P64;
           R2 = _sk33::P64;
           call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 a8_sk4i_entry() //  [R1]
         { info_tbl: [(ckW9,
                       label: a8_sk4i_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckW9:
           _sk4i::P64 = R1;
           goto ckV9;
       ckV9:
           if ((old + 0) - <highSp> < SpLim) goto ckWa; else goto ckWb;
       ckWb:
           Hp = Hp + 64;
           if (Hp > HpLim) goto ckWd; else goto ckWc;
       ckWd:
           HpAlloc = 64;
           goto ckWa;
       ckWa:
           R1 = _sk4i::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckWc:
           I64[(old + 24)] = stg_upd_frame_info;
           P64[(old + 16)] = _sk4i::P64;
           _sk33::P64 = P64[_sk4i::P64 + 16];
           _sk3m::I64 = I64[_sk4i::P64 + 24];
           _sk3x::I64 = I64[_sk4i::P64 + 32];
           I64[Hp - 56] = sat_sk4z_info;
           P64[Hp - 40] = _sk33::P64;
           I64[Hp - 32] = _sk3m::I64;
           I64[Hp - 24] = _sk3x::I64;
           _ckVb::P64 = Hp - 56;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl14_rjVg_closure+1;
           P64[Hp] = _ckVb::P64;
           _ckW8::P64 = Hp - 14;
           R3 = _ckW8::P64;
           R2 = lvl18_rjVl_closure;
           call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sk4P_entry() //  [R1]
         { info_tbl: [(ckWe,
                       label: sat_sk4P_info
                       rep:HeapRep 2 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckWe:
           _sk4P::P64 = R1;
           goto ckUY;
       ckUY:
           if ((old + 0) - <highSp> < SpLim) goto ckWf; else goto ckWg;
       ckWg:
           if (HpLim == 0) goto ckWf; else goto ckWh;
       ckWf:
           R1 = _sk4P::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckWh:
           I64[(old + 24)] = stg_upd_frame_info;
           P64[(old + 16)] = _sk4P::P64;
           _sk33::P64 = P64[_sk4P::P64 + 16];
           _sk49::P64 = P64[_sk4P::P64 + 24];
           _sk3m::I64 = I64[_sk4P::P64 + 32];
           _sk3x::I64 = I64[_sk4P::P64 + 40];
           I64[(young<ckV0> + 8)] = ckV0;
           R3 = 0;
           R2 = _sk49::P64;
           call $wgo2_rjVk_info(R3,
                                R2) returns to ckV0, args: 8, res: 8, upd: 24;
       ckV0:
           _sk4g::I64 = R1;
           Hp = Hp + 40;
           if (Hp > HpLim) goto ckWk; else goto ckWj;
       ckWk:
           HpAlloc = 40;
           goto ckWi;
       ckWi:
           R1 = _sk4g::I64;
           call stg_gc_unbx_r1(R1) returns to ckV0, args: 8, res: 8, upd: 24;
       ckWj:
           _ckV4::I64 = _sk4g::I64;
           _sk4h::I64 = _ckV4::I64;
           I64[Hp - 32] = a8_sk4i_info;
           P64[Hp - 16] = _sk33::P64;
           I64[Hp - 8] = _sk3m::I64;
           I64[Hp] = _sk3x::I64;
           _ckV7::P64 = Hp - 32;
           _ckWl::I64 = %MO_S_Ge_W64(_sk4h::I64, 0);
           _sk4B::I64 = _ckWl::I64;
           switch [0 .. 1] _sk4B::I64 {
               case 0 : goto ckWz;
               case 1 : goto ckWN;
           }
       ckWN:
           I64[(young<ckWF> + 8)] = ckWF;
           R2 = _sk4h::I64;
           call GHC.Integer.Type.smallInteger_info(R2) returns to ckWF, args: 8, res: 8, upd: 24;
       ckWF:
           _sk4J::P64 = R1;
           I64[(young<ckWJ> + 8)] = ckWJ;
           R4 = GHC.Types.[]_closure+1;
           R3 = _sk4J::P64;
           R2 = 0;
           call GHC.Show.$w$cshowsPrec1_info(R4,
                                             R3,
                                             R2) returns to ckWJ, args: 8, res: 8, upd: 24;
       ckWJ:
           _sk4M::P64 = R2;
           _sk4L::P64 = R1;
           Hp = Hp + 48;
           if (Hp > HpLim) goto ckWR; else goto ckWQ;
       ckWR:
           HpAlloc = 48;
           goto ckWP;
       ckWP:
           R2 = _sk4M::P64;
           R1 = _sk4L::P64;
           call stg_gc_pp(R2, R1) returns to ckWJ, args: 8, res: 8, upd: 24;
       ckWQ:
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = lvl14_rjVg_closure+1;
           P64[Hp - 24] = _ckV7::P64;
           _ckWL::P64 = Hp - 38;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sk4L::P64;
           P64[Hp] = _sk4M::P64;
           _ckWM::P64 = Hp - 14;
           R3 = _ckWL::P64;
           R2 = _ckWM::P64;
           call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
       ckWz:
           I64[(young<ckWq> + 8)] = ckWq;
           R2 = _sk4g::I64;
           call GHC.Integer.Type.wordToInteger_info(R2) returns to ckWq, args: 8, res: 8, upd: 24;
       ckWq:
           _sk4D::P64 = R1;
           I64[(young<ckWu> + 8)] = ckWu;
           R4 = GHC.Types.[]_closure+1;
           R3 = _sk4D::P64;
           R2 = 0;
           call GHC.Show.$w$cshowsPrec1_info(R4,
                                             R3,
                                             R2) returns to ckWu, args: 8, res: 8, upd: 24;
       ckWu:
           _sk4G::P64 = R2;
           _sk4F::P64 = R1;
           Hp = Hp + 48;
           if (Hp > HpLim) goto ckWD; else goto ckWC;
       ckWD:
           HpAlloc = 48;
           goto ckWB;
       ckWB:
           R2 = _sk4G::P64;
           R1 = _sk4F::P64;
           call stg_gc_pp(R2, R1) returns to ckWu, args: 8, res: 8, upd: 24;
       ckWC:
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = lvl14_rjVg_closure+1;
           P64[Hp - 24] = _ckV7::P64;
           _ckWw::P64 = Hp - 38;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sk4F::P64;
           P64[Hp] = _sk4G::P64;
           _ckWx::P64 = Hp - 14;
           R3 = _ckWw::P64;
           R2 = _ckWx::P64;
           call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sk4R_entry() //  [R1]
         { info_tbl: [(ckWT,
                       label: sat_sk4R_info
                       rep:HeapRep 2 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckWT:
           _sk4R::P64 = R1;
           goto ckUU;
       ckUU:
           if ((old + 0) - <highSp> < SpLim) goto ckWU; else goto ckWV;
       ckWV:
           Hp = Hp + 72;
           if (Hp > HpLim) goto ckWX; else goto ckWW;
       ckWX:
           HpAlloc = 72;
           goto ckWU;
       ckWU:
           R1 = _sk4R::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckWW:
           I64[(old + 24)] = stg_upd_frame_info;
           P64[(old + 16)] = _sk4R::P64;
           _sk33::P64 = P64[_sk4R::P64 + 16];
           _sk49::P64 = P64[_sk4R::P64 + 24];
           _sk3m::I64 = I64[_sk4R::P64 + 32];
           _sk3x::I64 = I64[_sk4R::P64 + 40];
           I64[Hp - 64] = sat_sk4P_info;
           P64[Hp - 48] = _sk33::P64;
           P64[Hp - 40] = _sk49::P64;
           I64[Hp - 32] = _sk3m::I64;
           I64[Hp - 24] = _sk3x::I64;
           _ckUW::P64 = Hp - 64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl14_rjVg_closure+1;
           P64[Hp] = _ckUW::P64;
           _ckWS::P64 = Hp - 14;
           R3 = _ckWS::P64;
           R2 = lvl17_rjVj_closure;
           call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sk4T_entry() //  [R1]
         { info_tbl: [(ckWY,
                       label: sat_sk4T_info
                       rep:HeapRep 3 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckWY:
           _sk4T::P64 = R1;
           goto ckUL;
       ckUL:
           if ((old + 0) - <highSp> < SpLim) goto ckX1; else goto ckX2;
       ckX2:
           if (HpLim == 0) goto ckX1; else goto ckX3;
       ckX1:
           R1 = _sk4T::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckX3:
           I64[(old + 24)] = stg_upd_frame_info;
           P64[(old + 16)] = _sk4T::P64;
           _sk33::P64 = P64[_sk4T::P64 + 16];
           _sk46::P64 = P64[_sk4T::P64 + 24];
           _sk49::P64 = P64[_sk4T::P64 + 32];
           _sk3m::I64 = I64[_sk4T::P64 + 40];
           _sk3x::I64 = I64[_sk4T::P64 + 48];
           I64[(young<ckUN> + 8)] = ckUN;
           R1 = _sk46::P64;
           if (R1 & 7 != 0) goto ckUN; else goto ckUO;
       ckUO:
           call (I64[R1])(R1) returns to ckUN, args: 8, res: 8, upd: 24;
       ckUN:
           _sk4d::P64 = R1;
           Hp = Hp + 72;
           if (Hp > HpLim) goto ckX6; else goto ckX5;
       ckX6:
           HpAlloc = 72;
           goto ckX4;
       ckX4:
           R1 = _sk4d::P64;
           call stg_gc_unpt_r1(R1) returns to ckUN, args: 8, res: 8, upd: 24;
       ckX5:
           _sk4e::F64 = F64[_sk4d::P64 + 7];
           I64[Hp - 64] = sat_sk4R_info;
           P64[Hp - 48] = _sk33::P64;
           P64[Hp - 40] = _sk49::P64;
           I64[Hp - 32] = _sk3m::I64;
           I64[Hp - 24] = _sk3x::I64;
           _ckUS::P64 = Hp - 64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl14_rjVg_closure+1;
           P64[Hp] = _ckUS::P64;
           _ckWZ::P64 = Hp - 14;
           I64[(young<ckX0> + 8)] = ckX0;
           D1 = _sk4e::F64;
           R3 = GHC.Show.shows18_closure;
           R2 = GHC.Float.$fShowDouble_$sshowFloat_closure+1;
           I64[(young<ckX0> + 24)] = stg_ap_p_info;
           P64[(young<ckX0> + 16)] = GHC.Types.[]_closure+1;
           call GHC.Float.$w$sshowSignedFloat_info(D1,
                                                   R3,
                                                   R2) returns to ckX0, args: 24, res: 8, upd: 24;
       ckX0:
           _sk4f::P64 = R1;
           R3 = _ckWZ::P64;
           R2 = _sk4f::P64;
           call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sk4V_entry() //  [R1]
         { info_tbl: [(ckXc,
                       label: sat_sk4V_info
                       rep:HeapRep 3 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckXc:
           _sk4V::P64 = R1;
           goto ckUH;
       ckUH:
           if ((old + 0) - <highSp> < SpLim) goto ckXd; else goto ckXe;
       ckXe:
           Hp = Hp + 80;
           if (Hp > HpLim) goto ckXg; else goto ckXf;
       ckXg:
           HpAlloc = 80;
           goto ckXd;
       ckXd:
           R1 = _sk4V::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckXf:
           I64[(old + 24)] = stg_upd_frame_info;
           P64[(old + 16)] = _sk4V::P64;
           _sk33::P64 = P64[_sk4V::P64 + 16];
           _sk46::P64 = P64[_sk4V::P64 + 24];
           _sk49::P64 = P64[_sk4V::P64 + 32];
           _sk3m::I64 = I64[_sk4V::P64 + 40];
           _sk3x::I64 = I64[_sk4V::P64 + 48];
           I64[Hp - 72] = sat_sk4T_info;
           P64[Hp - 56] = _sk33::P64;
           P64[Hp - 48] = _sk46::P64;
           P64[Hp - 40] = _sk49::P64;
           I64[Hp - 32] = _sk3m::I64;
           I64[Hp - 24] = _sk3x::I64;
           _ckUJ::P64 = Hp - 72;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl14_rjVg_closure+1;
           P64[Hp] = _ckUJ::P64;
           _ckXb::P64 = Hp - 14;
           R3 = _ckXb::P64;
           R2 = lvl16_rjVi_closure;
           call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sk4X_entry() //  [R1]
         { info_tbl: [(ckXh,
                       label: sat_sk4X_info
                       rep:HeapRep 4 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckXh:
           _sk4X::P64 = R1;
           goto ckUy;
       ckUy:
           if ((old + 0) - <highSp> < SpLim) goto ckXk; else goto ckXl;
       ckXl:
           if (HpLim == 0) goto ckXk; else goto ckXm;
       ckXk:
           R1 = _sk4X::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckXm:
           I64[(old + 24)] = stg_upd_frame_info;
           P64[(old + 16)] = _sk4X::P64;
           _sk33::P64 = P64[_sk4X::P64 + 16];
           _sk45::P64 = P64[_sk4X::P64 + 24];
           _sk46::P64 = P64[_sk4X::P64 + 32];
           _sk49::P64 = P64[_sk4X::P64 + 40];
           _sk3m::I64 = I64[_sk4X::P64 + 48];
           _sk3x::I64 = I64[_sk4X::P64 + 56];
           I64[(young<ckUA> + 8)] = ckUA;
           R1 = _sk45::P64;
           if (R1 & 7 != 0) goto ckUA; else goto ckUB;
       ckUB:
           call (I64[R1])(R1) returns to ckUA, args: 8, res: 8, upd: 24;
       ckUA:
           _sk4a::P64 = R1;
           Hp = Hp + 80;
           if (Hp > HpLim) goto ckXp; else goto ckXo;
       ckXp:
           HpAlloc = 80;
           goto ckXn;
       ckXn:
           R1 = _sk4a::P64;
           call stg_gc_unpt_r1(R1) returns to ckUA, args: 8, res: 8, upd: 24;
       ckXo:
           _sk4b::F64 = F64[_sk4a::P64 + 7];
           I64[Hp - 72] = sat_sk4V_info;
           P64[Hp - 56] = _sk33::P64;
           P64[Hp - 48] = _sk46::P64;
           P64[Hp - 40] = _sk49::P64;
           I64[Hp - 32] = _sk3m::I64;
           I64[Hp - 24] = _sk3x::I64;
           _ckUF::P64 = Hp - 72;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl14_rjVg_closure+1;
           P64[Hp] = _ckUF::P64;
           _ckXi::P64 = Hp - 14;
           I64[(young<ckXj> + 8)] = ckXj;
           D1 = _sk4b::F64;
           R3 = GHC.Show.shows18_closure;
           R2 = GHC.Float.$fShowDouble_$sshowFloat_closure+1;
           I64[(young<ckXj> + 24)] = stg_ap_p_info;
           P64[(young<ckXj> + 16)] = GHC.Types.[]_closure+1;
           call GHC.Float.$w$sshowSignedFloat_info(D1,
                                                   R3,
                                                   R2) returns to ckXj, args: 24, res: 8, upd: 24;
       ckXj:
           _sk4c::P64 = R1;
           R3 = _ckXi::P64;
           R2 = _sk4c::P64;
           call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sk4Z_entry() //  [R1]
         { info_tbl: [(ckXv,
                       label: sat_sk4Z_info
                       rep:HeapRep 4 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckXv:
           _sk4Z::P64 = R1;
           goto ckUu;
       ckUu:
           if ((old + 0) - <highSp> < SpLim) goto ckXw; else goto ckXx;
       ckXx:
           Hp = Hp + 88;
           if (Hp > HpLim) goto ckXz; else goto ckXy;
       ckXz:
           HpAlloc = 88;
           goto ckXw;
       ckXw:
           R1 = _sk4Z::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckXy:
           I64[(old + 24)] = stg_upd_frame_info;
           P64[(old + 16)] = _sk4Z::P64;
           _sk33::P64 = P64[_sk4Z::P64 + 16];
           _sk45::P64 = P64[_sk4Z::P64 + 24];
           _sk46::P64 = P64[_sk4Z::P64 + 32];
           _sk49::P64 = P64[_sk4Z::P64 + 40];
           _sk3m::I64 = I64[_sk4Z::P64 + 48];
           _sk3x::I64 = I64[_sk4Z::P64 + 56];
           I64[Hp - 80] = sat_sk4X_info;
           P64[Hp - 64] = _sk33::P64;
           P64[Hp - 56] = _sk45::P64;
           P64[Hp - 48] = _sk46::P64;
           P64[Hp - 40] = _sk49::P64;
           I64[Hp - 32] = _sk3m::I64;
           I64[Hp - 24] = _sk3x::I64;
           _ckUw::P64 = Hp - 80;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl14_rjVg_closure+1;
           P64[Hp] = _ckUw::P64;
           _ckXu::P64 = Hp - 14;
           R3 = _ckXu::P64;
           R2 = lvl15_rjVh_closure;
           call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sk51_entry() //  [R1]
         { info_tbl: [(ckY0,
                       label: sat_sk51_info
                       rep:HeapRep 4 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckY0:
           _sk51::P64 = R1;
           goto ckUq;
       ckUq:
           if ((old + 0) - <highSp> < SpLim) goto ckY1; else goto ckY2;
       ckY2:
           Hp = Hp + 88;
           if (Hp > HpLim) goto ckY4; else goto ckY3;
       ckY4:
           HpAlloc = 88;
           goto ckY1;
       ckY1:
           R1 = _sk51::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckY3:
           _sk33::P64 = P64[_sk51::P64 + 16];
           _sk45::P64 = P64[_sk51::P64 + 24];
           _sk46::P64 = P64[_sk51::P64 + 32];
           _sk49::P64 = P64[_sk51::P64 + 40];
           _sk3m::I64 = I64[_sk51::P64 + 48];
           _sk3x::I64 = I64[_sk51::P64 + 56];
           I64[Hp - 80] = sat_sk4Z_info;
           P64[Hp - 64] = _sk33::P64;
           P64[Hp - 56] = _sk45::P64;
           P64[Hp - 48] = _sk46::P64;
           P64[Hp - 40] = _sk49::P64;
           I64[Hp - 32] = _sk3m::I64;
           I64[Hp - 24] = _sk3x::I64;
           _ckUs::P64 = Hp - 80;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl14_rjVg_closure+1;
           P64[Hp] = _ckUs::P64;
           _ckXZ::P64 = Hp - 14;
           R3 = _ckXZ::P64;
           R2 = lvl13_rjVf_closure;
           call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sk5v_entry() //  [R3, R2, R1]
         { info_tbl: [(ckYm,
                       label: sat_sk5v_info
                       rep:HeapRep 1 ptrs 2 nonptrs {
                             Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckYm:
           _sk56::P64 = R3;
           _sk55::P64 = R2;
           _sk5v::P64 = R1;
           goto ckYh;
       ckYh:
           if ((old + 0) - <highSp> < SpLim) goto ckYU; else goto ckYV;
       ckYV:
           goto ckYg;
       ckYg:
           if (HpLim == 0) goto ckYU; else goto ckYW;
       ckYU:
           R3 = _sk56::P64;
           R2 = _sk55::P64;
           R1 = _sk5v::P64;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ckYW:
           _sk3D::P64 = P64[_sk5v::P64 + 5];
           _sk3v::F64 = F64[_sk5v::P64 + 13];
           _sk3x::I64 = I64[_sk5v::P64 + 21];
           I64[(young<ckYj> + 8)] = ckYj;
           R1 = _sk55::P64;
           if (R1 & 7 != 0) goto ckYj; else goto ckYk;
       ckYk:
           call (I64[R1])(R1) returns to ckYj, args: 8, res: 8, upd: 8;
       ckYj:
           _sk58::P64 = R1;
           _sk59::P64 = P64[_sk58::P64 + 7];
           I64[(young<ckYp> + 8)] = ckYp;
           R1 = _sk56::P64;
           if (R1 & 7 != 0) goto ckYp; else goto ckYq;
       ckYq:
           call (I64[R1])(R1) returns to ckYp, args: 8, res: 8, upd: 8;
       ckYp:
           _sk5a::P64 = R1;
           _sk5b::P64 = P64[_sk5a::P64 + 7];
           I64[(young<ckYu> + 8)] = ckYu;
           R1 = _sk3D::P64;
           if (R1 & 7 != 0) goto ckYu; else goto ckYv;
       ckYv:
           call (I64[R1])(R1) returns to ckYu, args: 8, res: 8, upd: 8;
       ckYu:
           _sk5c::P64 = R1;
           _sk5d::P64 = P64[_sk5c::P64 + 7];
           _sk5e::P64 = P64[_sk5c::P64 + 15];
           _sk5f::P64 = P64[_sk5c::P64 + 23];
           I64[(young<ckYz> + 8)] = ckYz;
           R1 = _sk5d::P64;
           if (R1 & 7 != 0) goto ckYz; else goto ckYA;
       ckYA:
           call (I64[R1])(R1) returns to ckYz, args: 8, res: 8, upd: 8;
       ckYz:
           _sk5g::P64 = R1;
           _sk5h::P64 = P64[_sk5g::P64 + 7];
           _sk5i::P64 = P64[_sk5g::P64 + 15];
           _sk5k::P64 = P64[_sk5g::P64 + 23];
           _sk5j::I64 = I64[_sk5g::P64 + 31];
           I64[(young<ckYE> + 8)] = ckYE;
           R1 = _sk5h::P64;
           if (R1 & 7 != 0) goto ckYE; else goto ckYF;
       ckYF:
           call (I64[R1])(R1) returns to ckYE, args: 8, res: 8, upd: 8;
       ckYE:
           _sk5l::P64 = R1;
           _sk5m::I64 = I64[_sk5l::P64 + 7];
           I64[(young<ckYJ> + 8)] = ckYJ;
           R1 = _sk5i::P64;
           if (R1 & 7 != 0) goto ckYJ; else goto ckYK;
       ckYK:
           call (I64[R1])(R1) returns to ckYJ, args: 8, res: 8, upd: 8;
       ckYJ:
           _sk5n::P64 = R1;
           _sk5o::I64 = I64[_sk5n::P64 + 7];
           I64[(young<ckYO> + 8)] = ckYO;
           R1 = _sk5e::P64;
           if (R1 & 7 != 0) goto ckYO; else goto ckYP;
       ckYP:
           call (I64[R1])(R1) returns to ckYO, args: 8, res: 8, upd: 8;
       ckYO:
           _sk5p::P64 = R1;
           _sk5q::P64 = P64[_sk5p::P64 + 7];
           I64[(young<ckYT> + 8)] = ckYT;
           R1 = _sk5f::P64;
           call stg_ap_0_fast(R1) returns to ckYT, args: 8, res: 8, upd: 8;
       ckYT:
           _sk5r::P64 = R1;
           _sk5u::P64 = P64[_sk5r::P64 + 7];
           _sk5s::I64 = I64[_sk5r::P64 + 15];
           _sk5t::I64 = I64[_sk5r::P64 + 23];
           R6 = _sk5j::I64;
           R5 = _sk5o::I64;
           R4 = _sk5m::I64;
           R3 = _sk5b::P64;
           R2 = _sk59::P64;
           P64[(old + 64)] = _sk5k::P64;
           P64[(old + 56)] = _sk5q::P64;
           I64[(old + 48)] = _sk5s::I64;
           I64[(old + 40)] = _sk5t::I64;
           P64[(old + 32)] = _sk5u::P64;
           I64[(old + 24)] = _sk3x::I64;
           F64[(old + 16)] = _sk3v::F64;
           call Main.$wa1_info(R6, R5, R4, R3, R2) args: 64, res: 0, upd: 8;
     }
 },
 sat_sk5w_entry() //  [R1]
         { info_tbl: [(ckZf,
                       label: sat_sk5w_info
                       rep:HeapRep 3 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckZf:
           _sk5w::P64 = R1;
           goto ckYc;
       ckYc:
           if ((old + 0) - <highSp> < SpLim) goto ckZg; else goto ckZh;
       ckZh:
           Hp = Hp + 32;
           if (Hp > HpLim) goto ckZj; else goto ckZi;
       ckZj:
           HpAlloc = 32;
           goto ckZg;
       ckZg:
           R1 = _sk5w::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckZi:
           I64[(old + 24)] = stg_upd_frame_info;
           P64[(old + 16)] = _sk5w::P64;
           _sk3A::P64 = P64[_sk5w::P64 + 16];
           _sk3D::P64 = P64[_sk5w::P64 + 24];
           _sk41::P64 = P64[_sk5w::P64 + 32];
           _sk3v::F64 = F64[_sk5w::P64 + 40];
           _sk3x::I64 = I64[_sk5w::P64 + 48];
           I64[Hp - 24] = sat_sk5v_info;
           P64[Hp - 16] = _sk3D::P64;
           F64[Hp - 8] = _sk3v::F64;
           I64[Hp] = _sk3x::I64;
           _ckYe::P64 = Hp - 21;
           R4 = _sk3A::P64;
           R3 = _sk41::P64;
           R2 = _ckYe::P64;
           call GHC.List.zipWith_info(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sk5M_entry() //  [R3, R2, R1]
         { info_tbl: [(ckZy,
                       label: sat_sk5M_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 3 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckZy:
           _sk5G::P64 = R3;
           _sk5F::P64 = R2;
           _sk5M::P64 = R1;
           goto ckZt;
       ckZt:
           if ((old + 0) - <highSp> < SpLim) goto ckZC; else goto ckZD;
       ckZD:
           goto ckZs;
       ckZs:
           if (HpLim == 0) goto ckZC; else goto ckZE;
       ckZC:
           R3 = _sk5G::P64;
           R2 = _sk5F::P64;
           R1 = _sk5M::P64;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ckZE:
           _sk3v::F64 = F64[_sk5M::P64 + 5];
           _sk3x::I64 = I64[_sk5M::P64 + 13];
           I64[(young<ckZv> + 8)] = ckZv;
           R1 = _sk5F::P64;
           if (R1 & 7 != 0) goto ckZv; else goto ckZw;
       ckZw:
           call (I64[R1])(R1) returns to ckZv, args: 8, res: 8, upd: 8;
       ckZv:
           _sk5I::P64 = R1;
           _sk5J::P64 = P64[_sk5I::P64 + 7];
           I64[(young<ckZB> + 8)] = ckZB;
           R1 = _sk5G::P64;
           if (R1 & 7 != 0) goto ckZB; else goto ckZG;
       ckZG:
           call (I64[R1])(R1) returns to ckZB, args: 8, res: 8, upd: 8;
       ckZB:
           _sk5K::P64 = R1;
           _sk5L::P64 = P64[_sk5K::P64 + 7];
           D1 = _sk3v::F64;
           R4 = _sk3x::I64;
           R3 = _sk5L::P64;
           R2 = _sk5J::P64;
           call Main.$wa_info(D1, R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sk5N_entry() //  [R1]
         { info_tbl: [(ckZV,
                       label: sat_sk5N_info
                       rep:HeapRep 2 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckZV:
           _sk5N::P64 = R1;
           goto ckZo;
       ckZo:
           if ((old + 0) - <highSp> < SpLim) goto ckZW; else goto ckZX;
       ckZX:
           Hp = Hp + 24;
           if (Hp > HpLim) goto ckZZ; else goto ckZY;
       ckZZ:
           HpAlloc = 24;
           goto ckZW;
       ckZW:
           R1 = _sk5N::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckZY:
           I64[(old + 24)] = stg_upd_frame_info;
           P64[(old + 16)] = _sk5N::P64;
           _sk3A::P64 = P64[_sk5N::P64 + 16];
           _sk41::P64 = P64[_sk5N::P64 + 24];
           _sk3v::F64 = F64[_sk5N::P64 + 32];
           _sk3x::I64 = I64[_sk5N::P64 + 40];
           I64[Hp - 16] = sat_sk5M_info;
           F64[Hp - 8] = _sk3v::F64;
           I64[Hp] = _sk3x::I64;
           _ckZq::P64 = Hp - 13;
           R4 = _sk3A::P64;
           R3 = _sk41::P64;
           R2 = _ckZq::P64;
           call GHC.List.zipWith_info(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sk6c_entry() //  [R1]
         { info_tbl: [(cl0g,
                       label: sat_sk6c_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cl0g:
           _sk6c::P64 = R1;
           goto cl0c;
       cl0c:
           if ((old + 0) - <highSp> < SpLim) goto cl0h; else goto cl0i;
       cl0i:
           if (HpLim == 0) goto cl0h; else goto cl0o;
       cl0h:
           R1 = _sk6c::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cl0o:
           I64[(old + 24)] = stg_upd_frame_info;
           P64[(old + 16)] = _sk6c::P64;
           _sk65::P64 = P64[_sk6c::P64 + 16];
           _sk3m::I64 = I64[_sk6c::P64 + 24];
           _sk66::I64 = I64[_sk6c::P64 + 32];
           _cl0e::I64 = _sk66::I64 == _sk3m::I64;
           _sk69::I64 = _cl0e::I64;
           switch [0 .. 1] _sk69::I64 {
               case 0 : goto cl0m;
               case 1 : goto cl0n;
           }
       cl0n:
           R1 = []_closure+1;
           call (P64[(old + 24)])(R1) args: 24, res: 0, upd: 24;
       cl0m:
           _cl0q::I64 = _sk66::I64 + 1;
           _sk6b::I64 = _cl0q::I64;
           R2 = _sk6b::I64;
           R1 = _sk65::P64;
           call go_sk65_info(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 go_sk65_entry() //  [R2, R1]
         { info_tbl: [(cl0t,
                       label: go_sk65_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cl0t:
           _sk66::I64 = R2;
           _sk65::P64 = R1;
           goto cl08;
       cl08:
           if ((old + 0) - <highSp> < SpLim) goto cl0x; else goto cl0y;
       cl0y:
           goto cl07;
       cl07:
           Hp = Hp + 80;
           if (Hp > HpLim) goto cl0A; else goto cl0z;
       cl0A:
           HpAlloc = 80;
           goto cl0x;
       cl0x:
           R2 = _sk66::I64;
           R1 = _sk65::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cl0z:
           _sk3m::I64 = I64[_sk65::P64 + 7];
           I64[Hp - 72] = sat_sk6c_info;
           P64[Hp - 56] = _sk65::P64;
           I64[Hp - 48] = _sk3m::I64;
           I64[Hp - 40] = _sk66::I64;
           _cl0a::P64 = Hp - 72;
           _cl0r::I64 = _sk66::I64;
           _sk67::I64 = _cl0r::I64;
           I64[Hp - 32] = GHC.Word.W64#_con_info;
           I64[Hp - 24] = _sk67::I64;
           _cl0v::P64 = Hp - 31;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _cl0v::P64;
           P64[Hp] = _cl0a::P64;
           _cl0w::P64 = Hp - 14;
           R1 = _cl0w::P64;
           call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Main.main1_entry() //  []
         { info_tbl: [(cl0B,
                       label: Main.main1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cl0B:
           goto ckRy;
       ckRy:
           if ((old + 0) - <highSp> < SpLim) goto cl0C; else goto cl0D;
       cl0D:
           goto ckRx;
       ckRx:
           if (HpLim == 0) goto cl0C; else goto cl0E;
       cl0C:
           R1 = Main.main1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cl0E:
           I64[(young<ckRA> + 8)] = ckRA;
           call System.Environment.getProgName1_info() returns to ckRA, args: 8, res: 8, upd: 8;
       ckRA:
           _sk33::P64 = R1;
           I64[(young<ckRC> + 8)] = ckRC;
           call System.Environment.getArgs1_info() returns to ckRC, args: 8, res: 8, upd: 8;
       ckRC:
           _sk36::P64 = R1;
           Hp = Hp + 88;
           if (Hp > HpLim) goto cl0I; else goto cl0H;
       cl0I:
           HpAlloc = 88;
           goto cl0G;
       cl0G:
           R1 = _sk36::P64;
           call stg_gc_unpt_r1(R1) returns to ckRC, args: 8, res: 8, upd: 8;
       cl0H:
           I64[Hp - 80] = sat_sk37_info;
           P64[Hp - 64] = _sk33::P64;
           _ckRE::P64 = Hp - 80;
           I64[Hp - 56] = Options.Applicative.Types.ParserInfo_con_info;
           P64[Hp - 48] = lvl20_rjVp_closure+3;
           P64[Hp - 40] = GHC.Types.True_closure+2;
           P64[Hp - 32] = lvl22_rjVr_closure;
           P64[Hp - 24] = _ckRE::P64;
           P64[Hp - 16] = GHC.Base.Nothing_closure+1;
           P64[Hp - 8] = Options.Applicative.Builder.info1_closure;
           P64[Hp] = GHC.Types.True_closure+2;
           _ckRM::P64 = Hp - 55;
           I64[(young<ckRN> + 8)] = ckRN;
           R4 = _sk36::P64;
           R3 = _ckRM::P64;
           R2 = Options.Applicative.Builder.prefs1_closure;
           call Options.Applicative.Extra.execParserPure_info(R4,
                                                              R3,
                                                              R2) returns to ckRN, args: 8, res: 8, upd: 8;
       ckRN:
           _sk39::P64 = R1;
           I64[(young<ckRR> + 8)] = ckRR;
           R2 = _sk39::P64;
           call Options.Applicative.Extra.customExecParser2_info(R2) returns to ckRR, args: 8, res: 8, upd: 8;
       ckRR:
           _sk3c::P64 = R1;
           I64[(young<ckRT> + 8)] = ckRT;
           R1 = _sk3c::P64;
           if (R1 & 7 != 0) goto ckRT; else goto ckRU;
       ckRU:
           call (I64[R1])(R1) returns to ckRT, args: 8, res: 8, upd: 8;
       ckRT:
           _sk3d::P64 = R1;
           _sk3e::P64 = P64[_sk3d::P64 + 7];
           _sk3f::P64 = P64[_sk3d::P64 + 15];
           _sk3g::P64 = P64[_sk3d::P64 + 23];
           _sk3h::P64 = P64[_sk3d::P64 + 31];
           _sk3i::P64 = P64[_sk3d::P64 + 39];
           _sk3j::P64 = P64[_sk3d::P64 + 47];
           _sk3k::P64 = P64[_sk3d::P64 + 55];
           I64[(young<ckRY> + 8)] = ckRY;
           R1 = _sk3f::P64;
           if (R1 & 7 != 0) goto ckRY; else goto ckRZ;
       ckRZ:
           call (I64[R1])(R1) returns to ckRY, args: 8, res: 8, upd: 8;
       ckRY:
           _sk3l::P64 = R1;
           _sk3m::I64 = I64[_sk3l::P64 + 7];
           _ckS3::I64 = _sk3m::I64;
           _sk3o::I64 = _ckS3::I64;
           _ckS6::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_sk3o::I64));
           _sk3p::I64 = _ckS6::I64;
           _ckS9::I64 = setNumCapabilities;
           _ckSa::I64 = _sk3p::I64;
           I64[(young<ckSb> + 8)] = ckSb;
           foreign call "ccall" arg hints:  []  result hints:  [] (_ckS9::I64)(...) returns to ckSb args: ([_ckSa::I64]) ress: ([])ret_args: 8ret_off: 8;
       ckSb:
           I64[(young<ckSd> + 8)] = ckSd;
           R1 = _sk3k::P64;
           if (R1 & 7 != 0) goto ckSd; else goto ckSe;
       ckSe:
           call (I64[R1])(R1) returns to ckSd, args: 8, res: 8, upd: 8;
       ckSd:
           _sk3s::P64 = R1;
           _sk3t::I64 = I64[_sk3s::P64 + 7];
           I64[(young<ckSi> + 8)] = ckSi;
           R1 = _sk3j::P64;
           if (R1 & 7 != 0) goto ckSi; else goto ckSj;
       ckSj:
           call (I64[R1])(R1) returns to ckSi, args: 8, res: 8, upd: 8;
       ckSi:
           _sk3u::P64 = R1;
           _sk3v::F64 = F64[_sk3u::P64 + 7];
           I64[(young<ckSn> + 8)] = ckSn;
           R1 = _sk3e::P64;
           if (R1 & 7 != 0) goto ckSn; else goto ckSo;
       ckSo:
           call (I64[R1])(R1) returns to ckSn, args: 8, res: 8, upd: 8;
       ckSn:
           _sk3w::P64 = R1;
           Hp = Hp + 16;
           if (Hp > HpLim) goto cl0S; else goto cl0R;
       cl0S:
           HpAlloc = 16;
           goto cl0Q;
       cl0Q:
           R1 = _sk3w::P64;
           call stg_gc_unpt_r1(R1) returns to ckSn, args: 8, res: 8, upd: 8;
       cl0R:
           _sk3x::I64 = I64[_sk3w::P64 + 7];
           _cl00::I64 = %MO_S_Gt_W64(1, _sk3m::I64);
           _sk63::I64 = _cl00::I64;
           switch [0 .. 1] _sk63::I64 {
               case 0 : goto cl29;
               case 1 : goto cl2h;
           }
       cl2h:
           Hp = Hp - 16;
           _sk3A::P64 = GHC.Types.[]_closure+1;
           goto sk3y;
       cl29:
           _cl05::P64 = Hp - 7;
           I64[Hp - 8] = go_sk65_info;
           I64[Hp] = _sk3m::I64;
           I64[(young<cl27> + 8)] = cl27;
           R2 = 1;
           R1 = _cl05::P64;
           call go_sk65_info(R2, R1) returns to cl27, args: 8, res: 8, upd: 8;
       cl27:
           _sk6d::P64 = R1;
           I64[(young<cl2d> + 8)] = cl2d;
           R2 = _sk6d::P64;
           call Main.initGens2_info(R2) returns to cl2d, args: 8, res: 8, upd: 8;
       cl2d:
           _sk6g::P64 = R1;
           _sk3A::P64 = _sk6g::P64;
           goto sk3y;
       sk3y:
           goto ckSv;
       ckSv:
           if (HpLim == 0) goto cl0T; else goto cl0U;
       cl0T:
           I64[(young<ckSu> + 8)] = ckSu;
           R1 = _sk3A::P64;
           call stg_gc_unpt_r1(R1) returns to ckSu, args: 8, res: 8, upd: 8;
       ckSu:
           _sk3A::P64 = R1;
           goto ckSv;
       cl0U:
           I64[(young<ckSx> + 8)] = ckSx;
           R1 = SkipList.newSL2_closure+1;
           call stg_norec_atomically#(R1) returns to ckSx, args: 8, res: 8, upd: 8;
       ckSx:
           _sk3D::P64 = R1;
           Hp = Hp + 16;
           if (Hp > HpLim) goto cl0X; else goto cl0W;
       cl0X:
           HpAlloc = 16;
           goto cl0V;
       cl0V:
           R1 = _sk3D::P64;
           call stg_gc_unpt_r1(R1) returns to ckSx, args: 8, res: 8, upd: 8;
       cl0W:
           _ckSz::P64 = Hp - 6;
           I64[Hp - 8] = a7_sk3E_info;
           P64[Hp] = _sk3D::P64;
           I64[(young<ckU1> + 8)] = ckU1;
           R4 = _sk3x::I64;
           R3 = 2;
           R2 = 0;
           call GHC.Enum.$w$cenumFromThenTo_info(R4,
                                                 R3,
                                                 R2) returns to ckU1, args: 8, res: 8, upd: 8;
       ckU1:
           _sk3V::P64 = R1;
           I64[(young<ckU5> + 8)] = ckU5;
           R2 = _sk3V::P64;
           R1 = _ckSz::P64;
           call a7_sk3E_info(R2, R1) returns to ckU5, args: 8, res: 8, upd: 8;
       ckU5:
           _sk3Y::P64 = R1;
           _cl1N::I64 = %MO_S_Lt_W64(0, _sk3m::I64);
           _sk5U::I64 = _cl1N::I64;
           switch [0 .. 1] _sk5U::I64 {
               case 0 : goto cl1U;
               case 1 : goto cl1Z;
           }
       cl1Z:
           I64[(young<cl1Y> + 8)] = cl1Y;
           R2 = _sk3m::I64;
           call $wxs_rjVo_info(R2) returns to cl1Y, args: 8, res: 8, upd: 8;
       cl1Y:
           _sk5Z::P64 = R1;
           I64[(young<cl23> + 8)] = cl23;
           R2 = _sk5Z::P64;
           call Control.Monad.replicateM4_info(R2) returns to cl23, args: 8, res: 8, upd: 8;
       cl23:
           _sk62::P64 = R1;
           _sk41::P64 = _sk62::P64;
           goto sk3Z;
       cl1U:
           I64[(young<cl1S> + 8)] = cl1S;
           R2 = GHC.Types.[]_closure+1;
           call Control.Monad.replicateM4_info(R2) returns to cl1S, args: 8, res: 8, upd: 8;
       cl1S:
           _sk5Y::P64 = R1;
           _sk41::P64 = _sk5Y::P64;
           goto sk3Z;
       sk3Z:
           goto ckUa;
       ckUa:
           if (HpLim == 0) goto cl10; else goto cl11;
       cl10:
           I64[(young<ckU9> + 8)] = ckU9;
           R1 = _sk41::P64;
           call stg_gc_unpt_r1(R1) returns to ckU9, args: 8, res: 8, upd: 8;
       ckU9:
           _sk41::P64 = R1;
           goto ckUa;
       cl11:
           I64[(young<ckUc> + 8)] = ckUc;
           R1 = _sk3g::P64;
           if (R1 & 7 != 0) goto ckUc; else goto ckUd;
       ckUd:
           call (I64[R1])(R1) returns to ckUc, args: 8, res: 8, upd: 8;
       ckUc:
           _sk42::P64 = R1;
           _cl2i::P64 = _sk42::P64 & 7;
           switch [1 .. 2] _cl2i::P64 {
               case 1 : goto cl19;
               case 2 : goto cl1M;
           }
       cl1M:
           R1 = GHC.Tuple.()_closure+1;
           call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
       cl19:
           I64[(young<ckY5> + 8)] = ckY5;
           R1 = _sk3h::P64;
           if (R1 & 7 != 0) goto ckY5; else goto ckY6;
       ckY6:
           call (I64[R1])(R1) returns to ckY5, args: 8, res: 8, upd: 8;
       ckY5:
           _sk52::P64 = R1;
           _cl2j::P64 = _sk52::P64 & 7;
           switch [1 .. 2] _cl2j::P64 {
               case 1 : goto cl1i;
               case 2 : goto cl1z;
           }
       cl1z:
           Hp = Hp + 64;
           if (Hp > HpLim) goto cl1C; else goto cl1B;
       cl1C:
           HpAlloc = 64;
           goto cl1A;
       cl1A:
           R1 = _sk52::P64;
           call stg_gc_unpt_r1(R1) returns to ckY5, args: 8, res: 8, upd: 8;
       cl1B:
           I64[Hp - 56] = sat_sk5N_info;
           P64[Hp - 40] = _sk3A::P64;
           P64[Hp - 32] = _sk41::P64;
           F64[Hp - 24] = _sk3v::F64;
           I64[Hp - 16] = _sk3x::I64;
           _ckZm::P64 = Hp - 56;
           _cl1s::I64 = _sk3t::I64 * 1000;
           _sk5D::I64 = _cl1s::I64;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sk5D::I64;
           _cl1v::P64 = Hp - 7;
           I64[(young<cl1w> + 8)] = cl1w;
           R3 = _ckZm::P64;
           R2 = _cl1v::P64;
           call Throughput.throughputMain1_info(R3,
                                                R2) returns to cl1w, args: 8, res: 8, upd: 8;
       cl1w:
           _sk5Q::P64 = R1;
           I64[(young<cl1y> + 8)] = cl1y;
           R1 = _sk5Q::P64;
           if (R1 & 7 != 0) goto cl1y; else goto cl1E;
       cl1E:
           call (I64[R1])(R1) returns to cl1y, args: 8, res: 8, upd: 8;
       cl1y:
           _sk5R::P64 = R1;
           _sk5S::P64 = P64[_sk5R::P64 + 7];
           _sk5T::P64 = P64[_sk5R::P64 + 15];
           _sk46::P64 = _sk5T::P64;
           _sk45::P64 = _sk5S::P64;
           goto sk43;
       cl1i:
           Hp = Hp + 72;
           if (Hp > HpLim) goto cl1l; else goto cl1k;
       cl1l:
           HpAlloc = 72;
           goto cl1j;
       cl1j:
           R1 = _sk52::P64;
           call stg_gc_unpt_r1(R1) returns to ckY5, args: 8, res: 8, upd: 8;
       cl1k:
           I64[Hp - 64] = sat_sk5w_info;
           P64[Hp - 48] = _sk3A::P64;
           P64[Hp - 40] = _sk3D::P64;
           P64[Hp - 32] = _sk41::P64;
           F64[Hp - 24] = _sk3v::F64;
           I64[Hp - 16] = _sk3x::I64;
           _ckYa::P64 = Hp - 64;
           _cl1a::I64 = _sk3t::I64 * 1000;
           _sk53::I64 = _cl1a::I64;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sk53::I64;
           _cl1d::P64 = Hp - 7;
           I64[(young<cl1e> + 8)] = cl1e;
           R3 = _ckYa::P64;
           R2 = _cl1d::P64;
           call Throughput.throughputMain1_info(R3,
                                                R2) returns to cl1e, args: 8, res: 8, upd: 8;
       cl1e:
           _sk5z::P64 = R1;
           I64[(young<cl1g> + 8)] = cl1g;
           R1 = _sk5z::P64;
           if (R1 & 7 != 0) goto cl1g; else goto cl1n;
       cl1n:
           call (I64[R1])(R1) returns to cl1g, args: 8, res: 8, upd: 8;
       cl1g:
           _sk5A::P64 = R1;
           _sk5B::P64 = P64[_sk5A::P64 + 7];
           _sk5C::P64 = P64[_sk5A::P64 + 15];
           _sk46::P64 = _sk5C::P64;
           _sk45::P64 = _sk5B::P64;
           goto sk43;
       sk43:
           goto ckUk;
       ckUk:
           if (HpLim == 0) goto cl13; else goto cl14;
       cl13:
           I64[(young<ckUj> + 8)] = ckUj;
           R2 = _sk46::P64;
           R1 = _sk45::P64;
           call stg_gc_pp(R2, R1) returns to ckUj, args: 8, res: 8, upd: 8;
       ckUj:
           _sk46::P64 = R2;
           _sk45::P64 = R1;
           goto ckUk;
       cl14:
           I64[(young<ckUm> + 8)] = ckUm;
           R2 = _sk41::P64;
           call a5_rjVe_info(R2) returns to ckUm, args: 8, res: 8, upd: 8;
       ckUm:
           _sk49::P64 = R1;
           Hp = Hp + 64;
           if (Hp > HpLim) goto cl17; else goto cl16;
       cl17:
           HpAlloc = 64;
           goto cl15;
       cl15:
           R1 = _sk49::P64;
           call stg_gc_unpt_r1(R1) returns to ckUm, args: 8, res: 8, upd: 8;
       cl16:
           I64[Hp - 56] = sat_sk51_info;
           P64[Hp - 40] = _sk33::P64;
           P64[Hp - 32] = _sk45::P64;
           P64[Hp - 24] = _sk46::P64;
           P64[Hp - 16] = _sk49::P64;
           I64[Hp - 8] = _sk3m::I64;
           I64[Hp] = _sk3x::I64;
           _ckUo::P64 = Hp - 56;
           R4 = GHC.Types.True_closure+2;
           R3 = _ckUo::P64;
           R2 = GHC.IO.Handle.FD.stdout_closure;
           call GHC.IO.Handle.Text.hPutStr2_info(R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:54.409054 UTC

{offset
  ckRI:
      _sk37::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckRJ; else goto ckRK;
  ckRK:
      if (HpLim == 0) goto ckRJ; else goto ckRL;
  ckRJ:
      R1 = _sk37::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckRL:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sk37::P64;
      _sk33::P64 = P64[_sk37::P64 + 16];
      R4 = _sk33::P64;
      R3 = GHC.Base.Nothing_closure+1;
      R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
      call Data.OldList.wordsFB_info(R4,
                                     R3,
                                     R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:54.410136 UTC

{offset
  ckRI:
      _sk37::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckRJ; else goto ckRK;
  ckRK:
      if (HpLim == 0) goto ckRJ; else goto ckRL;
  ckRJ:
      R1 = _sk37::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckRL:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sk37::P64;
      _sk33::P64 = P64[_sk37::P64 + 16];
      R4 = _sk33::P64;
      R3 = GHC.Base.Nothing_closure+1;
      R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
      call Data.OldList.wordsFB_info(R4,
                                     R3,
                                     R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:54.411113 UTC

{offset
  ckRI:
      _sk37::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckRJ; else goto ckRK;
  ckRK:
      if (HpLim == 0) goto ckRJ; else goto ckRL;
  ckRJ:
      R1 = _sk37::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckRL:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sk37::P64;
      _sk33::P64 = P64[_sk37::P64 + 16];
      R4 = _sk33::P64;
      R3 = GHC.Base.Nothing_closure+1;
      R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
      call Data.OldList.wordsFB_info(R4,
                                     R3,
                                     R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:54.412134 UTC

{offset
  ckRI:
      _sk37::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto ckRJ; else goto ckRK;
  ckRK:
      if (HpLim == 0) goto ckRJ; else goto ckRL;
  ckRJ:
      R1 = _sk37::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckRL:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _sk37::P64;
      _sk33::P64 = P64[_sk37::P64 + 16];
      R4 = _sk33::P64;
      R3 = GHC.Base.Nothing_closure+1;
      R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
      Sp = Sp - 16;
      call Data.OldList.wordsFB_info(R4,
                                     R3,
                                     R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:54.413127 UTC

{offset
  ckRI:
      _sk37::P64 = R1;
      if ((Sp + -16) < SpLim) goto ckRJ; else goto ckRK;
  ckRK:
      if (HpLim == 0) goto ckRJ; else goto ckRL;
  ckRJ:
      R1 = _sk37::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckRL:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _sk37::P64;
      R4 = P64[_sk37::P64 + 16];
      R3 = GHC.Base.Nothing_closure+1;
      R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
      Sp = Sp - 16;
      call Data.OldList.wordsFB_info(R4,
                                     R3,
                                     R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:54.414249 UTC

[(ckRI, {Options.Applicative.Help.Chunk.paragraph1_closure}),
 (ckRJ, {}),
 (ckRK, {Options.Applicative.Help.Chunk.paragraph1_closure}),
 (ckRL, {Options.Applicative.Help.Chunk.paragraph1_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:54.414684 UTC

sat_sk37_entry() //  [R1]
        { info_tbl: [(ckRI,
                      label: sat_sk37_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckRI:
          _sk37::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckRJ; else goto ckRK;
      ckRK:
          if (HpLim == 0) goto ckRJ; else goto ckRL;
      ckRJ:
          R1 = _sk37::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckRL:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _sk37::P64;
          R4 = P64[_sk37::P64 + 16];
          R3 = GHC.Base.Nothing_closure+1;
          R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
          Sp = Sp - 16;
          call Data.OldList.wordsFB_info(R4,
                                         R3,
                                         R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:54.415898 UTC

sat_sk37_entry() //  [R1]
        { info_tbl: [(ckRI,
                      label: sat_sk37_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckRI:
          _sk37::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckRJ; else goto ckRK;
      ckRK:
          if (HpLim == 0) goto ckRJ; else goto ckRL;
      ckRJ:
          R1 = _sk37::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckRL:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _sk37::P64;
          R4 = P64[_sk37::P64 + 16];
          R3 = GHC.Base.Nothing_closure+1;
          R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
          Sp = Sp - 16;
          call Data.OldList.wordsFB_info(R4,
                                         R3,
                                         R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:54.417145 UTC

{offset
  ckSS:
      _sk3R::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckSW; else goto ckSX;
  ckSX:
      if (HpLim == 0) goto ckSW; else goto ckSY;
  ckSW:
      R1 = _sk3R::P64;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  ckSY:
      _sk3D::P64 = P64[_sk3R::P64 + 7];
      _sk3I::P64 = P64[_sk3R::P64 + 15];
      I64[(young<ckSP> + 8)] = ckSP;
      R1 = _sk3D::P64;
      if (R1 & 7 != 0) goto ckSP; else goto ckSQ;
  ckSQ:
      call (I64[R1])(R1) returns to ckSP, args: 8, res: 8, upd: 8;
  ckSP:
      _sk3L::P64 = R1;
      _sk3M::P64 = P64[_sk3L::P64 + 7];
      _sk3N::P64 = P64[_sk3L::P64 + 15];
      _sk3O::P64 = P64[_sk3L::P64 + 23];
      I64[(young<ckSV> + 8)] = ckSV;
      R1 = _sk3N::P64;
      if (R1 & 7 != 0) goto ckSV; else goto ckT0;
  ckT0:
      call (I64[R1])(R1) returns to ckSV, args: 8, res: 8, upd: 8;
  ckSV:
      _sk3P::P64 = R1;
      _sk3Q::P64 = P64[_sk3P::P64 + 7];
      R6 = _sk3I::P64;
      R5 = _sk3O::P64;
      R4 = _sk3Q::P64;
      R3 = _sk3M::P64;
      R2 = GHC.Classes.$fOrdWord_closure;
      P64[(old + 16)] = GHC.Tuple.()_closure+1;
      call SkipList.$wa4_info(R6,
                              R5,
                              R4,
                              R3,
                              R2) args: 16, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:54.419121 UTC

{offset
  ckSS:
      _sk3R::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckSW; else goto ckSX;
  ckSX:
      if (HpLim == 0) goto ckSW; else goto ckSY;
  ckSW:
      R1 = _sk3R::P64;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  ckSY:
      _sk3D::P64 = P64[_sk3R::P64 + 7];
      _sk3I::P64 = P64[_sk3R::P64 + 15];
      I64[(young<ckSP> + 8)] = ckSP;
      R1 = _sk3D::P64;
      if (R1 & 7 != 0) goto ckSP; else goto ckSQ;
  ckSQ:
      call (I64[R1])(R1) returns to ckSP, args: 8, res: 8, upd: 8;
  ckSP:
      _sk3L::P64 = R1;
      _sk3M::P64 = P64[_sk3L::P64 + 7];
      _sk3N::P64 = P64[_sk3L::P64 + 15];
      _sk3O::P64 = P64[_sk3L::P64 + 23];
      I64[(young<ckSV> + 8)] = ckSV;
      R1 = _sk3N::P64;
      if (R1 & 7 != 0) goto ckSV; else goto ckT0;
  ckT0:
      call (I64[R1])(R1) returns to ckSV, args: 8, res: 8, upd: 8;
  ckSV:
      _sk3P::P64 = R1;
      _sk3Q::P64 = P64[_sk3P::P64 + 7];
      R6 = _sk3I::P64;
      R5 = _sk3O::P64;
      R4 = _sk3Q::P64;
      R3 = _sk3M::P64;
      R2 = GHC.Classes.$fOrdWord_closure;
      P64[(old + 16)] = GHC.Tuple.()_closure+1;
      call SkipList.$wa4_info(R6,
                              R5,
                              R4,
                              R3,
                              R2) args: 16, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:54.421101 UTC

{offset
  ckSS:
      _sk3R::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckSW; else goto ckSX;
  ckSX:
      if (HpLim == 0) goto ckSW; else goto ckSY;
  ckSW:
      R1 = _sk3R::P64;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  ckSY:
      _sk3D::P64 = P64[_sk3R::P64 + 7];
      _sk3I::P64 = P64[_sk3R::P64 + 15];
      I64[(young<ckSP> + 8)] = ckSP;
      R1 = _sk3D::P64;
      if (R1 & 7 != 0) goto ckSP; else goto ckSQ;
  ckSQ:
      call (I64[R1])(R1) returns to ckSP, args: 8, res: 8, upd: 8;
  ckSP:
      _sk3L::P64 = R1;
      _sk3M::P64 = P64[_sk3L::P64 + 7];
      _sk3N::P64 = P64[_sk3L::P64 + 15];
      _sk3O::P64 = P64[_sk3L::P64 + 23];
      I64[(young<ckSV> + 8)] = ckSV;
      R1 = _sk3N::P64;
      if (R1 & 7 != 0) goto ckSV; else goto ckT0;
  ckT0:
      call (I64[R1])(R1) returns to ckSV, args: 8, res: 8, upd: 8;
  ckSV:
      _sk3P::P64 = R1;
      _sk3Q::P64 = P64[_sk3P::P64 + 7];
      R6 = _sk3I::P64;
      R5 = _sk3O::P64;
      R4 = _sk3Q::P64;
      R3 = _sk3M::P64;
      R2 = GHC.Classes.$fOrdWord_closure;
      P64[(old + 16)] = GHC.Tuple.()_closure+1;
      call SkipList.$wa4_info(R6,
                              R5,
                              R4,
                              R3,
                              R2) args: 16, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:54.423312 UTC

{offset
  ckSS:
      _sk3R::P64 = R1;
      if ((Sp + 8) - 40 < SpLim) goto ckSW; else goto ckSX;
  ckSX:
      if (HpLim == 0) goto ckSW; else goto ckSY;
  ckSW:
      R1 = _sk3R::P64;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  ckSY:
      _sk3D::P64 = P64[_sk3R::P64 + 7];
      _sk3I::P64 = P64[_sk3R::P64 + 15];
      I64[Sp - 16] = ckSP;
      R1 = _sk3D::P64;
      P64[Sp - 8] = _sk3I::P64;
      Sp = Sp - 16;
      if (R1 & 7 != 0) goto ckSP; else goto ckSQ;
  ckSQ:
      call (I64[R1])(R1) returns to ckSP, args: 8, res: 8, upd: 8;
  ckSP:
      _sk3I::P64 = P64[Sp + 8];
      _sk3L::P64 = R1;
      _sk3M::P64 = P64[_sk3L::P64 + 7];
      _sk3N::P64 = P64[_sk3L::P64 + 15];
      _sk3O::P64 = P64[_sk3L::P64 + 23];
      I64[Sp - 16] = ckSV;
      R1 = _sk3N::P64;
      P64[Sp - 8] = _sk3O::P64;
      P64[Sp] = _sk3M::P64;
      Sp = Sp - 16;
      if (R1 & 7 != 0) goto ckSV; else goto ckT0;
  ckT0:
      call (I64[R1])(R1) returns to ckSV, args: 8, res: 8, upd: 8;
  ckSV:
      _sk3I::P64 = P64[Sp + 24];
      _sk3M::P64 = P64[Sp + 16];
      _sk3O::P64 = P64[Sp + 8];
      _sk3P::P64 = R1;
      _sk3Q::P64 = P64[_sk3P::P64 + 7];
      R6 = _sk3I::P64;
      R5 = _sk3O::P64;
      R4 = _sk3Q::P64;
      R3 = _sk3M::P64;
      R2 = GHC.Classes.$fOrdWord_closure;
      P64[Sp + 24] = GHC.Tuple.()_closure+1;
      Sp = Sp + 24;
      call SkipList.$wa4_info(R6,
                              R5,
                              R4,
                              R3,
                              R2) args: 16, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:54.425748 UTC

{offset
  ckSS:
      _sk3R::P64 = R1;
      if ((Sp + -32) < SpLim) goto ckSW; else goto ckSX;
  ckSX:
      if (HpLim == 0) goto ckSW; else goto ckSY;
  ckSW:
      R1 = _sk3R::P64;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  ckSY:
      I64[Sp - 16] = ckSP;
      R1 = P64[_sk3R::P64 + 7];
      P64[Sp - 8] = P64[_sk3R::P64 + 15];
      Sp = Sp - 16;
      if (R1 & 7 != 0) goto ckSP; else goto ckSQ;
  ckSQ:
      call (I64[R1])(R1) returns to ckSP, args: 8, res: 8, upd: 8;
  ckSP:
      I64[Sp - 16] = ckSV;
      _sk3M::P64 = P64[R1 + 7];
      _sk3O::P64 = P64[R1 + 23];
      R1 = P64[R1 + 15];
      P64[Sp - 8] = _sk3O::P64;
      P64[Sp] = _sk3M::P64;
      Sp = Sp - 16;
      if (R1 & 7 != 0) goto ckSV; else goto ckT0;
  ckT0:
      call (I64[R1])(R1) returns to ckSV, args: 8, res: 8, upd: 8;
  ckSV:
      R6 = P64[Sp + 24];
      R5 = P64[Sp + 8];
      R4 = P64[R1 + 7];
      R3 = P64[Sp + 16];
      R2 = GHC.Classes.$fOrdWord_closure;
      P64[Sp + 24] = GHC.Tuple.()_closure+1;
      Sp = Sp + 24;
      call SkipList.$wa4_info(R6,
                              R5,
                              R4,
                              R3,
                              R2) args: 16, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:54.428069 UTC

[(ckSP, {SkipList.$wa4_closure}), (ckSQ, {SkipList.$wa4_closure}),
 (ckSS, {SkipList.$wa4_closure}), (ckSV, {SkipList.$wa4_closure}),
 (ckSW, {}), (ckSX, {SkipList.$wa4_closure}),
 (ckSY, {SkipList.$wa4_closure}), (ckT0, {SkipList.$wa4_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:54.428721 UTC

sat_sk3R_entry() //  [R1]
        { info_tbl: [(ckSP,
                      label: block_ckSP_info
                      rep:StackRep [False]),
                     (ckSS,
                      label: sat_sk3R_info
                      rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} }),
                     (ckSV,
                      label: block_ckSV_info
                      rep:StackRep [False, False, False])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckSS:
          _sk3R::P64 = R1;
          if ((Sp + -32) < SpLim) goto ckSW; else goto ckSX;
      ckSX:
          if (HpLim == 0) goto ckSW; else goto ckSY;
      ckSW:
          R1 = _sk3R::P64;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
      ckSY:
          I64[Sp - 16] = ckSP;
          R1 = P64[_sk3R::P64 + 7];
          P64[Sp - 8] = P64[_sk3R::P64 + 15];
          Sp = Sp - 16;
          if (R1 & 7 != 0) goto ckSP; else goto ckSQ;
      ckSQ:
          call (I64[R1])(R1) returns to ckSP, args: 8, res: 8, upd: 8;
      ckSP:
          I64[Sp - 16] = ckSV;
          _sk3M::P64 = P64[R1 + 7];
          _sk3O::P64 = P64[R1 + 23];
          R1 = P64[R1 + 15];
          P64[Sp - 8] = _sk3O::P64;
          P64[Sp] = _sk3M::P64;
          Sp = Sp - 16;
          if (R1 & 7 != 0) goto ckSV; else goto ckT0;
      ckT0:
          call (I64[R1])(R1) returns to ckSV, args: 8, res: 8, upd: 8;
      ckSV:
          R6 = P64[Sp + 24];
          R5 = P64[Sp + 8];
          R4 = P64[R1 + 7];
          R3 = P64[Sp + 16];
          R2 = GHC.Classes.$fOrdWord_closure;
          P64[Sp + 24] = GHC.Tuple.()_closure+1;
          Sp = Sp + 24;
          call SkipList.$wa4_info(R6,
                                  R5,
                                  R4,
                                  R3,
                                  R2) args: 16, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:54.431285 UTC

sat_sk3R_entry() //  [R1]
        { info_tbl: [(ckSP,
                      label: block_ckSP_info
                      rep:StackRep [False]),
                     (ckSS,
                      label: sat_sk3R_info
                      rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} }),
                     (ckSV,
                      label: block_ckSV_info
                      rep:StackRep [False, False, False])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckSS:
          _sk3R::P64 = R1;
          if ((Sp + -32) < SpLim) goto ckSW; else goto ckSX;
      ckSX:
          if (HpLim == 0) goto ckSW; else goto ckSY;
      ckSW:
          R1 = _sk3R::P64;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
      ckSY:
          I64[Sp - 16] = ckSP;
          R1 = P64[_sk3R::P64 + 7];
          P64[Sp - 8] = P64[_sk3R::P64 + 15];
          Sp = Sp - 16;
          if (R1 & 7 != 0) goto ckSP; else goto ckSQ;
      ckSQ:
          call (I64[R1])(R1) returns to ckSP, args: 8, res: 8, upd: 8;
      ckSP:
          I64[Sp - 16] = ckSV;
          _sk3M::P64 = P64[R1 + 7];
          _sk3O::P64 = P64[R1 + 23];
          R1 = P64[R1 + 15];
          P64[Sp - 8] = _sk3O::P64;
          P64[Sp] = _sk3M::P64;
          Sp = Sp - 16;
          if (R1 & 7 != 0) goto ckSV; else goto ckT0;
      ckT0:
          call (I64[R1])(R1) returns to ckSV, args: 8, res: 8, upd: 8;
      ckSV:
          R6 = P64[Sp + 24];
          R5 = P64[Sp + 8];
          R4 = P64[R1 + 7];
          R3 = P64[Sp + 16];
          R2 = GHC.Classes.$fOrdWord_closure;
          P64[Sp + 24] = GHC.Tuple.()_closure+1;
          Sp = Sp + 24;
          call SkipList.$wa4_info(R6,
                                  R5,
                                  R4,
                                  R3,
                                  R2) args: 16, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:54.433799 UTC

{offset
  ckTP:
      _sk3F::P64 = R2;
      _sk3E::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckTQ; else goto ckTR;
  ckTR:
      if (HpLim == 0) goto ckTQ; else goto ckTS;
  ckTQ:
      R2 = _sk3F::P64;
      R1 = _sk3E::P64;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckTS:
      _sk3D::P64 = P64[_sk3E::P64 + 6];
      I64[(young<ckSE> + 8)] = ckSE;
      R1 = _sk3F::P64;
      if (R1 & 7 != 0) goto ckSE; else goto ckSF;
  ckSF:
      call (I64[R1])(R1) returns to ckSE, args: 8, res: 8, upd: 8;
  ckSE:
      _sk3H::P64 = R1;
      _ckTO::P64 = _sk3H::P64 & 7;
      switch [1 .. 2] _ckTO::P64 {
          case 1 : goto ckTM;
          case 2 : goto ckTN;
      }
  ckTN:
      Hp = Hp + 24;
      if (Hp > HpLim) goto ckTY; else goto ckTX;
  ckTY:
      HpAlloc = 24;
      R1 = _sk3H::P64;
      call stg_gc_unpt_r1(R1) returns to ckSE, args: 8, res: 8, upd: 8;
  ckTX:
      _sk3I::P64 = P64[_sk3H::P64 + 6];
      _sk3J::P64 = P64[_sk3H::P64 + 14];
      I64[Hp - 16] = sat_sk3R_info;
      P64[Hp - 8] = _sk3D::P64;
      P64[Hp] = _sk3I::P64;
      _ckSK::P64 = Hp - 15;
      I64[(young<ckTV> + 8)] = ckTV;
      R1 = _ckSK::P64;
      call stg_norec_atomically#(R1) returns to ckTV, args: 8, res: 8, upd: 8;
  ckTV:
      _sk3U::P64 = R1;
      R2 = _sk3J::P64;
      R1 = _sk3E::P64;
      call a7_sk3E_info(R2, R1) args: 8, res: 0, upd: 8;
  ckTM:
      R1 = GHC.Tuple.()_closure+1;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:54.436187 UTC

{offset
  ckTP:
      _sk3F::P64 = R2;
      _sk3E::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckTQ; else goto ckTR;
  ckTR:
      if (HpLim == 0) goto ckTQ; else goto ckTS;
  ckTQ:
      R2 = _sk3F::P64;
      R1 = _sk3E::P64;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckTS:
      _sk3D::P64 = P64[_sk3E::P64 + 6];
      I64[(young<ckSE> + 8)] = ckSE;
      R1 = _sk3F::P64;
      if (R1 & 7 != 0) goto ckSE; else goto ckSF;
  ckSF:
      call (I64[R1])(R1) returns to ckSE, args: 8, res: 8, upd: 8;
  ckSE:
      _sk3H::P64 = R1;
      _ckTO::P64 = _sk3H::P64 & 7;
      switch [1 .. 2] _ckTO::P64 {
          case 1 : goto ckTM;
          case 2 : goto ckTN;
      }
  ckTN:
      Hp = Hp + 24;
      if (Hp > HpLim) goto ckTY; else goto ckTX;
  ckTY:
      HpAlloc = 24;
      R1 = _sk3H::P64;
      call stg_gc_unpt_r1(R1) returns to ckSE, args: 8, res: 8, upd: 8;
  ckTX:
      _sk3I::P64 = P64[_sk3H::P64 + 6];
      _sk3J::P64 = P64[_sk3H::P64 + 14];
      I64[Hp - 16] = sat_sk3R_info;
      P64[Hp - 8] = _sk3D::P64;
      P64[Hp] = _sk3I::P64;
      _ckSK::P64 = Hp - 15;
      I64[(young<ckTV> + 8)] = ckTV;
      R1 = _ckSK::P64;
      call stg_norec_atomically#(R1) returns to ckTV, args: 8, res: 8, upd: 8;
  ckTV:
      _sk3U::P64 = R1;
      R2 = _sk3J::P64;
      R1 = _sk3E::P64;
      call a7_sk3E_info(R2, R1) args: 8, res: 0, upd: 8;
  ckTM:
      R1 = GHC.Tuple.()_closure+1;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:54.438623 UTC

{offset
  ckTP:
      _sk3F::P64 = R2;
      _sk3E::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckTQ; else goto ckTR;
  ckTR:
      if (HpLim == 0) goto ckTQ; else goto ckTS;
  ckTQ:
      R2 = _sk3F::P64;
      R1 = _sk3E::P64;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckTS:
      _sk3D::P64 = P64[_sk3E::P64 + 6];
      I64[(young<ckSE> + 8)] = ckSE;
      R1 = _sk3F::P64;
      if (R1 & 7 != 0) goto ckSE; else goto ckSF;
  ckSF:
      call (I64[R1])(R1) returns to ckSE, args: 8, res: 8, upd: 8;
  ckSE:
      _sk3H::P64 = R1;
      _ckTO::P64 = _sk3H::P64 & 7;
      if (_ckTO::P64 != 1) goto ckTN; else goto ckTM;
  ckTN:
      Hp = Hp + 24;
      if (Hp > HpLim) goto ckTY; else goto ckTX;
  ckTY:
      HpAlloc = 24;
      R1 = _sk3H::P64;
      call stg_gc_unpt_r1(R1) returns to ckSE, args: 8, res: 8, upd: 8;
  ckTX:
      _sk3I::P64 = P64[_sk3H::P64 + 6];
      _sk3J::P64 = P64[_sk3H::P64 + 14];
      I64[Hp - 16] = sat_sk3R_info;
      P64[Hp - 8] = _sk3D::P64;
      P64[Hp] = _sk3I::P64;
      _ckSK::P64 = Hp - 15;
      I64[(young<ckTV> + 8)] = ckTV;
      R1 = _ckSK::P64;
      call stg_norec_atomically#(R1) returns to ckTV, args: 8, res: 8, upd: 8;
  ckTV:
      _sk3U::P64 = R1;
      R2 = _sk3J::P64;
      R1 = _sk3E::P64;
      call a7_sk3E_info(R2, R1) args: 8, res: 0, upd: 8;
  ckTM:
      R1 = GHC.Tuple.()_closure+1;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:54.441291 UTC

{offset
  ckTP:
      _sk3F::P64 = R2;
      _sk3E::P64 = R1;
      if ((Sp + 8) - 32 < SpLim) goto ckTQ; else goto ckTR;
  ckTR:
      if (HpLim == 0) goto ckTQ; else goto ckTS;
  ckTQ:
      R2 = _sk3F::P64;
      R1 = _sk3E::P64;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckTS:
      _sk3D::P64 = P64[_sk3E::P64 + 6];
      I64[Sp - 24] = ckSE;
      R1 = _sk3F::P64;
      P64[Sp - 16] = _sk3D::P64;
      P64[Sp - 8] = _sk3E::P64;
      Sp = Sp - 24;
      if (R1 & 7 != 0) goto ckSE; else goto ckSF;
  ckSF:
      call (I64[R1])(R1) returns to ckSE, args: 8, res: 8, upd: 8;
  ckSE:
      _sk3D::P64 = P64[Sp + 8];
      _sk3E::P64 = P64[Sp + 16];
      _sk3H::P64 = R1;
      _ckTO::P64 = _sk3H::P64 & 7;
      if (_ckTO::P64 != 1) goto ckTN; else goto ckTM;
  ckTN:
      Hp = Hp + 24;
      if (Hp > HpLim) goto ckTY; else goto ckTX;
  ckTY:
      HpAlloc = 24;
      R1 = _sk3H::P64;
      call stg_gc_unpt_r1(R1) returns to ckSE, args: 8, res: 8, upd: 8;
  ckTX:
      _sk3I::P64 = P64[_sk3H::P64 + 6];
      _sk3J::P64 = P64[_sk3H::P64 + 14];
      I64[Hp - 16] = sat_sk3R_info;
      P64[Hp - 8] = _sk3D::P64;
      P64[Hp] = _sk3I::P64;
      _ckSK::P64 = Hp - 15;
      I64[Sp] = ckTV;
      R1 = _ckSK::P64;
      P64[Sp + 8] = _sk3J::P64;
      call stg_norec_atomically#(R1) returns to ckTV, args: 8, res: 8, upd: 8;
  ckTV:
      _sk3E::P64 = P64[Sp + 16];
      _sk3J::P64 = P64[Sp + 8];
      _sk3U::P64 = R1;
      R2 = _sk3J::P64;
      R1 = _sk3E::P64;
      Sp = Sp + 24;
      call a7_sk3E_info(R2, R1) args: 8, res: 0, upd: 8;
  ckTM:
      R1 = GHC.Tuple.()_closure+1;
      Sp = Sp + 24;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:54.444088 UTC

{offset
  ckTP:
      _sk3F::P64 = R2;
      _sk3E::P64 = R1;
      if ((Sp + -24) < SpLim) goto ckTQ; else goto ckTR;
  ckTR:
      if (HpLim == 0) goto ckTQ; else goto ckTS;
  ckTQ:
      R2 = _sk3F::P64;
      R1 = _sk3E::P64;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  ckTS:
      I64[Sp - 24] = ckSE;
      R1 = _sk3F::P64;
      P64[Sp - 16] = P64[_sk3E::P64 + 6];
      P64[Sp - 8] = _sk3E::P64;
      Sp = Sp - 24;
      if (R1 & 7 != 0) goto ckSE; else goto ckSF;
  ckSF:
      call (I64[R1])(R1) returns to ckSE, args: 8, res: 8, upd: 8;
  ckSE:
      if (R1 & 7 != 1) goto ckTN; else goto ckTM;
  ckTN:
      Hp = Hp + 24;
      if (Hp > HpLim) goto ckTY; else goto ckTX;
  ckTY:
      HpAlloc = 24;
      R1 = R1;
      call stg_gc_unpt_r1(R1) returns to ckSE, args: 8, res: 8, upd: 8;
  ckTX:
      _sk3I::P64 = P64[R1 + 6];
      _sk3J::P64 = P64[R1 + 14];
      I64[Hp - 16] = sat_sk3R_info;
      P64[Hp - 8] = P64[Sp + 8];
      P64[Hp] = _sk3I::P64;
      I64[Sp] = ckTV;
      R1 = Hp - 15;
      P64[Sp + 8] = _sk3J::P64;
      call stg_norec_atomically#(R1) returns to ckTV, args: 8, res: 8, upd: 8;
  ckTV:
      R2 = P64[Sp + 8];
      R1 = P64[Sp + 16];
      Sp = Sp + 24;
      call a7_sk3E_info(R2, R1) args: 8, res: 0, upd: 8;
  ckTM:
      R1 = GHC.Tuple.()_closure+1;
      Sp = Sp + 24;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:54.447456 UTC

[(ckSE, {a7_sk3E_closure, sat_sk3R_closure}),
 (ckSF, {a7_sk3E_closure, sat_sk3R_closure}), (ckTM, {}),
 (ckTN, {a7_sk3E_closure, sat_sk3R_closure}),
 (ckTP, {a7_sk3E_closure, sat_sk3R_closure}), (ckTQ, {}),
 (ckTR, {a7_sk3E_closure, sat_sk3R_closure}),
 (ckTS, {a7_sk3E_closure, sat_sk3R_closure}),
 (ckTV, {a7_sk3E_closure}),
 (ckTX, {a7_sk3E_closure, sat_sk3R_closure}),
 (ckTY, {a7_sk3E_closure, sat_sk3R_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:54.448509 UTC

a7_sk3E_entry() //  [R2, R1]
        { info_tbl: [(ckSE,
                      label: block_ckSE_info
                      rep:StackRep [False, False]),
                     (ckTP,
                      label: a7_sk3E_info
                      rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} }),
                     (ckTV,
                      label: block_ckTV_info
                      rep:StackRep [False, False])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckTP:
          _sk3F::P64 = R2;
          _sk3E::P64 = R1;
          if ((Sp + -24) < SpLim) goto ckTQ; else goto ckTR;
      ckTR:
          if (HpLim == 0) goto ckTQ; else goto ckTS;
      ckTQ:
          R2 = _sk3F::P64;
          R1 = _sk3E::P64;
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
      ckTS:
          I64[Sp - 24] = ckSE;
          R1 = _sk3F::P64;
          P64[Sp - 16] = P64[_sk3E::P64 + 6];
          P64[Sp - 8] = _sk3E::P64;
          Sp = Sp - 24;
          if (R1 & 7 != 0) goto ckSE; else goto ckSF;
      ckSF:
          call (I64[R1])(R1) returns to ckSE, args: 8, res: 8, upd: 8;
      ckSE:
          if (R1 & 7 != 1) goto ckTN; else goto ckTM;
      ckTN:
          Hp = Hp + 24;
          if (Hp > HpLim) goto ckTY; else goto ckTX;
      ckTY:
          HpAlloc = 24;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to ckSE, args: 8, res: 8, upd: 8;
      ckTX:
          _sk3I::P64 = P64[R1 + 6];
          _sk3J::P64 = P64[R1 + 14];
          I64[Hp - 16] = sat_sk3R_info;
          P64[Hp - 8] = P64[Sp + 8];
          P64[Hp] = _sk3I::P64;
          I64[Sp] = ckTV;
          R1 = Hp - 15;
          P64[Sp + 8] = _sk3J::P64;
          call stg_norec_atomically#(R1) returns to ckTV, args: 8, res: 8, upd: 8;
      ckTV:
          R2 = P64[Sp + 8];
          R1 = P64[Sp + 16];
          Sp = Sp + 24;
          call a7_sk3E_info(R2, R1) args: 8, res: 0, upd: 8;
      ckTM:
          R1 = GHC.Tuple.()_closure+1;
          Sp = Sp + 24;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:54.451375 UTC

a7_sk3E_entry() //  [R2, R1]
        { info_tbl: [(ckSE,
                      label: block_ckSE_info
                      rep:StackRep [False, False]),
                     (ckTP,
                      label: a7_sk3E_info
                      rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} }),
                     (ckTV,
                      label: block_ckTV_info
                      rep:StackRep [False, False])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckTP:
          _sk3F::P64 = R2;
          _sk3E::P64 = R1;
          if ((Sp + -24) < SpLim) goto ckTQ; else goto ckTR;
      ckTR:
          if (HpLim == 0) goto ckTQ; else goto ckTS;
      ckTQ:
          R2 = _sk3F::P64;
          R1 = _sk3E::P64;
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
      ckTS:
          I64[Sp - 24] = ckSE;
          R1 = _sk3F::P64;
          P64[Sp - 16] = P64[_sk3E::P64 + 6];
          P64[Sp - 8] = _sk3E::P64;
          Sp = Sp - 24;
          if (R1 & 7 != 0) goto ckSE; else goto ckSF;
      ckSF:
          call (I64[R1])(R1) returns to ckSE, args: 8, res: 8, upd: 8;
      ckSE:
          if (R1 & 7 != 1) goto ckTN; else goto ckTM;
      ckTN:
          Hp = Hp + 24;
          if (Hp > HpLim) goto ckTY; else goto ckTX;
      ckTY:
          HpAlloc = 24;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to ckSE, args: 8, res: 8, upd: 8;
      ckTX:
          _sk3I::P64 = P64[R1 + 6];
          _sk3J::P64 = P64[R1 + 14];
          I64[Hp - 16] = sat_sk3R_info;
          P64[Hp - 8] = P64[Sp + 8];
          P64[Hp] = _sk3I::P64;
          I64[Sp] = ckTV;
          R1 = Hp - 15;
          P64[Sp + 8] = _sk3J::P64;
          call stg_norec_atomically#(R1) returns to ckTV, args: 8, res: 8, upd: 8;
      ckTV:
          R2 = P64[Sp + 8];
          R1 = P64[Sp + 16];
          Sp = Sp + 24;
          call a7_sk3E_info(R2, R1) args: 8, res: 0, upd: 8;
      ckTM:
          R1 = GHC.Tuple.()_closure+1;
          Sp = Sp + 24;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:54.454253 UTC

{offset
  ckVA:
      _sk4r::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckVB; else goto ckVC;
  ckVC:
      if (HpLim == 0) goto ckVB; else goto ckVD;
  ckVB:
      R1 = _sk4r::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckVD:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sk4r::P64;
      _sk3x::I64 = I64[_sk4r::P64 + 16];
      I64[(young<ckVx> + 8)] = ckVx;
      R3 = GHC.Types.[]_closure+1;
      R2 = _sk3x::I64;
      call GHC.Show.$wshowWord_info(R3,
                                    R2) returns to ckVx, args: 8, res: 8, upd: 24;
  ckVx:
      _sk4p::P64 = R2;
      _sk4o::P64 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto ckVG; else goto ckVF;
  ckVG:
      HpAlloc = 24;
      R2 = _sk4p::P64;
      R1 = _sk4o::P64;
      call stg_gc_pp(R2, R1) returns to ckVx, args: 8, res: 8, upd: 24;
  ckVF:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _sk4o::P64;
      P64[Hp] = _sk4p::P64;
      _ckVz::P64 = Hp - 14;
      R3 = GHC.Types.[]_closure+1;
      R2 = _ckVz::P64;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:54.456002 UTC

{offset
  ckVA:
      _sk4r::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckVB; else goto ckVC;
  ckVC:
      if (HpLim == 0) goto ckVB; else goto ckVD;
  ckVB:
      R1 = _sk4r::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckVD:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sk4r::P64;
      _sk3x::I64 = I64[_sk4r::P64 + 16];
      I64[(young<ckVx> + 8)] = ckVx;
      R3 = GHC.Types.[]_closure+1;
      R2 = _sk3x::I64;
      call GHC.Show.$wshowWord_info(R3,
                                    R2) returns to ckVx, args: 8, res: 8, upd: 24;
  ckVx:
      _sk4p::P64 = R2;
      _sk4o::P64 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto ckVG; else goto ckVF;
  ckVG:
      HpAlloc = 24;
      R2 = _sk4p::P64;
      R1 = _sk4o::P64;
      call stg_gc_pp(R2, R1) returns to ckVx, args: 8, res: 8, upd: 24;
  ckVF:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _sk4o::P64;
      P64[Hp] = _sk4p::P64;
      _ckVz::P64 = Hp - 14;
      R3 = GHC.Types.[]_closure+1;
      R2 = _ckVz::P64;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:54.457781 UTC

{offset
  ckVA:
      _sk4r::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckVB; else goto ckVC;
  ckVC:
      if (HpLim == 0) goto ckVB; else goto ckVD;
  ckVB:
      R1 = _sk4r::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckVD:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sk4r::P64;
      _sk3x::I64 = I64[_sk4r::P64 + 16];
      I64[(young<ckVx> + 8)] = ckVx;
      R3 = GHC.Types.[]_closure+1;
      R2 = _sk3x::I64;
      call GHC.Show.$wshowWord_info(R3,
                                    R2) returns to ckVx, args: 8, res: 8, upd: 24;
  ckVx:
      _sk4p::P64 = R2;
      _sk4o::P64 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto ckVG; else goto ckVF;
  ckVG:
      HpAlloc = 24;
      R2 = _sk4p::P64;
      R1 = _sk4o::P64;
      call stg_gc_pp(R2, R1) returns to ckVx, args: 8, res: 8, upd: 24;
  ckVF:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _sk4o::P64;
      P64[Hp] = _sk4p::P64;
      _ckVz::P64 = Hp - 14;
      R3 = GHC.Types.[]_closure+1;
      R2 = _ckVz::P64;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:54.459826 UTC

{offset
  ckVA:
      _sk4r::P64 = R1;
      if ((Sp + 8) - 32 < SpLim) goto ckVB; else goto ckVC;
  ckVC:
      if (HpLim == 0) goto ckVB; else goto ckVD;
  ckVB:
      R1 = _sk4r::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckVD:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _sk4r::P64;
      _sk3x::I64 = I64[_sk4r::P64 + 16];
      I64[Sp - 24] = ckVx;
      R3 = GHC.Types.[]_closure+1;
      R2 = _sk3x::I64;
      Sp = Sp - 24;
      call GHC.Show.$wshowWord_info(R3,
                                    R2) returns to ckVx, args: 8, res: 8, upd: 24;
  ckVx:
      _sk4p::P64 = R2;
      _sk4o::P64 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto ckVG; else goto ckVF;
  ckVG:
      HpAlloc = 24;
      R2 = _sk4p::P64;
      R1 = _sk4o::P64;
      call stg_gc_pp(R2, R1) returns to ckVx, args: 8, res: 8, upd: 24;
  ckVF:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _sk4o::P64;
      P64[Hp] = _sk4p::P64;
      _ckVz::P64 = Hp - 14;
      R3 = GHC.Types.[]_closure+1;
      R2 = _ckVz::P64;
      Sp = Sp + 8;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:54.461601 UTC

{offset
  ckVA:
      _sk4r::P64 = R1;
      if ((Sp + -24) < SpLim) goto ckVB; else goto ckVC;
  ckVC:
      if (HpLim == 0) goto ckVB; else goto ckVD;
  ckVB:
      R1 = _sk4r::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckVD:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _sk4r::P64;
      I64[Sp - 24] = ckVx;
      R3 = GHC.Types.[]_closure+1;
      R2 = I64[_sk4r::P64 + 16];
      Sp = Sp - 24;
      call GHC.Show.$wshowWord_info(R3,
                                    R2) returns to ckVx, args: 8, res: 8, upd: 24;
  ckVx:
      Hp = Hp + 24;
      if (Hp > HpLim) goto ckVG; else goto ckVF;
  ckVG:
      HpAlloc = 24;
      R2 = R2;
      R1 = R1;
      call stg_gc_pp(R2, R1) returns to ckVx, args: 8, res: 8, upd: 24;
  ckVF:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = R1;
      P64[Hp] = R2;
      R3 = GHC.Types.[]_closure+1;
      R2 = Hp - 14;
      Sp = Sp + 8;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:54.463447 UTC

[(ckVx, {}), (ckVA, {}), (ckVB, {}), (ckVC, {}), (ckVD, {}),
 (ckVF, {}), (ckVG, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:54.463867 UTC

sat_sk4r_entry() //  [R1]
        { info_tbl: [(ckVx,
                      label: block_ckVx_info
                      rep:StackRep []),
                     (ckVA,
                      label: sat_sk4r_info
                      rep:HeapRep 1 nonptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckVA:
          _sk4r::P64 = R1;
          if ((Sp + -24) < SpLim) goto ckVB; else goto ckVC;
      ckVC:
          if (HpLim == 0) goto ckVB; else goto ckVD;
      ckVB:
          R1 = _sk4r::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckVD:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _sk4r::P64;
          I64[Sp - 24] = ckVx;
          R3 = GHC.Types.[]_closure+1;
          R2 = I64[_sk4r::P64 + 16];
          Sp = Sp - 24;
          call GHC.Show.$wshowWord_info(R3,
                                        R2) returns to ckVx, args: 8, res: 8, upd: 24;
      ckVx:
          Hp = Hp + 24;
          if (Hp > HpLim) goto ckVG; else goto ckVF;
      ckVG:
          HpAlloc = 24;
          R2 = R2;
          R1 = R1;
          call stg_gc_pp(R2, R1) returns to ckVx, args: 8, res: 8, upd: 24;
      ckVF:
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = R1;
          P64[Hp] = R2;
          R3 = GHC.Types.[]_closure+1;
          R2 = Hp - 14;
          Sp = Sp + 8;
          call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:54.465844 UTC

sat_sk4r_entry() //  [R1]
        { info_tbl: [(ckVx,
                      label: block_ckVx_info
                      rep:StackRep []),
                     (ckVA,
                      label: sat_sk4r_info
                      rep:HeapRep 1 nonptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckVA:
          _sk4r::P64 = R1;
          if ((Sp + -24) < SpLim) goto ckVB; else goto ckVC;
      ckVC:
          if (HpLim == 0) goto ckVB; else goto ckVD;
      ckVB:
          R1 = _sk4r::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckVD:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _sk4r::P64;
          I64[Sp - 24] = ckVx;
          R3 = GHC.Types.[]_closure+1;
          R2 = I64[_sk4r::P64 + 16];
          Sp = Sp - 24;
          call GHC.Show.$wshowWord_info(R3,
                                        R2) returns to ckVx, args: 8, res: 8, upd: 24;
      ckVx:
          Hp = Hp + 24;
          if (Hp > HpLim) goto ckVG; else goto ckVF;
      ckVG:
          HpAlloc = 24;
          R2 = R2;
          R1 = R1;
          call stg_gc_pp(R2, R1) returns to ckVx, args: 8, res: 8, upd: 24;
      ckVF:
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = R1;
          P64[Hp] = R2;
          R3 = GHC.Types.[]_closure+1;
          R2 = Hp - 14;
          Sp = Sp + 8;
          call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:54.467821 UTC

{offset
  ckVI:
      _sk4t::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckVJ; else goto ckVK;
  ckVK:
      Hp = Hp + 48;
      if (Hp > HpLim) goto ckVM; else goto ckVL;
  ckVM:
      HpAlloc = 48;
      goto ckVJ;
  ckVJ:
      R1 = _sk4t::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckVL:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sk4t::P64;
      _sk3x::I64 = I64[_sk4t::P64 + 16];
      I64[Hp - 40] = sat_sk4r_info;
      I64[Hp - 24] = _sk3x::I64;
      _ckVt::P64 = Hp - 40;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = lvl14_rjVg_closure+1;
      P64[Hp] = _ckVt::P64;
      _ckVH::P64 = Hp - 14;
      R3 = _ckVH::P64;
      R2 = Main.rbTreeOpts94_closure;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:54.469171 UTC

{offset
  ckVI:
      _sk4t::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckVJ; else goto ckVK;
  ckVK:
      Hp = Hp + 48;
      if (Hp > HpLim) goto ckVM; else goto ckVL;
  ckVM:
      HpAlloc = 48;
      goto ckVJ;
  ckVJ:
      R1 = _sk4t::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckVL:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sk4t::P64;
      _sk3x::I64 = I64[_sk4t::P64 + 16];
      I64[Hp - 40] = sat_sk4r_info;
      I64[Hp - 24] = _sk3x::I64;
      _ckVt::P64 = Hp - 40;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = lvl14_rjVg_closure+1;
      P64[Hp] = _ckVt::P64;
      _ckVH::P64 = Hp - 14;
      R3 = _ckVH::P64;
      R2 = Main.rbTreeOpts94_closure;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:54.470511 UTC

{offset
  ckVI:
      _sk4t::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckVJ; else goto ckVK;
  ckVK:
      Hp = Hp + 48;
      if (Hp > HpLim) goto ckVM; else goto ckVL;
  ckVM:
      HpAlloc = 48;
      goto ckVJ;
  ckVJ:
      R1 = _sk4t::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckVL:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sk4t::P64;
      _sk3x::I64 = I64[_sk4t::P64 + 16];
      I64[Hp - 40] = sat_sk4r_info;
      I64[Hp - 24] = _sk3x::I64;
      _ckVt::P64 = Hp - 40;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = lvl14_rjVg_closure+1;
      P64[Hp] = _ckVt::P64;
      _ckVH::P64 = Hp - 14;
      R3 = _ckVH::P64;
      R2 = Main.rbTreeOpts94_closure;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:54.471904 UTC

{offset
  ckVI:
      _sk4t::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto ckVJ; else goto ckVK;
  ckVK:
      Hp = Hp + 48;
      if (Hp > HpLim) goto ckVM; else goto ckVL;
  ckVM:
      HpAlloc = 48;
      goto ckVJ;
  ckVJ:
      R1 = _sk4t::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckVL:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _sk4t::P64;
      _sk3x::I64 = I64[_sk4t::P64 + 16];
      I64[Hp - 40] = sat_sk4r_info;
      I64[Hp - 24] = _sk3x::I64;
      _ckVt::P64 = Hp - 40;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = lvl14_rjVg_closure+1;
      P64[Hp] = _ckVt::P64;
      _ckVH::P64 = Hp - 14;
      R3 = _ckVH::P64;
      R2 = Main.rbTreeOpts94_closure;
      Sp = Sp - 16;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:54.473262 UTC

{offset
  ckVI:
      _sk4t::P64 = R1;
      if ((Sp + -16) < SpLim) goto ckVJ; else goto ckVK;
  ckVK:
      Hp = Hp + 48;
      if (Hp > HpLim) goto ckVM; else goto ckVL;
  ckVM:
      HpAlloc = 48;
      goto ckVJ;
  ckVJ:
      R1 = _sk4t::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckVL:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _sk4t::P64;
      _sk3x::I64 = I64[_sk4t::P64 + 16];
      I64[Hp - 40] = sat_sk4r_info;
      I64[Hp - 24] = _sk3x::I64;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = lvl14_rjVg_closure+1;
      P64[Hp] = Hp - 40;
      R3 = Hp - 14;
      R2 = Main.rbTreeOpts94_closure;
      Sp = Sp - 16;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:54.474681 UTC

[(ckVI, {Main.rbTreeOpts94_closure, sat_sk4r_closure}), (ckVJ, {}),
 (ckVK, {Main.rbTreeOpts94_closure, sat_sk4r_closure}),
 (ckVL, {Main.rbTreeOpts94_closure, sat_sk4r_closure}), (ckVM, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:54.475206 UTC

sat_sk4t_entry() //  [R1]
        { info_tbl: [(ckVI,
                      label: sat_sk4t_info
                      rep:HeapRep 1 nonptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckVI:
          _sk4t::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckVJ; else goto ckVK;
      ckVK:
          Hp = Hp + 48;
          if (Hp > HpLim) goto ckVM; else goto ckVL;
      ckVM:
          HpAlloc = 48;
          goto ckVJ;
      ckVJ:
          R1 = _sk4t::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckVL:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _sk4t::P64;
          _sk3x::I64 = I64[_sk4t::P64 + 16];
          I64[Hp - 40] = sat_sk4r_info;
          I64[Hp - 24] = _sk3x::I64;
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = lvl14_rjVg_closure+1;
          P64[Hp] = Hp - 40;
          R3 = Hp - 14;
          R2 = Main.rbTreeOpts94_closure;
          Sp = Sp - 16;
          call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:54.476742 UTC

sat_sk4t_entry() //  [R1]
        { info_tbl: [(ckVI,
                      label: sat_sk4t_info
                      rep:HeapRep 1 nonptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckVI:
          _sk4t::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckVJ; else goto ckVK;
      ckVK:
          Hp = Hp + 48;
          if (Hp > HpLim) goto ckVM; else goto ckVL;
      ckVM:
          HpAlloc = 48;
          goto ckVJ;
      ckVJ:
          R1 = _sk4t::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckVL:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _sk4t::P64;
          _sk3x::I64 = I64[_sk4t::P64 + 16];
          I64[Hp - 40] = sat_sk4r_info;
          I64[Hp - 24] = _sk3x::I64;
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = lvl14_rjVg_closure+1;
          P64[Hp] = Hp - 40;
          R3 = Hp - 14;
          R2 = Main.rbTreeOpts94_closure;
          Sp = Sp - 16;
          call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:54.478319 UTC

{offset
  ckVP:
      _sk4v::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckVQ; else goto ckVR;
  ckVR:
      if (HpLim == 0) goto ckVQ; else goto ckVS;
  ckVQ:
      R1 = _sk4v::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckVS:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sk4v::P64;
      _sk3m::I64 = I64[_sk4v::P64 + 16];
      _sk3x::I64 = I64[_sk4v::P64 + 24];
      I64[(young<ckVn> + 8)] = ckVn;
      R4 = GHC.Types.[]_closure+1;
      R3 = _sk3m::I64;
      R2 = 0;
      call GHC.Show.$wshowSignedInt_info(R4,
                                         R3,
                                         R2) returns to ckVn, args: 8, res: 8, upd: 24;
  ckVn:
      _sk4l::P64 = R2;
      _sk4k::P64 = R1;
      Hp = Hp + 72;
      if (Hp > HpLim) goto ckVV; else goto ckVU;
  ckVV:
      HpAlloc = 72;
      R2 = _sk4l::P64;
      R1 = _sk4k::P64;
      call stg_gc_pp(R2, R1) returns to ckVn, args: 8, res: 8, upd: 24;
  ckVU:
      I64[Hp - 64] = sat_sk4t_info;
      I64[Hp - 48] = _sk3x::I64;
      _ckVp::P64 = Hp - 64;
      I64[Hp - 40] = :_con_info;
      P64[Hp - 32] = lvl14_rjVg_closure+1;
      P64[Hp - 24] = _ckVp::P64;
      _ckVN::P64 = Hp - 38;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _sk4k::P64;
      P64[Hp] = _sk4l::P64;
      _ckVO::P64 = Hp - 14;
      R3 = _ckVN::P64;
      R2 = _ckVO::P64;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:54.480526 UTC

{offset
  ckVP:
      _sk4v::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckVQ; else goto ckVR;
  ckVR:
      if (HpLim == 0) goto ckVQ; else goto ckVS;
  ckVQ:
      R1 = _sk4v::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckVS:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sk4v::P64;
      _sk3m::I64 = I64[_sk4v::P64 + 16];
      _sk3x::I64 = I64[_sk4v::P64 + 24];
      I64[(young<ckVn> + 8)] = ckVn;
      R4 = GHC.Types.[]_closure+1;
      R3 = _sk3m::I64;
      R2 = 0;
      call GHC.Show.$wshowSignedInt_info(R4,
                                         R3,
                                         R2) returns to ckVn, args: 8, res: 8, upd: 24;
  ckVn:
      _sk4l::P64 = R2;
      _sk4k::P64 = R1;
      Hp = Hp + 72;
      if (Hp > HpLim) goto ckVV; else goto ckVU;
  ckVV:
      HpAlloc = 72;
      R2 = _sk4l::P64;
      R1 = _sk4k::P64;
      call stg_gc_pp(R2, R1) returns to ckVn, args: 8, res: 8, upd: 24;
  ckVU:
      I64[Hp - 64] = sat_sk4t_info;
      I64[Hp - 48] = _sk3x::I64;
      _ckVp::P64 = Hp - 64;
      I64[Hp - 40] = :_con_info;
      P64[Hp - 32] = lvl14_rjVg_closure+1;
      P64[Hp - 24] = _ckVp::P64;
      _ckVN::P64 = Hp - 38;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _sk4k::P64;
      P64[Hp] = _sk4l::P64;
      _ckVO::P64 = Hp - 14;
      R3 = _ckVN::P64;
      R2 = _ckVO::P64;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:54.482722 UTC

{offset
  ckVP:
      _sk4v::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckVQ; else goto ckVR;
  ckVR:
      if (HpLim == 0) goto ckVQ; else goto ckVS;
  ckVQ:
      R1 = _sk4v::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckVS:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sk4v::P64;
      _sk3m::I64 = I64[_sk4v::P64 + 16];
      _sk3x::I64 = I64[_sk4v::P64 + 24];
      I64[(young<ckVn> + 8)] = ckVn;
      R4 = GHC.Types.[]_closure+1;
      R3 = _sk3m::I64;
      R2 = 0;
      call GHC.Show.$wshowSignedInt_info(R4,
                                         R3,
                                         R2) returns to ckVn, args: 8, res: 8, upd: 24;
  ckVn:
      _sk4l::P64 = R2;
      _sk4k::P64 = R1;
      Hp = Hp + 72;
      if (Hp > HpLim) goto ckVV; else goto ckVU;
  ckVV:
      HpAlloc = 72;
      R2 = _sk4l::P64;
      R1 = _sk4k::P64;
      call stg_gc_pp(R2, R1) returns to ckVn, args: 8, res: 8, upd: 24;
  ckVU:
      I64[Hp - 64] = sat_sk4t_info;
      I64[Hp - 48] = _sk3x::I64;
      _ckVp::P64 = Hp - 64;
      I64[Hp - 40] = :_con_info;
      P64[Hp - 32] = lvl14_rjVg_closure+1;
      P64[Hp - 24] = _ckVp::P64;
      _ckVN::P64 = Hp - 38;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _sk4k::P64;
      P64[Hp] = _sk4l::P64;
      _ckVO::P64 = Hp - 14;
      R3 = _ckVN::P64;
      R2 = _ckVO::P64;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:54.48568 UTC

{offset
  ckVP:
      _sk4v::P64 = R1;
      if ((Sp + 8) - 40 < SpLim) goto ckVQ; else goto ckVR;
  ckVR:
      if (HpLim == 0) goto ckVQ; else goto ckVS;
  ckVQ:
      R1 = _sk4v::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckVS:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _sk4v::P64;
      _sk3m::I64 = I64[_sk4v::P64 + 16];
      _sk3x::I64 = I64[_sk4v::P64 + 24];
      I64[Sp - 32] = ckVn;
      R4 = GHC.Types.[]_closure+1;
      R3 = _sk3m::I64;
      R2 = 0;
      I64[Sp - 24] = _sk3x::I64;
      Sp = Sp - 32;
      call GHC.Show.$wshowSignedInt_info(R4,
                                         R3,
                                         R2) returns to ckVn, args: 8, res: 8, upd: 24;
  ckVn:
      _sk3x::I64 = I64[Sp + 8];
      _sk4l::P64 = R2;
      _sk4k::P64 = R1;
      Hp = Hp + 72;
      if (Hp > HpLim) goto ckVV; else goto ckVU;
  ckVV:
      HpAlloc = 72;
      R2 = _sk4l::P64;
      R1 = _sk4k::P64;
      call stg_gc_pp(R2, R1) returns to ckVn, args: 8, res: 8, upd: 24;
  ckVU:
      I64[Hp - 64] = sat_sk4t_info;
      I64[Hp - 48] = _sk3x::I64;
      _ckVp::P64 = Hp - 64;
      I64[Hp - 40] = :_con_info;
      P64[Hp - 32] = lvl14_rjVg_closure+1;
      P64[Hp - 24] = _ckVp::P64;
      _ckVN::P64 = Hp - 38;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _sk4k::P64;
      P64[Hp] = _sk4l::P64;
      _ckVO::P64 = Hp - 14;
      R3 = _ckVN::P64;
      R2 = _ckVO::P64;
      Sp = Sp + 16;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:54.488069 UTC

{offset
  ckVP:
      _sk4v::P64 = R1;
      if ((Sp + -32) < SpLim) goto ckVQ; else goto ckVR;
  ckVR:
      if (HpLim == 0) goto ckVQ; else goto ckVS;
  ckVQ:
      R1 = _sk4v::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckVS:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _sk4v::P64;
      I64[Sp - 32] = ckVn;
      R4 = GHC.Types.[]_closure+1;
      R3 = I64[_sk4v::P64 + 16];
      R2 = 0;
      I64[Sp - 24] = I64[_sk4v::P64 + 24];
      Sp = Sp - 32;
      call GHC.Show.$wshowSignedInt_info(R4,
                                         R3,
                                         R2) returns to ckVn, args: 8, res: 8, upd: 24;
  ckVn:
      Hp = Hp + 72;
      if (Hp > HpLim) goto ckVV; else goto ckVU;
  ckVV:
      HpAlloc = 72;
      R2 = R2;
      R1 = R1;
      call stg_gc_pp(R2, R1) returns to ckVn, args: 8, res: 8, upd: 24;
  ckVU:
      I64[Hp - 64] = sat_sk4t_info;
      I64[Hp - 48] = I64[Sp + 8];
      I64[Hp - 40] = :_con_info;
      P64[Hp - 32] = lvl14_rjVg_closure+1;
      P64[Hp - 24] = Hp - 64;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = R1;
      P64[Hp] = R2;
      R3 = Hp - 38;
      R2 = Hp - 14;
      Sp = Sp + 16;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:54.490473 UTC

[(ckVn, {sat_sk4t_closure}), (ckVP, {sat_sk4t_closure}),
 (ckVQ, {}), (ckVR, {sat_sk4t_closure}), (ckVS, {sat_sk4t_closure}),
 (ckVU, {sat_sk4t_closure}), (ckVV, {sat_sk4t_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:54.491058 UTC

sat_sk4v_entry() //  [R1]
        { info_tbl: [(ckVn,
                      label: block_ckVn_info
                      rep:StackRep [True]),
                     (ckVP,
                      label: sat_sk4v_info
                      rep:HeapRep 2 nonptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckVP:
          _sk4v::P64 = R1;
          if ((Sp + -32) < SpLim) goto ckVQ; else goto ckVR;
      ckVR:
          if (HpLim == 0) goto ckVQ; else goto ckVS;
      ckVQ:
          R1 = _sk4v::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckVS:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _sk4v::P64;
          I64[Sp - 32] = ckVn;
          R4 = GHC.Types.[]_closure+1;
          R3 = I64[_sk4v::P64 + 16];
          R2 = 0;
          I64[Sp - 24] = I64[_sk4v::P64 + 24];
          Sp = Sp - 32;
          call GHC.Show.$wshowSignedInt_info(R4,
                                             R3,
                                             R2) returns to ckVn, args: 8, res: 8, upd: 24;
      ckVn:
          Hp = Hp + 72;
          if (Hp > HpLim) goto ckVV; else goto ckVU;
      ckVV:
          HpAlloc = 72;
          R2 = R2;
          R1 = R1;
          call stg_gc_pp(R2, R1) returns to ckVn, args: 8, res: 8, upd: 24;
      ckVU:
          I64[Hp - 64] = sat_sk4t_info;
          I64[Hp - 48] = I64[Sp + 8];
          I64[Hp - 40] = :_con_info;
          P64[Hp - 32] = lvl14_rjVg_closure+1;
          P64[Hp - 24] = Hp - 64;
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = R1;
          P64[Hp] = R2;
          R3 = Hp - 38;
          R2 = Hp - 14;
          Sp = Sp + 16;
          call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:54.493462 UTC

sat_sk4v_entry() //  [R1]
        { info_tbl: [(ckVn,
                      label: block_ckVn_info
                      rep:StackRep [True]),
                     (ckVP,
                      label: sat_sk4v_info
                      rep:HeapRep 2 nonptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckVP:
          _sk4v::P64 = R1;
          if ((Sp + -32) < SpLim) goto ckVQ; else goto ckVR;
      ckVR:
          if (HpLim == 0) goto ckVQ; else goto ckVS;
      ckVQ:
          R1 = _sk4v::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckVS:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _sk4v::P64;
          I64[Sp - 32] = ckVn;
          R4 = GHC.Types.[]_closure+1;
          R3 = I64[_sk4v::P64 + 16];
          R2 = 0;
          I64[Sp - 24] = I64[_sk4v::P64 + 24];
          Sp = Sp - 32;
          call GHC.Show.$wshowSignedInt_info(R4,
                                             R3,
                                             R2) returns to ckVn, args: 8, res: 8, upd: 24;
      ckVn:
          Hp = Hp + 72;
          if (Hp > HpLim) goto ckVV; else goto ckVU;
      ckVV:
          HpAlloc = 72;
          R2 = R2;
          R1 = R1;
          call stg_gc_pp(R2, R1) returns to ckVn, args: 8, res: 8, upd: 24;
      ckVU:
          I64[Hp - 64] = sat_sk4t_info;
          I64[Hp - 48] = I64[Sp + 8];
          I64[Hp - 40] = :_con_info;
          P64[Hp - 32] = lvl14_rjVg_closure+1;
          P64[Hp - 24] = Hp - 64;
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = R1;
          P64[Hp] = R2;
          R3 = Hp - 38;
          R2 = Hp - 14;
          Sp = Sp + 16;
          call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:54.495857 UTC

{offset
  ckVX:
      _sk4x::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckVY; else goto ckVZ;
  ckVZ:
      Hp = Hp + 56;
      if (Hp > HpLim) goto ckW1; else goto ckW0;
  ckW1:
      HpAlloc = 56;
      goto ckVY;
  ckVY:
      R1 = _sk4x::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckW0:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sk4x::P64;
      _sk3m::I64 = I64[_sk4x::P64 + 16];
      _sk3x::I64 = I64[_sk4x::P64 + 24];
      I64[Hp - 48] = sat_sk4v_info;
      I64[Hp - 32] = _sk3m::I64;
      I64[Hp - 24] = _sk3x::I64;
      _ckVj::P64 = Hp - 48;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = lvl14_rjVg_closure+1;
      P64[Hp] = _ckVj::P64;
      _ckVW::P64 = Hp - 14;
      R3 = _ckVW::P64;
      R2 = Main.rbTreeOpts79_closure;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:54.497319 UTC

{offset
  ckVX:
      _sk4x::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckVY; else goto ckVZ;
  ckVZ:
      Hp = Hp + 56;
      if (Hp > HpLim) goto ckW1; else goto ckW0;
  ckW1:
      HpAlloc = 56;
      goto ckVY;
  ckVY:
      R1 = _sk4x::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckW0:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sk4x::P64;
      _sk3m::I64 = I64[_sk4x::P64 + 16];
      _sk3x::I64 = I64[_sk4x::P64 + 24];
      I64[Hp - 48] = sat_sk4v_info;
      I64[Hp - 32] = _sk3m::I64;
      I64[Hp - 24] = _sk3x::I64;
      _ckVj::P64 = Hp - 48;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = lvl14_rjVg_closure+1;
      P64[Hp] = _ckVj::P64;
      _ckVW::P64 = Hp - 14;
      R3 = _ckVW::P64;
      R2 = Main.rbTreeOpts79_closure;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:54.498761 UTC

{offset
  ckVX:
      _sk4x::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckVY; else goto ckVZ;
  ckVZ:
      Hp = Hp + 56;
      if (Hp > HpLim) goto ckW1; else goto ckW0;
  ckW1:
      HpAlloc = 56;
      goto ckVY;
  ckVY:
      R1 = _sk4x::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckW0:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sk4x::P64;
      _sk3m::I64 = I64[_sk4x::P64 + 16];
      _sk3x::I64 = I64[_sk4x::P64 + 24];
      I64[Hp - 48] = sat_sk4v_info;
      I64[Hp - 32] = _sk3m::I64;
      I64[Hp - 24] = _sk3x::I64;
      _ckVj::P64 = Hp - 48;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = lvl14_rjVg_closure+1;
      P64[Hp] = _ckVj::P64;
      _ckVW::P64 = Hp - 14;
      R3 = _ckVW::P64;
      R2 = Main.rbTreeOpts79_closure;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:54.500357 UTC

{offset
  ckVX:
      _sk4x::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto ckVY; else goto ckVZ;
  ckVZ:
      Hp = Hp + 56;
      if (Hp > HpLim) goto ckW1; else goto ckW0;
  ckW1:
      HpAlloc = 56;
      goto ckVY;
  ckVY:
      R1 = _sk4x::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckW0:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _sk4x::P64;
      _sk3m::I64 = I64[_sk4x::P64 + 16];
      _sk3x::I64 = I64[_sk4x::P64 + 24];
      I64[Hp - 48] = sat_sk4v_info;
      I64[Hp - 32] = _sk3m::I64;
      I64[Hp - 24] = _sk3x::I64;
      _ckVj::P64 = Hp - 48;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = lvl14_rjVg_closure+1;
      P64[Hp] = _ckVj::P64;
      _ckVW::P64 = Hp - 14;
      R3 = _ckVW::P64;
      R2 = Main.rbTreeOpts79_closure;
      Sp = Sp - 16;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:54.501818 UTC

{offset
  ckVX:
      _sk4x::P64 = R1;
      if ((Sp + -16) < SpLim) goto ckVY; else goto ckVZ;
  ckVZ:
      Hp = Hp + 56;
      if (Hp > HpLim) goto ckW1; else goto ckW0;
  ckW1:
      HpAlloc = 56;
      goto ckVY;
  ckVY:
      R1 = _sk4x::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckW0:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _sk4x::P64;
      _sk3m::I64 = I64[_sk4x::P64 + 16];
      _sk3x::I64 = I64[_sk4x::P64 + 24];
      I64[Hp - 48] = sat_sk4v_info;
      I64[Hp - 32] = _sk3m::I64;
      I64[Hp - 24] = _sk3x::I64;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = lvl14_rjVg_closure+1;
      P64[Hp] = Hp - 48;
      R3 = Hp - 14;
      R2 = Main.rbTreeOpts79_closure;
      Sp = Sp - 16;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:54.503403 UTC

[(ckVX, {Main.rbTreeOpts79_closure, sat_sk4v_closure}), (ckVY, {}),
 (ckVZ, {Main.rbTreeOpts79_closure, sat_sk4v_closure}),
 (ckW0, {Main.rbTreeOpts79_closure, sat_sk4v_closure}), (ckW1, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:54.503928 UTC

sat_sk4x_entry() //  [R1]
        { info_tbl: [(ckVX,
                      label: sat_sk4x_info
                      rep:HeapRep 2 nonptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckVX:
          _sk4x::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckVY; else goto ckVZ;
      ckVZ:
          Hp = Hp + 56;
          if (Hp > HpLim) goto ckW1; else goto ckW0;
      ckW1:
          HpAlloc = 56;
          goto ckVY;
      ckVY:
          R1 = _sk4x::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckW0:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _sk4x::P64;
          _sk3m::I64 = I64[_sk4x::P64 + 16];
          _sk3x::I64 = I64[_sk4x::P64 + 24];
          I64[Hp - 48] = sat_sk4v_info;
          I64[Hp - 32] = _sk3m::I64;
          I64[Hp - 24] = _sk3x::I64;
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = lvl14_rjVg_closure+1;
          P64[Hp] = Hp - 48;
          R3 = Hp - 14;
          R2 = Main.rbTreeOpts79_closure;
          Sp = Sp - 16;
          call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:54.505584 UTC

sat_sk4x_entry() //  [R1]
        { info_tbl: [(ckVX,
                      label: sat_sk4x_info
                      rep:HeapRep 2 nonptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckVX:
          _sk4x::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckVY; else goto ckVZ;
      ckVZ:
          Hp = Hp + 56;
          if (Hp > HpLim) goto ckW1; else goto ckW0;
      ckW1:
          HpAlloc = 56;
          goto ckVY;
      ckVY:
          R1 = _sk4x::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckW0:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _sk4x::P64;
          _sk3m::I64 = I64[_sk4x::P64 + 16];
          _sk3x::I64 = I64[_sk4x::P64 + 24];
          I64[Hp - 48] = sat_sk4v_info;
          I64[Hp - 32] = _sk3m::I64;
          I64[Hp - 24] = _sk3x::I64;
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = lvl14_rjVg_closure+1;
          P64[Hp] = Hp - 48;
          R3 = Hp - 14;
          R2 = Main.rbTreeOpts79_closure;
          Sp = Sp - 16;
          call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:54.507277 UTC

{offset
  ckW3:
      _sk4z::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckW4; else goto ckW5;
  ckW5:
      Hp = Hp + 56;
      if (Hp > HpLim) goto ckW7; else goto ckW6;
  ckW7:
      HpAlloc = 56;
      goto ckW4;
  ckW4:
      R1 = _sk4z::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckW6:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sk4z::P64;
      _sk33::P64 = P64[_sk4z::P64 + 16];
      _sk3m::I64 = I64[_sk4z::P64 + 24];
      _sk3x::I64 = I64[_sk4z::P64 + 32];
      I64[Hp - 48] = sat_sk4x_info;
      I64[Hp - 32] = _sk3m::I64;
      I64[Hp - 24] = _sk3x::I64;
      _ckVf::P64 = Hp - 48;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = lvl14_rjVg_closure+1;
      P64[Hp] = _ckVf::P64;
      _ckW2::P64 = Hp - 14;
      R3 = _ckW2::P64;
      R2 = _sk33::P64;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:54.508768 UTC

{offset
  ckW3:
      _sk4z::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckW4; else goto ckW5;
  ckW5:
      Hp = Hp + 56;
      if (Hp > HpLim) goto ckW7; else goto ckW6;
  ckW7:
      HpAlloc = 56;
      goto ckW4;
  ckW4:
      R1 = _sk4z::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckW6:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sk4z::P64;
      _sk33::P64 = P64[_sk4z::P64 + 16];
      _sk3m::I64 = I64[_sk4z::P64 + 24];
      _sk3x::I64 = I64[_sk4z::P64 + 32];
      I64[Hp - 48] = sat_sk4x_info;
      I64[Hp - 32] = _sk3m::I64;
      I64[Hp - 24] = _sk3x::I64;
      _ckVf::P64 = Hp - 48;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = lvl14_rjVg_closure+1;
      P64[Hp] = _ckVf::P64;
      _ckW2::P64 = Hp - 14;
      R3 = _ckW2::P64;
      R2 = _sk33::P64;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:54.510276 UTC

{offset
  ckW3:
      _sk4z::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckW4; else goto ckW5;
  ckW5:
      Hp = Hp + 56;
      if (Hp > HpLim) goto ckW7; else goto ckW6;
  ckW7:
      HpAlloc = 56;
      goto ckW4;
  ckW4:
      R1 = _sk4z::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckW6:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sk4z::P64;
      _sk33::P64 = P64[_sk4z::P64 + 16];
      _sk3m::I64 = I64[_sk4z::P64 + 24];
      _sk3x::I64 = I64[_sk4z::P64 + 32];
      I64[Hp - 48] = sat_sk4x_info;
      I64[Hp - 32] = _sk3m::I64;
      I64[Hp - 24] = _sk3x::I64;
      _ckVf::P64 = Hp - 48;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = lvl14_rjVg_closure+1;
      P64[Hp] = _ckVf::P64;
      _ckW2::P64 = Hp - 14;
      R3 = _ckW2::P64;
      R2 = _sk33::P64;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:54.511812 UTC

{offset
  ckW3:
      _sk4z::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto ckW4; else goto ckW5;
  ckW5:
      Hp = Hp + 56;
      if (Hp > HpLim) goto ckW7; else goto ckW6;
  ckW7:
      HpAlloc = 56;
      goto ckW4;
  ckW4:
      R1 = _sk4z::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckW6:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _sk4z::P64;
      _sk33::P64 = P64[_sk4z::P64 + 16];
      _sk3m::I64 = I64[_sk4z::P64 + 24];
      _sk3x::I64 = I64[_sk4z::P64 + 32];
      I64[Hp - 48] = sat_sk4x_info;
      I64[Hp - 32] = _sk3m::I64;
      I64[Hp - 24] = _sk3x::I64;
      _ckVf::P64 = Hp - 48;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = lvl14_rjVg_closure+1;
      P64[Hp] = _ckVf::P64;
      _ckW2::P64 = Hp - 14;
      R3 = _ckW2::P64;
      R2 = _sk33::P64;
      Sp = Sp - 16;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:54.513345 UTC

{offset
  ckW3:
      _sk4z::P64 = R1;
      if ((Sp + -16) < SpLim) goto ckW4; else goto ckW5;
  ckW5:
      Hp = Hp + 56;
      if (Hp > HpLim) goto ckW7; else goto ckW6;
  ckW7:
      HpAlloc = 56;
      goto ckW4;
  ckW4:
      R1 = _sk4z::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckW6:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _sk4z::P64;
      _sk33::P64 = P64[_sk4z::P64 + 16];
      _sk3m::I64 = I64[_sk4z::P64 + 24];
      _sk3x::I64 = I64[_sk4z::P64 + 32];
      I64[Hp - 48] = sat_sk4x_info;
      I64[Hp - 32] = _sk3m::I64;
      I64[Hp - 24] = _sk3x::I64;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = lvl14_rjVg_closure+1;
      P64[Hp] = Hp - 48;
      R3 = Hp - 14;
      R2 = _sk33::P64;
      Sp = Sp - 16;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:54.514972 UTC

[(ckW3, {sat_sk4x_closure}), (ckW4, {}),
 (ckW5, {sat_sk4x_closure}), (ckW6, {sat_sk4x_closure}), (ckW7, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:54.515409 UTC

sat_sk4z_entry() //  [R1]
        { info_tbl: [(ckW3,
                      label: sat_sk4z_info
                      rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckW3:
          _sk4z::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckW4; else goto ckW5;
      ckW5:
          Hp = Hp + 56;
          if (Hp > HpLim) goto ckW7; else goto ckW6;
      ckW7:
          HpAlloc = 56;
          goto ckW4;
      ckW4:
          R1 = _sk4z::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckW6:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _sk4z::P64;
          _sk33::P64 = P64[_sk4z::P64 + 16];
          _sk3m::I64 = I64[_sk4z::P64 + 24];
          _sk3x::I64 = I64[_sk4z::P64 + 32];
          I64[Hp - 48] = sat_sk4x_info;
          I64[Hp - 32] = _sk3m::I64;
          I64[Hp - 24] = _sk3x::I64;
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = lvl14_rjVg_closure+1;
          P64[Hp] = Hp - 48;
          R3 = Hp - 14;
          R2 = _sk33::P64;
          Sp = Sp - 16;
          call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:54.517145 UTC

sat_sk4z_entry() //  [R1]
        { info_tbl: [(ckW3,
                      label: sat_sk4z_info
                      rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckW3:
          _sk4z::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckW4; else goto ckW5;
      ckW5:
          Hp = Hp + 56;
          if (Hp > HpLim) goto ckW7; else goto ckW6;
      ckW7:
          HpAlloc = 56;
          goto ckW4;
      ckW4:
          R1 = _sk4z::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckW6:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _sk4z::P64;
          _sk33::P64 = P64[_sk4z::P64 + 16];
          _sk3m::I64 = I64[_sk4z::P64 + 24];
          _sk3x::I64 = I64[_sk4z::P64 + 32];
          I64[Hp - 48] = sat_sk4x_info;
          I64[Hp - 32] = _sk3m::I64;
          I64[Hp - 24] = _sk3x::I64;
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = lvl14_rjVg_closure+1;
          P64[Hp] = Hp - 48;
          R3 = Hp - 14;
          R2 = _sk33::P64;
          Sp = Sp - 16;
          call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:54.519399 UTC

{offset
  ckW9:
      _sk4i::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckWa; else goto ckWb;
  ckWb:
      Hp = Hp + 64;
      if (Hp > HpLim) goto ckWd; else goto ckWc;
  ckWd:
      HpAlloc = 64;
      goto ckWa;
  ckWa:
      R1 = _sk4i::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckWc:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sk4i::P64;
      _sk33::P64 = P64[_sk4i::P64 + 16];
      _sk3m::I64 = I64[_sk4i::P64 + 24];
      _sk3x::I64 = I64[_sk4i::P64 + 32];
      I64[Hp - 56] = sat_sk4z_info;
      P64[Hp - 40] = _sk33::P64;
      I64[Hp - 32] = _sk3m::I64;
      I64[Hp - 24] = _sk3x::I64;
      _ckVb::P64 = Hp - 56;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = lvl14_rjVg_closure+1;
      P64[Hp] = _ckVb::P64;
      _ckW8::P64 = Hp - 14;
      R3 = _ckW8::P64;
      R2 = lvl18_rjVl_closure;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:54.521016 UTC

{offset
  ckW9:
      _sk4i::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckWa; else goto ckWb;
  ckWb:
      Hp = Hp + 64;
      if (Hp > HpLim) goto ckWd; else goto ckWc;
  ckWd:
      HpAlloc = 64;
      goto ckWa;
  ckWa:
      R1 = _sk4i::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckWc:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sk4i::P64;
      _sk33::P64 = P64[_sk4i::P64 + 16];
      _sk3m::I64 = I64[_sk4i::P64 + 24];
      _sk3x::I64 = I64[_sk4i::P64 + 32];
      I64[Hp - 56] = sat_sk4z_info;
      P64[Hp - 40] = _sk33::P64;
      I64[Hp - 32] = _sk3m::I64;
      I64[Hp - 24] = _sk3x::I64;
      _ckVb::P64 = Hp - 56;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = lvl14_rjVg_closure+1;
      P64[Hp] = _ckVb::P64;
      _ckW8::P64 = Hp - 14;
      R3 = _ckW8::P64;
      R2 = lvl18_rjVl_closure;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:54.522564 UTC

{offset
  ckW9:
      _sk4i::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckWa; else goto ckWb;
  ckWb:
      Hp = Hp + 64;
      if (Hp > HpLim) goto ckWd; else goto ckWc;
  ckWd:
      HpAlloc = 64;
      goto ckWa;
  ckWa:
      R1 = _sk4i::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckWc:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sk4i::P64;
      _sk33::P64 = P64[_sk4i::P64 + 16];
      _sk3m::I64 = I64[_sk4i::P64 + 24];
      _sk3x::I64 = I64[_sk4i::P64 + 32];
      I64[Hp - 56] = sat_sk4z_info;
      P64[Hp - 40] = _sk33::P64;
      I64[Hp - 32] = _sk3m::I64;
      I64[Hp - 24] = _sk3x::I64;
      _ckVb::P64 = Hp - 56;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = lvl14_rjVg_closure+1;
      P64[Hp] = _ckVb::P64;
      _ckW8::P64 = Hp - 14;
      R3 = _ckW8::P64;
      R2 = lvl18_rjVl_closure;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:54.524151 UTC

{offset
  ckW9:
      _sk4i::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto ckWa; else goto ckWb;
  ckWb:
      Hp = Hp + 64;
      if (Hp > HpLim) goto ckWd; else goto ckWc;
  ckWd:
      HpAlloc = 64;
      goto ckWa;
  ckWa:
      R1 = _sk4i::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckWc:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _sk4i::P64;
      _sk33::P64 = P64[_sk4i::P64 + 16];
      _sk3m::I64 = I64[_sk4i::P64 + 24];
      _sk3x::I64 = I64[_sk4i::P64 + 32];
      I64[Hp - 56] = sat_sk4z_info;
      P64[Hp - 40] = _sk33::P64;
      I64[Hp - 32] = _sk3m::I64;
      I64[Hp - 24] = _sk3x::I64;
      _ckVb::P64 = Hp - 56;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = lvl14_rjVg_closure+1;
      P64[Hp] = _ckVb::P64;
      _ckW8::P64 = Hp - 14;
      R3 = _ckW8::P64;
      R2 = lvl18_rjVl_closure;
      Sp = Sp - 16;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:54.525692 UTC

{offset
  ckW9:
      _sk4i::P64 = R1;
      if ((Sp + -16) < SpLim) goto ckWa; else goto ckWb;
  ckWb:
      Hp = Hp + 64;
      if (Hp > HpLim) goto ckWd; else goto ckWc;
  ckWd:
      HpAlloc = 64;
      goto ckWa;
  ckWa:
      R1 = _sk4i::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckWc:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _sk4i::P64;
      _sk33::P64 = P64[_sk4i::P64 + 16];
      _sk3m::I64 = I64[_sk4i::P64 + 24];
      _sk3x::I64 = I64[_sk4i::P64 + 32];
      I64[Hp - 56] = sat_sk4z_info;
      P64[Hp - 40] = _sk33::P64;
      I64[Hp - 32] = _sk3m::I64;
      I64[Hp - 24] = _sk3x::I64;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = lvl14_rjVg_closure+1;
      P64[Hp] = Hp - 56;
      R3 = Hp - 14;
      R2 = lvl18_rjVl_closure;
      Sp = Sp - 16;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:54.527432 UTC

[(ckW9, {lvl18_rjVl_closure, sat_sk4z_closure}), (ckWa, {}),
 (ckWb, {lvl18_rjVl_closure, sat_sk4z_closure}),
 (ckWc, {lvl18_rjVl_closure, sat_sk4z_closure}), (ckWd, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:54.52797 UTC

a8_sk4i_entry() //  [R1]
        { info_tbl: [(ckW9,
                      label: a8_sk4i_info
                      rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckW9:
          _sk4i::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckWa; else goto ckWb;
      ckWb:
          Hp = Hp + 64;
          if (Hp > HpLim) goto ckWd; else goto ckWc;
      ckWd:
          HpAlloc = 64;
          goto ckWa;
      ckWa:
          R1 = _sk4i::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckWc:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _sk4i::P64;
          _sk33::P64 = P64[_sk4i::P64 + 16];
          _sk3m::I64 = I64[_sk4i::P64 + 24];
          _sk3x::I64 = I64[_sk4i::P64 + 32];
          I64[Hp - 56] = sat_sk4z_info;
          P64[Hp - 40] = _sk33::P64;
          I64[Hp - 32] = _sk3m::I64;
          I64[Hp - 24] = _sk3x::I64;
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = lvl14_rjVg_closure+1;
          P64[Hp] = Hp - 56;
          R3 = Hp - 14;
          R2 = lvl18_rjVl_closure;
          Sp = Sp - 16;
          call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:54.529766 UTC

a8_sk4i_entry() //  [R1]
        { info_tbl: [(ckW9,
                      label: a8_sk4i_info
                      rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckW9:
          _sk4i::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckWa; else goto ckWb;
      ckWb:
          Hp = Hp + 64;
          if (Hp > HpLim) goto ckWd; else goto ckWc;
      ckWd:
          HpAlloc = 64;
          goto ckWa;
      ckWa:
          R1 = _sk4i::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckWc:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _sk4i::P64;
          _sk33::P64 = P64[_sk4i::P64 + 16];
          _sk3m::I64 = I64[_sk4i::P64 + 24];
          _sk3x::I64 = I64[_sk4i::P64 + 32];
          I64[Hp - 56] = sat_sk4z_info;
          P64[Hp - 40] = _sk33::P64;
          I64[Hp - 32] = _sk3m::I64;
          I64[Hp - 24] = _sk3x::I64;
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = lvl14_rjVg_closure+1;
          P64[Hp] = Hp - 56;
          R3 = Hp - 14;
          R2 = lvl18_rjVl_closure;
          Sp = Sp - 16;
          call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:54.531584 UTC

{offset
  ckWe:
      _sk4P::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckWf; else goto ckWg;
  ckWg:
      if (HpLim == 0) goto ckWf; else goto ckWh;
  ckWf:
      R1 = _sk4P::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckWh:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sk4P::P64;
      _sk33::P64 = P64[_sk4P::P64 + 16];
      _sk49::P64 = P64[_sk4P::P64 + 24];
      _sk3m::I64 = I64[_sk4P::P64 + 32];
      _sk3x::I64 = I64[_sk4P::P64 + 40];
      I64[(young<ckV0> + 8)] = ckV0;
      R3 = 0;
      R2 = _sk49::P64;
      call $wgo2_rjVk_info(R3,
                           R2) returns to ckV0, args: 8, res: 8, upd: 24;
  ckV0:
      _sk4g::I64 = R1;
      Hp = Hp + 40;
      if (Hp > HpLim) goto ckWk; else goto ckWj;
  ckWk:
      HpAlloc = 40;
      R1 = _sk4g::I64;
      call stg_gc_unbx_r1(R1) returns to ckV0, args: 8, res: 8, upd: 24;
  ckWj:
      _ckV4::I64 = _sk4g::I64;
      _sk4h::I64 = _ckV4::I64;
      I64[Hp - 32] = a8_sk4i_info;
      P64[Hp - 16] = _sk33::P64;
      I64[Hp - 8] = _sk3m::I64;
      I64[Hp] = _sk3x::I64;
      _ckV7::P64 = Hp - 32;
      _ckWl::I64 = %MO_S_Ge_W64(_sk4h::I64, 0);
      _sk4B::I64 = _ckWl::I64;
      switch [0 .. 1] _sk4B::I64 {
          case 0 : goto ckWz;
          case 1 : goto ckWN;
      }
  ckWN:
      I64[(young<ckWF> + 8)] = ckWF;
      R2 = _sk4h::I64;
      call GHC.Integer.Type.smallInteger_info(R2) returns to ckWF, args: 8, res: 8, upd: 24;
  ckWF:
      _sk4J::P64 = R1;
      I64[(young<ckWJ> + 8)] = ckWJ;
      R4 = GHC.Types.[]_closure+1;
      R3 = _sk4J::P64;
      R2 = 0;
      call GHC.Show.$w$cshowsPrec1_info(R4,
                                        R3,
                                        R2) returns to ckWJ, args: 8, res: 8, upd: 24;
  ckWJ:
      _sk4M::P64 = R2;
      _sk4L::P64 = R1;
      Hp = Hp + 48;
      if (Hp > HpLim) goto ckWR; else goto ckWQ;
  ckWR:
      HpAlloc = 48;
      R2 = _sk4M::P64;
      R1 = _sk4L::P64;
      call stg_gc_pp(R2, R1) returns to ckWJ, args: 8, res: 8, upd: 24;
  ckWQ:
      I64[Hp - 40] = :_con_info;
      P64[Hp - 32] = lvl14_rjVg_closure+1;
      P64[Hp - 24] = _ckV7::P64;
      _ckWL::P64 = Hp - 38;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _sk4L::P64;
      P64[Hp] = _sk4M::P64;
      _ckWM::P64 = Hp - 14;
      R3 = _ckWL::P64;
      R2 = _ckWM::P64;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
  ckWz:
      I64[(young<ckWq> + 8)] = ckWq;
      R2 = _sk4g::I64;
      call GHC.Integer.Type.wordToInteger_info(R2) returns to ckWq, args: 8, res: 8, upd: 24;
  ckWq:
      _sk4D::P64 = R1;
      I64[(young<ckWu> + 8)] = ckWu;
      R4 = GHC.Types.[]_closure+1;
      R3 = _sk4D::P64;
      R2 = 0;
      call GHC.Show.$w$cshowsPrec1_info(R4,
                                        R3,
                                        R2) returns to ckWu, args: 8, res: 8, upd: 24;
  ckWu:
      _sk4G::P64 = R2;
      _sk4F::P64 = R1;
      Hp = Hp + 48;
      if (Hp > HpLim) goto ckWD; else goto ckWC;
  ckWD:
      HpAlloc = 48;
      R2 = _sk4G::P64;
      R1 = _sk4F::P64;
      call stg_gc_pp(R2, R1) returns to ckWu, args: 8, res: 8, upd: 24;
  ckWC:
      I64[Hp - 40] = :_con_info;
      P64[Hp - 32] = lvl14_rjVg_closure+1;
      P64[Hp - 24] = _ckV7::P64;
      _ckWw::P64 = Hp - 38;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _sk4F::P64;
      P64[Hp] = _sk4G::P64;
      _ckWx::P64 = Hp - 14;
      R3 = _ckWw::P64;
      R2 = _ckWx::P64;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:54.536523 UTC

{offset
  ckWe:
      _sk4P::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckWf; else goto ckWg;
  ckWg:
      if (HpLim == 0) goto ckWf; else goto ckWh;
  ckWf:
      R1 = _sk4P::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckWh:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sk4P::P64;
      _sk33::P64 = P64[_sk4P::P64 + 16];
      _sk49::P64 = P64[_sk4P::P64 + 24];
      _sk3m::I64 = I64[_sk4P::P64 + 32];
      _sk3x::I64 = I64[_sk4P::P64 + 40];
      I64[(young<ckV0> + 8)] = ckV0;
      R3 = 0;
      R2 = _sk49::P64;
      call $wgo2_rjVk_info(R3,
                           R2) returns to ckV0, args: 8, res: 8, upd: 24;
  ckV0:
      _sk4g::I64 = R1;
      Hp = Hp + 40;
      if (Hp > HpLim) goto ckWk; else goto ckWj;
  ckWk:
      HpAlloc = 40;
      R1 = _sk4g::I64;
      call stg_gc_unbx_r1(R1) returns to ckV0, args: 8, res: 8, upd: 24;
  ckWj:
      _ckV4::I64 = _sk4g::I64;
      _sk4h::I64 = _ckV4::I64;
      I64[Hp - 32] = a8_sk4i_info;
      P64[Hp - 16] = _sk33::P64;
      I64[Hp - 8] = _sk3m::I64;
      I64[Hp] = _sk3x::I64;
      _ckV7::P64 = Hp - 32;
      _ckWl::I64 = %MO_S_Ge_W64(_sk4h::I64, 0);
      _sk4B::I64 = _ckWl::I64;
      switch [0 .. 1] _sk4B::I64 {
          case 0 : goto ckWz;
          case 1 : goto ckWN;
      }
  ckWN:
      I64[(young<ckWF> + 8)] = ckWF;
      R2 = _sk4h::I64;
      call GHC.Integer.Type.smallInteger_info(R2) returns to ckWF, args: 8, res: 8, upd: 24;
  ckWF:
      _sk4J::P64 = R1;
      I64[(young<ckWJ> + 8)] = ckWJ;
      R4 = GHC.Types.[]_closure+1;
      R3 = _sk4J::P64;
      R2 = 0;
      call GHC.Show.$w$cshowsPrec1_info(R4,
                                        R3,
                                        R2) returns to ckWJ, args: 8, res: 8, upd: 24;
  ckWJ:
      _sk4M::P64 = R2;
      _sk4L::P64 = R1;
      Hp = Hp + 48;
      if (Hp > HpLim) goto ckWR; else goto ckWQ;
  ckWR:
      HpAlloc = 48;
      R2 = _sk4M::P64;
      R1 = _sk4L::P64;
      call stg_gc_pp(R2, R1) returns to ckWJ, args: 8, res: 8, upd: 24;
  ckWQ:
      I64[Hp - 40] = :_con_info;
      P64[Hp - 32] = lvl14_rjVg_closure+1;
      P64[Hp - 24] = _ckV7::P64;
      _ckWL::P64 = Hp - 38;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _sk4L::P64;
      P64[Hp] = _sk4M::P64;
      _ckWM::P64 = Hp - 14;
      R3 = _ckWL::P64;
      R2 = _ckWM::P64;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
  ckWz:
      I64[(young<ckWq> + 8)] = ckWq;
      R2 = _sk4g::I64;
      call GHC.Integer.Type.wordToInteger_info(R2) returns to ckWq, args: 8, res: 8, upd: 24;
  ckWq:
      _sk4D::P64 = R1;
      I64[(young<ckWu> + 8)] = ckWu;
      R4 = GHC.Types.[]_closure+1;
      R3 = _sk4D::P64;
      R2 = 0;
      call GHC.Show.$w$cshowsPrec1_info(R4,
                                        R3,
                                        R2) returns to ckWu, args: 8, res: 8, upd: 24;
  ckWu:
      _sk4G::P64 = R2;
      _sk4F::P64 = R1;
      Hp = Hp + 48;
      if (Hp > HpLim) goto ckWD; else goto ckWC;
  ckWD:
      HpAlloc = 48;
      R2 = _sk4G::P64;
      R1 = _sk4F::P64;
      call stg_gc_pp(R2, R1) returns to ckWu, args: 8, res: 8, upd: 24;
  ckWC:
      I64[Hp - 40] = :_con_info;
      P64[Hp - 32] = lvl14_rjVg_closure+1;
      P64[Hp - 24] = _ckV7::P64;
      _ckWw::P64 = Hp - 38;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _sk4F::P64;
      P64[Hp] = _sk4G::P64;
      _ckWx::P64 = Hp - 14;
      R3 = _ckWw::P64;
      R2 = _ckWx::P64;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:54.541608 UTC

{offset
  ckWe:
      _sk4P::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckWf; else goto ckWg;
  ckWg:
      if (HpLim == 0) goto ckWf; else goto ckWh;
  ckWf:
      R1 = _sk4P::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckWh:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sk4P::P64;
      _sk33::P64 = P64[_sk4P::P64 + 16];
      _sk49::P64 = P64[_sk4P::P64 + 24];
      _sk3m::I64 = I64[_sk4P::P64 + 32];
      _sk3x::I64 = I64[_sk4P::P64 + 40];
      I64[(young<ckV0> + 8)] = ckV0;
      R3 = 0;
      R2 = _sk49::P64;
      call $wgo2_rjVk_info(R3,
                           R2) returns to ckV0, args: 8, res: 8, upd: 24;
  ckV0:
      _sk4g::I64 = R1;
      Hp = Hp + 40;
      if (Hp > HpLim) goto ckWk; else goto ckWj;
  ckWk:
      HpAlloc = 40;
      R1 = _sk4g::I64;
      call stg_gc_unbx_r1(R1) returns to ckV0, args: 8, res: 8, upd: 24;
  ckWj:
      _ckV4::I64 = _sk4g::I64;
      _sk4h::I64 = _ckV4::I64;
      I64[Hp - 32] = a8_sk4i_info;
      P64[Hp - 16] = _sk33::P64;
      I64[Hp - 8] = _sk3m::I64;
      I64[Hp] = _sk3x::I64;
      _ckV7::P64 = Hp - 32;
      _ckWl::I64 = %MO_S_Ge_W64(_sk4h::I64, 0);
      _sk4B::I64 = _ckWl::I64;
      if (_sk4B::I64 != 0) goto ckWN; else goto ckWz;
  ckWN:
      I64[(young<ckWF> + 8)] = ckWF;
      R2 = _sk4h::I64;
      call GHC.Integer.Type.smallInteger_info(R2) returns to ckWF, args: 8, res: 8, upd: 24;
  ckWF:
      _sk4J::P64 = R1;
      I64[(young<ckWJ> + 8)] = ckWJ;
      R4 = GHC.Types.[]_closure+1;
      R3 = _sk4J::P64;
      R2 = 0;
      call GHC.Show.$w$cshowsPrec1_info(R4,
                                        R3,
                                        R2) returns to ckWJ, args: 8, res: 8, upd: 24;
  ckWJ:
      _sk4M::P64 = R2;
      _sk4L::P64 = R1;
      Hp = Hp + 48;
      if (Hp > HpLim) goto ckWR; else goto ckWQ;
  ckWR:
      HpAlloc = 48;
      R2 = _sk4M::P64;
      R1 = _sk4L::P64;
      call stg_gc_pp(R2, R1) returns to ckWJ, args: 8, res: 8, upd: 24;
  ckWQ:
      I64[Hp - 40] = :_con_info;
      P64[Hp - 32] = lvl14_rjVg_closure+1;
      P64[Hp - 24] = _ckV7::P64;
      _ckWL::P64 = Hp - 38;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _sk4L::P64;
      P64[Hp] = _sk4M::P64;
      _ckWM::P64 = Hp - 14;
      R3 = _ckWL::P64;
      R2 = _ckWM::P64;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
  ckWz:
      I64[(young<ckWq> + 8)] = ckWq;
      R2 = _sk4g::I64;
      call GHC.Integer.Type.wordToInteger_info(R2) returns to ckWq, args: 8, res: 8, upd: 24;
  ckWq:
      _sk4D::P64 = R1;
      I64[(young<ckWu> + 8)] = ckWu;
      R4 = GHC.Types.[]_closure+1;
      R3 = _sk4D::P64;
      R2 = 0;
      call GHC.Show.$w$cshowsPrec1_info(R4,
                                        R3,
                                        R2) returns to ckWu, args: 8, res: 8, upd: 24;
  ckWu:
      _sk4G::P64 = R2;
      _sk4F::P64 = R1;
      Hp = Hp + 48;
      if (Hp > HpLim) goto ckWD; else goto ckWC;
  ckWD:
      HpAlloc = 48;
      R2 = _sk4G::P64;
      R1 = _sk4F::P64;
      call stg_gc_pp(R2, R1) returns to ckWu, args: 8, res: 8, upd: 24;
  ckWC:
      I64[Hp - 40] = :_con_info;
      P64[Hp - 32] = lvl14_rjVg_closure+1;
      P64[Hp - 24] = _ckV7::P64;
      _ckWw::P64 = Hp - 38;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _sk4F::P64;
      P64[Hp] = _sk4G::P64;
      _ckWx::P64 = Hp - 14;
      R3 = _ckWw::P64;
      R2 = _ckWx::P64;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:54.547001 UTC

{offset
  ckWe:
      _sk4P::P64 = R1;
      if ((Sp + 8) - 56 < SpLim) goto ckWf; else goto ckWg;
  ckWg:
      if (HpLim == 0) goto ckWf; else goto ckWh;
  ckWf:
      R1 = _sk4P::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckWh:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _sk4P::P64;
      _sk33::P64 = P64[_sk4P::P64 + 16];
      _sk49::P64 = P64[_sk4P::P64 + 24];
      _sk3m::I64 = I64[_sk4P::P64 + 32];
      _sk3x::I64 = I64[_sk4P::P64 + 40];
      I64[Sp - 48] = ckV0;
      R3 = 0;
      R2 = _sk49::P64;
      P64[Sp - 40] = _sk33::P64;
      I64[Sp - 32] = _sk3m::I64;
      I64[Sp - 24] = _sk3x::I64;
      Sp = Sp - 48;
      call $wgo2_rjVk_info(R3,
                           R2) returns to ckV0, args: 8, res: 8, upd: 24;
  ckV0:
      _sk33::P64 = P64[Sp + 8];
      _sk3m::I64 = I64[Sp + 16];
      _sk3x::I64 = I64[Sp + 24];
      _sk4g::I64 = R1;
      Hp = Hp + 40;
      if (Hp > HpLim) goto ckWk; else goto ckWj;
  ckWk:
      HpAlloc = 40;
      R1 = _sk4g::I64;
      call stg_gc_unbx_r1(R1) returns to ckV0, args: 8, res: 8, upd: 24;
  ckWj:
      _ckV4::I64 = _sk4g::I64;
      _sk4h::I64 = _ckV4::I64;
      I64[Hp - 32] = a8_sk4i_info;
      P64[Hp - 16] = _sk33::P64;
      I64[Hp - 8] = _sk3m::I64;
      I64[Hp] = _sk3x::I64;
      _ckV7::P64 = Hp - 32;
      _ckWl::I64 = %MO_S_Ge_W64(_sk4h::I64, 0);
      _sk4B::I64 = _ckWl::I64;
      if (_sk4B::I64 != 0) goto ckWN; else goto ckWz;
  ckWN:
      I64[Sp + 16] = ckWF;
      R2 = _sk4h::I64;
      P64[Sp + 24] = _ckV7::P64;
      Sp = Sp + 16;
      call GHC.Integer.Type.smallInteger_info(R2) returns to ckWF, args: 8, res: 8, upd: 24;
  ckWF:
      _ckV7::P64 = P64[Sp + 8];
      _sk4J::P64 = R1;
      I64[Sp] = ckWJ;
      R4 = GHC.Types.[]_closure+1;
      R3 = _sk4J::P64;
      R2 = 0;
      call GHC.Show.$w$cshowsPrec1_info(R4,
                                        R3,
                                        R2) returns to ckWJ, args: 8, res: 8, upd: 24;
  ckWJ:
      _ckV7::P64 = P64[Sp + 8];
      _sk4M::P64 = R2;
      _sk4L::P64 = R1;
      Hp = Hp + 48;
      if (Hp > HpLim) goto ckWR; else goto ckWQ;
  ckWR:
      HpAlloc = 48;
      R2 = _sk4M::P64;
      R1 = _sk4L::P64;
      call stg_gc_pp(R2, R1) returns to ckWJ, args: 8, res: 8, upd: 24;
  ckWQ:
      I64[Hp - 40] = :_con_info;
      P64[Hp - 32] = lvl14_rjVg_closure+1;
      P64[Hp - 24] = _ckV7::P64;
      _ckWL::P64 = Hp - 38;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _sk4L::P64;
      P64[Hp] = _sk4M::P64;
      _ckWM::P64 = Hp - 14;
      R3 = _ckWL::P64;
      R2 = _ckWM::P64;
      Sp = Sp + 16;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
  ckWz:
      I64[Sp + 16] = ckWq;
      R2 = _sk4g::I64;
      P64[Sp + 24] = _ckV7::P64;
      Sp = Sp + 16;
      call GHC.Integer.Type.wordToInteger_info(R2) returns to ckWq, args: 8, res: 8, upd: 24;
  ckWq:
      _ckV7::P64 = P64[Sp + 8];
      _sk4D::P64 = R1;
      I64[Sp] = ckWu;
      R4 = GHC.Types.[]_closure+1;
      R3 = _sk4D::P64;
      R2 = 0;
      call GHC.Show.$w$cshowsPrec1_info(R4,
                                        R3,
                                        R2) returns to ckWu, args: 8, res: 8, upd: 24;
  ckWu:
      _ckV7::P64 = P64[Sp + 8];
      _sk4G::P64 = R2;
      _sk4F::P64 = R1;
      Hp = Hp + 48;
      if (Hp > HpLim) goto ckWD; else goto ckWC;
  ckWD:
      HpAlloc = 48;
      R2 = _sk4G::P64;
      R1 = _sk4F::P64;
      call stg_gc_pp(R2, R1) returns to ckWu, args: 8, res: 8, upd: 24;
  ckWC:
      I64[Hp - 40] = :_con_info;
      P64[Hp - 32] = lvl14_rjVg_closure+1;
      P64[Hp - 24] = _ckV7::P64;
      _ckWw::P64 = Hp - 38;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _sk4F::P64;
      P64[Hp] = _sk4G::P64;
      _ckWx::P64 = Hp - 14;
      R3 = _ckWw::P64;
      R2 = _ckWx::P64;
      Sp = Sp + 16;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:54.552863 UTC

{offset
  ckWe:
      _sk4P::P64 = R1;
      if ((Sp + -48) < SpLim) goto ckWf; else goto ckWg;
  ckWg:
      if (HpLim == 0) goto ckWf; else goto ckWh;
  ckWf:
      R1 = _sk4P::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckWh:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _sk4P::P64;
      I64[Sp - 48] = ckV0;
      R3 = 0;
      R2 = P64[_sk4P::P64 + 24];
      P64[Sp - 40] = P64[_sk4P::P64 + 16];
      I64[Sp - 32] = I64[_sk4P::P64 + 32];
      I64[Sp - 24] = I64[_sk4P::P64 + 40];
      Sp = Sp - 48;
      call $wgo2_rjVk_info(R3,
                           R2) returns to ckV0, args: 8, res: 8, upd: 24;
  ckV0:
      Hp = Hp + 40;
      if (Hp > HpLim) goto ckWk; else goto ckWj;
  ckWk:
      HpAlloc = 40;
      R1 = R1;
      call stg_gc_unbx_r1(R1) returns to ckV0, args: 8, res: 8, upd: 24;
  ckWj:
      I64[Hp - 32] = a8_sk4i_info;
      P64[Hp - 16] = P64[Sp + 8];
      I64[Hp - 8] = I64[Sp + 16];
      I64[Hp] = I64[Sp + 24];
      _ckV7::P64 = Hp - 32;
      if (%MO_S_Ge_W64(R1, 0)) goto ckWN; else goto ckWz;
  ckWN:
      I64[Sp + 16] = ckWF;
      R2 = R1;
      P64[Sp + 24] = _ckV7::P64;
      Sp = Sp + 16;
      call GHC.Integer.Type.smallInteger_info(R2) returns to ckWF, args: 8, res: 8, upd: 24;
  ckWF:
      I64[Sp] = ckWJ;
      R4 = GHC.Types.[]_closure+1;
      R3 = R1;
      R2 = 0;
      call GHC.Show.$w$cshowsPrec1_info(R4,
                                        R3,
                                        R2) returns to ckWJ, args: 8, res: 8, upd: 24;
  ckWJ:
      Hp = Hp + 48;
      if (Hp > HpLim) goto ckWR; else goto ckWQ;
  ckWR:
      HpAlloc = 48;
      R2 = R2;
      R1 = R1;
      call stg_gc_pp(R2, R1) returns to ckWJ, args: 8, res: 8, upd: 24;
  ckWQ:
      I64[Hp - 40] = :_con_info;
      P64[Hp - 32] = lvl14_rjVg_closure+1;
      P64[Hp - 24] = P64[Sp + 8];
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = R1;
      P64[Hp] = R2;
      R3 = Hp - 38;
      R2 = Hp - 14;
      Sp = Sp + 16;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
  ckWz:
      I64[Sp + 16] = ckWq;
      R2 = R1;
      P64[Sp + 24] = _ckV7::P64;
      Sp = Sp + 16;
      call GHC.Integer.Type.wordToInteger_info(R2) returns to ckWq, args: 8, res: 8, upd: 24;
  ckWq:
      I64[Sp] = ckWu;
      R4 = GHC.Types.[]_closure+1;
      R3 = R1;
      R2 = 0;
      call GHC.Show.$w$cshowsPrec1_info(R4,
                                        R3,
                                        R2) returns to ckWu, args: 8, res: 8, upd: 24;
  ckWu:
      Hp = Hp + 48;
      if (Hp > HpLim) goto ckWD; else goto ckWC;
  ckWD:
      HpAlloc = 48;
      R2 = R2;
      R1 = R1;
      call stg_gc_pp(R2, R1) returns to ckWu, args: 8, res: 8, upd: 24;
  ckWC:
      I64[Hp - 40] = :_con_info;
      P64[Hp - 32] = lvl14_rjVg_closure+1;
      P64[Hp - 24] = P64[Sp + 8];
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = R1;
      P64[Hp] = R2;
      R3 = Hp - 38;
      R2 = Hp - 14;
      Sp = Sp + 16;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:54.558387 UTC

[(ckV0,
  {GHC.Integer.Type.wordToInteger_closure,
   GHC.Show.$w$cshowsPrec1_closure, a8_sk4i_closure}),
 (ckWe,
  {GHC.Integer.Type.wordToInteger_closure,
   GHC.Show.$w$cshowsPrec1_closure, a8_sk4i_closure}),
 (ckWf, {}),
 (ckWg,
  {GHC.Integer.Type.wordToInteger_closure,
   GHC.Show.$w$cshowsPrec1_closure, a8_sk4i_closure}),
 (ckWh,
  {GHC.Integer.Type.wordToInteger_closure,
   GHC.Show.$w$cshowsPrec1_closure, a8_sk4i_closure}),
 (ckWj,
  {GHC.Integer.Type.wordToInteger_closure,
   GHC.Show.$w$cshowsPrec1_closure, a8_sk4i_closure}),
 (ckWk,
  {GHC.Integer.Type.wordToInteger_closure,
   GHC.Show.$w$cshowsPrec1_closure, a8_sk4i_closure}),
 (ckWq, {GHC.Show.$w$cshowsPrec1_closure}), (ckWu, {}),
 (ckWz,
  {GHC.Integer.Type.wordToInteger_closure,
   GHC.Show.$w$cshowsPrec1_closure}),
 (ckWC, {}), (ckWD, {}), (ckWF, {GHC.Show.$w$cshowsPrec1_closure}),
 (ckWJ, {}), (ckWN, {GHC.Show.$w$cshowsPrec1_closure}), (ckWQ, {}),
 (ckWR, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:54.559932 UTC

sat_sk4P_entry() //  [R1]
        { info_tbl: [(ckV0,
                      label: block_ckV0_info
                      rep:StackRep [False, True, True]),
                     (ckWe,
                      label: sat_sk4P_info
                      rep:HeapRep 2 ptrs 2 nonptrs { Thunk }),
                     (ckWq,
                      label: block_ckWq_info
                      rep:StackRep [False]),
                     (ckWu,
                      label: block_ckWu_info
                      rep:StackRep [False]),
                     (ckWF,
                      label: block_ckWF_info
                      rep:StackRep [False]),
                     (ckWJ,
                      label: block_ckWJ_info
                      rep:StackRep [False])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckWe:
          _sk4P::P64 = R1;
          if ((Sp + -48) < SpLim) goto ckWf; else goto ckWg;
      ckWg:
          if (HpLim == 0) goto ckWf; else goto ckWh;
      ckWf:
          R1 = _sk4P::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckWh:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _sk4P::P64;
          I64[Sp - 48] = ckV0;
          R3 = 0;
          R2 = P64[_sk4P::P64 + 24];
          P64[Sp - 40] = P64[_sk4P::P64 + 16];
          I64[Sp - 32] = I64[_sk4P::P64 + 32];
          I64[Sp - 24] = I64[_sk4P::P64 + 40];
          Sp = Sp - 48;
          call $wgo2_rjVk_info(R3,
                               R2) returns to ckV0, args: 8, res: 8, upd: 24;
      ckV0:
          Hp = Hp + 40;
          if (Hp > HpLim) goto ckWk; else goto ckWj;
      ckWk:
          HpAlloc = 40;
          R1 = R1;
          call stg_gc_unbx_r1(R1) returns to ckV0, args: 8, res: 8, upd: 24;
      ckWj:
          I64[Hp - 32] = a8_sk4i_info;
          P64[Hp - 16] = P64[Sp + 8];
          I64[Hp - 8] = I64[Sp + 16];
          I64[Hp] = I64[Sp + 24];
          _ckV7::P64 = Hp - 32;
          if (%MO_S_Ge_W64(R1, 0)) goto ckWN; else goto ckWz;
      ckWN:
          I64[Sp + 16] = ckWF;
          R2 = R1;
          P64[Sp + 24] = _ckV7::P64;
          Sp = Sp + 16;
          call GHC.Integer.Type.smallInteger_info(R2) returns to ckWF, args: 8, res: 8, upd: 24;
      ckWF:
          I64[Sp] = ckWJ;
          R4 = GHC.Types.[]_closure+1;
          R3 = R1;
          R2 = 0;
          call GHC.Show.$w$cshowsPrec1_info(R4,
                                            R3,
                                            R2) returns to ckWJ, args: 8, res: 8, upd: 24;
      ckWJ:
          Hp = Hp + 48;
          if (Hp > HpLim) goto ckWR; else goto ckWQ;
      ckWR:
          HpAlloc = 48;
          R2 = R2;
          R1 = R1;
          call stg_gc_pp(R2, R1) returns to ckWJ, args: 8, res: 8, upd: 24;
      ckWQ:
          I64[Hp - 40] = :_con_info;
          P64[Hp - 32] = lvl14_rjVg_closure+1;
          P64[Hp - 24] = P64[Sp + 8];
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = R1;
          P64[Hp] = R2;
          R3 = Hp - 38;
          R2 = Hp - 14;
          Sp = Sp + 16;
          call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
      ckWz:
          I64[Sp + 16] = ckWq;
          R2 = R1;
          P64[Sp + 24] = _ckV7::P64;
          Sp = Sp + 16;
          call GHC.Integer.Type.wordToInteger_info(R2) returns to ckWq, args: 8, res: 8, upd: 24;
      ckWq:
          I64[Sp] = ckWu;
          R4 = GHC.Types.[]_closure+1;
          R3 = R1;
          R2 = 0;
          call GHC.Show.$w$cshowsPrec1_info(R4,
                                            R3,
                                            R2) returns to ckWu, args: 8, res: 8, upd: 24;
      ckWu:
          Hp = Hp + 48;
          if (Hp > HpLim) goto ckWD; else goto ckWC;
      ckWD:
          HpAlloc = 48;
          R2 = R2;
          R1 = R1;
          call stg_gc_pp(R2, R1) returns to ckWu, args: 8, res: 8, upd: 24;
      ckWC:
          I64[Hp - 40] = :_con_info;
          P64[Hp - 32] = lvl14_rjVg_closure+1;
          P64[Hp - 24] = P64[Sp + 8];
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = R1;
          P64[Hp] = R2;
          R3 = Hp - 38;
          R2 = Hp - 14;
          Sp = Sp + 16;
          call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:54.565523 UTC

sat_sk4P_entry() //  [R1]
        { info_tbl: [(ckV0,
                      label: block_ckV0_info
                      rep:StackRep [False, True, True]),
                     (ckWe,
                      label: sat_sk4P_info
                      rep:HeapRep 2 ptrs 2 nonptrs { Thunk }),
                     (ckWq,
                      label: block_ckWq_info
                      rep:StackRep [False]),
                     (ckWu,
                      label: block_ckWu_info
                      rep:StackRep [False]),
                     (ckWF,
                      label: block_ckWF_info
                      rep:StackRep [False]),
                     (ckWJ,
                      label: block_ckWJ_info
                      rep:StackRep [False])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckWe:
          _sk4P::P64 = R1;
          if ((Sp + -48) < SpLim) goto ckWf; else goto ckWg;
      ckWg:
          if (HpLim == 0) goto ckWf; else goto ckWh;
      ckWf:
          R1 = _sk4P::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckWh:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _sk4P::P64;
          I64[Sp - 48] = ckV0;
          R3 = 0;
          R2 = P64[_sk4P::P64 + 24];
          P64[Sp - 40] = P64[_sk4P::P64 + 16];
          I64[Sp - 32] = I64[_sk4P::P64 + 32];
          I64[Sp - 24] = I64[_sk4P::P64 + 40];
          Sp = Sp - 48;
          call $wgo2_rjVk_info(R3,
                               R2) returns to ckV0, args: 8, res: 8, upd: 24;
      ckV0:
          Hp = Hp + 40;
          if (Hp > HpLim) goto ckWk; else goto ckWj;
      ckWk:
          HpAlloc = 40;
          R1 = R1;
          call stg_gc_unbx_r1(R1) returns to ckV0, args: 8, res: 8, upd: 24;
      ckWj:
          I64[Hp - 32] = a8_sk4i_info;
          P64[Hp - 16] = P64[Sp + 8];
          I64[Hp - 8] = I64[Sp + 16];
          I64[Hp] = I64[Sp + 24];
          _ckV7::P64 = Hp - 32;
          if (%MO_S_Ge_W64(R1, 0)) goto ckWN; else goto ckWz;
      ckWN:
          I64[Sp + 16] = ckWF;
          R2 = R1;
          P64[Sp + 24] = _ckV7::P64;
          Sp = Sp + 16;
          call GHC.Integer.Type.smallInteger_info(R2) returns to ckWF, args: 8, res: 8, upd: 24;
      ckWF:
          I64[Sp] = ckWJ;
          R4 = GHC.Types.[]_closure+1;
          R3 = R1;
          R2 = 0;
          call GHC.Show.$w$cshowsPrec1_info(R4,
                                            R3,
                                            R2) returns to ckWJ, args: 8, res: 8, upd: 24;
      ckWJ:
          Hp = Hp + 48;
          if (Hp > HpLim) goto ckWR; else goto ckWQ;
      ckWR:
          HpAlloc = 48;
          R2 = R2;
          R1 = R1;
          call stg_gc_pp(R2, R1) returns to ckWJ, args: 8, res: 8, upd: 24;
      ckWQ:
          I64[Hp - 40] = :_con_info;
          P64[Hp - 32] = lvl14_rjVg_closure+1;
          P64[Hp - 24] = P64[Sp + 8];
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = R1;
          P64[Hp] = R2;
          R3 = Hp - 38;
          R2 = Hp - 14;
          Sp = Sp + 16;
          call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
      ckWz:
          I64[Sp + 16] = ckWq;
          R2 = R1;
          P64[Sp + 24] = _ckV7::P64;
          Sp = Sp + 16;
          call GHC.Integer.Type.wordToInteger_info(R2) returns to ckWq, args: 8, res: 8, upd: 24;
      ckWq:
          I64[Sp] = ckWu;
          R4 = GHC.Types.[]_closure+1;
          R3 = R1;
          R2 = 0;
          call GHC.Show.$w$cshowsPrec1_info(R4,
                                            R3,
                                            R2) returns to ckWu, args: 8, res: 8, upd: 24;
      ckWu:
          Hp = Hp + 48;
          if (Hp > HpLim) goto ckWD; else goto ckWC;
      ckWD:
          HpAlloc = 48;
          R2 = R2;
          R1 = R1;
          call stg_gc_pp(R2, R1) returns to ckWu, args: 8, res: 8, upd: 24;
      ckWC:
          I64[Hp - 40] = :_con_info;
          P64[Hp - 32] = lvl14_rjVg_closure+1;
          P64[Hp - 24] = P64[Sp + 8];
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = R1;
          P64[Hp] = R2;
          R3 = Hp - 38;
          R2 = Hp - 14;
          Sp = Sp + 16;
          call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:54.571135 UTC

{offset
  ckWT:
      _sk4R::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckWU; else goto ckWV;
  ckWV:
      Hp = Hp + 72;
      if (Hp > HpLim) goto ckWX; else goto ckWW;
  ckWX:
      HpAlloc = 72;
      goto ckWU;
  ckWU:
      R1 = _sk4R::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckWW:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sk4R::P64;
      _sk33::P64 = P64[_sk4R::P64 + 16];
      _sk49::P64 = P64[_sk4R::P64 + 24];
      _sk3m::I64 = I64[_sk4R::P64 + 32];
      _sk3x::I64 = I64[_sk4R::P64 + 40];
      I64[Hp - 64] = sat_sk4P_info;
      P64[Hp - 48] = _sk33::P64;
      P64[Hp - 40] = _sk49::P64;
      I64[Hp - 32] = _sk3m::I64;
      I64[Hp - 24] = _sk3x::I64;
      _ckUW::P64 = Hp - 64;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = lvl14_rjVg_closure+1;
      P64[Hp] = _ckUW::P64;
      _ckWS::P64 = Hp - 14;
      R3 = _ckWS::P64;
      R2 = lvl17_rjVj_closure;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:54.572859 UTC

{offset
  ckWT:
      _sk4R::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckWU; else goto ckWV;
  ckWV:
      Hp = Hp + 72;
      if (Hp > HpLim) goto ckWX; else goto ckWW;
  ckWX:
      HpAlloc = 72;
      goto ckWU;
  ckWU:
      R1 = _sk4R::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckWW:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sk4R::P64;
      _sk33::P64 = P64[_sk4R::P64 + 16];
      _sk49::P64 = P64[_sk4R::P64 + 24];
      _sk3m::I64 = I64[_sk4R::P64 + 32];
      _sk3x::I64 = I64[_sk4R::P64 + 40];
      I64[Hp - 64] = sat_sk4P_info;
      P64[Hp - 48] = _sk33::P64;
      P64[Hp - 40] = _sk49::P64;
      I64[Hp - 32] = _sk3m::I64;
      I64[Hp - 24] = _sk3x::I64;
      _ckUW::P64 = Hp - 64;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = lvl14_rjVg_closure+1;
      P64[Hp] = _ckUW::P64;
      _ckWS::P64 = Hp - 14;
      R3 = _ckWS::P64;
      R2 = lvl17_rjVj_closure;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:54.574567 UTC

{offset
  ckWT:
      _sk4R::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckWU; else goto ckWV;
  ckWV:
      Hp = Hp + 72;
      if (Hp > HpLim) goto ckWX; else goto ckWW;
  ckWX:
      HpAlloc = 72;
      goto ckWU;
  ckWU:
      R1 = _sk4R::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckWW:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sk4R::P64;
      _sk33::P64 = P64[_sk4R::P64 + 16];
      _sk49::P64 = P64[_sk4R::P64 + 24];
      _sk3m::I64 = I64[_sk4R::P64 + 32];
      _sk3x::I64 = I64[_sk4R::P64 + 40];
      I64[Hp - 64] = sat_sk4P_info;
      P64[Hp - 48] = _sk33::P64;
      P64[Hp - 40] = _sk49::P64;
      I64[Hp - 32] = _sk3m::I64;
      I64[Hp - 24] = _sk3x::I64;
      _ckUW::P64 = Hp - 64;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = lvl14_rjVg_closure+1;
      P64[Hp] = _ckUW::P64;
      _ckWS::P64 = Hp - 14;
      R3 = _ckWS::P64;
      R2 = lvl17_rjVj_closure;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:54.576321 UTC

{offset
  ckWT:
      _sk4R::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto ckWU; else goto ckWV;
  ckWV:
      Hp = Hp + 72;
      if (Hp > HpLim) goto ckWX; else goto ckWW;
  ckWX:
      HpAlloc = 72;
      goto ckWU;
  ckWU:
      R1 = _sk4R::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckWW:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _sk4R::P64;
      _sk33::P64 = P64[_sk4R::P64 + 16];
      _sk49::P64 = P64[_sk4R::P64 + 24];
      _sk3m::I64 = I64[_sk4R::P64 + 32];
      _sk3x::I64 = I64[_sk4R::P64 + 40];
      I64[Hp - 64] = sat_sk4P_info;
      P64[Hp - 48] = _sk33::P64;
      P64[Hp - 40] = _sk49::P64;
      I64[Hp - 32] = _sk3m::I64;
      I64[Hp - 24] = _sk3x::I64;
      _ckUW::P64 = Hp - 64;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = lvl14_rjVg_closure+1;
      P64[Hp] = _ckUW::P64;
      _ckWS::P64 = Hp - 14;
      R3 = _ckWS::P64;
      R2 = lvl17_rjVj_closure;
      Sp = Sp - 16;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:54.57806 UTC

{offset
  ckWT:
      _sk4R::P64 = R1;
      if ((Sp + -16) < SpLim) goto ckWU; else goto ckWV;
  ckWV:
      Hp = Hp + 72;
      if (Hp > HpLim) goto ckWX; else goto ckWW;
  ckWX:
      HpAlloc = 72;
      goto ckWU;
  ckWU:
      R1 = _sk4R::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckWW:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _sk4R::P64;
      _sk33::P64 = P64[_sk4R::P64 + 16];
      _sk49::P64 = P64[_sk4R::P64 + 24];
      _sk3m::I64 = I64[_sk4R::P64 + 32];
      _sk3x::I64 = I64[_sk4R::P64 + 40];
      I64[Hp - 64] = sat_sk4P_info;
      P64[Hp - 48] = _sk33::P64;
      P64[Hp - 40] = _sk49::P64;
      I64[Hp - 32] = _sk3m::I64;
      I64[Hp - 24] = _sk3x::I64;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = lvl14_rjVg_closure+1;
      P64[Hp] = Hp - 64;
      R3 = Hp - 14;
      R2 = lvl17_rjVj_closure;
      Sp = Sp - 16;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:54.579919 UTC

[(ckWT, {lvl17_rjVj_closure, sat_sk4P_closure}), (ckWU, {}),
 (ckWV, {lvl17_rjVj_closure, sat_sk4P_closure}),
 (ckWW, {lvl17_rjVj_closure, sat_sk4P_closure}), (ckWX, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:54.581041 UTC

sat_sk4R_entry() //  [R1]
        { info_tbl: [(ckWT,
                      label: sat_sk4R_info
                      rep:HeapRep 2 ptrs 2 nonptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckWT:
          _sk4R::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckWU; else goto ckWV;
      ckWV:
          Hp = Hp + 72;
          if (Hp > HpLim) goto ckWX; else goto ckWW;
      ckWX:
          HpAlloc = 72;
          goto ckWU;
      ckWU:
          R1 = _sk4R::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckWW:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _sk4R::P64;
          _sk33::P64 = P64[_sk4R::P64 + 16];
          _sk49::P64 = P64[_sk4R::P64 + 24];
          _sk3m::I64 = I64[_sk4R::P64 + 32];
          _sk3x::I64 = I64[_sk4R::P64 + 40];
          I64[Hp - 64] = sat_sk4P_info;
          P64[Hp - 48] = _sk33::P64;
          P64[Hp - 40] = _sk49::P64;
          I64[Hp - 32] = _sk3m::I64;
          I64[Hp - 24] = _sk3x::I64;
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = lvl14_rjVg_closure+1;
          P64[Hp] = Hp - 64;
          R3 = Hp - 14;
          R2 = lvl17_rjVj_closure;
          Sp = Sp - 16;
          call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:54.582986 UTC

sat_sk4R_entry() //  [R1]
        { info_tbl: [(ckWT,
                      label: sat_sk4R_info
                      rep:HeapRep 2 ptrs 2 nonptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckWT:
          _sk4R::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckWU; else goto ckWV;
      ckWV:
          Hp = Hp + 72;
          if (Hp > HpLim) goto ckWX; else goto ckWW;
      ckWX:
          HpAlloc = 72;
          goto ckWU;
      ckWU:
          R1 = _sk4R::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckWW:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _sk4R::P64;
          _sk33::P64 = P64[_sk4R::P64 + 16];
          _sk49::P64 = P64[_sk4R::P64 + 24];
          _sk3m::I64 = I64[_sk4R::P64 + 32];
          _sk3x::I64 = I64[_sk4R::P64 + 40];
          I64[Hp - 64] = sat_sk4P_info;
          P64[Hp - 48] = _sk33::P64;
          P64[Hp - 40] = _sk49::P64;
          I64[Hp - 32] = _sk3m::I64;
          I64[Hp - 24] = _sk3x::I64;
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = lvl14_rjVg_closure+1;
          P64[Hp] = Hp - 64;
          R3 = Hp - 14;
          R2 = lvl17_rjVj_closure;
          Sp = Sp - 16;
          call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:54.58495 UTC

{offset
  ckWY:
      _sk4T::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckX1; else goto ckX2;
  ckX2:
      if (HpLim == 0) goto ckX1; else goto ckX3;
  ckX1:
      R1 = _sk4T::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckX3:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sk4T::P64;
      _sk33::P64 = P64[_sk4T::P64 + 16];
      _sk46::P64 = P64[_sk4T::P64 + 24];
      _sk49::P64 = P64[_sk4T::P64 + 32];
      _sk3m::I64 = I64[_sk4T::P64 + 40];
      _sk3x::I64 = I64[_sk4T::P64 + 48];
      I64[(young<ckUN> + 8)] = ckUN;
      R1 = _sk46::P64;
      if (R1 & 7 != 0) goto ckUN; else goto ckUO;
  ckUO:
      call (I64[R1])(R1) returns to ckUN, args: 8, res: 8, upd: 24;
  ckUN:
      _sk4d::P64 = R1;
      Hp = Hp + 72;
      if (Hp > HpLim) goto ckX6; else goto ckX5;
  ckX6:
      HpAlloc = 72;
      R1 = _sk4d::P64;
      call stg_gc_unpt_r1(R1) returns to ckUN, args: 8, res: 8, upd: 24;
  ckX5:
      _sk4e::F64 = F64[_sk4d::P64 + 7];
      I64[Hp - 64] = sat_sk4R_info;
      P64[Hp - 48] = _sk33::P64;
      P64[Hp - 40] = _sk49::P64;
      I64[Hp - 32] = _sk3m::I64;
      I64[Hp - 24] = _sk3x::I64;
      _ckUS::P64 = Hp - 64;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = lvl14_rjVg_closure+1;
      P64[Hp] = _ckUS::P64;
      _ckWZ::P64 = Hp - 14;
      I64[(young<ckX0> + 8)] = ckX0;
      D1 = _sk4e::F64;
      R3 = GHC.Show.shows18_closure;
      R2 = GHC.Float.$fShowDouble_$sshowFloat_closure+1;
      I64[(young<ckX0> + 24)] = stg_ap_p_info;
      P64[(young<ckX0> + 16)] = GHC.Types.[]_closure+1;
      call GHC.Float.$w$sshowSignedFloat_info(D1,
                                              R3,
                                              R2) returns to ckX0, args: 24, res: 8, upd: 24;
  ckX0:
      _sk4f::P64 = R1;
      R3 = _ckWZ::P64;
      R2 = _sk4f::P64;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:54.587785 UTC

{offset
  ckWY:
      _sk4T::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckX1; else goto ckX2;
  ckX2:
      if (HpLim == 0) goto ckX1; else goto ckX3;
  ckX1:
      R1 = _sk4T::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckX3:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sk4T::P64;
      _sk33::P64 = P64[_sk4T::P64 + 16];
      _sk46::P64 = P64[_sk4T::P64 + 24];
      _sk49::P64 = P64[_sk4T::P64 + 32];
      _sk3m::I64 = I64[_sk4T::P64 + 40];
      _sk3x::I64 = I64[_sk4T::P64 + 48];
      I64[(young<ckUN> + 8)] = ckUN;
      R1 = _sk46::P64;
      if (R1 & 7 != 0) goto ckUN; else goto ckUO;
  ckUO:
      call (I64[R1])(R1) returns to ckUN, args: 8, res: 8, upd: 24;
  ckUN:
      _sk4d::P64 = R1;
      Hp = Hp + 72;
      if (Hp > HpLim) goto ckX6; else goto ckX5;
  ckX6:
      HpAlloc = 72;
      R1 = _sk4d::P64;
      call stg_gc_unpt_r1(R1) returns to ckUN, args: 8, res: 8, upd: 24;
  ckX5:
      _sk4e::F64 = F64[_sk4d::P64 + 7];
      I64[Hp - 64] = sat_sk4R_info;
      P64[Hp - 48] = _sk33::P64;
      P64[Hp - 40] = _sk49::P64;
      I64[Hp - 32] = _sk3m::I64;
      I64[Hp - 24] = _sk3x::I64;
      _ckUS::P64 = Hp - 64;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = lvl14_rjVg_closure+1;
      P64[Hp] = _ckUS::P64;
      _ckWZ::P64 = Hp - 14;
      I64[(young<ckX0> + 8)] = ckX0;
      D1 = _sk4e::F64;
      R3 = GHC.Show.shows18_closure;
      R2 = GHC.Float.$fShowDouble_$sshowFloat_closure+1;
      I64[(young<ckX0> + 24)] = stg_ap_p_info;
      P64[(young<ckX0> + 16)] = GHC.Types.[]_closure+1;
      call GHC.Float.$w$sshowSignedFloat_info(D1,
                                              R3,
                                              R2) returns to ckX0, args: 24, res: 8, upd: 24;
  ckX0:
      _sk4f::P64 = R1;
      R3 = _ckWZ::P64;
      R2 = _sk4f::P64;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:54.590581 UTC

{offset
  ckWY:
      _sk4T::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckX1; else goto ckX2;
  ckX2:
      if (HpLim == 0) goto ckX1; else goto ckX3;
  ckX1:
      R1 = _sk4T::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckX3:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sk4T::P64;
      _sk33::P64 = P64[_sk4T::P64 + 16];
      _sk46::P64 = P64[_sk4T::P64 + 24];
      _sk49::P64 = P64[_sk4T::P64 + 32];
      _sk3m::I64 = I64[_sk4T::P64 + 40];
      _sk3x::I64 = I64[_sk4T::P64 + 48];
      I64[(young<ckUN> + 8)] = ckUN;
      R1 = _sk46::P64;
      if (R1 & 7 != 0) goto ckUN; else goto ckUO;
  ckUO:
      call (I64[R1])(R1) returns to ckUN, args: 8, res: 8, upd: 24;
  ckUN:
      _sk4d::P64 = R1;
      Hp = Hp + 72;
      if (Hp > HpLim) goto ckX6; else goto ckX5;
  ckX6:
      HpAlloc = 72;
      R1 = _sk4d::P64;
      call stg_gc_unpt_r1(R1) returns to ckUN, args: 8, res: 8, upd: 24;
  ckX5:
      _sk4e::F64 = F64[_sk4d::P64 + 7];
      I64[Hp - 64] = sat_sk4R_info;
      P64[Hp - 48] = _sk33::P64;
      P64[Hp - 40] = _sk49::P64;
      I64[Hp - 32] = _sk3m::I64;
      I64[Hp - 24] = _sk3x::I64;
      _ckUS::P64 = Hp - 64;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = lvl14_rjVg_closure+1;
      P64[Hp] = _ckUS::P64;
      _ckWZ::P64 = Hp - 14;
      I64[(young<ckX0> + 8)] = ckX0;
      D1 = _sk4e::F64;
      R3 = GHC.Show.shows18_closure;
      R2 = GHC.Float.$fShowDouble_$sshowFloat_closure+1;
      I64[(young<ckX0> + 24)] = stg_ap_p_info;
      P64[(young<ckX0> + 16)] = GHC.Types.[]_closure+1;
      call GHC.Float.$w$sshowSignedFloat_info(D1,
                                              R3,
                                              R2) returns to ckX0, args: 24, res: 8, upd: 24;
  ckX0:
      _sk4f::P64 = R1;
      R3 = _ckWZ::P64;
      R2 = _sk4f::P64;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:54.593708 UTC

{offset
  ckWY:
      _sk4T::P64 = R1;
      if ((Sp + 8) - 64 < SpLim) goto ckX1; else goto ckX2;
  ckX2:
      if (HpLim == 0) goto ckX1; else goto ckX3;
  ckX1:
      R1 = _sk4T::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckX3:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _sk4T::P64;
      _sk33::P64 = P64[_sk4T::P64 + 16];
      _sk46::P64 = P64[_sk4T::P64 + 24];
      _sk49::P64 = P64[_sk4T::P64 + 32];
      _sk3m::I64 = I64[_sk4T::P64 + 40];
      _sk3x::I64 = I64[_sk4T::P64 + 48];
      I64[Sp - 56] = ckUN;
      R1 = _sk46::P64;
      P64[Sp - 48] = _sk33::P64;
      I64[Sp - 40] = _sk3m::I64;
      I64[Sp - 32] = _sk3x::I64;
      P64[Sp - 24] = _sk49::P64;
      Sp = Sp - 56;
      if (R1 & 7 != 0) goto ckUN; else goto ckUO;
  ckUO:
      call (I64[R1])(R1) returns to ckUN, args: 8, res: 8, upd: 24;
  ckUN:
      _sk33::P64 = P64[Sp + 8];
      _sk3m::I64 = I64[Sp + 16];
      _sk3x::I64 = I64[Sp + 24];
      _sk49::P64 = P64[Sp + 32];
      _sk4d::P64 = R1;
      Hp = Hp + 72;
      if (Hp > HpLim) goto ckX6; else goto ckX5;
  ckX6:
      HpAlloc = 72;
      R1 = _sk4d::P64;
      call stg_gc_unpt_r1(R1) returns to ckUN, args: 8, res: 8, upd: 24;
  ckX5:
      _sk4e::F64 = F64[_sk4d::P64 + 7];
      I64[Hp - 64] = sat_sk4R_info;
      P64[Hp - 48] = _sk33::P64;
      P64[Hp - 40] = _sk49::P64;
      I64[Hp - 32] = _sk3m::I64;
      I64[Hp - 24] = _sk3x::I64;
      _ckUS::P64 = Hp - 64;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = lvl14_rjVg_closure+1;
      P64[Hp] = _ckUS::P64;
      _ckWZ::P64 = Hp - 14;
      I64[Sp + 24] = ckX0;
      D1 = _sk4e::F64;
      R3 = GHC.Show.shows18_closure;
      R2 = GHC.Float.$fShowDouble_$sshowFloat_closure+1;
      I64[Sp + 8] = stg_ap_p_info;
      P64[Sp + 16] = GHC.Types.[]_closure+1;
      P64[Sp + 32] = _ckWZ::P64;
      Sp = Sp + 8;
      call GHC.Float.$w$sshowSignedFloat_info(D1,
                                              R3,
                                              R2) returns to ckX0, args: 24, res: 8, upd: 24;
  ckX0:
      _ckWZ::P64 = P64[Sp + 8];
      _sk4f::P64 = R1;
      R3 = _ckWZ::P64;
      R2 = _sk4f::P64;
      Sp = Sp + 16;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:54.597154 UTC

{offset
  ckWY:
      _sk4T::P64 = R1;
      if ((Sp + -56) < SpLim) goto ckX1; else goto ckX2;
  ckX2:
      if (HpLim == 0) goto ckX1; else goto ckX3;
  ckX1:
      R1 = _sk4T::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckX3:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _sk4T::P64;
      I64[Sp - 56] = ckUN;
      R1 = P64[_sk4T::P64 + 24];
      P64[Sp - 48] = P64[_sk4T::P64 + 16];
      I64[Sp - 40] = I64[_sk4T::P64 + 40];
      I64[Sp - 32] = I64[_sk4T::P64 + 48];
      P64[Sp - 24] = P64[_sk4T::P64 + 32];
      Sp = Sp - 56;
      if (R1 & 7 != 0) goto ckUN; else goto ckUO;
  ckUO:
      call (I64[R1])(R1) returns to ckUN, args: 8, res: 8, upd: 24;
  ckUN:
      Hp = Hp + 72;
      if (Hp > HpLim) goto ckX6; else goto ckX5;
  ckX6:
      HpAlloc = 72;
      R1 = R1;
      call stg_gc_unpt_r1(R1) returns to ckUN, args: 8, res: 8, upd: 24;
  ckX5:
      _sk4e::F64 = F64[R1 + 7];
      I64[Hp - 64] = sat_sk4R_info;
      P64[Hp - 48] = P64[Sp + 8];
      P64[Hp - 40] = P64[Sp + 32];
      I64[Hp - 32] = I64[Sp + 16];
      I64[Hp - 24] = I64[Sp + 24];
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = lvl14_rjVg_closure+1;
      P64[Hp] = Hp - 64;
      I64[Sp + 24] = ckX0;
      D1 = _sk4e::F64;
      R3 = GHC.Show.shows18_closure;
      R2 = GHC.Float.$fShowDouble_$sshowFloat_closure+1;
      I64[Sp + 8] = stg_ap_p_info;
      P64[Sp + 16] = GHC.Types.[]_closure+1;
      P64[Sp + 32] = Hp - 14;
      Sp = Sp + 8;
      call GHC.Float.$w$sshowSignedFloat_info(D1,
                                              R3,
                                              R2) returns to ckX0, args: 24, res: 8, upd: 24;
  ckX0:
      R3 = P64[Sp + 8];
      R2 = R1;
      Sp = Sp + 16;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:54.600547 UTC

[(ckUN,
  {GHC.Float.$fShowDouble_$sshowFloat_closure, sat_sk4R_closure}),
 (ckUO,
  {GHC.Float.$fShowDouble_$sshowFloat_closure, sat_sk4R_closure}),
 (ckWY,
  {GHC.Float.$fShowDouble_$sshowFloat_closure, sat_sk4R_closure}),
 (ckX0, {}), (ckX1, {}),
 (ckX2,
  {GHC.Float.$fShowDouble_$sshowFloat_closure, sat_sk4R_closure}),
 (ckX3,
  {GHC.Float.$fShowDouble_$sshowFloat_closure, sat_sk4R_closure}),
 (ckX5,
  {GHC.Float.$fShowDouble_$sshowFloat_closure, sat_sk4R_closure}),
 (ckX6,
  {GHC.Float.$fShowDouble_$sshowFloat_closure, sat_sk4R_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:54.601516 UTC

sat_sk4T_entry() //  [R1]
        { info_tbl: [(ckUN,
                      label: block_ckUN_info
                      rep:StackRep [False, True, True, False]),
                     (ckWY,
                      label: sat_sk4T_info
                      rep:HeapRep 3 ptrs 2 nonptrs { Thunk }),
                     (ckX0,
                      label: block_ckX0_info
                      rep:StackRep [False])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckWY:
          _sk4T::P64 = R1;
          if ((Sp + -56) < SpLim) goto ckX1; else goto ckX2;
      ckX2:
          if (HpLim == 0) goto ckX1; else goto ckX3;
      ckX1:
          R1 = _sk4T::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckX3:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _sk4T::P64;
          I64[Sp - 56] = ckUN;
          R1 = P64[_sk4T::P64 + 24];
          P64[Sp - 48] = P64[_sk4T::P64 + 16];
          I64[Sp - 40] = I64[_sk4T::P64 + 40];
          I64[Sp - 32] = I64[_sk4T::P64 + 48];
          P64[Sp - 24] = P64[_sk4T::P64 + 32];
          Sp = Sp - 56;
          if (R1 & 7 != 0) goto ckUN; else goto ckUO;
      ckUO:
          call (I64[R1])(R1) returns to ckUN, args: 8, res: 8, upd: 24;
      ckUN:
          Hp = Hp + 72;
          if (Hp > HpLim) goto ckX6; else goto ckX5;
      ckX6:
          HpAlloc = 72;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to ckUN, args: 8, res: 8, upd: 24;
      ckX5:
          _sk4e::F64 = F64[R1 + 7];
          I64[Hp - 64] = sat_sk4R_info;
          P64[Hp - 48] = P64[Sp + 8];
          P64[Hp - 40] = P64[Sp + 32];
          I64[Hp - 32] = I64[Sp + 16];
          I64[Hp - 24] = I64[Sp + 24];
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = lvl14_rjVg_closure+1;
          P64[Hp] = Hp - 64;
          I64[Sp + 24] = ckX0;
          D1 = _sk4e::F64;
          R3 = GHC.Show.shows18_closure;
          R2 = GHC.Float.$fShowDouble_$sshowFloat_closure+1;
          I64[Sp + 8] = stg_ap_p_info;
          P64[Sp + 16] = GHC.Types.[]_closure+1;
          P64[Sp + 32] = Hp - 14;
          Sp = Sp + 8;
          call GHC.Float.$w$sshowSignedFloat_info(D1,
                                                  R3,
                                                  R2) returns to ckX0, args: 24, res: 8, upd: 24;
      ckX0:
          R3 = P64[Sp + 8];
          R2 = R1;
          Sp = Sp + 16;
          call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:54.604883 UTC

sat_sk4T_entry() //  [R1]
        { info_tbl: [(ckUN,
                      label: block_ckUN_info
                      rep:StackRep [False, True, True, False]),
                     (ckWY,
                      label: sat_sk4T_info
                      rep:HeapRep 3 ptrs 2 nonptrs { Thunk }),
                     (ckX0,
                      label: block_ckX0_info
                      rep:StackRep [False])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckWY:
          _sk4T::P64 = R1;
          if ((Sp + -56) < SpLim) goto ckX1; else goto ckX2;
      ckX2:
          if (HpLim == 0) goto ckX1; else goto ckX3;
      ckX1:
          R1 = _sk4T::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckX3:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _sk4T::P64;
          I64[Sp - 56] = ckUN;
          R1 = P64[_sk4T::P64 + 24];
          P64[Sp - 48] = P64[_sk4T::P64 + 16];
          I64[Sp - 40] = I64[_sk4T::P64 + 40];
          I64[Sp - 32] = I64[_sk4T::P64 + 48];
          P64[Sp - 24] = P64[_sk4T::P64 + 32];
          Sp = Sp - 56;
          if (R1 & 7 != 0) goto ckUN; else goto ckUO;
      ckUO:
          call (I64[R1])(R1) returns to ckUN, args: 8, res: 8, upd: 24;
      ckUN:
          Hp = Hp + 72;
          if (Hp > HpLim) goto ckX6; else goto ckX5;
      ckX6:
          HpAlloc = 72;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to ckUN, args: 8, res: 8, upd: 24;
      ckX5:
          _sk4e::F64 = F64[R1 + 7];
          I64[Hp - 64] = sat_sk4R_info;
          P64[Hp - 48] = P64[Sp + 8];
          P64[Hp - 40] = P64[Sp + 32];
          I64[Hp - 32] = I64[Sp + 16];
          I64[Hp - 24] = I64[Sp + 24];
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = lvl14_rjVg_closure+1;
          P64[Hp] = Hp - 64;
          I64[Sp + 24] = ckX0;
          D1 = _sk4e::F64;
          R3 = GHC.Show.shows18_closure;
          R2 = GHC.Float.$fShowDouble_$sshowFloat_closure+1;
          I64[Sp + 8] = stg_ap_p_info;
          P64[Sp + 16] = GHC.Types.[]_closure+1;
          P64[Sp + 32] = Hp - 14;
          Sp = Sp + 8;
          call GHC.Float.$w$sshowSignedFloat_info(D1,
                                                  R3,
                                                  R2) returns to ckX0, args: 24, res: 8, upd: 24;
      ckX0:
          R3 = P64[Sp + 8];
          R2 = R1;
          Sp = Sp + 16;
          call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:54.608301 UTC

{offset
  ckXc:
      _sk4V::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckXd; else goto ckXe;
  ckXe:
      Hp = Hp + 80;
      if (Hp > HpLim) goto ckXg; else goto ckXf;
  ckXg:
      HpAlloc = 80;
      goto ckXd;
  ckXd:
      R1 = _sk4V::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckXf:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sk4V::P64;
      _sk33::P64 = P64[_sk4V::P64 + 16];
      _sk46::P64 = P64[_sk4V::P64 + 24];
      _sk49::P64 = P64[_sk4V::P64 + 32];
      _sk3m::I64 = I64[_sk4V::P64 + 40];
      _sk3x::I64 = I64[_sk4V::P64 + 48];
      I64[Hp - 72] = sat_sk4T_info;
      P64[Hp - 56] = _sk33::P64;
      P64[Hp - 48] = _sk46::P64;
      P64[Hp - 40] = _sk49::P64;
      I64[Hp - 32] = _sk3m::I64;
      I64[Hp - 24] = _sk3x::I64;
      _ckUJ::P64 = Hp - 72;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = lvl14_rjVg_closure+1;
      P64[Hp] = _ckUJ::P64;
      _ckXb::P64 = Hp - 14;
      R3 = _ckXb::P64;
      R2 = lvl16_rjVi_closure;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:54.610094 UTC

{offset
  ckXc:
      _sk4V::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckXd; else goto ckXe;
  ckXe:
      Hp = Hp + 80;
      if (Hp > HpLim) goto ckXg; else goto ckXf;
  ckXg:
      HpAlloc = 80;
      goto ckXd;
  ckXd:
      R1 = _sk4V::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckXf:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sk4V::P64;
      _sk33::P64 = P64[_sk4V::P64 + 16];
      _sk46::P64 = P64[_sk4V::P64 + 24];
      _sk49::P64 = P64[_sk4V::P64 + 32];
      _sk3m::I64 = I64[_sk4V::P64 + 40];
      _sk3x::I64 = I64[_sk4V::P64 + 48];
      I64[Hp - 72] = sat_sk4T_info;
      P64[Hp - 56] = _sk33::P64;
      P64[Hp - 48] = _sk46::P64;
      P64[Hp - 40] = _sk49::P64;
      I64[Hp - 32] = _sk3m::I64;
      I64[Hp - 24] = _sk3x::I64;
      _ckUJ::P64 = Hp - 72;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = lvl14_rjVg_closure+1;
      P64[Hp] = _ckUJ::P64;
      _ckXb::P64 = Hp - 14;
      R3 = _ckXb::P64;
      R2 = lvl16_rjVi_closure;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:54.611889 UTC

{offset
  ckXc:
      _sk4V::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckXd; else goto ckXe;
  ckXe:
      Hp = Hp + 80;
      if (Hp > HpLim) goto ckXg; else goto ckXf;
  ckXg:
      HpAlloc = 80;
      goto ckXd;
  ckXd:
      R1 = _sk4V::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckXf:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sk4V::P64;
      _sk33::P64 = P64[_sk4V::P64 + 16];
      _sk46::P64 = P64[_sk4V::P64 + 24];
      _sk49::P64 = P64[_sk4V::P64 + 32];
      _sk3m::I64 = I64[_sk4V::P64 + 40];
      _sk3x::I64 = I64[_sk4V::P64 + 48];
      I64[Hp - 72] = sat_sk4T_info;
      P64[Hp - 56] = _sk33::P64;
      P64[Hp - 48] = _sk46::P64;
      P64[Hp - 40] = _sk49::P64;
      I64[Hp - 32] = _sk3m::I64;
      I64[Hp - 24] = _sk3x::I64;
      _ckUJ::P64 = Hp - 72;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = lvl14_rjVg_closure+1;
      P64[Hp] = _ckUJ::P64;
      _ckXb::P64 = Hp - 14;
      R3 = _ckXb::P64;
      R2 = lvl16_rjVi_closure;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:54.613717 UTC

{offset
  ckXc:
      _sk4V::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto ckXd; else goto ckXe;
  ckXe:
      Hp = Hp + 80;
      if (Hp > HpLim) goto ckXg; else goto ckXf;
  ckXg:
      HpAlloc = 80;
      goto ckXd;
  ckXd:
      R1 = _sk4V::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckXf:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _sk4V::P64;
      _sk33::P64 = P64[_sk4V::P64 + 16];
      _sk46::P64 = P64[_sk4V::P64 + 24];
      _sk49::P64 = P64[_sk4V::P64 + 32];
      _sk3m::I64 = I64[_sk4V::P64 + 40];
      _sk3x::I64 = I64[_sk4V::P64 + 48];
      I64[Hp - 72] = sat_sk4T_info;
      P64[Hp - 56] = _sk33::P64;
      P64[Hp - 48] = _sk46::P64;
      P64[Hp - 40] = _sk49::P64;
      I64[Hp - 32] = _sk3m::I64;
      I64[Hp - 24] = _sk3x::I64;
      _ckUJ::P64 = Hp - 72;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = lvl14_rjVg_closure+1;
      P64[Hp] = _ckUJ::P64;
      _ckXb::P64 = Hp - 14;
      R3 = _ckXb::P64;
      R2 = lvl16_rjVi_closure;
      Sp = Sp - 16;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:54.615507 UTC

{offset
  ckXc:
      _sk4V::P64 = R1;
      if ((Sp + -16) < SpLim) goto ckXd; else goto ckXe;
  ckXe:
      Hp = Hp + 80;
      if (Hp > HpLim) goto ckXg; else goto ckXf;
  ckXg:
      HpAlloc = 80;
      goto ckXd;
  ckXd:
      R1 = _sk4V::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckXf:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _sk4V::P64;
      _sk33::P64 = P64[_sk4V::P64 + 16];
      _sk46::P64 = P64[_sk4V::P64 + 24];
      _sk49::P64 = P64[_sk4V::P64 + 32];
      _sk3m::I64 = I64[_sk4V::P64 + 40];
      _sk3x::I64 = I64[_sk4V::P64 + 48];
      I64[Hp - 72] = sat_sk4T_info;
      P64[Hp - 56] = _sk33::P64;
      P64[Hp - 48] = _sk46::P64;
      P64[Hp - 40] = _sk49::P64;
      I64[Hp - 32] = _sk3m::I64;
      I64[Hp - 24] = _sk3x::I64;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = lvl14_rjVg_closure+1;
      P64[Hp] = Hp - 72;
      R3 = Hp - 14;
      R2 = lvl16_rjVi_closure;
      Sp = Sp - 16;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:54.617474 UTC

[(ckXc, {lvl16_rjVi_closure, sat_sk4T_closure}), (ckXd, {}),
 (ckXe, {lvl16_rjVi_closure, sat_sk4T_closure}),
 (ckXf, {lvl16_rjVi_closure, sat_sk4T_closure}), (ckXg, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:54.618002 UTC

sat_sk4V_entry() //  [R1]
        { info_tbl: [(ckXc,
                      label: sat_sk4V_info
                      rep:HeapRep 3 ptrs 2 nonptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckXc:
          _sk4V::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckXd; else goto ckXe;
      ckXe:
          Hp = Hp + 80;
          if (Hp > HpLim) goto ckXg; else goto ckXf;
      ckXg:
          HpAlloc = 80;
          goto ckXd;
      ckXd:
          R1 = _sk4V::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckXf:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _sk4V::P64;
          _sk33::P64 = P64[_sk4V::P64 + 16];
          _sk46::P64 = P64[_sk4V::P64 + 24];
          _sk49::P64 = P64[_sk4V::P64 + 32];
          _sk3m::I64 = I64[_sk4V::P64 + 40];
          _sk3x::I64 = I64[_sk4V::P64 + 48];
          I64[Hp - 72] = sat_sk4T_info;
          P64[Hp - 56] = _sk33::P64;
          P64[Hp - 48] = _sk46::P64;
          P64[Hp - 40] = _sk49::P64;
          I64[Hp - 32] = _sk3m::I64;
          I64[Hp - 24] = _sk3x::I64;
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = lvl14_rjVg_closure+1;
          P64[Hp] = Hp - 72;
          R3 = Hp - 14;
          R2 = lvl16_rjVi_closure;
          Sp = Sp - 16;
          call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:54.620047 UTC

sat_sk4V_entry() //  [R1]
        { info_tbl: [(ckXc,
                      label: sat_sk4V_info
                      rep:HeapRep 3 ptrs 2 nonptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckXc:
          _sk4V::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckXd; else goto ckXe;
      ckXe:
          Hp = Hp + 80;
          if (Hp > HpLim) goto ckXg; else goto ckXf;
      ckXg:
          HpAlloc = 80;
          goto ckXd;
      ckXd:
          R1 = _sk4V::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckXf:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _sk4V::P64;
          _sk33::P64 = P64[_sk4V::P64 + 16];
          _sk46::P64 = P64[_sk4V::P64 + 24];
          _sk49::P64 = P64[_sk4V::P64 + 32];
          _sk3m::I64 = I64[_sk4V::P64 + 40];
          _sk3x::I64 = I64[_sk4V::P64 + 48];
          I64[Hp - 72] = sat_sk4T_info;
          P64[Hp - 56] = _sk33::P64;
          P64[Hp - 48] = _sk46::P64;
          P64[Hp - 40] = _sk49::P64;
          I64[Hp - 32] = _sk3m::I64;
          I64[Hp - 24] = _sk3x::I64;
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = lvl14_rjVg_closure+1;
          P64[Hp] = Hp - 72;
          R3 = Hp - 14;
          R2 = lvl16_rjVi_closure;
          Sp = Sp - 16;
          call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:54.622069 UTC

{offset
  ckXh:
      _sk4X::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckXk; else goto ckXl;
  ckXl:
      if (HpLim == 0) goto ckXk; else goto ckXm;
  ckXk:
      R1 = _sk4X::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckXm:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sk4X::P64;
      _sk33::P64 = P64[_sk4X::P64 + 16];
      _sk45::P64 = P64[_sk4X::P64 + 24];
      _sk46::P64 = P64[_sk4X::P64 + 32];
      _sk49::P64 = P64[_sk4X::P64 + 40];
      _sk3m::I64 = I64[_sk4X::P64 + 48];
      _sk3x::I64 = I64[_sk4X::P64 + 56];
      I64[(young<ckUA> + 8)] = ckUA;
      R1 = _sk45::P64;
      if (R1 & 7 != 0) goto ckUA; else goto ckUB;
  ckUB:
      call (I64[R1])(R1) returns to ckUA, args: 8, res: 8, upd: 24;
  ckUA:
      _sk4a::P64 = R1;
      Hp = Hp + 80;
      if (Hp > HpLim) goto ckXp; else goto ckXo;
  ckXp:
      HpAlloc = 80;
      R1 = _sk4a::P64;
      call stg_gc_unpt_r1(R1) returns to ckUA, args: 8, res: 8, upd: 24;
  ckXo:
      _sk4b::F64 = F64[_sk4a::P64 + 7];
      I64[Hp - 72] = sat_sk4V_info;
      P64[Hp - 56] = _sk33::P64;
      P64[Hp - 48] = _sk46::P64;
      P64[Hp - 40] = _sk49::P64;
      I64[Hp - 32] = _sk3m::I64;
      I64[Hp - 24] = _sk3x::I64;
      _ckUF::P64 = Hp - 72;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = lvl14_rjVg_closure+1;
      P64[Hp] = _ckUF::P64;
      _ckXi::P64 = Hp - 14;
      I64[(young<ckXj> + 8)] = ckXj;
      D1 = _sk4b::F64;
      R3 = GHC.Show.shows18_closure;
      R2 = GHC.Float.$fShowDouble_$sshowFloat_closure+1;
      I64[(young<ckXj> + 24)] = stg_ap_p_info;
      P64[(young<ckXj> + 16)] = GHC.Types.[]_closure+1;
      call GHC.Float.$w$sshowSignedFloat_info(D1,
                                              R3,
                                              R2) returns to ckXj, args: 24, res: 8, upd: 24;
  ckXj:
      _sk4c::P64 = R1;
      R3 = _ckXi::P64;
      R2 = _sk4c::P64;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:54.62494 UTC

{offset
  ckXh:
      _sk4X::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckXk; else goto ckXl;
  ckXl:
      if (HpLim == 0) goto ckXk; else goto ckXm;
  ckXk:
      R1 = _sk4X::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckXm:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sk4X::P64;
      _sk33::P64 = P64[_sk4X::P64 + 16];
      _sk45::P64 = P64[_sk4X::P64 + 24];
      _sk46::P64 = P64[_sk4X::P64 + 32];
      _sk49::P64 = P64[_sk4X::P64 + 40];
      _sk3m::I64 = I64[_sk4X::P64 + 48];
      _sk3x::I64 = I64[_sk4X::P64 + 56];
      I64[(young<ckUA> + 8)] = ckUA;
      R1 = _sk45::P64;
      if (R1 & 7 != 0) goto ckUA; else goto ckUB;
  ckUB:
      call (I64[R1])(R1) returns to ckUA, args: 8, res: 8, upd: 24;
  ckUA:
      _sk4a::P64 = R1;
      Hp = Hp + 80;
      if (Hp > HpLim) goto ckXp; else goto ckXo;
  ckXp:
      HpAlloc = 80;
      R1 = _sk4a::P64;
      call stg_gc_unpt_r1(R1) returns to ckUA, args: 8, res: 8, upd: 24;
  ckXo:
      _sk4b::F64 = F64[_sk4a::P64 + 7];
      I64[Hp - 72] = sat_sk4V_info;
      P64[Hp - 56] = _sk33::P64;
      P64[Hp - 48] = _sk46::P64;
      P64[Hp - 40] = _sk49::P64;
      I64[Hp - 32] = _sk3m::I64;
      I64[Hp - 24] = _sk3x::I64;
      _ckUF::P64 = Hp - 72;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = lvl14_rjVg_closure+1;
      P64[Hp] = _ckUF::P64;
      _ckXi::P64 = Hp - 14;
      I64[(young<ckXj> + 8)] = ckXj;
      D1 = _sk4b::F64;
      R3 = GHC.Show.shows18_closure;
      R2 = GHC.Float.$fShowDouble_$sshowFloat_closure+1;
      I64[(young<ckXj> + 24)] = stg_ap_p_info;
      P64[(young<ckXj> + 16)] = GHC.Types.[]_closure+1;
      call GHC.Float.$w$sshowSignedFloat_info(D1,
                                              R3,
                                              R2) returns to ckXj, args: 24, res: 8, upd: 24;
  ckXj:
      _sk4c::P64 = R1;
      R3 = _ckXi::P64;
      R2 = _sk4c::P64;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:54.62787 UTC

{offset
  ckXh:
      _sk4X::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckXk; else goto ckXl;
  ckXl:
      if (HpLim == 0) goto ckXk; else goto ckXm;
  ckXk:
      R1 = _sk4X::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckXm:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sk4X::P64;
      _sk33::P64 = P64[_sk4X::P64 + 16];
      _sk45::P64 = P64[_sk4X::P64 + 24];
      _sk46::P64 = P64[_sk4X::P64 + 32];
      _sk49::P64 = P64[_sk4X::P64 + 40];
      _sk3m::I64 = I64[_sk4X::P64 + 48];
      _sk3x::I64 = I64[_sk4X::P64 + 56];
      I64[(young<ckUA> + 8)] = ckUA;
      R1 = _sk45::P64;
      if (R1 & 7 != 0) goto ckUA; else goto ckUB;
  ckUB:
      call (I64[R1])(R1) returns to ckUA, args: 8, res: 8, upd: 24;
  ckUA:
      _sk4a::P64 = R1;
      Hp = Hp + 80;
      if (Hp > HpLim) goto ckXp; else goto ckXo;
  ckXp:
      HpAlloc = 80;
      R1 = _sk4a::P64;
      call stg_gc_unpt_r1(R1) returns to ckUA, args: 8, res: 8, upd: 24;
  ckXo:
      _sk4b::F64 = F64[_sk4a::P64 + 7];
      I64[Hp - 72] = sat_sk4V_info;
      P64[Hp - 56] = _sk33::P64;
      P64[Hp - 48] = _sk46::P64;
      P64[Hp - 40] = _sk49::P64;
      I64[Hp - 32] = _sk3m::I64;
      I64[Hp - 24] = _sk3x::I64;
      _ckUF::P64 = Hp - 72;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = lvl14_rjVg_closure+1;
      P64[Hp] = _ckUF::P64;
      _ckXi::P64 = Hp - 14;
      I64[(young<ckXj> + 8)] = ckXj;
      D1 = _sk4b::F64;
      R3 = GHC.Show.shows18_closure;
      R2 = GHC.Float.$fShowDouble_$sshowFloat_closure+1;
      I64[(young<ckXj> + 24)] = stg_ap_p_info;
      P64[(young<ckXj> + 16)] = GHC.Types.[]_closure+1;
      call GHC.Float.$w$sshowSignedFloat_info(D1,
                                              R3,
                                              R2) returns to ckXj, args: 24, res: 8, upd: 24;
  ckXj:
      _sk4c::P64 = R1;
      R3 = _ckXi::P64;
      R2 = _sk4c::P64;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:54.631715 UTC

{offset
  ckXh:
      _sk4X::P64 = R1;
      if ((Sp + 8) - 72 < SpLim) goto ckXk; else goto ckXl;
  ckXl:
      if (HpLim == 0) goto ckXk; else goto ckXm;
  ckXk:
      R1 = _sk4X::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckXm:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _sk4X::P64;
      _sk33::P64 = P64[_sk4X::P64 + 16];
      _sk45::P64 = P64[_sk4X::P64 + 24];
      _sk46::P64 = P64[_sk4X::P64 + 32];
      _sk49::P64 = P64[_sk4X::P64 + 40];
      _sk3m::I64 = I64[_sk4X::P64 + 48];
      _sk3x::I64 = I64[_sk4X::P64 + 56];
      I64[Sp - 64] = ckUA;
      R1 = _sk45::P64;
      P64[Sp - 56] = _sk33::P64;
      I64[Sp - 48] = _sk3m::I64;
      I64[Sp - 40] = _sk3x::I64;
      P64[Sp - 32] = _sk46::P64;
      P64[Sp - 24] = _sk49::P64;
      Sp = Sp - 64;
      if (R1 & 7 != 0) goto ckUA; else goto ckUB;
  ckUB:
      call (I64[R1])(R1) returns to ckUA, args: 8, res: 8, upd: 24;
  ckUA:
      _sk33::P64 = P64[Sp + 8];
      _sk3m::I64 = I64[Sp + 16];
      _sk3x::I64 = I64[Sp + 24];
      _sk46::P64 = P64[Sp + 32];
      _sk49::P64 = P64[Sp + 40];
      _sk4a::P64 = R1;
      Hp = Hp + 80;
      if (Hp > HpLim) goto ckXp; else goto ckXo;
  ckXp:
      HpAlloc = 80;
      R1 = _sk4a::P64;
      call stg_gc_unpt_r1(R1) returns to ckUA, args: 8, res: 8, upd: 24;
  ckXo:
      _sk4b::F64 = F64[_sk4a::P64 + 7];
      I64[Hp - 72] = sat_sk4V_info;
      P64[Hp - 56] = _sk33::P64;
      P64[Hp - 48] = _sk46::P64;
      P64[Hp - 40] = _sk49::P64;
      I64[Hp - 32] = _sk3m::I64;
      I64[Hp - 24] = _sk3x::I64;
      _ckUF::P64 = Hp - 72;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = lvl14_rjVg_closure+1;
      P64[Hp] = _ckUF::P64;
      _ckXi::P64 = Hp - 14;
      I64[Sp + 32] = ckXj;
      D1 = _sk4b::F64;
      R3 = GHC.Show.shows18_closure;
      R2 = GHC.Float.$fShowDouble_$sshowFloat_closure+1;
      I64[Sp + 16] = stg_ap_p_info;
      P64[Sp + 24] = GHC.Types.[]_closure+1;
      P64[Sp + 40] = _ckXi::P64;
      Sp = Sp + 16;
      call GHC.Float.$w$sshowSignedFloat_info(D1,
                                              R3,
                                              R2) returns to ckXj, args: 24, res: 8, upd: 24;
  ckXj:
      _ckXi::P64 = P64[Sp + 8];
      _sk4c::P64 = R1;
      R3 = _ckXi::P64;
      R2 = _sk4c::P64;
      Sp = Sp + 16;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:54.635342 UTC

{offset
  ckXh:
      _sk4X::P64 = R1;
      if ((Sp + -64) < SpLim) goto ckXk; else goto ckXl;
  ckXl:
      if (HpLim == 0) goto ckXk; else goto ckXm;
  ckXk:
      R1 = _sk4X::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckXm:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _sk4X::P64;
      I64[Sp - 64] = ckUA;
      R1 = P64[_sk4X::P64 + 24];
      P64[Sp - 56] = P64[_sk4X::P64 + 16];
      I64[Sp - 48] = I64[_sk4X::P64 + 48];
      I64[Sp - 40] = I64[_sk4X::P64 + 56];
      P64[Sp - 32] = P64[_sk4X::P64 + 32];
      P64[Sp - 24] = P64[_sk4X::P64 + 40];
      Sp = Sp - 64;
      if (R1 & 7 != 0) goto ckUA; else goto ckUB;
  ckUB:
      call (I64[R1])(R1) returns to ckUA, args: 8, res: 8, upd: 24;
  ckUA:
      Hp = Hp + 80;
      if (Hp > HpLim) goto ckXp; else goto ckXo;
  ckXp:
      HpAlloc = 80;
      R1 = R1;
      call stg_gc_unpt_r1(R1) returns to ckUA, args: 8, res: 8, upd: 24;
  ckXo:
      _sk4b::F64 = F64[R1 + 7];
      I64[Hp - 72] = sat_sk4V_info;
      P64[Hp - 56] = P64[Sp + 8];
      P64[Hp - 48] = P64[Sp + 32];
      P64[Hp - 40] = P64[Sp + 40];
      I64[Hp - 32] = I64[Sp + 16];
      I64[Hp - 24] = I64[Sp + 24];
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = lvl14_rjVg_closure+1;
      P64[Hp] = Hp - 72;
      I64[Sp + 32] = ckXj;
      D1 = _sk4b::F64;
      R3 = GHC.Show.shows18_closure;
      R2 = GHC.Float.$fShowDouble_$sshowFloat_closure+1;
      I64[Sp + 16] = stg_ap_p_info;
      P64[Sp + 24] = GHC.Types.[]_closure+1;
      P64[Sp + 40] = Hp - 14;
      Sp = Sp + 16;
      call GHC.Float.$w$sshowSignedFloat_info(D1,
                                              R3,
                                              R2) returns to ckXj, args: 24, res: 8, upd: 24;
  ckXj:
      R3 = P64[Sp + 8];
      R2 = R1;
      Sp = Sp + 16;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:54.638891 UTC

[(ckUA,
  {GHC.Float.$fShowDouble_$sshowFloat_closure, sat_sk4V_closure}),
 (ckUB,
  {GHC.Float.$fShowDouble_$sshowFloat_closure, sat_sk4V_closure}),
 (ckXh,
  {GHC.Float.$fShowDouble_$sshowFloat_closure, sat_sk4V_closure}),
 (ckXj, {}), (ckXk, {}),
 (ckXl,
  {GHC.Float.$fShowDouble_$sshowFloat_closure, sat_sk4V_closure}),
 (ckXm,
  {GHC.Float.$fShowDouble_$sshowFloat_closure, sat_sk4V_closure}),
 (ckXo,
  {GHC.Float.$fShowDouble_$sshowFloat_closure, sat_sk4V_closure}),
 (ckXp,
  {GHC.Float.$fShowDouble_$sshowFloat_closure, sat_sk4V_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:54.639971 UTC

sat_sk4X_entry() //  [R1]
        { info_tbl: [(ckUA,
                      label: block_ckUA_info
                      rep:StackRep [False, True, True, False, False]),
                     (ckXh,
                      label: sat_sk4X_info
                      rep:HeapRep 4 ptrs 2 nonptrs { Thunk }),
                     (ckXj,
                      label: block_ckXj_info
                      rep:StackRep [False])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckXh:
          _sk4X::P64 = R1;
          if ((Sp + -64) < SpLim) goto ckXk; else goto ckXl;
      ckXl:
          if (HpLim == 0) goto ckXk; else goto ckXm;
      ckXk:
          R1 = _sk4X::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckXm:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _sk4X::P64;
          I64[Sp - 64] = ckUA;
          R1 = P64[_sk4X::P64 + 24];
          P64[Sp - 56] = P64[_sk4X::P64 + 16];
          I64[Sp - 48] = I64[_sk4X::P64 + 48];
          I64[Sp - 40] = I64[_sk4X::P64 + 56];
          P64[Sp - 32] = P64[_sk4X::P64 + 32];
          P64[Sp - 24] = P64[_sk4X::P64 + 40];
          Sp = Sp - 64;
          if (R1 & 7 != 0) goto ckUA; else goto ckUB;
      ckUB:
          call (I64[R1])(R1) returns to ckUA, args: 8, res: 8, upd: 24;
      ckUA:
          Hp = Hp + 80;
          if (Hp > HpLim) goto ckXp; else goto ckXo;
      ckXp:
          HpAlloc = 80;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to ckUA, args: 8, res: 8, upd: 24;
      ckXo:
          _sk4b::F64 = F64[R1 + 7];
          I64[Hp - 72] = sat_sk4V_info;
          P64[Hp - 56] = P64[Sp + 8];
          P64[Hp - 48] = P64[Sp + 32];
          P64[Hp - 40] = P64[Sp + 40];
          I64[Hp - 32] = I64[Sp + 16];
          I64[Hp - 24] = I64[Sp + 24];
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = lvl14_rjVg_closure+1;
          P64[Hp] = Hp - 72;
          I64[Sp + 32] = ckXj;
          D1 = _sk4b::F64;
          R3 = GHC.Show.shows18_closure;
          R2 = GHC.Float.$fShowDouble_$sshowFloat_closure+1;
          I64[Sp + 16] = stg_ap_p_info;
          P64[Sp + 24] = GHC.Types.[]_closure+1;
          P64[Sp + 40] = Hp - 14;
          Sp = Sp + 16;
          call GHC.Float.$w$sshowSignedFloat_info(D1,
                                                  R3,
                                                  R2) returns to ckXj, args: 24, res: 8, upd: 24;
      ckXj:
          R3 = P64[Sp + 8];
          R2 = R1;
          Sp = Sp + 16;
          call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:54.643479 UTC

sat_sk4X_entry() //  [R1]
        { info_tbl: [(ckUA,
                      label: block_ckUA_info
                      rep:StackRep [False, True, True, False, False]),
                     (ckXh,
                      label: sat_sk4X_info
                      rep:HeapRep 4 ptrs 2 nonptrs { Thunk }),
                     (ckXj,
                      label: block_ckXj_info
                      rep:StackRep [False])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckXh:
          _sk4X::P64 = R1;
          if ((Sp + -64) < SpLim) goto ckXk; else goto ckXl;
      ckXl:
          if (HpLim == 0) goto ckXk; else goto ckXm;
      ckXk:
          R1 = _sk4X::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckXm:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _sk4X::P64;
          I64[Sp - 64] = ckUA;
          R1 = P64[_sk4X::P64 + 24];
          P64[Sp - 56] = P64[_sk4X::P64 + 16];
          I64[Sp - 48] = I64[_sk4X::P64 + 48];
          I64[Sp - 40] = I64[_sk4X::P64 + 56];
          P64[Sp - 32] = P64[_sk4X::P64 + 32];
          P64[Sp - 24] = P64[_sk4X::P64 + 40];
          Sp = Sp - 64;
          if (R1 & 7 != 0) goto ckUA; else goto ckUB;
      ckUB:
          call (I64[R1])(R1) returns to ckUA, args: 8, res: 8, upd: 24;
      ckUA:
          Hp = Hp + 80;
          if (Hp > HpLim) goto ckXp; else goto ckXo;
      ckXp:
          HpAlloc = 80;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to ckUA, args: 8, res: 8, upd: 24;
      ckXo:
          _sk4b::F64 = F64[R1 + 7];
          I64[Hp - 72] = sat_sk4V_info;
          P64[Hp - 56] = P64[Sp + 8];
          P64[Hp - 48] = P64[Sp + 32];
          P64[Hp - 40] = P64[Sp + 40];
          I64[Hp - 32] = I64[Sp + 16];
          I64[Hp - 24] = I64[Sp + 24];
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = lvl14_rjVg_closure+1;
          P64[Hp] = Hp - 72;
          I64[Sp + 32] = ckXj;
          D1 = _sk4b::F64;
          R3 = GHC.Show.shows18_closure;
          R2 = GHC.Float.$fShowDouble_$sshowFloat_closure+1;
          I64[Sp + 16] = stg_ap_p_info;
          P64[Sp + 24] = GHC.Types.[]_closure+1;
          P64[Sp + 40] = Hp - 14;
          Sp = Sp + 16;
          call GHC.Float.$w$sshowSignedFloat_info(D1,
                                                  R3,
                                                  R2) returns to ckXj, args: 24, res: 8, upd: 24;
      ckXj:
          R3 = P64[Sp + 8];
          R2 = R1;
          Sp = Sp + 16;
          call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:54.647041 UTC

{offset
  ckXv:
      _sk4Z::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckXw; else goto ckXx;
  ckXx:
      Hp = Hp + 88;
      if (Hp > HpLim) goto ckXz; else goto ckXy;
  ckXz:
      HpAlloc = 88;
      goto ckXw;
  ckXw:
      R1 = _sk4Z::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckXy:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sk4Z::P64;
      _sk33::P64 = P64[_sk4Z::P64 + 16];
      _sk45::P64 = P64[_sk4Z::P64 + 24];
      _sk46::P64 = P64[_sk4Z::P64 + 32];
      _sk49::P64 = P64[_sk4Z::P64 + 40];
      _sk3m::I64 = I64[_sk4Z::P64 + 48];
      _sk3x::I64 = I64[_sk4Z::P64 + 56];
      I64[Hp - 80] = sat_sk4X_info;
      P64[Hp - 64] = _sk33::P64;
      P64[Hp - 56] = _sk45::P64;
      P64[Hp - 48] = _sk46::P64;
      P64[Hp - 40] = _sk49::P64;
      I64[Hp - 32] = _sk3m::I64;
      I64[Hp - 24] = _sk3x::I64;
      _ckUw::P64 = Hp - 80;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = lvl14_rjVg_closure+1;
      P64[Hp] = _ckUw::P64;
      _ckXu::P64 = Hp - 14;
      R3 = _ckXu::P64;
      R2 = lvl15_rjVh_closure;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:54.648953 UTC

{offset
  ckXv:
      _sk4Z::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckXw; else goto ckXx;
  ckXx:
      Hp = Hp + 88;
      if (Hp > HpLim) goto ckXz; else goto ckXy;
  ckXz:
      HpAlloc = 88;
      goto ckXw;
  ckXw:
      R1 = _sk4Z::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckXy:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sk4Z::P64;
      _sk33::P64 = P64[_sk4Z::P64 + 16];
      _sk45::P64 = P64[_sk4Z::P64 + 24];
      _sk46::P64 = P64[_sk4Z::P64 + 32];
      _sk49::P64 = P64[_sk4Z::P64 + 40];
      _sk3m::I64 = I64[_sk4Z::P64 + 48];
      _sk3x::I64 = I64[_sk4Z::P64 + 56];
      I64[Hp - 80] = sat_sk4X_info;
      P64[Hp - 64] = _sk33::P64;
      P64[Hp - 56] = _sk45::P64;
      P64[Hp - 48] = _sk46::P64;
      P64[Hp - 40] = _sk49::P64;
      I64[Hp - 32] = _sk3m::I64;
      I64[Hp - 24] = _sk3x::I64;
      _ckUw::P64 = Hp - 80;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = lvl14_rjVg_closure+1;
      P64[Hp] = _ckUw::P64;
      _ckXu::P64 = Hp - 14;
      R3 = _ckXu::P64;
      R2 = lvl15_rjVh_closure;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:54.650846 UTC

{offset
  ckXv:
      _sk4Z::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckXw; else goto ckXx;
  ckXx:
      Hp = Hp + 88;
      if (Hp > HpLim) goto ckXz; else goto ckXy;
  ckXz:
      HpAlloc = 88;
      goto ckXw;
  ckXw:
      R1 = _sk4Z::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckXy:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sk4Z::P64;
      _sk33::P64 = P64[_sk4Z::P64 + 16];
      _sk45::P64 = P64[_sk4Z::P64 + 24];
      _sk46::P64 = P64[_sk4Z::P64 + 32];
      _sk49::P64 = P64[_sk4Z::P64 + 40];
      _sk3m::I64 = I64[_sk4Z::P64 + 48];
      _sk3x::I64 = I64[_sk4Z::P64 + 56];
      I64[Hp - 80] = sat_sk4X_info;
      P64[Hp - 64] = _sk33::P64;
      P64[Hp - 56] = _sk45::P64;
      P64[Hp - 48] = _sk46::P64;
      P64[Hp - 40] = _sk49::P64;
      I64[Hp - 32] = _sk3m::I64;
      I64[Hp - 24] = _sk3x::I64;
      _ckUw::P64 = Hp - 80;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = lvl14_rjVg_closure+1;
      P64[Hp] = _ckUw::P64;
      _ckXu::P64 = Hp - 14;
      R3 = _ckXu::P64;
      R2 = lvl15_rjVh_closure;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:54.652783 UTC

{offset
  ckXv:
      _sk4Z::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto ckXw; else goto ckXx;
  ckXx:
      Hp = Hp + 88;
      if (Hp > HpLim) goto ckXz; else goto ckXy;
  ckXz:
      HpAlloc = 88;
      goto ckXw;
  ckXw:
      R1 = _sk4Z::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckXy:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _sk4Z::P64;
      _sk33::P64 = P64[_sk4Z::P64 + 16];
      _sk45::P64 = P64[_sk4Z::P64 + 24];
      _sk46::P64 = P64[_sk4Z::P64 + 32];
      _sk49::P64 = P64[_sk4Z::P64 + 40];
      _sk3m::I64 = I64[_sk4Z::P64 + 48];
      _sk3x::I64 = I64[_sk4Z::P64 + 56];
      I64[Hp - 80] = sat_sk4X_info;
      P64[Hp - 64] = _sk33::P64;
      P64[Hp - 56] = _sk45::P64;
      P64[Hp - 48] = _sk46::P64;
      P64[Hp - 40] = _sk49::P64;
      I64[Hp - 32] = _sk3m::I64;
      I64[Hp - 24] = _sk3x::I64;
      _ckUw::P64 = Hp - 80;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = lvl14_rjVg_closure+1;
      P64[Hp] = _ckUw::P64;
      _ckXu::P64 = Hp - 14;
      R3 = _ckXu::P64;
      R2 = lvl15_rjVh_closure;
      Sp = Sp - 16;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:54.654669 UTC

{offset
  ckXv:
      _sk4Z::P64 = R1;
      if ((Sp + -16) < SpLim) goto ckXw; else goto ckXx;
  ckXx:
      Hp = Hp + 88;
      if (Hp > HpLim) goto ckXz; else goto ckXy;
  ckXz:
      HpAlloc = 88;
      goto ckXw;
  ckXw:
      R1 = _sk4Z::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckXy:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _sk4Z::P64;
      _sk33::P64 = P64[_sk4Z::P64 + 16];
      _sk45::P64 = P64[_sk4Z::P64 + 24];
      _sk46::P64 = P64[_sk4Z::P64 + 32];
      _sk49::P64 = P64[_sk4Z::P64 + 40];
      _sk3m::I64 = I64[_sk4Z::P64 + 48];
      _sk3x::I64 = I64[_sk4Z::P64 + 56];
      I64[Hp - 80] = sat_sk4X_info;
      P64[Hp - 64] = _sk33::P64;
      P64[Hp - 56] = _sk45::P64;
      P64[Hp - 48] = _sk46::P64;
      P64[Hp - 40] = _sk49::P64;
      I64[Hp - 32] = _sk3m::I64;
      I64[Hp - 24] = _sk3x::I64;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = lvl14_rjVg_closure+1;
      P64[Hp] = Hp - 80;
      R3 = Hp - 14;
      R2 = lvl15_rjVh_closure;
      Sp = Sp - 16;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:54.656753 UTC

[(ckXv, {lvl15_rjVh_closure, sat_sk4X_closure}), (ckXw, {}),
 (ckXx, {lvl15_rjVh_closure, sat_sk4X_closure}),
 (ckXy, {lvl15_rjVh_closure, sat_sk4X_closure}), (ckXz, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:54.657305 UTC

sat_sk4Z_entry() //  [R1]
        { info_tbl: [(ckXv,
                      label: sat_sk4Z_info
                      rep:HeapRep 4 ptrs 2 nonptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckXv:
          _sk4Z::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckXw; else goto ckXx;
      ckXx:
          Hp = Hp + 88;
          if (Hp > HpLim) goto ckXz; else goto ckXy;
      ckXz:
          HpAlloc = 88;
          goto ckXw;
      ckXw:
          R1 = _sk4Z::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckXy:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _sk4Z::P64;
          _sk33::P64 = P64[_sk4Z::P64 + 16];
          _sk45::P64 = P64[_sk4Z::P64 + 24];
          _sk46::P64 = P64[_sk4Z::P64 + 32];
          _sk49::P64 = P64[_sk4Z::P64 + 40];
          _sk3m::I64 = I64[_sk4Z::P64 + 48];
          _sk3x::I64 = I64[_sk4Z::P64 + 56];
          I64[Hp - 80] = sat_sk4X_info;
          P64[Hp - 64] = _sk33::P64;
          P64[Hp - 56] = _sk45::P64;
          P64[Hp - 48] = _sk46::P64;
          P64[Hp - 40] = _sk49::P64;
          I64[Hp - 32] = _sk3m::I64;
          I64[Hp - 24] = _sk3x::I64;
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = lvl14_rjVg_closure+1;
          P64[Hp] = Hp - 80;
          R3 = Hp - 14;
          R2 = lvl15_rjVh_closure;
          Sp = Sp - 16;
          call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:54.659475 UTC

sat_sk4Z_entry() //  [R1]
        { info_tbl: [(ckXv,
                      label: sat_sk4Z_info
                      rep:HeapRep 4 ptrs 2 nonptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckXv:
          _sk4Z::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckXw; else goto ckXx;
      ckXx:
          Hp = Hp + 88;
          if (Hp > HpLim) goto ckXz; else goto ckXy;
      ckXz:
          HpAlloc = 88;
          goto ckXw;
      ckXw:
          R1 = _sk4Z::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckXy:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _sk4Z::P64;
          _sk33::P64 = P64[_sk4Z::P64 + 16];
          _sk45::P64 = P64[_sk4Z::P64 + 24];
          _sk46::P64 = P64[_sk4Z::P64 + 32];
          _sk49::P64 = P64[_sk4Z::P64 + 40];
          _sk3m::I64 = I64[_sk4Z::P64 + 48];
          _sk3x::I64 = I64[_sk4Z::P64 + 56];
          I64[Hp - 80] = sat_sk4X_info;
          P64[Hp - 64] = _sk33::P64;
          P64[Hp - 56] = _sk45::P64;
          P64[Hp - 48] = _sk46::P64;
          P64[Hp - 40] = _sk49::P64;
          I64[Hp - 32] = _sk3m::I64;
          I64[Hp - 24] = _sk3x::I64;
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = lvl14_rjVg_closure+1;
          P64[Hp] = Hp - 80;
          R3 = Hp - 14;
          R2 = lvl15_rjVh_closure;
          Sp = Sp - 16;
          call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:54.661664 UTC

{offset
  ckY0:
      _sk51::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckY1; else goto ckY2;
  ckY2:
      Hp = Hp + 88;
      if (Hp > HpLim) goto ckY4; else goto ckY3;
  ckY4:
      HpAlloc = 88;
      goto ckY1;
  ckY1:
      R1 = _sk51::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckY3:
      _sk33::P64 = P64[_sk51::P64 + 16];
      _sk45::P64 = P64[_sk51::P64 + 24];
      _sk46::P64 = P64[_sk51::P64 + 32];
      _sk49::P64 = P64[_sk51::P64 + 40];
      _sk3m::I64 = I64[_sk51::P64 + 48];
      _sk3x::I64 = I64[_sk51::P64 + 56];
      I64[Hp - 80] = sat_sk4Z_info;
      P64[Hp - 64] = _sk33::P64;
      P64[Hp - 56] = _sk45::P64;
      P64[Hp - 48] = _sk46::P64;
      P64[Hp - 40] = _sk49::P64;
      I64[Hp - 32] = _sk3m::I64;
      I64[Hp - 24] = _sk3x::I64;
      _ckUs::P64 = Hp - 80;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = lvl14_rjVg_closure+1;
      P64[Hp] = _ckUs::P64;
      _ckXZ::P64 = Hp - 14;
      R3 = _ckXZ::P64;
      R2 = lvl13_rjVf_closure;
      call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:54.663455 UTC

{offset
  ckY0:
      _sk51::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckY1; else goto ckY2;
  ckY2:
      Hp = Hp + 88;
      if (Hp > HpLim) goto ckY4; else goto ckY3;
  ckY4:
      HpAlloc = 88;
      goto ckY1;
  ckY1:
      R1 = _sk51::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckY3:
      _sk33::P64 = P64[_sk51::P64 + 16];
      _sk45::P64 = P64[_sk51::P64 + 24];
      _sk46::P64 = P64[_sk51::P64 + 32];
      _sk49::P64 = P64[_sk51::P64 + 40];
      _sk3m::I64 = I64[_sk51::P64 + 48];
      _sk3x::I64 = I64[_sk51::P64 + 56];
      I64[Hp - 80] = sat_sk4Z_info;
      P64[Hp - 64] = _sk33::P64;
      P64[Hp - 56] = _sk45::P64;
      P64[Hp - 48] = _sk46::P64;
      P64[Hp - 40] = _sk49::P64;
      I64[Hp - 32] = _sk3m::I64;
      I64[Hp - 24] = _sk3x::I64;
      _ckUs::P64 = Hp - 80;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = lvl14_rjVg_closure+1;
      P64[Hp] = _ckUs::P64;
      _ckXZ::P64 = Hp - 14;
      R3 = _ckXZ::P64;
      R2 = lvl13_rjVf_closure;
      call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:54.665261 UTC

{offset
  ckY0:
      _sk51::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckY1; else goto ckY2;
  ckY2:
      Hp = Hp + 88;
      if (Hp > HpLim) goto ckY4; else goto ckY3;
  ckY4:
      HpAlloc = 88;
      goto ckY1;
  ckY1:
      R1 = _sk51::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckY3:
      _sk33::P64 = P64[_sk51::P64 + 16];
      _sk45::P64 = P64[_sk51::P64 + 24];
      _sk46::P64 = P64[_sk51::P64 + 32];
      _sk49::P64 = P64[_sk51::P64 + 40];
      _sk3m::I64 = I64[_sk51::P64 + 48];
      _sk3x::I64 = I64[_sk51::P64 + 56];
      I64[Hp - 80] = sat_sk4Z_info;
      P64[Hp - 64] = _sk33::P64;
      P64[Hp - 56] = _sk45::P64;
      P64[Hp - 48] = _sk46::P64;
      P64[Hp - 40] = _sk49::P64;
      I64[Hp - 32] = _sk3m::I64;
      I64[Hp - 24] = _sk3x::I64;
      _ckUs::P64 = Hp - 80;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = lvl14_rjVg_closure+1;
      P64[Hp] = _ckUs::P64;
      _ckXZ::P64 = Hp - 14;
      R3 = _ckXZ::P64;
      R2 = lvl13_rjVf_closure;
      call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:54.667128 UTC

{offset
  ckY0:
      _sk51::P64 = R1;
      goto ckY2;
  ckY2:
      Hp = Hp + 88;
      if (Hp > HpLim) goto ckY4; else goto ckY3;
  ckY4:
      HpAlloc = 88;
      goto ckY1;
  ckY1:
      R1 = _sk51::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckY3:
      _sk33::P64 = P64[_sk51::P64 + 16];
      _sk45::P64 = P64[_sk51::P64 + 24];
      _sk46::P64 = P64[_sk51::P64 + 32];
      _sk49::P64 = P64[_sk51::P64 + 40];
      _sk3m::I64 = I64[_sk51::P64 + 48];
      _sk3x::I64 = I64[_sk51::P64 + 56];
      I64[Hp - 80] = sat_sk4Z_info;
      P64[Hp - 64] = _sk33::P64;
      P64[Hp - 56] = _sk45::P64;
      P64[Hp - 48] = _sk46::P64;
      P64[Hp - 40] = _sk49::P64;
      I64[Hp - 32] = _sk3m::I64;
      I64[Hp - 24] = _sk3x::I64;
      _ckUs::P64 = Hp - 80;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = lvl14_rjVg_closure+1;
      P64[Hp] = _ckUs::P64;
      _ckXZ::P64 = Hp - 14;
      R3 = _ckXZ::P64;
      R2 = lvl13_rjVf_closure;
      call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:54.668838 UTC

{offset
  ckY0:
      goto ckY2;
  ckY2:
      Hp = Hp + 88;
      if (Hp > HpLim) goto ckY4; else goto ckY3;
  ckY4:
      HpAlloc = 88;
      goto ckY1;
  ckY1:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckY3:
      _sk33::P64 = P64[R1 + 16];
      _sk45::P64 = P64[R1 + 24];
      _sk46::P64 = P64[R1 + 32];
      _sk49::P64 = P64[R1 + 40];
      _sk3m::I64 = I64[R1 + 48];
      _sk3x::I64 = I64[R1 + 56];
      I64[Hp - 80] = sat_sk4Z_info;
      P64[Hp - 64] = _sk33::P64;
      P64[Hp - 56] = _sk45::P64;
      P64[Hp - 48] = _sk46::P64;
      P64[Hp - 40] = _sk49::P64;
      I64[Hp - 32] = _sk3m::I64;
      I64[Hp - 24] = _sk3x::I64;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = lvl14_rjVg_closure+1;
      P64[Hp] = Hp - 80;
      R3 = Hp - 14;
      R2 = lvl13_rjVf_closure;
      call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:54.670687 UTC

[(ckY0, {lvl13_rjVf_closure, sat_sk4Z_closure}), (ckY1, {}),
 (ckY2, {lvl13_rjVf_closure, sat_sk4Z_closure}),
 (ckY3, {lvl13_rjVf_closure, sat_sk4Z_closure}), (ckY4, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:54.671211 UTC

sat_sk51_entry() //  [R1]
        { info_tbl: [(ckY0,
                      label: sat_sk51_info
                      rep:HeapRep 4 ptrs 2 nonptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckY0:
          goto ckY2;
      ckY2:
          Hp = Hp + 88;
          if (Hp > HpLim) goto ckY4; else goto ckY3;
      ckY4:
          HpAlloc = 88;
          goto ckY1;
      ckY1:
          R1 = R1;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckY3:
          _sk33::P64 = P64[R1 + 16];
          _sk45::P64 = P64[R1 + 24];
          _sk46::P64 = P64[R1 + 32];
          _sk49::P64 = P64[R1 + 40];
          _sk3m::I64 = I64[R1 + 48];
          _sk3x::I64 = I64[R1 + 56];
          I64[Hp - 80] = sat_sk4Z_info;
          P64[Hp - 64] = _sk33::P64;
          P64[Hp - 56] = _sk45::P64;
          P64[Hp - 48] = _sk46::P64;
          P64[Hp - 40] = _sk49::P64;
          I64[Hp - 32] = _sk3m::I64;
          I64[Hp - 24] = _sk3x::I64;
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = lvl14_rjVg_closure+1;
          P64[Hp] = Hp - 80;
          R3 = Hp - 14;
          R2 = lvl13_rjVf_closure;
          call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:54.673076 UTC

sat_sk51_entry() //  [R1]
        { info_tbl: [(ckY0,
                      label: sat_sk51_info
                      rep:HeapRep 4 ptrs 2 nonptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckY0:
          Hp = Hp + 88;
          if (Hp > HpLim) goto ckY4; else goto ckY3;
      ckY4:
          HpAlloc = 88;
          R1 = R1;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckY3:
          _sk33::P64 = P64[R1 + 16];
          _sk45::P64 = P64[R1 + 24];
          _sk46::P64 = P64[R1 + 32];
          _sk49::P64 = P64[R1 + 40];
          _sk3m::I64 = I64[R1 + 48];
          _sk3x::I64 = I64[R1 + 56];
          I64[Hp - 80] = sat_sk4Z_info;
          P64[Hp - 64] = _sk33::P64;
          P64[Hp - 56] = _sk45::P64;
          P64[Hp - 48] = _sk46::P64;
          P64[Hp - 40] = _sk49::P64;
          I64[Hp - 32] = _sk3m::I64;
          I64[Hp - 24] = _sk3x::I64;
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = lvl14_rjVg_closure+1;
          P64[Hp] = Hp - 80;
          R3 = Hp - 14;
          R2 = lvl13_rjVf_closure;
          call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:54.674863 UTC

{offset
  ckYm:
      _sk56::P64 = R3;
      _sk55::P64 = R2;
      _sk5v::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckYU; else goto ckYV;
  ckYV:
      if (HpLim == 0) goto ckYU; else goto ckYW;
  ckYU:
      R3 = _sk56::P64;
      R2 = _sk55::P64;
      R1 = _sk5v::P64;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  ckYW:
      _sk3D::P64 = P64[_sk5v::P64 + 5];
      _sk3v::F64 = F64[_sk5v::P64 + 13];
      _sk3x::I64 = I64[_sk5v::P64 + 21];
      I64[(young<ckYj> + 8)] = ckYj;
      R1 = _sk55::P64;
      if (R1 & 7 != 0) goto ckYj; else goto ckYk;
  ckYk:
      call (I64[R1])(R1) returns to ckYj, args: 8, res: 8, upd: 8;
  ckYj:
      _sk58::P64 = R1;
      _sk59::P64 = P64[_sk58::P64 + 7];
      I64[(young<ckYp> + 8)] = ckYp;
      R1 = _sk56::P64;
      if (R1 & 7 != 0) goto ckYp; else goto ckYq;
  ckYq:
      call (I64[R1])(R1) returns to ckYp, args: 8, res: 8, upd: 8;
  ckYp:
      _sk5a::P64 = R1;
      _sk5b::P64 = P64[_sk5a::P64 + 7];
      I64[(young<ckYu> + 8)] = ckYu;
      R1 = _sk3D::P64;
      if (R1 & 7 != 0) goto ckYu; else goto ckYv;
  ckYv:
      call (I64[R1])(R1) returns to ckYu, args: 8, res: 8, upd: 8;
  ckYu:
      _sk5c::P64 = R1;
      _sk5d::P64 = P64[_sk5c::P64 + 7];
      _sk5e::P64 = P64[_sk5c::P64 + 15];
      _sk5f::P64 = P64[_sk5c::P64 + 23];
      I64[(young<ckYz> + 8)] = ckYz;
      R1 = _sk5d::P64;
      if (R1 & 7 != 0) goto ckYz; else goto ckYA;
  ckYA:
      call (I64[R1])(R1) returns to ckYz, args: 8, res: 8, upd: 8;
  ckYz:
      _sk5g::P64 = R1;
      _sk5h::P64 = P64[_sk5g::P64 + 7];
      _sk5i::P64 = P64[_sk5g::P64 + 15];
      _sk5k::P64 = P64[_sk5g::P64 + 23];
      _sk5j::I64 = I64[_sk5g::P64 + 31];
      I64[(young<ckYE> + 8)] = ckYE;
      R1 = _sk5h::P64;
      if (R1 & 7 != 0) goto ckYE; else goto ckYF;
  ckYF:
      call (I64[R1])(R1) returns to ckYE, args: 8, res: 8, upd: 8;
  ckYE:
      _sk5l::P64 = R1;
      _sk5m::I64 = I64[_sk5l::P64 + 7];
      I64[(young<ckYJ> + 8)] = ckYJ;
      R1 = _sk5i::P64;
      if (R1 & 7 != 0) goto ckYJ; else goto ckYK;
  ckYK:
      call (I64[R1])(R1) returns to ckYJ, args: 8, res: 8, upd: 8;
  ckYJ:
      _sk5n::P64 = R1;
      _sk5o::I64 = I64[_sk5n::P64 + 7];
      I64[(young<ckYO> + 8)] = ckYO;
      R1 = _sk5e::P64;
      if (R1 & 7 != 0) goto ckYO; else goto ckYP;
  ckYP:
      call (I64[R1])(R1) returns to ckYO, args: 8, res: 8, upd: 8;
  ckYO:
      _sk5p::P64 = R1;
      _sk5q::P64 = P64[_sk5p::P64 + 7];
      I64[(young<ckYT> + 8)] = ckYT;
      R1 = _sk5f::P64;
      call stg_ap_0_fast(R1) returns to ckYT, args: 8, res: 8, upd: 8;
  ckYT:
      _sk5r::P64 = R1;
      _sk5u::P64 = P64[_sk5r::P64 + 7];
      _sk5s::I64 = I64[_sk5r::P64 + 15];
      _sk5t::I64 = I64[_sk5r::P64 + 23];
      R6 = _sk5j::I64;
      R5 = _sk5o::I64;
      R4 = _sk5m::I64;
      R3 = _sk5b::P64;
      R2 = _sk59::P64;
      P64[(old + 64)] = _sk5k::P64;
      P64[(old + 56)] = _sk5q::P64;
      I64[(old + 48)] = _sk5s::I64;
      I64[(old + 40)] = _sk5t::I64;
      P64[(old + 32)] = _sk5u::P64;
      I64[(old + 24)] = _sk3x::I64;
      F64[(old + 16)] = _sk3v::F64;
      call Main.$wa1_info(R6, R5, R4, R3, R2) args: 64, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:54.680312 UTC

{offset
  ckYm:
      _sk56::P64 = R3;
      _sk55::P64 = R2;
      _sk5v::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckYU; else goto ckYV;
  ckYV:
      if (HpLim == 0) goto ckYU; else goto ckYW;
  ckYU:
      R3 = _sk56::P64;
      R2 = _sk55::P64;
      R1 = _sk5v::P64;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  ckYW:
      _sk3D::P64 = P64[_sk5v::P64 + 5];
      _sk3v::F64 = F64[_sk5v::P64 + 13];
      _sk3x::I64 = I64[_sk5v::P64 + 21];
      I64[(young<ckYj> + 8)] = ckYj;
      R1 = _sk55::P64;
      if (R1 & 7 != 0) goto ckYj; else goto ckYk;
  ckYk:
      call (I64[R1])(R1) returns to ckYj, args: 8, res: 8, upd: 8;
  ckYj:
      _sk58::P64 = R1;
      _sk59::P64 = P64[_sk58::P64 + 7];
      I64[(young<ckYp> + 8)] = ckYp;
      R1 = _sk56::P64;
      if (R1 & 7 != 0) goto ckYp; else goto ckYq;
  ckYq:
      call (I64[R1])(R1) returns to ckYp, args: 8, res: 8, upd: 8;
  ckYp:
      _sk5a::P64 = R1;
      _sk5b::P64 = P64[_sk5a::P64 + 7];
      I64[(young<ckYu> + 8)] = ckYu;
      R1 = _sk3D::P64;
      if (R1 & 7 != 0) goto ckYu; else goto ckYv;
  ckYv:
      call (I64[R1])(R1) returns to ckYu, args: 8, res: 8, upd: 8;
  ckYu:
      _sk5c::P64 = R1;
      _sk5d::P64 = P64[_sk5c::P64 + 7];
      _sk5e::P64 = P64[_sk5c::P64 + 15];
      _sk5f::P64 = P64[_sk5c::P64 + 23];
      I64[(young<ckYz> + 8)] = ckYz;
      R1 = _sk5d::P64;
      if (R1 & 7 != 0) goto ckYz; else goto ckYA;
  ckYA:
      call (I64[R1])(R1) returns to ckYz, args: 8, res: 8, upd: 8;
  ckYz:
      _sk5g::P64 = R1;
      _sk5h::P64 = P64[_sk5g::P64 + 7];
      _sk5i::P64 = P64[_sk5g::P64 + 15];
      _sk5k::P64 = P64[_sk5g::P64 + 23];
      _sk5j::I64 = I64[_sk5g::P64 + 31];
      I64[(young<ckYE> + 8)] = ckYE;
      R1 = _sk5h::P64;
      if (R1 & 7 != 0) goto ckYE; else goto ckYF;
  ckYF:
      call (I64[R1])(R1) returns to ckYE, args: 8, res: 8, upd: 8;
  ckYE:
      _sk5l::P64 = R1;
      _sk5m::I64 = I64[_sk5l::P64 + 7];
      I64[(young<ckYJ> + 8)] = ckYJ;
      R1 = _sk5i::P64;
      if (R1 & 7 != 0) goto ckYJ; else goto ckYK;
  ckYK:
      call (I64[R1])(R1) returns to ckYJ, args: 8, res: 8, upd: 8;
  ckYJ:
      _sk5n::P64 = R1;
      _sk5o::I64 = I64[_sk5n::P64 + 7];
      I64[(young<ckYO> + 8)] = ckYO;
      R1 = _sk5e::P64;
      if (R1 & 7 != 0) goto ckYO; else goto ckYP;
  ckYP:
      call (I64[R1])(R1) returns to ckYO, args: 8, res: 8, upd: 8;
  ckYO:
      _sk5p::P64 = R1;
      _sk5q::P64 = P64[_sk5p::P64 + 7];
      I64[(young<ckYT> + 8)] = ckYT;
      R1 = _sk5f::P64;
      call stg_ap_0_fast(R1) returns to ckYT, args: 8, res: 8, upd: 8;
  ckYT:
      _sk5r::P64 = R1;
      _sk5u::P64 = P64[_sk5r::P64 + 7];
      _sk5s::I64 = I64[_sk5r::P64 + 15];
      _sk5t::I64 = I64[_sk5r::P64 + 23];
      R6 = _sk5j::I64;
      R5 = _sk5o::I64;
      R4 = _sk5m::I64;
      R3 = _sk5b::P64;
      R2 = _sk59::P64;
      P64[(old + 64)] = _sk5k::P64;
      P64[(old + 56)] = _sk5q::P64;
      I64[(old + 48)] = _sk5s::I64;
      I64[(old + 40)] = _sk5t::I64;
      P64[(old + 32)] = _sk5u::P64;
      I64[(old + 24)] = _sk3x::I64;
      F64[(old + 16)] = _sk3v::F64;
      call Main.$wa1_info(R6, R5, R4, R3, R2) args: 64, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:54.685079 UTC

{offset
  ckYm:
      _sk56::P64 = R3;
      _sk55::P64 = R2;
      _sk5v::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckYU; else goto ckYV;
  ckYV:
      if (HpLim == 0) goto ckYU; else goto ckYW;
  ckYU:
      R3 = _sk56::P64;
      R2 = _sk55::P64;
      R1 = _sk5v::P64;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  ckYW:
      _sk3D::P64 = P64[_sk5v::P64 + 5];
      _sk3v::F64 = F64[_sk5v::P64 + 13];
      _sk3x::I64 = I64[_sk5v::P64 + 21];
      I64[(young<ckYj> + 8)] = ckYj;
      R1 = _sk55::P64;
      if (R1 & 7 != 0) goto ckYj; else goto ckYk;
  ckYk:
      call (I64[R1])(R1) returns to ckYj, args: 8, res: 8, upd: 8;
  ckYj:
      _sk58::P64 = R1;
      _sk59::P64 = P64[_sk58::P64 + 7];
      I64[(young<ckYp> + 8)] = ckYp;
      R1 = _sk56::P64;
      if (R1 & 7 != 0) goto ckYp; else goto ckYq;
  ckYq:
      call (I64[R1])(R1) returns to ckYp, args: 8, res: 8, upd: 8;
  ckYp:
      _sk5a::P64 = R1;
      _sk5b::P64 = P64[_sk5a::P64 + 7];
      I64[(young<ckYu> + 8)] = ckYu;
      R1 = _sk3D::P64;
      if (R1 & 7 != 0) goto ckYu; else goto ckYv;
  ckYv:
      call (I64[R1])(R1) returns to ckYu, args: 8, res: 8, upd: 8;
  ckYu:
      _sk5c::P64 = R1;
      _sk5d::P64 = P64[_sk5c::P64 + 7];
      _sk5e::P64 = P64[_sk5c::P64 + 15];
      _sk5f::P64 = P64[_sk5c::P64 + 23];
      I64[(young<ckYz> + 8)] = ckYz;
      R1 = _sk5d::P64;
      if (R1 & 7 != 0) goto ckYz; else goto ckYA;
  ckYA:
      call (I64[R1])(R1) returns to ckYz, args: 8, res: 8, upd: 8;
  ckYz:
      _sk5g::P64 = R1;
      _sk5h::P64 = P64[_sk5g::P64 + 7];
      _sk5i::P64 = P64[_sk5g::P64 + 15];
      _sk5k::P64 = P64[_sk5g::P64 + 23];
      _sk5j::I64 = I64[_sk5g::P64 + 31];
      I64[(young<ckYE> + 8)] = ckYE;
      R1 = _sk5h::P64;
      if (R1 & 7 != 0) goto ckYE; else goto ckYF;
  ckYF:
      call (I64[R1])(R1) returns to ckYE, args: 8, res: 8, upd: 8;
  ckYE:
      _sk5l::P64 = R1;
      _sk5m::I64 = I64[_sk5l::P64 + 7];
      I64[(young<ckYJ> + 8)] = ckYJ;
      R1 = _sk5i::P64;
      if (R1 & 7 != 0) goto ckYJ; else goto ckYK;
  ckYK:
      call (I64[R1])(R1) returns to ckYJ, args: 8, res: 8, upd: 8;
  ckYJ:
      _sk5n::P64 = R1;
      _sk5o::I64 = I64[_sk5n::P64 + 7];
      I64[(young<ckYO> + 8)] = ckYO;
      R1 = _sk5e::P64;
      if (R1 & 7 != 0) goto ckYO; else goto ckYP;
  ckYP:
      call (I64[R1])(R1) returns to ckYO, args: 8, res: 8, upd: 8;
  ckYO:
      _sk5p::P64 = R1;
      _sk5q::P64 = P64[_sk5p::P64 + 7];
      I64[(young<ckYT> + 8)] = ckYT;
      R1 = _sk5f::P64;
      call stg_ap_0_fast(R1) returns to ckYT, args: 8, res: 8, upd: 8;
  ckYT:
      _sk5r::P64 = R1;
      _sk5u::P64 = P64[_sk5r::P64 + 7];
      _sk5s::I64 = I64[_sk5r::P64 + 15];
      _sk5t::I64 = I64[_sk5r::P64 + 23];
      R6 = _sk5j::I64;
      R5 = _sk5o::I64;
      R4 = _sk5m::I64;
      R3 = _sk5b::P64;
      R2 = _sk59::P64;
      P64[(old + 64)] = _sk5k::P64;
      P64[(old + 56)] = _sk5q::P64;
      I64[(old + 48)] = _sk5s::I64;
      I64[(old + 40)] = _sk5t::I64;
      P64[(old + 32)] = _sk5u::P64;
      I64[(old + 24)] = _sk3x::I64;
      F64[(old + 16)] = _sk3v::F64;
      call Main.$wa1_info(R6, R5, R4, R3, R2) args: 64, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:54.690508 UTC

{offset
  ckYm:
      _sk56::P64 = R3;
      _sk55::P64 = R2;
      _sk5v::P64 = R1;
      if ((Sp + 8) - 88 < SpLim) goto ckYU; else goto ckYV;
  ckYV:
      if (HpLim == 0) goto ckYU; else goto ckYW;
  ckYU:
      R3 = _sk56::P64;
      R2 = _sk55::P64;
      R1 = _sk5v::P64;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  ckYW:
      _sk3D::P64 = P64[_sk5v::P64 + 5];
      _sk3v::F64 = F64[_sk5v::P64 + 13];
      _sk3x::I64 = I64[_sk5v::P64 + 21];
      I64[Sp - 40] = ckYj;
      R1 = _sk55::P64;
      F64[Sp - 32] = _sk3v::F64;
      I64[Sp - 24] = _sk3x::I64;
      P64[Sp - 16] = _sk3D::P64;
      P64[Sp - 8] = _sk56::P64;
      Sp = Sp - 40;
      if (R1 & 7 != 0) goto ckYj; else goto ckYk;
  ckYk:
      call (I64[R1])(R1) returns to ckYj, args: 8, res: 8, upd: 8;
  ckYj:
      _sk3v::F64 = F64[Sp + 8];
      _sk3x::I64 = I64[Sp + 16];
      _sk3D::P64 = P64[Sp + 24];
      _sk56::P64 = P64[Sp + 32];
      _sk58::P64 = R1;
      _sk59::P64 = P64[_sk58::P64 + 7];
      I64[Sp] = ckYp;
      R1 = _sk56::P64;
      P64[Sp + 32] = _sk59::P64;
      if (R1 & 7 != 0) goto ckYp; else goto ckYq;
  ckYq:
      call (I64[R1])(R1) returns to ckYp, args: 8, res: 8, upd: 8;
  ckYp:
      _sk3v::F64 = F64[Sp + 8];
      _sk3x::I64 = I64[Sp + 16];
      _sk3D::P64 = P64[Sp + 24];
      _sk59::P64 = P64[Sp + 32];
      _sk5a::P64 = R1;
      _sk5b::P64 = P64[_sk5a::P64 + 7];
      I64[Sp] = ckYu;
      R1 = _sk3D::P64;
      P64[Sp + 24] = _sk5b::P64;
      if (R1 & 7 != 0) goto ckYu; else goto ckYv;
  ckYv:
      call (I64[R1])(R1) returns to ckYu, args: 8, res: 8, upd: 8;
  ckYu:
      _sk3v::F64 = F64[Sp + 8];
      _sk3x::I64 = I64[Sp + 16];
      _sk59::P64 = P64[Sp + 32];
      _sk5b::P64 = P64[Sp + 24];
      _sk5c::P64 = R1;
      _sk5d::P64 = P64[_sk5c::P64 + 7];
      _sk5e::P64 = P64[_sk5c::P64 + 15];
      _sk5f::P64 = P64[_sk5c::P64 + 23];
      I64[Sp - 16] = ckYz;
      R1 = _sk5d::P64;
      P64[Sp - 8] = _sk5f::P64;
      P64[Sp] = _sk5e::P64;
      Sp = Sp - 16;
      if (R1 & 7 != 0) goto ckYz; else goto ckYA;
  ckYA:
      call (I64[R1])(R1) returns to ckYz, args: 8, res: 8, upd: 8;
  ckYz:
      _sk3v::F64 = F64[Sp + 24];
      _sk3x::I64 = I64[Sp + 32];
      _sk59::P64 = P64[Sp + 48];
      _sk5b::P64 = P64[Sp + 40];
      _sk5e::P64 = P64[Sp + 16];
      _sk5f::P64 = P64[Sp + 8];
      _sk5g::P64 = R1;
      _sk5h::P64 = P64[_sk5g::P64 + 7];
      _sk5i::P64 = P64[_sk5g::P64 + 15];
      _sk5k::P64 = P64[_sk5g::P64 + 23];
      _sk5j::I64 = I64[_sk5g::P64 + 31];
      I64[Sp - 24] = ckYE;
      R1 = _sk5h::P64;
      I64[Sp - 16] = _sk5j::I64;
      P64[Sp - 8] = _sk5k::P64;
      P64[Sp] = _sk5i::P64;
      Sp = Sp - 24;
      if (R1 & 7 != 0) goto ckYE; else goto ckYF;
  ckYF:
      call (I64[R1])(R1) returns to ckYE, args: 8, res: 8, upd: 8;
  ckYE:
      _sk3v::F64 = F64[Sp + 48];
      _sk3x::I64 = I64[Sp + 56];
      _sk59::P64 = P64[Sp + 72];
      _sk5b::P64 = P64[Sp + 64];
      _sk5e::P64 = P64[Sp + 40];
      _sk5f::P64 = P64[Sp + 32];
      _sk5i::P64 = P64[Sp + 24];
      _sk5j::I64 = I64[Sp + 8];
      _sk5k::P64 = P64[Sp + 16];
      _sk5l::P64 = R1;
      _sk5m::I64 = I64[_sk5l::P64 + 7];
      I64[Sp] = ckYJ;
      R1 = _sk5i::P64;
      I64[Sp + 24] = _sk5m::I64;
      if (R1 & 7 != 0) goto ckYJ; else goto ckYK;
  ckYK:
      call (I64[R1])(R1) returns to ckYJ, args: 8, res: 8, upd: 8;
  ckYJ:
      _sk3v::F64 = F64[Sp + 48];
      _sk3x::I64 = I64[Sp + 56];
      _sk59::P64 = P64[Sp + 72];
      _sk5b::P64 = P64[Sp + 64];
      _sk5e::P64 = P64[Sp + 40];
      _sk5f::P64 = P64[Sp + 32];
      _sk5j::I64 = I64[Sp + 8];
      _sk5k::P64 = P64[Sp + 16];
      _sk5m::I64 = I64[Sp + 24];
      _sk5n::P64 = R1;
      _sk5o::I64 = I64[_sk5n::P64 + 7];
      I64[Sp] = ckYO;
      R1 = _sk5e::P64;
      I64[Sp + 40] = _sk5o::I64;
      if (R1 & 7 != 0) goto ckYO; else goto ckYP;
  ckYP:
      call (I64[R1])(R1) returns to ckYO, args: 8, res: 8, upd: 8;
  ckYO:
      _sk3v::F64 = F64[Sp + 48];
      _sk3x::I64 = I64[Sp + 56];
      _sk59::P64 = P64[Sp + 72];
      _sk5b::P64 = P64[Sp + 64];
      _sk5f::P64 = P64[Sp + 32];
      _sk5j::I64 = I64[Sp + 8];
      _sk5k::P64 = P64[Sp + 16];
      _sk5m::I64 = I64[Sp + 24];
      _sk5o::I64 = I64[Sp + 40];
      _sk5p::P64 = R1;
      _sk5q::P64 = P64[_sk5p::P64 + 7];
      I64[Sp] = ckYT;
      R1 = _sk5f::P64;
      P64[Sp + 32] = _sk5q::P64;
      call stg_ap_0_fast(R1) returns to ckYT, args: 8, res: 8, upd: 8;
  ckYT:
      _sk3v::F64 = F64[Sp + 48];
      _sk3x::I64 = I64[Sp + 56];
      _sk59::P64 = P64[Sp + 72];
      _sk5b::P64 = P64[Sp + 64];
      _sk5j::I64 = I64[Sp + 8];
      _sk5k::P64 = P64[Sp + 16];
      _sk5m::I64 = I64[Sp + 24];
      _sk5o::I64 = I64[Sp + 40];
      _sk5q::P64 = P64[Sp + 32];
      _sk5r::P64 = R1;
      _sk5u::P64 = P64[_sk5r::P64 + 7];
      _sk5s::I64 = I64[_sk5r::P64 + 15];
      _sk5t::I64 = I64[_sk5r::P64 + 23];
      R6 = _sk5j::I64;
      R5 = _sk5o::I64;
      R4 = _sk5m::I64;
      R3 = _sk5b::P64;
      R2 = _sk59::P64;
      P64[Sp + 24] = _sk5k::P64;
      I64[Sp + 40] = _sk5s::I64;
      I64[Sp + 48] = _sk5t::I64;
      P64[Sp + 56] = _sk5u::P64;
      I64[Sp + 64] = _sk3x::I64;
      F64[Sp + 72] = _sk3v::F64;
      Sp = Sp + 24;
      call Main.$wa1_info(R6, R5, R4, R3, R2) args: 64, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:54.698998 UTC

{offset
  ckYm:
      _sk56::P64 = R3;
      _sk55::P64 = R2;
      _sk5v::P64 = R1;
      if ((Sp + -80) < SpLim) goto ckYU; else goto ckYV;
  ckYV:
      if (HpLim == 0) goto ckYU; else goto ckYW;
  ckYU:
      R3 = _sk56::P64;
      R2 = _sk55::P64;
      R1 = _sk5v::P64;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  ckYW:
      I64[Sp - 40] = ckYj;
      R1 = _sk55::P64;
      F64[Sp - 32] = F64[_sk5v::P64 + 13];
      I64[Sp - 24] = I64[_sk5v::P64 + 21];
      P64[Sp - 16] = P64[_sk5v::P64 + 5];
      P64[Sp - 8] = _sk56::P64;
      Sp = Sp - 40;
      if (R1 & 7 != 0) goto ckYj; else goto ckYk;
  ckYk:
      call (I64[R1])(R1) returns to ckYj, args: 8, res: 8, upd: 8;
  ckYj:
      I64[Sp] = ckYp;
      _sk59::P64 = P64[R1 + 7];
      R1 = P64[Sp + 32];
      P64[Sp + 32] = _sk59::P64;
      if (R1 & 7 != 0) goto ckYp; else goto ckYq;
  ckYq:
      call (I64[R1])(R1) returns to ckYp, args: 8, res: 8, upd: 8;
  ckYp:
      I64[Sp] = ckYu;
      _sk5b::P64 = P64[R1 + 7];
      R1 = P64[Sp + 24];
      P64[Sp + 24] = _sk5b::P64;
      if (R1 & 7 != 0) goto ckYu; else goto ckYv;
  ckYv:
      call (I64[R1])(R1) returns to ckYu, args: 8, res: 8, upd: 8;
  ckYu:
      I64[Sp - 16] = ckYz;
      _sk5e::P64 = P64[R1 + 15];
      _sk5f::P64 = P64[R1 + 23];
      R1 = P64[R1 + 7];
      P64[Sp - 8] = _sk5f::P64;
      P64[Sp] = _sk5e::P64;
      Sp = Sp - 16;
      if (R1 & 7 != 0) goto ckYz; else goto ckYA;
  ckYA:
      call (I64[R1])(R1) returns to ckYz, args: 8, res: 8, upd: 8;
  ckYz:
      I64[Sp - 24] = ckYE;
      _sk5i::P64 = P64[R1 + 15];
      _sk5k::P64 = P64[R1 + 23];
      _sk5j::I64 = I64[R1 + 31];
      R1 = P64[R1 + 7];
      I64[Sp - 16] = _sk5j::I64;
      P64[Sp - 8] = _sk5k::P64;
      P64[Sp] = _sk5i::P64;
      Sp = Sp - 24;
      if (R1 & 7 != 0) goto ckYE; else goto ckYF;
  ckYF:
      call (I64[R1])(R1) returns to ckYE, args: 8, res: 8, upd: 8;
  ckYE:
      I64[Sp] = ckYJ;
      _sk5m::I64 = I64[R1 + 7];
      R1 = P64[Sp + 24];
      I64[Sp + 24] = _sk5m::I64;
      if (R1 & 7 != 0) goto ckYJ; else goto ckYK;
  ckYK:
      call (I64[R1])(R1) returns to ckYJ, args: 8, res: 8, upd: 8;
  ckYJ:
      I64[Sp] = ckYO;
      _sk5o::I64 = I64[R1 + 7];
      R1 = P64[Sp + 40];
      I64[Sp + 40] = _sk5o::I64;
      if (R1 & 7 != 0) goto ckYO; else goto ckYP;
  ckYP:
      call (I64[R1])(R1) returns to ckYO, args: 8, res: 8, upd: 8;
  ckYO:
      I64[Sp] = ckYT;
      _sk5q::P64 = P64[R1 + 7];
      R1 = P64[Sp + 32];
      P64[Sp + 32] = _sk5q::P64;
      call stg_ap_0_fast(R1) returns to ckYT, args: 8, res: 8, upd: 8;
  ckYT:
      R6 = I64[Sp + 8];
      R5 = I64[Sp + 40];
      R4 = I64[Sp + 24];
      R3 = P64[Sp + 64];
      R2 = P64[Sp + 72];
      P64[Sp + 24] = P64[Sp + 16];
      I64[Sp + 40] = I64[R1 + 15];
      _sk3v::F64 = F64[Sp + 48];
      I64[Sp + 48] = I64[R1 + 23];
      _sk3x::I64 = I64[Sp + 56];
      P64[Sp + 56] = P64[R1 + 7];
      I64[Sp + 64] = _sk3x::I64;
      F64[Sp + 72] = _sk3v::F64;
      Sp = Sp + 24;
      call Main.$wa1_info(R6, R5, R4, R3, R2) args: 64, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:54.705308 UTC

[(ckYj, {Main.$wa1_closure}), (ckYk, {Main.$wa1_closure}),
 (ckYm, {Main.$wa1_closure}), (ckYp, {Main.$wa1_closure}),
 (ckYq, {Main.$wa1_closure}), (ckYu, {Main.$wa1_closure}),
 (ckYv, {Main.$wa1_closure}), (ckYz, {Main.$wa1_closure}),
 (ckYA, {Main.$wa1_closure}), (ckYE, {Main.$wa1_closure}),
 (ckYF, {Main.$wa1_closure}), (ckYJ, {Main.$wa1_closure}),
 (ckYK, {Main.$wa1_closure}), (ckYO, {Main.$wa1_closure}),
 (ckYP, {Main.$wa1_closure}), (ckYT, {Main.$wa1_closure}),
 (ckYU, {}), (ckYV, {Main.$wa1_closure}),
 (ckYW, {Main.$wa1_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:54.706561 UTC

sat_sk5v_entry() //  [R3, R2, R1]
        { info_tbl: [(ckYj,
                      label: block_ckYj_info
                      rep:StackRep [True, True, False, False]),
                     (ckYm,
                      label: sat_sk5v_info
                      rep:HeapRep 1 ptrs 2 nonptrs {
                            Fun {arity: 3 fun_type: ArgSpec 15} }),
                     (ckYp,
                      label: block_ckYp_info
                      rep:StackRep [True, True, False, False]),
                     (ckYu,
                      label: block_ckYu_info
                      rep:StackRep [True, True, False, False]),
                     (ckYz,
                      label: block_ckYz_info
                      rep:StackRep [False, False, True, True, False, False]),
                     (ckYE,
                      label: block_ckYE_info
                      rep:StackRep [True, False, False, False, False, True, True, False,
                                    False]),
                     (ckYJ,
                      label: block_ckYJ_info
                      rep:StackRep [True, False, True, False, False, True, True, False,
                                    False]),
                     (ckYO,
                      label: block_ckYO_info
                      rep:StackRep [True, False, True, False, True, True, True, False,
                                    False]),
                     (ckYT,
                      label: block_ckYT_info
                      rep:StackRep [True, False, True, False, True, True, True, False,
                                    False])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckYm:
          _sk56::P64 = R3;
          _sk55::P64 = R2;
          _sk5v::P64 = R1;
          if ((Sp + -80) < SpLim) goto ckYU; else goto ckYV;
      ckYV:
          if (HpLim == 0) goto ckYU; else goto ckYW;
      ckYU:
          R3 = _sk56::P64;
          R2 = _sk55::P64;
          R1 = _sk5v::P64;
          call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
      ckYW:
          I64[Sp - 40] = ckYj;
          R1 = _sk55::P64;
          F64[Sp - 32] = F64[_sk5v::P64 + 13];
          I64[Sp - 24] = I64[_sk5v::P64 + 21];
          P64[Sp - 16] = P64[_sk5v::P64 + 5];
          P64[Sp - 8] = _sk56::P64;
          Sp = Sp - 40;
          if (R1 & 7 != 0) goto ckYj; else goto ckYk;
      ckYk:
          call (I64[R1])(R1) returns to ckYj, args: 8, res: 8, upd: 8;
      ckYj:
          I64[Sp] = ckYp;
          _sk59::P64 = P64[R1 + 7];
          R1 = P64[Sp + 32];
          P64[Sp + 32] = _sk59::P64;
          if (R1 & 7 != 0) goto ckYp; else goto ckYq;
      ckYq:
          call (I64[R1])(R1) returns to ckYp, args: 8, res: 8, upd: 8;
      ckYp:
          I64[Sp] = ckYu;
          _sk5b::P64 = P64[R1 + 7];
          R1 = P64[Sp + 24];
          P64[Sp + 24] = _sk5b::P64;
          if (R1 & 7 != 0) goto ckYu; else goto ckYv;
      ckYv:
          call (I64[R1])(R1) returns to ckYu, args: 8, res: 8, upd: 8;
      ckYu:
          I64[Sp - 16] = ckYz;
          _sk5e::P64 = P64[R1 + 15];
          _sk5f::P64 = P64[R1 + 23];
          R1 = P64[R1 + 7];
          P64[Sp - 8] = _sk5f::P64;
          P64[Sp] = _sk5e::P64;
          Sp = Sp - 16;
          if (R1 & 7 != 0) goto ckYz; else goto ckYA;
      ckYA:
          call (I64[R1])(R1) returns to ckYz, args: 8, res: 8, upd: 8;
      ckYz:
          I64[Sp - 24] = ckYE;
          _sk5i::P64 = P64[R1 + 15];
          _sk5k::P64 = P64[R1 + 23];
          _sk5j::I64 = I64[R1 + 31];
          R1 = P64[R1 + 7];
          I64[Sp - 16] = _sk5j::I64;
          P64[Sp - 8] = _sk5k::P64;
          P64[Sp] = _sk5i::P64;
          Sp = Sp - 24;
          if (R1 & 7 != 0) goto ckYE; else goto ckYF;
      ckYF:
          call (I64[R1])(R1) returns to ckYE, args: 8, res: 8, upd: 8;
      ckYE:
          I64[Sp] = ckYJ;
          _sk5m::I64 = I64[R1 + 7];
          R1 = P64[Sp + 24];
          I64[Sp + 24] = _sk5m::I64;
          if (R1 & 7 != 0) goto ckYJ; else goto ckYK;
      ckYK:
          call (I64[R1])(R1) returns to ckYJ, args: 8, res: 8, upd: 8;
      ckYJ:
          I64[Sp] = ckYO;
          _sk5o::I64 = I64[R1 + 7];
          R1 = P64[Sp + 40];
          I64[Sp + 40] = _sk5o::I64;
          if (R1 & 7 != 0) goto ckYO; else goto ckYP;
      ckYP:
          call (I64[R1])(R1) returns to ckYO, args: 8, res: 8, upd: 8;
      ckYO:
          I64[Sp] = ckYT;
          _sk5q::P64 = P64[R1 + 7];
          R1 = P64[Sp + 32];
          P64[Sp + 32] = _sk5q::P64;
          call stg_ap_0_fast(R1) returns to ckYT, args: 8, res: 8, upd: 8;
      ckYT:
          R6 = I64[Sp + 8];
          R5 = I64[Sp + 40];
          R4 = I64[Sp + 24];
          R3 = P64[Sp + 64];
          R2 = P64[Sp + 72];
          P64[Sp + 24] = P64[Sp + 16];
          I64[Sp + 40] = I64[R1 + 15];
          _sk3v::F64 = F64[Sp + 48];
          I64[Sp + 48] = I64[R1 + 23];
          _sk3x::I64 = I64[Sp + 56];
          P64[Sp + 56] = P64[R1 + 7];
          I64[Sp + 64] = _sk3x::I64;
          F64[Sp + 72] = _sk3v::F64;
          Sp = Sp + 24;
          call Main.$wa1_info(R6, R5, R4, R3, R2) args: 64, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:54.713676 UTC

sat_sk5v_entry() //  [R3, R2, R1]
        { info_tbl: [(ckYj,
                      label: block_ckYj_info
                      rep:StackRep [True, True, False, False]),
                     (ckYm,
                      label: sat_sk5v_info
                      rep:HeapRep 1 ptrs 2 nonptrs {
                            Fun {arity: 3 fun_type: ArgSpec 15} }),
                     (ckYp,
                      label: block_ckYp_info
                      rep:StackRep [True, True, False, False]),
                     (ckYu,
                      label: block_ckYu_info
                      rep:StackRep [True, True, False, False]),
                     (ckYz,
                      label: block_ckYz_info
                      rep:StackRep [False, False, True, True, False, False]),
                     (ckYE,
                      label: block_ckYE_info
                      rep:StackRep [True, False, False, False, False, True, True, False,
                                    False]),
                     (ckYJ,
                      label: block_ckYJ_info
                      rep:StackRep [True, False, True, False, False, True, True, False,
                                    False]),
                     (ckYO,
                      label: block_ckYO_info
                      rep:StackRep [True, False, True, False, True, True, True, False,
                                    False]),
                     (ckYT,
                      label: block_ckYT_info
                      rep:StackRep [True, False, True, False, True, True, True, False,
                                    False])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckYm:
          _sk56::P64 = R3;
          _sk55::P64 = R2;
          _sk5v::P64 = R1;
          if ((Sp + -80) < SpLim) goto ckYU; else goto ckYV;
      ckYV:
          if (HpLim == 0) goto ckYU; else goto ckYW;
      ckYU:
          R3 = _sk56::P64;
          R2 = _sk55::P64;
          R1 = _sk5v::P64;
          call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
      ckYW:
          I64[Sp - 40] = ckYj;
          R1 = _sk55::P64;
          F64[Sp - 32] = F64[_sk5v::P64 + 13];
          I64[Sp - 24] = I64[_sk5v::P64 + 21];
          P64[Sp - 16] = P64[_sk5v::P64 + 5];
          P64[Sp - 8] = _sk56::P64;
          Sp = Sp - 40;
          if (R1 & 7 != 0) goto ckYj; else goto ckYk;
      ckYk:
          call (I64[R1])(R1) returns to ckYj, args: 8, res: 8, upd: 8;
      ckYj:
          I64[Sp] = ckYp;
          _sk59::P64 = P64[R1 + 7];
          R1 = P64[Sp + 32];
          P64[Sp + 32] = _sk59::P64;
          if (R1 & 7 != 0) goto ckYp; else goto ckYq;
      ckYq:
          call (I64[R1])(R1) returns to ckYp, args: 8, res: 8, upd: 8;
      ckYp:
          I64[Sp] = ckYu;
          _sk5b::P64 = P64[R1 + 7];
          R1 = P64[Sp + 24];
          P64[Sp + 24] = _sk5b::P64;
          if (R1 & 7 != 0) goto ckYu; else goto ckYv;
      ckYv:
          call (I64[R1])(R1) returns to ckYu, args: 8, res: 8, upd: 8;
      ckYu:
          I64[Sp - 16] = ckYz;
          _sk5e::P64 = P64[R1 + 15];
          _sk5f::P64 = P64[R1 + 23];
          R1 = P64[R1 + 7];
          P64[Sp - 8] = _sk5f::P64;
          P64[Sp] = _sk5e::P64;
          Sp = Sp - 16;
          if (R1 & 7 != 0) goto ckYz; else goto ckYA;
      ckYA:
          call (I64[R1])(R1) returns to ckYz, args: 8, res: 8, upd: 8;
      ckYz:
          I64[Sp - 24] = ckYE;
          _sk5i::P64 = P64[R1 + 15];
          _sk5k::P64 = P64[R1 + 23];
          _sk5j::I64 = I64[R1 + 31];
          R1 = P64[R1 + 7];
          I64[Sp - 16] = _sk5j::I64;
          P64[Sp - 8] = _sk5k::P64;
          P64[Sp] = _sk5i::P64;
          Sp = Sp - 24;
          if (R1 & 7 != 0) goto ckYE; else goto ckYF;
      ckYF:
          call (I64[R1])(R1) returns to ckYE, args: 8, res: 8, upd: 8;
      ckYE:
          I64[Sp] = ckYJ;
          _sk5m::I64 = I64[R1 + 7];
          R1 = P64[Sp + 24];
          I64[Sp + 24] = _sk5m::I64;
          if (R1 & 7 != 0) goto ckYJ; else goto ckYK;
      ckYK:
          call (I64[R1])(R1) returns to ckYJ, args: 8, res: 8, upd: 8;
      ckYJ:
          I64[Sp] = ckYO;
          _sk5o::I64 = I64[R1 + 7];
          R1 = P64[Sp + 40];
          I64[Sp + 40] = _sk5o::I64;
          if (R1 & 7 != 0) goto ckYO; else goto ckYP;
      ckYP:
          call (I64[R1])(R1) returns to ckYO, args: 8, res: 8, upd: 8;
      ckYO:
          I64[Sp] = ckYT;
          _sk5q::P64 = P64[R1 + 7];
          R1 = P64[Sp + 32];
          P64[Sp + 32] = _sk5q::P64;
          call stg_ap_0_fast(R1) returns to ckYT, args: 8, res: 8, upd: 8;
      ckYT:
          R6 = I64[Sp + 8];
          R5 = I64[Sp + 40];
          R4 = I64[Sp + 24];
          R3 = P64[Sp + 64];
          R2 = P64[Sp + 72];
          P64[Sp + 24] = P64[Sp + 16];
          I64[Sp + 40] = I64[R1 + 15];
          _sk3v::F64 = F64[Sp + 48];
          I64[Sp + 48] = I64[R1 + 23];
          _sk3x::I64 = I64[Sp + 56];
          P64[Sp + 56] = P64[R1 + 7];
          I64[Sp + 64] = _sk3x::I64;
          F64[Sp + 72] = _sk3v::F64;
          Sp = Sp + 24;
          call Main.$wa1_info(R6, R5, R4, R3, R2) args: 64, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:54.720798 UTC

{offset
  ckZf:
      _sk5w::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckZg; else goto ckZh;
  ckZh:
      Hp = Hp + 32;
      if (Hp > HpLim) goto ckZj; else goto ckZi;
  ckZj:
      HpAlloc = 32;
      goto ckZg;
  ckZg:
      R1 = _sk5w::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckZi:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sk5w::P64;
      _sk3A::P64 = P64[_sk5w::P64 + 16];
      _sk3D::P64 = P64[_sk5w::P64 + 24];
      _sk41::P64 = P64[_sk5w::P64 + 32];
      _sk3v::F64 = F64[_sk5w::P64 + 40];
      _sk3x::I64 = I64[_sk5w::P64 + 48];
      I64[Hp - 24] = sat_sk5v_info;
      P64[Hp - 16] = _sk3D::P64;
      F64[Hp - 8] = _sk3v::F64;
      I64[Hp] = _sk3x::I64;
      _ckYe::P64 = Hp - 21;
      R4 = _sk3A::P64;
      R3 = _sk41::P64;
      R2 = _ckYe::P64;
      call GHC.List.zipWith_info(R4, R3, R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:54.722362 UTC

{offset
  ckZf:
      _sk5w::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckZg; else goto ckZh;
  ckZh:
      Hp = Hp + 32;
      if (Hp > HpLim) goto ckZj; else goto ckZi;
  ckZj:
      HpAlloc = 32;
      goto ckZg;
  ckZg:
      R1 = _sk5w::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckZi:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sk5w::P64;
      _sk3A::P64 = P64[_sk5w::P64 + 16];
      _sk3D::P64 = P64[_sk5w::P64 + 24];
      _sk41::P64 = P64[_sk5w::P64 + 32];
      _sk3v::F64 = F64[_sk5w::P64 + 40];
      _sk3x::I64 = I64[_sk5w::P64 + 48];
      I64[Hp - 24] = sat_sk5v_info;
      P64[Hp - 16] = _sk3D::P64;
      F64[Hp - 8] = _sk3v::F64;
      I64[Hp] = _sk3x::I64;
      _ckYe::P64 = Hp - 21;
      R4 = _sk3A::P64;
      R3 = _sk41::P64;
      R2 = _ckYe::P64;
      call GHC.List.zipWith_info(R4, R3, R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:54.723918 UTC

{offset
  ckZf:
      _sk5w::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckZg; else goto ckZh;
  ckZh:
      Hp = Hp + 32;
      if (Hp > HpLim) goto ckZj; else goto ckZi;
  ckZj:
      HpAlloc = 32;
      goto ckZg;
  ckZg:
      R1 = _sk5w::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckZi:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sk5w::P64;
      _sk3A::P64 = P64[_sk5w::P64 + 16];
      _sk3D::P64 = P64[_sk5w::P64 + 24];
      _sk41::P64 = P64[_sk5w::P64 + 32];
      _sk3v::F64 = F64[_sk5w::P64 + 40];
      _sk3x::I64 = I64[_sk5w::P64 + 48];
      I64[Hp - 24] = sat_sk5v_info;
      P64[Hp - 16] = _sk3D::P64;
      F64[Hp - 8] = _sk3v::F64;
      I64[Hp] = _sk3x::I64;
      _ckYe::P64 = Hp - 21;
      R4 = _sk3A::P64;
      R3 = _sk41::P64;
      R2 = _ckYe::P64;
      call GHC.List.zipWith_info(R4, R3, R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:54.725505 UTC

{offset
  ckZf:
      _sk5w::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto ckZg; else goto ckZh;
  ckZh:
      Hp = Hp + 32;
      if (Hp > HpLim) goto ckZj; else goto ckZi;
  ckZj:
      HpAlloc = 32;
      goto ckZg;
  ckZg:
      R1 = _sk5w::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckZi:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _sk5w::P64;
      _sk3A::P64 = P64[_sk5w::P64 + 16];
      _sk3D::P64 = P64[_sk5w::P64 + 24];
      _sk41::P64 = P64[_sk5w::P64 + 32];
      _sk3v::F64 = F64[_sk5w::P64 + 40];
      _sk3x::I64 = I64[_sk5w::P64 + 48];
      I64[Hp - 24] = sat_sk5v_info;
      P64[Hp - 16] = _sk3D::P64;
      F64[Hp - 8] = _sk3v::F64;
      I64[Hp] = _sk3x::I64;
      _ckYe::P64 = Hp - 21;
      R4 = _sk3A::P64;
      R3 = _sk41::P64;
      R2 = _ckYe::P64;
      Sp = Sp - 16;
      call GHC.List.zipWith_info(R4, R3, R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:54.727052 UTC

{offset
  ckZf:
      _sk5w::P64 = R1;
      if ((Sp + -16) < SpLim) goto ckZg; else goto ckZh;
  ckZh:
      Hp = Hp + 32;
      if (Hp > HpLim) goto ckZj; else goto ckZi;
  ckZj:
      HpAlloc = 32;
      goto ckZg;
  ckZg:
      R1 = _sk5w::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckZi:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _sk5w::P64;
      _sk3A::P64 = P64[_sk5w::P64 + 16];
      _sk3D::P64 = P64[_sk5w::P64 + 24];
      _sk41::P64 = P64[_sk5w::P64 + 32];
      _sk3v::F64 = F64[_sk5w::P64 + 40];
      _sk3x::I64 = I64[_sk5w::P64 + 48];
      I64[Hp - 24] = sat_sk5v_info;
      P64[Hp - 16] = _sk3D::P64;
      F64[Hp - 8] = _sk3v::F64;
      I64[Hp] = _sk3x::I64;
      R4 = _sk3A::P64;
      R3 = _sk41::P64;
      R2 = Hp - 21;
      Sp = Sp - 16;
      call GHC.List.zipWith_info(R4, R3, R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:54.728769 UTC

[(ckZf, {sat_sk5v_closure}), (ckZg, {}),
 (ckZh, {sat_sk5v_closure}), (ckZi, {sat_sk5v_closure}), (ckZj, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:54.729237 UTC

sat_sk5w_entry() //  [R1]
        { info_tbl: [(ckZf,
                      label: sat_sk5w_info
                      rep:HeapRep 3 ptrs 2 nonptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckZf:
          _sk5w::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckZg; else goto ckZh;
      ckZh:
          Hp = Hp + 32;
          if (Hp > HpLim) goto ckZj; else goto ckZi;
      ckZj:
          HpAlloc = 32;
          goto ckZg;
      ckZg:
          R1 = _sk5w::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckZi:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _sk5w::P64;
          _sk3A::P64 = P64[_sk5w::P64 + 16];
          _sk3D::P64 = P64[_sk5w::P64 + 24];
          _sk41::P64 = P64[_sk5w::P64 + 32];
          _sk3v::F64 = F64[_sk5w::P64 + 40];
          _sk3x::I64 = I64[_sk5w::P64 + 48];
          I64[Hp - 24] = sat_sk5v_info;
          P64[Hp - 16] = _sk3D::P64;
          F64[Hp - 8] = _sk3v::F64;
          I64[Hp] = _sk3x::I64;
          R4 = _sk3A::P64;
          R3 = _sk41::P64;
          R2 = Hp - 21;
          Sp = Sp - 16;
          call GHC.List.zipWith_info(R4, R3, R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:54.731029 UTC

sat_sk5w_entry() //  [R1]
        { info_tbl: [(ckZf,
                      label: sat_sk5w_info
                      rep:HeapRep 3 ptrs 2 nonptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckZf:
          _sk5w::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckZg; else goto ckZh;
      ckZh:
          Hp = Hp + 32;
          if (Hp > HpLim) goto ckZj; else goto ckZi;
      ckZj:
          HpAlloc = 32;
          goto ckZg;
      ckZg:
          R1 = _sk5w::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckZi:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _sk5w::P64;
          _sk3A::P64 = P64[_sk5w::P64 + 16];
          _sk3D::P64 = P64[_sk5w::P64 + 24];
          _sk41::P64 = P64[_sk5w::P64 + 32];
          _sk3v::F64 = F64[_sk5w::P64 + 40];
          _sk3x::I64 = I64[_sk5w::P64 + 48];
          I64[Hp - 24] = sat_sk5v_info;
          P64[Hp - 16] = _sk3D::P64;
          F64[Hp - 8] = _sk3v::F64;
          I64[Hp] = _sk3x::I64;
          R4 = _sk3A::P64;
          R3 = _sk41::P64;
          R2 = Hp - 21;
          Sp = Sp - 16;
          call GHC.List.zipWith_info(R4, R3, R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:54.732835 UTC

{offset
  ckZy:
      _sk5G::P64 = R3;
      _sk5F::P64 = R2;
      _sk5M::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckZC; else goto ckZD;
  ckZD:
      if (HpLim == 0) goto ckZC; else goto ckZE;
  ckZC:
      R3 = _sk5G::P64;
      R2 = _sk5F::P64;
      R1 = _sk5M::P64;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  ckZE:
      _sk3v::F64 = F64[_sk5M::P64 + 5];
      _sk3x::I64 = I64[_sk5M::P64 + 13];
      I64[(young<ckZv> + 8)] = ckZv;
      R1 = _sk5F::P64;
      if (R1 & 7 != 0) goto ckZv; else goto ckZw;
  ckZw:
      call (I64[R1])(R1) returns to ckZv, args: 8, res: 8, upd: 8;
  ckZv:
      _sk5I::P64 = R1;
      _sk5J::P64 = P64[_sk5I::P64 + 7];
      I64[(young<ckZB> + 8)] = ckZB;
      R1 = _sk5G::P64;
      if (R1 & 7 != 0) goto ckZB; else goto ckZG;
  ckZG:
      call (I64[R1])(R1) returns to ckZB, args: 8, res: 8, upd: 8;
  ckZB:
      _sk5K::P64 = R1;
      _sk5L::P64 = P64[_sk5K::P64 + 7];
      D1 = _sk3v::F64;
      R4 = _sk3x::I64;
      R3 = _sk5L::P64;
      R2 = _sk5J::P64;
      call Main.$wa_info(D1, R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:54.73467 UTC

{offset
  ckZy:
      _sk5G::P64 = R3;
      _sk5F::P64 = R2;
      _sk5M::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckZC; else goto ckZD;
  ckZD:
      if (HpLim == 0) goto ckZC; else goto ckZE;
  ckZC:
      R3 = _sk5G::P64;
      R2 = _sk5F::P64;
      R1 = _sk5M::P64;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  ckZE:
      _sk3v::F64 = F64[_sk5M::P64 + 5];
      _sk3x::I64 = I64[_sk5M::P64 + 13];
      I64[(young<ckZv> + 8)] = ckZv;
      R1 = _sk5F::P64;
      if (R1 & 7 != 0) goto ckZv; else goto ckZw;
  ckZw:
      call (I64[R1])(R1) returns to ckZv, args: 8, res: 8, upd: 8;
  ckZv:
      _sk5I::P64 = R1;
      _sk5J::P64 = P64[_sk5I::P64 + 7];
      I64[(young<ckZB> + 8)] = ckZB;
      R1 = _sk5G::P64;
      if (R1 & 7 != 0) goto ckZB; else goto ckZG;
  ckZG:
      call (I64[R1])(R1) returns to ckZB, args: 8, res: 8, upd: 8;
  ckZB:
      _sk5K::P64 = R1;
      _sk5L::P64 = P64[_sk5K::P64 + 7];
      D1 = _sk3v::F64;
      R4 = _sk3x::I64;
      R3 = _sk5L::P64;
      R2 = _sk5J::P64;
      call Main.$wa_info(D1, R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:54.737165 UTC

{offset
  ckZy:
      _sk5G::P64 = R3;
      _sk5F::P64 = R2;
      _sk5M::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckZC; else goto ckZD;
  ckZD:
      if (HpLim == 0) goto ckZC; else goto ckZE;
  ckZC:
      R3 = _sk5G::P64;
      R2 = _sk5F::P64;
      R1 = _sk5M::P64;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  ckZE:
      _sk3v::F64 = F64[_sk5M::P64 + 5];
      _sk3x::I64 = I64[_sk5M::P64 + 13];
      I64[(young<ckZv> + 8)] = ckZv;
      R1 = _sk5F::P64;
      if (R1 & 7 != 0) goto ckZv; else goto ckZw;
  ckZw:
      call (I64[R1])(R1) returns to ckZv, args: 8, res: 8, upd: 8;
  ckZv:
      _sk5I::P64 = R1;
      _sk5J::P64 = P64[_sk5I::P64 + 7];
      I64[(young<ckZB> + 8)] = ckZB;
      R1 = _sk5G::P64;
      if (R1 & 7 != 0) goto ckZB; else goto ckZG;
  ckZG:
      call (I64[R1])(R1) returns to ckZB, args: 8, res: 8, upd: 8;
  ckZB:
      _sk5K::P64 = R1;
      _sk5L::P64 = P64[_sk5K::P64 + 7];
      D1 = _sk3v::F64;
      R4 = _sk3x::I64;
      R3 = _sk5L::P64;
      R2 = _sk5J::P64;
      call Main.$wa_info(D1, R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:54.739382 UTC

{offset
  ckZy:
      _sk5G::P64 = R3;
      _sk5F::P64 = R2;
      _sk5M::P64 = R1;
      if ((Sp + 8) - 40 < SpLim) goto ckZC; else goto ckZD;
  ckZD:
      if (HpLim == 0) goto ckZC; else goto ckZE;
  ckZC:
      R3 = _sk5G::P64;
      R2 = _sk5F::P64;
      R1 = _sk5M::P64;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  ckZE:
      _sk3v::F64 = F64[_sk5M::P64 + 5];
      _sk3x::I64 = I64[_sk5M::P64 + 13];
      I64[Sp - 32] = ckZv;
      R1 = _sk5F::P64;
      F64[Sp - 24] = _sk3v::F64;
      I64[Sp - 16] = _sk3x::I64;
      P64[Sp - 8] = _sk5G::P64;
      Sp = Sp - 32;
      if (R1 & 7 != 0) goto ckZv; else goto ckZw;
  ckZw:
      call (I64[R1])(R1) returns to ckZv, args: 8, res: 8, upd: 8;
  ckZv:
      _sk3v::F64 = F64[Sp + 8];
      _sk3x::I64 = I64[Sp + 16];
      _sk5G::P64 = P64[Sp + 24];
      _sk5I::P64 = R1;
      _sk5J::P64 = P64[_sk5I::P64 + 7];
      I64[Sp] = ckZB;
      R1 = _sk5G::P64;
      P64[Sp + 24] = _sk5J::P64;
      if (R1 & 7 != 0) goto ckZB; else goto ckZG;
  ckZG:
      call (I64[R1])(R1) returns to ckZB, args: 8, res: 8, upd: 8;
  ckZB:
      _sk3v::F64 = F64[Sp + 8];
      _sk3x::I64 = I64[Sp + 16];
      _sk5J::P64 = P64[Sp + 24];
      _sk5K::P64 = R1;
      _sk5L::P64 = P64[_sk5K::P64 + 7];
      D1 = _sk3v::F64;
      R4 = _sk3x::I64;
      R3 = _sk5L::P64;
      R2 = _sk5J::P64;
      Sp = Sp + 32;
      call Main.$wa_info(D1, R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:54.741787 UTC

{offset
  ckZy:
      _sk5G::P64 = R3;
      _sk5F::P64 = R2;
      _sk5M::P64 = R1;
      if ((Sp + -32) < SpLim) goto ckZC; else goto ckZD;
  ckZD:
      if (HpLim == 0) goto ckZC; else goto ckZE;
  ckZC:
      R3 = _sk5G::P64;
      R2 = _sk5F::P64;
      R1 = _sk5M::P64;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  ckZE:
      I64[Sp - 32] = ckZv;
      R1 = _sk5F::P64;
      F64[Sp - 24] = F64[_sk5M::P64 + 5];
      I64[Sp - 16] = I64[_sk5M::P64 + 13];
      P64[Sp - 8] = _sk5G::P64;
      Sp = Sp - 32;
      if (R1 & 7 != 0) goto ckZv; else goto ckZw;
  ckZw:
      call (I64[R1])(R1) returns to ckZv, args: 8, res: 8, upd: 8;
  ckZv:
      I64[Sp] = ckZB;
      _sk5J::P64 = P64[R1 + 7];
      R1 = P64[Sp + 24];
      P64[Sp + 24] = _sk5J::P64;
      if (R1 & 7 != 0) goto ckZB; else goto ckZG;
  ckZG:
      call (I64[R1])(R1) returns to ckZB, args: 8, res: 8, upd: 8;
  ckZB:
      D1 = F64[Sp + 8];
      R4 = I64[Sp + 16];
      R3 = P64[R1 + 7];
      R2 = P64[Sp + 24];
      Sp = Sp + 32;
      call Main.$wa_info(D1, R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:54.744093 UTC

[(ckZv, {Main.$wa_closure}), (ckZw, {Main.$wa_closure}),
 (ckZy, {Main.$wa_closure}), (ckZB, {Main.$wa_closure}), (ckZC, {}),
 (ckZD, {Main.$wa_closure}), (ckZE, {Main.$wa_closure}),
 (ckZG, {Main.$wa_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:54.744736 UTC

sat_sk5M_entry() //  [R3, R2, R1]
        { info_tbl: [(ckZv,
                      label: block_ckZv_info
                      rep:StackRep [True, True, False]),
                     (ckZy,
                      label: sat_sk5M_info
                      rep:HeapRep 2 nonptrs { Fun {arity: 3 fun_type: ArgSpec 15} }),
                     (ckZB,
                      label: block_ckZB_info
                      rep:StackRep [True, True, False])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckZy:
          _sk5G::P64 = R3;
          _sk5F::P64 = R2;
          _sk5M::P64 = R1;
          if ((Sp + -32) < SpLim) goto ckZC; else goto ckZD;
      ckZD:
          if (HpLim == 0) goto ckZC; else goto ckZE;
      ckZC:
          R3 = _sk5G::P64;
          R2 = _sk5F::P64;
          R1 = _sk5M::P64;
          call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
      ckZE:
          I64[Sp - 32] = ckZv;
          R1 = _sk5F::P64;
          F64[Sp - 24] = F64[_sk5M::P64 + 5];
          I64[Sp - 16] = I64[_sk5M::P64 + 13];
          P64[Sp - 8] = _sk5G::P64;
          Sp = Sp - 32;
          if (R1 & 7 != 0) goto ckZv; else goto ckZw;
      ckZw:
          call (I64[R1])(R1) returns to ckZv, args: 8, res: 8, upd: 8;
      ckZv:
          I64[Sp] = ckZB;
          _sk5J::P64 = P64[R1 + 7];
          R1 = P64[Sp + 24];
          P64[Sp + 24] = _sk5J::P64;
          if (R1 & 7 != 0) goto ckZB; else goto ckZG;
      ckZG:
          call (I64[R1])(R1) returns to ckZB, args: 8, res: 8, upd: 8;
      ckZB:
          D1 = F64[Sp + 8];
          R4 = I64[Sp + 16];
          R3 = P64[R1 + 7];
          R2 = P64[Sp + 24];
          Sp = Sp + 32;
          call Main.$wa_info(D1, R4, R3, R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:54.747299 UTC

sat_sk5M_entry() //  [R3, R2, R1]
        { info_tbl: [(ckZv,
                      label: block_ckZv_info
                      rep:StackRep [True, True, False]),
                     (ckZy,
                      label: sat_sk5M_info
                      rep:HeapRep 2 nonptrs { Fun {arity: 3 fun_type: ArgSpec 15} }),
                     (ckZB,
                      label: block_ckZB_info
                      rep:StackRep [True, True, False])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckZy:
          _sk5G::P64 = R3;
          _sk5F::P64 = R2;
          _sk5M::P64 = R1;
          if ((Sp + -32) < SpLim) goto ckZC; else goto ckZD;
      ckZD:
          if (HpLim == 0) goto ckZC; else goto ckZE;
      ckZC:
          R3 = _sk5G::P64;
          R2 = _sk5F::P64;
          R1 = _sk5M::P64;
          call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
      ckZE:
          I64[Sp - 32] = ckZv;
          R1 = _sk5F::P64;
          F64[Sp - 24] = F64[_sk5M::P64 + 5];
          I64[Sp - 16] = I64[_sk5M::P64 + 13];
          P64[Sp - 8] = _sk5G::P64;
          Sp = Sp - 32;
          if (R1 & 7 != 0) goto ckZv; else goto ckZw;
      ckZw:
          call (I64[R1])(R1) returns to ckZv, args: 8, res: 8, upd: 8;
      ckZv:
          I64[Sp] = ckZB;
          _sk5J::P64 = P64[R1 + 7];
          R1 = P64[Sp + 24];
          P64[Sp + 24] = _sk5J::P64;
          if (R1 & 7 != 0) goto ckZB; else goto ckZG;
      ckZG:
          call (I64[R1])(R1) returns to ckZB, args: 8, res: 8, upd: 8;
      ckZB:
          D1 = F64[Sp + 8];
          R4 = I64[Sp + 16];
          R3 = P64[R1 + 7];
          R2 = P64[Sp + 24];
          Sp = Sp + 32;
          call Main.$wa_info(D1, R4, R3, R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:54.749846 UTC

{offset
  ckZV:
      _sk5N::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckZW; else goto ckZX;
  ckZX:
      Hp = Hp + 24;
      if (Hp > HpLim) goto ckZZ; else goto ckZY;
  ckZZ:
      HpAlloc = 24;
      goto ckZW;
  ckZW:
      R1 = _sk5N::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckZY:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sk5N::P64;
      _sk3A::P64 = P64[_sk5N::P64 + 16];
      _sk41::P64 = P64[_sk5N::P64 + 24];
      _sk3v::F64 = F64[_sk5N::P64 + 32];
      _sk3x::I64 = I64[_sk5N::P64 + 40];
      I64[Hp - 16] = sat_sk5M_info;
      F64[Hp - 8] = _sk3v::F64;
      I64[Hp] = _sk3x::I64;
      _ckZq::P64 = Hp - 13;
      R4 = _sk3A::P64;
      R3 = _sk41::P64;
      R2 = _ckZq::P64;
      call GHC.List.zipWith_info(R4, R3, R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:54.751252 UTC

{offset
  ckZV:
      _sk5N::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckZW; else goto ckZX;
  ckZX:
      Hp = Hp + 24;
      if (Hp > HpLim) goto ckZZ; else goto ckZY;
  ckZZ:
      HpAlloc = 24;
      goto ckZW;
  ckZW:
      R1 = _sk5N::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckZY:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sk5N::P64;
      _sk3A::P64 = P64[_sk5N::P64 + 16];
      _sk41::P64 = P64[_sk5N::P64 + 24];
      _sk3v::F64 = F64[_sk5N::P64 + 32];
      _sk3x::I64 = I64[_sk5N::P64 + 40];
      I64[Hp - 16] = sat_sk5M_info;
      F64[Hp - 8] = _sk3v::F64;
      I64[Hp] = _sk3x::I64;
      _ckZq::P64 = Hp - 13;
      R4 = _sk3A::P64;
      R3 = _sk41::P64;
      R2 = _ckZq::P64;
      call GHC.List.zipWith_info(R4, R3, R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:54.752657 UTC

{offset
  ckZV:
      _sk5N::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto ckZW; else goto ckZX;
  ckZX:
      Hp = Hp + 24;
      if (Hp > HpLim) goto ckZZ; else goto ckZY;
  ckZZ:
      HpAlloc = 24;
      goto ckZW;
  ckZW:
      R1 = _sk5N::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckZY:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sk5N::P64;
      _sk3A::P64 = P64[_sk5N::P64 + 16];
      _sk41::P64 = P64[_sk5N::P64 + 24];
      _sk3v::F64 = F64[_sk5N::P64 + 32];
      _sk3x::I64 = I64[_sk5N::P64 + 40];
      I64[Hp - 16] = sat_sk5M_info;
      F64[Hp - 8] = _sk3v::F64;
      I64[Hp] = _sk3x::I64;
      _ckZq::P64 = Hp - 13;
      R4 = _sk3A::P64;
      R3 = _sk41::P64;
      R2 = _ckZq::P64;
      call GHC.List.zipWith_info(R4, R3, R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:54.754094 UTC

{offset
  ckZV:
      _sk5N::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto ckZW; else goto ckZX;
  ckZX:
      Hp = Hp + 24;
      if (Hp > HpLim) goto ckZZ; else goto ckZY;
  ckZZ:
      HpAlloc = 24;
      goto ckZW;
  ckZW:
      R1 = _sk5N::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckZY:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _sk5N::P64;
      _sk3A::P64 = P64[_sk5N::P64 + 16];
      _sk41::P64 = P64[_sk5N::P64 + 24];
      _sk3v::F64 = F64[_sk5N::P64 + 32];
      _sk3x::I64 = I64[_sk5N::P64 + 40];
      I64[Hp - 16] = sat_sk5M_info;
      F64[Hp - 8] = _sk3v::F64;
      I64[Hp] = _sk3x::I64;
      _ckZq::P64 = Hp - 13;
      R4 = _sk3A::P64;
      R3 = _sk41::P64;
      R2 = _ckZq::P64;
      Sp = Sp - 16;
      call GHC.List.zipWith_info(R4, R3, R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:54.755513 UTC

{offset
  ckZV:
      _sk5N::P64 = R1;
      if ((Sp + -16) < SpLim) goto ckZW; else goto ckZX;
  ckZX:
      Hp = Hp + 24;
      if (Hp > HpLim) goto ckZZ; else goto ckZY;
  ckZZ:
      HpAlloc = 24;
      goto ckZW;
  ckZW:
      R1 = _sk5N::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  ckZY:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _sk5N::P64;
      _sk3A::P64 = P64[_sk5N::P64 + 16];
      _sk41::P64 = P64[_sk5N::P64 + 24];
      _sk3v::F64 = F64[_sk5N::P64 + 32];
      _sk3x::I64 = I64[_sk5N::P64 + 40];
      I64[Hp - 16] = sat_sk5M_info;
      F64[Hp - 8] = _sk3v::F64;
      I64[Hp] = _sk3x::I64;
      R4 = _sk3A::P64;
      R3 = _sk41::P64;
      R2 = Hp - 13;
      Sp = Sp - 16;
      call GHC.List.zipWith_info(R4, R3, R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:54.757107 UTC

[(ckZV, {sat_sk5M_closure}), (ckZW, {}),
 (ckZX, {sat_sk5M_closure}), (ckZY, {sat_sk5M_closure}), (ckZZ, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:54.757548 UTC

sat_sk5N_entry() //  [R1]
        { info_tbl: [(ckZV,
                      label: sat_sk5N_info
                      rep:HeapRep 2 ptrs 2 nonptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckZV:
          _sk5N::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckZW; else goto ckZX;
      ckZX:
          Hp = Hp + 24;
          if (Hp > HpLim) goto ckZZ; else goto ckZY;
      ckZZ:
          HpAlloc = 24;
          goto ckZW;
      ckZW:
          R1 = _sk5N::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckZY:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _sk5N::P64;
          _sk3A::P64 = P64[_sk5N::P64 + 16];
          _sk41::P64 = P64[_sk5N::P64 + 24];
          _sk3v::F64 = F64[_sk5N::P64 + 32];
          _sk3x::I64 = I64[_sk5N::P64 + 40];
          I64[Hp - 16] = sat_sk5M_info;
          F64[Hp - 8] = _sk3v::F64;
          I64[Hp] = _sk3x::I64;
          R4 = _sk3A::P64;
          R3 = _sk41::P64;
          R2 = Hp - 13;
          Sp = Sp - 16;
          call GHC.List.zipWith_info(R4, R3, R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:54.759235 UTC

sat_sk5N_entry() //  [R1]
        { info_tbl: [(ckZV,
                      label: sat_sk5N_info
                      rep:HeapRep 2 ptrs 2 nonptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ckZV:
          _sk5N::P64 = R1;
          if ((Sp + -16) < SpLim) goto ckZW; else goto ckZX;
      ckZX:
          Hp = Hp + 24;
          if (Hp > HpLim) goto ckZZ; else goto ckZY;
      ckZZ:
          HpAlloc = 24;
          goto ckZW;
      ckZW:
          R1 = _sk5N::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      ckZY:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _sk5N::P64;
          _sk3A::P64 = P64[_sk5N::P64 + 16];
          _sk41::P64 = P64[_sk5N::P64 + 24];
          _sk3v::F64 = F64[_sk5N::P64 + 32];
          _sk3x::I64 = I64[_sk5N::P64 + 40];
          I64[Hp - 16] = sat_sk5M_info;
          F64[Hp - 8] = _sk3v::F64;
          I64[Hp] = _sk3x::I64;
          R4 = _sk3A::P64;
          R3 = _sk41::P64;
          R2 = Hp - 13;
          Sp = Sp - 16;
          call GHC.List.zipWith_info(R4, R3, R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:54.760913 UTC

{offset
  cl0g:
      _sk6c::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cl0h; else goto cl0i;
  cl0i:
      if (HpLim == 0) goto cl0h; else goto cl0o;
  cl0h:
      R1 = _sk6c::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cl0o:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sk6c::P64;
      _sk65::P64 = P64[_sk6c::P64 + 16];
      _sk3m::I64 = I64[_sk6c::P64 + 24];
      _sk66::I64 = I64[_sk6c::P64 + 32];
      _cl0e::I64 = _sk66::I64 == _sk3m::I64;
      _sk69::I64 = _cl0e::I64;
      switch [0 .. 1] _sk69::I64 {
          case 0 : goto cl0m;
          case 1 : goto cl0n;
      }
  cl0n:
      R1 = []_closure+1;
      call (P64[(old + 24)])(R1) args: 24, res: 0, upd: 24;
  cl0m:
      _cl0q::I64 = _sk66::I64 + 1;
      _sk6b::I64 = _cl0q::I64;
      R2 = _sk6b::I64;
      R1 = _sk65::P64;
      call go_sk65_info(R2, R1) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:54.762432 UTC

{offset
  cl0g:
      _sk6c::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cl0h; else goto cl0i;
  cl0i:
      if (HpLim == 0) goto cl0h; else goto cl0o;
  cl0h:
      R1 = _sk6c::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cl0o:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sk6c::P64;
      _sk65::P64 = P64[_sk6c::P64 + 16];
      _sk3m::I64 = I64[_sk6c::P64 + 24];
      _sk66::I64 = I64[_sk6c::P64 + 32];
      _cl0e::I64 = _sk66::I64 == _sk3m::I64;
      _sk69::I64 = _cl0e::I64;
      switch [0 .. 1] _sk69::I64 {
          case 0 : goto cl0m;
          case 1 : goto cl0n;
      }
  cl0n:
      R1 = []_closure+1;
      call (P64[(old + 24)])(R1) args: 24, res: 0, upd: 24;
  cl0m:
      _cl0q::I64 = _sk66::I64 + 1;
      _sk6b::I64 = _cl0q::I64;
      R2 = _sk6b::I64;
      R1 = _sk65::P64;
      call go_sk65_info(R2, R1) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:54.763944 UTC

{offset
  cl0g:
      _sk6c::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cl0h; else goto cl0i;
  cl0i:
      if (HpLim == 0) goto cl0h; else goto cl0o;
  cl0h:
      R1 = _sk6c::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cl0o:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sk6c::P64;
      _sk65::P64 = P64[_sk6c::P64 + 16];
      _sk3m::I64 = I64[_sk6c::P64 + 24];
      _sk66::I64 = I64[_sk6c::P64 + 32];
      _cl0e::I64 = _sk66::I64 == _sk3m::I64;
      _sk69::I64 = _cl0e::I64;
      if (_sk69::I64 != 0) goto cl0n; else goto cl0m;
  cl0n:
      R1 = []_closure+1;
      call (P64[(old + 24)])(R1) args: 24, res: 0, upd: 24;
  cl0m:
      _cl0q::I64 = _sk66::I64 + 1;
      _sk6b::I64 = _cl0q::I64;
      R2 = _sk6b::I64;
      R1 = _sk65::P64;
      call go_sk65_info(R2, R1) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:54.765454 UTC

{offset
  cl0g:
      _sk6c::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto cl0h; else goto cl0i;
  cl0i:
      if (HpLim == 0) goto cl0h; else goto cl0o;
  cl0h:
      R1 = _sk6c::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cl0o:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _sk6c::P64;
      _sk65::P64 = P64[_sk6c::P64 + 16];
      _sk3m::I64 = I64[_sk6c::P64 + 24];
      _sk66::I64 = I64[_sk6c::P64 + 32];
      _cl0e::I64 = _sk66::I64 == _sk3m::I64;
      _sk69::I64 = _cl0e::I64;
      if (_sk69::I64 != 0) goto cl0n; else goto cl0m;
  cl0n:
      R1 = []_closure+1;
      Sp = Sp - 16;
      call (P64[Sp])(R1) args: 24, res: 0, upd: 24;
  cl0m:
      _cl0q::I64 = _sk66::I64 + 1;
      _sk6b::I64 = _cl0q::I64;
      R2 = _sk6b::I64;
      R1 = _sk65::P64;
      Sp = Sp - 16;
      call go_sk65_info(R2, R1) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:54.766949 UTC

{offset
  cl0g:
      _sk6c::P64 = R1;
      if ((Sp + -16) < SpLim) goto cl0h; else goto cl0i;
  cl0i:
      if (HpLim == 0) goto cl0h; else goto cl0o;
  cl0h:
      R1 = _sk6c::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cl0o:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _sk6c::P64;
      _sk66::I64 = I64[_sk6c::P64 + 32];
      if (_sk66::I64 == I64[_sk6c::P64 + 24]) goto cl0n; else goto cl0m;
  cl0n:
      R1 = []_closure+1;
      Sp = Sp - 16;
      call (P64[Sp])(R1) args: 24, res: 0, upd: 24;
  cl0m:
      R2 = _sk66::I64 + 1;
      R1 = P64[_sk6c::P64 + 16];
      Sp = Sp - 16;
      call go_sk65_info(R2, R1) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:54.768466 UTC

[(cl0g, {go_sk65_closure}), (cl0h, {}), (cl0i, {go_sk65_closure}),
 (cl0m, {go_sk65_closure}), (cl0n, {}), (cl0o, {go_sk65_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:54.768954 UTC

sat_sk6c_entry() //  [R1]
        { info_tbl: [(cl0g,
                      label: sat_sk6c_info
                      rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cl0g:
          _sk6c::P64 = R1;
          if ((Sp + -16) < SpLim) goto cl0h; else goto cl0i;
      cl0i:
          if (HpLim == 0) goto cl0h; else goto cl0o;
      cl0h:
          R1 = _sk6c::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      cl0o:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _sk6c::P64;
          _sk66::I64 = I64[_sk6c::P64 + 32];
          if (_sk66::I64 == I64[_sk6c::P64 + 24]) goto cl0n; else goto cl0m;
      cl0n:
          R1 = []_closure+1;
          Sp = Sp - 16;
          call (P64[Sp])(R1) args: 24, res: 0, upd: 24;
      cl0m:
          R2 = _sk66::I64 + 1;
          R1 = P64[_sk6c::P64 + 16];
          Sp = Sp - 16;
          call go_sk65_info(R2, R1) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:54.771012 UTC

sat_sk6c_entry() //  [R1]
        { info_tbl: [(cl0g,
                      label: sat_sk6c_info
                      rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cl0g:
          _sk6c::P64 = R1;
          if ((Sp + -16) < SpLim) goto cl0h; else goto cl0i;
      cl0i:
          if (HpLim == 0) goto cl0h; else goto cl0o;
      cl0h:
          R1 = _sk6c::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      cl0o:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _sk6c::P64;
          _sk66::I64 = I64[_sk6c::P64 + 32];
          if (_sk66::I64 == I64[_sk6c::P64 + 24]) goto cl0n; else goto cl0m;
      cl0n:
          R1 = []_closure+1;
          Sp = Sp - 16;
          call (P64[Sp])(R1) args: 24, res: 0, upd: 24;
      cl0m:
          R2 = _sk66::I64 + 1;
          R1 = P64[_sk6c::P64 + 16];
          Sp = Sp - 16;
          call go_sk65_info(R2, R1) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:54.772512 UTC

{offset
  cl0t:
      _sk66::I64 = R2;
      _sk65::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cl0x; else goto cl0y;
  cl0y:
      Hp = Hp + 80;
      if (Hp > HpLim) goto cl0A; else goto cl0z;
  cl0A:
      HpAlloc = 80;
      goto cl0x;
  cl0x:
      R2 = _sk66::I64;
      R1 = _sk65::P64;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  cl0z:
      _sk3m::I64 = I64[_sk65::P64 + 7];
      I64[Hp - 72] = sat_sk6c_info;
      P64[Hp - 56] = _sk65::P64;
      I64[Hp - 48] = _sk3m::I64;
      I64[Hp - 40] = _sk66::I64;
      _cl0a::P64 = Hp - 72;
      _cl0r::I64 = _sk66::I64;
      _sk67::I64 = _cl0r::I64;
      I64[Hp - 32] = GHC.Word.W64#_con_info;
      I64[Hp - 24] = _sk67::I64;
      _cl0v::P64 = Hp - 31;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _cl0v::P64;
      P64[Hp] = _cl0a::P64;
      _cl0w::P64 = Hp - 14;
      R1 = _cl0w::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:54.774111 UTC

{offset
  cl0t:
      _sk66::I64 = R2;
      _sk65::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cl0x; else goto cl0y;
  cl0y:
      Hp = Hp + 80;
      if (Hp > HpLim) goto cl0A; else goto cl0z;
  cl0A:
      HpAlloc = 80;
      goto cl0x;
  cl0x:
      R2 = _sk66::I64;
      R1 = _sk65::P64;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  cl0z:
      _sk3m::I64 = I64[_sk65::P64 + 7];
      I64[Hp - 72] = sat_sk6c_info;
      P64[Hp - 56] = _sk65::P64;
      I64[Hp - 48] = _sk3m::I64;
      I64[Hp - 40] = _sk66::I64;
      _cl0a::P64 = Hp - 72;
      _cl0r::I64 = _sk66::I64;
      _sk67::I64 = _cl0r::I64;
      I64[Hp - 32] = GHC.Word.W64#_con_info;
      I64[Hp - 24] = _sk67::I64;
      _cl0v::P64 = Hp - 31;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _cl0v::P64;
      P64[Hp] = _cl0a::P64;
      _cl0w::P64 = Hp - 14;
      R1 = _cl0w::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:54.77573 UTC

{offset
  cl0t:
      _sk66::I64 = R2;
      _sk65::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cl0x; else goto cl0y;
  cl0y:
      Hp = Hp + 80;
      if (Hp > HpLim) goto cl0A; else goto cl0z;
  cl0A:
      HpAlloc = 80;
      goto cl0x;
  cl0x:
      R2 = _sk66::I64;
      R1 = _sk65::P64;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  cl0z:
      _sk3m::I64 = I64[_sk65::P64 + 7];
      I64[Hp - 72] = sat_sk6c_info;
      P64[Hp - 56] = _sk65::P64;
      I64[Hp - 48] = _sk3m::I64;
      I64[Hp - 40] = _sk66::I64;
      _cl0a::P64 = Hp - 72;
      _cl0r::I64 = _sk66::I64;
      _sk67::I64 = _cl0r::I64;
      I64[Hp - 32] = GHC.Word.W64#_con_info;
      I64[Hp - 24] = _sk67::I64;
      _cl0v::P64 = Hp - 31;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _cl0v::P64;
      P64[Hp] = _cl0a::P64;
      _cl0w::P64 = Hp - 14;
      R1 = _cl0w::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:54.777379 UTC

{offset
  cl0t:
      _sk66::I64 = R2;
      _sk65::P64 = R1;
      goto cl0y;
  cl0y:
      Hp = Hp + 80;
      if (Hp > HpLim) goto cl0A; else goto cl0z;
  cl0A:
      HpAlloc = 80;
      goto cl0x;
  cl0x:
      R2 = _sk66::I64;
      R1 = _sk65::P64;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  cl0z:
      _sk3m::I64 = I64[_sk65::P64 + 7];
      I64[Hp - 72] = sat_sk6c_info;
      P64[Hp - 56] = _sk65::P64;
      I64[Hp - 48] = _sk3m::I64;
      I64[Hp - 40] = _sk66::I64;
      _cl0a::P64 = Hp - 72;
      _cl0r::I64 = _sk66::I64;
      _sk67::I64 = _cl0r::I64;
      I64[Hp - 32] = GHC.Word.W64#_con_info;
      I64[Hp - 24] = _sk67::I64;
      _cl0v::P64 = Hp - 31;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _cl0v::P64;
      P64[Hp] = _cl0a::P64;
      _cl0w::P64 = Hp - 14;
      R1 = _cl0w::P64;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:54.778908 UTC

{offset
  cl0t:
      goto cl0y;
  cl0y:
      Hp = Hp + 80;
      if (Hp > HpLim) goto cl0A; else goto cl0z;
  cl0A:
      HpAlloc = 80;
      goto cl0x;
  cl0x:
      R2 = R2;
      R1 = R1;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  cl0z:
      _sk3m::I64 = I64[R1 + 7];
      I64[Hp - 72] = sat_sk6c_info;
      P64[Hp - 56] = R1;
      I64[Hp - 48] = _sk3m::I64;
      I64[Hp - 40] = R2;
      I64[Hp - 32] = GHC.Word.W64#_con_info;
      I64[Hp - 24] = R2;
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = Hp - 31;
      P64[Hp] = Hp - 72;
      R1 = Hp - 14;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:54.780541 UTC

[(cl0t, {sat_sk6c_closure}), (cl0x, {}),
 (cl0y, {sat_sk6c_closure}), (cl0z, {sat_sk6c_closure}), (cl0A, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:54.780977 UTC

go_sk65_entry() //  [R2, R1]
        { info_tbl: [(cl0t,
                      label: go_sk65_info
                      rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cl0t:
          goto cl0y;
      cl0y:
          Hp = Hp + 80;
          if (Hp > HpLim) goto cl0A; else goto cl0z;
      cl0A:
          HpAlloc = 80;
          goto cl0x;
      cl0x:
          R2 = R2;
          R1 = R1;
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
      cl0z:
          _sk3m::I64 = I64[R1 + 7];
          I64[Hp - 72] = sat_sk6c_info;
          P64[Hp - 56] = R1;
          I64[Hp - 48] = _sk3m::I64;
          I64[Hp - 40] = R2;
          I64[Hp - 32] = GHC.Word.W64#_con_info;
          I64[Hp - 24] = R2;
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = Hp - 31;
          P64[Hp] = Hp - 72;
          R1 = Hp - 14;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:54.782498 UTC

go_sk65_entry() //  [R2, R1]
        { info_tbl: [(cl0t,
                      label: go_sk65_info
                      rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cl0t:
          Hp = Hp + 80;
          if (Hp > HpLim) goto cl0A; else goto cl0z;
      cl0A:
          HpAlloc = 80;
          R2 = R2;
          R1 = R1;
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
      cl0z:
          _sk3m::I64 = I64[R1 + 7];
          I64[Hp - 72] = sat_sk6c_info;
          P64[Hp - 56] = R1;
          I64[Hp - 48] = _sk3m::I64;
          I64[Hp - 40] = R2;
          I64[Hp - 32] = GHC.Word.W64#_con_info;
          I64[Hp - 24] = R2;
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = Hp - 31;
          P64[Hp] = Hp - 72;
          R1 = Hp - 14;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:54.783952 UTC

{offset
  cl0B:
      if ((old + 0) - <highSp> < SpLim) goto cl0C; else goto cl0D;
  cl0D:
      if (HpLim == 0) goto cl0C; else goto cl0E;
  cl0C:
      R1 = Main.main1_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  cl0E:
      I64[(young<ckRA> + 8)] = ckRA;
      call System.Environment.getProgName1_info() returns to ckRA, args: 8, res: 8, upd: 8;
  ckRA:
      _sk33::P64 = R1;
      I64[(young<ckRC> + 8)] = ckRC;
      call System.Environment.getArgs1_info() returns to ckRC, args: 8, res: 8, upd: 8;
  ckRC:
      _sk36::P64 = R1;
      Hp = Hp + 88;
      if (Hp > HpLim) goto cl0I; else goto cl0H;
  cl0I:
      HpAlloc = 88;
      R1 = _sk36::P64;
      call stg_gc_unpt_r1(R1) returns to ckRC, args: 8, res: 8, upd: 8;
  cl0H:
      I64[Hp - 80] = sat_sk37_info;
      P64[Hp - 64] = _sk33::P64;
      _ckRE::P64 = Hp - 80;
      I64[Hp - 56] = Options.Applicative.Types.ParserInfo_con_info;
      P64[Hp - 48] = lvl20_rjVp_closure+3;
      P64[Hp - 40] = GHC.Types.True_closure+2;
      P64[Hp - 32] = lvl22_rjVr_closure;
      P64[Hp - 24] = _ckRE::P64;
      P64[Hp - 16] = GHC.Base.Nothing_closure+1;
      P64[Hp - 8] = Options.Applicative.Builder.info1_closure;
      P64[Hp] = GHC.Types.True_closure+2;
      _ckRM::P64 = Hp - 55;
      I64[(young<ckRN> + 8)] = ckRN;
      R4 = _sk36::P64;
      R3 = _ckRM::P64;
      R2 = Options.Applicative.Builder.prefs1_closure;
      call Options.Applicative.Extra.execParserPure_info(R4,
                                                         R3,
                                                         R2) returns to ckRN, args: 8, res: 8, upd: 8;
  ckRN:
      _sk39::P64 = R1;
      I64[(young<ckRR> + 8)] = ckRR;
      R2 = _sk39::P64;
      call Options.Applicative.Extra.customExecParser2_info(R2) returns to ckRR, args: 8, res: 8, upd: 8;
  ckRR:
      _sk3c::P64 = R1;
      I64[(young<ckRT> + 8)] = ckRT;
      R1 = _sk3c::P64;
      if (R1 & 7 != 0) goto ckRT; else goto ckRU;
  ckRU:
      call (I64[R1])(R1) returns to ckRT, args: 8, res: 8, upd: 8;
  ckRT:
      _sk3d::P64 = R1;
      _sk3e::P64 = P64[_sk3d::P64 + 7];
      _sk3f::P64 = P64[_sk3d::P64 + 15];
      _sk3g::P64 = P64[_sk3d::P64 + 23];
      _sk3h::P64 = P64[_sk3d::P64 + 31];
      _sk3i::P64 = P64[_sk3d::P64 + 39];
      _sk3j::P64 = P64[_sk3d::P64 + 47];
      _sk3k::P64 = P64[_sk3d::P64 + 55];
      I64[(young<ckRY> + 8)] = ckRY;
      R1 = _sk3f::P64;
      if (R1 & 7 != 0) goto ckRY; else goto ckRZ;
  ckRZ:
      call (I64[R1])(R1) returns to ckRY, args: 8, res: 8, upd: 8;
  ckRY:
      _sk3l::P64 = R1;
      _sk3m::I64 = I64[_sk3l::P64 + 7];
      _ckS3::I64 = _sk3m::I64;
      _sk3o::I64 = _ckS3::I64;
      _ckS6::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_sk3o::I64));
      _sk3p::I64 = _ckS6::I64;
      _ckS9::I64 = setNumCapabilities;
      _ckSa::I64 = _sk3p::I64;
      I64[(young<ckSb> + 8)] = ckSb;
      foreign call "ccall" arg hints:  []  result hints:  [] (_ckS9::I64)(...) returns to ckSb args: ([_ckSa::I64]) ress: ([])ret_args: 8ret_off: 8;
  ckSb:
      I64[(young<ckSd> + 8)] = ckSd;
      R1 = _sk3k::P64;
      if (R1 & 7 != 0) goto ckSd; else goto ckSe;
  ckSe:
      call (I64[R1])(R1) returns to ckSd, args: 8, res: 8, upd: 8;
  ckSd:
      _sk3s::P64 = R1;
      _sk3t::I64 = I64[_sk3s::P64 + 7];
      I64[(young<ckSi> + 8)] = ckSi;
      R1 = _sk3j::P64;
      if (R1 & 7 != 0) goto ckSi; else goto ckSj;
  ckSj:
      call (I64[R1])(R1) returns to ckSi, args: 8, res: 8, upd: 8;
  ckSi:
      _sk3u::P64 = R1;
      _sk3v::F64 = F64[_sk3u::P64 + 7];
      I64[(young<ckSn> + 8)] = ckSn;
      R1 = _sk3e::P64;
      if (R1 & 7 != 0) goto ckSn; else goto ckSo;
  ckSo:
      call (I64[R1])(R1) returns to ckSn, args: 8, res: 8, upd: 8;
  ckSn:
      _sk3w::P64 = R1;
      Hp = Hp + 16;
      if (Hp > HpLim) goto cl0S; else goto cl0R;
  cl0S:
      HpAlloc = 16;
      R1 = _sk3w::P64;
      call stg_gc_unpt_r1(R1) returns to ckSn, args: 8, res: 8, upd: 8;
  cl0R:
      _sk3x::I64 = I64[_sk3w::P64 + 7];
      _cl00::I64 = %MO_S_Gt_W64(1, _sk3m::I64);
      _sk63::I64 = _cl00::I64;
      switch [0 .. 1] _sk63::I64 {
          case 0 : goto cl29;
          case 1 : goto cl2h;
      }
  cl2h:
      Hp = Hp - 16;
      _sk3A::P64 = GHC.Types.[]_closure+1;
      goto ckSv;
  cl29:
      _cl05::P64 = Hp - 7;
      I64[Hp - 8] = go_sk65_info;
      I64[Hp] = _sk3m::I64;
      I64[(young<cl27> + 8)] = cl27;
      R2 = 1;
      R1 = _cl05::P64;
      call go_sk65_info(R2, R1) returns to cl27, args: 8, res: 8, upd: 8;
  cl27:
      _sk6d::P64 = R1;
      I64[(young<cl2d> + 8)] = cl2d;
      R2 = _sk6d::P64;
      call Main.initGens2_info(R2) returns to cl2d, args: 8, res: 8, upd: 8;
  cl2d:
      _sk6g::P64 = R1;
      _sk3A::P64 = _sk6g::P64;
      goto ckSv;
  ckSv:
      if (HpLim == 0) goto cl0T; else goto cl0U;
  cl0T:
      I64[(young<ckSu> + 8)] = ckSu;
      R1 = _sk3A::P64;
      call stg_gc_unpt_r1(R1) returns to ckSu, args: 8, res: 8, upd: 8;
  ckSu:
      _sk3A::P64 = R1;
      goto ckSv;
  cl0U:
      I64[(young<ckSx> + 8)] = ckSx;
      R1 = SkipList.newSL2_closure+1;
      call stg_norec_atomically#(R1) returns to ckSx, args: 8, res: 8, upd: 8;
  ckSx:
      _sk3D::P64 = R1;
      Hp = Hp + 16;
      if (Hp > HpLim) goto cl0X; else goto cl0W;
  cl0X:
      HpAlloc = 16;
      R1 = _sk3D::P64;
      call stg_gc_unpt_r1(R1) returns to ckSx, args: 8, res: 8, upd: 8;
  cl0W:
      _ckSz::P64 = Hp - 6;
      I64[Hp - 8] = a7_sk3E_info;
      P64[Hp] = _sk3D::P64;
      I64[(young<ckU1> + 8)] = ckU1;
      R4 = _sk3x::I64;
      R3 = 2;
      R2 = 0;
      call GHC.Enum.$w$cenumFromThenTo_info(R4,
                                            R3,
                                            R2) returns to ckU1, args: 8, res: 8, upd: 8;
  ckU1:
      _sk3V::P64 = R1;
      I64[(young<ckU5> + 8)] = ckU5;
      R2 = _sk3V::P64;
      R1 = _ckSz::P64;
      call a7_sk3E_info(R2, R1) returns to ckU5, args: 8, res: 8, upd: 8;
  ckU5:
      _sk3Y::P64 = R1;
      _cl1N::I64 = %MO_S_Lt_W64(0, _sk3m::I64);
      _sk5U::I64 = _cl1N::I64;
      switch [0 .. 1] _sk5U::I64 {
          case 0 : goto cl1U;
          case 1 : goto cl1Z;
      }
  cl1Z:
      I64[(young<cl1Y> + 8)] = cl1Y;
      R2 = _sk3m::I64;
      call $wxs_rjVo_info(R2) returns to cl1Y, args: 8, res: 8, upd: 8;
  cl1Y:
      _sk5Z::P64 = R1;
      I64[(young<cl23> + 8)] = cl23;
      R2 = _sk5Z::P64;
      call Control.Monad.replicateM4_info(R2) returns to cl23, args: 8, res: 8, upd: 8;
  cl23:
      _sk62::P64 = R1;
      _sk41::P64 = _sk62::P64;
      goto ckUa;
  cl1U:
      I64[(young<cl1S> + 8)] = cl1S;
      R2 = GHC.Types.[]_closure+1;
      call Control.Monad.replicateM4_info(R2) returns to cl1S, args: 8, res: 8, upd: 8;
  cl1S:
      _sk5Y::P64 = R1;
      _sk41::P64 = _sk5Y::P64;
      goto ckUa;
  ckUa:
      if (HpLim == 0) goto cl10; else goto cl11;
  cl10:
      I64[(young<ckU9> + 8)] = ckU9;
      R1 = _sk41::P64;
      call stg_gc_unpt_r1(R1) returns to ckU9, args: 8, res: 8, upd: 8;
  ckU9:
      _sk41::P64 = R1;
      goto ckUa;
  cl11:
      I64[(young<ckUc> + 8)] = ckUc;
      R1 = _sk3g::P64;
      if (R1 & 7 != 0) goto ckUc; else goto ckUd;
  ckUd:
      call (I64[R1])(R1) returns to ckUc, args: 8, res: 8, upd: 8;
  ckUc:
      _sk42::P64 = R1;
      _cl2i::P64 = _sk42::P64 & 7;
      switch [1 .. 2] _cl2i::P64 {
          case 1 : goto cl19;
          case 2 : goto cl1M;
      }
  cl1M:
      R1 = GHC.Tuple.()_closure+1;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
  cl19:
      I64[(young<ckY5> + 8)] = ckY5;
      R1 = _sk3h::P64;
      if (R1 & 7 != 0) goto ckY5; else goto ckY6;
  ckY6:
      call (I64[R1])(R1) returns to ckY5, args: 8, res: 8, upd: 8;
  ckY5:
      _sk52::P64 = R1;
      _cl2j::P64 = _sk52::P64 & 7;
      switch [1 .. 2] _cl2j::P64 {
          case 1 : goto cl1i;
          case 2 : goto cl1z;
      }
  cl1z:
      Hp = Hp + 64;
      if (Hp > HpLim) goto cl1C; else goto cl1B;
  cl1C:
      HpAlloc = 64;
      R1 = _sk52::P64;
      call stg_gc_unpt_r1(R1) returns to ckY5, args: 8, res: 8, upd: 8;
  cl1B:
      I64[Hp - 56] = sat_sk5N_info;
      P64[Hp - 40] = _sk3A::P64;
      P64[Hp - 32] = _sk41::P64;
      F64[Hp - 24] = _sk3v::F64;
      I64[Hp - 16] = _sk3x::I64;
      _ckZm::P64 = Hp - 56;
      _cl1s::I64 = _sk3t::I64 * 1000;
      _sk5D::I64 = _cl1s::I64;
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _sk5D::I64;
      _cl1v::P64 = Hp - 7;
      I64[(young<cl1w> + 8)] = cl1w;
      R3 = _ckZm::P64;
      R2 = _cl1v::P64;
      call Throughput.throughputMain1_info(R3,
                                           R2) returns to cl1w, args: 8, res: 8, upd: 8;
  cl1w:
      _sk5Q::P64 = R1;
      I64[(young<cl1y> + 8)] = cl1y;
      R1 = _sk5Q::P64;
      if (R1 & 7 != 0) goto cl1y; else goto cl1E;
  cl1E:
      call (I64[R1])(R1) returns to cl1y, args: 8, res: 8, upd: 8;
  cl1y:
      _sk5R::P64 = R1;
      _sk5S::P64 = P64[_sk5R::P64 + 7];
      _sk5T::P64 = P64[_sk5R::P64 + 15];
      _sk46::P64 = _sk5T::P64;
      _sk45::P64 = _sk5S::P64;
      goto ckUk;
  cl1i:
      Hp = Hp + 72;
      if (Hp > HpLim) goto cl1l; else goto cl1k;
  cl1l:
      HpAlloc = 72;
      R1 = _sk52::P64;
      call stg_gc_unpt_r1(R1) returns to ckY5, args: 8, res: 8, upd: 8;
  cl1k:
      I64[Hp - 64] = sat_sk5w_info;
      P64[Hp - 48] = _sk3A::P64;
      P64[Hp - 40] = _sk3D::P64;
      P64[Hp - 32] = _sk41::P64;
      F64[Hp - 24] = _sk3v::F64;
      I64[Hp - 16] = _sk3x::I64;
      _ckYa::P64 = Hp - 64;
      _cl1a::I64 = _sk3t::I64 * 1000;
      _sk53::I64 = _cl1a::I64;
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _sk53::I64;
      _cl1d::P64 = Hp - 7;
      I64[(young<cl1e> + 8)] = cl1e;
      R3 = _ckYa::P64;
      R2 = _cl1d::P64;
      call Throughput.throughputMain1_info(R3,
                                           R2) returns to cl1e, args: 8, res: 8, upd: 8;
  cl1e:
      _sk5z::P64 = R1;
      I64[(young<cl1g> + 8)] = cl1g;
      R1 = _sk5z::P64;
      if (R1 & 7 != 0) goto cl1g; else goto cl1n;
  cl1n:
      call (I64[R1])(R1) returns to cl1g, args: 8, res: 8, upd: 8;
  cl1g:
      _sk5A::P64 = R1;
      _sk5B::P64 = P64[_sk5A::P64 + 7];
      _sk5C::P64 = P64[_sk5A::P64 + 15];
      _sk46::P64 = _sk5C::P64;
      _sk45::P64 = _sk5B::P64;
      goto ckUk;
  ckUk:
      if (HpLim == 0) goto cl13; else goto cl14;
  cl13:
      I64[(young<ckUj> + 8)] = ckUj;
      R2 = _sk46::P64;
      R1 = _sk45::P64;
      call stg_gc_pp(R2, R1) returns to ckUj, args: 8, res: 8, upd: 8;
  ckUj:
      _sk46::P64 = R2;
      _sk45::P64 = R1;
      goto ckUk;
  cl14:
      I64[(young<ckUm> + 8)] = ckUm;
      R2 = _sk41::P64;
      call a5_rjVe_info(R2) returns to ckUm, args: 8, res: 8, upd: 8;
  ckUm:
      _sk49::P64 = R1;
      Hp = Hp + 64;
      if (Hp > HpLim) goto cl17; else goto cl16;
  cl17:
      HpAlloc = 64;
      R1 = _sk49::P64;
      call stg_gc_unpt_r1(R1) returns to ckUm, args: 8, res: 8, upd: 8;
  cl16:
      I64[Hp - 56] = sat_sk51_info;
      P64[Hp - 40] = _sk33::P64;
      P64[Hp - 32] = _sk45::P64;
      P64[Hp - 24] = _sk46::P64;
      P64[Hp - 16] = _sk49::P64;
      I64[Hp - 8] = _sk3m::I64;
      I64[Hp] = _sk3x::I64;
      _ckUo::P64 = Hp - 56;
      R4 = GHC.Types.True_closure+2;
      R3 = _ckUo::P64;
      R2 = GHC.IO.Handle.FD.stdout_closure;
      call GHC.IO.Handle.Text.hPutStr2_info(R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:54.799735 UTC

{offset
  cl0B:
      if ((old + 0) - <highSp> < SpLim) goto cl0C; else goto cl0D;
  cl0D:
      if (HpLim == 0) goto cl0C; else goto cl0E;
  cl0C:
      R1 = Main.main1_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  cl0E:
      I64[(young<ckRA> + 8)] = ckRA;
      call System.Environment.getProgName1_info() returns to ckRA, args: 8, res: 8, upd: 8;
  ckRA:
      _sk33::P64 = R1;
      I64[(young<ckRC> + 8)] = ckRC;
      call System.Environment.getArgs1_info() returns to ckRC, args: 8, res: 8, upd: 8;
  ckRC:
      _sk36::P64 = R1;
      Hp = Hp + 88;
      if (Hp > HpLim) goto cl0I; else goto cl0H;
  cl0I:
      HpAlloc = 88;
      R1 = _sk36::P64;
      call stg_gc_unpt_r1(R1) returns to ckRC, args: 8, res: 8, upd: 8;
  cl0H:
      I64[Hp - 80] = sat_sk37_info;
      P64[Hp - 64] = _sk33::P64;
      _ckRE::P64 = Hp - 80;
      I64[Hp - 56] = Options.Applicative.Types.ParserInfo_con_info;
      P64[Hp - 48] = lvl20_rjVp_closure+3;
      P64[Hp - 40] = GHC.Types.True_closure+2;
      P64[Hp - 32] = lvl22_rjVr_closure;
      P64[Hp - 24] = _ckRE::P64;
      P64[Hp - 16] = GHC.Base.Nothing_closure+1;
      P64[Hp - 8] = Options.Applicative.Builder.info1_closure;
      P64[Hp] = GHC.Types.True_closure+2;
      _ckRM::P64 = Hp - 55;
      I64[(young<ckRN> + 8)] = ckRN;
      R4 = _sk36::P64;
      R3 = _ckRM::P64;
      R2 = Options.Applicative.Builder.prefs1_closure;
      call Options.Applicative.Extra.execParserPure_info(R4,
                                                         R3,
                                                         R2) returns to ckRN, args: 8, res: 8, upd: 8;
  ckRN:
      _sk39::P64 = R1;
      I64[(young<ckRR> + 8)] = ckRR;
      R2 = _sk39::P64;
      call Options.Applicative.Extra.customExecParser2_info(R2) returns to ckRR, args: 8, res: 8, upd: 8;
  ckRR:
      _sk3c::P64 = R1;
      I64[(young<ckRT> + 8)] = ckRT;
      R1 = _sk3c::P64;
      if (R1 & 7 != 0) goto ckRT; else goto ckRU;
  ckRU:
      call (I64[R1])(R1) returns to ckRT, args: 8, res: 8, upd: 8;
  ckRT:
      _sk3d::P64 = R1;
      _sk3e::P64 = P64[_sk3d::P64 + 7];
      _sk3f::P64 = P64[_sk3d::P64 + 15];
      _sk3g::P64 = P64[_sk3d::P64 + 23];
      _sk3h::P64 = P64[_sk3d::P64 + 31];
      _sk3i::P64 = P64[_sk3d::P64 + 39];
      _sk3j::P64 = P64[_sk3d::P64 + 47];
      _sk3k::P64 = P64[_sk3d::P64 + 55];
      I64[(young<ckRY> + 8)] = ckRY;
      R1 = _sk3f::P64;
      if (R1 & 7 != 0) goto ckRY; else goto ckRZ;
  ckRZ:
      call (I64[R1])(R1) returns to ckRY, args: 8, res: 8, upd: 8;
  ckRY:
      _sk3l::P64 = R1;
      _sk3m::I64 = I64[_sk3l::P64 + 7];
      _ckS3::I64 = _sk3m::I64;
      _sk3o::I64 = _ckS3::I64;
      _ckS6::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_sk3o::I64));
      _sk3p::I64 = _ckS6::I64;
      _ckS9::I64 = setNumCapabilities;
      _ckSa::I64 = _sk3p::I64;
      I64[(young<ckSb> + 8)] = ckSb;
      foreign call "ccall" arg hints:  []  result hints:  [] (_ckS9::I64)(...) returns to ckSb args: ([_ckSa::I64]) ress: ([])ret_args: 8ret_off: 8;
  ckSb:
      I64[(young<ckSd> + 8)] = ckSd;
      R1 = _sk3k::P64;
      if (R1 & 7 != 0) goto ckSd; else goto ckSe;
  ckSe:
      call (I64[R1])(R1) returns to ckSd, args: 8, res: 8, upd: 8;
  ckSd:
      _sk3s::P64 = R1;
      _sk3t::I64 = I64[_sk3s::P64 + 7];
      I64[(young<ckSi> + 8)] = ckSi;
      R1 = _sk3j::P64;
      if (R1 & 7 != 0) goto ckSi; else goto ckSj;
  ckSj:
      call (I64[R1])(R1) returns to ckSi, args: 8, res: 8, upd: 8;
  ckSi:
      _sk3u::P64 = R1;
      _sk3v::F64 = F64[_sk3u::P64 + 7];
      I64[(young<ckSn> + 8)] = ckSn;
      R1 = _sk3e::P64;
      if (R1 & 7 != 0) goto ckSn; else goto ckSo;
  ckSo:
      call (I64[R1])(R1) returns to ckSn, args: 8, res: 8, upd: 8;
  ckSn:
      _sk3w::P64 = R1;
      Hp = Hp + 16;
      if (Hp > HpLim) goto cl0S; else goto cl0R;
  cl0S:
      HpAlloc = 16;
      R1 = _sk3w::P64;
      call stg_gc_unpt_r1(R1) returns to ckSn, args: 8, res: 8, upd: 8;
  cl0R:
      _sk3x::I64 = I64[_sk3w::P64 + 7];
      _cl00::I64 = %MO_S_Gt_W64(1, _sk3m::I64);
      _sk63::I64 = _cl00::I64;
      switch [0 .. 1] _sk63::I64 {
          case 0 : goto cl29;
          case 1 : goto cl2h;
      }
  cl2h:
      Hp = Hp - 16;
      _sk3A::P64 = GHC.Types.[]_closure+1;
      goto ckSv;
  cl29:
      _cl05::P64 = Hp - 7;
      I64[Hp - 8] = go_sk65_info;
      I64[Hp] = _sk3m::I64;
      I64[(young<cl27> + 8)] = cl27;
      R2 = 1;
      R1 = _cl05::P64;
      call go_sk65_info(R2, R1) returns to cl27, args: 8, res: 8, upd: 8;
  cl27:
      _sk6d::P64 = R1;
      I64[(young<cl2d> + 8)] = cl2d;
      R2 = _sk6d::P64;
      call Main.initGens2_info(R2) returns to cl2d, args: 8, res: 8, upd: 8;
  cl2d:
      _sk6g::P64 = R1;
      _sk3A::P64 = _sk6g::P64;
      goto ckSv;
  ckSv:
      if (HpLim == 0) goto cl0T; else goto cl0U;
  cl0T:
      I64[(young<ckSu> + 8)] = ckSu;
      R1 = _sk3A::P64;
      call stg_gc_unpt_r1(R1) returns to ckSu, args: 8, res: 8, upd: 8;
  ckSu:
      _sk3A::P64 = R1;
      goto ckSv;
  cl0U:
      I64[(young<ckSx> + 8)] = ckSx;
      R1 = SkipList.newSL2_closure+1;
      call stg_norec_atomically#(R1) returns to ckSx, args: 8, res: 8, upd: 8;
  ckSx:
      _sk3D::P64 = R1;
      Hp = Hp + 16;
      if (Hp > HpLim) goto cl0X; else goto cl0W;
  cl0X:
      HpAlloc = 16;
      R1 = _sk3D::P64;
      call stg_gc_unpt_r1(R1) returns to ckSx, args: 8, res: 8, upd: 8;
  cl0W:
      _ckSz::P64 = Hp - 6;
      I64[Hp - 8] = a7_sk3E_info;
      P64[Hp] = _sk3D::P64;
      I64[(young<ckU1> + 8)] = ckU1;
      R4 = _sk3x::I64;
      R3 = 2;
      R2 = 0;
      call GHC.Enum.$w$cenumFromThenTo_info(R4,
                                            R3,
                                            R2) returns to ckU1, args: 8, res: 8, upd: 8;
  ckU1:
      _sk3V::P64 = R1;
      I64[(young<ckU5> + 8)] = ckU5;
      R2 = _sk3V::P64;
      R1 = _ckSz::P64;
      call a7_sk3E_info(R2, R1) returns to ckU5, args: 8, res: 8, upd: 8;
  ckU5:
      _sk3Y::P64 = R1;
      _cl1N::I64 = %MO_S_Lt_W64(0, _sk3m::I64);
      _sk5U::I64 = _cl1N::I64;
      switch [0 .. 1] _sk5U::I64 {
          case 0 : goto cl1U;
          case 1 : goto cl1Z;
      }
  cl1Z:
      I64[(young<cl1Y> + 8)] = cl1Y;
      R2 = _sk3m::I64;
      call $wxs_rjVo_info(R2) returns to cl1Y, args: 8, res: 8, upd: 8;
  cl1Y:
      _sk5Z::P64 = R1;
      I64[(young<cl23> + 8)] = cl23;
      R2 = _sk5Z::P64;
      call Control.Monad.replicateM4_info(R2) returns to cl23, args: 8, res: 8, upd: 8;
  cl23:
      _sk62::P64 = R1;
      _sk41::P64 = _sk62::P64;
      goto ckUa;
  cl1U:
      I64[(young<cl1S> + 8)] = cl1S;
      R2 = GHC.Types.[]_closure+1;
      call Control.Monad.replicateM4_info(R2) returns to cl1S, args: 8, res: 8, upd: 8;
  cl1S:
      _sk5Y::P64 = R1;
      _sk41::P64 = _sk5Y::P64;
      goto ckUa;
  ckUa:
      if (HpLim == 0) goto cl10; else goto cl11;
  cl10:
      I64[(young<ckU9> + 8)] = ckU9;
      R1 = _sk41::P64;
      call stg_gc_unpt_r1(R1) returns to ckU9, args: 8, res: 8, upd: 8;
  ckU9:
      _sk41::P64 = R1;
      goto ckUa;
  cl11:
      I64[(young<ckUc> + 8)] = ckUc;
      R1 = _sk3g::P64;
      if (R1 & 7 != 0) goto ckUc; else goto ckUd;
  ckUd:
      call (I64[R1])(R1) returns to ckUc, args: 8, res: 8, upd: 8;
  ckUc:
      _sk42::P64 = R1;
      _cl2i::P64 = _sk42::P64 & 7;
      switch [1 .. 2] _cl2i::P64 {
          case 1 : goto cl19;
          case 2 : goto cl1M;
      }
  cl1M:
      R1 = GHC.Tuple.()_closure+1;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
  cl19:
      I64[(young<ckY5> + 8)] = ckY5;
      R1 = _sk3h::P64;
      if (R1 & 7 != 0) goto ckY5; else goto ckY6;
  ckY6:
      call (I64[R1])(R1) returns to ckY5, args: 8, res: 8, upd: 8;
  ckY5:
      _sk52::P64 = R1;
      _cl2j::P64 = _sk52::P64 & 7;
      switch [1 .. 2] _cl2j::P64 {
          case 1 : goto cl1i;
          case 2 : goto cl1z;
      }
  cl1z:
      Hp = Hp + 64;
      if (Hp > HpLim) goto cl1C; else goto cl1B;
  cl1C:
      HpAlloc = 64;
      R1 = _sk52::P64;
      call stg_gc_unpt_r1(R1) returns to ckY5, args: 8, res: 8, upd: 8;
  cl1B:
      I64[Hp - 56] = sat_sk5N_info;
      P64[Hp - 40] = _sk3A::P64;
      P64[Hp - 32] = _sk41::P64;
      F64[Hp - 24] = _sk3v::F64;
      I64[Hp - 16] = _sk3x::I64;
      _ckZm::P64 = Hp - 56;
      _cl1s::I64 = _sk3t::I64 * 1000;
      _sk5D::I64 = _cl1s::I64;
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _sk5D::I64;
      _cl1v::P64 = Hp - 7;
      I64[(young<cl1w> + 8)] = cl1w;
      R3 = _ckZm::P64;
      R2 = _cl1v::P64;
      call Throughput.throughputMain1_info(R3,
                                           R2) returns to cl1w, args: 8, res: 8, upd: 8;
  cl1w:
      _sk5Q::P64 = R1;
      I64[(young<cl1y> + 8)] = cl1y;
      R1 = _sk5Q::P64;
      if (R1 & 7 != 0) goto cl1y; else goto cl1E;
  cl1E:
      call (I64[R1])(R1) returns to cl1y, args: 8, res: 8, upd: 8;
  cl1y:
      _sk5R::P64 = R1;
      _sk5S::P64 = P64[_sk5R::P64 + 7];
      _sk5T::P64 = P64[_sk5R::P64 + 15];
      _sk46::P64 = _sk5T::P64;
      _sk45::P64 = _sk5S::P64;
      goto ckUk;
  cl1i:
      Hp = Hp + 72;
      if (Hp > HpLim) goto cl1l; else goto cl1k;
  cl1l:
      HpAlloc = 72;
      R1 = _sk52::P64;
      call stg_gc_unpt_r1(R1) returns to ckY5, args: 8, res: 8, upd: 8;
  cl1k:
      I64[Hp - 64] = sat_sk5w_info;
      P64[Hp - 48] = _sk3A::P64;
      P64[Hp - 40] = _sk3D::P64;
      P64[Hp - 32] = _sk41::P64;
      F64[Hp - 24] = _sk3v::F64;
      I64[Hp - 16] = _sk3x::I64;
      _ckYa::P64 = Hp - 64;
      _cl1a::I64 = _sk3t::I64 * 1000;
      _sk53::I64 = _cl1a::I64;
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _sk53::I64;
      _cl1d::P64 = Hp - 7;
      I64[(young<cl1e> + 8)] = cl1e;
      R3 = _ckYa::P64;
      R2 = _cl1d::P64;
      call Throughput.throughputMain1_info(R3,
                                           R2) returns to cl1e, args: 8, res: 8, upd: 8;
  cl1e:
      _sk5z::P64 = R1;
      I64[(young<cl1g> + 8)] = cl1g;
      R1 = _sk5z::P64;
      if (R1 & 7 != 0) goto cl1g; else goto cl1n;
  cl1n:
      call (I64[R1])(R1) returns to cl1g, args: 8, res: 8, upd: 8;
  cl1g:
      _sk5A::P64 = R1;
      _sk5B::P64 = P64[_sk5A::P64 + 7];
      _sk5C::P64 = P64[_sk5A::P64 + 15];
      _sk46::P64 = _sk5C::P64;
      _sk45::P64 = _sk5B::P64;
      goto ckUk;
  ckUk:
      if (HpLim == 0) goto cl13; else goto cl14;
  cl13:
      I64[(young<ckUj> + 8)] = ckUj;
      R2 = _sk46::P64;
      R1 = _sk45::P64;
      call stg_gc_pp(R2, R1) returns to ckUj, args: 8, res: 8, upd: 8;
  ckUj:
      _sk46::P64 = R2;
      _sk45::P64 = R1;
      goto ckUk;
  cl14:
      I64[(young<ckUm> + 8)] = ckUm;
      R2 = _sk41::P64;
      call a5_rjVe_info(R2) returns to ckUm, args: 8, res: 8, upd: 8;
  ckUm:
      _sk49::P64 = R1;
      Hp = Hp + 64;
      if (Hp > HpLim) goto cl17; else goto cl16;
  cl17:
      HpAlloc = 64;
      R1 = _sk49::P64;
      call stg_gc_unpt_r1(R1) returns to ckUm, args: 8, res: 8, upd: 8;
  cl16:
      I64[Hp - 56] = sat_sk51_info;
      P64[Hp - 40] = _sk33::P64;
      P64[Hp - 32] = _sk45::P64;
      P64[Hp - 24] = _sk46::P64;
      P64[Hp - 16] = _sk49::P64;
      I64[Hp - 8] = _sk3m::I64;
      I64[Hp] = _sk3x::I64;
      _ckUo::P64 = Hp - 56;
      R4 = GHC.Types.True_closure+2;
      R3 = _ckUo::P64;
      R2 = GHC.IO.Handle.FD.stdout_closure;
      call GHC.IO.Handle.Text.hPutStr2_info(R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:54.815471 UTC

{offset
  cl0B:
      if ((old + 0) - <highSp> < SpLim) goto cl0C; else goto cl0D;
  cl0D:
      if (HpLim == 0) goto cl0C; else goto cl0E;
  cl0C:
      R1 = Main.main1_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  cl0E:
      I64[(young<ckRA> + 8)] = ckRA;
      call System.Environment.getProgName1_info() returns to ckRA, args: 8, res: 8, upd: 8;
  ckRA:
      _sk33::P64 = R1;
      I64[(young<ckRC> + 8)] = ckRC;
      call System.Environment.getArgs1_info() returns to ckRC, args: 8, res: 8, upd: 8;
  ckRC:
      _sk36::P64 = R1;
      Hp = Hp + 88;
      if (Hp > HpLim) goto cl0I; else goto cl0H;
  cl0I:
      HpAlloc = 88;
      R1 = _sk36::P64;
      call stg_gc_unpt_r1(R1) returns to ckRC, args: 8, res: 8, upd: 8;
  cl0H:
      I64[Hp - 80] = sat_sk37_info;
      P64[Hp - 64] = _sk33::P64;
      _ckRE::P64 = Hp - 80;
      I64[Hp - 56] = Options.Applicative.Types.ParserInfo_con_info;
      P64[Hp - 48] = lvl20_rjVp_closure+3;
      P64[Hp - 40] = GHC.Types.True_closure+2;
      P64[Hp - 32] = lvl22_rjVr_closure;
      P64[Hp - 24] = _ckRE::P64;
      P64[Hp - 16] = GHC.Base.Nothing_closure+1;
      P64[Hp - 8] = Options.Applicative.Builder.info1_closure;
      P64[Hp] = GHC.Types.True_closure+2;
      _ckRM::P64 = Hp - 55;
      I64[(young<ckRN> + 8)] = ckRN;
      R4 = _sk36::P64;
      R3 = _ckRM::P64;
      R2 = Options.Applicative.Builder.prefs1_closure;
      call Options.Applicative.Extra.execParserPure_info(R4,
                                                         R3,
                                                         R2) returns to ckRN, args: 8, res: 8, upd: 8;
  ckRN:
      _sk39::P64 = R1;
      I64[(young<ckRR> + 8)] = ckRR;
      R2 = _sk39::P64;
      call Options.Applicative.Extra.customExecParser2_info(R2) returns to ckRR, args: 8, res: 8, upd: 8;
  ckRR:
      _sk3c::P64 = R1;
      I64[(young<ckRT> + 8)] = ckRT;
      R1 = _sk3c::P64;
      if (R1 & 7 != 0) goto ckRT; else goto ckRU;
  ckRU:
      call (I64[R1])(R1) returns to ckRT, args: 8, res: 8, upd: 8;
  ckRT:
      _sk3d::P64 = R1;
      _sk3e::P64 = P64[_sk3d::P64 + 7];
      _sk3f::P64 = P64[_sk3d::P64 + 15];
      _sk3g::P64 = P64[_sk3d::P64 + 23];
      _sk3h::P64 = P64[_sk3d::P64 + 31];
      _sk3i::P64 = P64[_sk3d::P64 + 39];
      _sk3j::P64 = P64[_sk3d::P64 + 47];
      _sk3k::P64 = P64[_sk3d::P64 + 55];
      I64[(young<ckRY> + 8)] = ckRY;
      R1 = _sk3f::P64;
      if (R1 & 7 != 0) goto ckRY; else goto ckRZ;
  ckRZ:
      call (I64[R1])(R1) returns to ckRY, args: 8, res: 8, upd: 8;
  ckRY:
      _sk3l::P64 = R1;
      _sk3m::I64 = I64[_sk3l::P64 + 7];
      _ckS3::I64 = _sk3m::I64;
      _sk3o::I64 = _ckS3::I64;
      _ckS6::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_sk3o::I64));
      _sk3p::I64 = _ckS6::I64;
      _ckS9::I64 = setNumCapabilities;
      _ckSa::I64 = _sk3p::I64;
      I64[(young<ckSb> + 8)] = ckSb;
      foreign call "ccall" arg hints:  []  result hints:  [] (_ckS9::I64)(...) returns to ckSb args: ([_ckSa::I64]) ress: ([])ret_args: 8ret_off: 8;
  ckSb:
      I64[(young<ckSd> + 8)] = ckSd;
      R1 = _sk3k::P64;
      if (R1 & 7 != 0) goto ckSd; else goto ckSe;
  ckSe:
      call (I64[R1])(R1) returns to ckSd, args: 8, res: 8, upd: 8;
  ckSd:
      _sk3s::P64 = R1;
      _sk3t::I64 = I64[_sk3s::P64 + 7];
      I64[(young<ckSi> + 8)] = ckSi;
      R1 = _sk3j::P64;
      if (R1 & 7 != 0) goto ckSi; else goto ckSj;
  ckSj:
      call (I64[R1])(R1) returns to ckSi, args: 8, res: 8, upd: 8;
  ckSi:
      _sk3u::P64 = R1;
      _sk3v::F64 = F64[_sk3u::P64 + 7];
      I64[(young<ckSn> + 8)] = ckSn;
      R1 = _sk3e::P64;
      if (R1 & 7 != 0) goto ckSn; else goto ckSo;
  ckSo:
      call (I64[R1])(R1) returns to ckSn, args: 8, res: 8, upd: 8;
  ckSn:
      _sk3w::P64 = R1;
      Hp = Hp + 16;
      if (Hp > HpLim) goto cl0S; else goto cl0R;
  cl0S:
      HpAlloc = 16;
      R1 = _sk3w::P64;
      call stg_gc_unpt_r1(R1) returns to ckSn, args: 8, res: 8, upd: 8;
  cl0R:
      _sk3x::I64 = I64[_sk3w::P64 + 7];
      _cl00::I64 = %MO_S_Gt_W64(1, _sk3m::I64);
      _sk63::I64 = _cl00::I64;
      if (_sk63::I64 != 0) goto cl2h; else goto cl29;
  cl2h:
      Hp = Hp - 16;
      _sk3A::P64 = GHC.Types.[]_closure+1;
      goto ckSv;
  cl29:
      _cl05::P64 = Hp - 7;
      I64[Hp - 8] = go_sk65_info;
      I64[Hp] = _sk3m::I64;
      I64[(young<cl27> + 8)] = cl27;
      R2 = 1;
      R1 = _cl05::P64;
      call go_sk65_info(R2, R1) returns to cl27, args: 8, res: 8, upd: 8;
  cl27:
      _sk6d::P64 = R1;
      I64[(young<cl2d> + 8)] = cl2d;
      R2 = _sk6d::P64;
      call Main.initGens2_info(R2) returns to cl2d, args: 8, res: 8, upd: 8;
  cl2d:
      _sk6g::P64 = R1;
      _sk3A::P64 = _sk6g::P64;
      goto ckSv;
  ckSv:
      if (HpLim == 0) goto cl0T; else goto cl0U;
  cl0T:
      I64[(young<ckSu> + 8)] = ckSu;
      R1 = _sk3A::P64;
      call stg_gc_unpt_r1(R1) returns to ckSu, args: 8, res: 8, upd: 8;
  ckSu:
      _sk3A::P64 = R1;
      goto ckSv;
  cl0U:
      I64[(young<ckSx> + 8)] = ckSx;
      R1 = SkipList.newSL2_closure+1;
      call stg_norec_atomically#(R1) returns to ckSx, args: 8, res: 8, upd: 8;
  ckSx:
      _sk3D::P64 = R1;
      Hp = Hp + 16;
      if (Hp > HpLim) goto cl0X; else goto cl0W;
  cl0X:
      HpAlloc = 16;
      R1 = _sk3D::P64;
      call stg_gc_unpt_r1(R1) returns to ckSx, args: 8, res: 8, upd: 8;
  cl0W:
      _ckSz::P64 = Hp - 6;
      I64[Hp - 8] = a7_sk3E_info;
      P64[Hp] = _sk3D::P64;
      I64[(young<ckU1> + 8)] = ckU1;
      R4 = _sk3x::I64;
      R3 = 2;
      R2 = 0;
      call GHC.Enum.$w$cenumFromThenTo_info(R4,
                                            R3,
                                            R2) returns to ckU1, args: 8, res: 8, upd: 8;
  ckU1:
      _sk3V::P64 = R1;
      I64[(young<ckU5> + 8)] = ckU5;
      R2 = _sk3V::P64;
      R1 = _ckSz::P64;
      call a7_sk3E_info(R2, R1) returns to ckU5, args: 8, res: 8, upd: 8;
  ckU5:
      _sk3Y::P64 = R1;
      _cl1N::I64 = %MO_S_Lt_W64(0, _sk3m::I64);
      _sk5U::I64 = _cl1N::I64;
      if (_sk5U::I64 != 0) goto cl1Z; else goto cl1U;
  cl1Z:
      I64[(young<cl1Y> + 8)] = cl1Y;
      R2 = _sk3m::I64;
      call $wxs_rjVo_info(R2) returns to cl1Y, args: 8, res: 8, upd: 8;
  cl1Y:
      _sk5Z::P64 = R1;
      I64[(young<cl23> + 8)] = cl23;
      R2 = _sk5Z::P64;
      call Control.Monad.replicateM4_info(R2) returns to cl23, args: 8, res: 8, upd: 8;
  cl23:
      _sk62::P64 = R1;
      _sk41::P64 = _sk62::P64;
      goto ckUa;
  cl1U:
      I64[(young<cl1S> + 8)] = cl1S;
      R2 = GHC.Types.[]_closure+1;
      call Control.Monad.replicateM4_info(R2) returns to cl1S, args: 8, res: 8, upd: 8;
  cl1S:
      _sk5Y::P64 = R1;
      _sk41::P64 = _sk5Y::P64;
      goto ckUa;
  ckUa:
      if (HpLim == 0) goto cl10; else goto cl11;
  cl10:
      I64[(young<ckU9> + 8)] = ckU9;
      R1 = _sk41::P64;
      call stg_gc_unpt_r1(R1) returns to ckU9, args: 8, res: 8, upd: 8;
  ckU9:
      _sk41::P64 = R1;
      goto ckUa;
  cl11:
      I64[(young<ckUc> + 8)] = ckUc;
      R1 = _sk3g::P64;
      if (R1 & 7 != 0) goto ckUc; else goto ckUd;
  ckUd:
      call (I64[R1])(R1) returns to ckUc, args: 8, res: 8, upd: 8;
  ckUc:
      _sk42::P64 = R1;
      _cl2i::P64 = _sk42::P64 & 7;
      if (_cl2i::P64 != 1) goto cl1M; else goto cl19;
  cl1M:
      R1 = GHC.Tuple.()_closure+1;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
  cl19:
      I64[(young<ckY5> + 8)] = ckY5;
      R1 = _sk3h::P64;
      if (R1 & 7 != 0) goto ckY5; else goto ckY6;
  ckY6:
      call (I64[R1])(R1) returns to ckY5, args: 8, res: 8, upd: 8;
  ckY5:
      _sk52::P64 = R1;
      _cl2j::P64 = _sk52::P64 & 7;
      if (_cl2j::P64 != 1) goto cl1z; else goto cl1i;
  cl1z:
      Hp = Hp + 64;
      if (Hp > HpLim) goto cl1C; else goto cl1B;
  cl1C:
      HpAlloc = 64;
      R1 = _sk52::P64;
      call stg_gc_unpt_r1(R1) returns to ckY5, args: 8, res: 8, upd: 8;
  cl1B:
      I64[Hp - 56] = sat_sk5N_info;
      P64[Hp - 40] = _sk3A::P64;
      P64[Hp - 32] = _sk41::P64;
      F64[Hp - 24] = _sk3v::F64;
      I64[Hp - 16] = _sk3x::I64;
      _ckZm::P64 = Hp - 56;
      _cl1s::I64 = _sk3t::I64 * 1000;
      _sk5D::I64 = _cl1s::I64;
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _sk5D::I64;
      _cl1v::P64 = Hp - 7;
      I64[(young<cl1w> + 8)] = cl1w;
      R3 = _ckZm::P64;
      R2 = _cl1v::P64;
      call Throughput.throughputMain1_info(R3,
                                           R2) returns to cl1w, args: 8, res: 8, upd: 8;
  cl1w:
      _sk5Q::P64 = R1;
      I64[(young<cl1y> + 8)] = cl1y;
      R1 = _sk5Q::P64;
      if (R1 & 7 != 0) goto cl1y; else goto cl1E;
  cl1E:
      call (I64[R1])(R1) returns to cl1y, args: 8, res: 8, upd: 8;
  cl1y:
      _sk5R::P64 = R1;
      _sk5S::P64 = P64[_sk5R::P64 + 7];
      _sk5T::P64 = P64[_sk5R::P64 + 15];
      _sk46::P64 = _sk5T::P64;
      _sk45::P64 = _sk5S::P64;
      goto ckUk;
  cl1i:
      Hp = Hp + 72;
      if (Hp > HpLim) goto cl1l; else goto cl1k;
  cl1l:
      HpAlloc = 72;
      R1 = _sk52::P64;
      call stg_gc_unpt_r1(R1) returns to ckY5, args: 8, res: 8, upd: 8;
  cl1k:
      I64[Hp - 64] = sat_sk5w_info;
      P64[Hp - 48] = _sk3A::P64;
      P64[Hp - 40] = _sk3D::P64;
      P64[Hp - 32] = _sk41::P64;
      F64[Hp - 24] = _sk3v::F64;
      I64[Hp - 16] = _sk3x::I64;
      _ckYa::P64 = Hp - 64;
      _cl1a::I64 = _sk3t::I64 * 1000;
      _sk53::I64 = _cl1a::I64;
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _sk53::I64;
      _cl1d::P64 = Hp - 7;
      I64[(young<cl1e> + 8)] = cl1e;
      R3 = _ckYa::P64;
      R2 = _cl1d::P64;
      call Throughput.throughputMain1_info(R3,
                                           R2) returns to cl1e, args: 8, res: 8, upd: 8;
  cl1e:
      _sk5z::P64 = R1;
      I64[(young<cl1g> + 8)] = cl1g;
      R1 = _sk5z::P64;
      if (R1 & 7 != 0) goto cl1g; else goto cl1n;
  cl1n:
      call (I64[R1])(R1) returns to cl1g, args: 8, res: 8, upd: 8;
  cl1g:
      _sk5A::P64 = R1;
      _sk5B::P64 = P64[_sk5A::P64 + 7];
      _sk5C::P64 = P64[_sk5A::P64 + 15];
      _sk46::P64 = _sk5C::P64;
      _sk45::P64 = _sk5B::P64;
      goto ckUk;
  ckUk:
      if (HpLim == 0) goto cl13; else goto cl14;
  cl13:
      I64[(young<ckUj> + 8)] = ckUj;
      R2 = _sk46::P64;
      R1 = _sk45::P64;
      call stg_gc_pp(R2, R1) returns to ckUj, args: 8, res: 8, upd: 8;
  ckUj:
      _sk46::P64 = R2;
      _sk45::P64 = R1;
      goto ckUk;
  cl14:
      I64[(young<ckUm> + 8)] = ckUm;
      R2 = _sk41::P64;
      call a5_rjVe_info(R2) returns to ckUm, args: 8, res: 8, upd: 8;
  ckUm:
      _sk49::P64 = R1;
      Hp = Hp + 64;
      if (Hp > HpLim) goto cl17; else goto cl16;
  cl17:
      HpAlloc = 64;
      R1 = _sk49::P64;
      call stg_gc_unpt_r1(R1) returns to ckUm, args: 8, res: 8, upd: 8;
  cl16:
      I64[Hp - 56] = sat_sk51_info;
      P64[Hp - 40] = _sk33::P64;
      P64[Hp - 32] = _sk45::P64;
      P64[Hp - 24] = _sk46::P64;
      P64[Hp - 16] = _sk49::P64;
      I64[Hp - 8] = _sk3m::I64;
      I64[Hp] = _sk3x::I64;
      _ckUo::P64 = Hp - 56;
      R4 = GHC.Types.True_closure+2;
      R3 = _ckUo::P64;
      R2 = GHC.IO.Handle.FD.stdout_closure;
      call GHC.IO.Handle.Text.hPutStr2_info(R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:54.833814 UTC

{offset
  cl0B:
      if ((Sp + 8) - 96 < SpLim) goto cl0C; else goto cl0D;
  cl0D:
      if (HpLim == 0) goto cl0C; else goto cl0E;
  cl0C:
      R1 = Main.main1_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  cl0E:
      I64[Sp - 8] = ckRA;
      Sp = Sp - 8;
      call System.Environment.getProgName1_info() returns to ckRA, args: 8, res: 8, upd: 8;
  ckRA:
      _sk33::P64 = R1;
      I64[Sp - 8] = ckRC;
      P64[Sp] = _sk33::P64;
      Sp = Sp - 8;
      call System.Environment.getArgs1_info() returns to ckRC, args: 8, res: 8, upd: 8;
  ckRC:
      _sk33::P64 = P64[Sp + 8];
      _sk36::P64 = R1;
      Hp = Hp + 88;
      if (Hp > HpLim) goto cl0I; else goto cl0H;
  cl0I:
      HpAlloc = 88;
      R1 = _sk36::P64;
      call stg_gc_unpt_r1(R1) returns to ckRC, args: 8, res: 8, upd: 8;
  cl0H:
      I64[Hp - 80] = sat_sk37_info;
      P64[Hp - 64] = _sk33::P64;
      _ckRE::P64 = Hp - 80;
      I64[Hp - 56] = Options.Applicative.Types.ParserInfo_con_info;
      P64[Hp - 48] = lvl20_rjVp_closure+3;
      P64[Hp - 40] = GHC.Types.True_closure+2;
      P64[Hp - 32] = lvl22_rjVr_closure;
      P64[Hp - 24] = _ckRE::P64;
      P64[Hp - 16] = GHC.Base.Nothing_closure+1;
      P64[Hp - 8] = Options.Applicative.Builder.info1_closure;
      P64[Hp] = GHC.Types.True_closure+2;
      _ckRM::P64 = Hp - 55;
      I64[Sp] = ckRN;
      R4 = _sk36::P64;
      R3 = _ckRM::P64;
      R2 = Options.Applicative.Builder.prefs1_closure;
      call Options.Applicative.Extra.execParserPure_info(R4,
                                                         R3,
                                                         R2) returns to ckRN, args: 8, res: 8, upd: 8;
  ckRN:
      _sk33::P64 = P64[Sp + 8];
      _sk39::P64 = R1;
      I64[Sp] = ckRR;
      R2 = _sk39::P64;
      call Options.Applicative.Extra.customExecParser2_info(R2) returns to ckRR, args: 8, res: 8, upd: 8;
  ckRR:
      _sk33::P64 = P64[Sp + 8];
      _sk3c::P64 = R1;
      I64[Sp] = ckRT;
      R1 = _sk3c::P64;
      if (R1 & 7 != 0) goto ckRT; else goto ckRU;
  ckRU:
      call (I64[R1])(R1) returns to ckRT, args: 8, res: 8, upd: 8;
  ckRT:
      _sk33::P64 = P64[Sp + 8];
      _sk3d::P64 = R1;
      _sk3e::P64 = P64[_sk3d::P64 + 7];
      _sk3f::P64 = P64[_sk3d::P64 + 15];
      _sk3g::P64 = P64[_sk3d::P64 + 23];
      _sk3h::P64 = P64[_sk3d::P64 + 31];
      _sk3i::P64 = P64[_sk3d::P64 + 39];
      _sk3j::P64 = P64[_sk3d::P64 + 47];
      _sk3k::P64 = P64[_sk3d::P64 + 55];
      I64[Sp - 40] = ckRY;
      R1 = _sk3f::P64;
      P64[Sp - 32] = _sk3g::P64;
      P64[Sp - 24] = _sk3h::P64;
      P64[Sp - 16] = _sk3j::P64;
      P64[Sp - 8] = _sk3k::P64;
      P64[Sp] = _sk3e::P64;
      Sp = Sp - 40;
      if (R1 & 7 != 0) goto ckRY; else goto ckRZ;
  ckRZ:
      call (I64[R1])(R1) returns to ckRY, args: 8, res: 8, upd: 8;
  ckRY:
      _sk33::P64 = P64[Sp + 48];
      _sk3e::P64 = P64[Sp + 40];
      _sk3g::P64 = P64[Sp + 8];
      _sk3h::P64 = P64[Sp + 16];
      _sk3j::P64 = P64[Sp + 24];
      _sk3k::P64 = P64[Sp + 32];
      _sk3l::P64 = R1;
      _sk3m::I64 = I64[_sk3l::P64 + 7];
      _ckS3::I64 = _sk3m::I64;
      _sk3o::I64 = _ckS3::I64;
      _ckS6::I64 = %MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_sk3o::I64));
      _sk3p::I64 = _ckS6::I64;
      _ckS9::I64 = setNumCapabilities;
      _ckSa::I64 = _sk3p::I64;
      I64[Sp - 8] = ckSb;
      I64[Sp] = _sk3m::I64;
      Sp = Sp - 8;
      _ul2n::P64 = CurrentTSO;
      I64[I64[_ul2n::P64 + 24] + 16] = Sp;
      _ul2o::I64 = CurrentNursery;
      P64[_ul2o::I64 + 8] = Hp + 8;
      I64[_ul2n::P64 + 112] = I64[_ul2n::P64 + 112] - %MO_UU_Conv_W64_W64((Hp + 8) - I64[_ul2o::I64]);
      (_ul2k::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
      call "ccall" arg hints:  []  result hints:  [] (_ckS9::I64)(_ckSa::I64);
      (_ul2l::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_ul2k::I64);
      BaseReg = _ul2l::I64;
      _ul2n::P64 = CurrentTSO;
      _ul2m::P64 = I64[_ul2n::P64 + 24];
      Sp = I64[_ul2m::P64 + 16];
      SpLim = _ul2m::P64 + 192;
      HpAlloc = 0;
      _ul2o::I64 = CurrentNursery;
      _ul2p::I64 = I64[_ul2o::I64 + 8];
      Hp = _ul2p::I64 - 8;
      _ul2q::I64 = I64[_ul2o::I64];
      HpLim = _ul2q::I64 + (%MO_SS_Conv_W32_W64(I32[_ul2o::I64 + 48]) * 4096 - 1);
      I64[_ul2n::P64 + 112] = I64[_ul2n::P64 + 112] + %MO_UU_Conv_W64_W64(_ul2p::I64 - _ul2q::I64);
      call (I64[Sp])() returns to ckSb, args: 8, res: 8, upd: 8;
  ckSb:
      _sk33::P64 = P64[Sp + 56];
      _sk3e::P64 = P64[Sp + 48];
      _sk3g::P64 = P64[Sp + 16];
      _sk3h::P64 = P64[Sp + 24];
      _sk3j::P64 = P64[Sp + 32];
      _sk3k::P64 = P64[Sp + 40];
      _sk3m::I64 = I64[Sp + 8];
      I64[Sp] = ckSd;
      R1 = _sk3k::P64;
      if (R1 & 7 != 0) goto ckSd; else goto ckSe;
  ckSe:
      call (I64[R1])(R1) returns to ckSd, args: 8, res: 8, upd: 8;
  ckSd:
      _sk33::P64 = P64[Sp + 56];
      _sk3e::P64 = P64[Sp + 48];
      _sk3g::P64 = P64[Sp + 16];
      _sk3h::P64 = P64[Sp + 24];
      _sk3j::P64 = P64[Sp + 32];
      _sk3m::I64 = I64[Sp + 8];
      _sk3s::P64 = R1;
      _sk3t::I64 = I64[_sk3s::P64 + 7];
      I64[Sp] = ckSi;
      R1 = _sk3j::P64;
      I64[Sp + 40] = _sk3t::I64;
      if (R1 & 7 != 0) goto ckSi; else goto ckSj;
  ckSj:
      call (I64[R1])(R1) returns to ckSi, args: 8, res: 8, upd: 8;
  ckSi:
      _sk33::P64 = P64[Sp + 56];
      _sk3e::P64 = P64[Sp + 48];
      _sk3g::P64 = P64[Sp + 16];
      _sk3h::P64 = P64[Sp + 24];
      _sk3m::I64 = I64[Sp + 8];
      _sk3t::I64 = I64[Sp + 40];
      _sk3u::P64 = R1;
      _sk3v::F64 = F64[_sk3u::P64 + 7];
      I64[Sp] = ckSn;
      R1 = _sk3e::P64;
      F64[Sp + 48] = _sk3v::F64;
      if (R1 & 7 != 0) goto ckSn; else goto ckSo;
  ckSo:
      call (I64[R1])(R1) returns to ckSn, args: 8, res: 8, upd: 8;
  ckSn:
      _sk33::P64 = P64[Sp + 56];
      _sk3g::P64 = P64[Sp + 16];
      _sk3h::P64 = P64[Sp + 24];
      _sk3m::I64 = I64[Sp + 8];
      _sk3t::I64 = I64[Sp + 40];
      _sk3v::F64 = F64[Sp + 48];
      _sk3w::P64 = R1;
      Hp = Hp + 16;
      if (Hp > HpLim) goto cl0S; else goto cl0R;
  cl0S:
      HpAlloc = 16;
      R1 = _sk3w::P64;
      call stg_gc_unpt_r1(R1) returns to ckSn, args: 8, res: 8, upd: 8;
  cl0R:
      _sk3x::I64 = I64[_sk3w::P64 + 7];
      _cl00::I64 = %MO_S_Gt_W64(1, _sk3m::I64);
      _sk63::I64 = _cl00::I64;
      if (_sk63::I64 != 0) goto cl2h; else goto cl29;
  cl2h:
      Hp = Hp - 16;
      _sk3A::P64 = GHC.Types.[]_closure+1;
      goto ckSv;
  cl29:
      _cl05::P64 = Hp - 7;
      I64[Hp - 8] = go_sk65_info;
      I64[Hp] = _sk3m::I64;
      I64[Sp] = cl27;
      R2 = 1;
      R1 = _cl05::P64;
      I64[Sp + 32] = _sk3x::I64;
      call go_sk65_info(R2, R1) returns to cl27, args: 8, res: 8, upd: 8;
  cl27:
      _sk33::P64 = P64[Sp + 56];
      _sk3g::P64 = P64[Sp + 16];
      _sk3h::P64 = P64[Sp + 24];
      _sk3m::I64 = I64[Sp + 8];
      _sk3t::I64 = I64[Sp + 40];
      _sk3v::F64 = F64[Sp + 48];
      _sk3x::I64 = I64[Sp + 32];
      _sk6d::P64 = R1;
      I64[Sp] = cl2d;
      R2 = _sk6d::P64;
      call Main.initGens2_info(R2) returns to cl2d, args: 8, res: 8, upd: 8;
  cl2d:
      _sk33::P64 = P64[Sp + 56];
      _sk3g::P64 = P64[Sp + 16];
      _sk3h::P64 = P64[Sp + 24];
      _sk3m::I64 = I64[Sp + 8];
      _sk3t::I64 = I64[Sp + 40];
      _sk3v::F64 = F64[Sp + 48];
      _sk3x::I64 = I64[Sp + 32];
      _sk6g::P64 = R1;
      _sk3A::P64 = _sk6g::P64;
      goto ckSv;
  ckSv:
      if (HpLim == 0) goto cl0T; else goto cl0U;
  cl0T:
      I64[Sp] = ckSu;
      R1 = _sk3A::P64;
      I64[Sp + 32] = _sk3x::I64;
      call stg_gc_unpt_r1(R1) returns to ckSu, args: 8, res: 8, upd: 8;
  ckSu:
      _sk33::P64 = P64[Sp + 56];
      _sk3g::P64 = P64[Sp + 16];
      _sk3h::P64 = P64[Sp + 24];
      _sk3m::I64 = I64[Sp + 8];
      _sk3t::I64 = I64[Sp + 40];
      _sk3v::F64 = F64[Sp + 48];
      _sk3x::I64 = I64[Sp + 32];
      _sk3A::P64 = R1;
      goto ckSv;
  cl0U:
      I64[Sp - 8] = ckSx;
      R1 = SkipList.newSL2_closure+1;
      P64[Sp] = _sk3A::P64;
      I64[Sp + 32] = _sk3x::I64;
      Sp = Sp - 8;
      call stg_norec_atomically#(R1) returns to ckSx, args: 8, res: 8, upd: 8;
  ckSx:
      _sk33::P64 = P64[Sp + 64];
      _sk3g::P64 = P64[Sp + 24];
      _sk3h::P64 = P64[Sp + 32];
      _sk3m::I64 = I64[Sp + 16];
      _sk3t::I64 = I64[Sp + 48];
      _sk3v::F64 = F64[Sp + 56];
      _sk3x::I64 = I64[Sp + 40];
      _sk3A::P64 = P64[Sp + 8];
      _sk3D::P64 = R1;
      Hp = Hp + 16;
      if (Hp > HpLim) goto cl0X; else goto cl0W;
  cl0X:
      HpAlloc = 16;
      R1 = _sk3D::P64;
      call stg_gc_unpt_r1(R1) returns to ckSx, args: 8, res: 8, upd: 8;
  cl0W:
      _ckSz::P64 = Hp - 6;
      I64[Hp - 8] = a7_sk3E_info;
      P64[Hp] = _sk3D::P64;
      I64[Sp - 16] = ckU1;
      R4 = _sk3x::I64;
      R3 = 2;
      R2 = 0;
      P64[Sp - 8] = _sk3D::P64;
      P64[Sp] = _ckSz::P64;
      Sp = Sp - 16;
      call GHC.Enum.$w$cenumFromThenTo_info(R4,
                                            R3,
                                            R2) returns to ckU1, args: 8, res: 8, upd: 8;
  ckU1:
      _ckSz::P64 = P64[Sp + 16];
      _sk33::P64 = P64[Sp + 80];
      _sk3g::P64 = P64[Sp + 40];
      _sk3h::P64 = P64[Sp + 48];
      _sk3m::I64 = I64[Sp + 32];
      _sk3t::I64 = I64[Sp + 64];
      _sk3v::F64 = F64[Sp + 72];
      _sk3x::I64 = I64[Sp + 56];
      _sk3A::P64 = P64[Sp + 24];
      _sk3D::P64 = P64[Sp + 8];
      _sk3V::P64 = R1;
      I64[Sp] = ckU5;
      R2 = _sk3V::P64;
      R1 = _ckSz::P64;
      call a7_sk3E_info(R2, R1) returns to ckU5, args: 8, res: 8, upd: 8;
  ckU5:
      _sk33::P64 = P64[Sp + 80];
      _sk3g::P64 = P64[Sp + 40];
      _sk3h::P64 = P64[Sp + 48];
      _sk3m::I64 = I64[Sp + 32];
      _sk3t::I64 = I64[Sp + 64];
      _sk3v::F64 = F64[Sp + 72];
      _sk3x::I64 = I64[Sp + 56];
      _sk3A::P64 = P64[Sp + 24];
      _sk3D::P64 = P64[Sp + 8];
      _sk3Y::P64 = R1;
      _cl1N::I64 = %MO_S_Lt_W64(0, _sk3m::I64);
      _sk5U::I64 = _cl1N::I64;
      if (_sk5U::I64 != 0) goto cl1Z; else goto cl1U;
  cl1Z:
      I64[Sp] = cl1Y;
      R2 = _sk3m::I64;
      call $wxs_rjVo_info(R2) returns to cl1Y, args: 8, res: 8, upd: 8;
  cl1Y:
      _sk33::P64 = P64[Sp + 80];
      _sk3g::P64 = P64[Sp + 40];
      _sk3h::P64 = P64[Sp + 48];
      _sk3m::I64 = I64[Sp + 32];
      _sk3t::I64 = I64[Sp + 64];
      _sk3v::F64 = F64[Sp + 72];
      _sk3x::I64 = I64[Sp + 56];
      _sk3A::P64 = P64[Sp + 24];
      _sk3D::P64 = P64[Sp + 8];
      _sk5Z::P64 = R1;
      I64[Sp] = cl23;
      R2 = _sk5Z::P64;
      call Control.Monad.replicateM4_info(R2) returns to cl23, args: 8, res: 8, upd: 8;
  cl23:
      _sk33::P64 = P64[Sp + 80];
      _sk3g::P64 = P64[Sp + 40];
      _sk3h::P64 = P64[Sp + 48];
      _sk3m::I64 = I64[Sp + 32];
      _sk3t::I64 = I64[Sp + 64];
      _sk3v::F64 = F64[Sp + 72];
      _sk3x::I64 = I64[Sp + 56];
      _sk3A::P64 = P64[Sp + 24];
      _sk3D::P64 = P64[Sp + 8];
      _sk62::P64 = R1;
      _sk41::P64 = _sk62::P64;
      goto ckUa;
  cl1U:
      I64[Sp] = cl1S;
      R2 = GHC.Types.[]_closure+1;
      call Control.Monad.replicateM4_info(R2) returns to cl1S, args: 8, res: 8, upd: 8;
  cl1S:
      _sk33::P64 = P64[Sp + 80];
      _sk3g::P64 = P64[Sp + 40];
      _sk3h::P64 = P64[Sp + 48];
      _sk3m::I64 = I64[Sp + 32];
      _sk3t::I64 = I64[Sp + 64];
      _sk3v::F64 = F64[Sp + 72];
      _sk3x::I64 = I64[Sp + 56];
      _sk3A::P64 = P64[Sp + 24];
      _sk3D::P64 = P64[Sp + 8];
      _sk5Y::P64 = R1;
      _sk41::P64 = _sk5Y::P64;
      goto ckUa;
  ckUa:
      if (HpLim == 0) goto cl10; else goto cl11;
  cl10:
      I64[Sp] = ckU9;
      R1 = _sk41::P64;
      call stg_gc_unpt_r1(R1) returns to ckU9, args: 8, res: 8, upd: 8;
  ckU9:
      _sk33::P64 = P64[Sp + 80];
      _sk3g::P64 = P64[Sp + 40];
      _sk3h::P64 = P64[Sp + 48];
      _sk3m::I64 = I64[Sp + 32];
      _sk3t::I64 = I64[Sp + 64];
      _sk3v::F64 = F64[Sp + 72];
      _sk3x::I64 = I64[Sp + 56];
      _sk3A::P64 = P64[Sp + 24];
      _sk3D::P64 = P64[Sp + 8];
      _sk41::P64 = R1;
      goto ckUa;
  cl11:
      I64[Sp] = ckUc;
      R1 = _sk3g::P64;
      P64[Sp + 40] = _sk41::P64;
      if (R1 & 7 != 0) goto ckUc; else goto ckUd;
  ckUd:
      call (I64[R1])(R1) returns to ckUc, args: 8, res: 8, upd: 8;
  ckUc:
      _sk33::P64 = P64[Sp + 80];
      _sk3h::P64 = P64[Sp + 48];
      _sk3m::I64 = I64[Sp + 32];
      _sk3t::I64 = I64[Sp + 64];
      _sk3v::F64 = F64[Sp + 72];
      _sk3x::I64 = I64[Sp + 56];
      _sk3A::P64 = P64[Sp + 24];
      _sk3D::P64 = P64[Sp + 8];
      _sk41::P64 = P64[Sp + 40];
      _sk42::P64 = R1;
      _cl2i::P64 = _sk42::P64 & 7;
      if (_cl2i::P64 != 1) goto cl1M; else goto cl19;
  cl1M:
      R1 = GHC.Tuple.()_closure+1;
      Sp = Sp + 88;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
  cl19:
      I64[Sp] = ckY5;
      R1 = _sk3h::P64;
      if (R1 & 7 != 0) goto ckY5; else goto ckY6;
  ckY6:
      call (I64[R1])(R1) returns to ckY5, args: 8, res: 8, upd: 8;
  ckY5:
      _sk33::P64 = P64[Sp + 80];
      _sk3m::I64 = I64[Sp + 32];
      _sk3t::I64 = I64[Sp + 64];
      _sk3v::F64 = F64[Sp + 72];
      _sk3x::I64 = I64[Sp + 56];
      _sk3A::P64 = P64[Sp + 24];
      _sk3D::P64 = P64[Sp + 8];
      _sk41::P64 = P64[Sp + 40];
      _sk52::P64 = R1;
      _cl2j::P64 = _sk52::P64 & 7;
      if (_cl2j::P64 != 1) goto cl1z; else goto cl1i;
  cl1z:
      Hp = Hp + 64;
      if (Hp > HpLim) goto cl1C; else goto cl1B;
  cl1C:
      HpAlloc = 64;
      R1 = _sk52::P64;
      call stg_gc_unpt_r1(R1) returns to ckY5, args: 8, res: 8, upd: 8;
  cl1B:
      I64[Hp - 56] = sat_sk5N_info;
      P64[Hp - 40] = _sk3A::P64;
      P64[Hp - 32] = _sk41::P64;
      F64[Hp - 24] = _sk3v::F64;
      I64[Hp - 16] = _sk3x::I64;
      _ckZm::P64 = Hp - 56;
      _cl1s::I64 = _sk3t::I64 * 1000;
      _sk5D::I64 = _cl1s::I64;
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _sk5D::I64;
      _cl1v::P64 = Hp - 7;
      I64[Sp + 24] = cl1w;
      R3 = _ckZm::P64;
      R2 = _cl1v::P64;
      Sp = Sp + 24;
      call Throughput.throughputMain1_info(R3,
                                           R2) returns to cl1w, args: 8, res: 8, upd: 8;
  cl1w:
      _sk33::P64 = P64[Sp + 56];
      _sk3m::I64 = I64[Sp + 8];
      _sk3x::I64 = I64[Sp + 32];
      _sk41::P64 = P64[Sp + 16];
      _sk5Q::P64 = R1;
      I64[Sp] = cl1y;
      R1 = _sk5Q::P64;
      if (R1 & 7 != 0) goto cl1y; else goto cl1E;
  cl1E:
      call (I64[R1])(R1) returns to cl1y, args: 8, res: 8, upd: 8;
  cl1y:
      _sk33::P64 = P64[Sp + 56];
      _sk3m::I64 = I64[Sp + 8];
      _sk3x::I64 = I64[Sp + 32];
      _sk41::P64 = P64[Sp + 16];
      _sk5R::P64 = R1;
      _sk5S::P64 = P64[_sk5R::P64 + 7];
      _sk5T::P64 = P64[_sk5R::P64 + 15];
      _sk46::P64 = _sk5T::P64;
      _sk45::P64 = _sk5S::P64;
      goto ckUk;
  cl1i:
      Hp = Hp + 72;
      if (Hp > HpLim) goto cl1l; else goto cl1k;
  cl1l:
      HpAlloc = 72;
      R1 = _sk52::P64;
      call stg_gc_unpt_r1(R1) returns to ckY5, args: 8, res: 8, upd: 8;
  cl1k:
      I64[Hp - 64] = sat_sk5w_info;
      P64[Hp - 48] = _sk3A::P64;
      P64[Hp - 40] = _sk3D::P64;
      P64[Hp - 32] = _sk41::P64;
      F64[Hp - 24] = _sk3v::F64;
      I64[Hp - 16] = _sk3x::I64;
      _ckYa::P64 = Hp - 64;
      _cl1a::I64 = _sk3t::I64 * 1000;
      _sk53::I64 = _cl1a::I64;
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _sk53::I64;
      _cl1d::P64 = Hp - 7;
      I64[Sp + 24] = cl1e;
      R3 = _ckYa::P64;
      R2 = _cl1d::P64;
      Sp = Sp + 24;
      call Throughput.throughputMain1_info(R3,
                                           R2) returns to cl1e, args: 8, res: 8, upd: 8;
  cl1e:
      _sk33::P64 = P64[Sp + 56];
      _sk3m::I64 = I64[Sp + 8];
      _sk3x::I64 = I64[Sp + 32];
      _sk41::P64 = P64[Sp + 16];
      _sk5z::P64 = R1;
      I64[Sp] = cl1g;
      R1 = _sk5z::P64;
      if (R1 & 7 != 0) goto cl1g; else goto cl1n;
  cl1n:
      call (I64[R1])(R1) returns to cl1g, args: 8, res: 8, upd: 8;
  cl1g:
      _sk33::P64 = P64[Sp + 56];
      _sk3m::I64 = I64[Sp + 8];
      _sk3x::I64 = I64[Sp + 32];
      _sk41::P64 = P64[Sp + 16];
      _sk5A::P64 = R1;
      _sk5B::P64 = P64[_sk5A::P64 + 7];
      _sk5C::P64 = P64[_sk5A::P64 + 15];
      _sk46::P64 = _sk5C::P64;
      _sk45::P64 = _sk5B::P64;
      goto ckUk;
  ckUk:
      if (HpLim == 0) goto cl13; else goto cl14;
  cl13:
      I64[Sp] = ckUj;
      R2 = _sk46::P64;
      R1 = _sk45::P64;
      call stg_gc_pp(R2, R1) returns to ckUj, args: 8, res: 8, upd: 8;
  ckUj:
      _sk33::P64 = P64[Sp + 56];
      _sk3m::I64 = I64[Sp + 8];
      _sk3x::I64 = I64[Sp + 32];
      _sk41::P64 = P64[Sp + 16];
      _sk46::P64 = R2;
      _sk45::P64 = R1;
      goto ckUk;
  cl14:
      I64[Sp] = ckUm;
      R2 = _sk41::P64;
      P64[Sp + 40] = _sk46::P64;
      P64[Sp + 48] = _sk45::P64;
      call a5_rjVe_info(R2) returns to ckUm, args: 8, res: 8, upd: 8;
  ckUm:
      _sk33::P64 = P64[Sp + 56];
      _sk3m::I64 = I64[Sp + 8];
      _sk3x::I64 = I64[Sp + 32];
      _sk45::P64 = P64[Sp + 48];
      _sk46::P64 = P64[Sp + 40];
      _sk49::P64 = R1;
      Hp = Hp + 64;
      if (Hp > HpLim) goto cl17; else goto cl16;
  cl17:
      HpAlloc = 64;
      R1 = _sk49::P64;
      call stg_gc_unpt_r1(R1) returns to ckUm, args: 8, res: 8, upd: 8;
  cl16:
      I64[Hp - 56] = sat_sk51_info;
      P64[Hp - 40] = _sk33::P64;
      P64[Hp - 32] = _sk45::P64;
      P64[Hp - 24] = _sk46::P64;
      P64[Hp - 16] = _sk49::P64;
      I64[Hp - 8] = _sk3m::I64;
      I64[Hp] = _sk3x::I64;
      _ckUo::P64 = Hp - 56;
      R4 = GHC.Types.True_closure+2;
      R3 = _ckUo::P64;
      R2 = GHC.IO.Handle.FD.stdout_closure;
      Sp = Sp + 64;
      call GHC.IO.Handle.Text.hPutStr2_info(R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:54.860575 UTC

{offset
  cl0B:
      if ((Sp + -88) < SpLim) goto cl0C; else goto cl0D;
  cl0D:
      if (HpLim == 0) goto cl0C; else goto cl0E;
  cl0C:
      R1 = Main.main1_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  cl0E:
      I64[Sp - 8] = ckRA;
      Sp = Sp - 8;
      call System.Environment.getProgName1_info() returns to ckRA, args: 8, res: 8, upd: 8;
  ckRA:
      I64[Sp - 8] = ckRC;
      P64[Sp] = R1;
      Sp = Sp - 8;
      call System.Environment.getArgs1_info() returns to ckRC, args: 8, res: 8, upd: 8;
  ckRC:
      Hp = Hp + 88;
      if (Hp > HpLim) goto cl0I; else goto cl0H;
  cl0I:
      HpAlloc = 88;
      R1 = R1;
      call stg_gc_unpt_r1(R1) returns to ckRC, args: 8, res: 8, upd: 8;
  cl0H:
      I64[Hp - 80] = sat_sk37_info;
      P64[Hp - 64] = P64[Sp + 8];
      I64[Hp - 56] = Options.Applicative.Types.ParserInfo_con_info;
      P64[Hp - 48] = lvl20_rjVp_closure+3;
      P64[Hp - 40] = GHC.Types.True_closure+2;
      P64[Hp - 32] = lvl22_rjVr_closure;
      P64[Hp - 24] = Hp - 80;
      P64[Hp - 16] = GHC.Base.Nothing_closure+1;
      P64[Hp - 8] = Options.Applicative.Builder.info1_closure;
      P64[Hp] = GHC.Types.True_closure+2;
      I64[Sp] = ckRN;
      R4 = R1;
      R3 = Hp - 55;
      R2 = Options.Applicative.Builder.prefs1_closure;
      call Options.Applicative.Extra.execParserPure_info(R4,
                                                         R3,
                                                         R2) returns to ckRN, args: 8, res: 8, upd: 8;
  ckRN:
      I64[Sp] = ckRR;
      R2 = R1;
      call Options.Applicative.Extra.customExecParser2_info(R2) returns to ckRR, args: 8, res: 8, upd: 8;
  ckRR:
      I64[Sp] = ckRT;
      R1 = R1;
      if (R1 & 7 != 0) goto ckRT; else goto ckRU;
  ckRU:
      call (I64[R1])(R1) returns to ckRT, args: 8, res: 8, upd: 8;
  ckRT:
      I64[Sp - 40] = ckRY;
      _sk3e::P64 = P64[R1 + 7];
      _sk3g::P64 = P64[R1 + 23];
      _sk3h::P64 = P64[R1 + 31];
      _sk3j::P64 = P64[R1 + 47];
      _sk3k::P64 = P64[R1 + 55];
      R1 = P64[R1 + 15];
      P64[Sp - 32] = _sk3g::P64;
      P64[Sp - 24] = _sk3h::P64;
      P64[Sp - 16] = _sk3j::P64;
      P64[Sp - 8] = _sk3k::P64;
      P64[Sp] = _sk3e::P64;
      Sp = Sp - 40;
      if (R1 & 7 != 0) goto ckRY; else goto ckRZ;
  ckRZ:
      call (I64[R1])(R1) returns to ckRY, args: 8, res: 8, upd: 8;
  ckRY:
      I64[Sp - 8] = ckSb;
      _sk3m::I64 = I64[R1 + 7];
      I64[Sp] = _sk3m::I64;
      Sp = Sp - 8;
      _ul2n::P64 = CurrentTSO;
      I64[I64[_ul2n::P64 + 24] + 16] = Sp;
      _ul2o::I64 = CurrentNursery;
      P64[_ul2o::I64 + 8] = Hp + 8;
      I64[_ul2n::P64 + 112] = I64[_ul2n::P64 + 112] - ((Hp + 8) - I64[_ul2o::I64]);
      (_ul2k::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
      call "ccall" arg hints:  []  result hints:  [] setNumCapabilities(%MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_sk3m::I64)));
      (_ul2l::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_ul2k::I64);
      BaseReg = _ul2l::I64;
      _ul2n::P64 = CurrentTSO;
      _ul2m::P64 = I64[_ul2n::P64 + 24];
      Sp = I64[_ul2m::P64 + 16];
      SpLim = _ul2m::P64 + 192;
      HpAlloc = 0;
      _ul2o::I64 = CurrentNursery;
      _ul2p::I64 = I64[_ul2o::I64 + 8];
      Hp = _ul2p::I64 - 8;
      _ul2q::I64 = I64[_ul2o::I64];
      HpLim = _ul2q::I64 + ((%MO_SS_Conv_W32_W64(I32[_ul2o::I64 + 48]) << 12) - 1);
      I64[_ul2n::P64 + 112] = I64[_ul2n::P64 + 112] + (_ul2p::I64 - _ul2q::I64);
      call (I64[Sp])() returns to ckSb, args: 8, res: 8, upd: 8;
  ckSb:
      I64[Sp] = ckSd;
      R1 = P64[Sp + 40];
      if (R1 & 7 != 0) goto ckSd; else goto ckSe;
  ckSe:
      call (I64[R1])(R1) returns to ckSd, args: 8, res: 8, upd: 8;
  ckSd:
      I64[Sp] = ckSi;
      _sk3t::I64 = I64[R1 + 7];
      R1 = P64[Sp + 32];
      I64[Sp + 40] = _sk3t::I64;
      if (R1 & 7 != 0) goto ckSi; else goto ckSj;
  ckSj:
      call (I64[R1])(R1) returns to ckSi, args: 8, res: 8, upd: 8;
  ckSi:
      I64[Sp] = ckSn;
      _sk3v::F64 = F64[R1 + 7];
      R1 = P64[Sp + 48];
      F64[Sp + 48] = _sk3v::F64;
      if (R1 & 7 != 0) goto ckSn; else goto ckSo;
  ckSo:
      call (I64[R1])(R1) returns to ckSn, args: 8, res: 8, upd: 8;
  ckSn:
      Hp = Hp + 16;
      if (Hp > HpLim) goto cl0S; else goto cl0R;
  cl0S:
      HpAlloc = 16;
      R1 = R1;
      call stg_gc_unpt_r1(R1) returns to ckSn, args: 8, res: 8, upd: 8;
  cl0R:
      _sk3m::I64 = I64[Sp + 8];
      _sk3x::I64 = I64[R1 + 7];
      if (%MO_S_Gt_W64(1, _sk3m::I64)) goto cl2h; else goto cl29;
  cl2h:
      Hp = Hp - 16;
      _sk3A::P64 = GHC.Types.[]_closure+1;
      goto ckSv;
  cl29:
      I64[Hp - 8] = go_sk65_info;
      I64[Hp] = _sk3m::I64;
      I64[Sp] = cl27;
      R2 = 1;
      R1 = Hp - 7;
      I64[Sp + 32] = _sk3x::I64;
      call go_sk65_info(R2, R1) returns to cl27, args: 8, res: 8, upd: 8;
  cl27:
      I64[Sp] = cl2d;
      R2 = R1;
      call Main.initGens2_info(R2) returns to cl2d, args: 8, res: 8, upd: 8;
  cl2d:
      _sk3x::I64 = I64[Sp + 32];
      _sk3A::P64 = R1;
      goto ckSv;
  ckSv:
      if (HpLim == 0) goto cl0T; else goto cl0U;
  cl0T:
      I64[Sp] = ckSu;
      R1 = _sk3A::P64;
      I64[Sp + 32] = _sk3x::I64;
      call stg_gc_unpt_r1(R1) returns to ckSu, args: 8, res: 8, upd: 8;
  ckSu:
      _sk3x::I64 = I64[Sp + 32];
      _sk3A::P64 = R1;
      goto ckSv;
  cl0U:
      I64[Sp - 8] = ckSx;
      R1 = SkipList.newSL2_closure+1;
      P64[Sp] = _sk3A::P64;
      I64[Sp + 32] = _sk3x::I64;
      Sp = Sp - 8;
      call stg_norec_atomically#(R1) returns to ckSx, args: 8, res: 8, upd: 8;
  ckSx:
      Hp = Hp + 16;
      if (Hp > HpLim) goto cl0X; else goto cl0W;
  cl0X:
      HpAlloc = 16;
      R1 = R1;
      call stg_gc_unpt_r1(R1) returns to ckSx, args: 8, res: 8, upd: 8;
  cl0W:
      I64[Hp - 8] = a7_sk3E_info;
      P64[Hp] = R1;
      I64[Sp - 16] = ckU1;
      R4 = I64[Sp + 40];
      R3 = 2;
      R2 = 0;
      P64[Sp - 8] = R1;
      P64[Sp] = Hp - 6;
      Sp = Sp - 16;
      call GHC.Enum.$w$cenumFromThenTo_info(R4,
                                            R3,
                                            R2) returns to ckU1, args: 8, res: 8, upd: 8;
  ckU1:
      I64[Sp] = ckU5;
      R2 = R1;
      R1 = P64[Sp + 16];
      call a7_sk3E_info(R2, R1) returns to ckU5, args: 8, res: 8, upd: 8;
  ckU5:
      _sk3m::I64 = I64[Sp + 32];
      if (%MO_S_Lt_W64(0, _sk3m::I64)) goto cl1Z; else goto cl1U;
  cl1Z:
      I64[Sp] = cl1Y;
      R2 = _sk3m::I64;
      call $wxs_rjVo_info(R2) returns to cl1Y, args: 8, res: 8, upd: 8;
  cl1Y:
      I64[Sp] = cl23;
      R2 = R1;
      call Control.Monad.replicateM4_info(R2) returns to cl23, args: 8, res: 8, upd: 8;
  cl23:
      _sk3g::P64 = P64[Sp + 40];
      _sk41::P64 = R1;
      goto ckUa;
  cl1U:
      I64[Sp] = cl1S;
      R2 = GHC.Types.[]_closure+1;
      call Control.Monad.replicateM4_info(R2) returns to cl1S, args: 8, res: 8, upd: 8;
  cl1S:
      _sk3g::P64 = P64[Sp + 40];
      _sk41::P64 = R1;
      goto ckUa;
  ckUa:
      if (HpLim == 0) goto cl10; else goto cl11;
  cl10:
      I64[Sp] = ckU9;
      R1 = _sk41::P64;
      call stg_gc_unpt_r1(R1) returns to ckU9, args: 8, res: 8, upd: 8;
  ckU9:
      _sk3g::P64 = P64[Sp + 40];
      _sk41::P64 = R1;
      goto ckUa;
  cl11:
      I64[Sp] = ckUc;
      R1 = _sk3g::P64;
      P64[Sp + 40] = _sk41::P64;
      if (R1 & 7 != 0) goto ckUc; else goto ckUd;
  ckUd:
      call (I64[R1])(R1) returns to ckUc, args: 8, res: 8, upd: 8;
  ckUc:
      if (R1 & 7 != 1) goto cl1M; else goto cl19;
  cl1M:
      R1 = GHC.Tuple.()_closure+1;
      Sp = Sp + 88;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
  cl19:
      I64[Sp] = ckY5;
      R1 = P64[Sp + 48];
      if (R1 & 7 != 0) goto ckY5; else goto ckY6;
  ckY6:
      call (I64[R1])(R1) returns to ckY5, args: 8, res: 8, upd: 8;
  ckY5:
      _sk3t::I64 = I64[Sp + 64];
      _sk3v::F64 = F64[Sp + 72];
      _sk3x::I64 = I64[Sp + 56];
      _sk3A::P64 = P64[Sp + 24];
      _sk41::P64 = P64[Sp + 40];
      if (R1 & 7 != 1) goto cl1z; else goto cl1i;
  cl1z:
      Hp = Hp + 64;
      if (Hp > HpLim) goto cl1C; else goto cl1B;
  cl1C:
      HpAlloc = 64;
      R1 = R1;
      call stg_gc_unpt_r1(R1) returns to ckY5, args: 8, res: 8, upd: 8;
  cl1B:
      I64[Hp - 56] = sat_sk5N_info;
      P64[Hp - 40] = _sk3A::P64;
      P64[Hp - 32] = _sk41::P64;
      F64[Hp - 24] = _sk3v::F64;
      I64[Hp - 16] = _sk3x::I64;
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _sk3t::I64 * 1000;
      I64[Sp + 24] = cl1w;
      R3 = Hp - 56;
      R2 = Hp - 7;
      Sp = Sp + 24;
      call Throughput.throughputMain1_info(R3,
                                           R2) returns to cl1w, args: 8, res: 8, upd: 8;
  cl1w:
      I64[Sp] = cl1y;
      R1 = R1;
      if (R1 & 7 != 0) goto cl1y; else goto cl1E;
  cl1E:
      call (I64[R1])(R1) returns to cl1y, args: 8, res: 8, upd: 8;
  cl1y:
      _sk41::P64 = P64[Sp + 16];
      _sk46::P64 = P64[R1 + 15];
      _sk45::P64 = P64[R1 + 7];
      goto ckUk;
  cl1i:
      Hp = Hp + 72;
      if (Hp > HpLim) goto cl1l; else goto cl1k;
  cl1l:
      HpAlloc = 72;
      R1 = R1;
      call stg_gc_unpt_r1(R1) returns to ckY5, args: 8, res: 8, upd: 8;
  cl1k:
      I64[Hp - 64] = sat_sk5w_info;
      P64[Hp - 48] = _sk3A::P64;
      P64[Hp - 40] = P64[Sp + 8];
      P64[Hp - 32] = _sk41::P64;
      F64[Hp - 24] = _sk3v::F64;
      I64[Hp - 16] = _sk3x::I64;
      I64[Hp - 8] = GHC.Types.I#_con_info;
      I64[Hp] = _sk3t::I64 * 1000;
      I64[Sp + 24] = cl1e;
      R3 = Hp - 64;
      R2 = Hp - 7;
      Sp = Sp + 24;
      call Throughput.throughputMain1_info(R3,
                                           R2) returns to cl1e, args: 8, res: 8, upd: 8;
  cl1e:
      I64[Sp] = cl1g;
      R1 = R1;
      if (R1 & 7 != 0) goto cl1g; else goto cl1n;
  cl1n:
      call (I64[R1])(R1) returns to cl1g, args: 8, res: 8, upd: 8;
  cl1g:
      _sk41::P64 = P64[Sp + 16];
      _sk46::P64 = P64[R1 + 15];
      _sk45::P64 = P64[R1 + 7];
      goto ckUk;
  ckUk:
      if (HpLim == 0) goto cl13; else goto cl14;
  cl13:
      I64[Sp] = ckUj;
      R2 = _sk46::P64;
      R1 = _sk45::P64;
      call stg_gc_pp(R2, R1) returns to ckUj, args: 8, res: 8, upd: 8;
  ckUj:
      _sk41::P64 = P64[Sp + 16];
      _sk46::P64 = R2;
      _sk45::P64 = R1;
      goto ckUk;
  cl14:
      I64[Sp] = ckUm;
      R2 = _sk41::P64;
      P64[Sp + 40] = _sk46::P64;
      P64[Sp + 48] = _sk45::P64;
      call a5_rjVe_info(R2) returns to ckUm, args: 8, res: 8, upd: 8;
  ckUm:
      Hp = Hp + 64;
      if (Hp > HpLim) goto cl17; else goto cl16;
  cl17:
      HpAlloc = 64;
      R1 = R1;
      call stg_gc_unpt_r1(R1) returns to ckUm, args: 8, res: 8, upd: 8;
  cl16:
      I64[Hp - 56] = sat_sk51_info;
      P64[Hp - 40] = P64[Sp + 56];
      P64[Hp - 32] = P64[Sp + 48];
      P64[Hp - 24] = P64[Sp + 40];
      P64[Hp - 16] = R1;
      I64[Hp - 8] = I64[Sp + 8];
      I64[Hp] = I64[Sp + 32];
      R4 = GHC.Types.True_closure+2;
      R3 = Hp - 56;
      R2 = GHC.IO.Handle.FD.stdout_closure;
      Sp = Sp + 64;
      call GHC.IO.Handle.Text.hPutStr2_info(R4,
                                            R3,
                                            R2) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:54.880201 UTC

[(ckRA,
  {SkipList.newSL2_closure, GHC.IO.Handle.Text.hPutStr2_closure,
   GHC.Enum.$w$cenumFromThenTo_closure,
   GHC.IO.Handle.FD.stdout_closure, Main.initGens2_closure,
   Throughput.throughputMain1_closure,
   Options.Applicative.Extra.execParserPure_closure,
   System.Environment.getArgs1_closure,
   Options.Applicative.Extra.customExecParser2_closure,
   lvl20_rjVp_closure, lvl22_rjVr_closure, sat_sk37_closure,
   a7_sk3E_closure, sat_sk51_closure, sat_sk5w_closure,
   sat_sk5N_closure, go_sk65_closure}),
 (ckRC,
  {SkipList.newSL2_closure, GHC.IO.Handle.Text.hPutStr2_closure,
   GHC.Enum.$w$cenumFromThenTo_closure,
   GHC.IO.Handle.FD.stdout_closure, Main.initGens2_closure,
   Throughput.throughputMain1_closure,
   Options.Applicative.Extra.execParserPure_closure,
   Options.Applicative.Extra.customExecParser2_closure,
   lvl20_rjVp_closure, lvl22_rjVr_closure, sat_sk37_closure,
   a7_sk3E_closure, sat_sk51_closure, sat_sk5w_closure,
   sat_sk5N_closure, go_sk65_closure}),
 (ckRN,
  {SkipList.newSL2_closure, GHC.IO.Handle.Text.hPutStr2_closure,
   GHC.Enum.$w$cenumFromThenTo_closure,
   GHC.IO.Handle.FD.stdout_closure, Main.initGens2_closure,
   Throughput.throughputMain1_closure,
   Options.Applicative.Extra.customExecParser2_closure,
   a7_sk3E_closure, sat_sk51_closure, sat_sk5w_closure,
   sat_sk5N_closure, go_sk65_closure}),
 (ckRR,
  {SkipList.newSL2_closure, GHC.IO.Handle.Text.hPutStr2_closure,
   GHC.Enum.$w$cenumFromThenTo_closure,
   GHC.IO.Handle.FD.stdout_closure, Main.initGens2_closure,
   Throughput.throughputMain1_closure, a7_sk3E_closure,
   sat_sk51_closure, sat_sk5w_closure, sat_sk5N_closure,
   go_sk65_closure}),
 (ckRT,
  {SkipList.newSL2_closure, GHC.IO.Handle.Text.hPutStr2_closure,
   GHC.Enum.$w$cenumFromThenTo_closure,
   GHC.IO.Handle.FD.stdout_closure, Main.initGens2_closure,
   Throughput.throughputMain1_closure, a7_sk3E_closure,
   sat_sk51_closure, sat_sk5w_closure, sat_sk5N_closure,
   go_sk65_closure}),
 (ckRU,
  {SkipList.newSL2_closure, GHC.IO.Handle.Text.hPutStr2_closure,
   GHC.Enum.$w$cenumFromThenTo_closure,
   GHC.IO.Handle.FD.stdout_closure, Main.initGens2_closure,
   Throughput.throughputMain1_closure, a7_sk3E_closure,
   sat_sk51_closure, sat_sk5w_closure, sat_sk5N_closure,
   go_sk65_closure}),
 (ckRY,
  {SkipList.newSL2_closure, GHC.IO.Handle.Text.hPutStr2_closure,
   GHC.Enum.$w$cenumFromThenTo_closure,
   GHC.IO.Handle.FD.stdout_closure, Main.initGens2_closure,
   Throughput.throughputMain1_closure, a7_sk3E_closure,
   sat_sk51_closure, sat_sk5w_closure, sat_sk5N_closure,
   go_sk65_closure}),
 (ckRZ,
  {SkipList.newSL2_closure, GHC.IO.Handle.Text.hPutStr2_closure,
   GHC.Enum.$w$cenumFromThenTo_closure,
   GHC.IO.Handle.FD.stdout_closure, Main.initGens2_closure,
   Throughput.throughputMain1_closure, a7_sk3E_closure,
   sat_sk51_closure, sat_sk5w_closure, sat_sk5N_closure,
   go_sk65_closure}),
 (ckSb,
  {SkipList.newSL2_closure, GHC.IO.Handle.Text.hPutStr2_closure,
   GHC.Enum.$w$cenumFromThenTo_closure,
   GHC.IO.Handle.FD.stdout_closure, Main.initGens2_closure,
   Throughput.throughputMain1_closure, a7_sk3E_closure,
   sat_sk51_closure, sat_sk5w_closure, sat_sk5N_closure,
   go_sk65_closure}),
 (ckSd,
  {SkipList.newSL2_closure, GHC.IO.Handle.Text.hPutStr2_closure,
   GHC.Enum.$w$cenumFromThenTo_closure,
   GHC.IO.Handle.FD.stdout_closure, Main.initGens2_closure,
   Throughput.throughputMain1_closure, a7_sk3E_closure,
   sat_sk51_closure, sat_sk5w_closure, sat_sk5N_closure,
   go_sk65_closure}),
 (ckSe,
  {SkipList.newSL2_closure, GHC.IO.Handle.Text.hPutStr2_closure,
   GHC.Enum.$w$cenumFromThenTo_closure,
   GHC.IO.Handle.FD.stdout_closure, Main.initGens2_closure,
   Throughput.throughputMain1_closure, a7_sk3E_closure,
   sat_sk51_closure, sat_sk5w_closure, sat_sk5N_closure,
   go_sk65_closure}),
 (ckSi,
  {SkipList.newSL2_closure, GHC.IO.Handle.Text.hPutStr2_closure,
   GHC.Enum.$w$cenumFromThenTo_closure,
   GHC.IO.Handle.FD.stdout_closure, Main.initGens2_closure,
   Throughput.throughputMain1_closure, a7_sk3E_closure,
   sat_sk51_closure, sat_sk5w_closure, sat_sk5N_closure,
   go_sk65_closure}),
 (ckSj,
  {SkipList.newSL2_closure, GHC.IO.Handle.Text.hPutStr2_closure,
   GHC.Enum.$w$cenumFromThenTo_closure,
   GHC.IO.Handle.FD.stdout_closure, Main.initGens2_closure,
   Throughput.throughputMain1_closure, a7_sk3E_closure,
   sat_sk51_closure, sat_sk5w_closure, sat_sk5N_closure,
   go_sk65_closure}),
 (ckSn,
  {SkipList.newSL2_closure, GHC.IO.Handle.Text.hPutStr2_closure,
   GHC.Enum.$w$cenumFromThenTo_closure,
   GHC.IO.Handle.FD.stdout_closure, Main.initGens2_closure,
   Throughput.throughputMain1_closure, a7_sk3E_closure,
   sat_sk51_closure, sat_sk5w_closure, sat_sk5N_closure,
   go_sk65_closure}),
 (ckSo,
  {SkipList.newSL2_closure, GHC.IO.Handle.Text.hPutStr2_closure,
   GHC.Enum.$w$cenumFromThenTo_closure,
   GHC.IO.Handle.FD.stdout_closure, Main.initGens2_closure,
   Throughput.throughputMain1_closure, a7_sk3E_closure,
   sat_sk51_closure, sat_sk5w_closure, sat_sk5N_closure,
   go_sk65_closure}),
 (ckSu,
  {SkipList.newSL2_closure, GHC.IO.Handle.Text.hPutStr2_closure,
   GHC.Enum.$w$cenumFromThenTo_closure,
   GHC.IO.Handle.FD.stdout_closure,
   Throughput.throughputMain1_closure, a7_sk3E_closure,
   sat_sk51_closure, sat_sk5w_closure, sat_sk5N_closure}),
 (ckSv,
  {SkipList.newSL2_closure, GHC.IO.Handle.Text.hPutStr2_closure,
   GHC.Enum.$w$cenumFromThenTo_closure,
   GHC.IO.Handle.FD.stdout_closure,
   Throughput.throughputMain1_closure, a7_sk3E_closure,
   sat_sk51_closure, sat_sk5w_closure, sat_sk5N_closure}),
 (ckSx,
  {GHC.IO.Handle.Text.hPutStr2_closure,
   GHC.Enum.$w$cenumFromThenTo_closure,
   GHC.IO.Handle.FD.stdout_closure,
   Throughput.throughputMain1_closure, a7_sk3E_closure,
   sat_sk51_closure, sat_sk5w_closure, sat_sk5N_closure}),
 (ckU1,
  {GHC.IO.Handle.Text.hPutStr2_closure,
   GHC.IO.Handle.FD.stdout_closure,
   Throughput.throughputMain1_closure, a7_sk3E_closure,
   sat_sk51_closure, sat_sk5w_closure, sat_sk5N_closure}),
 (ckU5,
  {GHC.IO.Handle.Text.hPutStr2_closure,
   GHC.IO.Handle.FD.stdout_closure,
   Throughput.throughputMain1_closure, sat_sk51_closure,
   sat_sk5w_closure, sat_sk5N_closure}),
 (ckU9,
  {GHC.IO.Handle.Text.hPutStr2_closure,
   GHC.IO.Handle.FD.stdout_closure,
   Throughput.throughputMain1_closure, sat_sk51_closure,
   sat_sk5w_closure, sat_sk5N_closure}),
 (ckUa,
  {GHC.IO.Handle.Text.hPutStr2_closure,
   GHC.IO.Handle.FD.stdout_closure,
   Throughput.throughputMain1_closure, sat_sk51_closure,
   sat_sk5w_closure, sat_sk5N_closure}),
 (ckUc,
  {GHC.IO.Handle.Text.hPutStr2_closure,
   GHC.IO.Handle.FD.stdout_closure,
   Throughput.throughputMain1_closure, sat_sk51_closure,
   sat_sk5w_closure, sat_sk5N_closure}),
 (ckUd,
  {GHC.IO.Handle.Text.hPutStr2_closure,
   GHC.IO.Handle.FD.stdout_closure,
   Throughput.throughputMain1_closure, sat_sk51_closure,
   sat_sk5w_closure, sat_sk5N_closure}),
 (ckUj,
  {GHC.IO.Handle.Text.hPutStr2_closure,
   GHC.IO.Handle.FD.stdout_closure, sat_sk51_closure}),
 (ckUk,
  {GHC.IO.Handle.Text.hPutStr2_closure,
   GHC.IO.Handle.FD.stdout_closure, sat_sk51_closure}),
 (ckUm,
  {GHC.IO.Handle.Text.hPutStr2_closure,
   GHC.IO.Handle.FD.stdout_closure, sat_sk51_closure}),
 (ckY5,
  {GHC.IO.Handle.Text.hPutStr2_closure,
   GHC.IO.Handle.FD.stdout_closure,
   Throughput.throughputMain1_closure, sat_sk51_closure,
   sat_sk5w_closure, sat_sk5N_closure}),
 (ckY6,
  {GHC.IO.Handle.Text.hPutStr2_closure,
   GHC.IO.Handle.FD.stdout_closure,
   Throughput.throughputMain1_closure, sat_sk51_closure,
   sat_sk5w_closure, sat_sk5N_closure}),
 (cl0B,
  {SkipList.newSL2_closure, GHC.IO.Handle.Text.hPutStr2_closure,
   GHC.Enum.$w$cenumFromThenTo_closure,
   GHC.IO.Handle.FD.stdout_closure, Main.main1_closure,
   Main.initGens2_closure, Throughput.throughputMain1_closure,
   Options.Applicative.Extra.execParserPure_closure,
   System.Environment.getProgName1_closure,
   System.Environment.getArgs1_closure,
   Options.Applicative.Extra.customExecParser2_closure,
   lvl20_rjVp_closure, lvl22_rjVr_closure, sat_sk37_closure,
   a7_sk3E_closure, sat_sk51_closure, sat_sk5w_closure,
   sat_sk5N_closure, go_sk65_closure}),
 (cl0C, {Main.main1_closure}),
 (cl0D,
  {SkipList.newSL2_closure, GHC.IO.Handle.Text.hPutStr2_closure,
   GHC.Enum.$w$cenumFromThenTo_closure,
   GHC.IO.Handle.FD.stdout_closure, Main.main1_closure,
   Main.initGens2_closure, Throughput.throughputMain1_closure,
   Options.Applicative.Extra.execParserPure_closure,
   System.Environment.getProgName1_closure,
   System.Environment.getArgs1_closure,
   Options.Applicative.Extra.customExecParser2_closure,
   lvl20_rjVp_closure, lvl22_rjVr_closure, sat_sk37_closure,
   a7_sk3E_closure, sat_sk51_closure, sat_sk5w_closure,
   sat_sk5N_closure, go_sk65_closure}),
 (cl0E,
  {SkipList.newSL2_closure, GHC.IO.Handle.Text.hPutStr2_closure,
   GHC.Enum.$w$cenumFromThenTo_closure,
   GHC.IO.Handle.FD.stdout_closure, Main.initGens2_closure,
   Throughput.throughputMain1_closure,
   Options.Applicative.Extra.execParserPure_closure,
   System.Environment.getProgName1_closure,
   System.Environment.getArgs1_closure,
   Options.Applicative.Extra.customExecParser2_closure,
   lvl20_rjVp_closure, lvl22_rjVr_closure, sat_sk37_closure,
   a7_sk3E_closure, sat_sk51_closure, sat_sk5w_closure,
   sat_sk5N_closure, go_sk65_closure}),
 (cl0H,
  {SkipList.newSL2_closure, GHC.IO.Handle.Text.hPutStr2_closure,
   GHC.Enum.$w$cenumFromThenTo_closure,
   GHC.IO.Handle.FD.stdout_closure, Main.initGens2_closure,
   Throughput.throughputMain1_closure,
   Options.Applicative.Extra.execParserPure_closure,
   Options.Applicative.Extra.customExecParser2_closure,
   lvl20_rjVp_closure, lvl22_rjVr_closure, sat_sk37_closure,
   a7_sk3E_closure, sat_sk51_closure, sat_sk5w_closure,
   sat_sk5N_closure, go_sk65_closure}),
 (cl0I,
  {SkipList.newSL2_closure, GHC.IO.Handle.Text.hPutStr2_closure,
   GHC.Enum.$w$cenumFromThenTo_closure,
   GHC.IO.Handle.FD.stdout_closure, Main.initGens2_closure,
   Throughput.throughputMain1_closure,
   Options.Applicative.Extra.execParserPure_closure,
   Options.Applicative.Extra.customExecParser2_closure,
   lvl20_rjVp_closure, lvl22_rjVr_closure, sat_sk37_closure,
   a7_sk3E_closure, sat_sk51_closure, sat_sk5w_closure,
   sat_sk5N_closure, go_sk65_closure}),
 (cl0R,
  {SkipList.newSL2_closure, GHC.IO.Handle.Text.hPutStr2_closure,
   GHC.Enum.$w$cenumFromThenTo_closure,
   GHC.IO.Handle.FD.stdout_closure, Main.initGens2_closure,
   Throughput.throughputMain1_closure, a7_sk3E_closure,
   sat_sk51_closure, sat_sk5w_closure, sat_sk5N_closure,
   go_sk65_closure}),
 (cl0S,
  {SkipList.newSL2_closure, GHC.IO.Handle.Text.hPutStr2_closure,
   GHC.Enum.$w$cenumFromThenTo_closure,
   GHC.IO.Handle.FD.stdout_closure, Main.initGens2_closure,
   Throughput.throughputMain1_closure, a7_sk3E_closure,
   sat_sk51_closure, sat_sk5w_closure, sat_sk5N_closure,
   go_sk65_closure}),
 (cl0T,
  {SkipList.newSL2_closure, GHC.IO.Handle.Text.hPutStr2_closure,
   GHC.Enum.$w$cenumFromThenTo_closure,
   GHC.IO.Handle.FD.stdout_closure,
   Throughput.throughputMain1_closure, a7_sk3E_closure,
   sat_sk51_closure, sat_sk5w_closure, sat_sk5N_closure}),
 (cl0U,
  {SkipList.newSL2_closure, GHC.IO.Handle.Text.hPutStr2_closure,
   GHC.Enum.$w$cenumFromThenTo_closure,
   GHC.IO.Handle.FD.stdout_closure,
   Throughput.throughputMain1_closure, a7_sk3E_closure,
   sat_sk51_closure, sat_sk5w_closure, sat_sk5N_closure}),
 (cl0W,
  {GHC.IO.Handle.Text.hPutStr2_closure,
   GHC.Enum.$w$cenumFromThenTo_closure,
   GHC.IO.Handle.FD.stdout_closure,
   Throughput.throughputMain1_closure, a7_sk3E_closure,
   sat_sk51_closure, sat_sk5w_closure, sat_sk5N_closure}),
 (cl0X,
  {GHC.IO.Handle.Text.hPutStr2_closure,
   GHC.Enum.$w$cenumFromThenTo_closure,
   GHC.IO.Handle.FD.stdout_closure,
   Throughput.throughputMain1_closure, a7_sk3E_closure,
   sat_sk51_closure, sat_sk5w_closure, sat_sk5N_closure}),
 (cl10,
  {GHC.IO.Handle.Text.hPutStr2_closure,
   GHC.IO.Handle.FD.stdout_closure,
   Throughput.throughputMain1_closure, sat_sk51_closure,
   sat_sk5w_closure, sat_sk5N_closure}),
 (cl11,
  {GHC.IO.Handle.Text.hPutStr2_closure,
   GHC.IO.Handle.FD.stdout_closure,
   Throughput.throughputMain1_closure, sat_sk51_closure,
   sat_sk5w_closure, sat_sk5N_closure}),
 (cl13,
  {GHC.IO.Handle.Text.hPutStr2_closure,
   GHC.IO.Handle.FD.stdout_closure, sat_sk51_closure}),
 (cl14,
  {GHC.IO.Handle.Text.hPutStr2_closure,
   GHC.IO.Handle.FD.stdout_closure, sat_sk51_closure}),
 (cl16,
  {GHC.IO.Handle.Text.hPutStr2_closure,
   GHC.IO.Handle.FD.stdout_closure, sat_sk51_closure}),
 (cl17,
  {GHC.IO.Handle.Text.hPutStr2_closure,
   GHC.IO.Handle.FD.stdout_closure, sat_sk51_closure}),
 (cl19,
  {GHC.IO.Handle.Text.hPutStr2_closure,
   GHC.IO.Handle.FD.stdout_closure,
   Throughput.throughputMain1_closure, sat_sk51_closure,
   sat_sk5w_closure, sat_sk5N_closure}),
 (cl1e,
  {GHC.IO.Handle.Text.hPutStr2_closure,
   GHC.IO.Handle.FD.stdout_closure, sat_sk51_closure}),
 (cl1g,
  {GHC.IO.Handle.Text.hPutStr2_closure,
   GHC.IO.Handle.FD.stdout_closure, sat_sk51_closure}),
 (cl1i,
  {GHC.IO.Handle.Text.hPutStr2_closure,
   GHC.IO.Handle.FD.stdout_closure,
   Throughput.throughputMain1_closure, sat_sk51_closure,
   sat_sk5w_closure, sat_sk5N_closure}),
 (cl1k,
  {GHC.IO.Handle.Text.hPutStr2_closure,
   GHC.IO.Handle.FD.stdout_closure,
   Throughput.throughputMain1_closure, sat_sk51_closure,
   sat_sk5w_closure}),
 (cl1l,
  {GHC.IO.Handle.Text.hPutStr2_closure,
   GHC.IO.Handle.FD.stdout_closure,
   Throughput.throughputMain1_closure, sat_sk51_closure,
   sat_sk5w_closure, sat_sk5N_closure}),
 (cl1n,
  {GHC.IO.Handle.Text.hPutStr2_closure,
   GHC.IO.Handle.FD.stdout_closure, sat_sk51_closure}),
 (cl1w,
  {GHC.IO.Handle.Text.hPutStr2_closure,
   GHC.IO.Handle.FD.stdout_closure, sat_sk51_closure}),
 (cl1y,
  {GHC.IO.Handle.Text.hPutStr2_closure,
   GHC.IO.Handle.FD.stdout_closure, sat_sk51_closure}),
 (cl1z,
  {GHC.IO.Handle.Text.hPutStr2_closure,
   GHC.IO.Handle.FD.stdout_closure,
   Throughput.throughputMain1_closure, sat_sk51_closure,
   sat_sk5w_closure, sat_sk5N_closure}),
 (cl1B,
  {GHC.IO.Handle.Text.hPutStr2_closure,
   GHC.IO.Handle.FD.stdout_closure,
   Throughput.throughputMain1_closure, sat_sk51_closure,
   sat_sk5N_closure}),
 (cl1C,
  {GHC.IO.Handle.Text.hPutStr2_closure,
   GHC.IO.Handle.FD.stdout_closure,
   Throughput.throughputMain1_closure, sat_sk51_closure,
   sat_sk5w_closure, sat_sk5N_closure}),
 (cl1E,
  {GHC.IO.Handle.Text.hPutStr2_closure,
   GHC.IO.Handle.FD.stdout_closure, sat_sk51_closure}),
 (cl1M, {}),
 (cl1S,
  {GHC.IO.Handle.Text.hPutStr2_closure,
   GHC.IO.Handle.FD.stdout_closure,
   Throughput.throughputMain1_closure, sat_sk51_closure,
   sat_sk5w_closure, sat_sk5N_closure}),
 (cl1U,
  {GHC.IO.Handle.Text.hPutStr2_closure,
   GHC.IO.Handle.FD.stdout_closure,
   Throughput.throughputMain1_closure, sat_sk51_closure,
   sat_sk5w_closure, sat_sk5N_closure}),
 (cl1Y,
  {GHC.IO.Handle.Text.hPutStr2_closure,
   GHC.IO.Handle.FD.stdout_closure,
   Throughput.throughputMain1_closure, sat_sk51_closure,
   sat_sk5w_closure, sat_sk5N_closure}),
 (cl1Z,
  {GHC.IO.Handle.Text.hPutStr2_closure,
   GHC.IO.Handle.FD.stdout_closure,
   Throughput.throughputMain1_closure, sat_sk51_closure,
   sat_sk5w_closure, sat_sk5N_closure}),
 (cl23,
  {GHC.IO.Handle.Text.hPutStr2_closure,
   GHC.IO.Handle.FD.stdout_closure,
   Throughput.throughputMain1_closure, sat_sk51_closure,
   sat_sk5w_closure, sat_sk5N_closure}),
 (cl27,
  {SkipList.newSL2_closure, GHC.IO.Handle.Text.hPutStr2_closure,
   GHC.Enum.$w$cenumFromThenTo_closure,
   GHC.IO.Handle.FD.stdout_closure, Main.initGens2_closure,
   Throughput.throughputMain1_closure, a7_sk3E_closure,
   sat_sk51_closure, sat_sk5w_closure, sat_sk5N_closure}),
 (cl29,
  {SkipList.newSL2_closure, GHC.IO.Handle.Text.hPutStr2_closure,
   GHC.Enum.$w$cenumFromThenTo_closure,
   GHC.IO.Handle.FD.stdout_closure, Main.initGens2_closure,
   Throughput.throughputMain1_closure, a7_sk3E_closure,
   sat_sk51_closure, sat_sk5w_closure, sat_sk5N_closure,
   go_sk65_closure}),
 (cl2d,
  {SkipList.newSL2_closure, GHC.IO.Handle.Text.hPutStr2_closure,
   GHC.Enum.$w$cenumFromThenTo_closure,
   GHC.IO.Handle.FD.stdout_closure,
   Throughput.throughputMain1_closure, a7_sk3E_closure,
   sat_sk51_closure, sat_sk5w_closure, sat_sk5N_closure}),
 (cl2h,
  {SkipList.newSL2_closure, GHC.IO.Handle.Text.hPutStr2_closure,
   GHC.Enum.$w$cenumFromThenTo_closure,
   GHC.IO.Handle.FD.stdout_closure,
   Throughput.throughputMain1_closure, a7_sk3E_closure,
   sat_sk51_closure, sat_sk5w_closure, sat_sk5N_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:54.901336 UTC

Main.main1_entry() //  []
        { info_tbl: [(ckRA,
                      label: block_ckRA_info
                      rep:StackRep []),
                     (ckRC,
                      label: block_ckRC_info
                      rep:StackRep [False]),
                     (ckRN,
                      label: block_ckRN_info
                      rep:StackRep [False]),
                     (ckRR,
                      label: block_ckRR_info
                      rep:StackRep [False]),
                     (ckRT,
                      label: block_ckRT_info
                      rep:StackRep [False]),
                     (ckRY,
                      label: block_ckRY_info
                      rep:StackRep [False, False, False, False, False, False]),
                     (ckSb,
                      label: block_ckSb_info
                      rep:StackRep [True, False, False, False, False, False, False]),
                     (ckSd,
                      label: block_ckSd_info
                      rep:StackRep [True, False, False, False, True, False, False]),
                     (ckSi,
                      label: block_ckSi_info
                      rep:StackRep [True, False, False, True, True, False, False]),
                     (ckSn,
                      label: block_ckSn_info
                      rep:StackRep [True, False, False, True, True, True, False]),
                     (ckSu,
                      label: block_ckSu_info
                      rep:StackRep [True, False, False, True, True, True, False]),
                     (ckSx,
                      label: block_ckSx_info
                      rep:StackRep [False, True, False, False, True, True, True, False]),
                     (ckU1,
                      label: block_ckU1_info
                      rep:StackRep [False, False, False, True, False, False, True, True,
                                    True, False]),
                     (ckU5,
                      label: block_ckU5_info
                      rep:StackRep [False, True, False, True, False, False, True, True,
                                    True, False]),
                     (ckU9,
                      label: block_ckU9_info
                      rep:StackRep [False, True, False, True, False, False, True, True,
                                    True, False]),
                     (ckUc,
                      label: block_ckUc_info
                      rep:StackRep [False, True, False, True, False, False, True, True,
                                    True, False]),
                     (ckUj,
                      label: block_ckUj_info
                      rep:StackRep [True, False, True, True, True, True, False]),
                     (ckUm,
                      label: block_ckUm_info
                      rep:StackRep [True, True, True, True, False, False, False]),
                     (ckY5,
                      label: block_ckY5_info
                      rep:StackRep [False, True, False, True, False, True, True, True,
                                    True, False]),
                     (cl0B,
                      label: Main.main1_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} }),
                     (cl1e,
                      label: block_cl1e_info
                      rep:StackRep [True, False, True, True, True, True, False]),
                     (cl1g,
                      label: block_cl1g_info
                      rep:StackRep [True, False, True, True, True, True, False]),
                     (cl1w,
                      label: block_cl1w_info
                      rep:StackRep [True, False, True, True, True, True, False]),
                     (cl1y,
                      label: block_cl1y_info
                      rep:StackRep [True, False, True, True, True, True, False]),
                     (cl1S,
                      label: block_cl1S_info
                      rep:StackRep [False, True, False, True, False, False, True, True,
                                    True, False]),
                     (cl1Y,
                      label: block_cl1Y_info
                      rep:StackRep [False, True, False, True, False, False, True, True,
                                    True, False]),
                     (cl23,
                      label: block_cl23_info
                      rep:StackRep [False, True, False, True, False, False, True, True,
                                    True, False]),
                     (cl27,
                      label: block_cl27_info
                      rep:StackRep [True, False, False, True, True, True, False]),
                     (cl2d,
                      label: block_cl2d_info
                      rep:StackRep [True, False, False, True, True, True, False])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cl0B:
          if ((Sp + -88) < SpLim) goto cl0C; else goto cl0D;
      cl0D:
          if (HpLim == 0) goto cl0C; else goto cl0E;
      cl0C:
          R1 = Main.main1_closure;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
      cl0E:
          I64[Sp - 8] = ckRA;
          Sp = Sp - 8;
          call System.Environment.getProgName1_info() returns to ckRA, args: 8, res: 8, upd: 8;
      ckRA:
          I64[Sp - 8] = ckRC;
          P64[Sp] = R1;
          Sp = Sp - 8;
          call System.Environment.getArgs1_info() returns to ckRC, args: 8, res: 8, upd: 8;
      ckRC:
          Hp = Hp + 88;
          if (Hp > HpLim) goto cl0I; else goto cl0H;
      cl0I:
          HpAlloc = 88;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to ckRC, args: 8, res: 8, upd: 8;
      cl0H:
          I64[Hp - 80] = sat_sk37_info;
          P64[Hp - 64] = P64[Sp + 8];
          I64[Hp - 56] = Options.Applicative.Types.ParserInfo_con_info;
          P64[Hp - 48] = lvl20_rjVp_closure+3;
          P64[Hp - 40] = GHC.Types.True_closure+2;
          P64[Hp - 32] = lvl22_rjVr_closure;
          P64[Hp - 24] = Hp - 80;
          P64[Hp - 16] = GHC.Base.Nothing_closure+1;
          P64[Hp - 8] = Options.Applicative.Builder.info1_closure;
          P64[Hp] = GHC.Types.True_closure+2;
          I64[Sp] = ckRN;
          R4 = R1;
          R3 = Hp - 55;
          R2 = Options.Applicative.Builder.prefs1_closure;
          call Options.Applicative.Extra.execParserPure_info(R4,
                                                             R3,
                                                             R2) returns to ckRN, args: 8, res: 8, upd: 8;
      ckRN:
          I64[Sp] = ckRR;
          R2 = R1;
          call Options.Applicative.Extra.customExecParser2_info(R2) returns to ckRR, args: 8, res: 8, upd: 8;
      ckRR:
          I64[Sp] = ckRT;
          R1 = R1;
          if (R1 & 7 != 0) goto ckRT; else goto ckRU;
      ckRU:
          call (I64[R1])(R1) returns to ckRT, args: 8, res: 8, upd: 8;
      ckRT:
          I64[Sp - 40] = ckRY;
          _sk3e::P64 = P64[R1 + 7];
          _sk3g::P64 = P64[R1 + 23];
          _sk3h::P64 = P64[R1 + 31];
          _sk3j::P64 = P64[R1 + 47];
          _sk3k::P64 = P64[R1 + 55];
          R1 = P64[R1 + 15];
          P64[Sp - 32] = _sk3g::P64;
          P64[Sp - 24] = _sk3h::P64;
          P64[Sp - 16] = _sk3j::P64;
          P64[Sp - 8] = _sk3k::P64;
          P64[Sp] = _sk3e::P64;
          Sp = Sp - 40;
          if (R1 & 7 != 0) goto ckRY; else goto ckRZ;
      ckRZ:
          call (I64[R1])(R1) returns to ckRY, args: 8, res: 8, upd: 8;
      ckRY:
          I64[Sp - 8] = ckSb;
          _sk3m::I64 = I64[R1 + 7];
          I64[Sp] = _sk3m::I64;
          Sp = Sp - 8;
          _ul2n::P64 = CurrentTSO;
          I64[I64[_ul2n::P64 + 24] + 16] = Sp;
          _ul2o::I64 = CurrentNursery;
          P64[_ul2o::I64 + 8] = Hp + 8;
          I64[_ul2n::P64 + 112] = I64[_ul2n::P64 + 112] - ((Hp + 8) - I64[_ul2o::I64]);
          (_ul2k::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
          call "ccall" arg hints:  []  result hints:  [] setNumCapabilities(%MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_sk3m::I64)));
          (_ul2l::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_ul2k::I64);
          BaseReg = _ul2l::I64;
          _ul2n::P64 = CurrentTSO;
          _ul2m::P64 = I64[_ul2n::P64 + 24];
          Sp = I64[_ul2m::P64 + 16];
          SpLim = _ul2m::P64 + 192;
          HpAlloc = 0;
          _ul2o::I64 = CurrentNursery;
          _ul2p::I64 = I64[_ul2o::I64 + 8];
          Hp = _ul2p::I64 - 8;
          _ul2q::I64 = I64[_ul2o::I64];
          HpLim = _ul2q::I64 + ((%MO_SS_Conv_W32_W64(I32[_ul2o::I64 + 48]) << 12) - 1);
          I64[_ul2n::P64 + 112] = I64[_ul2n::P64 + 112] + (_ul2p::I64 - _ul2q::I64);
          call (I64[Sp])() returns to ckSb, args: 8, res: 8, upd: 8;
      ckSb:
          I64[Sp] = ckSd;
          R1 = P64[Sp + 40];
          if (R1 & 7 != 0) goto ckSd; else goto ckSe;
      ckSe:
          call (I64[R1])(R1) returns to ckSd, args: 8, res: 8, upd: 8;
      ckSd:
          I64[Sp] = ckSi;
          _sk3t::I64 = I64[R1 + 7];
          R1 = P64[Sp + 32];
          I64[Sp + 40] = _sk3t::I64;
          if (R1 & 7 != 0) goto ckSi; else goto ckSj;
      ckSj:
          call (I64[R1])(R1) returns to ckSi, args: 8, res: 8, upd: 8;
      ckSi:
          I64[Sp] = ckSn;
          _sk3v::F64 = F64[R1 + 7];
          R1 = P64[Sp + 48];
          F64[Sp + 48] = _sk3v::F64;
          if (R1 & 7 != 0) goto ckSn; else goto ckSo;
      ckSo:
          call (I64[R1])(R1) returns to ckSn, args: 8, res: 8, upd: 8;
      ckSn:
          Hp = Hp + 16;
          if (Hp > HpLim) goto cl0S; else goto cl0R;
      cl0S:
          HpAlloc = 16;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to ckSn, args: 8, res: 8, upd: 8;
      cl0R:
          _sk3m::I64 = I64[Sp + 8];
          _sk3x::I64 = I64[R1 + 7];
          if (%MO_S_Gt_W64(1, _sk3m::I64)) goto cl2h; else goto cl29;
      cl2h:
          Hp = Hp - 16;
          _sk3A::P64 = GHC.Types.[]_closure+1;
          goto ckSv;
      cl29:
          I64[Hp - 8] = go_sk65_info;
          I64[Hp] = _sk3m::I64;
          I64[Sp] = cl27;
          R2 = 1;
          R1 = Hp - 7;
          I64[Sp + 32] = _sk3x::I64;
          call go_sk65_info(R2, R1) returns to cl27, args: 8, res: 8, upd: 8;
      cl27:
          I64[Sp] = cl2d;
          R2 = R1;
          call Main.initGens2_info(R2) returns to cl2d, args: 8, res: 8, upd: 8;
      cl2d:
          _sk3x::I64 = I64[Sp + 32];
          _sk3A::P64 = R1;
          goto ckSv;
      ckSv:
          if (HpLim == 0) goto cl0T; else goto cl0U;
      cl0T:
          I64[Sp] = ckSu;
          R1 = _sk3A::P64;
          I64[Sp + 32] = _sk3x::I64;
          call stg_gc_unpt_r1(R1) returns to ckSu, args: 8, res: 8, upd: 8;
      ckSu:
          _sk3x::I64 = I64[Sp + 32];
          _sk3A::P64 = R1;
          goto ckSv;
      cl0U:
          I64[Sp - 8] = ckSx;
          R1 = SkipList.newSL2_closure+1;
          P64[Sp] = _sk3A::P64;
          I64[Sp + 32] = _sk3x::I64;
          Sp = Sp - 8;
          call stg_norec_atomically#(R1) returns to ckSx, args: 8, res: 8, upd: 8;
      ckSx:
          Hp = Hp + 16;
          if (Hp > HpLim) goto cl0X; else goto cl0W;
      cl0X:
          HpAlloc = 16;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to ckSx, args: 8, res: 8, upd: 8;
      cl0W:
          I64[Hp - 8] = a7_sk3E_info;
          P64[Hp] = R1;
          I64[Sp - 16] = ckU1;
          R4 = I64[Sp + 40];
          R3 = 2;
          R2 = 0;
          P64[Sp - 8] = R1;
          P64[Sp] = Hp - 6;
          Sp = Sp - 16;
          call GHC.Enum.$w$cenumFromThenTo_info(R4,
                                                R3,
                                                R2) returns to ckU1, args: 8, res: 8, upd: 8;
      ckU1:
          I64[Sp] = ckU5;
          R2 = R1;
          R1 = P64[Sp + 16];
          call a7_sk3E_info(R2, R1) returns to ckU5, args: 8, res: 8, upd: 8;
      ckU5:
          _sk3m::I64 = I64[Sp + 32];
          if (%MO_S_Lt_W64(0, _sk3m::I64)) goto cl1Z; else goto cl1U;
      cl1Z:
          I64[Sp] = cl1Y;
          R2 = _sk3m::I64;
          call $wxs_rjVo_info(R2) returns to cl1Y, args: 8, res: 8, upd: 8;
      cl1Y:
          I64[Sp] = cl23;
          R2 = R1;
          call Control.Monad.replicateM4_info(R2) returns to cl23, args: 8, res: 8, upd: 8;
      cl23:
          _sk3g::P64 = P64[Sp + 40];
          _sk41::P64 = R1;
          goto ckUa;
      cl1U:
          I64[Sp] = cl1S;
          R2 = GHC.Types.[]_closure+1;
          call Control.Monad.replicateM4_info(R2) returns to cl1S, args: 8, res: 8, upd: 8;
      cl1S:
          _sk3g::P64 = P64[Sp + 40];
          _sk41::P64 = R1;
          goto ckUa;
      ckUa:
          if (HpLim == 0) goto cl10; else goto cl11;
      cl10:
          I64[Sp] = ckU9;
          R1 = _sk41::P64;
          call stg_gc_unpt_r1(R1) returns to ckU9, args: 8, res: 8, upd: 8;
      ckU9:
          _sk3g::P64 = P64[Sp + 40];
          _sk41::P64 = R1;
          goto ckUa;
      cl11:
          I64[Sp] = ckUc;
          R1 = _sk3g::P64;
          P64[Sp + 40] = _sk41::P64;
          if (R1 & 7 != 0) goto ckUc; else goto ckUd;
      ckUd:
          call (I64[R1])(R1) returns to ckUc, args: 8, res: 8, upd: 8;
      ckUc:
          if (R1 & 7 != 1) goto cl1M; else goto cl19;
      cl1M:
          R1 = GHC.Tuple.()_closure+1;
          Sp = Sp + 88;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
      cl19:
          I64[Sp] = ckY5;
          R1 = P64[Sp + 48];
          if (R1 & 7 != 0) goto ckY5; else goto ckY6;
      ckY6:
          call (I64[R1])(R1) returns to ckY5, args: 8, res: 8, upd: 8;
      ckY5:
          _sk3t::I64 = I64[Sp + 64];
          _sk3v::F64 = F64[Sp + 72];
          _sk3x::I64 = I64[Sp + 56];
          _sk3A::P64 = P64[Sp + 24];
          _sk41::P64 = P64[Sp + 40];
          if (R1 & 7 != 1) goto cl1z; else goto cl1i;
      cl1z:
          Hp = Hp + 64;
          if (Hp > HpLim) goto cl1C; else goto cl1B;
      cl1C:
          HpAlloc = 64;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to ckY5, args: 8, res: 8, upd: 8;
      cl1B:
          I64[Hp - 56] = sat_sk5N_info;
          P64[Hp - 40] = _sk3A::P64;
          P64[Hp - 32] = _sk41::P64;
          F64[Hp - 24] = _sk3v::F64;
          I64[Hp - 16] = _sk3x::I64;
          I64[Hp - 8] = GHC.Types.I#_con_info;
          I64[Hp] = _sk3t::I64 * 1000;
          I64[Sp + 24] = cl1w;
          R3 = Hp - 56;
          R2 = Hp - 7;
          Sp = Sp + 24;
          call Throughput.throughputMain1_info(R3,
                                               R2) returns to cl1w, args: 8, res: 8, upd: 8;
      cl1w:
          I64[Sp] = cl1y;
          R1 = R1;
          if (R1 & 7 != 0) goto cl1y; else goto cl1E;
      cl1E:
          call (I64[R1])(R1) returns to cl1y, args: 8, res: 8, upd: 8;
      cl1y:
          _sk41::P64 = P64[Sp + 16];
          _sk46::P64 = P64[R1 + 15];
          _sk45::P64 = P64[R1 + 7];
          goto ckUk;
      cl1i:
          Hp = Hp + 72;
          if (Hp > HpLim) goto cl1l; else goto cl1k;
      cl1l:
          HpAlloc = 72;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to ckY5, args: 8, res: 8, upd: 8;
      cl1k:
          I64[Hp - 64] = sat_sk5w_info;
          P64[Hp - 48] = _sk3A::P64;
          P64[Hp - 40] = P64[Sp + 8];
          P64[Hp - 32] = _sk41::P64;
          F64[Hp - 24] = _sk3v::F64;
          I64[Hp - 16] = _sk3x::I64;
          I64[Hp - 8] = GHC.Types.I#_con_info;
          I64[Hp] = _sk3t::I64 * 1000;
          I64[Sp + 24] = cl1e;
          R3 = Hp - 64;
          R2 = Hp - 7;
          Sp = Sp + 24;
          call Throughput.throughputMain1_info(R3,
                                               R2) returns to cl1e, args: 8, res: 8, upd: 8;
      cl1e:
          I64[Sp] = cl1g;
          R1 = R1;
          if (R1 & 7 != 0) goto cl1g; else goto cl1n;
      cl1n:
          call (I64[R1])(R1) returns to cl1g, args: 8, res: 8, upd: 8;
      cl1g:
          _sk41::P64 = P64[Sp + 16];
          _sk46::P64 = P64[R1 + 15];
          _sk45::P64 = P64[R1 + 7];
          goto ckUk;
      ckUk:
          if (HpLim == 0) goto cl13; else goto cl14;
      cl13:
          I64[Sp] = ckUj;
          R2 = _sk46::P64;
          R1 = _sk45::P64;
          call stg_gc_pp(R2, R1) returns to ckUj, args: 8, res: 8, upd: 8;
      ckUj:
          _sk41::P64 = P64[Sp + 16];
          _sk46::P64 = R2;
          _sk45::P64 = R1;
          goto ckUk;
      cl14:
          I64[Sp] = ckUm;
          R2 = _sk41::P64;
          P64[Sp + 40] = _sk46::P64;
          P64[Sp + 48] = _sk45::P64;
          call a5_rjVe_info(R2) returns to ckUm, args: 8, res: 8, upd: 8;
      ckUm:
          Hp = Hp + 64;
          if (Hp > HpLim) goto cl17; else goto cl16;
      cl17:
          HpAlloc = 64;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to ckUm, args: 8, res: 8, upd: 8;
      cl16:
          I64[Hp - 56] = sat_sk51_info;
          P64[Hp - 40] = P64[Sp + 56];
          P64[Hp - 32] = P64[Sp + 48];
          P64[Hp - 24] = P64[Sp + 40];
          P64[Hp - 16] = R1;
          I64[Hp - 8] = I64[Sp + 8];
          I64[Hp] = I64[Sp + 32];
          R4 = GHC.Types.True_closure+2;
          R3 = Hp - 56;
          R2 = GHC.IO.Handle.FD.stdout_closure;
          Sp = Sp + 64;
          call GHC.IO.Handle.Text.hPutStr2_info(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:54.922865 UTC

Main.main1_entry() //  []
        { info_tbl: [(ckRA,
                      label: block_ckRA_info
                      rep:StackRep []),
                     (ckRC,
                      label: block_ckRC_info
                      rep:StackRep [False]),
                     (ckRN,
                      label: block_ckRN_info
                      rep:StackRep [False]),
                     (ckRR,
                      label: block_ckRR_info
                      rep:StackRep [False]),
                     (ckRT,
                      label: block_ckRT_info
                      rep:StackRep [False]),
                     (ckRY,
                      label: block_ckRY_info
                      rep:StackRep [False, False, False, False, False, False]),
                     (ckSb,
                      label: block_ckSb_info
                      rep:StackRep [True, False, False, False, False, False, False]),
                     (ckSd,
                      label: block_ckSd_info
                      rep:StackRep [True, False, False, False, True, False, False]),
                     (ckSi,
                      label: block_ckSi_info
                      rep:StackRep [True, False, False, True, True, False, False]),
                     (ckSn,
                      label: block_ckSn_info
                      rep:StackRep [True, False, False, True, True, True, False]),
                     (ckSu,
                      label: block_ckSu_info
                      rep:StackRep [True, False, False, True, True, True, False]),
                     (ckSx,
                      label: block_ckSx_info
                      rep:StackRep [False, True, False, False, True, True, True, False]),
                     (ckU1,
                      label: block_ckU1_info
                      rep:StackRep [False, False, False, True, False, False, True, True,
                                    True, False]),
                     (ckU5,
                      label: block_ckU5_info
                      rep:StackRep [False, True, False, True, False, False, True, True,
                                    True, False]),
                     (ckU9,
                      label: block_ckU9_info
                      rep:StackRep [False, True, False, True, False, False, True, True,
                                    True, False]),
                     (ckUc,
                      label: block_ckUc_info
                      rep:StackRep [False, True, False, True, False, False, True, True,
                                    True, False]),
                     (ckUj,
                      label: block_ckUj_info
                      rep:StackRep [True, False, True, True, True, True, False]),
                     (ckUm,
                      label: block_ckUm_info
                      rep:StackRep [True, True, True, True, False, False, False]),
                     (ckY5,
                      label: block_ckY5_info
                      rep:StackRep [False, True, False, True, False, True, True, True,
                                    True, False]),
                     (cl0B,
                      label: Main.main1_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} }),
                     (cl1e,
                      label: block_cl1e_info
                      rep:StackRep [True, False, True, True, True, True, False]),
                     (cl1g,
                      label: block_cl1g_info
                      rep:StackRep [True, False, True, True, True, True, False]),
                     (cl1w,
                      label: block_cl1w_info
                      rep:StackRep [True, False, True, True, True, True, False]),
                     (cl1y,
                      label: block_cl1y_info
                      rep:StackRep [True, False, True, True, True, True, False]),
                     (cl1S,
                      label: block_cl1S_info
                      rep:StackRep [False, True, False, True, False, False, True, True,
                                    True, False]),
                     (cl1Y,
                      label: block_cl1Y_info
                      rep:StackRep [False, True, False, True, False, False, True, True,
                                    True, False]),
                     (cl23,
                      label: block_cl23_info
                      rep:StackRep [False, True, False, True, False, False, True, True,
                                    True, False]),
                     (cl27,
                      label: block_cl27_info
                      rep:StackRep [True, False, False, True, True, True, False]),
                     (cl2d,
                      label: block_cl2d_info
                      rep:StackRep [True, False, False, True, True, True, False])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cl0B:
          if ((Sp + -88) < SpLim) goto cl0C; else goto cl0D;
      cl0D:
          if (HpLim == 0) goto cl0C; else goto cl0E;
      cl0C:
          R1 = Main.main1_closure;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
      cl0E:
          I64[Sp - 8] = ckRA;
          Sp = Sp - 8;
          call System.Environment.getProgName1_info() returns to ckRA, args: 8, res: 8, upd: 8;
      ckRA:
          I64[Sp - 8] = ckRC;
          P64[Sp] = R1;
          Sp = Sp - 8;
          call System.Environment.getArgs1_info() returns to ckRC, args: 8, res: 8, upd: 8;
      ckRC:
          Hp = Hp + 88;
          if (Hp > HpLim) goto cl0I; else goto cl0H;
      cl0I:
          HpAlloc = 88;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to ckRC, args: 8, res: 8, upd: 8;
      cl0H:
          I64[Hp - 80] = sat_sk37_info;
          P64[Hp - 64] = P64[Sp + 8];
          I64[Hp - 56] = Options.Applicative.Types.ParserInfo_con_info;
          P64[Hp - 48] = lvl20_rjVp_closure+3;
          P64[Hp - 40] = GHC.Types.True_closure+2;
          P64[Hp - 32] = lvl22_rjVr_closure;
          P64[Hp - 24] = Hp - 80;
          P64[Hp - 16] = GHC.Base.Nothing_closure+1;
          P64[Hp - 8] = Options.Applicative.Builder.info1_closure;
          P64[Hp] = GHC.Types.True_closure+2;
          I64[Sp] = ckRN;
          R4 = R1;
          R3 = Hp - 55;
          R2 = Options.Applicative.Builder.prefs1_closure;
          call Options.Applicative.Extra.execParserPure_info(R4,
                                                             R3,
                                                             R2) returns to ckRN, args: 8, res: 8, upd: 8;
      ckRN:
          I64[Sp] = ckRR;
          R2 = R1;
          call Options.Applicative.Extra.customExecParser2_info(R2) returns to ckRR, args: 8, res: 8, upd: 8;
      ckRR:
          I64[Sp] = ckRT;
          R1 = R1;
          if (R1 & 7 != 0) goto ckRT; else goto ckRU;
      ckRU:
          call (I64[R1])(R1) returns to ckRT, args: 8, res: 8, upd: 8;
      ckRT:
          I64[Sp - 40] = ckRY;
          _sk3e::P64 = P64[R1 + 7];
          _sk3g::P64 = P64[R1 + 23];
          _sk3h::P64 = P64[R1 + 31];
          _sk3j::P64 = P64[R1 + 47];
          _sk3k::P64 = P64[R1 + 55];
          R1 = P64[R1 + 15];
          P64[Sp - 32] = _sk3g::P64;
          P64[Sp - 24] = _sk3h::P64;
          P64[Sp - 16] = _sk3j::P64;
          P64[Sp - 8] = _sk3k::P64;
          P64[Sp] = _sk3e::P64;
          Sp = Sp - 40;
          if (R1 & 7 != 0) goto ckRY; else goto ckRZ;
      ckRZ:
          call (I64[R1])(R1) returns to ckRY, args: 8, res: 8, upd: 8;
      ckRY:
          I64[Sp - 8] = ckSb;
          _sk3m::I64 = I64[R1 + 7];
          I64[Sp] = _sk3m::I64;
          Sp = Sp - 8;
          _ul2n::P64 = CurrentTSO;
          I64[I64[_ul2n::P64 + 24] + 16] = Sp;
          _ul2o::I64 = CurrentNursery;
          P64[_ul2o::I64 + 8] = Hp + 8;
          I64[_ul2n::P64 + 112] = I64[_ul2n::P64 + 112] - ((Hp + 8) - I64[_ul2o::I64]);
          (_ul2k::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
          call "ccall" arg hints:  []  result hints:  [] setNumCapabilities(%MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_sk3m::I64)));
          (_ul2l::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_ul2k::I64);
          BaseReg = _ul2l::I64;
          _ul2n::P64 = CurrentTSO;
          _ul2m::P64 = I64[_ul2n::P64 + 24];
          Sp = I64[_ul2m::P64 + 16];
          SpLim = _ul2m::P64 + 192;
          HpAlloc = 0;
          _ul2o::I64 = CurrentNursery;
          _ul2p::I64 = I64[_ul2o::I64 + 8];
          Hp = _ul2p::I64 - 8;
          _ul2q::I64 = I64[_ul2o::I64];
          HpLim = _ul2q::I64 + ((%MO_SS_Conv_W32_W64(I32[_ul2o::I64 + 48]) << 12) - 1);
          I64[_ul2n::P64 + 112] = I64[_ul2n::P64 + 112] + (_ul2p::I64 - _ul2q::I64);
          call (I64[Sp])() returns to ckSb, args: 8, res: 8, upd: 8;
      ckSb:
          I64[Sp] = ckSd;
          R1 = P64[Sp + 40];
          if (R1 & 7 != 0) goto ckSd; else goto ckSe;
      ckSe:
          call (I64[R1])(R1) returns to ckSd, args: 8, res: 8, upd: 8;
      ckSd:
          I64[Sp] = ckSi;
          _sk3t::I64 = I64[R1 + 7];
          R1 = P64[Sp + 32];
          I64[Sp + 40] = _sk3t::I64;
          if (R1 & 7 != 0) goto ckSi; else goto ckSj;
      ckSj:
          call (I64[R1])(R1) returns to ckSi, args: 8, res: 8, upd: 8;
      ckSi:
          I64[Sp] = ckSn;
          _sk3v::F64 = F64[R1 + 7];
          R1 = P64[Sp + 48];
          F64[Sp + 48] = _sk3v::F64;
          if (R1 & 7 != 0) goto ckSn; else goto ckSo;
      ckSo:
          call (I64[R1])(R1) returns to ckSn, args: 8, res: 8, upd: 8;
      ckSn:
          Hp = Hp + 16;
          if (Hp > HpLim) goto cl0S; else goto cl0R;
      cl0S:
          HpAlloc = 16;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to ckSn, args: 8, res: 8, upd: 8;
      cl0R:
          _sk3m::I64 = I64[Sp + 8];
          _sk3x::I64 = I64[R1 + 7];
          if (%MO_S_Gt_W64(1, _sk3m::I64)) goto cl2h; else goto cl29;
      cl2h:
          Hp = Hp - 16;
          _sk3A::P64 = GHC.Types.[]_closure+1;
          goto ckSv;
      cl29:
          I64[Hp - 8] = go_sk65_info;
          I64[Hp] = _sk3m::I64;
          I64[Sp] = cl27;
          R2 = 1;
          R1 = Hp - 7;
          I64[Sp + 32] = _sk3x::I64;
          call go_sk65_info(R2, R1) returns to cl27, args: 8, res: 8, upd: 8;
      cl27:
          I64[Sp] = cl2d;
          R2 = R1;
          call Main.initGens2_info(R2) returns to cl2d, args: 8, res: 8, upd: 8;
      cl2d:
          _sk3x::I64 = I64[Sp + 32];
          _sk3A::P64 = R1;
          goto ckSv;
      ckSv:
          if (HpLim == 0) goto cl0T; else goto cl0U;
      cl0T:
          I64[Sp] = ckSu;
          R1 = _sk3A::P64;
          I64[Sp + 32] = _sk3x::I64;
          call stg_gc_unpt_r1(R1) returns to ckSu, args: 8, res: 8, upd: 8;
      ckSu:
          _sk3x::I64 = I64[Sp + 32];
          _sk3A::P64 = R1;
          goto ckSv;
      cl0U:
          I64[Sp - 8] = ckSx;
          R1 = SkipList.newSL2_closure+1;
          P64[Sp] = _sk3A::P64;
          I64[Sp + 32] = _sk3x::I64;
          Sp = Sp - 8;
          call stg_norec_atomically#(R1) returns to ckSx, args: 8, res: 8, upd: 8;
      ckSx:
          Hp = Hp + 16;
          if (Hp > HpLim) goto cl0X; else goto cl0W;
      cl0X:
          HpAlloc = 16;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to ckSx, args: 8, res: 8, upd: 8;
      cl0W:
          I64[Hp - 8] = a7_sk3E_info;
          P64[Hp] = R1;
          I64[Sp - 16] = ckU1;
          R4 = I64[Sp + 40];
          R3 = 2;
          R2 = 0;
          P64[Sp - 8] = R1;
          P64[Sp] = Hp - 6;
          Sp = Sp - 16;
          call GHC.Enum.$w$cenumFromThenTo_info(R4,
                                                R3,
                                                R2) returns to ckU1, args: 8, res: 8, upd: 8;
      ckU1:
          I64[Sp] = ckU5;
          R2 = R1;
          R1 = P64[Sp + 16];
          call a7_sk3E_info(R2, R1) returns to ckU5, args: 8, res: 8, upd: 8;
      ckU5:
          _sk3m::I64 = I64[Sp + 32];
          if (%MO_S_Lt_W64(0, _sk3m::I64)) goto cl1Z; else goto cl1U;
      cl1Z:
          I64[Sp] = cl1Y;
          R2 = _sk3m::I64;
          call $wxs_rjVo_info(R2) returns to cl1Y, args: 8, res: 8, upd: 8;
      cl1Y:
          I64[Sp] = cl23;
          R2 = R1;
          call Control.Monad.replicateM4_info(R2) returns to cl23, args: 8, res: 8, upd: 8;
      cl23:
          _sk3g::P64 = P64[Sp + 40];
          _sk41::P64 = R1;
          goto ckUa;
      cl1U:
          I64[Sp] = cl1S;
          R2 = GHC.Types.[]_closure+1;
          call Control.Monad.replicateM4_info(R2) returns to cl1S, args: 8, res: 8, upd: 8;
      cl1S:
          _sk3g::P64 = P64[Sp + 40];
          _sk41::P64 = R1;
          goto ckUa;
      ckUa:
          if (HpLim == 0) goto cl10; else goto cl11;
      cl10:
          I64[Sp] = ckU9;
          R1 = _sk41::P64;
          call stg_gc_unpt_r1(R1) returns to ckU9, args: 8, res: 8, upd: 8;
      ckU9:
          _sk3g::P64 = P64[Sp + 40];
          _sk41::P64 = R1;
          goto ckUa;
      cl11:
          I64[Sp] = ckUc;
          R1 = _sk3g::P64;
          P64[Sp + 40] = _sk41::P64;
          if (R1 & 7 != 0) goto ckUc; else goto ckUd;
      ckUd:
          call (I64[R1])(R1) returns to ckUc, args: 8, res: 8, upd: 8;
      ckUc:
          if (R1 & 7 != 1) goto cl1M; else goto cl19;
      cl1M:
          R1 = GHC.Tuple.()_closure+1;
          Sp = Sp + 88;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
      cl19:
          I64[Sp] = ckY5;
          R1 = P64[Sp + 48];
          if (R1 & 7 != 0) goto ckY5; else goto ckY6;
      ckY6:
          call (I64[R1])(R1) returns to ckY5, args: 8, res: 8, upd: 8;
      ckY5:
          _sk3t::I64 = I64[Sp + 64];
          _sk3v::F64 = F64[Sp + 72];
          _sk3x::I64 = I64[Sp + 56];
          _sk3A::P64 = P64[Sp + 24];
          _sk41::P64 = P64[Sp + 40];
          if (R1 & 7 != 1) goto cl1z; else goto cl1i;
      cl1z:
          Hp = Hp + 64;
          if (Hp > HpLim) goto cl1C; else goto cl1B;
      cl1C:
          HpAlloc = 64;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to ckY5, args: 8, res: 8, upd: 8;
      cl1B:
          I64[Hp - 56] = sat_sk5N_info;
          P64[Hp - 40] = _sk3A::P64;
          P64[Hp - 32] = _sk41::P64;
          F64[Hp - 24] = _sk3v::F64;
          I64[Hp - 16] = _sk3x::I64;
          I64[Hp - 8] = GHC.Types.I#_con_info;
          I64[Hp] = _sk3t::I64 * 1000;
          I64[Sp + 24] = cl1w;
          R3 = Hp - 56;
          R2 = Hp - 7;
          Sp = Sp + 24;
          call Throughput.throughputMain1_info(R3,
                                               R2) returns to cl1w, args: 8, res: 8, upd: 8;
      cl1w:
          I64[Sp] = cl1y;
          R1 = R1;
          if (R1 & 7 != 0) goto cl1y; else goto cl1E;
      cl1E:
          call (I64[R1])(R1) returns to cl1y, args: 8, res: 8, upd: 8;
      cl1y:
          _sk41::P64 = P64[Sp + 16];
          _sk46::P64 = P64[R1 + 15];
          _sk45::P64 = P64[R1 + 7];
          goto ckUk;
      cl1i:
          Hp = Hp + 72;
          if (Hp > HpLim) goto cl1l; else goto cl1k;
      cl1l:
          HpAlloc = 72;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to ckY5, args: 8, res: 8, upd: 8;
      cl1k:
          I64[Hp - 64] = sat_sk5w_info;
          P64[Hp - 48] = _sk3A::P64;
          P64[Hp - 40] = P64[Sp + 8];
          P64[Hp - 32] = _sk41::P64;
          F64[Hp - 24] = _sk3v::F64;
          I64[Hp - 16] = _sk3x::I64;
          I64[Hp - 8] = GHC.Types.I#_con_info;
          I64[Hp] = _sk3t::I64 * 1000;
          I64[Sp + 24] = cl1e;
          R3 = Hp - 64;
          R2 = Hp - 7;
          Sp = Sp + 24;
          call Throughput.throughputMain1_info(R3,
                                               R2) returns to cl1e, args: 8, res: 8, upd: 8;
      cl1e:
          I64[Sp] = cl1g;
          R1 = R1;
          if (R1 & 7 != 0) goto cl1g; else goto cl1n;
      cl1n:
          call (I64[R1])(R1) returns to cl1g, args: 8, res: 8, upd: 8;
      cl1g:
          _sk41::P64 = P64[Sp + 16];
          _sk46::P64 = P64[R1 + 15];
          _sk45::P64 = P64[R1 + 7];
          goto ckUk;
      ckUk:
          if (HpLim == 0) goto cl13; else goto cl14;
      cl13:
          I64[Sp] = ckUj;
          R2 = _sk46::P64;
          R1 = _sk45::P64;
          call stg_gc_pp(R2, R1) returns to ckUj, args: 8, res: 8, upd: 8;
      ckUj:
          _sk41::P64 = P64[Sp + 16];
          _sk46::P64 = R2;
          _sk45::P64 = R1;
          goto ckUk;
      cl14:
          I64[Sp] = ckUm;
          R2 = _sk41::P64;
          P64[Sp + 40] = _sk46::P64;
          P64[Sp + 48] = _sk45::P64;
          call a5_rjVe_info(R2) returns to ckUm, args: 8, res: 8, upd: 8;
      ckUm:
          Hp = Hp + 64;
          if (Hp > HpLim) goto cl17; else goto cl16;
      cl17:
          HpAlloc = 64;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to ckUm, args: 8, res: 8, upd: 8;
      cl16:
          I64[Hp - 56] = sat_sk51_info;
          P64[Hp - 40] = P64[Sp + 56];
          P64[Hp - 32] = P64[Sp + 48];
          P64[Hp - 24] = P64[Sp + 40];
          P64[Hp - 16] = R1;
          I64[Hp - 8] = I64[Sp + 8];
          I64[Hp] = I64[Sp + 32];
          R4 = GHC.Types.True_closure+2;
          R3 = Hp - 56;
          R2 = GHC.IO.Handle.FD.stdout_closure;
          Sp = Sp + 64;
          call GHC.IO.Handle.Text.hPutStr2_info(R4,
                                                R3,
                                                R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:54.944405 UTC

[section "data" {
     Main.main1_closure:
         const Main.main1_info;
         const 0;
 },
 sat_sk37_entry() //  [R1]
         { info_tbl: [(ckRI,
                       label: sat_sk37_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckRI:
           _sk37::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckRJ; else goto ckRK;
       ckRK:
           if (HpLim == 0) goto ckRJ; else goto ckRL;
       ckRJ:
           R1 = _sk37::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckRL:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sk37::P64;
           R4 = P64[_sk37::P64 + 16];
           R3 = GHC.Base.Nothing_closure+1;
           R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
           Sp = Sp - 16;
           call Data.OldList.wordsFB_info(R4,
                                          R3,
                                          R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sk3R_entry() //  [R1]
         { info_tbl: [(ckSP,
                       label: block_ckSP_info
                       rep:StackRep [False]),
                      (ckSS,
                       label: sat_sk3R_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} }),
                      (ckSV,
                       label: block_ckSV_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckSS:
           _sk3R::P64 = R1;
           if ((Sp + -32) < SpLim) goto ckSW; else goto ckSX;
       ckSX:
           if (HpLim == 0) goto ckSW; else goto ckSY;
       ckSW:
           R1 = _sk3R::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ckSY:
           I64[Sp - 16] = ckSP;
           R1 = P64[_sk3R::P64 + 7];
           P64[Sp - 8] = P64[_sk3R::P64 + 15];
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ckSP; else goto ckSQ;
       ckSQ:
           call (I64[R1])(R1) returns to ckSP, args: 8, res: 8, upd: 8;
       ckSP:
           I64[Sp - 16] = ckSV;
           _sk3M::P64 = P64[R1 + 7];
           _sk3O::P64 = P64[R1 + 23];
           R1 = P64[R1 + 15];
           P64[Sp - 8] = _sk3O::P64;
           P64[Sp] = _sk3M::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ckSV; else goto ckT0;
       ckT0:
           call (I64[R1])(R1) returns to ckSV, args: 8, res: 8, upd: 8;
       ckSV:
           R6 = P64[Sp + 24];
           R5 = P64[Sp + 8];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = GHC.Classes.$fOrdWord_closure;
           P64[Sp + 24] = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call SkipList.$wa4_info(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 16, res: 0, upd: 8;
     }
 },
 a7_sk3E_entry() //  [R2, R1]
         { info_tbl: [(ckSE,
                       label: block_ckSE_info
                       rep:StackRep [False, False]),
                      (ckTP,
                       label: a7_sk3E_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} }),
                      (ckTV,
                       label: block_ckTV_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckTP:
           _sk3F::P64 = R2;
           _sk3E::P64 = R1;
           if ((Sp + -24) < SpLim) goto ckTQ; else goto ckTR;
       ckTR:
           if (HpLim == 0) goto ckTQ; else goto ckTS;
       ckTQ:
           R2 = _sk3F::P64;
           R1 = _sk3E::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckTS:
           I64[Sp - 24] = ckSE;
           R1 = _sk3F::P64;
           P64[Sp - 16] = P64[_sk3E::P64 + 6];
           P64[Sp - 8] = _sk3E::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ckSE; else goto ckSF;
       ckSF:
           call (I64[R1])(R1) returns to ckSE, args: 8, res: 8, upd: 8;
       ckSE:
           if (R1 & 7 != 1) goto ckTN; else goto ckTM;
       ckTN:
           Hp = Hp + 24;
           if (Hp > HpLim) goto ckTY; else goto ckTX;
       ckTY:
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to ckSE, args: 8, res: 8, upd: 8;
       ckTX:
           _sk3I::P64 = P64[R1 + 6];
           _sk3J::P64 = P64[R1 + 14];
           I64[Hp - 16] = sat_sk3R_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = _sk3I::P64;
           I64[Sp] = ckTV;
           R1 = Hp - 15;
           P64[Sp + 8] = _sk3J::P64;
           call stg_norec_atomically#(R1) returns to ckTV, args: 8, res: 8, upd: 8;
       ckTV:
           R2 = P64[Sp + 8];
           R1 = P64[Sp + 16];
           Sp = Sp + 24;
           call a7_sk3E_info(R2, R1) args: 8, res: 0, upd: 8;
       ckTM:
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sk4r_entry() //  [R1]
         { info_tbl: [(ckVx,
                       label: block_ckVx_info
                       rep:StackRep []),
                      (ckVA,
                       label: sat_sk4r_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckVA:
           _sk4r::P64 = R1;
           if ((Sp + -24) < SpLim) goto ckVB; else goto ckVC;
       ckVC:
           if (HpLim == 0) goto ckVB; else goto ckVD;
       ckVB:
           R1 = _sk4r::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckVD:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sk4r::P64;
           I64[Sp - 24] = ckVx;
           R3 = GHC.Types.[]_closure+1;
           R2 = I64[_sk4r::P64 + 16];
           Sp = Sp - 24;
           call GHC.Show.$wshowWord_info(R3,
                                         R2) returns to ckVx, args: 8, res: 8, upd: 24;
       ckVx:
           Hp = Hp + 24;
           if (Hp > HpLim) goto ckVG; else goto ckVF;
       ckVG:
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) returns to ckVx, args: 8, res: 8, upd: 24;
       ckVF:
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = GHC.Types.[]_closure+1;
           R2 = Hp - 14;
           Sp = Sp + 8;
           call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sk4t_entry() //  [R1]
         { info_tbl: [(ckVI,
                       label: sat_sk4t_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckVI:
           _sk4t::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckVJ; else goto ckVK;
       ckVK:
           Hp = Hp + 48;
           if (Hp > HpLim) goto ckVM; else goto ckVL;
       ckVM:
           HpAlloc = 48;
           goto ckVJ;
       ckVJ:
           R1 = _sk4t::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckVL:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sk4t::P64;
           _sk3x::I64 = I64[_sk4t::P64 + 16];
           I64[Hp - 40] = sat_sk4r_info;
           I64[Hp - 24] = _sk3x::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl14_rjVg_closure+1;
           P64[Hp] = Hp - 40;
           R3 = Hp - 14;
           R2 = Main.rbTreeOpts94_closure;
           Sp = Sp - 16;
           call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sk4v_entry() //  [R1]
         { info_tbl: [(ckVn,
                       label: block_ckVn_info
                       rep:StackRep [True]),
                      (ckVP,
                       label: sat_sk4v_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckVP:
           _sk4v::P64 = R1;
           if ((Sp + -32) < SpLim) goto ckVQ; else goto ckVR;
       ckVR:
           if (HpLim == 0) goto ckVQ; else goto ckVS;
       ckVQ:
           R1 = _sk4v::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckVS:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sk4v::P64;
           I64[Sp - 32] = ckVn;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[_sk4v::P64 + 16];
           R2 = 0;
           I64[Sp - 24] = I64[_sk4v::P64 + 24];
           Sp = Sp - 32;
           call GHC.Show.$wshowSignedInt_info(R4,
                                              R3,
                                              R2) returns to ckVn, args: 8, res: 8, upd: 24;
       ckVn:
           Hp = Hp + 72;
           if (Hp > HpLim) goto ckVV; else goto ckVU;
       ckVV:
           HpAlloc = 72;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) returns to ckVn, args: 8, res: 8, upd: 24;
       ckVU:
           I64[Hp - 64] = sat_sk4t_info;
           I64[Hp - 48] = I64[Sp + 8];
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = lvl14_rjVg_closure+1;
           P64[Hp - 24] = Hp - 64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = Hp - 38;
           R2 = Hp - 14;
           Sp = Sp + 16;
           call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sk4x_entry() //  [R1]
         { info_tbl: [(ckVX,
                       label: sat_sk4x_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckVX:
           _sk4x::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckVY; else goto ckVZ;
       ckVZ:
           Hp = Hp + 56;
           if (Hp > HpLim) goto ckW1; else goto ckW0;
       ckW1:
           HpAlloc = 56;
           goto ckVY;
       ckVY:
           R1 = _sk4x::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckW0:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sk4x::P64;
           _sk3m::I64 = I64[_sk4x::P64 + 16];
           _sk3x::I64 = I64[_sk4x::P64 + 24];
           I64[Hp - 48] = sat_sk4v_info;
           I64[Hp - 32] = _sk3m::I64;
           I64[Hp - 24] = _sk3x::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl14_rjVg_closure+1;
           P64[Hp] = Hp - 48;
           R3 = Hp - 14;
           R2 = Main.rbTreeOpts79_closure;
           Sp = Sp - 16;
           call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sk4z_entry() //  [R1]
         { info_tbl: [(ckW3,
                       label: sat_sk4z_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckW3:
           _sk4z::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckW4; else goto ckW5;
       ckW5:
           Hp = Hp + 56;
           if (Hp > HpLim) goto ckW7; else goto ckW6;
       ckW7:
           HpAlloc = 56;
           goto ckW4;
       ckW4:
           R1 = _sk4z::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckW6:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sk4z::P64;
           _sk33::P64 = P64[_sk4z::P64 + 16];
           _sk3m::I64 = I64[_sk4z::P64 + 24];
           _sk3x::I64 = I64[_sk4z::P64 + 32];
           I64[Hp - 48] = sat_sk4x_info;
           I64[Hp - 32] = _sk3m::I64;
           I64[Hp - 24] = _sk3x::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl14_rjVg_closure+1;
           P64[Hp] = Hp - 48;
           R3 = Hp - 14;
           R2 = _sk33::P64;
           Sp = Sp - 16;
           call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 a8_sk4i_entry() //  [R1]
         { info_tbl: [(ckW9,
                       label: a8_sk4i_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckW9:
           _sk4i::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckWa; else goto ckWb;
       ckWb:
           Hp = Hp + 64;
           if (Hp > HpLim) goto ckWd; else goto ckWc;
       ckWd:
           HpAlloc = 64;
           goto ckWa;
       ckWa:
           R1 = _sk4i::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckWc:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sk4i::P64;
           _sk33::P64 = P64[_sk4i::P64 + 16];
           _sk3m::I64 = I64[_sk4i::P64 + 24];
           _sk3x::I64 = I64[_sk4i::P64 + 32];
           I64[Hp - 56] = sat_sk4z_info;
           P64[Hp - 40] = _sk33::P64;
           I64[Hp - 32] = _sk3m::I64;
           I64[Hp - 24] = _sk3x::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl14_rjVg_closure+1;
           P64[Hp] = Hp - 56;
           R3 = Hp - 14;
           R2 = lvl18_rjVl_closure;
           Sp = Sp - 16;
           call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sk4P_entry() //  [R1]
         { info_tbl: [(ckV0,
                       label: block_ckV0_info
                       rep:StackRep [False, True, True]),
                      (ckWe,
                       label: sat_sk4P_info
                       rep:HeapRep 2 ptrs 2 nonptrs { Thunk }),
                      (ckWq,
                       label: block_ckWq_info
                       rep:StackRep [False]),
                      (ckWu,
                       label: block_ckWu_info
                       rep:StackRep [False]),
                      (ckWF,
                       label: block_ckWF_info
                       rep:StackRep [False]),
                      (ckWJ,
                       label: block_ckWJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckWe:
           _sk4P::P64 = R1;
           if ((Sp + -48) < SpLim) goto ckWf; else goto ckWg;
       ckWg:
           if (HpLim == 0) goto ckWf; else goto ckWh;
       ckWf:
           R1 = _sk4P::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckWh:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sk4P::P64;
           I64[Sp - 48] = ckV0;
           R3 = 0;
           R2 = P64[_sk4P::P64 + 24];
           P64[Sp - 40] = P64[_sk4P::P64 + 16];
           I64[Sp - 32] = I64[_sk4P::P64 + 32];
           I64[Sp - 24] = I64[_sk4P::P64 + 40];
           Sp = Sp - 48;
           call $wgo2_rjVk_info(R3,
                                R2) returns to ckV0, args: 8, res: 8, upd: 24;
       ckV0:
           Hp = Hp + 40;
           if (Hp > HpLim) goto ckWk; else goto ckWj;
       ckWk:
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) returns to ckV0, args: 8, res: 8, upd: 24;
       ckWj:
           I64[Hp - 32] = a8_sk4i_info;
           P64[Hp - 16] = P64[Sp + 8];
           I64[Hp - 8] = I64[Sp + 16];
           I64[Hp] = I64[Sp + 24];
           _ckV7::P64 = Hp - 32;
           if (%MO_S_Ge_W64(R1, 0)) goto ckWN; else goto ckWz;
       ckWN:
           I64[Sp + 16] = ckWF;
           R2 = R1;
           P64[Sp + 24] = _ckV7::P64;
           Sp = Sp + 16;
           call GHC.Integer.Type.smallInteger_info(R2) returns to ckWF, args: 8, res: 8, upd: 24;
       ckWF:
           I64[Sp] = ckWJ;
           R4 = GHC.Types.[]_closure+1;
           R3 = R1;
           R2 = 0;
           call GHC.Show.$w$cshowsPrec1_info(R4,
                                             R3,
                                             R2) returns to ckWJ, args: 8, res: 8, upd: 24;
       ckWJ:
           Hp = Hp + 48;
           if (Hp > HpLim) goto ckWR; else goto ckWQ;
       ckWR:
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) returns to ckWJ, args: 8, res: 8, upd: 24;
       ckWQ:
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = lvl14_rjVg_closure+1;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = Hp - 38;
           R2 = Hp - 14;
           Sp = Sp + 16;
           call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
       ckWz:
           I64[Sp + 16] = ckWq;
           R2 = R1;
           P64[Sp + 24] = _ckV7::P64;
           Sp = Sp + 16;
           call GHC.Integer.Type.wordToInteger_info(R2) returns to ckWq, args: 8, res: 8, upd: 24;
       ckWq:
           I64[Sp] = ckWu;
           R4 = GHC.Types.[]_closure+1;
           R3 = R1;
           R2 = 0;
           call GHC.Show.$w$cshowsPrec1_info(R4,
                                             R3,
                                             R2) returns to ckWu, args: 8, res: 8, upd: 24;
       ckWu:
           Hp = Hp + 48;
           if (Hp > HpLim) goto ckWD; else goto ckWC;
       ckWD:
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) returns to ckWu, args: 8, res: 8, upd: 24;
       ckWC:
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = lvl14_rjVg_closure+1;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = Hp - 38;
           R2 = Hp - 14;
           Sp = Sp + 16;
           call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sk4R_entry() //  [R1]
         { info_tbl: [(ckWT,
                       label: sat_sk4R_info
                       rep:HeapRep 2 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckWT:
           _sk4R::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckWU; else goto ckWV;
       ckWV:
           Hp = Hp + 72;
           if (Hp > HpLim) goto ckWX; else goto ckWW;
       ckWX:
           HpAlloc = 72;
           goto ckWU;
       ckWU:
           R1 = _sk4R::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckWW:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sk4R::P64;
           _sk33::P64 = P64[_sk4R::P64 + 16];
           _sk49::P64 = P64[_sk4R::P64 + 24];
           _sk3m::I64 = I64[_sk4R::P64 + 32];
           _sk3x::I64 = I64[_sk4R::P64 + 40];
           I64[Hp - 64] = sat_sk4P_info;
           P64[Hp - 48] = _sk33::P64;
           P64[Hp - 40] = _sk49::P64;
           I64[Hp - 32] = _sk3m::I64;
           I64[Hp - 24] = _sk3x::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl14_rjVg_closure+1;
           P64[Hp] = Hp - 64;
           R3 = Hp - 14;
           R2 = lvl17_rjVj_closure;
           Sp = Sp - 16;
           call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sk4T_entry() //  [R1]
         { info_tbl: [(ckUN,
                       label: block_ckUN_info
                       rep:StackRep [False, True, True, False]),
                      (ckWY,
                       label: sat_sk4T_info
                       rep:HeapRep 3 ptrs 2 nonptrs { Thunk }),
                      (ckX0,
                       label: block_ckX0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckWY:
           _sk4T::P64 = R1;
           if ((Sp + -56) < SpLim) goto ckX1; else goto ckX2;
       ckX2:
           if (HpLim == 0) goto ckX1; else goto ckX3;
       ckX1:
           R1 = _sk4T::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckX3:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sk4T::P64;
           I64[Sp - 56] = ckUN;
           R1 = P64[_sk4T::P64 + 24];
           P64[Sp - 48] = P64[_sk4T::P64 + 16];
           I64[Sp - 40] = I64[_sk4T::P64 + 40];
           I64[Sp - 32] = I64[_sk4T::P64 + 48];
           P64[Sp - 24] = P64[_sk4T::P64 + 32];
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto ckUN; else goto ckUO;
       ckUO:
           call (I64[R1])(R1) returns to ckUN, args: 8, res: 8, upd: 24;
       ckUN:
           Hp = Hp + 72;
           if (Hp > HpLim) goto ckX6; else goto ckX5;
       ckX6:
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to ckUN, args: 8, res: 8, upd: 24;
       ckX5:
           _sk4e::F64 = F64[R1 + 7];
           I64[Hp - 64] = sat_sk4R_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = P64[Sp + 32];
           I64[Hp - 32] = I64[Sp + 16];
           I64[Hp - 24] = I64[Sp + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl14_rjVg_closure+1;
           P64[Hp] = Hp - 64;
           I64[Sp + 24] = ckX0;
           D1 = _sk4e::F64;
           R3 = GHC.Show.shows18_closure;
           R2 = GHC.Float.$fShowDouble_$sshowFloat_closure+1;
           I64[Sp + 8] = stg_ap_p_info;
           P64[Sp + 16] = GHC.Types.[]_closure+1;
           P64[Sp + 32] = Hp - 14;
           Sp = Sp + 8;
           call GHC.Float.$w$sshowSignedFloat_info(D1,
                                                   R3,
                                                   R2) returns to ckX0, args: 24, res: 8, upd: 24;
       ckX0:
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sk4V_entry() //  [R1]
         { info_tbl: [(ckXc,
                       label: sat_sk4V_info
                       rep:HeapRep 3 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckXc:
           _sk4V::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckXd; else goto ckXe;
       ckXe:
           Hp = Hp + 80;
           if (Hp > HpLim) goto ckXg; else goto ckXf;
       ckXg:
           HpAlloc = 80;
           goto ckXd;
       ckXd:
           R1 = _sk4V::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckXf:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sk4V::P64;
           _sk33::P64 = P64[_sk4V::P64 + 16];
           _sk46::P64 = P64[_sk4V::P64 + 24];
           _sk49::P64 = P64[_sk4V::P64 + 32];
           _sk3m::I64 = I64[_sk4V::P64 + 40];
           _sk3x::I64 = I64[_sk4V::P64 + 48];
           I64[Hp - 72] = sat_sk4T_info;
           P64[Hp - 56] = _sk33::P64;
           P64[Hp - 48] = _sk46::P64;
           P64[Hp - 40] = _sk49::P64;
           I64[Hp - 32] = _sk3m::I64;
           I64[Hp - 24] = _sk3x::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl14_rjVg_closure+1;
           P64[Hp] = Hp - 72;
           R3 = Hp - 14;
           R2 = lvl16_rjVi_closure;
           Sp = Sp - 16;
           call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sk4X_entry() //  [R1]
         { info_tbl: [(ckUA,
                       label: block_ckUA_info
                       rep:StackRep [False, True, True, False, False]),
                      (ckXh,
                       label: sat_sk4X_info
                       rep:HeapRep 4 ptrs 2 nonptrs { Thunk }),
                      (ckXj,
                       label: block_ckXj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckXh:
           _sk4X::P64 = R1;
           if ((Sp + -64) < SpLim) goto ckXk; else goto ckXl;
       ckXl:
           if (HpLim == 0) goto ckXk; else goto ckXm;
       ckXk:
           R1 = _sk4X::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckXm:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sk4X::P64;
           I64[Sp - 64] = ckUA;
           R1 = P64[_sk4X::P64 + 24];
           P64[Sp - 56] = P64[_sk4X::P64 + 16];
           I64[Sp - 48] = I64[_sk4X::P64 + 48];
           I64[Sp - 40] = I64[_sk4X::P64 + 56];
           P64[Sp - 32] = P64[_sk4X::P64 + 32];
           P64[Sp - 24] = P64[_sk4X::P64 + 40];
           Sp = Sp - 64;
           if (R1 & 7 != 0) goto ckUA; else goto ckUB;
       ckUB:
           call (I64[R1])(R1) returns to ckUA, args: 8, res: 8, upd: 24;
       ckUA:
           Hp = Hp + 80;
           if (Hp > HpLim) goto ckXp; else goto ckXo;
       ckXp:
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to ckUA, args: 8, res: 8, upd: 24;
       ckXo:
           _sk4b::F64 = F64[R1 + 7];
           I64[Hp - 72] = sat_sk4V_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = P64[Sp + 32];
           P64[Hp - 40] = P64[Sp + 40];
           I64[Hp - 32] = I64[Sp + 16];
           I64[Hp - 24] = I64[Sp + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl14_rjVg_closure+1;
           P64[Hp] = Hp - 72;
           I64[Sp + 32] = ckXj;
           D1 = _sk4b::F64;
           R3 = GHC.Show.shows18_closure;
           R2 = GHC.Float.$fShowDouble_$sshowFloat_closure+1;
           I64[Sp + 16] = stg_ap_p_info;
           P64[Sp + 24] = GHC.Types.[]_closure+1;
           P64[Sp + 40] = Hp - 14;
           Sp = Sp + 16;
           call GHC.Float.$w$sshowSignedFloat_info(D1,
                                                   R3,
                                                   R2) returns to ckXj, args: 24, res: 8, upd: 24;
       ckXj:
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sk4Z_entry() //  [R1]
         { info_tbl: [(ckXv,
                       label: sat_sk4Z_info
                       rep:HeapRep 4 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckXv:
           _sk4Z::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckXw; else goto ckXx;
       ckXx:
           Hp = Hp + 88;
           if (Hp > HpLim) goto ckXz; else goto ckXy;
       ckXz:
           HpAlloc = 88;
           goto ckXw;
       ckXw:
           R1 = _sk4Z::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckXy:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sk4Z::P64;
           _sk33::P64 = P64[_sk4Z::P64 + 16];
           _sk45::P64 = P64[_sk4Z::P64 + 24];
           _sk46::P64 = P64[_sk4Z::P64 + 32];
           _sk49::P64 = P64[_sk4Z::P64 + 40];
           _sk3m::I64 = I64[_sk4Z::P64 + 48];
           _sk3x::I64 = I64[_sk4Z::P64 + 56];
           I64[Hp - 80] = sat_sk4X_info;
           P64[Hp - 64] = _sk33::P64;
           P64[Hp - 56] = _sk45::P64;
           P64[Hp - 48] = _sk46::P64;
           P64[Hp - 40] = _sk49::P64;
           I64[Hp - 32] = _sk3m::I64;
           I64[Hp - 24] = _sk3x::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl14_rjVg_closure+1;
           P64[Hp] = Hp - 80;
           R3 = Hp - 14;
           R2 = lvl15_rjVh_closure;
           Sp = Sp - 16;
           call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sk51_entry() //  [R1]
         { info_tbl: [(ckY0,
                       label: sat_sk51_info
                       rep:HeapRep 4 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckY0:
           Hp = Hp + 88;
           if (Hp > HpLim) goto ckY4; else goto ckY3;
       ckY4:
           HpAlloc = 88;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckY3:
           _sk33::P64 = P64[R1 + 16];
           _sk45::P64 = P64[R1 + 24];
           _sk46::P64 = P64[R1 + 32];
           _sk49::P64 = P64[R1 + 40];
           _sk3m::I64 = I64[R1 + 48];
           _sk3x::I64 = I64[R1 + 56];
           I64[Hp - 80] = sat_sk4Z_info;
           P64[Hp - 64] = _sk33::P64;
           P64[Hp - 56] = _sk45::P64;
           P64[Hp - 48] = _sk46::P64;
           P64[Hp - 40] = _sk49::P64;
           I64[Hp - 32] = _sk3m::I64;
           I64[Hp - 24] = _sk3x::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl14_rjVg_closure+1;
           P64[Hp] = Hp - 80;
           R3 = Hp - 14;
           R2 = lvl13_rjVf_closure;
           call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sk5v_entry() //  [R3, R2, R1]
         { info_tbl: [(ckYj,
                       label: block_ckYj_info
                       rep:StackRep [True, True, False, False]),
                      (ckYm,
                       label: sat_sk5v_info
                       rep:HeapRep 1 ptrs 2 nonptrs {
                             Fun {arity: 3 fun_type: ArgSpec 15} }),
                      (ckYp,
                       label: block_ckYp_info
                       rep:StackRep [True, True, False, False]),
                      (ckYu,
                       label: block_ckYu_info
                       rep:StackRep [True, True, False, False]),
                      (ckYz,
                       label: block_ckYz_info
                       rep:StackRep [False, False, True, True, False, False]),
                      (ckYE,
                       label: block_ckYE_info
                       rep:StackRep [True, False, False, False, False, True, True, False,
                                     False]),
                      (ckYJ,
                       label: block_ckYJ_info
                       rep:StackRep [True, False, True, False, False, True, True, False,
                                     False]),
                      (ckYO,
                       label: block_ckYO_info
                       rep:StackRep [True, False, True, False, True, True, True, False,
                                     False]),
                      (ckYT,
                       label: block_ckYT_info
                       rep:StackRep [True, False, True, False, True, True, True, False,
                                     False])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckYm:
           _sk56::P64 = R3;
           _sk55::P64 = R2;
           _sk5v::P64 = R1;
           if ((Sp + -80) < SpLim) goto ckYU; else goto ckYV;
       ckYV:
           if (HpLim == 0) goto ckYU; else goto ckYW;
       ckYU:
           R3 = _sk56::P64;
           R2 = _sk55::P64;
           R1 = _sk5v::P64;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ckYW:
           I64[Sp - 40] = ckYj;
           R1 = _sk55::P64;
           F64[Sp - 32] = F64[_sk5v::P64 + 13];
           I64[Sp - 24] = I64[_sk5v::P64 + 21];
           P64[Sp - 16] = P64[_sk5v::P64 + 5];
           P64[Sp - 8] = _sk56::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ckYj; else goto ckYk;
       ckYk:
           call (I64[R1])(R1) returns to ckYj, args: 8, res: 8, upd: 8;
       ckYj:
           I64[Sp] = ckYp;
           _sk59::P64 = P64[R1 + 7];
           R1 = P64[Sp + 32];
           P64[Sp + 32] = _sk59::P64;
           if (R1 & 7 != 0) goto ckYp; else goto ckYq;
       ckYq:
           call (I64[R1])(R1) returns to ckYp, args: 8, res: 8, upd: 8;
       ckYp:
           I64[Sp] = ckYu;
           _sk5b::P64 = P64[R1 + 7];
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _sk5b::P64;
           if (R1 & 7 != 0) goto ckYu; else goto ckYv;
       ckYv:
           call (I64[R1])(R1) returns to ckYu, args: 8, res: 8, upd: 8;
       ckYu:
           I64[Sp - 16] = ckYz;
           _sk5e::P64 = P64[R1 + 15];
           _sk5f::P64 = P64[R1 + 23];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _sk5f::P64;
           P64[Sp] = _sk5e::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ckYz; else goto ckYA;
       ckYA:
           call (I64[R1])(R1) returns to ckYz, args: 8, res: 8, upd: 8;
       ckYz:
           I64[Sp - 24] = ckYE;
           _sk5i::P64 = P64[R1 + 15];
           _sk5k::P64 = P64[R1 + 23];
           _sk5j::I64 = I64[R1 + 31];
           R1 = P64[R1 + 7];
           I64[Sp - 16] = _sk5j::I64;
           P64[Sp - 8] = _sk5k::P64;
           P64[Sp] = _sk5i::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ckYE; else goto ckYF;
       ckYF:
           call (I64[R1])(R1) returns to ckYE, args: 8, res: 8, upd: 8;
       ckYE:
           I64[Sp] = ckYJ;
           _sk5m::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _sk5m::I64;
           if (R1 & 7 != 0) goto ckYJ; else goto ckYK;
       ckYK:
           call (I64[R1])(R1) returns to ckYJ, args: 8, res: 8, upd: 8;
       ckYJ:
           I64[Sp] = ckYO;
           _sk5o::I64 = I64[R1 + 7];
           R1 = P64[Sp + 40];
           I64[Sp + 40] = _sk5o::I64;
           if (R1 & 7 != 0) goto ckYO; else goto ckYP;
       ckYP:
           call (I64[R1])(R1) returns to ckYO, args: 8, res: 8, upd: 8;
       ckYO:
           I64[Sp] = ckYT;
           _sk5q::P64 = P64[R1 + 7];
           R1 = P64[Sp + 32];
           P64[Sp + 32] = _sk5q::P64;
           call stg_ap_0_fast(R1) returns to ckYT, args: 8, res: 8, upd: 8;
       ckYT:
           R6 = I64[Sp + 8];
           R5 = I64[Sp + 40];
           R4 = I64[Sp + 24];
           R3 = P64[Sp + 64];
           R2 = P64[Sp + 72];
           P64[Sp + 24] = P64[Sp + 16];
           I64[Sp + 40] = I64[R1 + 15];
           _sk3v::F64 = F64[Sp + 48];
           I64[Sp + 48] = I64[R1 + 23];
           _sk3x::I64 = I64[Sp + 56];
           P64[Sp + 56] = P64[R1 + 7];
           I64[Sp + 64] = _sk3x::I64;
           F64[Sp + 72] = _sk3v::F64;
           Sp = Sp + 24;
           call Main.$wa1_info(R6, R5, R4, R3, R2) args: 64, res: 0, upd: 8;
     }
 },
 sat_sk5w_entry() //  [R1]
         { info_tbl: [(ckZf,
                       label: sat_sk5w_info
                       rep:HeapRep 3 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckZf:
           _sk5w::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckZg; else goto ckZh;
       ckZh:
           Hp = Hp + 32;
           if (Hp > HpLim) goto ckZj; else goto ckZi;
       ckZj:
           HpAlloc = 32;
           goto ckZg;
       ckZg:
           R1 = _sk5w::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckZi:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sk5w::P64;
           _sk3A::P64 = P64[_sk5w::P64 + 16];
           _sk3D::P64 = P64[_sk5w::P64 + 24];
           _sk41::P64 = P64[_sk5w::P64 + 32];
           _sk3v::F64 = F64[_sk5w::P64 + 40];
           _sk3x::I64 = I64[_sk5w::P64 + 48];
           I64[Hp - 24] = sat_sk5v_info;
           P64[Hp - 16] = _sk3D::P64;
           F64[Hp - 8] = _sk3v::F64;
           I64[Hp] = _sk3x::I64;
           R4 = _sk3A::P64;
           R3 = _sk41::P64;
           R2 = Hp - 21;
           Sp = Sp - 16;
           call GHC.List.zipWith_info(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sk5M_entry() //  [R3, R2, R1]
         { info_tbl: [(ckZv,
                       label: block_ckZv_info
                       rep:StackRep [True, True, False]),
                      (ckZy,
                       label: sat_sk5M_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 3 fun_type: ArgSpec 15} }),
                      (ckZB,
                       label: block_ckZB_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckZy:
           _sk5G::P64 = R3;
           _sk5F::P64 = R2;
           _sk5M::P64 = R1;
           if ((Sp + -32) < SpLim) goto ckZC; else goto ckZD;
       ckZD:
           if (HpLim == 0) goto ckZC; else goto ckZE;
       ckZC:
           R3 = _sk5G::P64;
           R2 = _sk5F::P64;
           R1 = _sk5M::P64;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ckZE:
           I64[Sp - 32] = ckZv;
           R1 = _sk5F::P64;
           F64[Sp - 24] = F64[_sk5M::P64 + 5];
           I64[Sp - 16] = I64[_sk5M::P64 + 13];
           P64[Sp - 8] = _sk5G::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ckZv; else goto ckZw;
       ckZw:
           call (I64[R1])(R1) returns to ckZv, args: 8, res: 8, upd: 8;
       ckZv:
           I64[Sp] = ckZB;
           _sk5J::P64 = P64[R1 + 7];
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _sk5J::P64;
           if (R1 & 7 != 0) goto ckZB; else goto ckZG;
       ckZG:
           call (I64[R1])(R1) returns to ckZB, args: 8, res: 8, upd: 8;
       ckZB:
           D1 = F64[Sp + 8];
           R4 = I64[Sp + 16];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 24];
           Sp = Sp + 32;
           call Main.$wa_info(D1, R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sk5N_entry() //  [R1]
         { info_tbl: [(ckZV,
                       label: sat_sk5N_info
                       rep:HeapRep 2 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckZV:
           _sk5N::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckZW; else goto ckZX;
       ckZX:
           Hp = Hp + 24;
           if (Hp > HpLim) goto ckZZ; else goto ckZY;
       ckZZ:
           HpAlloc = 24;
           goto ckZW;
       ckZW:
           R1 = _sk5N::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckZY:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sk5N::P64;
           _sk3A::P64 = P64[_sk5N::P64 + 16];
           _sk41::P64 = P64[_sk5N::P64 + 24];
           _sk3v::F64 = F64[_sk5N::P64 + 32];
           _sk3x::I64 = I64[_sk5N::P64 + 40];
           I64[Hp - 16] = sat_sk5M_info;
           F64[Hp - 8] = _sk3v::F64;
           I64[Hp] = _sk3x::I64;
           R4 = _sk3A::P64;
           R3 = _sk41::P64;
           R2 = Hp - 13;
           Sp = Sp - 16;
           call GHC.List.zipWith_info(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sk6c_entry() //  [R1]
         { info_tbl: [(cl0g,
                       label: sat_sk6c_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cl0g:
           _sk6c::P64 = R1;
           if ((Sp + -16) < SpLim) goto cl0h; else goto cl0i;
       cl0i:
           if (HpLim == 0) goto cl0h; else goto cl0o;
       cl0h:
           R1 = _sk6c::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cl0o:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sk6c::P64;
           _sk66::I64 = I64[_sk6c::P64 + 32];
           if (_sk66::I64 == I64[_sk6c::P64 + 24]) goto cl0n; else goto cl0m;
       cl0n:
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (P64[Sp])(R1) args: 24, res: 0, upd: 24;
       cl0m:
           R2 = _sk66::I64 + 1;
           R1 = P64[_sk6c::P64 + 16];
           Sp = Sp - 16;
           call go_sk65_info(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 go_sk65_entry() //  [R2, R1]
         { info_tbl: [(cl0t,
                       label: go_sk65_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cl0t:
           Hp = Hp + 80;
           if (Hp > HpLim) goto cl0A; else goto cl0z;
       cl0A:
           HpAlloc = 80;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cl0z:
           _sk3m::I64 = I64[R1 + 7];
           I64[Hp - 72] = sat_sk6c_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = _sk3m::I64;
           I64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Word.W64#_con_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section "relreadonly" {
     ul2s_srtd:
         const Sk8q_srt+176;
         const 40;
         const 1099510588489;
 },
 section "relreadonly" {
     ul2t_srtd:
         const Sk8q_srt+176;
         const 40;
         const 1030791111753;
 },
 section "relreadonly" {
     ul2u_srtd:
         const Sk8q_srt+176;
         const 38;
         const 171796603977;
 },
 section "relreadonly" {
     ul2v_srtd:
         const Sk8q_srt+176;
         const 35;
         const 34357650505;
 },
 section "relreadonly" {
     ul2w_srtd:
         const Sk8q_srt+176;
         const 35;
         const 34357650505;
 },
 section "relreadonly" {
     ul2x_srtd:
         const Sk8q_srt+176;
         const 35;
         const 34357650505;
 },
 section "relreadonly" {
     ul2y_srtd:
         const Sk8q_srt+176;
         const 35;
         const 34357650505;
 },
 section "relreadonly" {
     ul2z_srtd:
         const Sk8q_srt+176;
         const 35;
         const 34357650505;
 },
 section "relreadonly" {
     ul2A_srtd:
         const Sk8q_srt+176;
         const 35;
         const 34357650505;
 },
 section "relreadonly" {
     ul2B_srtd:
         const Sk8q_srt+176;
         const 35;
         const 34357650505;
 },
 section "relreadonly" {
     ul2C_srtd:
         const Sk8q_srt+176;
         const 42;
         const 4398045471817;
 },
 section "relreadonly" {
     ul2D_srtd:
         const Sk8q_srt+176;
         const 35;
         const 34357650505;
 },
 Main.main1_entry() //  []
         { info_tbl: [(ckRA,
                       label: block_ckRA_info
                       rep:StackRep []),
                      (ckRC,
                       label: block_ckRC_info
                       rep:StackRep [False]),
                      (ckRN,
                       label: block_ckRN_info
                       rep:StackRep [False]),
                      (ckRR,
                       label: block_ckRR_info
                       rep:StackRep [False]),
                      (ckRT,
                       label: block_ckRT_info
                       rep:StackRep [False]),
                      (ckRY,
                       label: block_ckRY_info
                       rep:StackRep [False, False, False, False, False, False]),
                      (ckSb,
                       label: block_ckSb_info
                       rep:StackRep [True, False, False, False, False, False, False]),
                      (ckSd,
                       label: block_ckSd_info
                       rep:StackRep [True, False, False, False, True, False, False]),
                      (ckSi,
                       label: block_ckSi_info
                       rep:StackRep [True, False, False, True, True, False, False]),
                      (ckSn,
                       label: block_ckSn_info
                       rep:StackRep [True, False, False, True, True, True, False]),
                      (ckSu,
                       label: block_ckSu_info
                       rep:StackRep [True, False, False, True, True, True, False]),
                      (ckSx,
                       label: block_ckSx_info
                       rep:StackRep [False, True, False, False, True, True, True, False]),
                      (ckU1,
                       label: block_ckU1_info
                       rep:StackRep [False, False, False, True, False, False, True, True,
                                     True, False]),
                      (ckU5,
                       label: block_ckU5_info
                       rep:StackRep [False, True, False, True, False, False, True, True,
                                     True, False]),
                      (ckU9,
                       label: block_ckU9_info
                       rep:StackRep [False, True, False, True, False, False, True, True,
                                     True, False]),
                      (ckUc,
                       label: block_ckUc_info
                       rep:StackRep [False, True, False, True, False, False, True, True,
                                     True, False]),
                      (ckUj,
                       label: block_ckUj_info
                       rep:StackRep [True, False, True, True, True, True, False]),
                      (ckUm,
                       label: block_ckUm_info
                       rep:StackRep [True, True, True, True, False, False, False]),
                      (ckY5,
                       label: block_ckY5_info
                       rep:StackRep [False, True, False, True, False, True, True, True,
                                     True, False]),
                      (cl0B,
                       label: Main.main1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} }),
                      (cl1e,
                       label: block_cl1e_info
                       rep:StackRep [True, False, True, True, True, True, False]),
                      (cl1g,
                       label: block_cl1g_info
                       rep:StackRep [True, False, True, True, True, True, False]),
                      (cl1w,
                       label: block_cl1w_info
                       rep:StackRep [True, False, True, True, True, True, False]),
                      (cl1y,
                       label: block_cl1y_info
                       rep:StackRep [True, False, True, True, True, True, False]),
                      (cl1S,
                       label: block_cl1S_info
                       rep:StackRep [False, True, False, True, False, False, True, True,
                                     True, False]),
                      (cl1Y,
                       label: block_cl1Y_info
                       rep:StackRep [False, True, False, True, False, False, True, True,
                                     True, False]),
                      (cl23,
                       label: block_cl23_info
                       rep:StackRep [False, True, False, True, False, False, True, True,
                                     True, False]),
                      (cl27,
                       label: block_cl27_info
                       rep:StackRep [True, False, False, True, True, True, False]),
                      (cl2d,
                       label: block_cl2d_info
                       rep:StackRep [True, False, False, True, True, True, False])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cl0B:
           if ((Sp + -88) < SpLim) goto cl0C; else goto cl0D;
       cl0D:
           if (HpLim == 0) goto cl0C; else goto cl0E;
       cl0C:
           R1 = Main.main1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cl0E:
           I64[Sp - 8] = ckRA;
           Sp = Sp - 8;
           call System.Environment.getProgName1_info() returns to ckRA, args: 8, res: 8, upd: 8;
       ckRA:
           I64[Sp - 8] = ckRC;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call System.Environment.getArgs1_info() returns to ckRC, args: 8, res: 8, upd: 8;
       ckRC:
           Hp = Hp + 88;
           if (Hp > HpLim) goto cl0I; else goto cl0H;
       cl0I:
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to ckRC, args: 8, res: 8, upd: 8;
       cl0H:
           I64[Hp - 80] = sat_sk37_info;
           P64[Hp - 64] = P64[Sp + 8];
           I64[Hp - 56] = Options.Applicative.Types.ParserInfo_con_info;
           P64[Hp - 48] = lvl20_rjVp_closure+3;
           P64[Hp - 40] = GHC.Types.True_closure+2;
           P64[Hp - 32] = lvl22_rjVr_closure;
           P64[Hp - 24] = Hp - 80;
           P64[Hp - 16] = GHC.Base.Nothing_closure+1;
           P64[Hp - 8] = Options.Applicative.Builder.info1_closure;
           P64[Hp] = GHC.Types.True_closure+2;
           I64[Sp] = ckRN;
           R4 = R1;
           R3 = Hp - 55;
           R2 = Options.Applicative.Builder.prefs1_closure;
           call Options.Applicative.Extra.execParserPure_info(R4,
                                                              R3,
                                                              R2) returns to ckRN, args: 8, res: 8, upd: 8;
       ckRN:
           I64[Sp] = ckRR;
           R2 = R1;
           call Options.Applicative.Extra.customExecParser2_info(R2) returns to ckRR, args: 8, res: 8, upd: 8;
       ckRR:
           I64[Sp] = ckRT;
           R1 = R1;
           if (R1 & 7 != 0) goto ckRT; else goto ckRU;
       ckRU:
           call (I64[R1])(R1) returns to ckRT, args: 8, res: 8, upd: 8;
       ckRT:
           I64[Sp - 40] = ckRY;
           _sk3e::P64 = P64[R1 + 7];
           _sk3g::P64 = P64[R1 + 23];
           _sk3h::P64 = P64[R1 + 31];
           _sk3j::P64 = P64[R1 + 47];
           _sk3k::P64 = P64[R1 + 55];
           R1 = P64[R1 + 15];
           P64[Sp - 32] = _sk3g::P64;
           P64[Sp - 24] = _sk3h::P64;
           P64[Sp - 16] = _sk3j::P64;
           P64[Sp - 8] = _sk3k::P64;
           P64[Sp] = _sk3e::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ckRY; else goto ckRZ;
       ckRZ:
           call (I64[R1])(R1) returns to ckRY, args: 8, res: 8, upd: 8;
       ckRY:
           I64[Sp - 8] = ckSb;
           _sk3m::I64 = I64[R1 + 7];
           I64[Sp] = _sk3m::I64;
           Sp = Sp - 8;
           _ul2n::P64 = CurrentTSO;
           I64[I64[_ul2n::P64 + 24] + 16] = Sp;
           _ul2o::I64 = CurrentNursery;
           P64[_ul2o::I64 + 8] = Hp + 8;
           I64[_ul2n::P64 + 112] = I64[_ul2n::P64 + 112] - ((Hp + 8) - I64[_ul2o::I64]);
           (_ul2k::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           call "ccall" arg hints:  []  result hints:  [] setNumCapabilities(%MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_sk3m::I64)));
           (_ul2l::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_ul2k::I64);
           BaseReg = _ul2l::I64;
           _ul2n::P64 = CurrentTSO;
           _ul2m::P64 = I64[_ul2n::P64 + 24];
           Sp = I64[_ul2m::P64 + 16];
           SpLim = _ul2m::P64 + 192;
           HpAlloc = 0;
           _ul2o::I64 = CurrentNursery;
           _ul2p::I64 = I64[_ul2o::I64 + 8];
           Hp = _ul2p::I64 - 8;
           _ul2q::I64 = I64[_ul2o::I64];
           HpLim = _ul2q::I64 + ((%MO_SS_Conv_W32_W64(I32[_ul2o::I64 + 48]) << 12) - 1);
           I64[_ul2n::P64 + 112] = I64[_ul2n::P64 + 112] + (_ul2p::I64 - _ul2q::I64);
           call (I64[Sp])() returns to ckSb, args: 8, res: 8, upd: 8;
       ckSb:
           I64[Sp] = ckSd;
           R1 = P64[Sp + 40];
           if (R1 & 7 != 0) goto ckSd; else goto ckSe;
       ckSe:
           call (I64[R1])(R1) returns to ckSd, args: 8, res: 8, upd: 8;
       ckSd:
           I64[Sp] = ckSi;
           _sk3t::I64 = I64[R1 + 7];
           R1 = P64[Sp + 32];
           I64[Sp + 40] = _sk3t::I64;
           if (R1 & 7 != 0) goto ckSi; else goto ckSj;
       ckSj:
           call (I64[R1])(R1) returns to ckSi, args: 8, res: 8, upd: 8;
       ckSi:
           I64[Sp] = ckSn;
           _sk3v::F64 = F64[R1 + 7];
           R1 = P64[Sp + 48];
           F64[Sp + 48] = _sk3v::F64;
           if (R1 & 7 != 0) goto ckSn; else goto ckSo;
       ckSo:
           call (I64[R1])(R1) returns to ckSn, args: 8, res: 8, upd: 8;
       ckSn:
           Hp = Hp + 16;
           if (Hp > HpLim) goto cl0S; else goto cl0R;
       cl0S:
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to ckSn, args: 8, res: 8, upd: 8;
       cl0R:
           _sk3m::I64 = I64[Sp + 8];
           _sk3x::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(1, _sk3m::I64)) goto cl2h; else goto cl29;
       cl2h:
           Hp = Hp - 16;
           _sk3A::P64 = GHC.Types.[]_closure+1;
           goto ckSv;
       cl29:
           I64[Hp - 8] = go_sk65_info;
           I64[Hp] = _sk3m::I64;
           I64[Sp] = cl27;
           R2 = 1;
           R1 = Hp - 7;
           I64[Sp + 32] = _sk3x::I64;
           call go_sk65_info(R2, R1) returns to cl27, args: 8, res: 8, upd: 8;
       cl27:
           I64[Sp] = cl2d;
           R2 = R1;
           call Main.initGens2_info(R2) returns to cl2d, args: 8, res: 8, upd: 8;
       cl2d:
           _sk3x::I64 = I64[Sp + 32];
           _sk3A::P64 = R1;
           goto ckSv;
       ckSv:
           if (HpLim == 0) goto cl0T; else goto cl0U;
       cl0T:
           I64[Sp] = ckSu;
           R1 = _sk3A::P64;
           I64[Sp + 32] = _sk3x::I64;
           call stg_gc_unpt_r1(R1) returns to ckSu, args: 8, res: 8, upd: 8;
       ckSu:
           _sk3x::I64 = I64[Sp + 32];
           _sk3A::P64 = R1;
           goto ckSv;
       cl0U:
           I64[Sp - 8] = ckSx;
           R1 = SkipList.newSL2_closure+1;
           P64[Sp] = _sk3A::P64;
           I64[Sp + 32] = _sk3x::I64;
           Sp = Sp - 8;
           call stg_norec_atomically#(R1) returns to ckSx, args: 8, res: 8, upd: 8;
       ckSx:
           Hp = Hp + 16;
           if (Hp > HpLim) goto cl0X; else goto cl0W;
       cl0X:
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to ckSx, args: 8, res: 8, upd: 8;
       cl0W:
           I64[Hp - 8] = a7_sk3E_info;
           P64[Hp] = R1;
           I64[Sp - 16] = ckU1;
           R4 = I64[Sp + 40];
           R3 = 2;
           R2 = 0;
           P64[Sp - 8] = R1;
           P64[Sp] = Hp - 6;
           Sp = Sp - 16;
           call GHC.Enum.$w$cenumFromThenTo_info(R4,
                                                 R3,
                                                 R2) returns to ckU1, args: 8, res: 8, upd: 8;
       ckU1:
           I64[Sp] = ckU5;
           R2 = R1;
           R1 = P64[Sp + 16];
           call a7_sk3E_info(R2, R1) returns to ckU5, args: 8, res: 8, upd: 8;
       ckU5:
           _sk3m::I64 = I64[Sp + 32];
           if (%MO_S_Lt_W64(0, _sk3m::I64)) goto cl1Z; else goto cl1U;
       cl1Z:
           I64[Sp] = cl1Y;
           R2 = _sk3m::I64;
           call $wxs_rjVo_info(R2) returns to cl1Y, args: 8, res: 8, upd: 8;
       cl1Y:
           I64[Sp] = cl23;
           R2 = R1;
           call Control.Monad.replicateM4_info(R2) returns to cl23, args: 8, res: 8, upd: 8;
       cl23:
           _sk3g::P64 = P64[Sp + 40];
           _sk41::P64 = R1;
           goto ckUa;
       cl1U:
           I64[Sp] = cl1S;
           R2 = GHC.Types.[]_closure+1;
           call Control.Monad.replicateM4_info(R2) returns to cl1S, args: 8, res: 8, upd: 8;
       cl1S:
           _sk3g::P64 = P64[Sp + 40];
           _sk41::P64 = R1;
           goto ckUa;
       ckUa:
           if (HpLim == 0) goto cl10; else goto cl11;
       cl10:
           I64[Sp] = ckU9;
           R1 = _sk41::P64;
           call stg_gc_unpt_r1(R1) returns to ckU9, args: 8, res: 8, upd: 8;
       ckU9:
           _sk3g::P64 = P64[Sp + 40];
           _sk41::P64 = R1;
           goto ckUa;
       cl11:
           I64[Sp] = ckUc;
           R1 = _sk3g::P64;
           P64[Sp + 40] = _sk41::P64;
           if (R1 & 7 != 0) goto ckUc; else goto ckUd;
       ckUd:
           call (I64[R1])(R1) returns to ckUc, args: 8, res: 8, upd: 8;
       ckUc:
           if (R1 & 7 != 1) goto cl1M; else goto cl19;
       cl1M:
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 88;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
       cl19:
           I64[Sp] = ckY5;
           R1 = P64[Sp + 48];
           if (R1 & 7 != 0) goto ckY5; else goto ckY6;
       ckY6:
           call (I64[R1])(R1) returns to ckY5, args: 8, res: 8, upd: 8;
       ckY5:
           _sk3t::I64 = I64[Sp + 64];
           _sk3v::F64 = F64[Sp + 72];
           _sk3x::I64 = I64[Sp + 56];
           _sk3A::P64 = P64[Sp + 24];
           _sk41::P64 = P64[Sp + 40];
           if (R1 & 7 != 1) goto cl1z; else goto cl1i;
       cl1z:
           Hp = Hp + 64;
           if (Hp > HpLim) goto cl1C; else goto cl1B;
       cl1C:
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to ckY5, args: 8, res: 8, upd: 8;
       cl1B:
           I64[Hp - 56] = sat_sk5N_info;
           P64[Hp - 40] = _sk3A::P64;
           P64[Hp - 32] = _sk41::P64;
           F64[Hp - 24] = _sk3v::F64;
           I64[Hp - 16] = _sk3x::I64;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sk3t::I64 * 1000;
           I64[Sp + 24] = cl1w;
           R3 = Hp - 56;
           R2 = Hp - 7;
           Sp = Sp + 24;
           call Throughput.throughputMain1_info(R3,
                                                R2) returns to cl1w, args: 8, res: 8, upd: 8;
       cl1w:
           I64[Sp] = cl1y;
           R1 = R1;
           if (R1 & 7 != 0) goto cl1y; else goto cl1E;
       cl1E:
           call (I64[R1])(R1) returns to cl1y, args: 8, res: 8, upd: 8;
       cl1y:
           _sk41::P64 = P64[Sp + 16];
           _sk46::P64 = P64[R1 + 15];
           _sk45::P64 = P64[R1 + 7];
           goto ckUk;
       cl1i:
           Hp = Hp + 72;
           if (Hp > HpLim) goto cl1l; else goto cl1k;
       cl1l:
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to ckY5, args: 8, res: 8, upd: 8;
       cl1k:
           I64[Hp - 64] = sat_sk5w_info;
           P64[Hp - 48] = _sk3A::P64;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = _sk41::P64;
           F64[Hp - 24] = _sk3v::F64;
           I64[Hp - 16] = _sk3x::I64;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sk3t::I64 * 1000;
           I64[Sp + 24] = cl1e;
           R3 = Hp - 64;
           R2 = Hp - 7;
           Sp = Sp + 24;
           call Throughput.throughputMain1_info(R3,
                                                R2) returns to cl1e, args: 8, res: 8, upd: 8;
       cl1e:
           I64[Sp] = cl1g;
           R1 = R1;
           if (R1 & 7 != 0) goto cl1g; else goto cl1n;
       cl1n:
           call (I64[R1])(R1) returns to cl1g, args: 8, res: 8, upd: 8;
       cl1g:
           _sk41::P64 = P64[Sp + 16];
           _sk46::P64 = P64[R1 + 15];
           _sk45::P64 = P64[R1 + 7];
           goto ckUk;
       ckUk:
           if (HpLim == 0) goto cl13; else goto cl14;
       cl13:
           I64[Sp] = ckUj;
           R2 = _sk46::P64;
           R1 = _sk45::P64;
           call stg_gc_pp(R2, R1) returns to ckUj, args: 8, res: 8, upd: 8;
       ckUj:
           _sk41::P64 = P64[Sp + 16];
           _sk46::P64 = R2;
           _sk45::P64 = R1;
           goto ckUk;
       cl14:
           I64[Sp] = ckUm;
           R2 = _sk41::P64;
           P64[Sp + 40] = _sk46::P64;
           P64[Sp + 48] = _sk45::P64;
           call a5_rjVe_info(R2) returns to ckUm, args: 8, res: 8, upd: 8;
       ckUm:
           Hp = Hp + 64;
           if (Hp > HpLim) goto cl17; else goto cl16;
       cl17:
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to ckUm, args: 8, res: 8, upd: 8;
       cl16:
           I64[Hp - 56] = sat_sk51_info;
           P64[Hp - 40] = P64[Sp + 56];
           P64[Hp - 32] = P64[Sp + 48];
           P64[Hp - 24] = P64[Sp + 40];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = I64[Sp + 32];
           R4 = GHC.Types.True_closure+2;
           R3 = Hp - 56;
           R2 = GHC.IO.Handle.FD.stdout_closure;
           Sp = Sp + 64;
           call GHC.IO.Handle.Text.hPutStr2_info(R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:55.025637 UTC

[section "data" {
     Main.main1_closure:
         const Main.main1_info;
         const 0;
 },
 sat_sk37_entry() //  [R1]
         { info_tbl: [(ckRI,
                       label: sat_sk37_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckRI:
           _sk37::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckRJ; else goto ckRK;
       ckRK:
           if (HpLim == 0) goto ckRJ; else goto ckRL;
       ckRJ:
           R1 = _sk37::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckRL:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sk37::P64;
           R4 = P64[_sk37::P64 + 16];
           R3 = GHC.Base.Nothing_closure+1;
           R2 = Options.Applicative.Help.Chunk.paragraph1_closure+1;
           Sp = Sp - 16;
           call Data.OldList.wordsFB_info(R4,
                                          R3,
                                          R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sk3R_entry() //  [R1]
         { info_tbl: [(ckSP,
                       label: block_ckSP_info
                       rep:StackRep [False]),
                      (ckSS,
                       label: sat_sk3R_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} }),
                      (ckSV,
                       label: block_ckSV_info
                       rep:StackRep [False, False, False])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckSS:
           _sk3R::P64 = R1;
           if ((Sp + -32) < SpLim) goto ckSW; else goto ckSX;
       ckSX:
           if (HpLim == 0) goto ckSW; else goto ckSY;
       ckSW:
           R1 = _sk3R::P64;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       ckSY:
           I64[Sp - 16] = ckSP;
           R1 = P64[_sk3R::P64 + 7];
           P64[Sp - 8] = P64[_sk3R::P64 + 15];
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ckSP; else goto ckSQ;
       ckSQ:
           call (I64[R1])(R1) returns to ckSP, args: 8, res: 8, upd: 8;
       ckSP:
           I64[Sp - 16] = ckSV;
           _sk3M::P64 = P64[R1 + 7];
           _sk3O::P64 = P64[R1 + 23];
           R1 = P64[R1 + 15];
           P64[Sp - 8] = _sk3O::P64;
           P64[Sp] = _sk3M::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ckSV; else goto ckT0;
       ckT0:
           call (I64[R1])(R1) returns to ckSV, args: 8, res: 8, upd: 8;
       ckSV:
           R6 = P64[Sp + 24];
           R5 = P64[Sp + 8];
           R4 = P64[R1 + 7];
           R3 = P64[Sp + 16];
           R2 = GHC.Classes.$fOrdWord_closure;
           P64[Sp + 24] = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call SkipList.$wa4_info(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 16, res: 0, upd: 8;
     }
 },
 a7_sk3E_entry() //  [R2, R1]
         { info_tbl: [(ckSE,
                       label: block_ckSE_info
                       rep:StackRep [False, False]),
                      (ckTP,
                       label: a7_sk3E_info
                       rep:HeapRep 1 ptrs { Fun {arity: 2 fun_type: ArgSpec 5} }),
                      (ckTV,
                       label: block_ckTV_info
                       rep:StackRep [False, False])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckTP:
           _sk3F::P64 = R2;
           _sk3E::P64 = R1;
           if ((Sp + -24) < SpLim) goto ckTQ; else goto ckTR;
       ckTR:
           if (HpLim == 0) goto ckTQ; else goto ckTS;
       ckTQ:
           R2 = _sk3F::P64;
           R1 = _sk3E::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       ckTS:
           I64[Sp - 24] = ckSE;
           R1 = _sk3F::P64;
           P64[Sp - 16] = P64[_sk3E::P64 + 6];
           P64[Sp - 8] = _sk3E::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ckSE; else goto ckSF;
       ckSF:
           call (I64[R1])(R1) returns to ckSE, args: 8, res: 8, upd: 8;
       ckSE:
           if (R1 & 7 != 1) goto ckTN; else goto ckTM;
       ckTN:
           Hp = Hp + 24;
           if (Hp > HpLim) goto ckTY; else goto ckTX;
       ckTY:
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to ckSE, args: 8, res: 8, upd: 8;
       ckTX:
           _sk3I::P64 = P64[R1 + 6];
           _sk3J::P64 = P64[R1 + 14];
           I64[Hp - 16] = sat_sk3R_info;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = _sk3I::P64;
           I64[Sp] = ckTV;
           R1 = Hp - 15;
           P64[Sp + 8] = _sk3J::P64;
           call stg_norec_atomically#(R1) returns to ckTV, args: 8, res: 8, upd: 8;
       ckTV:
           R2 = P64[Sp + 8];
           R1 = P64[Sp + 16];
           Sp = Sp + 24;
           call a7_sk3E_info(R2, R1) args: 8, res: 0, upd: 8;
       ckTM:
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 24;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sk4r_entry() //  [R1]
         { info_tbl: [(ckVx,
                       label: block_ckVx_info
                       rep:StackRep []),
                      (ckVA,
                       label: sat_sk4r_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckVA:
           _sk4r::P64 = R1;
           if ((Sp + -24) < SpLim) goto ckVB; else goto ckVC;
       ckVC:
           if (HpLim == 0) goto ckVB; else goto ckVD;
       ckVB:
           R1 = _sk4r::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckVD:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sk4r::P64;
           I64[Sp - 24] = ckVx;
           R3 = GHC.Types.[]_closure+1;
           R2 = I64[_sk4r::P64 + 16];
           Sp = Sp - 24;
           call GHC.Show.$wshowWord_info(R3,
                                         R2) returns to ckVx, args: 8, res: 8, upd: 24;
       ckVx:
           Hp = Hp + 24;
           if (Hp > HpLim) goto ckVG; else goto ckVF;
       ckVG:
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) returns to ckVx, args: 8, res: 8, upd: 24;
       ckVF:
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = GHC.Types.[]_closure+1;
           R2 = Hp - 14;
           Sp = Sp + 8;
           call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sk4t_entry() //  [R1]
         { info_tbl: [(ckVI,
                       label: sat_sk4t_info
                       rep:HeapRep 1 nonptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckVI:
           _sk4t::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckVJ; else goto ckVK;
       ckVK:
           Hp = Hp + 48;
           if (Hp > HpLim) goto ckVM; else goto ckVL;
       ckVM:
           HpAlloc = 48;
           goto ckVJ;
       ckVJ:
           R1 = _sk4t::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckVL:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sk4t::P64;
           _sk3x::I64 = I64[_sk4t::P64 + 16];
           I64[Hp - 40] = sat_sk4r_info;
           I64[Hp - 24] = _sk3x::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl14_rjVg_closure+1;
           P64[Hp] = Hp - 40;
           R3 = Hp - 14;
           R2 = Main.rbTreeOpts94_closure;
           Sp = Sp - 16;
           call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sk4v_entry() //  [R1]
         { info_tbl: [(ckVn,
                       label: block_ckVn_info
                       rep:StackRep [True]),
                      (ckVP,
                       label: sat_sk4v_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckVP:
           _sk4v::P64 = R1;
           if ((Sp + -32) < SpLim) goto ckVQ; else goto ckVR;
       ckVR:
           if (HpLim == 0) goto ckVQ; else goto ckVS;
       ckVQ:
           R1 = _sk4v::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckVS:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sk4v::P64;
           I64[Sp - 32] = ckVn;
           R4 = GHC.Types.[]_closure+1;
           R3 = I64[_sk4v::P64 + 16];
           R2 = 0;
           I64[Sp - 24] = I64[_sk4v::P64 + 24];
           Sp = Sp - 32;
           call GHC.Show.$wshowSignedInt_info(R4,
                                              R3,
                                              R2) returns to ckVn, args: 8, res: 8, upd: 24;
       ckVn:
           Hp = Hp + 72;
           if (Hp > HpLim) goto ckVV; else goto ckVU;
       ckVV:
           HpAlloc = 72;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) returns to ckVn, args: 8, res: 8, upd: 24;
       ckVU:
           I64[Hp - 64] = sat_sk4t_info;
           I64[Hp - 48] = I64[Sp + 8];
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = lvl14_rjVg_closure+1;
           P64[Hp - 24] = Hp - 64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = Hp - 38;
           R2 = Hp - 14;
           Sp = Sp + 16;
           call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sk4x_entry() //  [R1]
         { info_tbl: [(ckVX,
                       label: sat_sk4x_info
                       rep:HeapRep 2 nonptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckVX:
           _sk4x::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckVY; else goto ckVZ;
       ckVZ:
           Hp = Hp + 56;
           if (Hp > HpLim) goto ckW1; else goto ckW0;
       ckW1:
           HpAlloc = 56;
           goto ckVY;
       ckVY:
           R1 = _sk4x::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckW0:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sk4x::P64;
           _sk3m::I64 = I64[_sk4x::P64 + 16];
           _sk3x::I64 = I64[_sk4x::P64 + 24];
           I64[Hp - 48] = sat_sk4v_info;
           I64[Hp - 32] = _sk3m::I64;
           I64[Hp - 24] = _sk3x::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl14_rjVg_closure+1;
           P64[Hp] = Hp - 48;
           R3 = Hp - 14;
           R2 = Main.rbTreeOpts79_closure;
           Sp = Sp - 16;
           call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sk4z_entry() //  [R1]
         { info_tbl: [(ckW3,
                       label: sat_sk4z_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckW3:
           _sk4z::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckW4; else goto ckW5;
       ckW5:
           Hp = Hp + 56;
           if (Hp > HpLim) goto ckW7; else goto ckW6;
       ckW7:
           HpAlloc = 56;
           goto ckW4;
       ckW4:
           R1 = _sk4z::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckW6:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sk4z::P64;
           _sk33::P64 = P64[_sk4z::P64 + 16];
           _sk3m::I64 = I64[_sk4z::P64 + 24];
           _sk3x::I64 = I64[_sk4z::P64 + 32];
           I64[Hp - 48] = sat_sk4x_info;
           I64[Hp - 32] = _sk3m::I64;
           I64[Hp - 24] = _sk3x::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl14_rjVg_closure+1;
           P64[Hp] = Hp - 48;
           R3 = Hp - 14;
           R2 = _sk33::P64;
           Sp = Sp - 16;
           call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 a8_sk4i_entry() //  [R1]
         { info_tbl: [(ckW9,
                       label: a8_sk4i_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckW9:
           _sk4i::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckWa; else goto ckWb;
       ckWb:
           Hp = Hp + 64;
           if (Hp > HpLim) goto ckWd; else goto ckWc;
       ckWd:
           HpAlloc = 64;
           goto ckWa;
       ckWa:
           R1 = _sk4i::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckWc:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sk4i::P64;
           _sk33::P64 = P64[_sk4i::P64 + 16];
           _sk3m::I64 = I64[_sk4i::P64 + 24];
           _sk3x::I64 = I64[_sk4i::P64 + 32];
           I64[Hp - 56] = sat_sk4z_info;
           P64[Hp - 40] = _sk33::P64;
           I64[Hp - 32] = _sk3m::I64;
           I64[Hp - 24] = _sk3x::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl14_rjVg_closure+1;
           P64[Hp] = Hp - 56;
           R3 = Hp - 14;
           R2 = lvl18_rjVl_closure;
           Sp = Sp - 16;
           call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sk4P_entry() //  [R1]
         { info_tbl: [(ckV0,
                       label: block_ckV0_info
                       rep:StackRep [False, True, True]),
                      (ckWe,
                       label: sat_sk4P_info
                       rep:HeapRep 2 ptrs 2 nonptrs { Thunk }),
                      (ckWq,
                       label: block_ckWq_info
                       rep:StackRep [False]),
                      (ckWu,
                       label: block_ckWu_info
                       rep:StackRep [False]),
                      (ckWF,
                       label: block_ckWF_info
                       rep:StackRep [False]),
                      (ckWJ,
                       label: block_ckWJ_info
                       rep:StackRep [False])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckWe:
           _sk4P::P64 = R1;
           if ((Sp + -48) < SpLim) goto ckWf; else goto ckWg;
       ckWg:
           if (HpLim == 0) goto ckWf; else goto ckWh;
       ckWf:
           R1 = _sk4P::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckWh:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sk4P::P64;
           I64[Sp - 48] = ckV0;
           R3 = 0;
           R2 = P64[_sk4P::P64 + 24];
           P64[Sp - 40] = P64[_sk4P::P64 + 16];
           I64[Sp - 32] = I64[_sk4P::P64 + 32];
           I64[Sp - 24] = I64[_sk4P::P64 + 40];
           Sp = Sp - 48;
           call $wgo2_rjVk_info(R3,
                                R2) returns to ckV0, args: 8, res: 8, upd: 24;
       ckV0:
           Hp = Hp + 40;
           if (Hp > HpLim) goto ckWk; else goto ckWj;
       ckWk:
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unbx_r1(R1) returns to ckV0, args: 8, res: 8, upd: 24;
       ckWj:
           I64[Hp - 32] = a8_sk4i_info;
           P64[Hp - 16] = P64[Sp + 8];
           I64[Hp - 8] = I64[Sp + 16];
           I64[Hp] = I64[Sp + 24];
           _ckV7::P64 = Hp - 32;
           if (%MO_S_Ge_W64(R1, 0)) goto ckWN; else goto ckWz;
       ckWN:
           I64[Sp + 16] = ckWF;
           R2 = R1;
           P64[Sp + 24] = _ckV7::P64;
           Sp = Sp + 16;
           call GHC.Integer.Type.smallInteger_info(R2) returns to ckWF, args: 8, res: 8, upd: 24;
       ckWF:
           I64[Sp] = ckWJ;
           R4 = GHC.Types.[]_closure+1;
           R3 = R1;
           R2 = 0;
           call GHC.Show.$w$cshowsPrec1_info(R4,
                                             R3,
                                             R2) returns to ckWJ, args: 8, res: 8, upd: 24;
       ckWJ:
           Hp = Hp + 48;
           if (Hp > HpLim) goto ckWR; else goto ckWQ;
       ckWR:
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) returns to ckWJ, args: 8, res: 8, upd: 24;
       ckWQ:
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = lvl14_rjVg_closure+1;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = Hp - 38;
           R2 = Hp - 14;
           Sp = Sp + 16;
           call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
       ckWz:
           I64[Sp + 16] = ckWq;
           R2 = R1;
           P64[Sp + 24] = _ckV7::P64;
           Sp = Sp + 16;
           call GHC.Integer.Type.wordToInteger_info(R2) returns to ckWq, args: 8, res: 8, upd: 24;
       ckWq:
           I64[Sp] = ckWu;
           R4 = GHC.Types.[]_closure+1;
           R3 = R1;
           R2 = 0;
           call GHC.Show.$w$cshowsPrec1_info(R4,
                                             R3,
                                             R2) returns to ckWu, args: 8, res: 8, upd: 24;
       ckWu:
           Hp = Hp + 48;
           if (Hp > HpLim) goto ckWD; else goto ckWC;
       ckWD:
           HpAlloc = 48;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) returns to ckWu, args: 8, res: 8, upd: 24;
       ckWC:
           I64[Hp - 40] = :_con_info;
           P64[Hp - 32] = lvl14_rjVg_closure+1;
           P64[Hp - 24] = P64[Sp + 8];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R3 = Hp - 38;
           R2 = Hp - 14;
           Sp = Sp + 16;
           call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sk4R_entry() //  [R1]
         { info_tbl: [(ckWT,
                       label: sat_sk4R_info
                       rep:HeapRep 2 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckWT:
           _sk4R::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckWU; else goto ckWV;
       ckWV:
           Hp = Hp + 72;
           if (Hp > HpLim) goto ckWX; else goto ckWW;
       ckWX:
           HpAlloc = 72;
           goto ckWU;
       ckWU:
           R1 = _sk4R::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckWW:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sk4R::P64;
           _sk33::P64 = P64[_sk4R::P64 + 16];
           _sk49::P64 = P64[_sk4R::P64 + 24];
           _sk3m::I64 = I64[_sk4R::P64 + 32];
           _sk3x::I64 = I64[_sk4R::P64 + 40];
           I64[Hp - 64] = sat_sk4P_info;
           P64[Hp - 48] = _sk33::P64;
           P64[Hp - 40] = _sk49::P64;
           I64[Hp - 32] = _sk3m::I64;
           I64[Hp - 24] = _sk3x::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl14_rjVg_closure+1;
           P64[Hp] = Hp - 64;
           R3 = Hp - 14;
           R2 = lvl17_rjVj_closure;
           Sp = Sp - 16;
           call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sk4T_entry() //  [R1]
         { info_tbl: [(ckUN,
                       label: block_ckUN_info
                       rep:StackRep [False, True, True, False]),
                      (ckWY,
                       label: sat_sk4T_info
                       rep:HeapRep 3 ptrs 2 nonptrs { Thunk }),
                      (ckX0,
                       label: block_ckX0_info
                       rep:StackRep [False])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckWY:
           _sk4T::P64 = R1;
           if ((Sp + -56) < SpLim) goto ckX1; else goto ckX2;
       ckX2:
           if (HpLim == 0) goto ckX1; else goto ckX3;
       ckX1:
           R1 = _sk4T::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckX3:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sk4T::P64;
           I64[Sp - 56] = ckUN;
           R1 = P64[_sk4T::P64 + 24];
           P64[Sp - 48] = P64[_sk4T::P64 + 16];
           I64[Sp - 40] = I64[_sk4T::P64 + 40];
           I64[Sp - 32] = I64[_sk4T::P64 + 48];
           P64[Sp - 24] = P64[_sk4T::P64 + 32];
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto ckUN; else goto ckUO;
       ckUO:
           call (I64[R1])(R1) returns to ckUN, args: 8, res: 8, upd: 24;
       ckUN:
           Hp = Hp + 72;
           if (Hp > HpLim) goto ckX6; else goto ckX5;
       ckX6:
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to ckUN, args: 8, res: 8, upd: 24;
       ckX5:
           _sk4e::F64 = F64[R1 + 7];
           I64[Hp - 64] = sat_sk4R_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = P64[Sp + 32];
           I64[Hp - 32] = I64[Sp + 16];
           I64[Hp - 24] = I64[Sp + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl14_rjVg_closure+1;
           P64[Hp] = Hp - 64;
           I64[Sp + 24] = ckX0;
           D1 = _sk4e::F64;
           R3 = GHC.Show.shows18_closure;
           R2 = GHC.Float.$fShowDouble_$sshowFloat_closure+1;
           I64[Sp + 8] = stg_ap_p_info;
           P64[Sp + 16] = GHC.Types.[]_closure+1;
           P64[Sp + 32] = Hp - 14;
           Sp = Sp + 8;
           call GHC.Float.$w$sshowSignedFloat_info(D1,
                                                   R3,
                                                   R2) returns to ckX0, args: 24, res: 8, upd: 24;
       ckX0:
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sk4V_entry() //  [R1]
         { info_tbl: [(ckXc,
                       label: sat_sk4V_info
                       rep:HeapRep 3 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckXc:
           _sk4V::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckXd; else goto ckXe;
       ckXe:
           Hp = Hp + 80;
           if (Hp > HpLim) goto ckXg; else goto ckXf;
       ckXg:
           HpAlloc = 80;
           goto ckXd;
       ckXd:
           R1 = _sk4V::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckXf:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sk4V::P64;
           _sk33::P64 = P64[_sk4V::P64 + 16];
           _sk46::P64 = P64[_sk4V::P64 + 24];
           _sk49::P64 = P64[_sk4V::P64 + 32];
           _sk3m::I64 = I64[_sk4V::P64 + 40];
           _sk3x::I64 = I64[_sk4V::P64 + 48];
           I64[Hp - 72] = sat_sk4T_info;
           P64[Hp - 56] = _sk33::P64;
           P64[Hp - 48] = _sk46::P64;
           P64[Hp - 40] = _sk49::P64;
           I64[Hp - 32] = _sk3m::I64;
           I64[Hp - 24] = _sk3x::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl14_rjVg_closure+1;
           P64[Hp] = Hp - 72;
           R3 = Hp - 14;
           R2 = lvl16_rjVi_closure;
           Sp = Sp - 16;
           call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sk4X_entry() //  [R1]
         { info_tbl: [(ckUA,
                       label: block_ckUA_info
                       rep:StackRep [False, True, True, False, False]),
                      (ckXh,
                       label: sat_sk4X_info
                       rep:HeapRep 4 ptrs 2 nonptrs { Thunk }),
                      (ckXj,
                       label: block_ckXj_info
                       rep:StackRep [False])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckXh:
           _sk4X::P64 = R1;
           if ((Sp + -64) < SpLim) goto ckXk; else goto ckXl;
       ckXl:
           if (HpLim == 0) goto ckXk; else goto ckXm;
       ckXk:
           R1 = _sk4X::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckXm:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sk4X::P64;
           I64[Sp - 64] = ckUA;
           R1 = P64[_sk4X::P64 + 24];
           P64[Sp - 56] = P64[_sk4X::P64 + 16];
           I64[Sp - 48] = I64[_sk4X::P64 + 48];
           I64[Sp - 40] = I64[_sk4X::P64 + 56];
           P64[Sp - 32] = P64[_sk4X::P64 + 32];
           P64[Sp - 24] = P64[_sk4X::P64 + 40];
           Sp = Sp - 64;
           if (R1 & 7 != 0) goto ckUA; else goto ckUB;
       ckUB:
           call (I64[R1])(R1) returns to ckUA, args: 8, res: 8, upd: 24;
       ckUA:
           Hp = Hp + 80;
           if (Hp > HpLim) goto ckXp; else goto ckXo;
       ckXp:
           HpAlloc = 80;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to ckUA, args: 8, res: 8, upd: 24;
       ckXo:
           _sk4b::F64 = F64[R1 + 7];
           I64[Hp - 72] = sat_sk4V_info;
           P64[Hp - 56] = P64[Sp + 8];
           P64[Hp - 48] = P64[Sp + 32];
           P64[Hp - 40] = P64[Sp + 40];
           I64[Hp - 32] = I64[Sp + 16];
           I64[Hp - 24] = I64[Sp + 24];
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl14_rjVg_closure+1;
           P64[Hp] = Hp - 72;
           I64[Sp + 32] = ckXj;
           D1 = _sk4b::F64;
           R3 = GHC.Show.shows18_closure;
           R2 = GHC.Float.$fShowDouble_$sshowFloat_closure+1;
           I64[Sp + 16] = stg_ap_p_info;
           P64[Sp + 24] = GHC.Types.[]_closure+1;
           P64[Sp + 40] = Hp - 14;
           Sp = Sp + 16;
           call GHC.Float.$w$sshowSignedFloat_info(D1,
                                                   R3,
                                                   R2) returns to ckXj, args: 24, res: 8, upd: 24;
       ckXj:
           R3 = P64[Sp + 8];
           R2 = R1;
           Sp = Sp + 16;
           call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sk4Z_entry() //  [R1]
         { info_tbl: [(ckXv,
                       label: sat_sk4Z_info
                       rep:HeapRep 4 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckXv:
           _sk4Z::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckXw; else goto ckXx;
       ckXx:
           Hp = Hp + 88;
           if (Hp > HpLim) goto ckXz; else goto ckXy;
       ckXz:
           HpAlloc = 88;
           goto ckXw;
       ckXw:
           R1 = _sk4Z::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckXy:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sk4Z::P64;
           _sk33::P64 = P64[_sk4Z::P64 + 16];
           _sk45::P64 = P64[_sk4Z::P64 + 24];
           _sk46::P64 = P64[_sk4Z::P64 + 32];
           _sk49::P64 = P64[_sk4Z::P64 + 40];
           _sk3m::I64 = I64[_sk4Z::P64 + 48];
           _sk3x::I64 = I64[_sk4Z::P64 + 56];
           I64[Hp - 80] = sat_sk4X_info;
           P64[Hp - 64] = _sk33::P64;
           P64[Hp - 56] = _sk45::P64;
           P64[Hp - 48] = _sk46::P64;
           P64[Hp - 40] = _sk49::P64;
           I64[Hp - 32] = _sk3m::I64;
           I64[Hp - 24] = _sk3x::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl14_rjVg_closure+1;
           P64[Hp] = Hp - 80;
           R3 = Hp - 14;
           R2 = lvl15_rjVh_closure;
           Sp = Sp - 16;
           call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sk51_entry() //  [R1]
         { info_tbl: [(ckY0,
                       label: sat_sk51_info
                       rep:HeapRep 4 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckY0:
           Hp = Hp + 88;
           if (Hp > HpLim) goto ckY4; else goto ckY3;
       ckY4:
           HpAlloc = 88;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckY3:
           _sk33::P64 = P64[R1 + 16];
           _sk45::P64 = P64[R1 + 24];
           _sk46::P64 = P64[R1 + 32];
           _sk49::P64 = P64[R1 + 40];
           _sk3m::I64 = I64[R1 + 48];
           _sk3x::I64 = I64[R1 + 56];
           I64[Hp - 80] = sat_sk4Z_info;
           P64[Hp - 64] = _sk33::P64;
           P64[Hp - 56] = _sk45::P64;
           P64[Hp - 48] = _sk46::P64;
           P64[Hp - 40] = _sk49::P64;
           I64[Hp - 32] = _sk3m::I64;
           I64[Hp - 24] = _sk3x::I64;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = lvl14_rjVg_closure+1;
           P64[Hp] = Hp - 80;
           R3 = Hp - 14;
           R2 = lvl13_rjVf_closure;
           call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sk5v_entry() //  [R3, R2, R1]
         { info_tbl: [(ckYj,
                       label: block_ckYj_info
                       rep:StackRep [True, True, False, False]),
                      (ckYm,
                       label: sat_sk5v_info
                       rep:HeapRep 1 ptrs 2 nonptrs {
                             Fun {arity: 3 fun_type: ArgSpec 15} }),
                      (ckYp,
                       label: block_ckYp_info
                       rep:StackRep [True, True, False, False]),
                      (ckYu,
                       label: block_ckYu_info
                       rep:StackRep [True, True, False, False]),
                      (ckYz,
                       label: block_ckYz_info
                       rep:StackRep [False, False, True, True, False, False]),
                      (ckYE,
                       label: block_ckYE_info
                       rep:StackRep [True, False, False, False, False, True, True, False,
                                     False]),
                      (ckYJ,
                       label: block_ckYJ_info
                       rep:StackRep [True, False, True, False, False, True, True, False,
                                     False]),
                      (ckYO,
                       label: block_ckYO_info
                       rep:StackRep [True, False, True, False, True, True, True, False,
                                     False]),
                      (ckYT,
                       label: block_ckYT_info
                       rep:StackRep [True, False, True, False, True, True, True, False,
                                     False])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckYm:
           _sk56::P64 = R3;
           _sk55::P64 = R2;
           _sk5v::P64 = R1;
           if ((Sp + -80) < SpLim) goto ckYU; else goto ckYV;
       ckYV:
           if (HpLim == 0) goto ckYU; else goto ckYW;
       ckYU:
           R3 = _sk56::P64;
           R2 = _sk55::P64;
           R1 = _sk5v::P64;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ckYW:
           I64[Sp - 40] = ckYj;
           R1 = _sk55::P64;
           F64[Sp - 32] = F64[_sk5v::P64 + 13];
           I64[Sp - 24] = I64[_sk5v::P64 + 21];
           P64[Sp - 16] = P64[_sk5v::P64 + 5];
           P64[Sp - 8] = _sk56::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ckYj; else goto ckYk;
       ckYk:
           call (I64[R1])(R1) returns to ckYj, args: 8, res: 8, upd: 8;
       ckYj:
           I64[Sp] = ckYp;
           _sk59::P64 = P64[R1 + 7];
           R1 = P64[Sp + 32];
           P64[Sp + 32] = _sk59::P64;
           if (R1 & 7 != 0) goto ckYp; else goto ckYq;
       ckYq:
           call (I64[R1])(R1) returns to ckYp, args: 8, res: 8, upd: 8;
       ckYp:
           I64[Sp] = ckYu;
           _sk5b::P64 = P64[R1 + 7];
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _sk5b::P64;
           if (R1 & 7 != 0) goto ckYu; else goto ckYv;
       ckYv:
           call (I64[R1])(R1) returns to ckYu, args: 8, res: 8, upd: 8;
       ckYu:
           I64[Sp - 16] = ckYz;
           _sk5e::P64 = P64[R1 + 15];
           _sk5f::P64 = P64[R1 + 23];
           R1 = P64[R1 + 7];
           P64[Sp - 8] = _sk5f::P64;
           P64[Sp] = _sk5e::P64;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto ckYz; else goto ckYA;
       ckYA:
           call (I64[R1])(R1) returns to ckYz, args: 8, res: 8, upd: 8;
       ckYz:
           I64[Sp - 24] = ckYE;
           _sk5i::P64 = P64[R1 + 15];
           _sk5k::P64 = P64[R1 + 23];
           _sk5j::I64 = I64[R1 + 31];
           R1 = P64[R1 + 7];
           I64[Sp - 16] = _sk5j::I64;
           P64[Sp - 8] = _sk5k::P64;
           P64[Sp] = _sk5i::P64;
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto ckYE; else goto ckYF;
       ckYF:
           call (I64[R1])(R1) returns to ckYE, args: 8, res: 8, upd: 8;
       ckYE:
           I64[Sp] = ckYJ;
           _sk5m::I64 = I64[R1 + 7];
           R1 = P64[Sp + 24];
           I64[Sp + 24] = _sk5m::I64;
           if (R1 & 7 != 0) goto ckYJ; else goto ckYK;
       ckYK:
           call (I64[R1])(R1) returns to ckYJ, args: 8, res: 8, upd: 8;
       ckYJ:
           I64[Sp] = ckYO;
           _sk5o::I64 = I64[R1 + 7];
           R1 = P64[Sp + 40];
           I64[Sp + 40] = _sk5o::I64;
           if (R1 & 7 != 0) goto ckYO; else goto ckYP;
       ckYP:
           call (I64[R1])(R1) returns to ckYO, args: 8, res: 8, upd: 8;
       ckYO:
           I64[Sp] = ckYT;
           _sk5q::P64 = P64[R1 + 7];
           R1 = P64[Sp + 32];
           P64[Sp + 32] = _sk5q::P64;
           call stg_ap_0_fast(R1) returns to ckYT, args: 8, res: 8, upd: 8;
       ckYT:
           R6 = I64[Sp + 8];
           R5 = I64[Sp + 40];
           R4 = I64[Sp + 24];
           R3 = P64[Sp + 64];
           R2 = P64[Sp + 72];
           P64[Sp + 24] = P64[Sp + 16];
           I64[Sp + 40] = I64[R1 + 15];
           _sk3v::F64 = F64[Sp + 48];
           I64[Sp + 48] = I64[R1 + 23];
           _sk3x::I64 = I64[Sp + 56];
           P64[Sp + 56] = P64[R1 + 7];
           I64[Sp + 64] = _sk3x::I64;
           F64[Sp + 72] = _sk3v::F64;
           Sp = Sp + 24;
           call Main.$wa1_info(R6, R5, R4, R3, R2) args: 64, res: 0, upd: 8;
     }
 },
 sat_sk5w_entry() //  [R1]
         { info_tbl: [(ckZf,
                       label: sat_sk5w_info
                       rep:HeapRep 3 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckZf:
           _sk5w::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckZg; else goto ckZh;
       ckZh:
           Hp = Hp + 32;
           if (Hp > HpLim) goto ckZj; else goto ckZi;
       ckZj:
           HpAlloc = 32;
           goto ckZg;
       ckZg:
           R1 = _sk5w::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckZi:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sk5w::P64;
           _sk3A::P64 = P64[_sk5w::P64 + 16];
           _sk3D::P64 = P64[_sk5w::P64 + 24];
           _sk41::P64 = P64[_sk5w::P64 + 32];
           _sk3v::F64 = F64[_sk5w::P64 + 40];
           _sk3x::I64 = I64[_sk5w::P64 + 48];
           I64[Hp - 24] = sat_sk5v_info;
           P64[Hp - 16] = _sk3D::P64;
           F64[Hp - 8] = _sk3v::F64;
           I64[Hp] = _sk3x::I64;
           R4 = _sk3A::P64;
           R3 = _sk41::P64;
           R2 = Hp - 21;
           Sp = Sp - 16;
           call GHC.List.zipWith_info(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sk5M_entry() //  [R3, R2, R1]
         { info_tbl: [(ckZv,
                       label: block_ckZv_info
                       rep:StackRep [True, True, False]),
                      (ckZy,
                       label: sat_sk5M_info
                       rep:HeapRep 2 nonptrs { Fun {arity: 3 fun_type: ArgSpec 15} }),
                      (ckZB,
                       label: block_ckZB_info
                       rep:StackRep [True, True, False])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckZy:
           _sk5G::P64 = R3;
           _sk5F::P64 = R2;
           _sk5M::P64 = R1;
           if ((Sp + -32) < SpLim) goto ckZC; else goto ckZD;
       ckZD:
           if (HpLim == 0) goto ckZC; else goto ckZE;
       ckZC:
           R3 = _sk5G::P64;
           R2 = _sk5F::P64;
           R1 = _sk5M::P64;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       ckZE:
           I64[Sp - 32] = ckZv;
           R1 = _sk5F::P64;
           F64[Sp - 24] = F64[_sk5M::P64 + 5];
           I64[Sp - 16] = I64[_sk5M::P64 + 13];
           P64[Sp - 8] = _sk5G::P64;
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto ckZv; else goto ckZw;
       ckZw:
           call (I64[R1])(R1) returns to ckZv, args: 8, res: 8, upd: 8;
       ckZv:
           I64[Sp] = ckZB;
           _sk5J::P64 = P64[R1 + 7];
           R1 = P64[Sp + 24];
           P64[Sp + 24] = _sk5J::P64;
           if (R1 & 7 != 0) goto ckZB; else goto ckZG;
       ckZG:
           call (I64[R1])(R1) returns to ckZB, args: 8, res: 8, upd: 8;
       ckZB:
           D1 = F64[Sp + 8];
           R4 = I64[Sp + 16];
           R3 = P64[R1 + 7];
           R2 = P64[Sp + 24];
           Sp = Sp + 32;
           call Main.$wa_info(D1, R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sk5N_entry() //  [R1]
         { info_tbl: [(ckZV,
                       label: sat_sk5N_info
                       rep:HeapRep 2 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ckZV:
           _sk5N::P64 = R1;
           if ((Sp + -16) < SpLim) goto ckZW; else goto ckZX;
       ckZX:
           Hp = Hp + 24;
           if (Hp > HpLim) goto ckZZ; else goto ckZY;
       ckZZ:
           HpAlloc = 24;
           goto ckZW;
       ckZW:
           R1 = _sk5N::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       ckZY:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sk5N::P64;
           _sk3A::P64 = P64[_sk5N::P64 + 16];
           _sk41::P64 = P64[_sk5N::P64 + 24];
           _sk3v::F64 = F64[_sk5N::P64 + 32];
           _sk3x::I64 = I64[_sk5N::P64 + 40];
           I64[Hp - 16] = sat_sk5M_info;
           F64[Hp - 8] = _sk3v::F64;
           I64[Hp] = _sk3x::I64;
           R4 = _sk3A::P64;
           R3 = _sk41::P64;
           R2 = Hp - 13;
           Sp = Sp - 16;
           call GHC.List.zipWith_info(R4, R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sk6c_entry() //  [R1]
         { info_tbl: [(cl0g,
                       label: sat_sk6c_info
                       rep:HeapRep 1 ptrs 2 nonptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cl0g:
           _sk6c::P64 = R1;
           if ((Sp + -16) < SpLim) goto cl0h; else goto cl0i;
       cl0i:
           if (HpLim == 0) goto cl0h; else goto cl0o;
       cl0h:
           R1 = _sk6c::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cl0o:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sk6c::P64;
           _sk66::I64 = I64[_sk6c::P64 + 32];
           if (_sk66::I64 == I64[_sk6c::P64 + 24]) goto cl0n; else goto cl0m;
       cl0n:
           R1 = []_closure+1;
           Sp = Sp - 16;
           call (P64[Sp])(R1) args: 24, res: 0, upd: 24;
       cl0m:
           R2 = _sk66::I64 + 1;
           R1 = P64[_sk6c::P64 + 16];
           Sp = Sp - 16;
           call go_sk65_info(R2, R1) args: 24, res: 0, upd: 24;
     }
 },
 go_sk65_entry() //  [R2, R1]
         { info_tbl: [(cl0t,
                       label: go_sk65_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 4} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cl0t:
           Hp = Hp + 80;
           if (Hp > HpLim) goto cl0A; else goto cl0z;
       cl0A:
           HpAlloc = 80;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cl0z:
           _sk3m::I64 = I64[R1 + 7];
           I64[Hp - 72] = sat_sk6c_info;
           P64[Hp - 56] = R1;
           I64[Hp - 48] = _sk3m::I64;
           I64[Hp - 40] = R2;
           I64[Hp - 32] = GHC.Word.W64#_con_info;
           I64[Hp - 24] = R2;
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = Hp - 31;
           P64[Hp] = Hp - 72;
           R1 = Hp - 14;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 },
 section "relreadonly" {
     ul2s_srtd:
         const Sk8q_srt+176;
         const 40;
         const 1099510588489;
 },
 section "relreadonly" {
     ul2t_srtd:
         const Sk8q_srt+176;
         const 40;
         const 1030791111753;
 },
 section "relreadonly" {
     ul2u_srtd:
         const Sk8q_srt+176;
         const 38;
         const 171796603977;
 },
 section "relreadonly" {
     ul2v_srtd:
         const Sk8q_srt+176;
         const 35;
         const 34357650505;
 },
 section "relreadonly" {
     ul2w_srtd:
         const Sk8q_srt+176;
         const 35;
         const 34357650505;
 },
 section "relreadonly" {
     ul2x_srtd:
         const Sk8q_srt+176;
         const 35;
         const 34357650505;
 },
 section "relreadonly" {
     ul2y_srtd:
         const Sk8q_srt+176;
         const 35;
         const 34357650505;
 },
 section "relreadonly" {
     ul2z_srtd:
         const Sk8q_srt+176;
         const 35;
         const 34357650505;
 },
 section "relreadonly" {
     ul2A_srtd:
         const Sk8q_srt+176;
         const 35;
         const 34357650505;
 },
 section "relreadonly" {
     ul2B_srtd:
         const Sk8q_srt+176;
         const 35;
         const 34357650505;
 },
 section "relreadonly" {
     ul2C_srtd:
         const Sk8q_srt+176;
         const 42;
         const 4398045471817;
 },
 section "relreadonly" {
     ul2D_srtd:
         const Sk8q_srt+176;
         const 35;
         const 34357650505;
 },
 Main.main1_entry() //  []
         { info_tbl: [(ckRA,
                       label: block_ckRA_info
                       rep:StackRep []),
                      (ckRC,
                       label: block_ckRC_info
                       rep:StackRep [False]),
                      (ckRN,
                       label: block_ckRN_info
                       rep:StackRep [False]),
                      (ckRR,
                       label: block_ckRR_info
                       rep:StackRep [False]),
                      (ckRT,
                       label: block_ckRT_info
                       rep:StackRep [False]),
                      (ckRY,
                       label: block_ckRY_info
                       rep:StackRep [False, False, False, False, False, False]),
                      (ckSb,
                       label: block_ckSb_info
                       rep:StackRep [True, False, False, False, False, False, False]),
                      (ckSd,
                       label: block_ckSd_info
                       rep:StackRep [True, False, False, False, True, False, False]),
                      (ckSi,
                       label: block_ckSi_info
                       rep:StackRep [True, False, False, True, True, False, False]),
                      (ckSn,
                       label: block_ckSn_info
                       rep:StackRep [True, False, False, True, True, True, False]),
                      (ckSu,
                       label: block_ckSu_info
                       rep:StackRep [True, False, False, True, True, True, False]),
                      (ckSx,
                       label: block_ckSx_info
                       rep:StackRep [False, True, False, False, True, True, True, False]),
                      (ckU1,
                       label: block_ckU1_info
                       rep:StackRep [False, False, False, True, False, False, True, True,
                                     True, False]),
                      (ckU5,
                       label: block_ckU5_info
                       rep:StackRep [False, True, False, True, False, False, True, True,
                                     True, False]),
                      (ckU9,
                       label: block_ckU9_info
                       rep:StackRep [False, True, False, True, False, False, True, True,
                                     True, False]),
                      (ckUc,
                       label: block_ckUc_info
                       rep:StackRep [False, True, False, True, False, False, True, True,
                                     True, False]),
                      (ckUj,
                       label: block_ckUj_info
                       rep:StackRep [True, False, True, True, True, True, False]),
                      (ckUm,
                       label: block_ckUm_info
                       rep:StackRep [True, True, True, True, False, False, False]),
                      (ckY5,
                       label: block_ckY5_info
                       rep:StackRep [False, True, False, True, False, True, True, True,
                                     True, False]),
                      (cl0B,
                       label: Main.main1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} }),
                      (cl1e,
                       label: block_cl1e_info
                       rep:StackRep [True, False, True, True, True, True, False]),
                      (cl1g,
                       label: block_cl1g_info
                       rep:StackRep [True, False, True, True, True, True, False]),
                      (cl1w,
                       label: block_cl1w_info
                       rep:StackRep [True, False, True, True, True, True, False]),
                      (cl1y,
                       label: block_cl1y_info
                       rep:StackRep [True, False, True, True, True, True, False]),
                      (cl1S,
                       label: block_cl1S_info
                       rep:StackRep [False, True, False, True, False, False, True, True,
                                     True, False]),
                      (cl1Y,
                       label: block_cl1Y_info
                       rep:StackRep [False, True, False, True, False, False, True, True,
                                     True, False]),
                      (cl23,
                       label: block_cl23_info
                       rep:StackRep [False, True, False, True, False, False, True, True,
                                     True, False]),
                      (cl27,
                       label: block_cl27_info
                       rep:StackRep [True, False, False, True, True, True, False]),
                      (cl2d,
                       label: block_cl2d_info
                       rep:StackRep [True, False, False, True, True, True, False])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cl0B:
           if ((Sp + -88) < SpLim) goto cl0C; else goto cl0D;
       cl0D:
           if (HpLim == 0) goto cl0C; else goto cl0E;
       cl0C:
           R1 = Main.main1_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cl0E:
           I64[Sp - 8] = ckRA;
           Sp = Sp - 8;
           call System.Environment.getProgName1_info() returns to ckRA, args: 8, res: 8, upd: 8;
       ckRA:
           I64[Sp - 8] = ckRC;
           P64[Sp] = R1;
           Sp = Sp - 8;
           call System.Environment.getArgs1_info() returns to ckRC, args: 8, res: 8, upd: 8;
       ckRC:
           Hp = Hp + 88;
           if (Hp > HpLim) goto cl0I; else goto cl0H;
       cl0I:
           HpAlloc = 88;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to ckRC, args: 8, res: 8, upd: 8;
       cl0H:
           I64[Hp - 80] = sat_sk37_info;
           P64[Hp - 64] = P64[Sp + 8];
           I64[Hp - 56] = Options.Applicative.Types.ParserInfo_con_info;
           P64[Hp - 48] = lvl20_rjVp_closure+3;
           P64[Hp - 40] = GHC.Types.True_closure+2;
           P64[Hp - 32] = lvl22_rjVr_closure;
           P64[Hp - 24] = Hp - 80;
           P64[Hp - 16] = GHC.Base.Nothing_closure+1;
           P64[Hp - 8] = Options.Applicative.Builder.info1_closure;
           P64[Hp] = GHC.Types.True_closure+2;
           I64[Sp] = ckRN;
           R4 = R1;
           R3 = Hp - 55;
           R2 = Options.Applicative.Builder.prefs1_closure;
           call Options.Applicative.Extra.execParserPure_info(R4,
                                                              R3,
                                                              R2) returns to ckRN, args: 8, res: 8, upd: 8;
       ckRN:
           I64[Sp] = ckRR;
           R2 = R1;
           call Options.Applicative.Extra.customExecParser2_info(R2) returns to ckRR, args: 8, res: 8, upd: 8;
       ckRR:
           I64[Sp] = ckRT;
           R1 = R1;
           if (R1 & 7 != 0) goto ckRT; else goto ckRU;
       ckRU:
           call (I64[R1])(R1) returns to ckRT, args: 8, res: 8, upd: 8;
       ckRT:
           I64[Sp - 40] = ckRY;
           _sk3e::P64 = P64[R1 + 7];
           _sk3g::P64 = P64[R1 + 23];
           _sk3h::P64 = P64[R1 + 31];
           _sk3j::P64 = P64[R1 + 47];
           _sk3k::P64 = P64[R1 + 55];
           R1 = P64[R1 + 15];
           P64[Sp - 32] = _sk3g::P64;
           P64[Sp - 24] = _sk3h::P64;
           P64[Sp - 16] = _sk3j::P64;
           P64[Sp - 8] = _sk3k::P64;
           P64[Sp] = _sk3e::P64;
           Sp = Sp - 40;
           if (R1 & 7 != 0) goto ckRY; else goto ckRZ;
       ckRZ:
           call (I64[R1])(R1) returns to ckRY, args: 8, res: 8, upd: 8;
       ckRY:
           I64[Sp - 8] = ckSb;
           _sk3m::I64 = I64[R1 + 7];
           I64[Sp] = _sk3m::I64;
           Sp = Sp - 8;
           _ul2n::P64 = CurrentTSO;
           I64[I64[_ul2n::P64 + 24] + 16] = Sp;
           _ul2o::I64 = CurrentNursery;
           P64[_ul2o::I64 + 8] = Hp + 8;
           I64[_ul2n::P64 + 112] = I64[_ul2n::P64 + 112] - ((Hp + 8) - I64[_ul2o::I64]);
           (_ul2k::I64) = call "ccall" arg hints:  [PtrHint,]  result hints:  [PtrHint] suspendThread(BaseReg, 0);
           call "ccall" arg hints:  []  result hints:  [] setNumCapabilities(%MO_UU_Conv_W32_W64(%MO_UU_Conv_W64_W32(_sk3m::I64)));
           (_ul2l::I64) = call "ccall" arg hints:  [PtrHint]  result hints:  [PtrHint] resumeThread(_ul2k::I64);
           BaseReg = _ul2l::I64;
           _ul2n::P64 = CurrentTSO;
           _ul2m::P64 = I64[_ul2n::P64 + 24];
           Sp = I64[_ul2m::P64 + 16];
           SpLim = _ul2m::P64 + 192;
           HpAlloc = 0;
           _ul2o::I64 = CurrentNursery;
           _ul2p::I64 = I64[_ul2o::I64 + 8];
           Hp = _ul2p::I64 - 8;
           _ul2q::I64 = I64[_ul2o::I64];
           HpLim = _ul2q::I64 + ((%MO_SS_Conv_W32_W64(I32[_ul2o::I64 + 48]) << 12) - 1);
           I64[_ul2n::P64 + 112] = I64[_ul2n::P64 + 112] + (_ul2p::I64 - _ul2q::I64);
           call (I64[Sp])() returns to ckSb, args: 8, res: 8, upd: 8;
       ckSb:
           I64[Sp] = ckSd;
           R1 = P64[Sp + 40];
           if (R1 & 7 != 0) goto ckSd; else goto ckSe;
       ckSe:
           call (I64[R1])(R1) returns to ckSd, args: 8, res: 8, upd: 8;
       ckSd:
           I64[Sp] = ckSi;
           _sk3t::I64 = I64[R1 + 7];
           R1 = P64[Sp + 32];
           I64[Sp + 40] = _sk3t::I64;
           if (R1 & 7 != 0) goto ckSi; else goto ckSj;
       ckSj:
           call (I64[R1])(R1) returns to ckSi, args: 8, res: 8, upd: 8;
       ckSi:
           I64[Sp] = ckSn;
           _sk3v::F64 = F64[R1 + 7];
           R1 = P64[Sp + 48];
           F64[Sp + 48] = _sk3v::F64;
           if (R1 & 7 != 0) goto ckSn; else goto ckSo;
       ckSo:
           call (I64[R1])(R1) returns to ckSn, args: 8, res: 8, upd: 8;
       ckSn:
           Hp = Hp + 16;
           if (Hp > HpLim) goto cl0S; else goto cl0R;
       cl0S:
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to ckSn, args: 8, res: 8, upd: 8;
       cl0R:
           _sk3m::I64 = I64[Sp + 8];
           _sk3x::I64 = I64[R1 + 7];
           if (%MO_S_Gt_W64(1, _sk3m::I64)) goto cl2h; else goto cl29;
       cl2h:
           Hp = Hp - 16;
           _sk3A::P64 = GHC.Types.[]_closure+1;
           goto ckSv;
       cl29:
           I64[Hp - 8] = go_sk65_info;
           I64[Hp] = _sk3m::I64;
           I64[Sp] = cl27;
           R2 = 1;
           R1 = Hp - 7;
           I64[Sp + 32] = _sk3x::I64;
           call go_sk65_info(R2, R1) returns to cl27, args: 8, res: 8, upd: 8;
       cl27:
           I64[Sp] = cl2d;
           R2 = R1;
           call Main.initGens2_info(R2) returns to cl2d, args: 8, res: 8, upd: 8;
       cl2d:
           _sk3x::I64 = I64[Sp + 32];
           _sk3A::P64 = R1;
           goto ckSv;
       ckSv:
           if (HpLim == 0) goto cl0T; else goto cl0U;
       cl0T:
           I64[Sp] = ckSu;
           R1 = _sk3A::P64;
           I64[Sp + 32] = _sk3x::I64;
           call stg_gc_unpt_r1(R1) returns to ckSu, args: 8, res: 8, upd: 8;
       ckSu:
           _sk3x::I64 = I64[Sp + 32];
           _sk3A::P64 = R1;
           goto ckSv;
       cl0U:
           I64[Sp - 8] = ckSx;
           R1 = SkipList.newSL2_closure+1;
           P64[Sp] = _sk3A::P64;
           I64[Sp + 32] = _sk3x::I64;
           Sp = Sp - 8;
           call stg_norec_atomically#(R1) returns to ckSx, args: 8, res: 8, upd: 8;
       ckSx:
           Hp = Hp + 16;
           if (Hp > HpLim) goto cl0X; else goto cl0W;
       cl0X:
           HpAlloc = 16;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to ckSx, args: 8, res: 8, upd: 8;
       cl0W:
           I64[Hp - 8] = a7_sk3E_info;
           P64[Hp] = R1;
           I64[Sp - 16] = ckU1;
           R4 = I64[Sp + 40];
           R3 = 2;
           R2 = 0;
           P64[Sp - 8] = R1;
           P64[Sp] = Hp - 6;
           Sp = Sp - 16;
           call GHC.Enum.$w$cenumFromThenTo_info(R4,
                                                 R3,
                                                 R2) returns to ckU1, args: 8, res: 8, upd: 8;
       ckU1:
           I64[Sp] = ckU5;
           R2 = R1;
           R1 = P64[Sp + 16];
           call a7_sk3E_info(R2, R1) returns to ckU5, args: 8, res: 8, upd: 8;
       ckU5:
           _sk3m::I64 = I64[Sp + 32];
           if (%MO_S_Lt_W64(0, _sk3m::I64)) goto cl1Z; else goto cl1U;
       cl1Z:
           I64[Sp] = cl1Y;
           R2 = _sk3m::I64;
           call $wxs_rjVo_info(R2) returns to cl1Y, args: 8, res: 8, upd: 8;
       cl1Y:
           I64[Sp] = cl23;
           R2 = R1;
           call Control.Monad.replicateM4_info(R2) returns to cl23, args: 8, res: 8, upd: 8;
       cl23:
           _sk3g::P64 = P64[Sp + 40];
           _sk41::P64 = R1;
           goto ckUa;
       cl1U:
           I64[Sp] = cl1S;
           R2 = GHC.Types.[]_closure+1;
           call Control.Monad.replicateM4_info(R2) returns to cl1S, args: 8, res: 8, upd: 8;
       cl1S:
           _sk3g::P64 = P64[Sp + 40];
           _sk41::P64 = R1;
           goto ckUa;
       ckUa:
           if (HpLim == 0) goto cl10; else goto cl11;
       cl10:
           I64[Sp] = ckU9;
           R1 = _sk41::P64;
           call stg_gc_unpt_r1(R1) returns to ckU9, args: 8, res: 8, upd: 8;
       ckU9:
           _sk3g::P64 = P64[Sp + 40];
           _sk41::P64 = R1;
           goto ckUa;
       cl11:
           I64[Sp] = ckUc;
           R1 = _sk3g::P64;
           P64[Sp + 40] = _sk41::P64;
           if (R1 & 7 != 0) goto ckUc; else goto ckUd;
       ckUd:
           call (I64[R1])(R1) returns to ckUc, args: 8, res: 8, upd: 8;
       ckUc:
           if (R1 & 7 != 1) goto cl1M; else goto cl19;
       cl1M:
           R1 = GHC.Tuple.()_closure+1;
           Sp = Sp + 88;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
       cl19:
           I64[Sp] = ckY5;
           R1 = P64[Sp + 48];
           if (R1 & 7 != 0) goto ckY5; else goto ckY6;
       ckY6:
           call (I64[R1])(R1) returns to ckY5, args: 8, res: 8, upd: 8;
       ckY5:
           _sk3t::I64 = I64[Sp + 64];
           _sk3v::F64 = F64[Sp + 72];
           _sk3x::I64 = I64[Sp + 56];
           _sk3A::P64 = P64[Sp + 24];
           _sk41::P64 = P64[Sp + 40];
           if (R1 & 7 != 1) goto cl1z; else goto cl1i;
       cl1z:
           Hp = Hp + 64;
           if (Hp > HpLim) goto cl1C; else goto cl1B;
       cl1C:
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to ckY5, args: 8, res: 8, upd: 8;
       cl1B:
           I64[Hp - 56] = sat_sk5N_info;
           P64[Hp - 40] = _sk3A::P64;
           P64[Hp - 32] = _sk41::P64;
           F64[Hp - 24] = _sk3v::F64;
           I64[Hp - 16] = _sk3x::I64;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sk3t::I64 * 1000;
           I64[Sp + 24] = cl1w;
           R3 = Hp - 56;
           R2 = Hp - 7;
           Sp = Sp + 24;
           call Throughput.throughputMain1_info(R3,
                                                R2) returns to cl1w, args: 8, res: 8, upd: 8;
       cl1w:
           I64[Sp] = cl1y;
           R1 = R1;
           if (R1 & 7 != 0) goto cl1y; else goto cl1E;
       cl1E:
           call (I64[R1])(R1) returns to cl1y, args: 8, res: 8, upd: 8;
       cl1y:
           _sk41::P64 = P64[Sp + 16];
           _sk46::P64 = P64[R1 + 15];
           _sk45::P64 = P64[R1 + 7];
           goto ckUk;
       cl1i:
           Hp = Hp + 72;
           if (Hp > HpLim) goto cl1l; else goto cl1k;
       cl1l:
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to ckY5, args: 8, res: 8, upd: 8;
       cl1k:
           I64[Hp - 64] = sat_sk5w_info;
           P64[Hp - 48] = _sk3A::P64;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = _sk41::P64;
           F64[Hp - 24] = _sk3v::F64;
           I64[Hp - 16] = _sk3x::I64;
           I64[Hp - 8] = GHC.Types.I#_con_info;
           I64[Hp] = _sk3t::I64 * 1000;
           I64[Sp + 24] = cl1e;
           R3 = Hp - 64;
           R2 = Hp - 7;
           Sp = Sp + 24;
           call Throughput.throughputMain1_info(R3,
                                                R2) returns to cl1e, args: 8, res: 8, upd: 8;
       cl1e:
           I64[Sp] = cl1g;
           R1 = R1;
           if (R1 & 7 != 0) goto cl1g; else goto cl1n;
       cl1n:
           call (I64[R1])(R1) returns to cl1g, args: 8, res: 8, upd: 8;
       cl1g:
           _sk41::P64 = P64[Sp + 16];
           _sk46::P64 = P64[R1 + 15];
           _sk45::P64 = P64[R1 + 7];
           goto ckUk;
       ckUk:
           if (HpLim == 0) goto cl13; else goto cl14;
       cl13:
           I64[Sp] = ckUj;
           R2 = _sk46::P64;
           R1 = _sk45::P64;
           call stg_gc_pp(R2, R1) returns to ckUj, args: 8, res: 8, upd: 8;
       ckUj:
           _sk41::P64 = P64[Sp + 16];
           _sk46::P64 = R2;
           _sk45::P64 = R1;
           goto ckUk;
       cl14:
           I64[Sp] = ckUm;
           R2 = _sk41::P64;
           P64[Sp + 40] = _sk46::P64;
           P64[Sp + 48] = _sk45::P64;
           call a5_rjVe_info(R2) returns to ckUm, args: 8, res: 8, upd: 8;
       ckUm:
           Hp = Hp + 64;
           if (Hp > HpLim) goto cl17; else goto cl16;
       cl17:
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to ckUm, args: 8, res: 8, upd: 8;
       cl16:
           I64[Hp - 56] = sat_sk51_info;
           P64[Hp - 40] = P64[Sp + 56];
           P64[Hp - 32] = P64[Sp + 48];
           P64[Hp - 24] = P64[Sp + 40];
           P64[Hp - 16] = R1;
           I64[Hp - 8] = I64[Sp + 8];
           I64[Hp] = I64[Sp + 32];
           R4 = GHC.Types.True_closure+2;
           R3 = Hp - 56;
           R2 = GHC.IO.Handle.FD.stdout_closure;
           Sp = Sp + 64;
           call GHC.IO.Handle.Text.hPutStr2_info(R4,
                                                 R3,
                                                 R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:55.209628 UTC

[section "data" {
     Main.main_closure:
         const Main.main_info;
         const 0;
 },
 Main.main_entry() //  []
         { info_tbl: [(cl5u,
                       label: Main.main_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cl5u:
           goto cl5s;
       cl5s:
           if ((old + 0) - <highSp> < SpLim) goto cl5v; else goto cl5w;
       cl5w:
           goto cl5r;
       cl5r:
           if (HpLim == 0) goto cl5v; else goto cl5x;
       cl5v:
           R1 = Main.main_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cl5x:
           call Main.main1_info() args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:55.211152 UTC

{offset
  cl5u:
      if ((old + 0) - <highSp> < SpLim) goto cl5v; else goto cl5w;
  cl5w:
      if (HpLim == 0) goto cl5v; else goto cl5x;
  cl5v:
      R1 = Main.main_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  cl5x:
      call Main.main1_info() args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:55.211789 UTC

{offset
  cl5u:
      if ((old + 0) - <highSp> < SpLim) goto cl5v; else goto cl5w;
  cl5w:
      if (HpLim == 0) goto cl5v; else goto cl5x;
  cl5v:
      R1 = Main.main_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  cl5x:
      call Main.main1_info() args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:55.212415 UTC

{offset
  cl5u:
      if ((old + 0) - <highSp> < SpLim) goto cl5v; else goto cl5w;
  cl5w:
      if (HpLim == 0) goto cl5v; else goto cl5x;
  cl5v:
      R1 = Main.main_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  cl5x:
      call Main.main1_info() args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:55.213085 UTC

{offset
  cl5u:
      goto cl5w;
  cl5w:
      if (HpLim == 0) goto cl5v; else goto cl5x;
  cl5v:
      R1 = Main.main_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  cl5x:
      call Main.main1_info() args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:55.213622 UTC

{offset
  cl5u:
      goto cl5w;
  cl5w:
      if (HpLim == 0) goto cl5v; else goto cl5x;
  cl5v:
      R1 = Main.main_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  cl5x:
      call Main.main1_info() args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:55.21418 UTC

[(cl5u, {Main.main1_closure, Main.main_closure}),
 (cl5v, {Main.main_closure}),
 (cl5w, {Main.main1_closure, Main.main_closure}),
 (cl5x, {Main.main1_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:55.214696 UTC

Main.main_entry() //  []
        { info_tbl: [(cl5u,
                      label: Main.main_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cl5u:
          goto cl5w;
      cl5w:
          if (HpLim == 0) goto cl5v; else goto cl5x;
      cl5v:
          R1 = Main.main_closure;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
      cl5x:
          call Main.main1_info() args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:55.215484 UTC

Main.main_entry() //  []
        { info_tbl: [(cl5u,
                      label: Main.main_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cl5u:
          if (HpLim == 0) goto cl5v; else goto cl5x;
      cl5v:
          R1 = Main.main_closure;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
      cl5x:
          call Main.main1_info() args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:55.216238 UTC

[section "data" {
     Main.main_closure:
         const Main.main_info;
         const 0;
 },
 Main.main_entry() //  []
         { info_tbl: [(cl5u,
                       label: Main.main_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cl5u:
           if (HpLim == 0) goto cl5v; else goto cl5x;
       cl5v:
           R1 = Main.main_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cl5x:
           call Main.main1_info() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:55.21724 UTC

[section "data" {
     Main.main_closure:
         const Main.main_info;
         const 0;
 },
 Main.main_entry() //  []
         { info_tbl: [(cl5u,
                       label: Main.main_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cl5u:
           if (HpLim == 0) goto cl5v; else goto cl5x;
       cl5v:
           R1 = Main.main_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cl5x:
           call Main.main1_info() args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:55.219728 UTC

[section "data" {
     Main.main2_closure:
         const Main.main2_info;
         const 0;
 },
 Main.main2_entry() //  []
         { info_tbl: [(cl5G,
                       label: Main.main2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cl5G:
           goto cl5E;
       cl5E:
           if ((old + 0) - <highSp> < SpLim) goto cl5H; else goto cl5I;
       cl5I:
           goto cl5D;
       cl5D:
           if (HpLim == 0) goto cl5H; else goto cl5J;
       cl5H:
           R1 = Main.main2_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cl5J:
           R2 = Main.main1_closure+1;
           call GHC.TopHandler.runMainIO1_info(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:55.221157 UTC

{offset
  cl5G:
      if ((old + 0) - <highSp> < SpLim) goto cl5H; else goto cl5I;
  cl5I:
      if (HpLim == 0) goto cl5H; else goto cl5J;
  cl5H:
      R1 = Main.main2_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  cl5J:
      R2 = Main.main1_closure+1;
      call GHC.TopHandler.runMainIO1_info(R2) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:55.221821 UTC

{offset
  cl5G:
      if ((old + 0) - <highSp> < SpLim) goto cl5H; else goto cl5I;
  cl5I:
      if (HpLim == 0) goto cl5H; else goto cl5J;
  cl5H:
      R1 = Main.main2_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  cl5J:
      R2 = Main.main1_closure+1;
      call GHC.TopHandler.runMainIO1_info(R2) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:55.222485 UTC

{offset
  cl5G:
      if ((old + 0) - <highSp> < SpLim) goto cl5H; else goto cl5I;
  cl5I:
      if (HpLim == 0) goto cl5H; else goto cl5J;
  cl5H:
      R1 = Main.main2_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  cl5J:
      R2 = Main.main1_closure+1;
      call GHC.TopHandler.runMainIO1_info(R2) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:55.223187 UTC

{offset
  cl5G:
      goto cl5I;
  cl5I:
      if (HpLim == 0) goto cl5H; else goto cl5J;
  cl5H:
      R1 = Main.main2_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  cl5J:
      R2 = Main.main1_closure+1;
      call GHC.TopHandler.runMainIO1_info(R2) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:55.223772 UTC

{offset
  cl5G:
      goto cl5I;
  cl5I:
      if (HpLim == 0) goto cl5H; else goto cl5J;
  cl5H:
      R1 = Main.main2_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  cl5J:
      R2 = Main.main1_closure+1;
      call GHC.TopHandler.runMainIO1_info(R2) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:55.224377 UTC

[(cl5G,
  {GHC.TopHandler.runMainIO1_closure, Main.main1_closure,
   Main.main2_closure}),
 (cl5H, {Main.main2_closure}),
 (cl5I,
  {GHC.TopHandler.runMainIO1_closure, Main.main1_closure,
   Main.main2_closure}),
 (cl5J, {GHC.TopHandler.runMainIO1_closure, Main.main1_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:55.225017 UTC

Main.main2_entry() //  []
        { info_tbl: [(cl5G,
                      label: Main.main2_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cl5G:
          goto cl5I;
      cl5I:
          if (HpLim == 0) goto cl5H; else goto cl5J;
      cl5H:
          R1 = Main.main2_closure;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
      cl5J:
          R2 = Main.main1_closure+1;
          call GHC.TopHandler.runMainIO1_info(R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:55.225853 UTC

Main.main2_entry() //  []
        { info_tbl: [(cl5G,
                      label: Main.main2_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cl5G:
          if (HpLim == 0) goto cl5H; else goto cl5J;
      cl5H:
          R1 = Main.main2_closure;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
      cl5J:
          R2 = Main.main1_closure+1;
          call GHC.TopHandler.runMainIO1_info(R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:55.22666 UTC

[section "data" {
     Main.main2_closure:
         const Main.main2_info;
         const 0;
 },
 Main.main2_entry() //  []
         { info_tbl: [(cl5G,
                       label: Main.main2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cl5G:
           if (HpLim == 0) goto cl5H; else goto cl5J;
       cl5H:
           R1 = Main.main2_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cl5J:
           R2 = Main.main1_closure+1;
           call GHC.TopHandler.runMainIO1_info(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:55.228304 UTC

[section "data" {
     Main.main2_closure:
         const Main.main2_info;
         const 0;
 },
 Main.main2_entry() //  []
         { info_tbl: [(cl5G,
                       label: Main.main2_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cl5G:
           if (HpLim == 0) goto cl5H; else goto cl5J;
       cl5H:
           R1 = Main.main2_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cl5J:
           R2 = Main.main1_closure+1;
           call GHC.TopHandler.runMainIO1_info(R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:55.232128 UTC

[section "data" {
     Main.$w$cshowsPrec_closure:
         const Main.$w$cshowsPrec_info;
         const 0;
 },
 Main.$w$cshowsPrec_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 64 updfr_space: Just 8
         }
     {offset
       cl5T:
           _rbVv::P64 = R1;
           _sk6h::P64 = P64[(old + 64)];
           _sk6i::P64 = P64[(old + 56)];
           _sk6j::P64 = P64[(old + 48)];
           _sk6k::P64 = P64[(old + 40)];
           _sk6l::P64 = P64[(old + 32)];
           _sk6m::P64 = P64[(old + 24)];
           _sk6n::P64 = P64[(old + 16)];
           R6 = _sk6l::P64;
           R5 = _sk6k::P64;
           R4 = _sk6j::P64;
           R3 = _sk6i::P64;
           R2 = _sk6h::P64;
           R1 = _rbVv::P64;
           P64[(old + 24)] = _sk6m::P64;
           P64[(old + 16)] = _sk6n::P64;
           call Main.$w$cshowsPrec_info(R6,
                                        R5,
                                        R4,
                                        R3,
                                        R2,
                                        R1) args: 24, res: 0, upd: 8;
     }
 },
 f_sk6o_entry() //  [R1]
         { info_tbl: [(cl6J,
                       label: f_sk6o_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cl6J:
           _sk6o::P64 = R1;
           goto cl6E;
       cl6E:
           if ((old + 0) - <highSp> < SpLim) goto cl6K; else goto cl6L;
       cl6L:
           if (HpLim == 0) goto cl6K; else goto cl6M;
       cl6K:
           R1 = _sk6o::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cl6M:
           I64[(old + 24)] = stg_upd_frame_info;
           P64[(old + 16)] = _sk6o::P64;
           _sk6m::P64 = P64[_sk6o::P64 + 16];
           I64[(young<cl6G> + 8)] = cl6G;
           R1 = _sk6m::P64;
           if (R1 & 7 != 0) goto cl6G; else goto cl6H;
       cl6H:
           call (I64[R1])(R1) returns to cl6G, args: 8, res: 8, upd: 24;
       cl6G:
           _sk6p::P64 = R1;
           _sk6q::F64 = F64[_sk6p::P64 + 7];
           D1 = _sk6q::F64;
           R3 = lvl4_rjV1_closure+1;
           R2 = GHC.Float.$fShowDouble_$sshowFloat_closure+1;
           call GHC.Float.$w$sshowSignedFloat_info(D1,
                                                   R3,
                                                   R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sk6C_entry() //  [R1]
         { info_tbl: [(cl8B,
                       label: sat_sk6C_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cl8B:
           _sk6C::P64 = R1;
           goto cl8z;
       cl8z:
           if ((old + 0) - <highSp> < SpLim) goto cl8C; else goto cl8D;
       cl8D:
           if (HpLim == 0) goto cl8C; else goto cl8E;
       cl8C:
           R1 = _sk6C::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cl8E:
           I64[(old + 24)] = stg_upd_frame_info;
           P64[(old + 16)] = _sk6C::P64;
           _sk6r::P64 = P64[_sk6C::P64 + 16];
           R3 = _sk6r::P64;
           R2 = lvl1_rjUY_closure;
           call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sk6G_entry() //  [R1]
         { info_tbl: [(cl8F,
                       label: sat_sk6G_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cl8F:
           _sk6G::P64 = R1;
           goto cl8q;
       cl8q:
           if ((old + 0) - <highSp> < SpLim) goto cl8J; else goto cl8K;
       cl8K:
           if (HpLim == 0) goto cl8J; else goto cl8L;
       cl8J:
           R1 = _sk6G::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cl8L:
           _sk6n::P64 = P64[_sk6G::P64 + 16];
           _sk6r::P64 = P64[_sk6G::P64 + 24];
           I64[(young<cl8s> + 8)] = cl8s;
           R1 = _sk6n::P64;
           if (R1 & 7 != 0) goto cl8s; else goto cl8t;
       cl8t:
           call (I64[R1])(R1) returns to cl8s, args: 8, res: 8, upd: 8;
       cl8s:
           _sk6A::P64 = R1;
           Hp = Hp + 24;
           if (Hp > HpLim) goto cl8O; else goto cl8N;
       cl8O:
           HpAlloc = 24;
           goto cl8M;
       cl8M:
           R1 = _sk6A::P64;
           call stg_gc_unpt_r1(R1) returns to cl8s, args: 8, res: 8, upd: 8;
       cl8N:
           _sk6B::I64 = I64[_sk6A::P64 + 7];
           I64[Hp - 16] = sat_sk6C_info;
           P64[Hp] = _sk6r::P64;
           _cl8x::P64 = Hp - 16;
           I64[(young<cl8G> + 8)] = cl8G;
           R4 = _cl8x::P64;
           R3 = _sk6B::I64;
           R2 = 0;
           call GHC.Show.$wshowSignedInt_info(R4,
                                              R3,
                                              R2) returns to cl8G, args: 8, res: 8, upd: 8;
       cl8G:
           _sk6F::P64 = R2;
           _sk6E::P64 = R1;
           Hp = Hp + 24;
           if (Hp > HpLim) goto cl8R; else goto cl8Q;
       cl8R:
           HpAlloc = 24;
           goto cl8P;
       cl8P:
           R2 = _sk6F::P64;
           R1 = _sk6E::P64;
           call stg_gc_pp(R2, R1) returns to cl8G, args: 8, res: 8, upd: 8;
       cl8Q:
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sk6E::P64;
           P64[Hp] = _sk6F::P64;
           _cl8I::P64 = Hp - 14;
           R1 = _cl8I::P64;
           call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sk6H_entry() //  [R1]
         { info_tbl: [(cl8S,
                       label: sat_sk6H_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cl8S:
           _sk6H::P64 = R1;
           goto cl8m;
       cl8m:
           if ((old + 0) - <highSp> < SpLim) goto cl8T; else goto cl8U;
       cl8U:
           Hp = Hp + 32;
           if (Hp > HpLim) goto cl8W; else goto cl8V;
       cl8W:
           HpAlloc = 32;
           goto cl8T;
       cl8T:
           R1 = _sk6H::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cl8V:
           _sk6n::P64 = P64[_sk6H::P64 + 16];
           _sk6r::P64 = P64[_sk6H::P64 + 24];
           I64[Hp - 24] = sat_sk6G_info;
           P64[Hp - 8] = _sk6n::P64;
           P64[Hp] = _sk6r::P64;
           _cl8o::P64 = Hp - 24;
           R3 = _cl8o::P64;
           R2 = lvl2_rjUZ_closure;
           call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sk6I_entry() //  [R1]
         { info_tbl: [(cl8X,
                       label: sat_sk6I_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cl8X:
           _sk6I::P64 = R1;
           goto cl8i;
       cl8i:
           if ((old + 0) - <highSp> < SpLim) goto cl8Y; else goto cl8Z;
       cl8Z:
           Hp = Hp + 32;
           if (Hp > HpLim) goto cl91; else goto cl90;
       cl91:
           HpAlloc = 32;
           goto cl8Y;
       cl8Y:
           R1 = _sk6I::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cl90:
           I64[(old + 24)] = stg_upd_frame_info;
           P64[(old + 16)] = _sk6I::P64;
           _sk6n::P64 = P64[_sk6I::P64 + 16];
           _sk6r::P64 = P64[_sk6I::P64 + 24];
           I64[Hp - 24] = sat_sk6H_info;
           P64[Hp - 8] = _sk6n::P64;
           P64[Hp] = _sk6r::P64;
           _cl8k::P64 = Hp - 24;
           R3 = _cl8k::P64;
           R2 = lvl3_rjV0_closure;
           call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sk6J_entry() //  [R1]
         { info_tbl: [(cl92,
                       label: sat_sk6J_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cl92:
           _sk6J::P64 = R1;
           goto cl8e;
       cl8e:
           if ((old + 0) - <highSp> < SpLim) goto cl93; else goto cl94;
       cl94:
           Hp = Hp + 32;
           if (Hp > HpLim) goto cl96; else goto cl95;
       cl96:
           HpAlloc = 32;
           goto cl93;
       cl93:
           R1 = _sk6J::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cl95:
           _sk6n::P64 = P64[_sk6J::P64 + 16];
           _sk6o::P64 = P64[_sk6J::P64 + 24];
           _sk6r::P64 = P64[_sk6J::P64 + 32];
           I64[Hp - 24] = sat_sk6I_info;
           P64[Hp - 8] = _sk6n::P64;
           P64[Hp] = _sk6r::P64;
           _cl8g::P64 = Hp - 24;
           R2 = _cl8g::P64;
           R1 = _sk6o::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sk6K_entry() //  [R1]
         { info_tbl: [(cl97,
                       label: sat_sk6K_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cl97:
           _sk6K::P64 = R1;
           goto cl8a;
       cl8a:
           if ((old + 0) - <highSp> < SpLim) goto cl98; else goto cl99;
       cl99:
           Hp = Hp + 40;
           if (Hp > HpLim) goto cl9b; else goto cl9a;
       cl9b:
           HpAlloc = 40;
           goto cl98;
       cl98:
           R1 = _sk6K::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cl9a:
           _sk6n::P64 = P64[_sk6K::P64 + 16];
           _sk6o::P64 = P64[_sk6K::P64 + 24];
           _sk6r::P64 = P64[_sk6K::P64 + 32];
           I64[Hp - 32] = sat_sk6J_info;
           P64[Hp - 16] = _sk6n::P64;
           P64[Hp - 8] = _sk6o::P64;
           P64[Hp] = _sk6r::P64;
           _cl8c::P64 = Hp - 32;
           R3 = _cl8c::P64;
           R2 = lvl5_rjV2_closure;
           call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sk6L_entry() //  [R1]
         { info_tbl: [(cl9c,
                       label: sat_sk6L_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cl9c:
           _sk6L::P64 = R1;
           goto cl86;
       cl86:
           if ((old + 0) - <highSp> < SpLim) goto cl9d; else goto cl9e;
       cl9e:
           Hp = Hp + 40;
           if (Hp > HpLim) goto cl9g; else goto cl9f;
       cl9g:
           HpAlloc = 40;
           goto cl9d;
       cl9d:
           R1 = _sk6L::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cl9f:
           I64[(old + 24)] = stg_upd_frame_info;
           P64[(old + 16)] = _sk6L::P64;
           _sk6n::P64 = P64[_sk6L::P64 + 16];
           _sk6o::P64 = P64[_sk6L::P64 + 24];
           _sk6r::P64 = P64[_sk6L::P64 + 32];
           I64[Hp - 32] = sat_sk6K_info;
           P64[Hp - 16] = _sk6n::P64;
           P64[Hp - 8] = _sk6o::P64;
           P64[Hp] = _sk6r::P64;
           _cl88::P64 = Hp - 32;
           R3 = _cl88::P64;
           R2 = lvl3_rjV0_closure;
           call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sk6P_entry() //  [R1]
         { info_tbl: [(cl9h,
                       label: sat_sk6P_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cl9h:
           _sk6P::P64 = R1;
           goto cl7X;
       cl7X:
           if ((old + 0) - <highSp> < SpLim) goto cl9l; else goto cl9m;
       cl9m:
           if (HpLim == 0) goto cl9l; else goto cl9n;
       cl9l:
           R1 = _sk6P::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cl9n:
           _sk6l::P64 = P64[_sk6P::P64 + 16];
           _sk6n::P64 = P64[_sk6P::P64 + 24];
           _sk6o::P64 = P64[_sk6P::P64 + 32];
           _sk6r::P64 = P64[_sk6P::P64 + 40];
           I64[(young<cl7Z> + 8)] = cl7Z;
           R1 = _sk6l::P64;
           if (R1 & 7 != 0) goto cl7Z; else goto cl80;
       cl80:
           call (I64[R1])(R1) returns to cl7Z, args: 8, res: 8, upd: 8;
       cl7Z:
           _sk6y::P64 = R1;
           Hp = Hp + 40;
           if (Hp > HpLim) goto cl9q; else goto cl9p;
       cl9q:
           HpAlloc = 40;
           goto cl9o;
       cl9o:
           R1 = _sk6y::P64;
           call stg_gc_unpt_r1(R1) returns to cl7Z, args: 8, res: 8, upd: 8;
       cl9p:
           _sk6z::I64 = I64[_sk6y::P64 + 7];
           I64[Hp - 32] = sat_sk6L_info;
           P64[Hp - 16] = _sk6n::P64;
           P64[Hp - 8] = _sk6o::P64;
           P64[Hp] = _sk6r::P64;
           _cl84::P64 = Hp - 32;
           I64[(young<cl9i> + 8)] = cl9i;
           R4 = _cl84::P64;
           R3 = _sk6z::I64;
           R2 = 0;
           call GHC.Show.$wshowSignedInt_info(R4,
                                              R3,
                                              R2) returns to cl9i, args: 8, res: 8, upd: 8;
       cl9i:
           _sk6O::P64 = R2;
           _sk6N::P64 = R1;
           Hp = Hp + 24;
           if (Hp > HpLim) goto cl9t; else goto cl9s;
       cl9t:
           HpAlloc = 24;
           goto cl9r;
       cl9r:
           R2 = _sk6O::P64;
           R1 = _sk6N::P64;
           call stg_gc_pp(R2, R1) returns to cl9i, args: 8, res: 8, upd: 8;
       cl9s:
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sk6N::P64;
           P64[Hp] = _sk6O::P64;
           _cl9k::P64 = Hp - 14;
           R1 = _cl9k::P64;
           call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sk6Q_entry() //  [R1]
         { info_tbl: [(cl9u,
                       label: sat_sk6Q_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cl9u:
           _sk6Q::P64 = R1;
           goto cl7T;
       cl7T:
           if ((old + 0) - <highSp> < SpLim) goto cl9v; else goto cl9w;
       cl9w:
           Hp = Hp + 48;
           if (Hp > HpLim) goto cl9y; else goto cl9x;
       cl9y:
           HpAlloc = 48;
           goto cl9v;
       cl9v:
           R1 = _sk6Q::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cl9x:
           _sk6l::P64 = P64[_sk6Q::P64 + 16];
           _sk6n::P64 = P64[_sk6Q::P64 + 24];
           _sk6o::P64 = P64[_sk6Q::P64 + 32];
           _sk6r::P64 = P64[_sk6Q::P64 + 40];
           I64[Hp - 40] = sat_sk6P_info;
           P64[Hp - 24] = _sk6l::P64;
           P64[Hp - 16] = _sk6n::P64;
           P64[Hp - 8] = _sk6o::P64;
           P64[Hp] = _sk6r::P64;
           _cl7V::P64 = Hp - 40;
           R3 = _cl7V::P64;
           R2 = lvl6_rjV3_closure;
           call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 eta1_sk6x_entry() //  [R1]
         { info_tbl: [(cl9z,
                       label: eta1_sk6x_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cl9z:
           _sk6x::P64 = R1;
           goto cl7P;
       cl7P:
           if ((old + 0) - <highSp> < SpLim) goto cl9A; else goto cl9B;
       cl9B:
           Hp = Hp + 48;
           if (Hp > HpLim) goto cl9D; else goto cl9C;
       cl9D:
           HpAlloc = 48;
           goto cl9A;
       cl9A:
           R1 = _sk6x::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cl9C:
           I64[(old + 24)] = stg_upd_frame_info;
           P64[(old + 16)] = _sk6x::P64;
           _sk6l::P64 = P64[_sk6x::P64 + 16];
           _sk6n::P64 = P64[_sk6x::P64 + 24];
           _sk6o::P64 = P64[_sk6x::P64 + 32];
           _sk6r::P64 = P64[_sk6x::P64 + 40];
           I64[Hp - 40] = sat_sk6Q_info;
           P64[Hp - 24] = _sk6l::P64;
           P64[Hp - 16] = _sk6n::P64;
           P64[Hp - 8] = _sk6o::P64;
           P64[Hp] = _sk6r::P64;
           _cl7R::P64 = Hp - 40;
           R3 = _cl7R::P64;
           R2 = lvl3_rjV0_closure;
           call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sk6S_entry() //  [R1]
         { info_tbl: [(cl9L,
                       label: sat_sk6S_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cl9L:
           _sk6S::P64 = R1;
           goto cl7L;
       cl7L:
           if ((old + 0) - <highSp> < SpLim) goto cl9M; else goto cl9N;
       cl9N:
           Hp = Hp + 48;
           if (Hp > HpLim) goto cl9P; else goto cl9O;
       cl9P:
           HpAlloc = 48;
           goto cl9M;
       cl9M:
           R1 = _sk6S::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cl9O:
           _sk6k::P64 = P64[_sk6S::P64 + 16];
           _sk6l::P64 = P64[_sk6S::P64 + 24];
           _sk6n::P64 = P64[_sk6S::P64 + 32];
           _sk6o::P64 = P64[_sk6S::P64 + 40];
           _sk6r::P64 = P64[_sk6S::P64 + 48];
           I64[Hp - 40] = eta1_sk6x_info;
           P64[Hp - 24] = _sk6l::P64;
           P64[Hp - 16] = _sk6n::P64;
           P64[Hp - 8] = _sk6o::P64;
           P64[Hp] = _sk6r::P64;
           _cl7N::P64 = Hp - 40;
           I64[(young<cl9E> + 8)] = cl9E;
           R1 = _sk6k::P64;
           if (R1 & 7 != 0) goto cl9E; else goto cl9F;
       cl9F:
           call (I64[R1])(R1) returns to cl9E, args: 8, res: 8, upd: 8;
       cl9E:
           _sk6R::P64 = R1;
           _cl9K::P64 = _sk6R::P64 & 7;
           switch [1 .. 2] _cl9K::P64 {
               case 1 : goto cl9I;
               case 2 : goto cl9J;
           }
       cl9J:
           R3 = _cl7N::P64;
           R2 = GHC.Show.shows16_closure;
           call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
       cl9I:
           R3 = _cl7N::P64;
           R2 = GHC.Show.shows17_closure;
           call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sk6T_entry() //  [R1]
         { info_tbl: [(cl9W,
                       label: sat_sk6T_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cl9W:
           _sk6T::P64 = R1;
           goto cl7H;
       cl7H:
           if ((old + 0) - <highSp> < SpLim) goto cl9X; else goto cl9Y;
       cl9Y:
           Hp = Hp + 56;
           if (Hp > HpLim) goto cla0; else goto cl9Z;
       cla0:
           HpAlloc = 56;
           goto cl9X;
       cl9X:
           R1 = _sk6T::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cl9Z:
           _sk6k::P64 = P64[_sk6T::P64 + 16];
           _sk6l::P64 = P64[_sk6T::P64 + 24];
           _sk6n::P64 = P64[_sk6T::P64 + 32];
           _sk6o::P64 = P64[_sk6T::P64 + 40];
           _sk6r::P64 = P64[_sk6T::P64 + 48];
           I64[Hp - 48] = sat_sk6S_info;
           P64[Hp - 32] = _sk6k::P64;
           P64[Hp - 24] = _sk6l::P64;
           P64[Hp - 16] = _sk6n::P64;
           P64[Hp - 8] = _sk6o::P64;
           P64[Hp] = _sk6r::P64;
           _cl7J::P64 = Hp - 48;
           R3 = _cl7J::P64;
           R2 = lvl7_rjV4_closure;
           call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 eta_sk6w_entry() //  [R1]
         { info_tbl: [(cla1,
                       label: eta_sk6w_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cla1:
           _sk6w::P64 = R1;
           goto cl7D;
       cl7D:
           if ((old + 0) - <highSp> < SpLim) goto cla2; else goto cla3;
       cla3:
           Hp = Hp + 56;
           if (Hp > HpLim) goto cla5; else goto cla4;
       cla5:
           HpAlloc = 56;
           goto cla2;
       cla2:
           R1 = _sk6w::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cla4:
           I64[(old + 24)] = stg_upd_frame_info;
           P64[(old + 16)] = _sk6w::P64;
           _sk6k::P64 = P64[_sk6w::P64 + 16];
           _sk6l::P64 = P64[_sk6w::P64 + 24];
           _sk6n::P64 = P64[_sk6w::P64 + 32];
           _sk6o::P64 = P64[_sk6w::P64 + 40];
           _sk6r::P64 = P64[_sk6w::P64 + 48];
           I64[Hp - 48] = sat_sk6T_info;
           P64[Hp - 32] = _sk6k::P64;
           P64[Hp - 24] = _sk6l::P64;
           P64[Hp - 16] = _sk6n::P64;
           P64[Hp - 8] = _sk6o::P64;
           P64[Hp] = _sk6r::P64;
           _cl7F::P64 = Hp - 48;
           R3 = _cl7F::P64;
           R2 = lvl3_rjV0_closure;
           call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sk6V_entry() //  [R1]
         { info_tbl: [(clad,
                       label: sat_sk6V_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       clad:
           _sk6V::P64 = R1;
           goto cl7z;
       cl7z:
           if ((old + 0) - <highSp> < SpLim) goto clae; else goto claf;
       claf:
           Hp = Hp + 56;
           if (Hp > HpLim) goto clah; else goto clag;
       clah:
           HpAlloc = 56;
           goto clae;
       clae:
           R1 = _sk6V::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       clag:
           _sk6j::P64 = P64[_sk6V::P64 + 16];
           _sk6k::P64 = P64[_sk6V::P64 + 24];
           _sk6l::P64 = P64[_sk6V::P64 + 32];
           _sk6n::P64 = P64[_sk6V::P64 + 40];
           _sk6o::P64 = P64[_sk6V::P64 + 48];
           _sk6r::P64 = P64[_sk6V::P64 + 56];
           I64[Hp - 48] = eta_sk6w_info;
           P64[Hp - 32] = _sk6k::P64;
           P64[Hp - 24] = _sk6l::P64;
           P64[Hp - 16] = _sk6n::P64;
           P64[Hp - 8] = _sk6o::P64;
           P64[Hp] = _sk6r::P64;
           _cl7B::P64 = Hp - 48;
           I64[(young<cla6> + 8)] = cla6;
           R1 = _sk6j::P64;
           if (R1 & 7 != 0) goto cla6; else goto cla7;
       cla7:
           call (I64[R1])(R1) returns to cla6, args: 8, res: 8, upd: 8;
       cla6:
           _sk6U::P64 = R1;
           _clac::P64 = _sk6U::P64 & 7;
           switch [1 .. 2] _clac::P64 {
               case 1 : goto claa;
               case 2 : goto clab;
           }
       clab:
           R3 = _cl7B::P64;
           R2 = GHC.Show.shows16_closure;
           call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
       claa:
           R3 = _cl7B::P64;
           R2 = GHC.Show.shows17_closure;
           call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sk6W_entry() //  [R1]
         { info_tbl: [(clao,
                       label: sat_sk6W_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       clao:
           _sk6W::P64 = R1;
           goto cl7v;
       cl7v:
           if ((old + 0) - <highSp> < SpLim) goto clap; else goto claq;
       claq:
           Hp = Hp + 64;
           if (Hp > HpLim) goto clas; else goto clar;
       clas:
           HpAlloc = 64;
           goto clap;
       clap:
           R1 = _sk6W::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       clar:
           _sk6j::P64 = P64[_sk6W::P64 + 16];
           _sk6k::P64 = P64[_sk6W::P64 + 24];
           _sk6l::P64 = P64[_sk6W::P64 + 32];
           _sk6n::P64 = P64[_sk6W::P64 + 40];
           _sk6o::P64 = P64[_sk6W::P64 + 48];
           _sk6r::P64 = P64[_sk6W::P64 + 56];
           I64[Hp - 56] = sat_sk6V_info;
           P64[Hp - 40] = _sk6j::P64;
           P64[Hp - 32] = _sk6k::P64;
           P64[Hp - 24] = _sk6l::P64;
           P64[Hp - 16] = _sk6n::P64;
           P64[Hp - 8] = _sk6o::P64;
           P64[Hp] = _sk6r::P64;
           _cl7x::P64 = Hp - 56;
           R3 = _cl7x::P64;
           R2 = lvl8_rjV5_closure;
           call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sk6X_entry() //  [R1]
         { info_tbl: [(clat,
                       label: sat_sk6X_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       clat:
           _sk6X::P64 = R1;
           goto cl7r;
       cl7r:
           if ((old + 0) - <highSp> < SpLim) goto clau; else goto clav;
       clav:
           Hp = Hp + 64;
           if (Hp > HpLim) goto clax; else goto claw;
       clax:
           HpAlloc = 64;
           goto clau;
       clau:
           R1 = _sk6X::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       claw:
           I64[(old + 24)] = stg_upd_frame_info;
           P64[(old + 16)] = _sk6X::P64;
           _sk6j::P64 = P64[_sk6X::P64 + 16];
           _sk6k::P64 = P64[_sk6X::P64 + 24];
           _sk6l::P64 = P64[_sk6X::P64 + 32];
           _sk6n::P64 = P64[_sk6X::P64 + 40];
           _sk6o::P64 = P64[_sk6X::P64 + 48];
           _sk6r::P64 = P64[_sk6X::P64 + 56];
           I64[Hp - 56] = sat_sk6W_info;
           P64[Hp - 40] = _sk6j::P64;
           P64[Hp - 32] = _sk6k::P64;
           P64[Hp - 24] = _sk6l::P64;
           P64[Hp - 16] = _sk6n::P64;
           P64[Hp - 8] = _sk6o::P64;
           P64[Hp] = _sk6r::P64;
           _cl7t::P64 = Hp - 56;
           R3 = _cl7t::P64;
           R2 = lvl3_rjV0_closure;
           call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sk71_entry() //  [R1]
         { info_tbl: [(clay,
                       label: sat_sk71_info
                       rep:HeapRep 7 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       clay:
           _sk71::P64 = R1;
           goto cl7i;
       cl7i:
           if ((old + 0) - <highSp> < SpLim) goto claC; else goto claD;
       claD:
           if (HpLim == 0) goto claC; else goto claE;
       claC:
           R1 = _sk71::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       claE:
           _sk6i::P64 = P64[_sk71::P64 + 16];
           _sk6j::P64 = P64[_sk71::P64 + 24];
           _sk6k::P64 = P64[_sk71::P64 + 32];
           _sk6l::P64 = P64[_sk71::P64 + 40];
           _sk6n::P64 = P64[_sk71::P64 + 48];
           _sk6o::P64 = P64[_sk71::P64 + 56];
           _sk6r::P64 = P64[_sk71::P64 + 64];
           I64[(young<cl7k> + 8)] = cl7k;
           R1 = _sk6i::P64;
           if (R1 & 7 != 0) goto cl7k; else goto cl7l;
       cl7l:
           call (I64[R1])(R1) returns to cl7k, args: 8, res: 8, upd: 8;
       cl7k:
           _sk6u::P64 = R1;
           Hp = Hp + 64;
           if (Hp > HpLim) goto claH; else goto claG;
       claH:
           HpAlloc = 64;
           goto claF;
       claF:
           R1 = _sk6u::P64;
           call stg_gc_unpt_r1(R1) returns to cl7k, args: 8, res: 8, upd: 8;
       claG:
           _sk6v::I64 = I64[_sk6u::P64 + 7];
           I64[Hp - 56] = sat_sk6X_info;
           P64[Hp - 40] = _sk6j::P64;
           P64[Hp - 32] = _sk6k::P64;
           P64[Hp - 24] = _sk6l::P64;
           P64[Hp - 16] = _sk6n::P64;
           P64[Hp - 8] = _sk6o::P64;
           P64[Hp] = _sk6r::P64;
           _cl7p::P64 = Hp - 56;
           I64[(young<claz> + 8)] = claz;
           R4 = _cl7p::P64;
           R3 = _sk6v::I64;
           R2 = 0;
           call GHC.Show.$wshowSignedInt_info(R4,
                                              R3,
                                              R2) returns to claz, args: 8, res: 8, upd: 8;
       claz:
           _sk70::P64 = R2;
           _sk6Z::P64 = R1;
           Hp = Hp + 24;
           if (Hp > HpLim) goto claK; else goto claJ;
       claK:
           HpAlloc = 24;
           goto claI;
       claI:
           R2 = _sk70::P64;
           R1 = _sk6Z::P64;
           call stg_gc_pp(R2, R1) returns to claz, args: 8, res: 8, upd: 8;
       claJ:
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sk6Z::P64;
           P64[Hp] = _sk70::P64;
           _claB::P64 = Hp - 14;
           R1 = _claB::P64;
           call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sk72_entry() //  [R1]
         { info_tbl: [(claL,
                       label: sat_sk72_info
                       rep:HeapRep 7 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       claL:
           _sk72::P64 = R1;
           goto cl7e;
       cl7e:
           if ((old + 0) - <highSp> < SpLim) goto claM; else goto claN;
       claN:
           Hp = Hp + 72;
           if (Hp > HpLim) goto claP; else goto claO;
       claP:
           HpAlloc = 72;
           goto claM;
       claM:
           R1 = _sk72::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       claO:
           _sk6i::P64 = P64[_sk72::P64 + 16];
           _sk6j::P64 = P64[_sk72::P64 + 24];
           _sk6k::P64 = P64[_sk72::P64 + 32];
           _sk6l::P64 = P64[_sk72::P64 + 40];
           _sk6n::P64 = P64[_sk72::P64 + 48];
           _sk6o::P64 = P64[_sk72::P64 + 56];
           _sk6r::P64 = P64[_sk72::P64 + 64];
           I64[Hp - 64] = sat_sk71_info;
           P64[Hp - 48] = _sk6i::P64;
           P64[Hp - 40] = _sk6j::P64;
           P64[Hp - 32] = _sk6k::P64;
           P64[Hp - 24] = _sk6l::P64;
           P64[Hp - 16] = _sk6n::P64;
           P64[Hp - 8] = _sk6o::P64;
           P64[Hp] = _sk6r::P64;
           _cl7g::P64 = Hp - 64;
           R3 = _cl7g::P64;
           R2 = lvl9_rjV6_closure;
           call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sk73_entry() //  [R1]
         { info_tbl: [(claQ,
                       label: sat_sk73_info
                       rep:HeapRep 7 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       claQ:
           _sk73::P64 = R1;
           goto cl7a;
       cl7a:
           if ((old + 0) - <highSp> < SpLim) goto claR; else goto claS;
       claS:
           Hp = Hp + 72;
           if (Hp > HpLim) goto claU; else goto claT;
       claU:
           HpAlloc = 72;
           goto claR;
       claR:
           R1 = _sk73::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       claT:
           I64[(old + 24)] = stg_upd_frame_info;
           P64[(old + 16)] = _sk73::P64;
           _sk6i::P64 = P64[_sk73::P64 + 16];
           _sk6j::P64 = P64[_sk73::P64 + 24];
           _sk6k::P64 = P64[_sk73::P64 + 32];
           _sk6l::P64 = P64[_sk73::P64 + 40];
           _sk6n::P64 = P64[_sk73::P64 + 48];
           _sk6o::P64 = P64[_sk73::P64 + 56];
           _sk6r::P64 = P64[_sk73::P64 + 64];
           I64[Hp - 64] = sat_sk72_info;
           P64[Hp - 48] = _sk6i::P64;
           P64[Hp - 40] = _sk6j::P64;
           P64[Hp - 32] = _sk6k::P64;
           P64[Hp - 24] = _sk6l::P64;
           P64[Hp - 16] = _sk6n::P64;
           P64[Hp - 8] = _sk6o::P64;
           P64[Hp] = _sk6r::P64;
           _cl7c::P64 = Hp - 64;
           R3 = _cl7c::P64;
           R2 = lvl3_rjV0_closure;
           call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sk77_entry() //  [R1]
         { info_tbl: [(claV,
                       label: sat_sk77_info
                       rep:HeapRep 8 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       claV:
           _sk77::P64 = R1;
           goto cl71;
       cl71:
           if ((old + 0) - <highSp> < SpLim) goto claZ; else goto clb0;
       clb0:
           if (HpLim == 0) goto claZ; else goto clb1;
       claZ:
           R1 = _sk77::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       clb1:
           _sk6h::P64 = P64[_sk77::P64 + 16];
           _sk6i::P64 = P64[_sk77::P64 + 24];
           _sk6j::P64 = P64[_sk77::P64 + 32];
           _sk6k::P64 = P64[_sk77::P64 + 40];
           _sk6l::P64 = P64[_sk77::P64 + 48];
           _sk6n::P64 = P64[_sk77::P64 + 56];
           _sk6o::P64 = P64[_sk77::P64 + 64];
           _sk6r::P64 = P64[_sk77::P64 + 72];
           I64[(young<cl73> + 8)] = cl73;
           R1 = _sk6h::P64;
           if (R1 & 7 != 0) goto cl73; else goto cl74;
       cl74:
           call (I64[R1])(R1) returns to cl73, args: 8, res: 8, upd: 8;
       cl73:
           _sk6s::P64 = R1;
           Hp = Hp + 72;
           if (Hp > HpLim) goto clb4; else goto clb3;
       clb4:
           HpAlloc = 72;
           goto clb2;
       clb2:
           R1 = _sk6s::P64;
           call stg_gc_unpt_r1(R1) returns to cl73, args: 8, res: 8, upd: 8;
       clb3:
           _sk6t::I64 = I64[_sk6s::P64 + 7];
           I64[Hp - 64] = sat_sk73_info;
           P64[Hp - 48] = _sk6i::P64;
           P64[Hp - 40] = _sk6j::P64;
           P64[Hp - 32] = _sk6k::P64;
           P64[Hp - 24] = _sk6l::P64;
           P64[Hp - 16] = _sk6n::P64;
           P64[Hp - 8] = _sk6o::P64;
           P64[Hp] = _sk6r::P64;
           _cl78::P64 = Hp - 64;
           I64[(young<claW> + 8)] = claW;
           R3 = _cl78::P64;
           R2 = _sk6t::I64;
           call GHC.Show.$wshowWord_info(R3,
                                         R2) returns to claW, args: 8, res: 8, upd: 8;
       claW:
           _sk76::P64 = R2;
           _sk75::P64 = R1;
           Hp = Hp + 24;
           if (Hp > HpLim) goto clb7; else goto clb6;
       clb7:
           HpAlloc = 24;
           goto clb5;
       clb5:
           R2 = _sk76::P64;
           R1 = _sk75::P64;
           call stg_gc_pp(R2, R1) returns to claW, args: 8, res: 8, upd: 8;
       clb6:
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = _sk75::P64;
           P64[Hp] = _sk76::P64;
           _claY::P64 = Hp - 14;
           R1 = _claY::P64;
           call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sk78_entry() //  [R1]
         { info_tbl: [(clb8,
                       label: sat_sk78_info
                       rep:HeapRep 8 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       clb8:
           _sk78::P64 = R1;
           goto cl6X;
       cl6X:
           if ((old + 0) - <highSp> < SpLim) goto clb9; else goto clba;
       clba:
           Hp = Hp + 80;
           if (Hp > HpLim) goto clbc; else goto clbb;
       clbc:
           HpAlloc = 80;
           goto clb9;
       clb9:
           R1 = _sk78::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       clbb:
           _sk6h::P64 = P64[_sk78::P64 + 16];
           _sk6i::P64 = P64[_sk78::P64 + 24];
           _sk6j::P64 = P64[_sk78::P64 + 32];
           _sk6k::P64 = P64[_sk78::P64 + 40];
           _sk6l::P64 = P64[_sk78::P64 + 48];
           _sk6n::P64 = P64[_sk78::P64 + 56];
           _sk6o::P64 = P64[_sk78::P64 + 64];
           _sk6r::P64 = P64[_sk78::P64 + 72];
           I64[Hp - 72] = sat_sk77_info;
           P64[Hp - 56] = _sk6h::P64;
           P64[Hp - 48] = _sk6i::P64;
           P64[Hp - 40] = _sk6j::P64;
           P64[Hp - 32] = _sk6k::P64;
           P64[Hp - 24] = _sk6l::P64;
           P64[Hp - 16] = _sk6n::P64;
           P64[Hp - 8] = _sk6o::P64;
           P64[Hp] = _sk6r::P64;
           _cl6Z::P64 = Hp - 72;
           R3 = _cl6Z::P64;
           R2 = lvl10_rjV7_closure;
           call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sk79_entry() //  [R2, R1]
         { info_tbl: [(clbd,
                       label: sat_sk79_info
                       rep:HeapRep 7 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       clbd:
           _sk6r::P64 = R2;
           _sk79::P64 = R1;
           goto cl6T;
       cl6T:
           if ((old + 0) - <highSp> < SpLim) goto clbe; else goto clbf;
       clbf:
           goto cl6S;
       cl6S:
           Hp = Hp + 80;
           if (Hp > HpLim) goto clbh; else goto clbg;
       clbh:
           HpAlloc = 80;
           goto clbe;
       clbe:
           R2 = _sk6r::P64;
           R1 = _sk79::P64;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       clbg:
           _sk6h::P64 = P64[_sk79::P64 + 7];
           _sk6i::P64 = P64[_sk79::P64 + 15];
           _sk6j::P64 = P64[_sk79::P64 + 23];
           _sk6k::P64 = P64[_sk79::P64 + 31];
           _sk6l::P64 = P64[_sk79::P64 + 39];
           _sk6n::P64 = P64[_sk79::P64 + 47];
           _sk6o::P64 = P64[_sk79::P64 + 55];
           I64[Hp - 72] = sat_sk78_info;
           P64[Hp - 56] = _sk6h::P64;
           P64[Hp - 48] = _sk6i::P64;
           P64[Hp - 40] = _sk6j::P64;
           P64[Hp - 32] = _sk6k::P64;
           P64[Hp - 24] = _sk6l::P64;
           P64[Hp - 16] = _sk6n::P64;
           P64[Hp - 8] = _sk6o::P64;
           P64[Hp] = _sk6r::P64;
           _cl6V::P64 = Hp - 72;
           R3 = _cl6V::P64;
           R2 = lvl11_rjV8_closure;
           call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 Main.$w$cshowsPrec_entry() //  [R6, R5, R4, R3, R2]
         { info_tbl: [(clbi,
                       label: Main.$w$cshowsPrec_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 24 updfr_space: Just 8
         }
     {offset
       clbi:
           _sk6l::P64 = R6;
           _sk6k::P64 = R5;
           _sk6j::P64 = R4;
           _sk6i::P64 = R3;
           _sk6h::P64 = R2;
           _sk6m::P64 = P64[(old + 24)];
           _sk6n::P64 = P64[(old + 16)];
           goto cl6A;
       cl6A:
           if ((old + 0) - <highSp> < SpLim) goto clbj; else goto clbk;
       clbk:
           goto cl6z;
       cl6z:
           Hp = Hp + 88;
           if (Hp > HpLim) goto clbm; else goto clbl;
       clbm:
           HpAlloc = 88;
           goto clbj;
       clbj:
           R1 = Main.$w$cshowsPrec_closure;
           P64[(old + 64)] = _sk6h::P64;
           P64[(old + 56)] = _sk6i::P64;
           P64[(old + 48)] = _sk6j::P64;
           P64[(old + 40)] = _sk6k::P64;
           P64[(old + 32)] = _sk6l::P64;
           P64[(old + 24)] = _sk6m::P64;
           P64[(old + 16)] = _sk6n::P64;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       clbl:
           I64[Hp - 80] = f_sk6o_info;
           P64[Hp - 64] = _sk6m::P64;
           _cl6C::P64 = Hp - 80;
           I64[Hp - 56] = sat_sk79_info;
           P64[Hp - 48] = _sk6h::P64;
           P64[Hp - 40] = _sk6i::P64;
           P64[Hp - 32] = _sk6j::P64;
           P64[Hp - 24] = _sk6k::P64;
           P64[Hp - 16] = _sk6l::P64;
           P64[Hp - 8] = _sk6n::P64;
           P64[Hp] = _cl6C::P64;
           _cl6Q::P64 = Hp - 55;
           R1 = _cl6Q::P64;
           call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:55.294939 UTC

{offset
  cl5T:
      _rbVv::P64 = R1;
      _sk6h::P64 = P64[(old + 64)];
      _sk6i::P64 = P64[(old + 56)];
      _sk6j::P64 = P64[(old + 48)];
      _sk6k::P64 = P64[(old + 40)];
      _sk6l::P64 = P64[(old + 32)];
      _sk6m::P64 = P64[(old + 24)];
      _sk6n::P64 = P64[(old + 16)];
      R6 = _sk6l::P64;
      R5 = _sk6k::P64;
      R4 = _sk6j::P64;
      R3 = _sk6i::P64;
      R2 = _sk6h::P64;
      R1 = _rbVv::P64;
      P64[(old + 24)] = _sk6m::P64;
      P64[(old + 16)] = _sk6n::P64;
      call Main.$w$cshowsPrec_info(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2,
                                   R1) args: 24, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:55.296032 UTC

{offset
  cl5T:
      _rbVv::P64 = R1;
      _sk6h::P64 = P64[(old + 64)];
      _sk6i::P64 = P64[(old + 56)];
      _sk6j::P64 = P64[(old + 48)];
      _sk6k::P64 = P64[(old + 40)];
      _sk6l::P64 = P64[(old + 32)];
      _sk6m::P64 = P64[(old + 24)];
      _sk6n::P64 = P64[(old + 16)];
      R6 = _sk6l::P64;
      R5 = _sk6k::P64;
      R4 = _sk6j::P64;
      R3 = _sk6i::P64;
      R2 = _sk6h::P64;
      R1 = _rbVv::P64;
      P64[(old + 24)] = _sk6m::P64;
      P64[(old + 16)] = _sk6n::P64;
      call Main.$w$cshowsPrec_info(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2,
                                   R1) args: 24, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:55.297135 UTC

{offset
  cl5T:
      _rbVv::P64 = R1;
      _sk6h::P64 = P64[(old + 64)];
      _sk6i::P64 = P64[(old + 56)];
      _sk6j::P64 = P64[(old + 48)];
      _sk6k::P64 = P64[(old + 40)];
      _sk6l::P64 = P64[(old + 32)];
      _sk6m::P64 = P64[(old + 24)];
      _sk6n::P64 = P64[(old + 16)];
      R6 = _sk6l::P64;
      R5 = _sk6k::P64;
      R4 = _sk6j::P64;
      R3 = _sk6i::P64;
      R2 = _sk6h::P64;
      R1 = _rbVv::P64;
      P64[(old + 24)] = _sk6m::P64;
      P64[(old + 16)] = _sk6n::P64;
      call Main.$w$cshowsPrec_info(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2,
                                   R1) args: 24, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:55.298173 UTC

{offset
  cl5T:
      _rbVv::P64 = R1;
      _sk6h::P64 = P64[Sp];
      _sk6i::P64 = P64[Sp + 8];
      _sk6j::P64 = P64[Sp + 16];
      _sk6k::P64 = P64[Sp + 24];
      _sk6l::P64 = P64[Sp + 32];
      _sk6m::P64 = P64[Sp + 40];
      _sk6n::P64 = P64[Sp + 48];
      R6 = _sk6l::P64;
      R5 = _sk6k::P64;
      R4 = _sk6j::P64;
      R3 = _sk6i::P64;
      R2 = _sk6h::P64;
      R1 = _rbVv::P64;
      Sp = Sp + 40;
      call Main.$w$cshowsPrec_info(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2,
                                   R1) args: 24, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:55.299301 UTC

{offset
  cl5T:
      R6 = P64[Sp + 32];
      R5 = P64[Sp + 24];
      R4 = P64[Sp + 16];
      R3 = P64[Sp + 8];
      R2 = P64[Sp];
      R1 = R1;
      Sp = Sp + 40;
      call Main.$w$cshowsPrec_info(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2,
                                   R1) args: 24, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:55.300111 UTC

[(cl5T, {Main.$w$cshowsPrec_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:55.300385 UTC

Main.$w$cshowsPrec_slow() //  [R1]
        { info_tbl: []
          stack_info: arg_space: 64 updfr_space: Just 8
        }
    {offset
      cl5T:
          R6 = P64[Sp + 32];
          R5 = P64[Sp + 24];
          R4 = P64[Sp + 16];
          R3 = P64[Sp + 8];
          R2 = P64[Sp];
          R1 = R1;
          Sp = Sp + 40;
          call Main.$w$cshowsPrec_info(R6,
                                       R5,
                                       R4,
                                       R3,
                                       R2,
                                       R1) args: 24, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:55.301157 UTC

Main.$w$cshowsPrec_slow() //  [R1]
        { info_tbl: []
          stack_info: arg_space: 64 updfr_space: Just 8
        }
    {offset
      cl5T:
          R6 = P64[Sp + 32];
          R5 = P64[Sp + 24];
          R4 = P64[Sp + 16];
          R3 = P64[Sp + 8];
          R2 = P64[Sp];
          R1 = R1;
          Sp = Sp + 40;
          call Main.$w$cshowsPrec_info(R6,
                                       R5,
                                       R4,
                                       R3,
                                       R2,
                                       R1) args: 24, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:55.30195 UTC

{offset
  cl6J:
      _sk6o::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cl6K; else goto cl6L;
  cl6L:
      if (HpLim == 0) goto cl6K; else goto cl6M;
  cl6K:
      R1 = _sk6o::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cl6M:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sk6o::P64;
      _sk6m::P64 = P64[_sk6o::P64 + 16];
      I64[(young<cl6G> + 8)] = cl6G;
      R1 = _sk6m::P64;
      if (R1 & 7 != 0) goto cl6G; else goto cl6H;
  cl6H:
      call (I64[R1])(R1) returns to cl6G, args: 8, res: 8, upd: 24;
  cl6G:
      _sk6p::P64 = R1;
      _sk6q::F64 = F64[_sk6p::P64 + 7];
      D1 = _sk6q::F64;
      R3 = lvl4_rjV1_closure+1;
      R2 = GHC.Float.$fShowDouble_$sshowFloat_closure+1;
      call GHC.Float.$w$sshowSignedFloat_info(D1,
                                              R3,
                                              R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:55.303282 UTC

{offset
  cl6J:
      _sk6o::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cl6K; else goto cl6L;
  cl6L:
      if (HpLim == 0) goto cl6K; else goto cl6M;
  cl6K:
      R1 = _sk6o::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cl6M:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sk6o::P64;
      _sk6m::P64 = P64[_sk6o::P64 + 16];
      I64[(young<cl6G> + 8)] = cl6G;
      R1 = _sk6m::P64;
      if (R1 & 7 != 0) goto cl6G; else goto cl6H;
  cl6H:
      call (I64[R1])(R1) returns to cl6G, args: 8, res: 8, upd: 24;
  cl6G:
      _sk6p::P64 = R1;
      _sk6q::F64 = F64[_sk6p::P64 + 7];
      D1 = _sk6q::F64;
      R3 = lvl4_rjV1_closure+1;
      R2 = GHC.Float.$fShowDouble_$sshowFloat_closure+1;
      call GHC.Float.$w$sshowSignedFloat_info(D1,
                                              R3,
                                              R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:55.30464 UTC

{offset
  cl6J:
      _sk6o::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cl6K; else goto cl6L;
  cl6L:
      if (HpLim == 0) goto cl6K; else goto cl6M;
  cl6K:
      R1 = _sk6o::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cl6M:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sk6o::P64;
      _sk6m::P64 = P64[_sk6o::P64 + 16];
      I64[(young<cl6G> + 8)] = cl6G;
      R1 = _sk6m::P64;
      if (R1 & 7 != 0) goto cl6G; else goto cl6H;
  cl6H:
      call (I64[R1])(R1) returns to cl6G, args: 8, res: 8, upd: 24;
  cl6G:
      _sk6p::P64 = R1;
      _sk6q::F64 = F64[_sk6p::P64 + 7];
      D1 = _sk6q::F64;
      R3 = lvl4_rjV1_closure+1;
      R2 = GHC.Float.$fShowDouble_$sshowFloat_closure+1;
      call GHC.Float.$w$sshowSignedFloat_info(D1,
                                              R3,
                                              R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:55.306132 UTC

{offset
  cl6J:
      _sk6o::P64 = R1;
      if ((Sp + 8) - 32 < SpLim) goto cl6K; else goto cl6L;
  cl6L:
      if (HpLim == 0) goto cl6K; else goto cl6M;
  cl6K:
      R1 = _sk6o::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cl6M:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _sk6o::P64;
      _sk6m::P64 = P64[_sk6o::P64 + 16];
      I64[Sp - 24] = cl6G;
      R1 = _sk6m::P64;
      Sp = Sp - 24;
      if (R1 & 7 != 0) goto cl6G; else goto cl6H;
  cl6H:
      call (I64[R1])(R1) returns to cl6G, args: 8, res: 8, upd: 24;
  cl6G:
      _sk6p::P64 = R1;
      _sk6q::F64 = F64[_sk6p::P64 + 7];
      D1 = _sk6q::F64;
      R3 = lvl4_rjV1_closure+1;
      R2 = GHC.Float.$fShowDouble_$sshowFloat_closure+1;
      Sp = Sp + 8;
      call GHC.Float.$w$sshowSignedFloat_info(D1,
                                              R3,
                                              R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:55.307577 UTC

{offset
  cl6J:
      _sk6o::P64 = R1;
      if ((Sp + -24) < SpLim) goto cl6K; else goto cl6L;
  cl6L:
      if (HpLim == 0) goto cl6K; else goto cl6M;
  cl6K:
      R1 = _sk6o::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cl6M:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _sk6o::P64;
      I64[Sp - 24] = cl6G;
      R1 = P64[_sk6o::P64 + 16];
      Sp = Sp - 24;
      if (R1 & 7 != 0) goto cl6G; else goto cl6H;
  cl6H:
      call (I64[R1])(R1) returns to cl6G, args: 8, res: 8, upd: 24;
  cl6G:
      D1 = F64[R1 + 7];
      R3 = lvl4_rjV1_closure+1;
      R2 = GHC.Float.$fShowDouble_$sshowFloat_closure+1;
      Sp = Sp + 8;
      call GHC.Float.$w$sshowSignedFloat_info(D1,
                                              R3,
                                              R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:55.309056 UTC

[(cl6G, {GHC.Float.$fShowDouble_$sshowFloat_closure}),
 (cl6H, {GHC.Float.$fShowDouble_$sshowFloat_closure}),
 (cl6J, {GHC.Float.$fShowDouble_$sshowFloat_closure}), (cl6K, {}),
 (cl6L, {GHC.Float.$fShowDouble_$sshowFloat_closure}),
 (cl6M, {GHC.Float.$fShowDouble_$sshowFloat_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:55.309612 UTC

f_sk6o_entry() //  [R1]
        { info_tbl: [(cl6G,
                      label: block_cl6G_info
                      rep:StackRep []),
                     (cl6J,
                      label: f_sk6o_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cl6J:
          _sk6o::P64 = R1;
          if ((Sp + -24) < SpLim) goto cl6K; else goto cl6L;
      cl6L:
          if (HpLim == 0) goto cl6K; else goto cl6M;
      cl6K:
          R1 = _sk6o::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      cl6M:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _sk6o::P64;
          I64[Sp - 24] = cl6G;
          R1 = P64[_sk6o::P64 + 16];
          Sp = Sp - 24;
          if (R1 & 7 != 0) goto cl6G; else goto cl6H;
      cl6H:
          call (I64[R1])(R1) returns to cl6G, args: 8, res: 8, upd: 24;
      cl6G:
          D1 = F64[R1 + 7];
          R3 = lvl4_rjV1_closure+1;
          R2 = GHC.Float.$fShowDouble_$sshowFloat_closure+1;
          Sp = Sp + 8;
          call GHC.Float.$w$sshowSignedFloat_info(D1,
                                                  R3,
                                                  R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:55.311297 UTC

f_sk6o_entry() //  [R1]
        { info_tbl: [(cl6G,
                      label: block_cl6G_info
                      rep:StackRep []),
                     (cl6J,
                      label: f_sk6o_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cl6J:
          _sk6o::P64 = R1;
          if ((Sp + -24) < SpLim) goto cl6K; else goto cl6L;
      cl6L:
          if (HpLim == 0) goto cl6K; else goto cl6M;
      cl6K:
          R1 = _sk6o::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      cl6M:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _sk6o::P64;
          I64[Sp - 24] = cl6G;
          R1 = P64[_sk6o::P64 + 16];
          Sp = Sp - 24;
          if (R1 & 7 != 0) goto cl6G; else goto cl6H;
      cl6H:
          call (I64[R1])(R1) returns to cl6G, args: 8, res: 8, upd: 24;
      cl6G:
          D1 = F64[R1 + 7];
          R3 = lvl4_rjV1_closure+1;
          R2 = GHC.Float.$fShowDouble_$sshowFloat_closure+1;
          Sp = Sp + 8;
          call GHC.Float.$w$sshowSignedFloat_info(D1,
                                                  R3,
                                                  R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:55.312953 UTC

{offset
  cl8B:
      _sk6C::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cl8C; else goto cl8D;
  cl8D:
      if (HpLim == 0) goto cl8C; else goto cl8E;
  cl8C:
      R1 = _sk6C::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cl8E:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sk6C::P64;
      _sk6r::P64 = P64[_sk6C::P64 + 16];
      R3 = _sk6r::P64;
      R2 = lvl1_rjUY_closure;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:55.313847 UTC

{offset
  cl8B:
      _sk6C::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cl8C; else goto cl8D;
  cl8D:
      if (HpLim == 0) goto cl8C; else goto cl8E;
  cl8C:
      R1 = _sk6C::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cl8E:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sk6C::P64;
      _sk6r::P64 = P64[_sk6C::P64 + 16];
      R3 = _sk6r::P64;
      R2 = lvl1_rjUY_closure;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:55.314755 UTC

{offset
  cl8B:
      _sk6C::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cl8C; else goto cl8D;
  cl8D:
      if (HpLim == 0) goto cl8C; else goto cl8E;
  cl8C:
      R1 = _sk6C::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cl8E:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sk6C::P64;
      _sk6r::P64 = P64[_sk6C::P64 + 16];
      R3 = _sk6r::P64;
      R2 = lvl1_rjUY_closure;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:55.31571 UTC

{offset
  cl8B:
      _sk6C::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto cl8C; else goto cl8D;
  cl8D:
      if (HpLim == 0) goto cl8C; else goto cl8E;
  cl8C:
      R1 = _sk6C::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cl8E:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _sk6C::P64;
      _sk6r::P64 = P64[_sk6C::P64 + 16];
      R3 = _sk6r::P64;
      R2 = lvl1_rjUY_closure;
      Sp = Sp - 16;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:55.316639 UTC

{offset
  cl8B:
      _sk6C::P64 = R1;
      if ((Sp + -16) < SpLim) goto cl8C; else goto cl8D;
  cl8D:
      if (HpLim == 0) goto cl8C; else goto cl8E;
  cl8C:
      R1 = _sk6C::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cl8E:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _sk6C::P64;
      R3 = P64[_sk6C::P64 + 16];
      R2 = lvl1_rjUY_closure;
      Sp = Sp - 16;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:55.318592 UTC

[(cl8B, {lvl1_rjUY_closure}), (cl8C, {}),
 (cl8D, {lvl1_rjUY_closure}), (cl8E, {lvl1_rjUY_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:55.319019 UTC

sat_sk6C_entry() //  [R1]
        { info_tbl: [(cl8B,
                      label: sat_sk6C_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cl8B:
          _sk6C::P64 = R1;
          if ((Sp + -16) < SpLim) goto cl8C; else goto cl8D;
      cl8D:
          if (HpLim == 0) goto cl8C; else goto cl8E;
      cl8C:
          R1 = _sk6C::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      cl8E:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _sk6C::P64;
          R3 = P64[_sk6C::P64 + 16];
          R2 = lvl1_rjUY_closure;
          Sp = Sp - 16;
          call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:55.320205 UTC

sat_sk6C_entry() //  [R1]
        { info_tbl: [(cl8B,
                      label: sat_sk6C_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cl8B:
          _sk6C::P64 = R1;
          if ((Sp + -16) < SpLim) goto cl8C; else goto cl8D;
      cl8D:
          if (HpLim == 0) goto cl8C; else goto cl8E;
      cl8C:
          R1 = _sk6C::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      cl8E:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _sk6C::P64;
          R3 = P64[_sk6C::P64 + 16];
          R2 = lvl1_rjUY_closure;
          Sp = Sp - 16;
          call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:55.321312 UTC

{offset
  cl8F:
      _sk6G::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cl8J; else goto cl8K;
  cl8K:
      if (HpLim == 0) goto cl8J; else goto cl8L;
  cl8J:
      R1 = _sk6G::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cl8L:
      _sk6n::P64 = P64[_sk6G::P64 + 16];
      _sk6r::P64 = P64[_sk6G::P64 + 24];
      I64[(young<cl8s> + 8)] = cl8s;
      R1 = _sk6n::P64;
      if (R1 & 7 != 0) goto cl8s; else goto cl8t;
  cl8t:
      call (I64[R1])(R1) returns to cl8s, args: 8, res: 8, upd: 8;
  cl8s:
      _sk6A::P64 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto cl8O; else goto cl8N;
  cl8O:
      HpAlloc = 24;
      R1 = _sk6A::P64;
      call stg_gc_unpt_r1(R1) returns to cl8s, args: 8, res: 8, upd: 8;
  cl8N:
      _sk6B::I64 = I64[_sk6A::P64 + 7];
      I64[Hp - 16] = sat_sk6C_info;
      P64[Hp] = _sk6r::P64;
      _cl8x::P64 = Hp - 16;
      I64[(young<cl8G> + 8)] = cl8G;
      R4 = _cl8x::P64;
      R3 = _sk6B::I64;
      R2 = 0;
      call GHC.Show.$wshowSignedInt_info(R4,
                                         R3,
                                         R2) returns to cl8G, args: 8, res: 8, upd: 8;
  cl8G:
      _sk6F::P64 = R2;
      _sk6E::P64 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto cl8R; else goto cl8Q;
  cl8R:
      HpAlloc = 24;
      R2 = _sk6F::P64;
      R1 = _sk6E::P64;
      call stg_gc_pp(R2, R1) returns to cl8G, args: 8, res: 8, upd: 8;
  cl8Q:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _sk6E::P64;
      P64[Hp] = _sk6F::P64;
      _cl8I::P64 = Hp - 14;
      R1 = _cl8I::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:55.323702 UTC

{offset
  cl8F:
      _sk6G::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cl8J; else goto cl8K;
  cl8K:
      if (HpLim == 0) goto cl8J; else goto cl8L;
  cl8J:
      R1 = _sk6G::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cl8L:
      _sk6n::P64 = P64[_sk6G::P64 + 16];
      _sk6r::P64 = P64[_sk6G::P64 + 24];
      I64[(young<cl8s> + 8)] = cl8s;
      R1 = _sk6n::P64;
      if (R1 & 7 != 0) goto cl8s; else goto cl8t;
  cl8t:
      call (I64[R1])(R1) returns to cl8s, args: 8, res: 8, upd: 8;
  cl8s:
      _sk6A::P64 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto cl8O; else goto cl8N;
  cl8O:
      HpAlloc = 24;
      R1 = _sk6A::P64;
      call stg_gc_unpt_r1(R1) returns to cl8s, args: 8, res: 8, upd: 8;
  cl8N:
      _sk6B::I64 = I64[_sk6A::P64 + 7];
      I64[Hp - 16] = sat_sk6C_info;
      P64[Hp] = _sk6r::P64;
      _cl8x::P64 = Hp - 16;
      I64[(young<cl8G> + 8)] = cl8G;
      R4 = _cl8x::P64;
      R3 = _sk6B::I64;
      R2 = 0;
      call GHC.Show.$wshowSignedInt_info(R4,
                                         R3,
                                         R2) returns to cl8G, args: 8, res: 8, upd: 8;
  cl8G:
      _sk6F::P64 = R2;
      _sk6E::P64 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto cl8R; else goto cl8Q;
  cl8R:
      HpAlloc = 24;
      R2 = _sk6F::P64;
      R1 = _sk6E::P64;
      call stg_gc_pp(R2, R1) returns to cl8G, args: 8, res: 8, upd: 8;
  cl8Q:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _sk6E::P64;
      P64[Hp] = _sk6F::P64;
      _cl8I::P64 = Hp - 14;
      R1 = _cl8I::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:55.326125 UTC

{offset
  cl8F:
      _sk6G::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cl8J; else goto cl8K;
  cl8K:
      if (HpLim == 0) goto cl8J; else goto cl8L;
  cl8J:
      R1 = _sk6G::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cl8L:
      _sk6n::P64 = P64[_sk6G::P64 + 16];
      _sk6r::P64 = P64[_sk6G::P64 + 24];
      I64[(young<cl8s> + 8)] = cl8s;
      R1 = _sk6n::P64;
      if (R1 & 7 != 0) goto cl8s; else goto cl8t;
  cl8t:
      call (I64[R1])(R1) returns to cl8s, args: 8, res: 8, upd: 8;
  cl8s:
      _sk6A::P64 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto cl8O; else goto cl8N;
  cl8O:
      HpAlloc = 24;
      R1 = _sk6A::P64;
      call stg_gc_unpt_r1(R1) returns to cl8s, args: 8, res: 8, upd: 8;
  cl8N:
      _sk6B::I64 = I64[_sk6A::P64 + 7];
      I64[Hp - 16] = sat_sk6C_info;
      P64[Hp] = _sk6r::P64;
      _cl8x::P64 = Hp - 16;
      I64[(young<cl8G> + 8)] = cl8G;
      R4 = _cl8x::P64;
      R3 = _sk6B::I64;
      R2 = 0;
      call GHC.Show.$wshowSignedInt_info(R4,
                                         R3,
                                         R2) returns to cl8G, args: 8, res: 8, upd: 8;
  cl8G:
      _sk6F::P64 = R2;
      _sk6E::P64 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto cl8R; else goto cl8Q;
  cl8R:
      HpAlloc = 24;
      R2 = _sk6F::P64;
      R1 = _sk6E::P64;
      call stg_gc_pp(R2, R1) returns to cl8G, args: 8, res: 8, upd: 8;
  cl8Q:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _sk6E::P64;
      P64[Hp] = _sk6F::P64;
      _cl8I::P64 = Hp - 14;
      R1 = _cl8I::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:55.328884 UTC

{offset
  cl8F:
      _sk6G::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto cl8J; else goto cl8K;
  cl8K:
      if (HpLim == 0) goto cl8J; else goto cl8L;
  cl8J:
      R1 = _sk6G::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cl8L:
      _sk6n::P64 = P64[_sk6G::P64 + 16];
      _sk6r::P64 = P64[_sk6G::P64 + 24];
      I64[Sp - 16] = cl8s;
      R1 = _sk6n::P64;
      P64[Sp - 8] = _sk6r::P64;
      Sp = Sp - 16;
      if (R1 & 7 != 0) goto cl8s; else goto cl8t;
  cl8t:
      call (I64[R1])(R1) returns to cl8s, args: 8, res: 8, upd: 8;
  cl8s:
      _sk6r::P64 = P64[Sp + 8];
      _sk6A::P64 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto cl8O; else goto cl8N;
  cl8O:
      HpAlloc = 24;
      R1 = _sk6A::P64;
      call stg_gc_unpt_r1(R1) returns to cl8s, args: 8, res: 8, upd: 8;
  cl8N:
      _sk6B::I64 = I64[_sk6A::P64 + 7];
      I64[Hp - 16] = sat_sk6C_info;
      P64[Hp] = _sk6r::P64;
      _cl8x::P64 = Hp - 16;
      I64[Sp + 8] = cl8G;
      R4 = _cl8x::P64;
      R3 = _sk6B::I64;
      R2 = 0;
      Sp = Sp + 8;
      call GHC.Show.$wshowSignedInt_info(R4,
                                         R3,
                                         R2) returns to cl8G, args: 8, res: 8, upd: 8;
  cl8G:
      _sk6F::P64 = R2;
      _sk6E::P64 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto cl8R; else goto cl8Q;
  cl8R:
      HpAlloc = 24;
      R2 = _sk6F::P64;
      R1 = _sk6E::P64;
      call stg_gc_pp(R2, R1) returns to cl8G, args: 8, res: 8, upd: 8;
  cl8Q:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _sk6E::P64;
      P64[Hp] = _sk6F::P64;
      _cl8I::P64 = Hp - 14;
      R1 = _cl8I::P64;
      Sp = Sp + 8;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:55.331627 UTC

{offset
  cl8F:
      _sk6G::P64 = R1;
      if ((Sp + -16) < SpLim) goto cl8J; else goto cl8K;
  cl8K:
      if (HpLim == 0) goto cl8J; else goto cl8L;
  cl8J:
      R1 = _sk6G::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cl8L:
      I64[Sp - 16] = cl8s;
      R1 = P64[_sk6G::P64 + 16];
      P64[Sp - 8] = P64[_sk6G::P64 + 24];
      Sp = Sp - 16;
      if (R1 & 7 != 0) goto cl8s; else goto cl8t;
  cl8t:
      call (I64[R1])(R1) returns to cl8s, args: 8, res: 8, upd: 8;
  cl8s:
      Hp = Hp + 24;
      if (Hp > HpLim) goto cl8O; else goto cl8N;
  cl8O:
      HpAlloc = 24;
      R1 = R1;
      call stg_gc_unpt_r1(R1) returns to cl8s, args: 8, res: 8, upd: 8;
  cl8N:
      _sk6B::I64 = I64[R1 + 7];
      I64[Hp - 16] = sat_sk6C_info;
      P64[Hp] = P64[Sp + 8];
      I64[Sp + 8] = cl8G;
      R4 = Hp - 16;
      R3 = _sk6B::I64;
      R2 = 0;
      Sp = Sp + 8;
      call GHC.Show.$wshowSignedInt_info(R4,
                                         R3,
                                         R2) returns to cl8G, args: 8, res: 8, upd: 8;
  cl8G:
      Hp = Hp + 24;
      if (Hp > HpLim) goto cl8R; else goto cl8Q;
  cl8R:
      HpAlloc = 24;
      R2 = R2;
      R1 = R1;
      call stg_gc_pp(R2, R1) returns to cl8G, args: 8, res: 8, upd: 8;
  cl8Q:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = R1;
      P64[Hp] = R2;
      R1 = Hp - 14;
      Sp = Sp + 8;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:55.334315 UTC

[(cl8s, {sat_sk6C_closure}), (cl8t, {sat_sk6C_closure}),
 (cl8F, {sat_sk6C_closure}), (cl8G, {}), (cl8J, {}),
 (cl8K, {sat_sk6C_closure}), (cl8L, {sat_sk6C_closure}),
 (cl8N, {sat_sk6C_closure}), (cl8O, {sat_sk6C_closure}), (cl8Q, {}),
 (cl8R, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:55.335056 UTC

sat_sk6G_entry() //  [R1]
        { info_tbl: [(cl8s,
                      label: block_cl8s_info
                      rep:StackRep [False]),
                     (cl8F,
                      label: sat_sk6G_info
                      rep:HeapRep 2 ptrs { Thunk }),
                     (cl8G,
                      label: block_cl8G_info
                      rep:StackRep [])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cl8F:
          _sk6G::P64 = R1;
          if ((Sp + -16) < SpLim) goto cl8J; else goto cl8K;
      cl8K:
          if (HpLim == 0) goto cl8J; else goto cl8L;
      cl8J:
          R1 = _sk6G::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      cl8L:
          I64[Sp - 16] = cl8s;
          R1 = P64[_sk6G::P64 + 16];
          P64[Sp - 8] = P64[_sk6G::P64 + 24];
          Sp = Sp - 16;
          if (R1 & 7 != 0) goto cl8s; else goto cl8t;
      cl8t:
          call (I64[R1])(R1) returns to cl8s, args: 8, res: 8, upd: 8;
      cl8s:
          Hp = Hp + 24;
          if (Hp > HpLim) goto cl8O; else goto cl8N;
      cl8O:
          HpAlloc = 24;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to cl8s, args: 8, res: 8, upd: 8;
      cl8N:
          _sk6B::I64 = I64[R1 + 7];
          I64[Hp - 16] = sat_sk6C_info;
          P64[Hp] = P64[Sp + 8];
          I64[Sp + 8] = cl8G;
          R4 = Hp - 16;
          R3 = _sk6B::I64;
          R2 = 0;
          Sp = Sp + 8;
          call GHC.Show.$wshowSignedInt_info(R4,
                                             R3,
                                             R2) returns to cl8G, args: 8, res: 8, upd: 8;
      cl8G:
          Hp = Hp + 24;
          if (Hp > HpLim) goto cl8R; else goto cl8Q;
      cl8R:
          HpAlloc = 24;
          R2 = R2;
          R1 = R1;
          call stg_gc_pp(R2, R1) returns to cl8G, args: 8, res: 8, upd: 8;
      cl8Q:
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = R1;
          P64[Hp] = R2;
          R1 = Hp - 14;
          Sp = Sp + 8;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:55.33788 UTC

sat_sk6G_entry() //  [R1]
        { info_tbl: [(cl8s,
                      label: block_cl8s_info
                      rep:StackRep [False]),
                     (cl8F,
                      label: sat_sk6G_info
                      rep:HeapRep 2 ptrs { Thunk }),
                     (cl8G,
                      label: block_cl8G_info
                      rep:StackRep [])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cl8F:
          _sk6G::P64 = R1;
          if ((Sp + -16) < SpLim) goto cl8J; else goto cl8K;
      cl8K:
          if (HpLim == 0) goto cl8J; else goto cl8L;
      cl8J:
          R1 = _sk6G::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      cl8L:
          I64[Sp - 16] = cl8s;
          R1 = P64[_sk6G::P64 + 16];
          P64[Sp - 8] = P64[_sk6G::P64 + 24];
          Sp = Sp - 16;
          if (R1 & 7 != 0) goto cl8s; else goto cl8t;
      cl8t:
          call (I64[R1])(R1) returns to cl8s, args: 8, res: 8, upd: 8;
      cl8s:
          Hp = Hp + 24;
          if (Hp > HpLim) goto cl8O; else goto cl8N;
      cl8O:
          HpAlloc = 24;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to cl8s, args: 8, res: 8, upd: 8;
      cl8N:
          _sk6B::I64 = I64[R1 + 7];
          I64[Hp - 16] = sat_sk6C_info;
          P64[Hp] = P64[Sp + 8];
          I64[Sp + 8] = cl8G;
          R4 = Hp - 16;
          R3 = _sk6B::I64;
          R2 = 0;
          Sp = Sp + 8;
          call GHC.Show.$wshowSignedInt_info(R4,
                                             R3,
                                             R2) returns to cl8G, args: 8, res: 8, upd: 8;
      cl8G:
          Hp = Hp + 24;
          if (Hp > HpLim) goto cl8R; else goto cl8Q;
      cl8R:
          HpAlloc = 24;
          R2 = R2;
          R1 = R1;
          call stg_gc_pp(R2, R1) returns to cl8G, args: 8, res: 8, upd: 8;
      cl8Q:
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = R1;
          P64[Hp] = R2;
          R1 = Hp - 14;
          Sp = Sp + 8;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:55.340676 UTC

{offset
  cl8S:
      _sk6H::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cl8T; else goto cl8U;
  cl8U:
      Hp = Hp + 32;
      if (Hp > HpLim) goto cl8W; else goto cl8V;
  cl8W:
      HpAlloc = 32;
      goto cl8T;
  cl8T:
      R1 = _sk6H::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cl8V:
      _sk6n::P64 = P64[_sk6H::P64 + 16];
      _sk6r::P64 = P64[_sk6H::P64 + 24];
      I64[Hp - 24] = sat_sk6G_info;
      P64[Hp - 8] = _sk6n::P64;
      P64[Hp] = _sk6r::P64;
      _cl8o::P64 = Hp - 24;
      R3 = _cl8o::P64;
      R2 = lvl2_rjUZ_closure;
      call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:55.341842 UTC

{offset
  cl8S:
      _sk6H::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cl8T; else goto cl8U;
  cl8U:
      Hp = Hp + 32;
      if (Hp > HpLim) goto cl8W; else goto cl8V;
  cl8W:
      HpAlloc = 32;
      goto cl8T;
  cl8T:
      R1 = _sk6H::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cl8V:
      _sk6n::P64 = P64[_sk6H::P64 + 16];
      _sk6r::P64 = P64[_sk6H::P64 + 24];
      I64[Hp - 24] = sat_sk6G_info;
      P64[Hp - 8] = _sk6n::P64;
      P64[Hp] = _sk6r::P64;
      _cl8o::P64 = Hp - 24;
      R3 = _cl8o::P64;
      R2 = lvl2_rjUZ_closure;
      call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:55.343008 UTC

{offset
  cl8S:
      _sk6H::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cl8T; else goto cl8U;
  cl8U:
      Hp = Hp + 32;
      if (Hp > HpLim) goto cl8W; else goto cl8V;
  cl8W:
      HpAlloc = 32;
      goto cl8T;
  cl8T:
      R1 = _sk6H::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cl8V:
      _sk6n::P64 = P64[_sk6H::P64 + 16];
      _sk6r::P64 = P64[_sk6H::P64 + 24];
      I64[Hp - 24] = sat_sk6G_info;
      P64[Hp - 8] = _sk6n::P64;
      P64[Hp] = _sk6r::P64;
      _cl8o::P64 = Hp - 24;
      R3 = _cl8o::P64;
      R2 = lvl2_rjUZ_closure;
      call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:55.344214 UTC

{offset
  cl8S:
      _sk6H::P64 = R1;
      goto cl8U;
  cl8U:
      Hp = Hp + 32;
      if (Hp > HpLim) goto cl8W; else goto cl8V;
  cl8W:
      HpAlloc = 32;
      goto cl8T;
  cl8T:
      R1 = _sk6H::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cl8V:
      _sk6n::P64 = P64[_sk6H::P64 + 16];
      _sk6r::P64 = P64[_sk6H::P64 + 24];
      I64[Hp - 24] = sat_sk6G_info;
      P64[Hp - 8] = _sk6n::P64;
      P64[Hp] = _sk6r::P64;
      _cl8o::P64 = Hp - 24;
      R3 = _cl8o::P64;
      R2 = lvl2_rjUZ_closure;
      call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:55.345305 UTC

{offset
  cl8S:
      goto cl8U;
  cl8U:
      Hp = Hp + 32;
      if (Hp > HpLim) goto cl8W; else goto cl8V;
  cl8W:
      HpAlloc = 32;
      goto cl8T;
  cl8T:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cl8V:
      _sk6n::P64 = P64[R1 + 16];
      _sk6r::P64 = P64[R1 + 24];
      I64[Hp - 24] = sat_sk6G_info;
      P64[Hp - 8] = _sk6n::P64;
      P64[Hp] = _sk6r::P64;
      R3 = Hp - 24;
      R2 = lvl2_rjUZ_closure;
      call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:55.346506 UTC

[(cl8S, {lvl2_rjUZ_closure, sat_sk6G_closure}), (cl8T, {}),
 (cl8U, {lvl2_rjUZ_closure, sat_sk6G_closure}),
 (cl8V, {lvl2_rjUZ_closure, sat_sk6G_closure}), (cl8W, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:55.347051 UTC

sat_sk6H_entry() //  [R1]
        { info_tbl: [(cl8S,
                      label: sat_sk6H_info
                      rep:HeapRep 2 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cl8S:
          goto cl8U;
      cl8U:
          Hp = Hp + 32;
          if (Hp > HpLim) goto cl8W; else goto cl8V;
      cl8W:
          HpAlloc = 32;
          goto cl8T;
      cl8T:
          R1 = R1;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      cl8V:
          _sk6n::P64 = P64[R1 + 16];
          _sk6r::P64 = P64[R1 + 24];
          I64[Hp - 24] = sat_sk6G_info;
          P64[Hp - 8] = _sk6n::P64;
          P64[Hp] = _sk6r::P64;
          R3 = Hp - 24;
          R2 = lvl2_rjUZ_closure;
          call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:55.3483 UTC

sat_sk6H_entry() //  [R1]
        { info_tbl: [(cl8S,
                      label: sat_sk6H_info
                      rep:HeapRep 2 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cl8S:
          Hp = Hp + 32;
          if (Hp > HpLim) goto cl8W; else goto cl8V;
      cl8W:
          HpAlloc = 32;
          R1 = R1;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      cl8V:
          _sk6n::P64 = P64[R1 + 16];
          _sk6r::P64 = P64[R1 + 24];
          I64[Hp - 24] = sat_sk6G_info;
          P64[Hp - 8] = _sk6n::P64;
          P64[Hp] = _sk6r::P64;
          R3 = Hp - 24;
          R2 = lvl2_rjUZ_closure;
          call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:55.3495 UTC

{offset
  cl8X:
      _sk6I::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cl8Y; else goto cl8Z;
  cl8Z:
      Hp = Hp + 32;
      if (Hp > HpLim) goto cl91; else goto cl90;
  cl91:
      HpAlloc = 32;
      goto cl8Y;
  cl8Y:
      R1 = _sk6I::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cl90:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sk6I::P64;
      _sk6n::P64 = P64[_sk6I::P64 + 16];
      _sk6r::P64 = P64[_sk6I::P64 + 24];
      I64[Hp - 24] = sat_sk6H_info;
      P64[Hp - 8] = _sk6n::P64;
      P64[Hp] = _sk6r::P64;
      _cl8k::P64 = Hp - 24;
      R3 = _cl8k::P64;
      R2 = lvl3_rjV0_closure;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:55.350754 UTC

{offset
  cl8X:
      _sk6I::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cl8Y; else goto cl8Z;
  cl8Z:
      Hp = Hp + 32;
      if (Hp > HpLim) goto cl91; else goto cl90;
  cl91:
      HpAlloc = 32;
      goto cl8Y;
  cl8Y:
      R1 = _sk6I::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cl90:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sk6I::P64;
      _sk6n::P64 = P64[_sk6I::P64 + 16];
      _sk6r::P64 = P64[_sk6I::P64 + 24];
      I64[Hp - 24] = sat_sk6H_info;
      P64[Hp - 8] = _sk6n::P64;
      P64[Hp] = _sk6r::P64;
      _cl8k::P64 = Hp - 24;
      R3 = _cl8k::P64;
      R2 = lvl3_rjV0_closure;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:55.352004 UTC

{offset
  cl8X:
      _sk6I::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cl8Y; else goto cl8Z;
  cl8Z:
      Hp = Hp + 32;
      if (Hp > HpLim) goto cl91; else goto cl90;
  cl91:
      HpAlloc = 32;
      goto cl8Y;
  cl8Y:
      R1 = _sk6I::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cl90:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sk6I::P64;
      _sk6n::P64 = P64[_sk6I::P64 + 16];
      _sk6r::P64 = P64[_sk6I::P64 + 24];
      I64[Hp - 24] = sat_sk6H_info;
      P64[Hp - 8] = _sk6n::P64;
      P64[Hp] = _sk6r::P64;
      _cl8k::P64 = Hp - 24;
      R3 = _cl8k::P64;
      R2 = lvl3_rjV0_closure;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:55.353836 UTC

{offset
  cl8X:
      _sk6I::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto cl8Y; else goto cl8Z;
  cl8Z:
      Hp = Hp + 32;
      if (Hp > HpLim) goto cl91; else goto cl90;
  cl91:
      HpAlloc = 32;
      goto cl8Y;
  cl8Y:
      R1 = _sk6I::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cl90:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _sk6I::P64;
      _sk6n::P64 = P64[_sk6I::P64 + 16];
      _sk6r::P64 = P64[_sk6I::P64 + 24];
      I64[Hp - 24] = sat_sk6H_info;
      P64[Hp - 8] = _sk6n::P64;
      P64[Hp] = _sk6r::P64;
      _cl8k::P64 = Hp - 24;
      R3 = _cl8k::P64;
      R2 = lvl3_rjV0_closure;
      Sp = Sp - 16;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:55.35512 UTC

{offset
  cl8X:
      _sk6I::P64 = R1;
      if ((Sp + -16) < SpLim) goto cl8Y; else goto cl8Z;
  cl8Z:
      Hp = Hp + 32;
      if (Hp > HpLim) goto cl91; else goto cl90;
  cl91:
      HpAlloc = 32;
      goto cl8Y;
  cl8Y:
      R1 = _sk6I::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cl90:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _sk6I::P64;
      _sk6n::P64 = P64[_sk6I::P64 + 16];
      _sk6r::P64 = P64[_sk6I::P64 + 24];
      I64[Hp - 24] = sat_sk6H_info;
      P64[Hp - 8] = _sk6n::P64;
      P64[Hp] = _sk6r::P64;
      R3 = Hp - 24;
      R2 = lvl3_rjV0_closure;
      Sp = Sp - 16;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:55.35649 UTC

[(cl8X, {lvl3_rjV0_closure, sat_sk6H_closure}), (cl8Y, {}),
 (cl8Z, {lvl3_rjV0_closure, sat_sk6H_closure}),
 (cl90, {lvl3_rjV0_closure, sat_sk6H_closure}), (cl91, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:55.357028 UTC

sat_sk6I_entry() //  [R1]
        { info_tbl: [(cl8X,
                      label: sat_sk6I_info
                      rep:HeapRep 2 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cl8X:
          _sk6I::P64 = R1;
          if ((Sp + -16) < SpLim) goto cl8Y; else goto cl8Z;
      cl8Z:
          Hp = Hp + 32;
          if (Hp > HpLim) goto cl91; else goto cl90;
      cl91:
          HpAlloc = 32;
          goto cl8Y;
      cl8Y:
          R1 = _sk6I::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      cl90:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _sk6I::P64;
          _sk6n::P64 = P64[_sk6I::P64 + 16];
          _sk6r::P64 = P64[_sk6I::P64 + 24];
          I64[Hp - 24] = sat_sk6H_info;
          P64[Hp - 8] = _sk6n::P64;
          P64[Hp] = _sk6r::P64;
          R3 = Hp - 24;
          R2 = lvl3_rjV0_closure;
          Sp = Sp - 16;
          call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:55.358516 UTC

sat_sk6I_entry() //  [R1]
        { info_tbl: [(cl8X,
                      label: sat_sk6I_info
                      rep:HeapRep 2 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cl8X:
          _sk6I::P64 = R1;
          if ((Sp + -16) < SpLim) goto cl8Y; else goto cl8Z;
      cl8Z:
          Hp = Hp + 32;
          if (Hp > HpLim) goto cl91; else goto cl90;
      cl91:
          HpAlloc = 32;
          goto cl8Y;
      cl8Y:
          R1 = _sk6I::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      cl90:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _sk6I::P64;
          _sk6n::P64 = P64[_sk6I::P64 + 16];
          _sk6r::P64 = P64[_sk6I::P64 + 24];
          I64[Hp - 24] = sat_sk6H_info;
          P64[Hp - 8] = _sk6n::P64;
          P64[Hp] = _sk6r::P64;
          R3 = Hp - 24;
          R2 = lvl3_rjV0_closure;
          Sp = Sp - 16;
          call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:55.360135 UTC

{offset
  cl92:
      _sk6J::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cl93; else goto cl94;
  cl94:
      Hp = Hp + 32;
      if (Hp > HpLim) goto cl96; else goto cl95;
  cl96:
      HpAlloc = 32;
      goto cl93;
  cl93:
      R1 = _sk6J::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cl95:
      _sk6n::P64 = P64[_sk6J::P64 + 16];
      _sk6o::P64 = P64[_sk6J::P64 + 24];
      _sk6r::P64 = P64[_sk6J::P64 + 32];
      I64[Hp - 24] = sat_sk6I_info;
      P64[Hp - 8] = _sk6n::P64;
      P64[Hp] = _sk6r::P64;
      _cl8g::P64 = Hp - 24;
      R2 = _cl8g::P64;
      R1 = _sk6o::P64;
      call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:55.361314 UTC

{offset
  cl92:
      _sk6J::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cl93; else goto cl94;
  cl94:
      Hp = Hp + 32;
      if (Hp > HpLim) goto cl96; else goto cl95;
  cl96:
      HpAlloc = 32;
      goto cl93;
  cl93:
      R1 = _sk6J::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cl95:
      _sk6n::P64 = P64[_sk6J::P64 + 16];
      _sk6o::P64 = P64[_sk6J::P64 + 24];
      _sk6r::P64 = P64[_sk6J::P64 + 32];
      I64[Hp - 24] = sat_sk6I_info;
      P64[Hp - 8] = _sk6n::P64;
      P64[Hp] = _sk6r::P64;
      _cl8g::P64 = Hp - 24;
      R2 = _cl8g::P64;
      R1 = _sk6o::P64;
      call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:55.362505 UTC

{offset
  cl92:
      _sk6J::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cl93; else goto cl94;
  cl94:
      Hp = Hp + 32;
      if (Hp > HpLim) goto cl96; else goto cl95;
  cl96:
      HpAlloc = 32;
      goto cl93;
  cl93:
      R1 = _sk6J::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cl95:
      _sk6n::P64 = P64[_sk6J::P64 + 16];
      _sk6o::P64 = P64[_sk6J::P64 + 24];
      _sk6r::P64 = P64[_sk6J::P64 + 32];
      I64[Hp - 24] = sat_sk6I_info;
      P64[Hp - 8] = _sk6n::P64;
      P64[Hp] = _sk6r::P64;
      _cl8g::P64 = Hp - 24;
      R2 = _cl8g::P64;
      R1 = _sk6o::P64;
      call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:55.363743 UTC

{offset
  cl92:
      _sk6J::P64 = R1;
      goto cl94;
  cl94:
      Hp = Hp + 32;
      if (Hp > HpLim) goto cl96; else goto cl95;
  cl96:
      HpAlloc = 32;
      goto cl93;
  cl93:
      R1 = _sk6J::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cl95:
      _sk6n::P64 = P64[_sk6J::P64 + 16];
      _sk6o::P64 = P64[_sk6J::P64 + 24];
      _sk6r::P64 = P64[_sk6J::P64 + 32];
      I64[Hp - 24] = sat_sk6I_info;
      P64[Hp - 8] = _sk6n::P64;
      P64[Hp] = _sk6r::P64;
      _cl8g::P64 = Hp - 24;
      R2 = _cl8g::P64;
      R1 = _sk6o::P64;
      call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:55.364854 UTC

{offset
  cl92:
      goto cl94;
  cl94:
      Hp = Hp + 32;
      if (Hp > HpLim) goto cl96; else goto cl95;
  cl96:
      HpAlloc = 32;
      goto cl93;
  cl93:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cl95:
      _sk6n::P64 = P64[R1 + 16];
      _sk6o::P64 = P64[R1 + 24];
      _sk6r::P64 = P64[R1 + 32];
      I64[Hp - 24] = sat_sk6I_info;
      P64[Hp - 8] = _sk6n::P64;
      P64[Hp] = _sk6r::P64;
      R2 = Hp - 24;
      R1 = _sk6o::P64;
      call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:55.366054 UTC

[(cl92, {sat_sk6I_closure}), (cl93, {}),
 (cl94, {sat_sk6I_closure}), (cl95, {sat_sk6I_closure}), (cl96, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:55.366482 UTC

sat_sk6J_entry() //  [R1]
        { info_tbl: [(cl92,
                      label: sat_sk6J_info
                      rep:HeapRep 3 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cl92:
          goto cl94;
      cl94:
          Hp = Hp + 32;
          if (Hp > HpLim) goto cl96; else goto cl95;
      cl96:
          HpAlloc = 32;
          goto cl93;
      cl93:
          R1 = R1;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      cl95:
          _sk6n::P64 = P64[R1 + 16];
          _sk6o::P64 = P64[R1 + 24];
          _sk6r::P64 = P64[R1 + 32];
          I64[Hp - 24] = sat_sk6I_info;
          P64[Hp - 8] = _sk6n::P64;
          P64[Hp] = _sk6r::P64;
          R2 = Hp - 24;
          R1 = _sk6o::P64;
          call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:55.367769 UTC

sat_sk6J_entry() //  [R1]
        { info_tbl: [(cl92,
                      label: sat_sk6J_info
                      rep:HeapRep 3 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cl92:
          Hp = Hp + 32;
          if (Hp > HpLim) goto cl96; else goto cl95;
      cl96:
          HpAlloc = 32;
          R1 = R1;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      cl95:
          _sk6n::P64 = P64[R1 + 16];
          _sk6o::P64 = P64[R1 + 24];
          _sk6r::P64 = P64[R1 + 32];
          I64[Hp - 24] = sat_sk6I_info;
          P64[Hp - 8] = _sk6n::P64;
          P64[Hp] = _sk6r::P64;
          R2 = Hp - 24;
          R1 = _sk6o::P64;
          call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:55.368971 UTC

{offset
  cl97:
      _sk6K::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cl98; else goto cl99;
  cl99:
      Hp = Hp + 40;
      if (Hp > HpLim) goto cl9b; else goto cl9a;
  cl9b:
      HpAlloc = 40;
      goto cl98;
  cl98:
      R1 = _sk6K::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cl9a:
      _sk6n::P64 = P64[_sk6K::P64 + 16];
      _sk6o::P64 = P64[_sk6K::P64 + 24];
      _sk6r::P64 = P64[_sk6K::P64 + 32];
      I64[Hp - 32] = sat_sk6J_info;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      _cl8c::P64 = Hp - 32;
      R3 = _cl8c::P64;
      R2 = lvl5_rjV2_closure;
      call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:55.37023 UTC

{offset
  cl97:
      _sk6K::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cl98; else goto cl99;
  cl99:
      Hp = Hp + 40;
      if (Hp > HpLim) goto cl9b; else goto cl9a;
  cl9b:
      HpAlloc = 40;
      goto cl98;
  cl98:
      R1 = _sk6K::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cl9a:
      _sk6n::P64 = P64[_sk6K::P64 + 16];
      _sk6o::P64 = P64[_sk6K::P64 + 24];
      _sk6r::P64 = P64[_sk6K::P64 + 32];
      I64[Hp - 32] = sat_sk6J_info;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      _cl8c::P64 = Hp - 32;
      R3 = _cl8c::P64;
      R2 = lvl5_rjV2_closure;
      call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:55.371477 UTC

{offset
  cl97:
      _sk6K::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cl98; else goto cl99;
  cl99:
      Hp = Hp + 40;
      if (Hp > HpLim) goto cl9b; else goto cl9a;
  cl9b:
      HpAlloc = 40;
      goto cl98;
  cl98:
      R1 = _sk6K::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cl9a:
      _sk6n::P64 = P64[_sk6K::P64 + 16];
      _sk6o::P64 = P64[_sk6K::P64 + 24];
      _sk6r::P64 = P64[_sk6K::P64 + 32];
      I64[Hp - 32] = sat_sk6J_info;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      _cl8c::P64 = Hp - 32;
      R3 = _cl8c::P64;
      R2 = lvl5_rjV2_closure;
      call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:55.372783 UTC

{offset
  cl97:
      _sk6K::P64 = R1;
      goto cl99;
  cl99:
      Hp = Hp + 40;
      if (Hp > HpLim) goto cl9b; else goto cl9a;
  cl9b:
      HpAlloc = 40;
      goto cl98;
  cl98:
      R1 = _sk6K::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cl9a:
      _sk6n::P64 = P64[_sk6K::P64 + 16];
      _sk6o::P64 = P64[_sk6K::P64 + 24];
      _sk6r::P64 = P64[_sk6K::P64 + 32];
      I64[Hp - 32] = sat_sk6J_info;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      _cl8c::P64 = Hp - 32;
      R3 = _cl8c::P64;
      R2 = lvl5_rjV2_closure;
      call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:55.373962 UTC

{offset
  cl97:
      goto cl99;
  cl99:
      Hp = Hp + 40;
      if (Hp > HpLim) goto cl9b; else goto cl9a;
  cl9b:
      HpAlloc = 40;
      goto cl98;
  cl98:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cl9a:
      _sk6n::P64 = P64[R1 + 16];
      _sk6o::P64 = P64[R1 + 24];
      _sk6r::P64 = P64[R1 + 32];
      I64[Hp - 32] = sat_sk6J_info;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      R3 = Hp - 32;
      R2 = lvl5_rjV2_closure;
      call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:55.375234 UTC

[(cl97, {lvl5_rjV2_closure, sat_sk6J_closure}), (cl98, {}),
 (cl99, {lvl5_rjV2_closure, sat_sk6J_closure}),
 (cl9a, {lvl5_rjV2_closure, sat_sk6J_closure}), (cl9b, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:55.375752 UTC

sat_sk6K_entry() //  [R1]
        { info_tbl: [(cl97,
                      label: sat_sk6K_info
                      rep:HeapRep 3 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cl97:
          goto cl99;
      cl99:
          Hp = Hp + 40;
          if (Hp > HpLim) goto cl9b; else goto cl9a;
      cl9b:
          HpAlloc = 40;
          goto cl98;
      cl98:
          R1 = R1;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      cl9a:
          _sk6n::P64 = P64[R1 + 16];
          _sk6o::P64 = P64[R1 + 24];
          _sk6r::P64 = P64[R1 + 32];
          I64[Hp - 32] = sat_sk6J_info;
          P64[Hp - 16] = _sk6n::P64;
          P64[Hp - 8] = _sk6o::P64;
          P64[Hp] = _sk6r::P64;
          R3 = Hp - 32;
          R2 = lvl5_rjV2_closure;
          call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:55.377102 UTC

sat_sk6K_entry() //  [R1]
        { info_tbl: [(cl97,
                      label: sat_sk6K_info
                      rep:HeapRep 3 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cl97:
          Hp = Hp + 40;
          if (Hp > HpLim) goto cl9b; else goto cl9a;
      cl9b:
          HpAlloc = 40;
          R1 = R1;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      cl9a:
          _sk6n::P64 = P64[R1 + 16];
          _sk6o::P64 = P64[R1 + 24];
          _sk6r::P64 = P64[R1 + 32];
          I64[Hp - 32] = sat_sk6J_info;
          P64[Hp - 16] = _sk6n::P64;
          P64[Hp - 8] = _sk6o::P64;
          P64[Hp] = _sk6r::P64;
          R3 = Hp - 32;
          R2 = lvl5_rjV2_closure;
          call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:55.378853 UTC

{offset
  cl9c:
      _sk6L::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cl9d; else goto cl9e;
  cl9e:
      Hp = Hp + 40;
      if (Hp > HpLim) goto cl9g; else goto cl9f;
  cl9g:
      HpAlloc = 40;
      goto cl9d;
  cl9d:
      R1 = _sk6L::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cl9f:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sk6L::P64;
      _sk6n::P64 = P64[_sk6L::P64 + 16];
      _sk6o::P64 = P64[_sk6L::P64 + 24];
      _sk6r::P64 = P64[_sk6L::P64 + 32];
      I64[Hp - 32] = sat_sk6K_info;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      _cl88::P64 = Hp - 32;
      R3 = _cl88::P64;
      R2 = lvl3_rjV0_closure;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:55.380312 UTC

{offset
  cl9c:
      _sk6L::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cl9d; else goto cl9e;
  cl9e:
      Hp = Hp + 40;
      if (Hp > HpLim) goto cl9g; else goto cl9f;
  cl9g:
      HpAlloc = 40;
      goto cl9d;
  cl9d:
      R1 = _sk6L::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cl9f:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sk6L::P64;
      _sk6n::P64 = P64[_sk6L::P64 + 16];
      _sk6o::P64 = P64[_sk6L::P64 + 24];
      _sk6r::P64 = P64[_sk6L::P64 + 32];
      I64[Hp - 32] = sat_sk6K_info;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      _cl88::P64 = Hp - 32;
      R3 = _cl88::P64;
      R2 = lvl3_rjV0_closure;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:55.381672 UTC

{offset
  cl9c:
      _sk6L::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cl9d; else goto cl9e;
  cl9e:
      Hp = Hp + 40;
      if (Hp > HpLim) goto cl9g; else goto cl9f;
  cl9g:
      HpAlloc = 40;
      goto cl9d;
  cl9d:
      R1 = _sk6L::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cl9f:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sk6L::P64;
      _sk6n::P64 = P64[_sk6L::P64 + 16];
      _sk6o::P64 = P64[_sk6L::P64 + 24];
      _sk6r::P64 = P64[_sk6L::P64 + 32];
      I64[Hp - 32] = sat_sk6K_info;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      _cl88::P64 = Hp - 32;
      R3 = _cl88::P64;
      R2 = lvl3_rjV0_closure;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:55.383067 UTC

{offset
  cl9c:
      _sk6L::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto cl9d; else goto cl9e;
  cl9e:
      Hp = Hp + 40;
      if (Hp > HpLim) goto cl9g; else goto cl9f;
  cl9g:
      HpAlloc = 40;
      goto cl9d;
  cl9d:
      R1 = _sk6L::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cl9f:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _sk6L::P64;
      _sk6n::P64 = P64[_sk6L::P64 + 16];
      _sk6o::P64 = P64[_sk6L::P64 + 24];
      _sk6r::P64 = P64[_sk6L::P64 + 32];
      I64[Hp - 32] = sat_sk6K_info;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      _cl88::P64 = Hp - 32;
      R3 = _cl88::P64;
      R2 = lvl3_rjV0_closure;
      Sp = Sp - 16;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:55.384433 UTC

{offset
  cl9c:
      _sk6L::P64 = R1;
      if ((Sp + -16) < SpLim) goto cl9d; else goto cl9e;
  cl9e:
      Hp = Hp + 40;
      if (Hp > HpLim) goto cl9g; else goto cl9f;
  cl9g:
      HpAlloc = 40;
      goto cl9d;
  cl9d:
      R1 = _sk6L::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cl9f:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _sk6L::P64;
      _sk6n::P64 = P64[_sk6L::P64 + 16];
      _sk6o::P64 = P64[_sk6L::P64 + 24];
      _sk6r::P64 = P64[_sk6L::P64 + 32];
      I64[Hp - 32] = sat_sk6K_info;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      R3 = Hp - 32;
      R2 = lvl3_rjV0_closure;
      Sp = Sp - 16;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:55.385922 UTC

[(cl9c, {lvl3_rjV0_closure, sat_sk6K_closure}), (cl9d, {}),
 (cl9e, {lvl3_rjV0_closure, sat_sk6K_closure}),
 (cl9f, {lvl3_rjV0_closure, sat_sk6K_closure}), (cl9g, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:55.386453 UTC

sat_sk6L_entry() //  [R1]
        { info_tbl: [(cl9c,
                      label: sat_sk6L_info
                      rep:HeapRep 3 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cl9c:
          _sk6L::P64 = R1;
          if ((Sp + -16) < SpLim) goto cl9d; else goto cl9e;
      cl9e:
          Hp = Hp + 40;
          if (Hp > HpLim) goto cl9g; else goto cl9f;
      cl9g:
          HpAlloc = 40;
          goto cl9d;
      cl9d:
          R1 = _sk6L::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      cl9f:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _sk6L::P64;
          _sk6n::P64 = P64[_sk6L::P64 + 16];
          _sk6o::P64 = P64[_sk6L::P64 + 24];
          _sk6r::P64 = P64[_sk6L::P64 + 32];
          I64[Hp - 32] = sat_sk6K_info;
          P64[Hp - 16] = _sk6n::P64;
          P64[Hp - 8] = _sk6o::P64;
          P64[Hp] = _sk6r::P64;
          R3 = Hp - 32;
          R2 = lvl3_rjV0_closure;
          Sp = Sp - 16;
          call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:55.388052 UTC

sat_sk6L_entry() //  [R1]
        { info_tbl: [(cl9c,
                      label: sat_sk6L_info
                      rep:HeapRep 3 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cl9c:
          _sk6L::P64 = R1;
          if ((Sp + -16) < SpLim) goto cl9d; else goto cl9e;
      cl9e:
          Hp = Hp + 40;
          if (Hp > HpLim) goto cl9g; else goto cl9f;
      cl9g:
          HpAlloc = 40;
          goto cl9d;
      cl9d:
          R1 = _sk6L::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      cl9f:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _sk6L::P64;
          _sk6n::P64 = P64[_sk6L::P64 + 16];
          _sk6o::P64 = P64[_sk6L::P64 + 24];
          _sk6r::P64 = P64[_sk6L::P64 + 32];
          I64[Hp - 32] = sat_sk6K_info;
          P64[Hp - 16] = _sk6n::P64;
          P64[Hp - 8] = _sk6o::P64;
          P64[Hp] = _sk6r::P64;
          R3 = Hp - 32;
          R2 = lvl3_rjV0_closure;
          Sp = Sp - 16;
          call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:55.389693 UTC

{offset
  cl9h:
      _sk6P::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cl9l; else goto cl9m;
  cl9m:
      if (HpLim == 0) goto cl9l; else goto cl9n;
  cl9l:
      R1 = _sk6P::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cl9n:
      _sk6l::P64 = P64[_sk6P::P64 + 16];
      _sk6n::P64 = P64[_sk6P::P64 + 24];
      _sk6o::P64 = P64[_sk6P::P64 + 32];
      _sk6r::P64 = P64[_sk6P::P64 + 40];
      I64[(young<cl7Z> + 8)] = cl7Z;
      R1 = _sk6l::P64;
      if (R1 & 7 != 0) goto cl7Z; else goto cl80;
  cl80:
      call (I64[R1])(R1) returns to cl7Z, args: 8, res: 8, upd: 8;
  cl7Z:
      _sk6y::P64 = R1;
      Hp = Hp + 40;
      if (Hp > HpLim) goto cl9q; else goto cl9p;
  cl9q:
      HpAlloc = 40;
      R1 = _sk6y::P64;
      call stg_gc_unpt_r1(R1) returns to cl7Z, args: 8, res: 8, upd: 8;
  cl9p:
      _sk6z::I64 = I64[_sk6y::P64 + 7];
      I64[Hp - 32] = sat_sk6L_info;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      _cl84::P64 = Hp - 32;
      I64[(young<cl9i> + 8)] = cl9i;
      R4 = _cl84::P64;
      R3 = _sk6z::I64;
      R2 = 0;
      call GHC.Show.$wshowSignedInt_info(R4,
                                         R3,
                                         R2) returns to cl9i, args: 8, res: 8, upd: 8;
  cl9i:
      _sk6O::P64 = R2;
      _sk6N::P64 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto cl9t; else goto cl9s;
  cl9t:
      HpAlloc = 24;
      R2 = _sk6O::P64;
      R1 = _sk6N::P64;
      call stg_gc_pp(R2, R1) returns to cl9i, args: 8, res: 8, upd: 8;
  cl9s:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _sk6N::P64;
      P64[Hp] = _sk6O::P64;
      _cl9k::P64 = Hp - 14;
      R1 = _cl9k::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:55.392337 UTC

{offset
  cl9h:
      _sk6P::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cl9l; else goto cl9m;
  cl9m:
      if (HpLim == 0) goto cl9l; else goto cl9n;
  cl9l:
      R1 = _sk6P::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cl9n:
      _sk6l::P64 = P64[_sk6P::P64 + 16];
      _sk6n::P64 = P64[_sk6P::P64 + 24];
      _sk6o::P64 = P64[_sk6P::P64 + 32];
      _sk6r::P64 = P64[_sk6P::P64 + 40];
      I64[(young<cl7Z> + 8)] = cl7Z;
      R1 = _sk6l::P64;
      if (R1 & 7 != 0) goto cl7Z; else goto cl80;
  cl80:
      call (I64[R1])(R1) returns to cl7Z, args: 8, res: 8, upd: 8;
  cl7Z:
      _sk6y::P64 = R1;
      Hp = Hp + 40;
      if (Hp > HpLim) goto cl9q; else goto cl9p;
  cl9q:
      HpAlloc = 40;
      R1 = _sk6y::P64;
      call stg_gc_unpt_r1(R1) returns to cl7Z, args: 8, res: 8, upd: 8;
  cl9p:
      _sk6z::I64 = I64[_sk6y::P64 + 7];
      I64[Hp - 32] = sat_sk6L_info;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      _cl84::P64 = Hp - 32;
      I64[(young<cl9i> + 8)] = cl9i;
      R4 = _cl84::P64;
      R3 = _sk6z::I64;
      R2 = 0;
      call GHC.Show.$wshowSignedInt_info(R4,
                                         R3,
                                         R2) returns to cl9i, args: 8, res: 8, upd: 8;
  cl9i:
      _sk6O::P64 = R2;
      _sk6N::P64 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto cl9t; else goto cl9s;
  cl9t:
      HpAlloc = 24;
      R2 = _sk6O::P64;
      R1 = _sk6N::P64;
      call stg_gc_pp(R2, R1) returns to cl9i, args: 8, res: 8, upd: 8;
  cl9s:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _sk6N::P64;
      P64[Hp] = _sk6O::P64;
      _cl9k::P64 = Hp - 14;
      R1 = _cl9k::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:55.395022 UTC

{offset
  cl9h:
      _sk6P::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cl9l; else goto cl9m;
  cl9m:
      if (HpLim == 0) goto cl9l; else goto cl9n;
  cl9l:
      R1 = _sk6P::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cl9n:
      _sk6l::P64 = P64[_sk6P::P64 + 16];
      _sk6n::P64 = P64[_sk6P::P64 + 24];
      _sk6o::P64 = P64[_sk6P::P64 + 32];
      _sk6r::P64 = P64[_sk6P::P64 + 40];
      I64[(young<cl7Z> + 8)] = cl7Z;
      R1 = _sk6l::P64;
      if (R1 & 7 != 0) goto cl7Z; else goto cl80;
  cl80:
      call (I64[R1])(R1) returns to cl7Z, args: 8, res: 8, upd: 8;
  cl7Z:
      _sk6y::P64 = R1;
      Hp = Hp + 40;
      if (Hp > HpLim) goto cl9q; else goto cl9p;
  cl9q:
      HpAlloc = 40;
      R1 = _sk6y::P64;
      call stg_gc_unpt_r1(R1) returns to cl7Z, args: 8, res: 8, upd: 8;
  cl9p:
      _sk6z::I64 = I64[_sk6y::P64 + 7];
      I64[Hp - 32] = sat_sk6L_info;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      _cl84::P64 = Hp - 32;
      I64[(young<cl9i> + 8)] = cl9i;
      R4 = _cl84::P64;
      R3 = _sk6z::I64;
      R2 = 0;
      call GHC.Show.$wshowSignedInt_info(R4,
                                         R3,
                                         R2) returns to cl9i, args: 8, res: 8, upd: 8;
  cl9i:
      _sk6O::P64 = R2;
      _sk6N::P64 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto cl9t; else goto cl9s;
  cl9t:
      HpAlloc = 24;
      R2 = _sk6O::P64;
      R1 = _sk6N::P64;
      call stg_gc_pp(R2, R1) returns to cl9i, args: 8, res: 8, upd: 8;
  cl9s:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _sk6N::P64;
      P64[Hp] = _sk6O::P64;
      _cl9k::P64 = Hp - 14;
      R1 = _cl9k::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:55.398035 UTC

{offset
  cl9h:
      _sk6P::P64 = R1;
      if ((Sp + 8) - 40 < SpLim) goto cl9l; else goto cl9m;
  cl9m:
      if (HpLim == 0) goto cl9l; else goto cl9n;
  cl9l:
      R1 = _sk6P::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cl9n:
      _sk6l::P64 = P64[_sk6P::P64 + 16];
      _sk6n::P64 = P64[_sk6P::P64 + 24];
      _sk6o::P64 = P64[_sk6P::P64 + 32];
      _sk6r::P64 = P64[_sk6P::P64 + 40];
      I64[Sp - 32] = cl7Z;
      R1 = _sk6l::P64;
      P64[Sp - 24] = _sk6n::P64;
      P64[Sp - 16] = _sk6o::P64;
      P64[Sp - 8] = _sk6r::P64;
      Sp = Sp - 32;
      if (R1 & 7 != 0) goto cl7Z; else goto cl80;
  cl80:
      call (I64[R1])(R1) returns to cl7Z, args: 8, res: 8, upd: 8;
  cl7Z:
      _sk6n::P64 = P64[Sp + 8];
      _sk6o::P64 = P64[Sp + 16];
      _sk6r::P64 = P64[Sp + 24];
      _sk6y::P64 = R1;
      Hp = Hp + 40;
      if (Hp > HpLim) goto cl9q; else goto cl9p;
  cl9q:
      HpAlloc = 40;
      R1 = _sk6y::P64;
      call stg_gc_unpt_r1(R1) returns to cl7Z, args: 8, res: 8, upd: 8;
  cl9p:
      _sk6z::I64 = I64[_sk6y::P64 + 7];
      I64[Hp - 32] = sat_sk6L_info;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      _cl84::P64 = Hp - 32;
      I64[Sp + 24] = cl9i;
      R4 = _cl84::P64;
      R3 = _sk6z::I64;
      R2 = 0;
      Sp = Sp + 24;
      call GHC.Show.$wshowSignedInt_info(R4,
                                         R3,
                                         R2) returns to cl9i, args: 8, res: 8, upd: 8;
  cl9i:
      _sk6O::P64 = R2;
      _sk6N::P64 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto cl9t; else goto cl9s;
  cl9t:
      HpAlloc = 24;
      R2 = _sk6O::P64;
      R1 = _sk6N::P64;
      call stg_gc_pp(R2, R1) returns to cl9i, args: 8, res: 8, upd: 8;
  cl9s:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _sk6N::P64;
      P64[Hp] = _sk6O::P64;
      _cl9k::P64 = Hp - 14;
      R1 = _cl9k::P64;
      Sp = Sp + 8;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:55.401212 UTC

{offset
  cl9h:
      _sk6P::P64 = R1;
      if ((Sp + -32) < SpLim) goto cl9l; else goto cl9m;
  cl9m:
      if (HpLim == 0) goto cl9l; else goto cl9n;
  cl9l:
      R1 = _sk6P::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cl9n:
      I64[Sp - 32] = cl7Z;
      R1 = P64[_sk6P::P64 + 16];
      P64[Sp - 24] = P64[_sk6P::P64 + 24];
      P64[Sp - 16] = P64[_sk6P::P64 + 32];
      P64[Sp - 8] = P64[_sk6P::P64 + 40];
      Sp = Sp - 32;
      if (R1 & 7 != 0) goto cl7Z; else goto cl80;
  cl80:
      call (I64[R1])(R1) returns to cl7Z, args: 8, res: 8, upd: 8;
  cl7Z:
      Hp = Hp + 40;
      if (Hp > HpLim) goto cl9q; else goto cl9p;
  cl9q:
      HpAlloc = 40;
      R1 = R1;
      call stg_gc_unpt_r1(R1) returns to cl7Z, args: 8, res: 8, upd: 8;
  cl9p:
      _sk6z::I64 = I64[R1 + 7];
      I64[Hp - 32] = sat_sk6L_info;
      P64[Hp - 16] = P64[Sp + 8];
      P64[Hp - 8] = P64[Sp + 16];
      P64[Hp] = P64[Sp + 24];
      I64[Sp + 24] = cl9i;
      R4 = Hp - 32;
      R3 = _sk6z::I64;
      R2 = 0;
      Sp = Sp + 24;
      call GHC.Show.$wshowSignedInt_info(R4,
                                         R3,
                                         R2) returns to cl9i, args: 8, res: 8, upd: 8;
  cl9i:
      Hp = Hp + 24;
      if (Hp > HpLim) goto cl9t; else goto cl9s;
  cl9t:
      HpAlloc = 24;
      R2 = R2;
      R1 = R1;
      call stg_gc_pp(R2, R1) returns to cl9i, args: 8, res: 8, upd: 8;
  cl9s:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = R1;
      P64[Hp] = R2;
      R1 = Hp - 14;
      Sp = Sp + 8;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:55.404291 UTC

[(cl7Z, {sat_sk6L_closure}), (cl80, {sat_sk6L_closure}),
 (cl9h, {sat_sk6L_closure}), (cl9i, {}), (cl9l, {}),
 (cl9m, {sat_sk6L_closure}), (cl9n, {sat_sk6L_closure}),
 (cl9p, {sat_sk6L_closure}), (cl9q, {sat_sk6L_closure}), (cl9s, {}),
 (cl9t, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:55.405048 UTC

sat_sk6P_entry() //  [R1]
        { info_tbl: [(cl7Z,
                      label: block_cl7Z_info
                      rep:StackRep [False, False, False]),
                     (cl9h,
                      label: sat_sk6P_info
                      rep:HeapRep 4 ptrs { Thunk }),
                     (cl9i,
                      label: block_cl9i_info
                      rep:StackRep [])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cl9h:
          _sk6P::P64 = R1;
          if ((Sp + -32) < SpLim) goto cl9l; else goto cl9m;
      cl9m:
          if (HpLim == 0) goto cl9l; else goto cl9n;
      cl9l:
          R1 = _sk6P::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      cl9n:
          I64[Sp - 32] = cl7Z;
          R1 = P64[_sk6P::P64 + 16];
          P64[Sp - 24] = P64[_sk6P::P64 + 24];
          P64[Sp - 16] = P64[_sk6P::P64 + 32];
          P64[Sp - 8] = P64[_sk6P::P64 + 40];
          Sp = Sp - 32;
          if (R1 & 7 != 0) goto cl7Z; else goto cl80;
      cl80:
          call (I64[R1])(R1) returns to cl7Z, args: 8, res: 8, upd: 8;
      cl7Z:
          Hp = Hp + 40;
          if (Hp > HpLim) goto cl9q; else goto cl9p;
      cl9q:
          HpAlloc = 40;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to cl7Z, args: 8, res: 8, upd: 8;
      cl9p:
          _sk6z::I64 = I64[R1 + 7];
          I64[Hp - 32] = sat_sk6L_info;
          P64[Hp - 16] = P64[Sp + 8];
          P64[Hp - 8] = P64[Sp + 16];
          P64[Hp] = P64[Sp + 24];
          I64[Sp + 24] = cl9i;
          R4 = Hp - 32;
          R3 = _sk6z::I64;
          R2 = 0;
          Sp = Sp + 24;
          call GHC.Show.$wshowSignedInt_info(R4,
                                             R3,
                                             R2) returns to cl9i, args: 8, res: 8, upd: 8;
      cl9i:
          Hp = Hp + 24;
          if (Hp > HpLim) goto cl9t; else goto cl9s;
      cl9t:
          HpAlloc = 24;
          R2 = R2;
          R1 = R1;
          call stg_gc_pp(R2, R1) returns to cl9i, args: 8, res: 8, upd: 8;
      cl9s:
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = R1;
          P64[Hp] = R2;
          R1 = Hp - 14;
          Sp = Sp + 8;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:55.408251 UTC

sat_sk6P_entry() //  [R1]
        { info_tbl: [(cl7Z,
                      label: block_cl7Z_info
                      rep:StackRep [False, False, False]),
                     (cl9h,
                      label: sat_sk6P_info
                      rep:HeapRep 4 ptrs { Thunk }),
                     (cl9i,
                      label: block_cl9i_info
                      rep:StackRep [])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cl9h:
          _sk6P::P64 = R1;
          if ((Sp + -32) < SpLim) goto cl9l; else goto cl9m;
      cl9m:
          if (HpLim == 0) goto cl9l; else goto cl9n;
      cl9l:
          R1 = _sk6P::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      cl9n:
          I64[Sp - 32] = cl7Z;
          R1 = P64[_sk6P::P64 + 16];
          P64[Sp - 24] = P64[_sk6P::P64 + 24];
          P64[Sp - 16] = P64[_sk6P::P64 + 32];
          P64[Sp - 8] = P64[_sk6P::P64 + 40];
          Sp = Sp - 32;
          if (R1 & 7 != 0) goto cl7Z; else goto cl80;
      cl80:
          call (I64[R1])(R1) returns to cl7Z, args: 8, res: 8, upd: 8;
      cl7Z:
          Hp = Hp + 40;
          if (Hp > HpLim) goto cl9q; else goto cl9p;
      cl9q:
          HpAlloc = 40;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to cl7Z, args: 8, res: 8, upd: 8;
      cl9p:
          _sk6z::I64 = I64[R1 + 7];
          I64[Hp - 32] = sat_sk6L_info;
          P64[Hp - 16] = P64[Sp + 8];
          P64[Hp - 8] = P64[Sp + 16];
          P64[Hp] = P64[Sp + 24];
          I64[Sp + 24] = cl9i;
          R4 = Hp - 32;
          R3 = _sk6z::I64;
          R2 = 0;
          Sp = Sp + 24;
          call GHC.Show.$wshowSignedInt_info(R4,
                                             R3,
                                             R2) returns to cl9i, args: 8, res: 8, upd: 8;
      cl9i:
          Hp = Hp + 24;
          if (Hp > HpLim) goto cl9t; else goto cl9s;
      cl9t:
          HpAlloc = 24;
          R2 = R2;
          R1 = R1;
          call stg_gc_pp(R2, R1) returns to cl9i, args: 8, res: 8, upd: 8;
      cl9s:
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = R1;
          P64[Hp] = R2;
          R1 = Hp - 14;
          Sp = Sp + 8;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:55.411403 UTC

{offset
  cl9u:
      _sk6Q::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cl9v; else goto cl9w;
  cl9w:
      Hp = Hp + 48;
      if (Hp > HpLim) goto cl9y; else goto cl9x;
  cl9y:
      HpAlloc = 48;
      goto cl9v;
  cl9v:
      R1 = _sk6Q::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cl9x:
      _sk6l::P64 = P64[_sk6Q::P64 + 16];
      _sk6n::P64 = P64[_sk6Q::P64 + 24];
      _sk6o::P64 = P64[_sk6Q::P64 + 32];
      _sk6r::P64 = P64[_sk6Q::P64 + 40];
      I64[Hp - 40] = sat_sk6P_info;
      P64[Hp - 24] = _sk6l::P64;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      _cl7V::P64 = Hp - 40;
      R3 = _cl7V::P64;
      R2 = lvl6_rjV3_closure;
      call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:55.412772 UTC

{offset
  cl9u:
      _sk6Q::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cl9v; else goto cl9w;
  cl9w:
      Hp = Hp + 48;
      if (Hp > HpLim) goto cl9y; else goto cl9x;
  cl9y:
      HpAlloc = 48;
      goto cl9v;
  cl9v:
      R1 = _sk6Q::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cl9x:
      _sk6l::P64 = P64[_sk6Q::P64 + 16];
      _sk6n::P64 = P64[_sk6Q::P64 + 24];
      _sk6o::P64 = P64[_sk6Q::P64 + 32];
      _sk6r::P64 = P64[_sk6Q::P64 + 40];
      I64[Hp - 40] = sat_sk6P_info;
      P64[Hp - 24] = _sk6l::P64;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      _cl7V::P64 = Hp - 40;
      R3 = _cl7V::P64;
      R2 = lvl6_rjV3_closure;
      call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:55.414161 UTC

{offset
  cl9u:
      _sk6Q::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cl9v; else goto cl9w;
  cl9w:
      Hp = Hp + 48;
      if (Hp > HpLim) goto cl9y; else goto cl9x;
  cl9y:
      HpAlloc = 48;
      goto cl9v;
  cl9v:
      R1 = _sk6Q::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cl9x:
      _sk6l::P64 = P64[_sk6Q::P64 + 16];
      _sk6n::P64 = P64[_sk6Q::P64 + 24];
      _sk6o::P64 = P64[_sk6Q::P64 + 32];
      _sk6r::P64 = P64[_sk6Q::P64 + 40];
      I64[Hp - 40] = sat_sk6P_info;
      P64[Hp - 24] = _sk6l::P64;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      _cl7V::P64 = Hp - 40;
      R3 = _cl7V::P64;
      R2 = lvl6_rjV3_closure;
      call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:55.415597 UTC

{offset
  cl9u:
      _sk6Q::P64 = R1;
      goto cl9w;
  cl9w:
      Hp = Hp + 48;
      if (Hp > HpLim) goto cl9y; else goto cl9x;
  cl9y:
      HpAlloc = 48;
      goto cl9v;
  cl9v:
      R1 = _sk6Q::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cl9x:
      _sk6l::P64 = P64[_sk6Q::P64 + 16];
      _sk6n::P64 = P64[_sk6Q::P64 + 24];
      _sk6o::P64 = P64[_sk6Q::P64 + 32];
      _sk6r::P64 = P64[_sk6Q::P64 + 40];
      I64[Hp - 40] = sat_sk6P_info;
      P64[Hp - 24] = _sk6l::P64;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      _cl7V::P64 = Hp - 40;
      R3 = _cl7V::P64;
      R2 = lvl6_rjV3_closure;
      call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:55.416902 UTC

{offset
  cl9u:
      goto cl9w;
  cl9w:
      Hp = Hp + 48;
      if (Hp > HpLim) goto cl9y; else goto cl9x;
  cl9y:
      HpAlloc = 48;
      goto cl9v;
  cl9v:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cl9x:
      _sk6l::P64 = P64[R1 + 16];
      _sk6n::P64 = P64[R1 + 24];
      _sk6o::P64 = P64[R1 + 32];
      _sk6r::P64 = P64[R1 + 40];
      I64[Hp - 40] = sat_sk6P_info;
      P64[Hp - 24] = _sk6l::P64;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      R3 = Hp - 40;
      R2 = lvl6_rjV3_closure;
      call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:55.418363 UTC

[(cl9u, {lvl6_rjV3_closure, sat_sk6P_closure}), (cl9v, {}),
 (cl9w, {lvl6_rjV3_closure, sat_sk6P_closure}),
 (cl9x, {lvl6_rjV3_closure, sat_sk6P_closure}), (cl9y, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:55.419535 UTC

sat_sk6Q_entry() //  [R1]
        { info_tbl: [(cl9u,
                      label: sat_sk6Q_info
                      rep:HeapRep 4 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cl9u:
          goto cl9w;
      cl9w:
          Hp = Hp + 48;
          if (Hp > HpLim) goto cl9y; else goto cl9x;
      cl9y:
          HpAlloc = 48;
          goto cl9v;
      cl9v:
          R1 = R1;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      cl9x:
          _sk6l::P64 = P64[R1 + 16];
          _sk6n::P64 = P64[R1 + 24];
          _sk6o::P64 = P64[R1 + 32];
          _sk6r::P64 = P64[R1 + 40];
          I64[Hp - 40] = sat_sk6P_info;
          P64[Hp - 24] = _sk6l::P64;
          P64[Hp - 16] = _sk6n::P64;
          P64[Hp - 8] = _sk6o::P64;
          P64[Hp] = _sk6r::P64;
          R3 = Hp - 40;
          R2 = lvl6_rjV3_closure;
          call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:55.420952 UTC

sat_sk6Q_entry() //  [R1]
        { info_tbl: [(cl9u,
                      label: sat_sk6Q_info
                      rep:HeapRep 4 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cl9u:
          Hp = Hp + 48;
          if (Hp > HpLim) goto cl9y; else goto cl9x;
      cl9y:
          HpAlloc = 48;
          R1 = R1;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      cl9x:
          _sk6l::P64 = P64[R1 + 16];
          _sk6n::P64 = P64[R1 + 24];
          _sk6o::P64 = P64[R1 + 32];
          _sk6r::P64 = P64[R1 + 40];
          I64[Hp - 40] = sat_sk6P_info;
          P64[Hp - 24] = _sk6l::P64;
          P64[Hp - 16] = _sk6n::P64;
          P64[Hp - 8] = _sk6o::P64;
          P64[Hp] = _sk6r::P64;
          R3 = Hp - 40;
          R2 = lvl6_rjV3_closure;
          call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:55.422325 UTC

{offset
  cl9z:
      _sk6x::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cl9A; else goto cl9B;
  cl9B:
      Hp = Hp + 48;
      if (Hp > HpLim) goto cl9D; else goto cl9C;
  cl9D:
      HpAlloc = 48;
      goto cl9A;
  cl9A:
      R1 = _sk6x::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cl9C:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sk6x::P64;
      _sk6l::P64 = P64[_sk6x::P64 + 16];
      _sk6n::P64 = P64[_sk6x::P64 + 24];
      _sk6o::P64 = P64[_sk6x::P64 + 32];
      _sk6r::P64 = P64[_sk6x::P64 + 40];
      I64[Hp - 40] = sat_sk6Q_info;
      P64[Hp - 24] = _sk6l::P64;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      _cl7R::P64 = Hp - 40;
      R3 = _cl7R::P64;
      R2 = lvl3_rjV0_closure;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:55.423769 UTC

{offset
  cl9z:
      _sk6x::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cl9A; else goto cl9B;
  cl9B:
      Hp = Hp + 48;
      if (Hp > HpLim) goto cl9D; else goto cl9C;
  cl9D:
      HpAlloc = 48;
      goto cl9A;
  cl9A:
      R1 = _sk6x::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cl9C:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sk6x::P64;
      _sk6l::P64 = P64[_sk6x::P64 + 16];
      _sk6n::P64 = P64[_sk6x::P64 + 24];
      _sk6o::P64 = P64[_sk6x::P64 + 32];
      _sk6r::P64 = P64[_sk6x::P64 + 40];
      I64[Hp - 40] = sat_sk6Q_info;
      P64[Hp - 24] = _sk6l::P64;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      _cl7R::P64 = Hp - 40;
      R3 = _cl7R::P64;
      R2 = lvl3_rjV0_closure;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:55.425241 UTC

{offset
  cl9z:
      _sk6x::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cl9A; else goto cl9B;
  cl9B:
      Hp = Hp + 48;
      if (Hp > HpLim) goto cl9D; else goto cl9C;
  cl9D:
      HpAlloc = 48;
      goto cl9A;
  cl9A:
      R1 = _sk6x::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cl9C:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sk6x::P64;
      _sk6l::P64 = P64[_sk6x::P64 + 16];
      _sk6n::P64 = P64[_sk6x::P64 + 24];
      _sk6o::P64 = P64[_sk6x::P64 + 32];
      _sk6r::P64 = P64[_sk6x::P64 + 40];
      I64[Hp - 40] = sat_sk6Q_info;
      P64[Hp - 24] = _sk6l::P64;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      _cl7R::P64 = Hp - 40;
      R3 = _cl7R::P64;
      R2 = lvl3_rjV0_closure;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:55.426751 UTC

{offset
  cl9z:
      _sk6x::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto cl9A; else goto cl9B;
  cl9B:
      Hp = Hp + 48;
      if (Hp > HpLim) goto cl9D; else goto cl9C;
  cl9D:
      HpAlloc = 48;
      goto cl9A;
  cl9A:
      R1 = _sk6x::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cl9C:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _sk6x::P64;
      _sk6l::P64 = P64[_sk6x::P64 + 16];
      _sk6n::P64 = P64[_sk6x::P64 + 24];
      _sk6o::P64 = P64[_sk6x::P64 + 32];
      _sk6r::P64 = P64[_sk6x::P64 + 40];
      I64[Hp - 40] = sat_sk6Q_info;
      P64[Hp - 24] = _sk6l::P64;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      _cl7R::P64 = Hp - 40;
      R3 = _cl7R::P64;
      R2 = lvl3_rjV0_closure;
      Sp = Sp - 16;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:55.428241 UTC

{offset
  cl9z:
      _sk6x::P64 = R1;
      if ((Sp + -16) < SpLim) goto cl9A; else goto cl9B;
  cl9B:
      Hp = Hp + 48;
      if (Hp > HpLim) goto cl9D; else goto cl9C;
  cl9D:
      HpAlloc = 48;
      goto cl9A;
  cl9A:
      R1 = _sk6x::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cl9C:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _sk6x::P64;
      _sk6l::P64 = P64[_sk6x::P64 + 16];
      _sk6n::P64 = P64[_sk6x::P64 + 24];
      _sk6o::P64 = P64[_sk6x::P64 + 32];
      _sk6r::P64 = P64[_sk6x::P64 + 40];
      I64[Hp - 40] = sat_sk6Q_info;
      P64[Hp - 24] = _sk6l::P64;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      R3 = Hp - 40;
      R2 = lvl3_rjV0_closure;
      Sp = Sp - 16;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:55.429851 UTC

[(cl9z, {lvl3_rjV0_closure, sat_sk6Q_closure}), (cl9A, {}),
 (cl9B, {lvl3_rjV0_closure, sat_sk6Q_closure}),
 (cl9C, {lvl3_rjV0_closure, sat_sk6Q_closure}), (cl9D, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:55.430384 UTC

eta1_sk6x_entry() //  [R1]
        { info_tbl: [(cl9z,
                      label: eta1_sk6x_info
                      rep:HeapRep 4 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cl9z:
          _sk6x::P64 = R1;
          if ((Sp + -16) < SpLim) goto cl9A; else goto cl9B;
      cl9B:
          Hp = Hp + 48;
          if (Hp > HpLim) goto cl9D; else goto cl9C;
      cl9D:
          HpAlloc = 48;
          goto cl9A;
      cl9A:
          R1 = _sk6x::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      cl9C:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _sk6x::P64;
          _sk6l::P64 = P64[_sk6x::P64 + 16];
          _sk6n::P64 = P64[_sk6x::P64 + 24];
          _sk6o::P64 = P64[_sk6x::P64 + 32];
          _sk6r::P64 = P64[_sk6x::P64 + 40];
          I64[Hp - 40] = sat_sk6Q_info;
          P64[Hp - 24] = _sk6l::P64;
          P64[Hp - 16] = _sk6n::P64;
          P64[Hp - 8] = _sk6o::P64;
          P64[Hp] = _sk6r::P64;
          R3 = Hp - 40;
          R2 = lvl3_rjV0_closure;
          Sp = Sp - 16;
          call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:55.43208 UTC

eta1_sk6x_entry() //  [R1]
        { info_tbl: [(cl9z,
                      label: eta1_sk6x_info
                      rep:HeapRep 4 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cl9z:
          _sk6x::P64 = R1;
          if ((Sp + -16) < SpLim) goto cl9A; else goto cl9B;
      cl9B:
          Hp = Hp + 48;
          if (Hp > HpLim) goto cl9D; else goto cl9C;
      cl9D:
          HpAlloc = 48;
          goto cl9A;
      cl9A:
          R1 = _sk6x::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      cl9C:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _sk6x::P64;
          _sk6l::P64 = P64[_sk6x::P64 + 16];
          _sk6n::P64 = P64[_sk6x::P64 + 24];
          _sk6o::P64 = P64[_sk6x::P64 + 32];
          _sk6r::P64 = P64[_sk6x::P64 + 40];
          I64[Hp - 40] = sat_sk6Q_info;
          P64[Hp - 24] = _sk6l::P64;
          P64[Hp - 16] = _sk6n::P64;
          P64[Hp - 8] = _sk6o::P64;
          P64[Hp] = _sk6r::P64;
          R3 = Hp - 40;
          R2 = lvl3_rjV0_closure;
          Sp = Sp - 16;
          call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:55.433801 UTC

{offset
  cl9L:
      _sk6S::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cl9M; else goto cl9N;
  cl9N:
      Hp = Hp + 48;
      if (Hp > HpLim) goto cl9P; else goto cl9O;
  cl9P:
      HpAlloc = 48;
      goto cl9M;
  cl9M:
      R1 = _sk6S::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cl9O:
      _sk6k::P64 = P64[_sk6S::P64 + 16];
      _sk6l::P64 = P64[_sk6S::P64 + 24];
      _sk6n::P64 = P64[_sk6S::P64 + 32];
      _sk6o::P64 = P64[_sk6S::P64 + 40];
      _sk6r::P64 = P64[_sk6S::P64 + 48];
      I64[Hp - 40] = eta1_sk6x_info;
      P64[Hp - 24] = _sk6l::P64;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      _cl7N::P64 = Hp - 40;
      I64[(young<cl9E> + 8)] = cl9E;
      R1 = _sk6k::P64;
      if (R1 & 7 != 0) goto cl9E; else goto cl9F;
  cl9F:
      call (I64[R1])(R1) returns to cl9E, args: 8, res: 8, upd: 8;
  cl9E:
      _sk6R::P64 = R1;
      _cl9K::P64 = _sk6R::P64 & 7;
      switch [1 .. 2] _cl9K::P64 {
          case 1 : goto cl9I;
          case 2 : goto cl9J;
      }
  cl9J:
      R3 = _cl7N::P64;
      R2 = GHC.Show.shows16_closure;
      call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
  cl9I:
      R3 = _cl7N::P64;
      R2 = GHC.Show.shows17_closure;
      call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:55.435919 UTC

{offset
  cl9L:
      _sk6S::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cl9M; else goto cl9N;
  cl9N:
      Hp = Hp + 48;
      if (Hp > HpLim) goto cl9P; else goto cl9O;
  cl9P:
      HpAlloc = 48;
      goto cl9M;
  cl9M:
      R1 = _sk6S::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cl9O:
      _sk6k::P64 = P64[_sk6S::P64 + 16];
      _sk6l::P64 = P64[_sk6S::P64 + 24];
      _sk6n::P64 = P64[_sk6S::P64 + 32];
      _sk6o::P64 = P64[_sk6S::P64 + 40];
      _sk6r::P64 = P64[_sk6S::P64 + 48];
      I64[Hp - 40] = eta1_sk6x_info;
      P64[Hp - 24] = _sk6l::P64;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      _cl7N::P64 = Hp - 40;
      I64[(young<cl9E> + 8)] = cl9E;
      R1 = _sk6k::P64;
      if (R1 & 7 != 0) goto cl9E; else goto cl9F;
  cl9F:
      call (I64[R1])(R1) returns to cl9E, args: 8, res: 8, upd: 8;
  cl9E:
      _sk6R::P64 = R1;
      _cl9K::P64 = _sk6R::P64 & 7;
      switch [1 .. 2] _cl9K::P64 {
          case 1 : goto cl9I;
          case 2 : goto cl9J;
      }
  cl9J:
      R3 = _cl7N::P64;
      R2 = GHC.Show.shows16_closure;
      call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
  cl9I:
      R3 = _cl7N::P64;
      R2 = GHC.Show.shows17_closure;
      call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:55.438079 UTC

{offset
  cl9L:
      _sk6S::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cl9M; else goto cl9N;
  cl9N:
      Hp = Hp + 48;
      if (Hp > HpLim) goto cl9P; else goto cl9O;
  cl9P:
      HpAlloc = 48;
      goto cl9M;
  cl9M:
      R1 = _sk6S::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cl9O:
      _sk6k::P64 = P64[_sk6S::P64 + 16];
      _sk6l::P64 = P64[_sk6S::P64 + 24];
      _sk6n::P64 = P64[_sk6S::P64 + 32];
      _sk6o::P64 = P64[_sk6S::P64 + 40];
      _sk6r::P64 = P64[_sk6S::P64 + 48];
      I64[Hp - 40] = eta1_sk6x_info;
      P64[Hp - 24] = _sk6l::P64;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      _cl7N::P64 = Hp - 40;
      I64[(young<cl9E> + 8)] = cl9E;
      R1 = _sk6k::P64;
      if (R1 & 7 != 0) goto cl9E; else goto cl9F;
  cl9F:
      call (I64[R1])(R1) returns to cl9E, args: 8, res: 8, upd: 8;
  cl9E:
      _sk6R::P64 = R1;
      _cl9K::P64 = _sk6R::P64 & 7;
      if (_cl9K::P64 != 1) goto cl9J; else goto cl9I;
  cl9J:
      R3 = _cl7N::P64;
      R2 = GHC.Show.shows16_closure;
      call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
  cl9I:
      R3 = _cl7N::P64;
      R2 = GHC.Show.shows17_closure;
      call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:55.440366 UTC

{offset
  cl9L:
      _sk6S::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto cl9M; else goto cl9N;
  cl9N:
      Hp = Hp + 48;
      if (Hp > HpLim) goto cl9P; else goto cl9O;
  cl9P:
      HpAlloc = 48;
      goto cl9M;
  cl9M:
      R1 = _sk6S::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cl9O:
      _sk6k::P64 = P64[_sk6S::P64 + 16];
      _sk6l::P64 = P64[_sk6S::P64 + 24];
      _sk6n::P64 = P64[_sk6S::P64 + 32];
      _sk6o::P64 = P64[_sk6S::P64 + 40];
      _sk6r::P64 = P64[_sk6S::P64 + 48];
      I64[Hp - 40] = eta1_sk6x_info;
      P64[Hp - 24] = _sk6l::P64;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      _cl7N::P64 = Hp - 40;
      I64[Sp - 16] = cl9E;
      R1 = _sk6k::P64;
      P64[Sp - 8] = _cl7N::P64;
      Sp = Sp - 16;
      if (R1 & 7 != 0) goto cl9E; else goto cl9F;
  cl9F:
      call (I64[R1])(R1) returns to cl9E, args: 8, res: 8, upd: 8;
  cl9E:
      _cl7N::P64 = P64[Sp + 8];
      _sk6R::P64 = R1;
      _cl9K::P64 = _sk6R::P64 & 7;
      if (_cl9K::P64 != 1) goto cl9J; else goto cl9I;
  cl9J:
      R3 = _cl7N::P64;
      R2 = GHC.Show.shows16_closure;
      Sp = Sp + 16;
      call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
  cl9I:
      R3 = _cl7N::P64;
      R2 = GHC.Show.shows17_closure;
      Sp = Sp + 16;
      call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:55.442665 UTC

{offset
  cl9L:
      _sk6S::P64 = R1;
      if ((Sp + -16) < SpLim) goto cl9M; else goto cl9N;
  cl9N:
      Hp = Hp + 48;
      if (Hp > HpLim) goto cl9P; else goto cl9O;
  cl9P:
      HpAlloc = 48;
      goto cl9M;
  cl9M:
      R1 = _sk6S::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cl9O:
      _sk6k::P64 = P64[_sk6S::P64 + 16];
      _sk6l::P64 = P64[_sk6S::P64 + 24];
      _sk6n::P64 = P64[_sk6S::P64 + 32];
      _sk6o::P64 = P64[_sk6S::P64 + 40];
      _sk6r::P64 = P64[_sk6S::P64 + 48];
      I64[Hp - 40] = eta1_sk6x_info;
      P64[Hp - 24] = _sk6l::P64;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      I64[Sp - 16] = cl9E;
      R1 = _sk6k::P64;
      P64[Sp - 8] = Hp - 40;
      Sp = Sp - 16;
      if (R1 & 7 != 0) goto cl9E; else goto cl9F;
  cl9F:
      call (I64[R1])(R1) returns to cl9E, args: 8, res: 8, upd: 8;
  cl9E:
      _cl7N::P64 = P64[Sp + 8];
      if (R1 & 7 != 1) goto cl9J; else goto cl9I;
  cl9J:
      R3 = _cl7N::P64;
      R2 = GHC.Show.shows16_closure;
      Sp = Sp + 16;
      call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
  cl9I:
      R3 = _cl7N::P64;
      R2 = GHC.Show.shows17_closure;
      Sp = Sp + 16;
      call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:55.445056 UTC

[(cl9E, {GHC.Show.shows16_closure, GHC.Show.shows17_closure}),
 (cl9F, {GHC.Show.shows16_closure, GHC.Show.shows17_closure}),
 (cl9I, {GHC.Show.shows17_closure}),
 (cl9J, {GHC.Show.shows16_closure}),
 (cl9L,
  {GHC.Show.shows16_closure, GHC.Show.shows17_closure,
   eta1_sk6x_closure}),
 (cl9M, {}),
 (cl9N,
  {GHC.Show.shows16_closure, GHC.Show.shows17_closure,
   eta1_sk6x_closure}),
 (cl9O,
  {GHC.Show.shows16_closure, GHC.Show.shows17_closure,
   eta1_sk6x_closure}),
 (cl9P, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:55.446048 UTC

sat_sk6S_entry() //  [R1]
        { info_tbl: [(cl9E,
                      label: block_cl9E_info
                      rep:StackRep [False]),
                     (cl9L,
                      label: sat_sk6S_info
                      rep:HeapRep 5 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cl9L:
          _sk6S::P64 = R1;
          if ((Sp + -16) < SpLim) goto cl9M; else goto cl9N;
      cl9N:
          Hp = Hp + 48;
          if (Hp > HpLim) goto cl9P; else goto cl9O;
      cl9P:
          HpAlloc = 48;
          goto cl9M;
      cl9M:
          R1 = _sk6S::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      cl9O:
          _sk6k::P64 = P64[_sk6S::P64 + 16];
          _sk6l::P64 = P64[_sk6S::P64 + 24];
          _sk6n::P64 = P64[_sk6S::P64 + 32];
          _sk6o::P64 = P64[_sk6S::P64 + 40];
          _sk6r::P64 = P64[_sk6S::P64 + 48];
          I64[Hp - 40] = eta1_sk6x_info;
          P64[Hp - 24] = _sk6l::P64;
          P64[Hp - 16] = _sk6n::P64;
          P64[Hp - 8] = _sk6o::P64;
          P64[Hp] = _sk6r::P64;
          I64[Sp - 16] = cl9E;
          R1 = _sk6k::P64;
          P64[Sp - 8] = Hp - 40;
          Sp = Sp - 16;
          if (R1 & 7 != 0) goto cl9E; else goto cl9F;
      cl9F:
          call (I64[R1])(R1) returns to cl9E, args: 8, res: 8, upd: 8;
      cl9E:
          _cl7N::P64 = P64[Sp + 8];
          if (R1 & 7 != 1) goto cl9J; else goto cl9I;
      cl9J:
          R3 = _cl7N::P64;
          R2 = GHC.Show.shows16_closure;
          Sp = Sp + 16;
          call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
      cl9I:
          R3 = _cl7N::P64;
          R2 = GHC.Show.shows17_closure;
          Sp = Sp + 16;
          call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:55.44865 UTC

sat_sk6S_entry() //  [R1]
        { info_tbl: [(cl9E,
                      label: block_cl9E_info
                      rep:StackRep [False]),
                     (cl9L,
                      label: sat_sk6S_info
                      rep:HeapRep 5 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cl9L:
          _sk6S::P64 = R1;
          if ((Sp + -16) < SpLim) goto cl9M; else goto cl9N;
      cl9N:
          Hp = Hp + 48;
          if (Hp > HpLim) goto cl9P; else goto cl9O;
      cl9P:
          HpAlloc = 48;
          goto cl9M;
      cl9M:
          R1 = _sk6S::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      cl9O:
          _sk6k::P64 = P64[_sk6S::P64 + 16];
          _sk6l::P64 = P64[_sk6S::P64 + 24];
          _sk6n::P64 = P64[_sk6S::P64 + 32];
          _sk6o::P64 = P64[_sk6S::P64 + 40];
          _sk6r::P64 = P64[_sk6S::P64 + 48];
          I64[Hp - 40] = eta1_sk6x_info;
          P64[Hp - 24] = _sk6l::P64;
          P64[Hp - 16] = _sk6n::P64;
          P64[Hp - 8] = _sk6o::P64;
          P64[Hp] = _sk6r::P64;
          I64[Sp - 16] = cl9E;
          R1 = _sk6k::P64;
          P64[Sp - 8] = Hp - 40;
          Sp = Sp - 16;
          if (R1 & 7 != 0) goto cl9E; else goto cl9F;
      cl9F:
          call (I64[R1])(R1) returns to cl9E, args: 8, res: 8, upd: 8;
      cl9E:
          _cl7N::P64 = P64[Sp + 8];
          if (R1 & 7 != 1) goto cl9J; else goto cl9I;
      cl9J:
          R3 = _cl7N::P64;
          R2 = GHC.Show.shows16_closure;
          Sp = Sp + 16;
          call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
      cl9I:
          R3 = _cl7N::P64;
          R2 = GHC.Show.shows17_closure;
          Sp = Sp + 16;
          call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:55.451237 UTC

{offset
  cl9W:
      _sk6T::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cl9X; else goto cl9Y;
  cl9Y:
      Hp = Hp + 56;
      if (Hp > HpLim) goto cla0; else goto cl9Z;
  cla0:
      HpAlloc = 56;
      goto cl9X;
  cl9X:
      R1 = _sk6T::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cl9Z:
      _sk6k::P64 = P64[_sk6T::P64 + 16];
      _sk6l::P64 = P64[_sk6T::P64 + 24];
      _sk6n::P64 = P64[_sk6T::P64 + 32];
      _sk6o::P64 = P64[_sk6T::P64 + 40];
      _sk6r::P64 = P64[_sk6T::P64 + 48];
      I64[Hp - 48] = sat_sk6S_info;
      P64[Hp - 32] = _sk6k::P64;
      P64[Hp - 24] = _sk6l::P64;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      _cl7J::P64 = Hp - 48;
      R3 = _cl7J::P64;
      R2 = lvl7_rjV4_closure;
      call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:55.45272 UTC

{offset
  cl9W:
      _sk6T::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cl9X; else goto cl9Y;
  cl9Y:
      Hp = Hp + 56;
      if (Hp > HpLim) goto cla0; else goto cl9Z;
  cla0:
      HpAlloc = 56;
      goto cl9X;
  cl9X:
      R1 = _sk6T::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cl9Z:
      _sk6k::P64 = P64[_sk6T::P64 + 16];
      _sk6l::P64 = P64[_sk6T::P64 + 24];
      _sk6n::P64 = P64[_sk6T::P64 + 32];
      _sk6o::P64 = P64[_sk6T::P64 + 40];
      _sk6r::P64 = P64[_sk6T::P64 + 48];
      I64[Hp - 48] = sat_sk6S_info;
      P64[Hp - 32] = _sk6k::P64;
      P64[Hp - 24] = _sk6l::P64;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      _cl7J::P64 = Hp - 48;
      R3 = _cl7J::P64;
      R2 = lvl7_rjV4_closure;
      call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:55.454195 UTC

{offset
  cl9W:
      _sk6T::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cl9X; else goto cl9Y;
  cl9Y:
      Hp = Hp + 56;
      if (Hp > HpLim) goto cla0; else goto cl9Z;
  cla0:
      HpAlloc = 56;
      goto cl9X;
  cl9X:
      R1 = _sk6T::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cl9Z:
      _sk6k::P64 = P64[_sk6T::P64 + 16];
      _sk6l::P64 = P64[_sk6T::P64 + 24];
      _sk6n::P64 = P64[_sk6T::P64 + 32];
      _sk6o::P64 = P64[_sk6T::P64 + 40];
      _sk6r::P64 = P64[_sk6T::P64 + 48];
      I64[Hp - 48] = sat_sk6S_info;
      P64[Hp - 32] = _sk6k::P64;
      P64[Hp - 24] = _sk6l::P64;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      _cl7J::P64 = Hp - 48;
      R3 = _cl7J::P64;
      R2 = lvl7_rjV4_closure;
      call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:55.456271 UTC

{offset
  cl9W:
      _sk6T::P64 = R1;
      goto cl9Y;
  cl9Y:
      Hp = Hp + 56;
      if (Hp > HpLim) goto cla0; else goto cl9Z;
  cla0:
      HpAlloc = 56;
      goto cl9X;
  cl9X:
      R1 = _sk6T::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cl9Z:
      _sk6k::P64 = P64[_sk6T::P64 + 16];
      _sk6l::P64 = P64[_sk6T::P64 + 24];
      _sk6n::P64 = P64[_sk6T::P64 + 32];
      _sk6o::P64 = P64[_sk6T::P64 + 40];
      _sk6r::P64 = P64[_sk6T::P64 + 48];
      I64[Hp - 48] = sat_sk6S_info;
      P64[Hp - 32] = _sk6k::P64;
      P64[Hp - 24] = _sk6l::P64;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      _cl7J::P64 = Hp - 48;
      R3 = _cl7J::P64;
      R2 = lvl7_rjV4_closure;
      call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:55.457701 UTC

{offset
  cl9W:
      goto cl9Y;
  cl9Y:
      Hp = Hp + 56;
      if (Hp > HpLim) goto cla0; else goto cl9Z;
  cla0:
      HpAlloc = 56;
      goto cl9X;
  cl9X:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cl9Z:
      _sk6k::P64 = P64[R1 + 16];
      _sk6l::P64 = P64[R1 + 24];
      _sk6n::P64 = P64[R1 + 32];
      _sk6o::P64 = P64[R1 + 40];
      _sk6r::P64 = P64[R1 + 48];
      I64[Hp - 48] = sat_sk6S_info;
      P64[Hp - 32] = _sk6k::P64;
      P64[Hp - 24] = _sk6l::P64;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      R3 = Hp - 48;
      R2 = lvl7_rjV4_closure;
      call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:55.459365 UTC

[(cl9W, {lvl7_rjV4_closure, sat_sk6S_closure}), (cl9X, {}),
 (cl9Y, {lvl7_rjV4_closure, sat_sk6S_closure}),
 (cl9Z, {lvl7_rjV4_closure, sat_sk6S_closure}), (cla0, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:55.459881 UTC

sat_sk6T_entry() //  [R1]
        { info_tbl: [(cl9W,
                      label: sat_sk6T_info
                      rep:HeapRep 5 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cl9W:
          goto cl9Y;
      cl9Y:
          Hp = Hp + 56;
          if (Hp > HpLim) goto cla0; else goto cl9Z;
      cla0:
          HpAlloc = 56;
          goto cl9X;
      cl9X:
          R1 = R1;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      cl9Z:
          _sk6k::P64 = P64[R1 + 16];
          _sk6l::P64 = P64[R1 + 24];
          _sk6n::P64 = P64[R1 + 32];
          _sk6o::P64 = P64[R1 + 40];
          _sk6r::P64 = P64[R1 + 48];
          I64[Hp - 48] = sat_sk6S_info;
          P64[Hp - 32] = _sk6k::P64;
          P64[Hp - 24] = _sk6l::P64;
          P64[Hp - 16] = _sk6n::P64;
          P64[Hp - 8] = _sk6o::P64;
          P64[Hp] = _sk6r::P64;
          R3 = Hp - 48;
          R2 = lvl7_rjV4_closure;
          call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:55.461419 UTC

sat_sk6T_entry() //  [R1]
        { info_tbl: [(cl9W,
                      label: sat_sk6T_info
                      rep:HeapRep 5 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cl9W:
          Hp = Hp + 56;
          if (Hp > HpLim) goto cla0; else goto cl9Z;
      cla0:
          HpAlloc = 56;
          R1 = R1;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      cl9Z:
          _sk6k::P64 = P64[R1 + 16];
          _sk6l::P64 = P64[R1 + 24];
          _sk6n::P64 = P64[R1 + 32];
          _sk6o::P64 = P64[R1 + 40];
          _sk6r::P64 = P64[R1 + 48];
          I64[Hp - 48] = sat_sk6S_info;
          P64[Hp - 32] = _sk6k::P64;
          P64[Hp - 24] = _sk6l::P64;
          P64[Hp - 16] = _sk6n::P64;
          P64[Hp - 8] = _sk6o::P64;
          P64[Hp] = _sk6r::P64;
          R3 = Hp - 48;
          R2 = lvl7_rjV4_closure;
          call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:55.462942 UTC

{offset
  cla1:
      _sk6w::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cla2; else goto cla3;
  cla3:
      Hp = Hp + 56;
      if (Hp > HpLim) goto cla5; else goto cla4;
  cla5:
      HpAlloc = 56;
      goto cla2;
  cla2:
      R1 = _sk6w::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cla4:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sk6w::P64;
      _sk6k::P64 = P64[_sk6w::P64 + 16];
      _sk6l::P64 = P64[_sk6w::P64 + 24];
      _sk6n::P64 = P64[_sk6w::P64 + 32];
      _sk6o::P64 = P64[_sk6w::P64 + 40];
      _sk6r::P64 = P64[_sk6w::P64 + 48];
      I64[Hp - 48] = sat_sk6T_info;
      P64[Hp - 32] = _sk6k::P64;
      P64[Hp - 24] = _sk6l::P64;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      _cl7F::P64 = Hp - 48;
      R3 = _cl7F::P64;
      R2 = lvl3_rjV0_closure;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:55.4645 UTC

{offset
  cla1:
      _sk6w::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cla2; else goto cla3;
  cla3:
      Hp = Hp + 56;
      if (Hp > HpLim) goto cla5; else goto cla4;
  cla5:
      HpAlloc = 56;
      goto cla2;
  cla2:
      R1 = _sk6w::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cla4:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sk6w::P64;
      _sk6k::P64 = P64[_sk6w::P64 + 16];
      _sk6l::P64 = P64[_sk6w::P64 + 24];
      _sk6n::P64 = P64[_sk6w::P64 + 32];
      _sk6o::P64 = P64[_sk6w::P64 + 40];
      _sk6r::P64 = P64[_sk6w::P64 + 48];
      I64[Hp - 48] = sat_sk6T_info;
      P64[Hp - 32] = _sk6k::P64;
      P64[Hp - 24] = _sk6l::P64;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      _cl7F::P64 = Hp - 48;
      R3 = _cl7F::P64;
      R2 = lvl3_rjV0_closure;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:55.46606 UTC

{offset
  cla1:
      _sk6w::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto cla2; else goto cla3;
  cla3:
      Hp = Hp + 56;
      if (Hp > HpLim) goto cla5; else goto cla4;
  cla5:
      HpAlloc = 56;
      goto cla2;
  cla2:
      R1 = _sk6w::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cla4:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sk6w::P64;
      _sk6k::P64 = P64[_sk6w::P64 + 16];
      _sk6l::P64 = P64[_sk6w::P64 + 24];
      _sk6n::P64 = P64[_sk6w::P64 + 32];
      _sk6o::P64 = P64[_sk6w::P64 + 40];
      _sk6r::P64 = P64[_sk6w::P64 + 48];
      I64[Hp - 48] = sat_sk6T_info;
      P64[Hp - 32] = _sk6k::P64;
      P64[Hp - 24] = _sk6l::P64;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      _cl7F::P64 = Hp - 48;
      R3 = _cl7F::P64;
      R2 = lvl3_rjV0_closure;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:55.467721 UTC

{offset
  cla1:
      _sk6w::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto cla2; else goto cla3;
  cla3:
      Hp = Hp + 56;
      if (Hp > HpLim) goto cla5; else goto cla4;
  cla5:
      HpAlloc = 56;
      goto cla2;
  cla2:
      R1 = _sk6w::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cla4:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _sk6w::P64;
      _sk6k::P64 = P64[_sk6w::P64 + 16];
      _sk6l::P64 = P64[_sk6w::P64 + 24];
      _sk6n::P64 = P64[_sk6w::P64 + 32];
      _sk6o::P64 = P64[_sk6w::P64 + 40];
      _sk6r::P64 = P64[_sk6w::P64 + 48];
      I64[Hp - 48] = sat_sk6T_info;
      P64[Hp - 32] = _sk6k::P64;
      P64[Hp - 24] = _sk6l::P64;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      _cl7F::P64 = Hp - 48;
      R3 = _cl7F::P64;
      R2 = lvl3_rjV0_closure;
      Sp = Sp - 16;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:55.469301 UTC

{offset
  cla1:
      _sk6w::P64 = R1;
      if ((Sp + -16) < SpLim) goto cla2; else goto cla3;
  cla3:
      Hp = Hp + 56;
      if (Hp > HpLim) goto cla5; else goto cla4;
  cla5:
      HpAlloc = 56;
      goto cla2;
  cla2:
      R1 = _sk6w::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  cla4:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _sk6w::P64;
      _sk6k::P64 = P64[_sk6w::P64 + 16];
      _sk6l::P64 = P64[_sk6w::P64 + 24];
      _sk6n::P64 = P64[_sk6w::P64 + 32];
      _sk6o::P64 = P64[_sk6w::P64 + 40];
      _sk6r::P64 = P64[_sk6w::P64 + 48];
      I64[Hp - 48] = sat_sk6T_info;
      P64[Hp - 32] = _sk6k::P64;
      P64[Hp - 24] = _sk6l::P64;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      R3 = Hp - 48;
      R2 = lvl3_rjV0_closure;
      Sp = Sp - 16;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:55.471042 UTC

[(cla1, {lvl3_rjV0_closure, sat_sk6T_closure}), (cla2, {}),
 (cla3, {lvl3_rjV0_closure, sat_sk6T_closure}),
 (cla4, {lvl3_rjV0_closure, sat_sk6T_closure}), (cla5, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:55.471567 UTC

eta_sk6w_entry() //  [R1]
        { info_tbl: [(cla1,
                      label: eta_sk6w_info
                      rep:HeapRep 5 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cla1:
          _sk6w::P64 = R1;
          if ((Sp + -16) < SpLim) goto cla2; else goto cla3;
      cla3:
          Hp = Hp + 56;
          if (Hp > HpLim) goto cla5; else goto cla4;
      cla5:
          HpAlloc = 56;
          goto cla2;
      cla2:
          R1 = _sk6w::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      cla4:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _sk6w::P64;
          _sk6k::P64 = P64[_sk6w::P64 + 16];
          _sk6l::P64 = P64[_sk6w::P64 + 24];
          _sk6n::P64 = P64[_sk6w::P64 + 32];
          _sk6o::P64 = P64[_sk6w::P64 + 40];
          _sk6r::P64 = P64[_sk6w::P64 + 48];
          I64[Hp - 48] = sat_sk6T_info;
          P64[Hp - 32] = _sk6k::P64;
          P64[Hp - 24] = _sk6l::P64;
          P64[Hp - 16] = _sk6n::P64;
          P64[Hp - 8] = _sk6o::P64;
          P64[Hp] = _sk6r::P64;
          R3 = Hp - 48;
          R2 = lvl3_rjV0_closure;
          Sp = Sp - 16;
          call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:55.473384 UTC

eta_sk6w_entry() //  [R1]
        { info_tbl: [(cla1,
                      label: eta_sk6w_info
                      rep:HeapRep 5 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cla1:
          _sk6w::P64 = R1;
          if ((Sp + -16) < SpLim) goto cla2; else goto cla3;
      cla3:
          Hp = Hp + 56;
          if (Hp > HpLim) goto cla5; else goto cla4;
      cla5:
          HpAlloc = 56;
          goto cla2;
      cla2:
          R1 = _sk6w::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      cla4:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _sk6w::P64;
          _sk6k::P64 = P64[_sk6w::P64 + 16];
          _sk6l::P64 = P64[_sk6w::P64 + 24];
          _sk6n::P64 = P64[_sk6w::P64 + 32];
          _sk6o::P64 = P64[_sk6w::P64 + 40];
          _sk6r::P64 = P64[_sk6w::P64 + 48];
          I64[Hp - 48] = sat_sk6T_info;
          P64[Hp - 32] = _sk6k::P64;
          P64[Hp - 24] = _sk6l::P64;
          P64[Hp - 16] = _sk6n::P64;
          P64[Hp - 8] = _sk6o::P64;
          P64[Hp] = _sk6r::P64;
          R3 = Hp - 48;
          R2 = lvl3_rjV0_closure;
          Sp = Sp - 16;
          call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:55.475222 UTC

{offset
  clad:
      _sk6V::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto clae; else goto claf;
  claf:
      Hp = Hp + 56;
      if (Hp > HpLim) goto clah; else goto clag;
  clah:
      HpAlloc = 56;
      goto clae;
  clae:
      R1 = _sk6V::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  clag:
      _sk6j::P64 = P64[_sk6V::P64 + 16];
      _sk6k::P64 = P64[_sk6V::P64 + 24];
      _sk6l::P64 = P64[_sk6V::P64 + 32];
      _sk6n::P64 = P64[_sk6V::P64 + 40];
      _sk6o::P64 = P64[_sk6V::P64 + 48];
      _sk6r::P64 = P64[_sk6V::P64 + 56];
      I64[Hp - 48] = eta_sk6w_info;
      P64[Hp - 32] = _sk6k::P64;
      P64[Hp - 24] = _sk6l::P64;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      _cl7B::P64 = Hp - 48;
      I64[(young<cla6> + 8)] = cla6;
      R1 = _sk6j::P64;
      if (R1 & 7 != 0) goto cla6; else goto cla7;
  cla7:
      call (I64[R1])(R1) returns to cla6, args: 8, res: 8, upd: 8;
  cla6:
      _sk6U::P64 = R1;
      _clac::P64 = _sk6U::P64 & 7;
      switch [1 .. 2] _clac::P64 {
          case 1 : goto claa;
          case 2 : goto clab;
      }
  clab:
      R3 = _cl7B::P64;
      R2 = GHC.Show.shows16_closure;
      call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
  claa:
      R3 = _cl7B::P64;
      R2 = GHC.Show.shows17_closure;
      call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:55.477455 UTC

{offset
  clad:
      _sk6V::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto clae; else goto claf;
  claf:
      Hp = Hp + 56;
      if (Hp > HpLim) goto clah; else goto clag;
  clah:
      HpAlloc = 56;
      goto clae;
  clae:
      R1 = _sk6V::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  clag:
      _sk6j::P64 = P64[_sk6V::P64 + 16];
      _sk6k::P64 = P64[_sk6V::P64 + 24];
      _sk6l::P64 = P64[_sk6V::P64 + 32];
      _sk6n::P64 = P64[_sk6V::P64 + 40];
      _sk6o::P64 = P64[_sk6V::P64 + 48];
      _sk6r::P64 = P64[_sk6V::P64 + 56];
      I64[Hp - 48] = eta_sk6w_info;
      P64[Hp - 32] = _sk6k::P64;
      P64[Hp - 24] = _sk6l::P64;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      _cl7B::P64 = Hp - 48;
      I64[(young<cla6> + 8)] = cla6;
      R1 = _sk6j::P64;
      if (R1 & 7 != 0) goto cla6; else goto cla7;
  cla7:
      call (I64[R1])(R1) returns to cla6, args: 8, res: 8, upd: 8;
  cla6:
      _sk6U::P64 = R1;
      _clac::P64 = _sk6U::P64 & 7;
      switch [1 .. 2] _clac::P64 {
          case 1 : goto claa;
          case 2 : goto clab;
      }
  clab:
      R3 = _cl7B::P64;
      R2 = GHC.Show.shows16_closure;
      call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
  claa:
      R3 = _cl7B::P64;
      R2 = GHC.Show.shows17_closure;
      call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:55.479744 UTC

{offset
  clad:
      _sk6V::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto clae; else goto claf;
  claf:
      Hp = Hp + 56;
      if (Hp > HpLim) goto clah; else goto clag;
  clah:
      HpAlloc = 56;
      goto clae;
  clae:
      R1 = _sk6V::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  clag:
      _sk6j::P64 = P64[_sk6V::P64 + 16];
      _sk6k::P64 = P64[_sk6V::P64 + 24];
      _sk6l::P64 = P64[_sk6V::P64 + 32];
      _sk6n::P64 = P64[_sk6V::P64 + 40];
      _sk6o::P64 = P64[_sk6V::P64 + 48];
      _sk6r::P64 = P64[_sk6V::P64 + 56];
      I64[Hp - 48] = eta_sk6w_info;
      P64[Hp - 32] = _sk6k::P64;
      P64[Hp - 24] = _sk6l::P64;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      _cl7B::P64 = Hp - 48;
      I64[(young<cla6> + 8)] = cla6;
      R1 = _sk6j::P64;
      if (R1 & 7 != 0) goto cla6; else goto cla7;
  cla7:
      call (I64[R1])(R1) returns to cla6, args: 8, res: 8, upd: 8;
  cla6:
      _sk6U::P64 = R1;
      _clac::P64 = _sk6U::P64 & 7;
      if (_clac::P64 != 1) goto clab; else goto claa;
  clab:
      R3 = _cl7B::P64;
      R2 = GHC.Show.shows16_closure;
      call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
  claa:
      R3 = _cl7B::P64;
      R2 = GHC.Show.shows17_closure;
      call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:55.482174 UTC

{offset
  clad:
      _sk6V::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto clae; else goto claf;
  claf:
      Hp = Hp + 56;
      if (Hp > HpLim) goto clah; else goto clag;
  clah:
      HpAlloc = 56;
      goto clae;
  clae:
      R1 = _sk6V::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  clag:
      _sk6j::P64 = P64[_sk6V::P64 + 16];
      _sk6k::P64 = P64[_sk6V::P64 + 24];
      _sk6l::P64 = P64[_sk6V::P64 + 32];
      _sk6n::P64 = P64[_sk6V::P64 + 40];
      _sk6o::P64 = P64[_sk6V::P64 + 48];
      _sk6r::P64 = P64[_sk6V::P64 + 56];
      I64[Hp - 48] = eta_sk6w_info;
      P64[Hp - 32] = _sk6k::P64;
      P64[Hp - 24] = _sk6l::P64;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      _cl7B::P64 = Hp - 48;
      I64[Sp - 16] = cla6;
      R1 = _sk6j::P64;
      P64[Sp - 8] = _cl7B::P64;
      Sp = Sp - 16;
      if (R1 & 7 != 0) goto cla6; else goto cla7;
  cla7:
      call (I64[R1])(R1) returns to cla6, args: 8, res: 8, upd: 8;
  cla6:
      _cl7B::P64 = P64[Sp + 8];
      _sk6U::P64 = R1;
      _clac::P64 = _sk6U::P64 & 7;
      if (_clac::P64 != 1) goto clab; else goto claa;
  clab:
      R3 = _cl7B::P64;
      R2 = GHC.Show.shows16_closure;
      Sp = Sp + 16;
      call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
  claa:
      R3 = _cl7B::P64;
      R2 = GHC.Show.shows17_closure;
      Sp = Sp + 16;
      call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:55.4846 UTC

{offset
  clad:
      _sk6V::P64 = R1;
      if ((Sp + -16) < SpLim) goto clae; else goto claf;
  claf:
      Hp = Hp + 56;
      if (Hp > HpLim) goto clah; else goto clag;
  clah:
      HpAlloc = 56;
      goto clae;
  clae:
      R1 = _sk6V::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  clag:
      _sk6j::P64 = P64[_sk6V::P64 + 16];
      _sk6k::P64 = P64[_sk6V::P64 + 24];
      _sk6l::P64 = P64[_sk6V::P64 + 32];
      _sk6n::P64 = P64[_sk6V::P64 + 40];
      _sk6o::P64 = P64[_sk6V::P64 + 48];
      _sk6r::P64 = P64[_sk6V::P64 + 56];
      I64[Hp - 48] = eta_sk6w_info;
      P64[Hp - 32] = _sk6k::P64;
      P64[Hp - 24] = _sk6l::P64;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      I64[Sp - 16] = cla6;
      R1 = _sk6j::P64;
      P64[Sp - 8] = Hp - 48;
      Sp = Sp - 16;
      if (R1 & 7 != 0) goto cla6; else goto cla7;
  cla7:
      call (I64[R1])(R1) returns to cla6, args: 8, res: 8, upd: 8;
  cla6:
      _cl7B::P64 = P64[Sp + 8];
      if (R1 & 7 != 1) goto clab; else goto claa;
  clab:
      R3 = _cl7B::P64;
      R2 = GHC.Show.shows16_closure;
      Sp = Sp + 16;
      call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
  claa:
      R3 = _cl7B::P64;
      R2 = GHC.Show.shows17_closure;
      Sp = Sp + 16;
      call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:55.487146 UTC

[(cla6, {GHC.Show.shows16_closure, GHC.Show.shows17_closure}),
 (cla7, {GHC.Show.shows16_closure, GHC.Show.shows17_closure}),
 (claa, {GHC.Show.shows17_closure}),
 (clab, {GHC.Show.shows16_closure}),
 (clad,
  {GHC.Show.shows16_closure, GHC.Show.shows17_closure,
   eta_sk6w_closure}),
 (clae, {}),
 (claf,
  {GHC.Show.shows16_closure, GHC.Show.shows17_closure,
   eta_sk6w_closure}),
 (clag,
  {GHC.Show.shows16_closure, GHC.Show.shows17_closure,
   eta_sk6w_closure}),
 (clah, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:55.488136 UTC

sat_sk6V_entry() //  [R1]
        { info_tbl: [(cla6,
                      label: block_cla6_info
                      rep:StackRep [False]),
                     (clad,
                      label: sat_sk6V_info
                      rep:HeapRep 6 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      clad:
          _sk6V::P64 = R1;
          if ((Sp + -16) < SpLim) goto clae; else goto claf;
      claf:
          Hp = Hp + 56;
          if (Hp > HpLim) goto clah; else goto clag;
      clah:
          HpAlloc = 56;
          goto clae;
      clae:
          R1 = _sk6V::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      clag:
          _sk6j::P64 = P64[_sk6V::P64 + 16];
          _sk6k::P64 = P64[_sk6V::P64 + 24];
          _sk6l::P64 = P64[_sk6V::P64 + 32];
          _sk6n::P64 = P64[_sk6V::P64 + 40];
          _sk6o::P64 = P64[_sk6V::P64 + 48];
          _sk6r::P64 = P64[_sk6V::P64 + 56];
          I64[Hp - 48] = eta_sk6w_info;
          P64[Hp - 32] = _sk6k::P64;
          P64[Hp - 24] = _sk6l::P64;
          P64[Hp - 16] = _sk6n::P64;
          P64[Hp - 8] = _sk6o::P64;
          P64[Hp] = _sk6r::P64;
          I64[Sp - 16] = cla6;
          R1 = _sk6j::P64;
          P64[Sp - 8] = Hp - 48;
          Sp = Sp - 16;
          if (R1 & 7 != 0) goto cla6; else goto cla7;
      cla7:
          call (I64[R1])(R1) returns to cla6, args: 8, res: 8, upd: 8;
      cla6:
          _cl7B::P64 = P64[Sp + 8];
          if (R1 & 7 != 1) goto clab; else goto claa;
      clab:
          R3 = _cl7B::P64;
          R2 = GHC.Show.shows16_closure;
          Sp = Sp + 16;
          call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
      claa:
          R3 = _cl7B::P64;
          R2 = GHC.Show.shows17_closure;
          Sp = Sp + 16;
          call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:55.490845 UTC

sat_sk6V_entry() //  [R1]
        { info_tbl: [(cla6,
                      label: block_cla6_info
                      rep:StackRep [False]),
                     (clad,
                      label: sat_sk6V_info
                      rep:HeapRep 6 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      clad:
          _sk6V::P64 = R1;
          if ((Sp + -16) < SpLim) goto clae; else goto claf;
      claf:
          Hp = Hp + 56;
          if (Hp > HpLim) goto clah; else goto clag;
      clah:
          HpAlloc = 56;
          goto clae;
      clae:
          R1 = _sk6V::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      clag:
          _sk6j::P64 = P64[_sk6V::P64 + 16];
          _sk6k::P64 = P64[_sk6V::P64 + 24];
          _sk6l::P64 = P64[_sk6V::P64 + 32];
          _sk6n::P64 = P64[_sk6V::P64 + 40];
          _sk6o::P64 = P64[_sk6V::P64 + 48];
          _sk6r::P64 = P64[_sk6V::P64 + 56];
          I64[Hp - 48] = eta_sk6w_info;
          P64[Hp - 32] = _sk6k::P64;
          P64[Hp - 24] = _sk6l::P64;
          P64[Hp - 16] = _sk6n::P64;
          P64[Hp - 8] = _sk6o::P64;
          P64[Hp] = _sk6r::P64;
          I64[Sp - 16] = cla6;
          R1 = _sk6j::P64;
          P64[Sp - 8] = Hp - 48;
          Sp = Sp - 16;
          if (R1 & 7 != 0) goto cla6; else goto cla7;
      cla7:
          call (I64[R1])(R1) returns to cla6, args: 8, res: 8, upd: 8;
      cla6:
          _cl7B::P64 = P64[Sp + 8];
          if (R1 & 7 != 1) goto clab; else goto claa;
      clab:
          R3 = _cl7B::P64;
          R2 = GHC.Show.shows16_closure;
          Sp = Sp + 16;
          call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
      claa:
          R3 = _cl7B::P64;
          R2 = GHC.Show.shows17_closure;
          Sp = Sp + 16;
          call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:55.493532 UTC

{offset
  clao:
      _sk6W::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto clap; else goto claq;
  claq:
      Hp = Hp + 64;
      if (Hp > HpLim) goto clas; else goto clar;
  clas:
      HpAlloc = 64;
      goto clap;
  clap:
      R1 = _sk6W::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  clar:
      _sk6j::P64 = P64[_sk6W::P64 + 16];
      _sk6k::P64 = P64[_sk6W::P64 + 24];
      _sk6l::P64 = P64[_sk6W::P64 + 32];
      _sk6n::P64 = P64[_sk6W::P64 + 40];
      _sk6o::P64 = P64[_sk6W::P64 + 48];
      _sk6r::P64 = P64[_sk6W::P64 + 56];
      I64[Hp - 56] = sat_sk6V_info;
      P64[Hp - 40] = _sk6j::P64;
      P64[Hp - 32] = _sk6k::P64;
      P64[Hp - 24] = _sk6l::P64;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      _cl7x::P64 = Hp - 56;
      R3 = _cl7x::P64;
      R2 = lvl8_rjV5_closure;
      call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:55.49572 UTC

{offset
  clao:
      _sk6W::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto clap; else goto claq;
  claq:
      Hp = Hp + 64;
      if (Hp > HpLim) goto clas; else goto clar;
  clas:
      HpAlloc = 64;
      goto clap;
  clap:
      R1 = _sk6W::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  clar:
      _sk6j::P64 = P64[_sk6W::P64 + 16];
      _sk6k::P64 = P64[_sk6W::P64 + 24];
      _sk6l::P64 = P64[_sk6W::P64 + 32];
      _sk6n::P64 = P64[_sk6W::P64 + 40];
      _sk6o::P64 = P64[_sk6W::P64 + 48];
      _sk6r::P64 = P64[_sk6W::P64 + 56];
      I64[Hp - 56] = sat_sk6V_info;
      P64[Hp - 40] = _sk6j::P64;
      P64[Hp - 32] = _sk6k::P64;
      P64[Hp - 24] = _sk6l::P64;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      _cl7x::P64 = Hp - 56;
      R3 = _cl7x::P64;
      R2 = lvl8_rjV5_closure;
      call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:55.497343 UTC

{offset
  clao:
      _sk6W::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto clap; else goto claq;
  claq:
      Hp = Hp + 64;
      if (Hp > HpLim) goto clas; else goto clar;
  clas:
      HpAlloc = 64;
      goto clap;
  clap:
      R1 = _sk6W::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  clar:
      _sk6j::P64 = P64[_sk6W::P64 + 16];
      _sk6k::P64 = P64[_sk6W::P64 + 24];
      _sk6l::P64 = P64[_sk6W::P64 + 32];
      _sk6n::P64 = P64[_sk6W::P64 + 40];
      _sk6o::P64 = P64[_sk6W::P64 + 48];
      _sk6r::P64 = P64[_sk6W::P64 + 56];
      I64[Hp - 56] = sat_sk6V_info;
      P64[Hp - 40] = _sk6j::P64;
      P64[Hp - 32] = _sk6k::P64;
      P64[Hp - 24] = _sk6l::P64;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      _cl7x::P64 = Hp - 56;
      R3 = _cl7x::P64;
      R2 = lvl8_rjV5_closure;
      call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:55.498977 UTC

{offset
  clao:
      _sk6W::P64 = R1;
      goto claq;
  claq:
      Hp = Hp + 64;
      if (Hp > HpLim) goto clas; else goto clar;
  clas:
      HpAlloc = 64;
      goto clap;
  clap:
      R1 = _sk6W::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  clar:
      _sk6j::P64 = P64[_sk6W::P64 + 16];
      _sk6k::P64 = P64[_sk6W::P64 + 24];
      _sk6l::P64 = P64[_sk6W::P64 + 32];
      _sk6n::P64 = P64[_sk6W::P64 + 40];
      _sk6o::P64 = P64[_sk6W::P64 + 48];
      _sk6r::P64 = P64[_sk6W::P64 + 56];
      I64[Hp - 56] = sat_sk6V_info;
      P64[Hp - 40] = _sk6j::P64;
      P64[Hp - 32] = _sk6k::P64;
      P64[Hp - 24] = _sk6l::P64;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      _cl7x::P64 = Hp - 56;
      R3 = _cl7x::P64;
      R2 = lvl8_rjV5_closure;
      call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:55.500571 UTC

{offset
  clao:
      goto claq;
  claq:
      Hp = Hp + 64;
      if (Hp > HpLim) goto clas; else goto clar;
  clas:
      HpAlloc = 64;
      goto clap;
  clap:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  clar:
      _sk6j::P64 = P64[R1 + 16];
      _sk6k::P64 = P64[R1 + 24];
      _sk6l::P64 = P64[R1 + 32];
      _sk6n::P64 = P64[R1 + 40];
      _sk6o::P64 = P64[R1 + 48];
      _sk6r::P64 = P64[R1 + 56];
      I64[Hp - 56] = sat_sk6V_info;
      P64[Hp - 40] = _sk6j::P64;
      P64[Hp - 32] = _sk6k::P64;
      P64[Hp - 24] = _sk6l::P64;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      R3 = Hp - 56;
      R2 = lvl8_rjV5_closure;
      call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:55.502246 UTC

[(clao, {lvl8_rjV5_closure, sat_sk6V_closure}), (clap, {}),
 (claq, {lvl8_rjV5_closure, sat_sk6V_closure}),
 (clar, {lvl8_rjV5_closure, sat_sk6V_closure}), (clas, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:55.502767 UTC

sat_sk6W_entry() //  [R1]
        { info_tbl: [(clao,
                      label: sat_sk6W_info
                      rep:HeapRep 6 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      clao:
          goto claq;
      claq:
          Hp = Hp + 64;
          if (Hp > HpLim) goto clas; else goto clar;
      clas:
          HpAlloc = 64;
          goto clap;
      clap:
          R1 = R1;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      clar:
          _sk6j::P64 = P64[R1 + 16];
          _sk6k::P64 = P64[R1 + 24];
          _sk6l::P64 = P64[R1 + 32];
          _sk6n::P64 = P64[R1 + 40];
          _sk6o::P64 = P64[R1 + 48];
          _sk6r::P64 = P64[R1 + 56];
          I64[Hp - 56] = sat_sk6V_info;
          P64[Hp - 40] = _sk6j::P64;
          P64[Hp - 32] = _sk6k::P64;
          P64[Hp - 24] = _sk6l::P64;
          P64[Hp - 16] = _sk6n::P64;
          P64[Hp - 8] = _sk6o::P64;
          P64[Hp] = _sk6r::P64;
          R3 = Hp - 56;
          R2 = lvl8_rjV5_closure;
          call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:55.504419 UTC

sat_sk6W_entry() //  [R1]
        { info_tbl: [(clao,
                      label: sat_sk6W_info
                      rep:HeapRep 6 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      clao:
          Hp = Hp + 64;
          if (Hp > HpLim) goto clas; else goto clar;
      clas:
          HpAlloc = 64;
          R1 = R1;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      clar:
          _sk6j::P64 = P64[R1 + 16];
          _sk6k::P64 = P64[R1 + 24];
          _sk6l::P64 = P64[R1 + 32];
          _sk6n::P64 = P64[R1 + 40];
          _sk6o::P64 = P64[R1 + 48];
          _sk6r::P64 = P64[R1 + 56];
          I64[Hp - 56] = sat_sk6V_info;
          P64[Hp - 40] = _sk6j::P64;
          P64[Hp - 32] = _sk6k::P64;
          P64[Hp - 24] = _sk6l::P64;
          P64[Hp - 16] = _sk6n::P64;
          P64[Hp - 8] = _sk6o::P64;
          P64[Hp] = _sk6r::P64;
          R3 = Hp - 56;
          R2 = lvl8_rjV5_closure;
          call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:55.506034 UTC

{offset
  clat:
      _sk6X::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto clau; else goto clav;
  clav:
      Hp = Hp + 64;
      if (Hp > HpLim) goto clax; else goto claw;
  clax:
      HpAlloc = 64;
      goto clau;
  clau:
      R1 = _sk6X::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  claw:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sk6X::P64;
      _sk6j::P64 = P64[_sk6X::P64 + 16];
      _sk6k::P64 = P64[_sk6X::P64 + 24];
      _sk6l::P64 = P64[_sk6X::P64 + 32];
      _sk6n::P64 = P64[_sk6X::P64 + 40];
      _sk6o::P64 = P64[_sk6X::P64 + 48];
      _sk6r::P64 = P64[_sk6X::P64 + 56];
      I64[Hp - 56] = sat_sk6W_info;
      P64[Hp - 40] = _sk6j::P64;
      P64[Hp - 32] = _sk6k::P64;
      P64[Hp - 24] = _sk6l::P64;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      _cl7t::P64 = Hp - 56;
      R3 = _cl7t::P64;
      R2 = lvl3_rjV0_closure;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:55.507723 UTC

{offset
  clat:
      _sk6X::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto clau; else goto clav;
  clav:
      Hp = Hp + 64;
      if (Hp > HpLim) goto clax; else goto claw;
  clax:
      HpAlloc = 64;
      goto clau;
  clau:
      R1 = _sk6X::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  claw:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sk6X::P64;
      _sk6j::P64 = P64[_sk6X::P64 + 16];
      _sk6k::P64 = P64[_sk6X::P64 + 24];
      _sk6l::P64 = P64[_sk6X::P64 + 32];
      _sk6n::P64 = P64[_sk6X::P64 + 40];
      _sk6o::P64 = P64[_sk6X::P64 + 48];
      _sk6r::P64 = P64[_sk6X::P64 + 56];
      I64[Hp - 56] = sat_sk6W_info;
      P64[Hp - 40] = _sk6j::P64;
      P64[Hp - 32] = _sk6k::P64;
      P64[Hp - 24] = _sk6l::P64;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      _cl7t::P64 = Hp - 56;
      R3 = _cl7t::P64;
      R2 = lvl3_rjV0_closure;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:55.509423 UTC

{offset
  clat:
      _sk6X::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto clau; else goto clav;
  clav:
      Hp = Hp + 64;
      if (Hp > HpLim) goto clax; else goto claw;
  clax:
      HpAlloc = 64;
      goto clau;
  clau:
      R1 = _sk6X::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  claw:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sk6X::P64;
      _sk6j::P64 = P64[_sk6X::P64 + 16];
      _sk6k::P64 = P64[_sk6X::P64 + 24];
      _sk6l::P64 = P64[_sk6X::P64 + 32];
      _sk6n::P64 = P64[_sk6X::P64 + 40];
      _sk6o::P64 = P64[_sk6X::P64 + 48];
      _sk6r::P64 = P64[_sk6X::P64 + 56];
      I64[Hp - 56] = sat_sk6W_info;
      P64[Hp - 40] = _sk6j::P64;
      P64[Hp - 32] = _sk6k::P64;
      P64[Hp - 24] = _sk6l::P64;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      _cl7t::P64 = Hp - 56;
      R3 = _cl7t::P64;
      R2 = lvl3_rjV0_closure;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:55.51116 UTC

{offset
  clat:
      _sk6X::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto clau; else goto clav;
  clav:
      Hp = Hp + 64;
      if (Hp > HpLim) goto clax; else goto claw;
  clax:
      HpAlloc = 64;
      goto clau;
  clau:
      R1 = _sk6X::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  claw:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _sk6X::P64;
      _sk6j::P64 = P64[_sk6X::P64 + 16];
      _sk6k::P64 = P64[_sk6X::P64 + 24];
      _sk6l::P64 = P64[_sk6X::P64 + 32];
      _sk6n::P64 = P64[_sk6X::P64 + 40];
      _sk6o::P64 = P64[_sk6X::P64 + 48];
      _sk6r::P64 = P64[_sk6X::P64 + 56];
      I64[Hp - 56] = sat_sk6W_info;
      P64[Hp - 40] = _sk6j::P64;
      P64[Hp - 32] = _sk6k::P64;
      P64[Hp - 24] = _sk6l::P64;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      _cl7t::P64 = Hp - 56;
      R3 = _cl7t::P64;
      R2 = lvl3_rjV0_closure;
      Sp = Sp - 16;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:55.51288 UTC

{offset
  clat:
      _sk6X::P64 = R1;
      if ((Sp + -16) < SpLim) goto clau; else goto clav;
  clav:
      Hp = Hp + 64;
      if (Hp > HpLim) goto clax; else goto claw;
  clax:
      HpAlloc = 64;
      goto clau;
  clau:
      R1 = _sk6X::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  claw:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _sk6X::P64;
      _sk6j::P64 = P64[_sk6X::P64 + 16];
      _sk6k::P64 = P64[_sk6X::P64 + 24];
      _sk6l::P64 = P64[_sk6X::P64 + 32];
      _sk6n::P64 = P64[_sk6X::P64 + 40];
      _sk6o::P64 = P64[_sk6X::P64 + 48];
      _sk6r::P64 = P64[_sk6X::P64 + 56];
      I64[Hp - 56] = sat_sk6W_info;
      P64[Hp - 40] = _sk6j::P64;
      P64[Hp - 32] = _sk6k::P64;
      P64[Hp - 24] = _sk6l::P64;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      R3 = Hp - 56;
      R2 = lvl3_rjV0_closure;
      Sp = Sp - 16;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:55.514752 UTC

[(clat, {lvl3_rjV0_closure, sat_sk6W_closure}), (clau, {}),
 (clav, {lvl3_rjV0_closure, sat_sk6W_closure}),
 (claw, {lvl3_rjV0_closure, sat_sk6W_closure}), (clax, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:55.515274 UTC

sat_sk6X_entry() //  [R1]
        { info_tbl: [(clat,
                      label: sat_sk6X_info
                      rep:HeapRep 6 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      clat:
          _sk6X::P64 = R1;
          if ((Sp + -16) < SpLim) goto clau; else goto clav;
      clav:
          Hp = Hp + 64;
          if (Hp > HpLim) goto clax; else goto claw;
      clax:
          HpAlloc = 64;
          goto clau;
      clau:
          R1 = _sk6X::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      claw:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _sk6X::P64;
          _sk6j::P64 = P64[_sk6X::P64 + 16];
          _sk6k::P64 = P64[_sk6X::P64 + 24];
          _sk6l::P64 = P64[_sk6X::P64 + 32];
          _sk6n::P64 = P64[_sk6X::P64 + 40];
          _sk6o::P64 = P64[_sk6X::P64 + 48];
          _sk6r::P64 = P64[_sk6X::P64 + 56];
          I64[Hp - 56] = sat_sk6W_info;
          P64[Hp - 40] = _sk6j::P64;
          P64[Hp - 32] = _sk6k::P64;
          P64[Hp - 24] = _sk6l::P64;
          P64[Hp - 16] = _sk6n::P64;
          P64[Hp - 8] = _sk6o::P64;
          P64[Hp] = _sk6r::P64;
          R3 = Hp - 56;
          R2 = lvl3_rjV0_closure;
          Sp = Sp - 16;
          call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:55.517236 UTC

sat_sk6X_entry() //  [R1]
        { info_tbl: [(clat,
                      label: sat_sk6X_info
                      rep:HeapRep 6 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      clat:
          _sk6X::P64 = R1;
          if ((Sp + -16) < SpLim) goto clau; else goto clav;
      clav:
          Hp = Hp + 64;
          if (Hp > HpLim) goto clax; else goto claw;
      clax:
          HpAlloc = 64;
          goto clau;
      clau:
          R1 = _sk6X::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      claw:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _sk6X::P64;
          _sk6j::P64 = P64[_sk6X::P64 + 16];
          _sk6k::P64 = P64[_sk6X::P64 + 24];
          _sk6l::P64 = P64[_sk6X::P64 + 32];
          _sk6n::P64 = P64[_sk6X::P64 + 40];
          _sk6o::P64 = P64[_sk6X::P64 + 48];
          _sk6r::P64 = P64[_sk6X::P64 + 56];
          I64[Hp - 56] = sat_sk6W_info;
          P64[Hp - 40] = _sk6j::P64;
          P64[Hp - 32] = _sk6k::P64;
          P64[Hp - 24] = _sk6l::P64;
          P64[Hp - 16] = _sk6n::P64;
          P64[Hp - 8] = _sk6o::P64;
          P64[Hp] = _sk6r::P64;
          R3 = Hp - 56;
          R2 = lvl3_rjV0_closure;
          Sp = Sp - 16;
          call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:55.519247 UTC

{offset
  clay:
      _sk71::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto claC; else goto claD;
  claD:
      if (HpLim == 0) goto claC; else goto claE;
  claC:
      R1 = _sk71::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  claE:
      _sk6i::P64 = P64[_sk71::P64 + 16];
      _sk6j::P64 = P64[_sk71::P64 + 24];
      _sk6k::P64 = P64[_sk71::P64 + 32];
      _sk6l::P64 = P64[_sk71::P64 + 40];
      _sk6n::P64 = P64[_sk71::P64 + 48];
      _sk6o::P64 = P64[_sk71::P64 + 56];
      _sk6r::P64 = P64[_sk71::P64 + 64];
      I64[(young<cl7k> + 8)] = cl7k;
      R1 = _sk6i::P64;
      if (R1 & 7 != 0) goto cl7k; else goto cl7l;
  cl7l:
      call (I64[R1])(R1) returns to cl7k, args: 8, res: 8, upd: 8;
  cl7k:
      _sk6u::P64 = R1;
      Hp = Hp + 64;
      if (Hp > HpLim) goto claH; else goto claG;
  claH:
      HpAlloc = 64;
      R1 = _sk6u::P64;
      call stg_gc_unpt_r1(R1) returns to cl7k, args: 8, res: 8, upd: 8;
  claG:
      _sk6v::I64 = I64[_sk6u::P64 + 7];
      I64[Hp - 56] = sat_sk6X_info;
      P64[Hp - 40] = _sk6j::P64;
      P64[Hp - 32] = _sk6k::P64;
      P64[Hp - 24] = _sk6l::P64;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      _cl7p::P64 = Hp - 56;
      I64[(young<claz> + 8)] = claz;
      R4 = _cl7p::P64;
      R3 = _sk6v::I64;
      R2 = 0;
      call GHC.Show.$wshowSignedInt_info(R4,
                                         R3,
                                         R2) returns to claz, args: 8, res: 8, upd: 8;
  claz:
      _sk70::P64 = R2;
      _sk6Z::P64 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto claK; else goto claJ;
  claK:
      HpAlloc = 24;
      R2 = _sk70::P64;
      R1 = _sk6Z::P64;
      call stg_gc_pp(R2, R1) returns to claz, args: 8, res: 8, upd: 8;
  claJ:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _sk6Z::P64;
      P64[Hp] = _sk70::P64;
      _claB::P64 = Hp - 14;
      R1 = _claB::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:55.522185 UTC

{offset
  clay:
      _sk71::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto claC; else goto claD;
  claD:
      if (HpLim == 0) goto claC; else goto claE;
  claC:
      R1 = _sk71::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  claE:
      _sk6i::P64 = P64[_sk71::P64 + 16];
      _sk6j::P64 = P64[_sk71::P64 + 24];
      _sk6k::P64 = P64[_sk71::P64 + 32];
      _sk6l::P64 = P64[_sk71::P64 + 40];
      _sk6n::P64 = P64[_sk71::P64 + 48];
      _sk6o::P64 = P64[_sk71::P64 + 56];
      _sk6r::P64 = P64[_sk71::P64 + 64];
      I64[(young<cl7k> + 8)] = cl7k;
      R1 = _sk6i::P64;
      if (R1 & 7 != 0) goto cl7k; else goto cl7l;
  cl7l:
      call (I64[R1])(R1) returns to cl7k, args: 8, res: 8, upd: 8;
  cl7k:
      _sk6u::P64 = R1;
      Hp = Hp + 64;
      if (Hp > HpLim) goto claH; else goto claG;
  claH:
      HpAlloc = 64;
      R1 = _sk6u::P64;
      call stg_gc_unpt_r1(R1) returns to cl7k, args: 8, res: 8, upd: 8;
  claG:
      _sk6v::I64 = I64[_sk6u::P64 + 7];
      I64[Hp - 56] = sat_sk6X_info;
      P64[Hp - 40] = _sk6j::P64;
      P64[Hp - 32] = _sk6k::P64;
      P64[Hp - 24] = _sk6l::P64;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      _cl7p::P64 = Hp - 56;
      I64[(young<claz> + 8)] = claz;
      R4 = _cl7p::P64;
      R3 = _sk6v::I64;
      R2 = 0;
      call GHC.Show.$wshowSignedInt_info(R4,
                                         R3,
                                         R2) returns to claz, args: 8, res: 8, upd: 8;
  claz:
      _sk70::P64 = R2;
      _sk6Z::P64 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto claK; else goto claJ;
  claK:
      HpAlloc = 24;
      R2 = _sk70::P64;
      R1 = _sk6Z::P64;
      call stg_gc_pp(R2, R1) returns to claz, args: 8, res: 8, upd: 8;
  claJ:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _sk6Z::P64;
      P64[Hp] = _sk70::P64;
      _claB::P64 = Hp - 14;
      R1 = _claB::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:55.525223 UTC

{offset
  clay:
      _sk71::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto claC; else goto claD;
  claD:
      if (HpLim == 0) goto claC; else goto claE;
  claC:
      R1 = _sk71::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  claE:
      _sk6i::P64 = P64[_sk71::P64 + 16];
      _sk6j::P64 = P64[_sk71::P64 + 24];
      _sk6k::P64 = P64[_sk71::P64 + 32];
      _sk6l::P64 = P64[_sk71::P64 + 40];
      _sk6n::P64 = P64[_sk71::P64 + 48];
      _sk6o::P64 = P64[_sk71::P64 + 56];
      _sk6r::P64 = P64[_sk71::P64 + 64];
      I64[(young<cl7k> + 8)] = cl7k;
      R1 = _sk6i::P64;
      if (R1 & 7 != 0) goto cl7k; else goto cl7l;
  cl7l:
      call (I64[R1])(R1) returns to cl7k, args: 8, res: 8, upd: 8;
  cl7k:
      _sk6u::P64 = R1;
      Hp = Hp + 64;
      if (Hp > HpLim) goto claH; else goto claG;
  claH:
      HpAlloc = 64;
      R1 = _sk6u::P64;
      call stg_gc_unpt_r1(R1) returns to cl7k, args: 8, res: 8, upd: 8;
  claG:
      _sk6v::I64 = I64[_sk6u::P64 + 7];
      I64[Hp - 56] = sat_sk6X_info;
      P64[Hp - 40] = _sk6j::P64;
      P64[Hp - 32] = _sk6k::P64;
      P64[Hp - 24] = _sk6l::P64;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      _cl7p::P64 = Hp - 56;
      I64[(young<claz> + 8)] = claz;
      R4 = _cl7p::P64;
      R3 = _sk6v::I64;
      R2 = 0;
      call GHC.Show.$wshowSignedInt_info(R4,
                                         R3,
                                         R2) returns to claz, args: 8, res: 8, upd: 8;
  claz:
      _sk70::P64 = R2;
      _sk6Z::P64 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto claK; else goto claJ;
  claK:
      HpAlloc = 24;
      R2 = _sk70::P64;
      R1 = _sk6Z::P64;
      call stg_gc_pp(R2, R1) returns to claz, args: 8, res: 8, upd: 8;
  claJ:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _sk6Z::P64;
      P64[Hp] = _sk70::P64;
      _claB::P64 = Hp - 14;
      R1 = _claB::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:55.528609 UTC

{offset
  clay:
      _sk71::P64 = R1;
      if ((Sp + 8) - 64 < SpLim) goto claC; else goto claD;
  claD:
      if (HpLim == 0) goto claC; else goto claE;
  claC:
      R1 = _sk71::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  claE:
      _sk6i::P64 = P64[_sk71::P64 + 16];
      _sk6j::P64 = P64[_sk71::P64 + 24];
      _sk6k::P64 = P64[_sk71::P64 + 32];
      _sk6l::P64 = P64[_sk71::P64 + 40];
      _sk6n::P64 = P64[_sk71::P64 + 48];
      _sk6o::P64 = P64[_sk71::P64 + 56];
      _sk6r::P64 = P64[_sk71::P64 + 64];
      I64[Sp - 56] = cl7k;
      R1 = _sk6i::P64;
      P64[Sp - 48] = _sk6j::P64;
      P64[Sp - 40] = _sk6k::P64;
      P64[Sp - 32] = _sk6l::P64;
      P64[Sp - 24] = _sk6n::P64;
      P64[Sp - 16] = _sk6o::P64;
      P64[Sp - 8] = _sk6r::P64;
      Sp = Sp - 56;
      if (R1 & 7 != 0) goto cl7k; else goto cl7l;
  cl7l:
      call (I64[R1])(R1) returns to cl7k, args: 8, res: 8, upd: 8;
  cl7k:
      _sk6j::P64 = P64[Sp + 8];
      _sk6k::P64 = P64[Sp + 16];
      _sk6l::P64 = P64[Sp + 24];
      _sk6n::P64 = P64[Sp + 32];
      _sk6o::P64 = P64[Sp + 40];
      _sk6r::P64 = P64[Sp + 48];
      _sk6u::P64 = R1;
      Hp = Hp + 64;
      if (Hp > HpLim) goto claH; else goto claG;
  claH:
      HpAlloc = 64;
      R1 = _sk6u::P64;
      call stg_gc_unpt_r1(R1) returns to cl7k, args: 8, res: 8, upd: 8;
  claG:
      _sk6v::I64 = I64[_sk6u::P64 + 7];
      I64[Hp - 56] = sat_sk6X_info;
      P64[Hp - 40] = _sk6j::P64;
      P64[Hp - 32] = _sk6k::P64;
      P64[Hp - 24] = _sk6l::P64;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      _cl7p::P64 = Hp - 56;
      I64[Sp + 48] = claz;
      R4 = _cl7p::P64;
      R3 = _sk6v::I64;
      R2 = 0;
      Sp = Sp + 48;
      call GHC.Show.$wshowSignedInt_info(R4,
                                         R3,
                                         R2) returns to claz, args: 8, res: 8, upd: 8;
  claz:
      _sk70::P64 = R2;
      _sk6Z::P64 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto claK; else goto claJ;
  claK:
      HpAlloc = 24;
      R2 = _sk70::P64;
      R1 = _sk6Z::P64;
      call stg_gc_pp(R2, R1) returns to claz, args: 8, res: 8, upd: 8;
  claJ:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _sk6Z::P64;
      P64[Hp] = _sk70::P64;
      _claB::P64 = Hp - 14;
      R1 = _claB::P64;
      Sp = Sp + 8;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:55.532475 UTC

{offset
  clay:
      _sk71::P64 = R1;
      if ((Sp + -56) < SpLim) goto claC; else goto claD;
  claD:
      if (HpLim == 0) goto claC; else goto claE;
  claC:
      R1 = _sk71::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  claE:
      I64[Sp - 56] = cl7k;
      R1 = P64[_sk71::P64 + 16];
      P64[Sp - 48] = P64[_sk71::P64 + 24];
      P64[Sp - 40] = P64[_sk71::P64 + 32];
      P64[Sp - 32] = P64[_sk71::P64 + 40];
      P64[Sp - 24] = P64[_sk71::P64 + 48];
      P64[Sp - 16] = P64[_sk71::P64 + 56];
      P64[Sp - 8] = P64[_sk71::P64 + 64];
      Sp = Sp - 56;
      if (R1 & 7 != 0) goto cl7k; else goto cl7l;
  cl7l:
      call (I64[R1])(R1) returns to cl7k, args: 8, res: 8, upd: 8;
  cl7k:
      Hp = Hp + 64;
      if (Hp > HpLim) goto claH; else goto claG;
  claH:
      HpAlloc = 64;
      R1 = R1;
      call stg_gc_unpt_r1(R1) returns to cl7k, args: 8, res: 8, upd: 8;
  claG:
      _sk6v::I64 = I64[R1 + 7];
      I64[Hp - 56] = sat_sk6X_info;
      P64[Hp - 40] = P64[Sp + 8];
      P64[Hp - 32] = P64[Sp + 16];
      P64[Hp - 24] = P64[Sp + 24];
      P64[Hp - 16] = P64[Sp + 32];
      P64[Hp - 8] = P64[Sp + 40];
      P64[Hp] = P64[Sp + 48];
      I64[Sp + 48] = claz;
      R4 = Hp - 56;
      R3 = _sk6v::I64;
      R2 = 0;
      Sp = Sp + 48;
      call GHC.Show.$wshowSignedInt_info(R4,
                                         R3,
                                         R2) returns to claz, args: 8, res: 8, upd: 8;
  claz:
      Hp = Hp + 24;
      if (Hp > HpLim) goto claK; else goto claJ;
  claK:
      HpAlloc = 24;
      R2 = R2;
      R1 = R1;
      call stg_gc_pp(R2, R1) returns to claz, args: 8, res: 8, upd: 8;
  claJ:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = R1;
      P64[Hp] = R2;
      R1 = Hp - 14;
      Sp = Sp + 8;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:55.536164 UTC

[(cl7k, {sat_sk6X_closure}), (cl7l, {sat_sk6X_closure}),
 (clay, {sat_sk6X_closure}), (claz, {}), (claC, {}),
 (claD, {sat_sk6X_closure}), (claE, {sat_sk6X_closure}),
 (claG, {sat_sk6X_closure}), (claH, {sat_sk6X_closure}), (claJ, {}),
 (claK, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:55.537483 UTC

sat_sk71_entry() //  [R1]
        { info_tbl: [(cl7k,
                      label: block_cl7k_info
                      rep:StackRep [False, False, False, False, False, False]),
                     (clay,
                      label: sat_sk71_info
                      rep:HeapRep 7 ptrs { Thunk }),
                     (claz,
                      label: block_claz_info
                      rep:StackRep [])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      clay:
          _sk71::P64 = R1;
          if ((Sp + -56) < SpLim) goto claC; else goto claD;
      claD:
          if (HpLim == 0) goto claC; else goto claE;
      claC:
          R1 = _sk71::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      claE:
          I64[Sp - 56] = cl7k;
          R1 = P64[_sk71::P64 + 16];
          P64[Sp - 48] = P64[_sk71::P64 + 24];
          P64[Sp - 40] = P64[_sk71::P64 + 32];
          P64[Sp - 32] = P64[_sk71::P64 + 40];
          P64[Sp - 24] = P64[_sk71::P64 + 48];
          P64[Sp - 16] = P64[_sk71::P64 + 56];
          P64[Sp - 8] = P64[_sk71::P64 + 64];
          Sp = Sp - 56;
          if (R1 & 7 != 0) goto cl7k; else goto cl7l;
      cl7l:
          call (I64[R1])(R1) returns to cl7k, args: 8, res: 8, upd: 8;
      cl7k:
          Hp = Hp + 64;
          if (Hp > HpLim) goto claH; else goto claG;
      claH:
          HpAlloc = 64;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to cl7k, args: 8, res: 8, upd: 8;
      claG:
          _sk6v::I64 = I64[R1 + 7];
          I64[Hp - 56] = sat_sk6X_info;
          P64[Hp - 40] = P64[Sp + 8];
          P64[Hp - 32] = P64[Sp + 16];
          P64[Hp - 24] = P64[Sp + 24];
          P64[Hp - 16] = P64[Sp + 32];
          P64[Hp - 8] = P64[Sp + 40];
          P64[Hp] = P64[Sp + 48];
          I64[Sp + 48] = claz;
          R4 = Hp - 56;
          R3 = _sk6v::I64;
          R2 = 0;
          Sp = Sp + 48;
          call GHC.Show.$wshowSignedInt_info(R4,
                                             R3,
                                             R2) returns to claz, args: 8, res: 8, upd: 8;
      claz:
          Hp = Hp + 24;
          if (Hp > HpLim) goto claK; else goto claJ;
      claK:
          HpAlloc = 24;
          R2 = R2;
          R1 = R1;
          call stg_gc_pp(R2, R1) returns to claz, args: 8, res: 8, upd: 8;
      claJ:
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = R1;
          P64[Hp] = R2;
          R1 = Hp - 14;
          Sp = Sp + 8;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:55.541068 UTC

sat_sk71_entry() //  [R1]
        { info_tbl: [(cl7k,
                      label: block_cl7k_info
                      rep:StackRep [False, False, False, False, False, False]),
                     (clay,
                      label: sat_sk71_info
                      rep:HeapRep 7 ptrs { Thunk }),
                     (claz,
                      label: block_claz_info
                      rep:StackRep [])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      clay:
          _sk71::P64 = R1;
          if ((Sp + -56) < SpLim) goto claC; else goto claD;
      claD:
          if (HpLim == 0) goto claC; else goto claE;
      claC:
          R1 = _sk71::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      claE:
          I64[Sp - 56] = cl7k;
          R1 = P64[_sk71::P64 + 16];
          P64[Sp - 48] = P64[_sk71::P64 + 24];
          P64[Sp - 40] = P64[_sk71::P64 + 32];
          P64[Sp - 32] = P64[_sk71::P64 + 40];
          P64[Sp - 24] = P64[_sk71::P64 + 48];
          P64[Sp - 16] = P64[_sk71::P64 + 56];
          P64[Sp - 8] = P64[_sk71::P64 + 64];
          Sp = Sp - 56;
          if (R1 & 7 != 0) goto cl7k; else goto cl7l;
      cl7l:
          call (I64[R1])(R1) returns to cl7k, args: 8, res: 8, upd: 8;
      cl7k:
          Hp = Hp + 64;
          if (Hp > HpLim) goto claH; else goto claG;
      claH:
          HpAlloc = 64;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to cl7k, args: 8, res: 8, upd: 8;
      claG:
          _sk6v::I64 = I64[R1 + 7];
          I64[Hp - 56] = sat_sk6X_info;
          P64[Hp - 40] = P64[Sp + 8];
          P64[Hp - 32] = P64[Sp + 16];
          P64[Hp - 24] = P64[Sp + 24];
          P64[Hp - 16] = P64[Sp + 32];
          P64[Hp - 8] = P64[Sp + 40];
          P64[Hp] = P64[Sp + 48];
          I64[Sp + 48] = claz;
          R4 = Hp - 56;
          R3 = _sk6v::I64;
          R2 = 0;
          Sp = Sp + 48;
          call GHC.Show.$wshowSignedInt_info(R4,
                                             R3,
                                             R2) returns to claz, args: 8, res: 8, upd: 8;
      claz:
          Hp = Hp + 24;
          if (Hp > HpLim) goto claK; else goto claJ;
      claK:
          HpAlloc = 24;
          R2 = R2;
          R1 = R1;
          call stg_gc_pp(R2, R1) returns to claz, args: 8, res: 8, upd: 8;
      claJ:
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = R1;
          P64[Hp] = R2;
          R1 = Hp - 14;
          Sp = Sp + 8;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:55.544561 UTC

{offset
  claL:
      _sk72::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto claM; else goto claN;
  claN:
      Hp = Hp + 72;
      if (Hp > HpLim) goto claP; else goto claO;
  claP:
      HpAlloc = 72;
      goto claM;
  claM:
      R1 = _sk72::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  claO:
      _sk6i::P64 = P64[_sk72::P64 + 16];
      _sk6j::P64 = P64[_sk72::P64 + 24];
      _sk6k::P64 = P64[_sk72::P64 + 32];
      _sk6l::P64 = P64[_sk72::P64 + 40];
      _sk6n::P64 = P64[_sk72::P64 + 48];
      _sk6o::P64 = P64[_sk72::P64 + 56];
      _sk6r::P64 = P64[_sk72::P64 + 64];
      I64[Hp - 64] = sat_sk71_info;
      P64[Hp - 48] = _sk6i::P64;
      P64[Hp - 40] = _sk6j::P64;
      P64[Hp - 32] = _sk6k::P64;
      P64[Hp - 24] = _sk6l::P64;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      _cl7g::P64 = Hp - 64;
      R3 = _cl7g::P64;
      R2 = lvl9_rjV6_closure;
      call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:55.546255 UTC

{offset
  claL:
      _sk72::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto claM; else goto claN;
  claN:
      Hp = Hp + 72;
      if (Hp > HpLim) goto claP; else goto claO;
  claP:
      HpAlloc = 72;
      goto claM;
  claM:
      R1 = _sk72::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  claO:
      _sk6i::P64 = P64[_sk72::P64 + 16];
      _sk6j::P64 = P64[_sk72::P64 + 24];
      _sk6k::P64 = P64[_sk72::P64 + 32];
      _sk6l::P64 = P64[_sk72::P64 + 40];
      _sk6n::P64 = P64[_sk72::P64 + 48];
      _sk6o::P64 = P64[_sk72::P64 + 56];
      _sk6r::P64 = P64[_sk72::P64 + 64];
      I64[Hp - 64] = sat_sk71_info;
      P64[Hp - 48] = _sk6i::P64;
      P64[Hp - 40] = _sk6j::P64;
      P64[Hp - 32] = _sk6k::P64;
      P64[Hp - 24] = _sk6l::P64;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      _cl7g::P64 = Hp - 64;
      R3 = _cl7g::P64;
      R2 = lvl9_rjV6_closure;
      call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:55.547994 UTC

{offset
  claL:
      _sk72::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto claM; else goto claN;
  claN:
      Hp = Hp + 72;
      if (Hp > HpLim) goto claP; else goto claO;
  claP:
      HpAlloc = 72;
      goto claM;
  claM:
      R1 = _sk72::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  claO:
      _sk6i::P64 = P64[_sk72::P64 + 16];
      _sk6j::P64 = P64[_sk72::P64 + 24];
      _sk6k::P64 = P64[_sk72::P64 + 32];
      _sk6l::P64 = P64[_sk72::P64 + 40];
      _sk6n::P64 = P64[_sk72::P64 + 48];
      _sk6o::P64 = P64[_sk72::P64 + 56];
      _sk6r::P64 = P64[_sk72::P64 + 64];
      I64[Hp - 64] = sat_sk71_info;
      P64[Hp - 48] = _sk6i::P64;
      P64[Hp - 40] = _sk6j::P64;
      P64[Hp - 32] = _sk6k::P64;
      P64[Hp - 24] = _sk6l::P64;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      _cl7g::P64 = Hp - 64;
      R3 = _cl7g::P64;
      R2 = lvl9_rjV6_closure;
      call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:55.549794 UTC

{offset
  claL:
      _sk72::P64 = R1;
      goto claN;
  claN:
      Hp = Hp + 72;
      if (Hp > HpLim) goto claP; else goto claO;
  claP:
      HpAlloc = 72;
      goto claM;
  claM:
      R1 = _sk72::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  claO:
      _sk6i::P64 = P64[_sk72::P64 + 16];
      _sk6j::P64 = P64[_sk72::P64 + 24];
      _sk6k::P64 = P64[_sk72::P64 + 32];
      _sk6l::P64 = P64[_sk72::P64 + 40];
      _sk6n::P64 = P64[_sk72::P64 + 48];
      _sk6o::P64 = P64[_sk72::P64 + 56];
      _sk6r::P64 = P64[_sk72::P64 + 64];
      I64[Hp - 64] = sat_sk71_info;
      P64[Hp - 48] = _sk6i::P64;
      P64[Hp - 40] = _sk6j::P64;
      P64[Hp - 32] = _sk6k::P64;
      P64[Hp - 24] = _sk6l::P64;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      _cl7g::P64 = Hp - 64;
      R3 = _cl7g::P64;
      R2 = lvl9_rjV6_closure;
      call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:55.551412 UTC

{offset
  claL:
      goto claN;
  claN:
      Hp = Hp + 72;
      if (Hp > HpLim) goto claP; else goto claO;
  claP:
      HpAlloc = 72;
      goto claM;
  claM:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  claO:
      _sk6i::P64 = P64[R1 + 16];
      _sk6j::P64 = P64[R1 + 24];
      _sk6k::P64 = P64[R1 + 32];
      _sk6l::P64 = P64[R1 + 40];
      _sk6n::P64 = P64[R1 + 48];
      _sk6o::P64 = P64[R1 + 56];
      _sk6r::P64 = P64[R1 + 64];
      I64[Hp - 64] = sat_sk71_info;
      P64[Hp - 48] = _sk6i::P64;
      P64[Hp - 40] = _sk6j::P64;
      P64[Hp - 32] = _sk6k::P64;
      P64[Hp - 24] = _sk6l::P64;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      R3 = Hp - 64;
      R2 = lvl9_rjV6_closure;
      call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:55.553186 UTC

[(claL, {lvl9_rjV6_closure, sat_sk71_closure}), (claM, {}),
 (claN, {lvl9_rjV6_closure, sat_sk71_closure}),
 (claO, {lvl9_rjV6_closure, sat_sk71_closure}), (claP, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:55.553716 UTC

sat_sk72_entry() //  [R1]
        { info_tbl: [(claL,
                      label: sat_sk72_info
                      rep:HeapRep 7 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      claL:
          goto claN;
      claN:
          Hp = Hp + 72;
          if (Hp > HpLim) goto claP; else goto claO;
      claP:
          HpAlloc = 72;
          goto claM;
      claM:
          R1 = R1;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      claO:
          _sk6i::P64 = P64[R1 + 16];
          _sk6j::P64 = P64[R1 + 24];
          _sk6k::P64 = P64[R1 + 32];
          _sk6l::P64 = P64[R1 + 40];
          _sk6n::P64 = P64[R1 + 48];
          _sk6o::P64 = P64[R1 + 56];
          _sk6r::P64 = P64[R1 + 64];
          I64[Hp - 64] = sat_sk71_info;
          P64[Hp - 48] = _sk6i::P64;
          P64[Hp - 40] = _sk6j::P64;
          P64[Hp - 32] = _sk6k::P64;
          P64[Hp - 24] = _sk6l::P64;
          P64[Hp - 16] = _sk6n::P64;
          P64[Hp - 8] = _sk6o::P64;
          P64[Hp] = _sk6r::P64;
          R3 = Hp - 64;
          R2 = lvl9_rjV6_closure;
          call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:55.555489 UTC

sat_sk72_entry() //  [R1]
        { info_tbl: [(claL,
                      label: sat_sk72_info
                      rep:HeapRep 7 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      claL:
          Hp = Hp + 72;
          if (Hp > HpLim) goto claP; else goto claO;
      claP:
          HpAlloc = 72;
          R1 = R1;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      claO:
          _sk6i::P64 = P64[R1 + 16];
          _sk6j::P64 = P64[R1 + 24];
          _sk6k::P64 = P64[R1 + 32];
          _sk6l::P64 = P64[R1 + 40];
          _sk6n::P64 = P64[R1 + 48];
          _sk6o::P64 = P64[R1 + 56];
          _sk6r::P64 = P64[R1 + 64];
          I64[Hp - 64] = sat_sk71_info;
          P64[Hp - 48] = _sk6i::P64;
          P64[Hp - 40] = _sk6j::P64;
          P64[Hp - 32] = _sk6k::P64;
          P64[Hp - 24] = _sk6l::P64;
          P64[Hp - 16] = _sk6n::P64;
          P64[Hp - 8] = _sk6o::P64;
          P64[Hp] = _sk6r::P64;
          R3 = Hp - 64;
          R2 = lvl9_rjV6_closure;
          call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:55.557241 UTC

{offset
  claQ:
      _sk73::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto claR; else goto claS;
  claS:
      Hp = Hp + 72;
      if (Hp > HpLim) goto claU; else goto claT;
  claU:
      HpAlloc = 72;
      goto claR;
  claR:
      R1 = _sk73::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  claT:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sk73::P64;
      _sk6i::P64 = P64[_sk73::P64 + 16];
      _sk6j::P64 = P64[_sk73::P64 + 24];
      _sk6k::P64 = P64[_sk73::P64 + 32];
      _sk6l::P64 = P64[_sk73::P64 + 40];
      _sk6n::P64 = P64[_sk73::P64 + 48];
      _sk6o::P64 = P64[_sk73::P64 + 56];
      _sk6r::P64 = P64[_sk73::P64 + 64];
      I64[Hp - 64] = sat_sk72_info;
      P64[Hp - 48] = _sk6i::P64;
      P64[Hp - 40] = _sk6j::P64;
      P64[Hp - 32] = _sk6k::P64;
      P64[Hp - 24] = _sk6l::P64;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      _cl7c::P64 = Hp - 64;
      R3 = _cl7c::P64;
      R2 = lvl3_rjV0_closure;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Post common block elimination ====================
2015-11-09 18:21:55.559005 UTC

{offset
  claQ:
      _sk73::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto claR; else goto claS;
  claS:
      Hp = Hp + 72;
      if (Hp > HpLim) goto claU; else goto claT;
  claU:
      HpAlloc = 72;
      goto claR;
  claR:
      R1 = _sk73::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  claT:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sk73::P64;
      _sk6i::P64 = P64[_sk73::P64 + 16];
      _sk6j::P64 = P64[_sk73::P64 + 24];
      _sk6k::P64 = P64[_sk73::P64 + 32];
      _sk6l::P64 = P64[_sk73::P64 + 40];
      _sk6n::P64 = P64[_sk73::P64 + 48];
      _sk6o::P64 = P64[_sk73::P64 + 56];
      _sk6r::P64 = P64[_sk73::P64 + 64];
      I64[Hp - 64] = sat_sk72_info;
      P64[Hp - 48] = _sk6i::P64;
      P64[Hp - 40] = _sk6j::P64;
      P64[Hp - 32] = _sk6k::P64;
      P64[Hp - 24] = _sk6l::P64;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      _cl7c::P64 = Hp - 64;
      R3 = _cl7c::P64;
      R2 = lvl3_rjV0_closure;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Post switch plan ====================
2015-11-09 18:21:55.560818 UTC

{offset
  claQ:
      _sk73::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto claR; else goto claS;
  claS:
      Hp = Hp + 72;
      if (Hp > HpLim) goto claU; else goto claT;
  claU:
      HpAlloc = 72;
      goto claR;
  claR:
      R1 = _sk73::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  claT:
      I64[(old + 24)] = stg_upd_frame_info;
      P64[(old + 16)] = _sk73::P64;
      _sk6i::P64 = P64[_sk73::P64 + 16];
      _sk6j::P64 = P64[_sk73::P64 + 24];
      _sk6k::P64 = P64[_sk73::P64 + 32];
      _sk6l::P64 = P64[_sk73::P64 + 40];
      _sk6n::P64 = P64[_sk73::P64 + 48];
      _sk6o::P64 = P64[_sk73::P64 + 56];
      _sk6r::P64 = P64[_sk73::P64 + 64];
      I64[Hp - 64] = sat_sk72_info;
      P64[Hp - 48] = _sk6i::P64;
      P64[Hp - 40] = _sk6j::P64;
      P64[Hp - 32] = _sk6k::P64;
      P64[Hp - 24] = _sk6l::P64;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      _cl7c::P64 = Hp - 64;
      R3 = _cl7c::P64;
      R2 = lvl3_rjV0_closure;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Layout Stack ====================
2015-11-09 18:21:55.562655 UTC

{offset
  claQ:
      _sk73::P64 = R1;
      if ((Sp + 8) - 24 < SpLim) goto claR; else goto claS;
  claS:
      Hp = Hp + 72;
      if (Hp > HpLim) goto claU; else goto claT;
  claU:
      HpAlloc = 72;
      goto claR;
  claR:
      R1 = _sk73::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  claT:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _sk73::P64;
      _sk6i::P64 = P64[_sk73::P64 + 16];
      _sk6j::P64 = P64[_sk73::P64 + 24];
      _sk6k::P64 = P64[_sk73::P64 + 32];
      _sk6l::P64 = P64[_sk73::P64 + 40];
      _sk6n::P64 = P64[_sk73::P64 + 48];
      _sk6o::P64 = P64[_sk73::P64 + 56];
      _sk6r::P64 = P64[_sk73::P64 + 64];
      I64[Hp - 64] = sat_sk72_info;
      P64[Hp - 48] = _sk6i::P64;
      P64[Hp - 40] = _sk6j::P64;
      P64[Hp - 32] = _sk6k::P64;
      P64[Hp - 24] = _sk6l::P64;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      _cl7c::P64 = Hp - 64;
      R3 = _cl7c::P64;
      R2 = lvl3_rjV0_closure;
      Sp = Sp - 16;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== Sink assignments ====================
2015-11-09 18:21:55.564475 UTC

{offset
  claQ:
      _sk73::P64 = R1;
      if ((Sp + -16) < SpLim) goto claR; else goto claS;
  claS:
      Hp = Hp + 72;
      if (Hp > HpLim) goto claU; else goto claT;
  claU:
      HpAlloc = 72;
      goto claR;
  claR:
      R1 = _sk73::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  claT:
      I64[Sp - 16] = stg_upd_frame_info;
      P64[Sp - 8] = _sk73::P64;
      _sk6i::P64 = P64[_sk73::P64 + 16];
      _sk6j::P64 = P64[_sk73::P64 + 24];
      _sk6k::P64 = P64[_sk73::P64 + 32];
      _sk6l::P64 = P64[_sk73::P64 + 40];
      _sk6n::P64 = P64[_sk73::P64 + 48];
      _sk6o::P64 = P64[_sk73::P64 + 56];
      _sk6r::P64 = P64[_sk73::P64 + 64];
      I64[Hp - 64] = sat_sk72_info;
      P64[Hp - 48] = _sk6i::P64;
      P64[Hp - 40] = _sk6j::P64;
      P64[Hp - 32] = _sk6k::P64;
      P64[Hp - 24] = _sk6l::P64;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      R3 = Hp - 64;
      R2 = lvl3_rjV0_closure;
      Sp = Sp - 16;
      call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
}


==================== CAFEnv ====================
2015-11-09 18:21:55.566483 UTC

[(claQ, {lvl3_rjV0_closure, sat_sk72_closure}), (claR, {}),
 (claS, {lvl3_rjV0_closure, sat_sk72_closure}),
 (claT, {lvl3_rjV0_closure, sat_sk72_closure}), (claU, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:55.567055 UTC

sat_sk73_entry() //  [R1]
        { info_tbl: [(claQ,
                      label: sat_sk73_info
                      rep:HeapRep 7 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      claQ:
          _sk73::P64 = R1;
          if ((Sp + -16) < SpLim) goto claR; else goto claS;
      claS:
          Hp = Hp + 72;
          if (Hp > HpLim) goto claU; else goto claT;
      claU:
          HpAlloc = 72;
          goto claR;
      claR:
          R1 = _sk73::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      claT:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _sk73::P64;
          _sk6i::P64 = P64[_sk73::P64 + 16];
          _sk6j::P64 = P64[_sk73::P64 + 24];
          _sk6k::P64 = P64[_sk73::P64 + 32];
          _sk6l::P64 = P64[_sk73::P64 + 40];
          _sk6n::P64 = P64[_sk73::P64 + 48];
          _sk6o::P64 = P64[_sk73::P64 + 56];
          _sk6r::P64 = P64[_sk73::P64 + 64];
          I64[Hp - 64] = sat_sk72_info;
          P64[Hp - 48] = _sk6i::P64;
          P64[Hp - 40] = _sk6j::P64;
          P64[Hp - 32] = _sk6k::P64;
          P64[Hp - 24] = _sk6l::P64;
          P64[Hp - 16] = _sk6n::P64;
          P64[Hp - 8] = _sk6o::P64;
          P64[Hp] = _sk6r::P64;
          R3 = Hp - 64;
          R2 = lvl3_rjV0_closure;
          Sp = Sp - 16;
          call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:55.569142 UTC

sat_sk73_entry() //  [R1]
        { info_tbl: [(claQ,
                      label: sat_sk73_info
                      rep:HeapRep 7 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      claQ:
          _sk73::P64 = R1;
          if ((Sp + -16) < SpLim) goto claR; else goto claS;
      claS:
          Hp = Hp + 72;
          if (Hp > HpLim) goto claU; else goto claT;
      claU:
          HpAlloc = 72;
          goto claR;
      claR:
          R1 = _sk73::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      claT:
          I64[Sp - 16] = stg_upd_frame_info;
          P64[Sp - 8] = _sk73::P64;
          _sk6i::P64 = P64[_sk73::P64 + 16];
          _sk6j::P64 = P64[_sk73::P64 + 24];
          _sk6k::P64 = P64[_sk73::P64 + 32];
          _sk6l::P64 = P64[_sk73::P64 + 40];
          _sk6n::P64 = P64[_sk73::P64 + 48];
          _sk6o::P64 = P64[_sk73::P64 + 56];
          _sk6r::P64 = P64[_sk73::P64 + 64];
          I64[Hp - 64] = sat_sk72_info;
          P64[Hp - 48] = _sk6i::P64;
          P64[Hp - 40] = _sk6j::P64;
          P64[Hp - 32] = _sk6k::P64;
          P64[Hp - 24] = _sk6l::P64;
          P64[Hp - 16] = _sk6n::P64;
          P64[Hp - 8] = _sk6o::P64;
          P64[Hp] = _sk6r::P64;
          R3 = Hp - 64;
          R2 = lvl3_rjV0_closure;
          Sp = Sp - 16;
          call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:55.571182 UTC

{offset
  claV:
      _sk77::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto claZ; else goto clb0;
  clb0:
      if (HpLim == 0) goto claZ; else goto clb1;
  claZ:
      R1 = _sk77::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  clb1:
      _sk6h::P64 = P64[_sk77::P64 + 16];
      _sk6i::P64 = P64[_sk77::P64 + 24];
      _sk6j::P64 = P64[_sk77::P64 + 32];
      _sk6k::P64 = P64[_sk77::P64 + 40];
      _sk6l::P64 = P64[_sk77::P64 + 48];
      _sk6n::P64 = P64[_sk77::P64 + 56];
      _sk6o::P64 = P64[_sk77::P64 + 64];
      _sk6r::P64 = P64[_sk77::P64 + 72];
      I64[(young<cl73> + 8)] = cl73;
      R1 = _sk6h::P64;
      if (R1 & 7 != 0) goto cl73; else goto cl74;
  cl74:
      call (I64[R1])(R1) returns to cl73, args: 8, res: 8, upd: 8;
  cl73:
      _sk6s::P64 = R1;
      Hp = Hp + 72;
      if (Hp > HpLim) goto clb4; else goto clb3;
  clb4:
      HpAlloc = 72;
      R1 = _sk6s::P64;
      call stg_gc_unpt_r1(R1) returns to cl73, args: 8, res: 8, upd: 8;
  clb3:
      _sk6t::I64 = I64[_sk6s::P64 + 7];
      I64[Hp - 64] = sat_sk73_info;
      P64[Hp - 48] = _sk6i::P64;
      P64[Hp - 40] = _sk6j::P64;
      P64[Hp - 32] = _sk6k::P64;
      P64[Hp - 24] = _sk6l::P64;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      _cl78::P64 = Hp - 64;
      I64[(young<claW> + 8)] = claW;
      R3 = _cl78::P64;
      R2 = _sk6t::I64;
      call GHC.Show.$wshowWord_info(R3,
                                    R2) returns to claW, args: 8, res: 8, upd: 8;
  claW:
      _sk76::P64 = R2;
      _sk75::P64 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto clb7; else goto clb6;
  clb7:
      HpAlloc = 24;
      R2 = _sk76::P64;
      R1 = _sk75::P64;
      call stg_gc_pp(R2, R1) returns to claW, args: 8, res: 8, upd: 8;
  clb6:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _sk75::P64;
      P64[Hp] = _sk76::P64;
      _claY::P64 = Hp - 14;
      R1 = _claY::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:55.574223 UTC

{offset
  claV:
      _sk77::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto claZ; else goto clb0;
  clb0:
      if (HpLim == 0) goto claZ; else goto clb1;
  claZ:
      R1 = _sk77::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  clb1:
      _sk6h::P64 = P64[_sk77::P64 + 16];
      _sk6i::P64 = P64[_sk77::P64 + 24];
      _sk6j::P64 = P64[_sk77::P64 + 32];
      _sk6k::P64 = P64[_sk77::P64 + 40];
      _sk6l::P64 = P64[_sk77::P64 + 48];
      _sk6n::P64 = P64[_sk77::P64 + 56];
      _sk6o::P64 = P64[_sk77::P64 + 64];
      _sk6r::P64 = P64[_sk77::P64 + 72];
      I64[(young<cl73> + 8)] = cl73;
      R1 = _sk6h::P64;
      if (R1 & 7 != 0) goto cl73; else goto cl74;
  cl74:
      call (I64[R1])(R1) returns to cl73, args: 8, res: 8, upd: 8;
  cl73:
      _sk6s::P64 = R1;
      Hp = Hp + 72;
      if (Hp > HpLim) goto clb4; else goto clb3;
  clb4:
      HpAlloc = 72;
      R1 = _sk6s::P64;
      call stg_gc_unpt_r1(R1) returns to cl73, args: 8, res: 8, upd: 8;
  clb3:
      _sk6t::I64 = I64[_sk6s::P64 + 7];
      I64[Hp - 64] = sat_sk73_info;
      P64[Hp - 48] = _sk6i::P64;
      P64[Hp - 40] = _sk6j::P64;
      P64[Hp - 32] = _sk6k::P64;
      P64[Hp - 24] = _sk6l::P64;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      _cl78::P64 = Hp - 64;
      I64[(young<claW> + 8)] = claW;
      R3 = _cl78::P64;
      R2 = _sk6t::I64;
      call GHC.Show.$wshowWord_info(R3,
                                    R2) returns to claW, args: 8, res: 8, upd: 8;
  claW:
      _sk76::P64 = R2;
      _sk75::P64 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto clb7; else goto clb6;
  clb7:
      HpAlloc = 24;
      R2 = _sk76::P64;
      R1 = _sk75::P64;
      call stg_gc_pp(R2, R1) returns to claW, args: 8, res: 8, upd: 8;
  clb6:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _sk75::P64;
      P64[Hp] = _sk76::P64;
      _claY::P64 = Hp - 14;
      R1 = _claY::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:55.577345 UTC

{offset
  claV:
      _sk77::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto claZ; else goto clb0;
  clb0:
      if (HpLim == 0) goto claZ; else goto clb1;
  claZ:
      R1 = _sk77::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  clb1:
      _sk6h::P64 = P64[_sk77::P64 + 16];
      _sk6i::P64 = P64[_sk77::P64 + 24];
      _sk6j::P64 = P64[_sk77::P64 + 32];
      _sk6k::P64 = P64[_sk77::P64 + 40];
      _sk6l::P64 = P64[_sk77::P64 + 48];
      _sk6n::P64 = P64[_sk77::P64 + 56];
      _sk6o::P64 = P64[_sk77::P64 + 64];
      _sk6r::P64 = P64[_sk77::P64 + 72];
      I64[(young<cl73> + 8)] = cl73;
      R1 = _sk6h::P64;
      if (R1 & 7 != 0) goto cl73; else goto cl74;
  cl74:
      call (I64[R1])(R1) returns to cl73, args: 8, res: 8, upd: 8;
  cl73:
      _sk6s::P64 = R1;
      Hp = Hp + 72;
      if (Hp > HpLim) goto clb4; else goto clb3;
  clb4:
      HpAlloc = 72;
      R1 = _sk6s::P64;
      call stg_gc_unpt_r1(R1) returns to cl73, args: 8, res: 8, upd: 8;
  clb3:
      _sk6t::I64 = I64[_sk6s::P64 + 7];
      I64[Hp - 64] = sat_sk73_info;
      P64[Hp - 48] = _sk6i::P64;
      P64[Hp - 40] = _sk6j::P64;
      P64[Hp - 32] = _sk6k::P64;
      P64[Hp - 24] = _sk6l::P64;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      _cl78::P64 = Hp - 64;
      I64[(young<claW> + 8)] = claW;
      R3 = _cl78::P64;
      R2 = _sk6t::I64;
      call GHC.Show.$wshowWord_info(R3,
                                    R2) returns to claW, args: 8, res: 8, upd: 8;
  claW:
      _sk76::P64 = R2;
      _sk75::P64 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto clb7; else goto clb6;
  clb7:
      HpAlloc = 24;
      R2 = _sk76::P64;
      R1 = _sk75::P64;
      call stg_gc_pp(R2, R1) returns to claW, args: 8, res: 8, upd: 8;
  clb6:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _sk75::P64;
      P64[Hp] = _sk76::P64;
      _claY::P64 = Hp - 14;
      R1 = _claY::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:55.580772 UTC

{offset
  claV:
      _sk77::P64 = R1;
      if ((Sp + 8) - 72 < SpLim) goto claZ; else goto clb0;
  clb0:
      if (HpLim == 0) goto claZ; else goto clb1;
  claZ:
      R1 = _sk77::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  clb1:
      _sk6h::P64 = P64[_sk77::P64 + 16];
      _sk6i::P64 = P64[_sk77::P64 + 24];
      _sk6j::P64 = P64[_sk77::P64 + 32];
      _sk6k::P64 = P64[_sk77::P64 + 40];
      _sk6l::P64 = P64[_sk77::P64 + 48];
      _sk6n::P64 = P64[_sk77::P64 + 56];
      _sk6o::P64 = P64[_sk77::P64 + 64];
      _sk6r::P64 = P64[_sk77::P64 + 72];
      I64[Sp - 64] = cl73;
      R1 = _sk6h::P64;
      P64[Sp - 56] = _sk6i::P64;
      P64[Sp - 48] = _sk6j::P64;
      P64[Sp - 40] = _sk6k::P64;
      P64[Sp - 32] = _sk6l::P64;
      P64[Sp - 24] = _sk6n::P64;
      P64[Sp - 16] = _sk6o::P64;
      P64[Sp - 8] = _sk6r::P64;
      Sp = Sp - 64;
      if (R1 & 7 != 0) goto cl73; else goto cl74;
  cl74:
      call (I64[R1])(R1) returns to cl73, args: 8, res: 8, upd: 8;
  cl73:
      _sk6i::P64 = P64[Sp + 8];
      _sk6j::P64 = P64[Sp + 16];
      _sk6k::P64 = P64[Sp + 24];
      _sk6l::P64 = P64[Sp + 32];
      _sk6n::P64 = P64[Sp + 40];
      _sk6o::P64 = P64[Sp + 48];
      _sk6r::P64 = P64[Sp + 56];
      _sk6s::P64 = R1;
      Hp = Hp + 72;
      if (Hp > HpLim) goto clb4; else goto clb3;
  clb4:
      HpAlloc = 72;
      R1 = _sk6s::P64;
      call stg_gc_unpt_r1(R1) returns to cl73, args: 8, res: 8, upd: 8;
  clb3:
      _sk6t::I64 = I64[_sk6s::P64 + 7];
      I64[Hp - 64] = sat_sk73_info;
      P64[Hp - 48] = _sk6i::P64;
      P64[Hp - 40] = _sk6j::P64;
      P64[Hp - 32] = _sk6k::P64;
      P64[Hp - 24] = _sk6l::P64;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      _cl78::P64 = Hp - 64;
      I64[Sp + 56] = claW;
      R3 = _cl78::P64;
      R2 = _sk6t::I64;
      Sp = Sp + 56;
      call GHC.Show.$wshowWord_info(R3,
                                    R2) returns to claW, args: 8, res: 8, upd: 8;
  claW:
      _sk76::P64 = R2;
      _sk75::P64 = R1;
      Hp = Hp + 24;
      if (Hp > HpLim) goto clb7; else goto clb6;
  clb7:
      HpAlloc = 24;
      R2 = _sk76::P64;
      R1 = _sk75::P64;
      call stg_gc_pp(R2, R1) returns to claW, args: 8, res: 8, upd: 8;
  clb6:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = _sk75::P64;
      P64[Hp] = _sk76::P64;
      _claY::P64 = Hp - 14;
      R1 = _claY::P64;
      Sp = Sp + 8;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:55.58527 UTC

{offset
  claV:
      _sk77::P64 = R1;
      if ((Sp + -64) < SpLim) goto claZ; else goto clb0;
  clb0:
      if (HpLim == 0) goto claZ; else goto clb1;
  claZ:
      R1 = _sk77::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  clb1:
      I64[Sp - 64] = cl73;
      R1 = P64[_sk77::P64 + 16];
      P64[Sp - 56] = P64[_sk77::P64 + 24];
      P64[Sp - 48] = P64[_sk77::P64 + 32];
      P64[Sp - 40] = P64[_sk77::P64 + 40];
      P64[Sp - 32] = P64[_sk77::P64 + 48];
      P64[Sp - 24] = P64[_sk77::P64 + 56];
      P64[Sp - 16] = P64[_sk77::P64 + 64];
      P64[Sp - 8] = P64[_sk77::P64 + 72];
      Sp = Sp - 64;
      if (R1 & 7 != 0) goto cl73; else goto cl74;
  cl74:
      call (I64[R1])(R1) returns to cl73, args: 8, res: 8, upd: 8;
  cl73:
      Hp = Hp + 72;
      if (Hp > HpLim) goto clb4; else goto clb3;
  clb4:
      HpAlloc = 72;
      R1 = R1;
      call stg_gc_unpt_r1(R1) returns to cl73, args: 8, res: 8, upd: 8;
  clb3:
      _sk6t::I64 = I64[R1 + 7];
      I64[Hp - 64] = sat_sk73_info;
      P64[Hp - 48] = P64[Sp + 8];
      P64[Hp - 40] = P64[Sp + 16];
      P64[Hp - 32] = P64[Sp + 24];
      P64[Hp - 24] = P64[Sp + 32];
      P64[Hp - 16] = P64[Sp + 40];
      P64[Hp - 8] = P64[Sp + 48];
      P64[Hp] = P64[Sp + 56];
      I64[Sp + 56] = claW;
      R3 = Hp - 64;
      R2 = _sk6t::I64;
      Sp = Sp + 56;
      call GHC.Show.$wshowWord_info(R3,
                                    R2) returns to claW, args: 8, res: 8, upd: 8;
  claW:
      Hp = Hp + 24;
      if (Hp > HpLim) goto clb7; else goto clb6;
  clb7:
      HpAlloc = 24;
      R2 = R2;
      R1 = R1;
      call stg_gc_pp(R2, R1) returns to claW, args: 8, res: 8, upd: 8;
  clb6:
      I64[Hp - 16] = :_con_info;
      P64[Hp - 8] = R1;
      P64[Hp] = R2;
      R1 = Hp - 14;
      Sp = Sp + 8;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:55.589234 UTC

[(cl73, {sat_sk73_closure}), (cl74, {sat_sk73_closure}),
 (claV, {sat_sk73_closure}), (claW, {}), (claZ, {}),
 (clb0, {sat_sk73_closure}), (clb1, {sat_sk73_closure}),
 (clb3, {sat_sk73_closure}), (clb4, {sat_sk73_closure}), (clb6, {}),
 (clb7, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:55.589978 UTC

sat_sk77_entry() //  [R1]
        { info_tbl: [(cl73,
                      label: block_cl73_info
                      rep:StackRep [False, False, False, False, False, False, False]),
                     (claV,
                      label: sat_sk77_info
                      rep:HeapRep 8 ptrs { Thunk }),
                     (claW,
                      label: block_claW_info
                      rep:StackRep [])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      claV:
          _sk77::P64 = R1;
          if ((Sp + -64) < SpLim) goto claZ; else goto clb0;
      clb0:
          if (HpLim == 0) goto claZ; else goto clb1;
      claZ:
          R1 = _sk77::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      clb1:
          I64[Sp - 64] = cl73;
          R1 = P64[_sk77::P64 + 16];
          P64[Sp - 56] = P64[_sk77::P64 + 24];
          P64[Sp - 48] = P64[_sk77::P64 + 32];
          P64[Sp - 40] = P64[_sk77::P64 + 40];
          P64[Sp - 32] = P64[_sk77::P64 + 48];
          P64[Sp - 24] = P64[_sk77::P64 + 56];
          P64[Sp - 16] = P64[_sk77::P64 + 64];
          P64[Sp - 8] = P64[_sk77::P64 + 72];
          Sp = Sp - 64;
          if (R1 & 7 != 0) goto cl73; else goto cl74;
      cl74:
          call (I64[R1])(R1) returns to cl73, args: 8, res: 8, upd: 8;
      cl73:
          Hp = Hp + 72;
          if (Hp > HpLim) goto clb4; else goto clb3;
      clb4:
          HpAlloc = 72;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to cl73, args: 8, res: 8, upd: 8;
      clb3:
          _sk6t::I64 = I64[R1 + 7];
          I64[Hp - 64] = sat_sk73_info;
          P64[Hp - 48] = P64[Sp + 8];
          P64[Hp - 40] = P64[Sp + 16];
          P64[Hp - 32] = P64[Sp + 24];
          P64[Hp - 24] = P64[Sp + 32];
          P64[Hp - 16] = P64[Sp + 40];
          P64[Hp - 8] = P64[Sp + 48];
          P64[Hp] = P64[Sp + 56];
          I64[Sp + 56] = claW;
          R3 = Hp - 64;
          R2 = _sk6t::I64;
          Sp = Sp + 56;
          call GHC.Show.$wshowWord_info(R3,
                                        R2) returns to claW, args: 8, res: 8, upd: 8;
      claW:
          Hp = Hp + 24;
          if (Hp > HpLim) goto clb7; else goto clb6;
      clb7:
          HpAlloc = 24;
          R2 = R2;
          R1 = R1;
          call stg_gc_pp(R2, R1) returns to claW, args: 8, res: 8, upd: 8;
      clb6:
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = R1;
          P64[Hp] = R2;
          R1 = Hp - 14;
          Sp = Sp + 8;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:55.593651 UTC

sat_sk77_entry() //  [R1]
        { info_tbl: [(cl73,
                      label: block_cl73_info
                      rep:StackRep [False, False, False, False, False, False, False]),
                     (claV,
                      label: sat_sk77_info
                      rep:HeapRep 8 ptrs { Thunk }),
                     (claW,
                      label: block_claW_info
                      rep:StackRep [])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      claV:
          _sk77::P64 = R1;
          if ((Sp + -64) < SpLim) goto claZ; else goto clb0;
      clb0:
          if (HpLim == 0) goto claZ; else goto clb1;
      claZ:
          R1 = _sk77::P64;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      clb1:
          I64[Sp - 64] = cl73;
          R1 = P64[_sk77::P64 + 16];
          P64[Sp - 56] = P64[_sk77::P64 + 24];
          P64[Sp - 48] = P64[_sk77::P64 + 32];
          P64[Sp - 40] = P64[_sk77::P64 + 40];
          P64[Sp - 32] = P64[_sk77::P64 + 48];
          P64[Sp - 24] = P64[_sk77::P64 + 56];
          P64[Sp - 16] = P64[_sk77::P64 + 64];
          P64[Sp - 8] = P64[_sk77::P64 + 72];
          Sp = Sp - 64;
          if (R1 & 7 != 0) goto cl73; else goto cl74;
      cl74:
          call (I64[R1])(R1) returns to cl73, args: 8, res: 8, upd: 8;
      cl73:
          Hp = Hp + 72;
          if (Hp > HpLim) goto clb4; else goto clb3;
      clb4:
          HpAlloc = 72;
          R1 = R1;
          call stg_gc_unpt_r1(R1) returns to cl73, args: 8, res: 8, upd: 8;
      clb3:
          _sk6t::I64 = I64[R1 + 7];
          I64[Hp - 64] = sat_sk73_info;
          P64[Hp - 48] = P64[Sp + 8];
          P64[Hp - 40] = P64[Sp + 16];
          P64[Hp - 32] = P64[Sp + 24];
          P64[Hp - 24] = P64[Sp + 32];
          P64[Hp - 16] = P64[Sp + 40];
          P64[Hp - 8] = P64[Sp + 48];
          P64[Hp] = P64[Sp + 56];
          I64[Sp + 56] = claW;
          R3 = Hp - 64;
          R2 = _sk6t::I64;
          Sp = Sp + 56;
          call GHC.Show.$wshowWord_info(R3,
                                        R2) returns to claW, args: 8, res: 8, upd: 8;
      claW:
          Hp = Hp + 24;
          if (Hp > HpLim) goto clb7; else goto clb6;
      clb7:
          HpAlloc = 24;
          R2 = R2;
          R1 = R1;
          call stg_gc_pp(R2, R1) returns to claW, args: 8, res: 8, upd: 8;
      clb6:
          I64[Hp - 16] = :_con_info;
          P64[Hp - 8] = R1;
          P64[Hp] = R2;
          R1 = Hp - 14;
          Sp = Sp + 8;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:55.597379 UTC

{offset
  clb8:
      _sk78::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto clb9; else goto clba;
  clba:
      Hp = Hp + 80;
      if (Hp > HpLim) goto clbc; else goto clbb;
  clbc:
      HpAlloc = 80;
      goto clb9;
  clb9:
      R1 = _sk78::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  clbb:
      _sk6h::P64 = P64[_sk78::P64 + 16];
      _sk6i::P64 = P64[_sk78::P64 + 24];
      _sk6j::P64 = P64[_sk78::P64 + 32];
      _sk6k::P64 = P64[_sk78::P64 + 40];
      _sk6l::P64 = P64[_sk78::P64 + 48];
      _sk6n::P64 = P64[_sk78::P64 + 56];
      _sk6o::P64 = P64[_sk78::P64 + 64];
      _sk6r::P64 = P64[_sk78::P64 + 72];
      I64[Hp - 72] = sat_sk77_info;
      P64[Hp - 56] = _sk6h::P64;
      P64[Hp - 48] = _sk6i::P64;
      P64[Hp - 40] = _sk6j::P64;
      P64[Hp - 32] = _sk6k::P64;
      P64[Hp - 24] = _sk6l::P64;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      _cl6Z::P64 = Hp - 72;
      R3 = _cl6Z::P64;
      R2 = lvl10_rjV7_closure;
      call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:55.599296 UTC

{offset
  clb8:
      _sk78::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto clb9; else goto clba;
  clba:
      Hp = Hp + 80;
      if (Hp > HpLim) goto clbc; else goto clbb;
  clbc:
      HpAlloc = 80;
      goto clb9;
  clb9:
      R1 = _sk78::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  clbb:
      _sk6h::P64 = P64[_sk78::P64 + 16];
      _sk6i::P64 = P64[_sk78::P64 + 24];
      _sk6j::P64 = P64[_sk78::P64 + 32];
      _sk6k::P64 = P64[_sk78::P64 + 40];
      _sk6l::P64 = P64[_sk78::P64 + 48];
      _sk6n::P64 = P64[_sk78::P64 + 56];
      _sk6o::P64 = P64[_sk78::P64 + 64];
      _sk6r::P64 = P64[_sk78::P64 + 72];
      I64[Hp - 72] = sat_sk77_info;
      P64[Hp - 56] = _sk6h::P64;
      P64[Hp - 48] = _sk6i::P64;
      P64[Hp - 40] = _sk6j::P64;
      P64[Hp - 32] = _sk6k::P64;
      P64[Hp - 24] = _sk6l::P64;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      _cl6Z::P64 = Hp - 72;
      R3 = _cl6Z::P64;
      R2 = lvl10_rjV7_closure;
      call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:55.601123 UTC

{offset
  clb8:
      _sk78::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto clb9; else goto clba;
  clba:
      Hp = Hp + 80;
      if (Hp > HpLim) goto clbc; else goto clbb;
  clbc:
      HpAlloc = 80;
      goto clb9;
  clb9:
      R1 = _sk78::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  clbb:
      _sk6h::P64 = P64[_sk78::P64 + 16];
      _sk6i::P64 = P64[_sk78::P64 + 24];
      _sk6j::P64 = P64[_sk78::P64 + 32];
      _sk6k::P64 = P64[_sk78::P64 + 40];
      _sk6l::P64 = P64[_sk78::P64 + 48];
      _sk6n::P64 = P64[_sk78::P64 + 56];
      _sk6o::P64 = P64[_sk78::P64 + 64];
      _sk6r::P64 = P64[_sk78::P64 + 72];
      I64[Hp - 72] = sat_sk77_info;
      P64[Hp - 56] = _sk6h::P64;
      P64[Hp - 48] = _sk6i::P64;
      P64[Hp - 40] = _sk6j::P64;
      P64[Hp - 32] = _sk6k::P64;
      P64[Hp - 24] = _sk6l::P64;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      _cl6Z::P64 = Hp - 72;
      R3 = _cl6Z::P64;
      R2 = lvl10_rjV7_closure;
      call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:55.602978 UTC

{offset
  clb8:
      _sk78::P64 = R1;
      goto clba;
  clba:
      Hp = Hp + 80;
      if (Hp > HpLim) goto clbc; else goto clbb;
  clbc:
      HpAlloc = 80;
      goto clb9;
  clb9:
      R1 = _sk78::P64;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  clbb:
      _sk6h::P64 = P64[_sk78::P64 + 16];
      _sk6i::P64 = P64[_sk78::P64 + 24];
      _sk6j::P64 = P64[_sk78::P64 + 32];
      _sk6k::P64 = P64[_sk78::P64 + 40];
      _sk6l::P64 = P64[_sk78::P64 + 48];
      _sk6n::P64 = P64[_sk78::P64 + 56];
      _sk6o::P64 = P64[_sk78::P64 + 64];
      _sk6r::P64 = P64[_sk78::P64 + 72];
      I64[Hp - 72] = sat_sk77_info;
      P64[Hp - 56] = _sk6h::P64;
      P64[Hp - 48] = _sk6i::P64;
      P64[Hp - 40] = _sk6j::P64;
      P64[Hp - 32] = _sk6k::P64;
      P64[Hp - 24] = _sk6l::P64;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      _cl6Z::P64 = Hp - 72;
      R3 = _cl6Z::P64;
      R2 = lvl10_rjV7_closure;
      call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:55.604704 UTC

{offset
  clb8:
      goto clba;
  clba:
      Hp = Hp + 80;
      if (Hp > HpLim) goto clbc; else goto clbb;
  clbc:
      HpAlloc = 80;
      goto clb9;
  clb9:
      R1 = R1;
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
  clbb:
      _sk6h::P64 = P64[R1 + 16];
      _sk6i::P64 = P64[R1 + 24];
      _sk6j::P64 = P64[R1 + 32];
      _sk6k::P64 = P64[R1 + 40];
      _sk6l::P64 = P64[R1 + 48];
      _sk6n::P64 = P64[R1 + 56];
      _sk6o::P64 = P64[R1 + 64];
      _sk6r::P64 = P64[R1 + 72];
      I64[Hp - 72] = sat_sk77_info;
      P64[Hp - 56] = _sk6h::P64;
      P64[Hp - 48] = _sk6i::P64;
      P64[Hp - 40] = _sk6j::P64;
      P64[Hp - 32] = _sk6k::P64;
      P64[Hp - 24] = _sk6l::P64;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      R3 = Hp - 72;
      R2 = lvl10_rjV7_closure;
      call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:55.606616 UTC

[(clb8, {lvl10_rjV7_closure, sat_sk77_closure}), (clb9, {}),
 (clba, {lvl10_rjV7_closure, sat_sk77_closure}),
 (clbb, {lvl10_rjV7_closure, sat_sk77_closure}), (clbc, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:55.607185 UTC

sat_sk78_entry() //  [R1]
        { info_tbl: [(clb8,
                      label: sat_sk78_info
                      rep:HeapRep 8 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      clb8:
          goto clba;
      clba:
          Hp = Hp + 80;
          if (Hp > HpLim) goto clbc; else goto clbb;
      clbc:
          HpAlloc = 80;
          goto clb9;
      clb9:
          R1 = R1;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      clbb:
          _sk6h::P64 = P64[R1 + 16];
          _sk6i::P64 = P64[R1 + 24];
          _sk6j::P64 = P64[R1 + 32];
          _sk6k::P64 = P64[R1 + 40];
          _sk6l::P64 = P64[R1 + 48];
          _sk6n::P64 = P64[R1 + 56];
          _sk6o::P64 = P64[R1 + 64];
          _sk6r::P64 = P64[R1 + 72];
          I64[Hp - 72] = sat_sk77_info;
          P64[Hp - 56] = _sk6h::P64;
          P64[Hp - 48] = _sk6i::P64;
          P64[Hp - 40] = _sk6j::P64;
          P64[Hp - 32] = _sk6k::P64;
          P64[Hp - 24] = _sk6l::P64;
          P64[Hp - 16] = _sk6n::P64;
          P64[Hp - 8] = _sk6o::P64;
          P64[Hp] = _sk6r::P64;
          R3 = Hp - 72;
          R2 = lvl10_rjV7_closure;
          call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:55.609129 UTC

sat_sk78_entry() //  [R1]
        { info_tbl: [(clb8,
                      label: sat_sk78_info
                      rep:HeapRep 8 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      clb8:
          Hp = Hp + 80;
          if (Hp > HpLim) goto clbc; else goto clbb;
      clbc:
          HpAlloc = 80;
          R1 = R1;
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
      clbb:
          _sk6h::P64 = P64[R1 + 16];
          _sk6i::P64 = P64[R1 + 24];
          _sk6j::P64 = P64[R1 + 32];
          _sk6k::P64 = P64[R1 + 40];
          _sk6l::P64 = P64[R1 + 48];
          _sk6n::P64 = P64[R1 + 56];
          _sk6o::P64 = P64[R1 + 64];
          _sk6r::P64 = P64[R1 + 72];
          I64[Hp - 72] = sat_sk77_info;
          P64[Hp - 56] = _sk6h::P64;
          P64[Hp - 48] = _sk6i::P64;
          P64[Hp - 40] = _sk6j::P64;
          P64[Hp - 32] = _sk6k::P64;
          P64[Hp - 24] = _sk6l::P64;
          P64[Hp - 16] = _sk6n::P64;
          P64[Hp - 8] = _sk6o::P64;
          P64[Hp] = _sk6r::P64;
          R3 = Hp - 72;
          R2 = lvl10_rjV7_closure;
          call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:55.610967 UTC

{offset
  clbd:
      _sk6r::P64 = R2;
      _sk79::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto clbe; else goto clbf;
  clbf:
      Hp = Hp + 80;
      if (Hp > HpLim) goto clbh; else goto clbg;
  clbh:
      HpAlloc = 80;
      goto clbe;
  clbe:
      R2 = _sk6r::P64;
      R1 = _sk79::P64;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  clbg:
      _sk6h::P64 = P64[_sk79::P64 + 7];
      _sk6i::P64 = P64[_sk79::P64 + 15];
      _sk6j::P64 = P64[_sk79::P64 + 23];
      _sk6k::P64 = P64[_sk79::P64 + 31];
      _sk6l::P64 = P64[_sk79::P64 + 39];
      _sk6n::P64 = P64[_sk79::P64 + 47];
      _sk6o::P64 = P64[_sk79::P64 + 55];
      I64[Hp - 72] = sat_sk78_info;
      P64[Hp - 56] = _sk6h::P64;
      P64[Hp - 48] = _sk6i::P64;
      P64[Hp - 40] = _sk6j::P64;
      P64[Hp - 32] = _sk6k::P64;
      P64[Hp - 24] = _sk6l::P64;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      _cl6V::P64 = Hp - 72;
      R3 = _cl6V::P64;
      R2 = lvl11_rjV8_closure;
      call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:55.612792 UTC

{offset
  clbd:
      _sk6r::P64 = R2;
      _sk79::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto clbe; else goto clbf;
  clbf:
      Hp = Hp + 80;
      if (Hp > HpLim) goto clbh; else goto clbg;
  clbh:
      HpAlloc = 80;
      goto clbe;
  clbe:
      R2 = _sk6r::P64;
      R1 = _sk79::P64;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  clbg:
      _sk6h::P64 = P64[_sk79::P64 + 7];
      _sk6i::P64 = P64[_sk79::P64 + 15];
      _sk6j::P64 = P64[_sk79::P64 + 23];
      _sk6k::P64 = P64[_sk79::P64 + 31];
      _sk6l::P64 = P64[_sk79::P64 + 39];
      _sk6n::P64 = P64[_sk79::P64 + 47];
      _sk6o::P64 = P64[_sk79::P64 + 55];
      I64[Hp - 72] = sat_sk78_info;
      P64[Hp - 56] = _sk6h::P64;
      P64[Hp - 48] = _sk6i::P64;
      P64[Hp - 40] = _sk6j::P64;
      P64[Hp - 32] = _sk6k::P64;
      P64[Hp - 24] = _sk6l::P64;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      _cl6V::P64 = Hp - 72;
      R3 = _cl6V::P64;
      R2 = lvl11_rjV8_closure;
      call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:55.614618 UTC

{offset
  clbd:
      _sk6r::P64 = R2;
      _sk79::P64 = R1;
      if ((old + 0) - <highSp> < SpLim) goto clbe; else goto clbf;
  clbf:
      Hp = Hp + 80;
      if (Hp > HpLim) goto clbh; else goto clbg;
  clbh:
      HpAlloc = 80;
      goto clbe;
  clbe:
      R2 = _sk6r::P64;
      R1 = _sk79::P64;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  clbg:
      _sk6h::P64 = P64[_sk79::P64 + 7];
      _sk6i::P64 = P64[_sk79::P64 + 15];
      _sk6j::P64 = P64[_sk79::P64 + 23];
      _sk6k::P64 = P64[_sk79::P64 + 31];
      _sk6l::P64 = P64[_sk79::P64 + 39];
      _sk6n::P64 = P64[_sk79::P64 + 47];
      _sk6o::P64 = P64[_sk79::P64 + 55];
      I64[Hp - 72] = sat_sk78_info;
      P64[Hp - 56] = _sk6h::P64;
      P64[Hp - 48] = _sk6i::P64;
      P64[Hp - 40] = _sk6j::P64;
      P64[Hp - 32] = _sk6k::P64;
      P64[Hp - 24] = _sk6l::P64;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      _cl6V::P64 = Hp - 72;
      R3 = _cl6V::P64;
      R2 = lvl11_rjV8_closure;
      call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:55.616462 UTC

{offset
  clbd:
      _sk6r::P64 = R2;
      _sk79::P64 = R1;
      goto clbf;
  clbf:
      Hp = Hp + 80;
      if (Hp > HpLim) goto clbh; else goto clbg;
  clbh:
      HpAlloc = 80;
      goto clbe;
  clbe:
      R2 = _sk6r::P64;
      R1 = _sk79::P64;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  clbg:
      _sk6h::P64 = P64[_sk79::P64 + 7];
      _sk6i::P64 = P64[_sk79::P64 + 15];
      _sk6j::P64 = P64[_sk79::P64 + 23];
      _sk6k::P64 = P64[_sk79::P64 + 31];
      _sk6l::P64 = P64[_sk79::P64 + 39];
      _sk6n::P64 = P64[_sk79::P64 + 47];
      _sk6o::P64 = P64[_sk79::P64 + 55];
      I64[Hp - 72] = sat_sk78_info;
      P64[Hp - 56] = _sk6h::P64;
      P64[Hp - 48] = _sk6i::P64;
      P64[Hp - 40] = _sk6j::P64;
      P64[Hp - 32] = _sk6k::P64;
      P64[Hp - 24] = _sk6l::P64;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = _sk6r::P64;
      _cl6V::P64 = Hp - 72;
      R3 = _cl6V::P64;
      R2 = lvl11_rjV8_closure;
      call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:55.618208 UTC

{offset
  clbd:
      goto clbf;
  clbf:
      Hp = Hp + 80;
      if (Hp > HpLim) goto clbh; else goto clbg;
  clbh:
      HpAlloc = 80;
      goto clbe;
  clbe:
      R2 = R2;
      R1 = R1;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  clbg:
      _sk6h::P64 = P64[R1 + 7];
      _sk6i::P64 = P64[R1 + 15];
      _sk6j::P64 = P64[R1 + 23];
      _sk6k::P64 = P64[R1 + 31];
      _sk6l::P64 = P64[R1 + 39];
      _sk6n::P64 = P64[R1 + 47];
      _sk6o::P64 = P64[R1 + 55];
      I64[Hp - 72] = sat_sk78_info;
      P64[Hp - 56] = _sk6h::P64;
      P64[Hp - 48] = _sk6i::P64;
      P64[Hp - 40] = _sk6j::P64;
      P64[Hp - 32] = _sk6k::P64;
      P64[Hp - 24] = _sk6l::P64;
      P64[Hp - 16] = _sk6n::P64;
      P64[Hp - 8] = _sk6o::P64;
      P64[Hp] = R2;
      R3 = Hp - 72;
      R2 = lvl11_rjV8_closure;
      call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:55.620198 UTC

[(clbd, {lvl11_rjV8_closure, sat_sk78_closure}), (clbe, {}),
 (clbf, {lvl11_rjV8_closure, sat_sk78_closure}),
 (clbg, {lvl11_rjV8_closure, sat_sk78_closure}), (clbh, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:55.620724 UTC

sat_sk79_entry() //  [R2, R1]
        { info_tbl: [(clbd,
                      label: sat_sk79_info
                      rep:HeapRep 7 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      clbd:
          goto clbf;
      clbf:
          Hp = Hp + 80;
          if (Hp > HpLim) goto clbh; else goto clbg;
      clbh:
          HpAlloc = 80;
          goto clbe;
      clbe:
          R2 = R2;
          R1 = R1;
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
      clbg:
          _sk6h::P64 = P64[R1 + 7];
          _sk6i::P64 = P64[R1 + 15];
          _sk6j::P64 = P64[R1 + 23];
          _sk6k::P64 = P64[R1 + 31];
          _sk6l::P64 = P64[R1 + 39];
          _sk6n::P64 = P64[R1 + 47];
          _sk6o::P64 = P64[R1 + 55];
          I64[Hp - 72] = sat_sk78_info;
          P64[Hp - 56] = _sk6h::P64;
          P64[Hp - 48] = _sk6i::P64;
          P64[Hp - 40] = _sk6j::P64;
          P64[Hp - 32] = _sk6k::P64;
          P64[Hp - 24] = _sk6l::P64;
          P64[Hp - 16] = _sk6n::P64;
          P64[Hp - 8] = _sk6o::P64;
          P64[Hp] = R2;
          R3 = Hp - 72;
          R2 = lvl11_rjV8_closure;
          call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:55.622638 UTC

sat_sk79_entry() //  [R2, R1]
        { info_tbl: [(clbd,
                      label: sat_sk79_info
                      rep:HeapRep 7 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      clbd:
          Hp = Hp + 80;
          if (Hp > HpLim) goto clbh; else goto clbg;
      clbh:
          HpAlloc = 80;
          R2 = R2;
          R1 = R1;
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
      clbg:
          _sk6h::P64 = P64[R1 + 7];
          _sk6i::P64 = P64[R1 + 15];
          _sk6j::P64 = P64[R1 + 23];
          _sk6k::P64 = P64[R1 + 31];
          _sk6l::P64 = P64[R1 + 39];
          _sk6n::P64 = P64[R1 + 47];
          _sk6o::P64 = P64[R1 + 55];
          I64[Hp - 72] = sat_sk78_info;
          P64[Hp - 56] = _sk6h::P64;
          P64[Hp - 48] = _sk6i::P64;
          P64[Hp - 40] = _sk6j::P64;
          P64[Hp - 32] = _sk6k::P64;
          P64[Hp - 24] = _sk6l::P64;
          P64[Hp - 16] = _sk6n::P64;
          P64[Hp - 8] = _sk6o::P64;
          P64[Hp] = R2;
          R3 = Hp - 72;
          R2 = lvl11_rjV8_closure;
          call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:55.624467 UTC

{offset
  clbi:
      _sk6l::P64 = R6;
      _sk6k::P64 = R5;
      _sk6j::P64 = R4;
      _sk6i::P64 = R3;
      _sk6h::P64 = R2;
      _sk6m::P64 = P64[(old + 24)];
      _sk6n::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto clbj; else goto clbk;
  clbk:
      Hp = Hp + 88;
      if (Hp > HpLim) goto clbm; else goto clbl;
  clbm:
      HpAlloc = 88;
      goto clbj;
  clbj:
      R1 = Main.$w$cshowsPrec_closure;
      P64[(old + 64)] = _sk6h::P64;
      P64[(old + 56)] = _sk6i::P64;
      P64[(old + 48)] = _sk6j::P64;
      P64[(old + 40)] = _sk6k::P64;
      P64[(old + 32)] = _sk6l::P64;
      P64[(old + 24)] = _sk6m::P64;
      P64[(old + 16)] = _sk6n::P64;
      call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
  clbl:
      I64[Hp - 80] = f_sk6o_info;
      P64[Hp - 64] = _sk6m::P64;
      _cl6C::P64 = Hp - 80;
      I64[Hp - 56] = sat_sk79_info;
      P64[Hp - 48] = _sk6h::P64;
      P64[Hp - 40] = _sk6i::P64;
      P64[Hp - 32] = _sk6j::P64;
      P64[Hp - 24] = _sk6k::P64;
      P64[Hp - 16] = _sk6l::P64;
      P64[Hp - 8] = _sk6n::P64;
      P64[Hp] = _cl6C::P64;
      _cl6Q::P64 = Hp - 55;
      R1 = _cl6Q::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:55.626952 UTC

{offset
  clbi:
      _sk6l::P64 = R6;
      _sk6k::P64 = R5;
      _sk6j::P64 = R4;
      _sk6i::P64 = R3;
      _sk6h::P64 = R2;
      _sk6m::P64 = P64[(old + 24)];
      _sk6n::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto clbj; else goto clbk;
  clbk:
      Hp = Hp + 88;
      if (Hp > HpLim) goto clbm; else goto clbl;
  clbm:
      HpAlloc = 88;
      goto clbj;
  clbj:
      R1 = Main.$w$cshowsPrec_closure;
      P64[(old + 64)] = _sk6h::P64;
      P64[(old + 56)] = _sk6i::P64;
      P64[(old + 48)] = _sk6j::P64;
      P64[(old + 40)] = _sk6k::P64;
      P64[(old + 32)] = _sk6l::P64;
      P64[(old + 24)] = _sk6m::P64;
      P64[(old + 16)] = _sk6n::P64;
      call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
  clbl:
      I64[Hp - 80] = f_sk6o_info;
      P64[Hp - 64] = _sk6m::P64;
      _cl6C::P64 = Hp - 80;
      I64[Hp - 56] = sat_sk79_info;
      P64[Hp - 48] = _sk6h::P64;
      P64[Hp - 40] = _sk6i::P64;
      P64[Hp - 32] = _sk6j::P64;
      P64[Hp - 24] = _sk6k::P64;
      P64[Hp - 16] = _sk6l::P64;
      P64[Hp - 8] = _sk6n::P64;
      P64[Hp] = _cl6C::P64;
      _cl6Q::P64 = Hp - 55;
      R1 = _cl6Q::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:55.628926 UTC

{offset
  clbi:
      _sk6l::P64 = R6;
      _sk6k::P64 = R5;
      _sk6j::P64 = R4;
      _sk6i::P64 = R3;
      _sk6h::P64 = R2;
      _sk6m::P64 = P64[(old + 24)];
      _sk6n::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto clbj; else goto clbk;
  clbk:
      Hp = Hp + 88;
      if (Hp > HpLim) goto clbm; else goto clbl;
  clbm:
      HpAlloc = 88;
      goto clbj;
  clbj:
      R1 = Main.$w$cshowsPrec_closure;
      P64[(old + 64)] = _sk6h::P64;
      P64[(old + 56)] = _sk6i::P64;
      P64[(old + 48)] = _sk6j::P64;
      P64[(old + 40)] = _sk6k::P64;
      P64[(old + 32)] = _sk6l::P64;
      P64[(old + 24)] = _sk6m::P64;
      P64[(old + 16)] = _sk6n::P64;
      call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
  clbl:
      I64[Hp - 80] = f_sk6o_info;
      P64[Hp - 64] = _sk6m::P64;
      _cl6C::P64 = Hp - 80;
      I64[Hp - 56] = sat_sk79_info;
      P64[Hp - 48] = _sk6h::P64;
      P64[Hp - 40] = _sk6i::P64;
      P64[Hp - 32] = _sk6j::P64;
      P64[Hp - 24] = _sk6k::P64;
      P64[Hp - 16] = _sk6l::P64;
      P64[Hp - 8] = _sk6n::P64;
      P64[Hp] = _cl6C::P64;
      _cl6Q::P64 = Hp - 55;
      R1 = _cl6Q::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:55.631028 UTC

{offset
  clbi:
      _sk6l::P64 = R6;
      _sk6k::P64 = R5;
      _sk6j::P64 = R4;
      _sk6i::P64 = R3;
      _sk6h::P64 = R2;
      _sk6m::P64 = P64[Sp];
      _sk6n::P64 = P64[Sp + 8];
      goto clbk;
  clbk:
      Hp = Hp + 88;
      if (Hp > HpLim) goto clbm; else goto clbl;
  clbm:
      HpAlloc = 88;
      goto clbj;
  clbj:
      R1 = Main.$w$cshowsPrec_closure;
      P64[Sp - 40] = _sk6h::P64;
      P64[Sp - 32] = _sk6i::P64;
      P64[Sp - 24] = _sk6j::P64;
      P64[Sp - 16] = _sk6k::P64;
      P64[Sp - 8] = _sk6l::P64;
      Sp = Sp - 40;
      call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
  clbl:
      I64[Hp - 80] = f_sk6o_info;
      P64[Hp - 64] = _sk6m::P64;
      _cl6C::P64 = Hp - 80;
      I64[Hp - 56] = sat_sk79_info;
      P64[Hp - 48] = _sk6h::P64;
      P64[Hp - 40] = _sk6i::P64;
      P64[Hp - 32] = _sk6j::P64;
      P64[Hp - 24] = _sk6k::P64;
      P64[Hp - 16] = _sk6l::P64;
      P64[Hp - 8] = _sk6n::P64;
      P64[Hp] = _cl6C::P64;
      _cl6Q::P64 = Hp - 55;
      R1 = _cl6Q::P64;
      Sp = Sp + 16;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:55.632897 UTC

{offset
  clbi:
      goto clbk;
  clbk:
      Hp = Hp + 88;
      if (Hp > HpLim) goto clbm; else goto clbl;
  clbm:
      HpAlloc = 88;
      goto clbj;
  clbj:
      R1 = Main.$w$cshowsPrec_closure;
      P64[Sp - 40] = R2;
      P64[Sp - 32] = R3;
      P64[Sp - 24] = R4;
      P64[Sp - 16] = R5;
      P64[Sp - 8] = R6;
      Sp = Sp - 40;
      call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
  clbl:
      I64[Hp - 80] = f_sk6o_info;
      P64[Hp - 64] = P64[Sp];
      I64[Hp - 56] = sat_sk79_info;
      P64[Hp - 48] = R2;
      P64[Hp - 40] = R3;
      P64[Hp - 32] = R4;
      P64[Hp - 24] = R5;
      P64[Hp - 16] = R6;
      P64[Hp - 8] = P64[Sp + 8];
      P64[Hp] = Hp - 80;
      R1 = Hp - 55;
      Sp = Sp + 16;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:55.63497 UTC

[(clbi,
  {Main.$w$cshowsPrec_closure, f_sk6o_closure, sat_sk79_closure}),
 (clbj, {Main.$w$cshowsPrec_closure}),
 (clbk,
  {Main.$w$cshowsPrec_closure, f_sk6o_closure, sat_sk79_closure}),
 (clbl, {f_sk6o_closure, sat_sk79_closure}),
 (clbm, {Main.$w$cshowsPrec_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:55.635639 UTC

Main.$w$cshowsPrec_entry() //  [R6, R5, R4, R3, R2]
        { info_tbl: [(clbi,
                      label: Main.$w$cshowsPrec_info
                      rep:HeapRep static {
                            Fun {arity: 7
                                 fun_type: ArgGen [False, False, False, False, False, False,
                                                   False]} })]
          stack_info: arg_space: 24 updfr_space: Just 8
        }
    {offset
      clbi:
          goto clbk;
      clbk:
          Hp = Hp + 88;
          if (Hp > HpLim) goto clbm; else goto clbl;
      clbm:
          HpAlloc = 88;
          goto clbj;
      clbj:
          R1 = Main.$w$cshowsPrec_closure;
          P64[Sp - 40] = R2;
          P64[Sp - 32] = R3;
          P64[Sp - 24] = R4;
          P64[Sp - 16] = R5;
          P64[Sp - 8] = R6;
          Sp = Sp - 40;
          call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
      clbl:
          I64[Hp - 80] = f_sk6o_info;
          P64[Hp - 64] = P64[Sp];
          I64[Hp - 56] = sat_sk79_info;
          P64[Hp - 48] = R2;
          P64[Hp - 40] = R3;
          P64[Hp - 32] = R4;
          P64[Hp - 24] = R5;
          P64[Hp - 16] = R6;
          P64[Hp - 8] = P64[Sp + 8];
          P64[Hp] = Hp - 80;
          R1 = Hp - 55;
          Sp = Sp + 16;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:55.637589 UTC

Main.$w$cshowsPrec_entry() //  [R6, R5, R4, R3, R2]
        { info_tbl: [(clbi,
                      label: Main.$w$cshowsPrec_info
                      rep:HeapRep static {
                            Fun {arity: 7
                                 fun_type: ArgGen [False, False, False, False, False, False,
                                                   False]} })]
          stack_info: arg_space: 24 updfr_space: Just 8
        }
    {offset
      clbi:
          Hp = Hp + 88;
          if (Hp > HpLim) goto clbm; else goto clbl;
      clbm:
          HpAlloc = 88;
          R1 = Main.$w$cshowsPrec_closure;
          P64[Sp - 40] = R2;
          P64[Sp - 32] = R3;
          P64[Sp - 24] = R4;
          P64[Sp - 16] = R5;
          P64[Sp - 8] = R6;
          Sp = Sp - 40;
          call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
      clbl:
          I64[Hp - 80] = f_sk6o_info;
          P64[Hp - 64] = P64[Sp];
          I64[Hp - 56] = sat_sk79_info;
          P64[Hp - 48] = R2;
          P64[Hp - 40] = R3;
          P64[Hp - 32] = R4;
          P64[Hp - 24] = R5;
          P64[Hp - 16] = R6;
          P64[Hp - 8] = P64[Sp + 8];
          P64[Hp] = Hp - 80;
          R1 = Hp - 55;
          Sp = Sp + 16;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:55.639565 UTC

[section "data" {
     Main.$w$cshowsPrec_closure:
         const Main.$w$cshowsPrec_info;
         const 0;
 },
 Main.$w$cshowsPrec_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 64 updfr_space: Just 8
         }
     {offset
       cl5T:
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Main.$w$cshowsPrec_info(R6,
                                        R5,
                                        R4,
                                        R3,
                                        R2,
                                        R1) args: 24, res: 0, upd: 8;
     }
 },
 f_sk6o_entry() //  [R1]
         { info_tbl: [(cl6G,
                       label: block_cl6G_info
                       rep:StackRep []),
                      (cl6J,
                       label: f_sk6o_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cl6J:
           _sk6o::P64 = R1;
           if ((Sp + -24) < SpLim) goto cl6K; else goto cl6L;
       cl6L:
           if (HpLim == 0) goto cl6K; else goto cl6M;
       cl6K:
           R1 = _sk6o::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cl6M:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sk6o::P64;
           I64[Sp - 24] = cl6G;
           R1 = P64[_sk6o::P64 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto cl6G; else goto cl6H;
       cl6H:
           call (I64[R1])(R1) returns to cl6G, args: 8, res: 8, upd: 24;
       cl6G:
           D1 = F64[R1 + 7];
           R3 = lvl4_rjV1_closure+1;
           R2 = GHC.Float.$fShowDouble_$sshowFloat_closure+1;
           Sp = Sp + 8;
           call GHC.Float.$w$sshowSignedFloat_info(D1,
                                                   R3,
                                                   R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sk6C_entry() //  [R1]
         { info_tbl: [(cl8B,
                       label: sat_sk6C_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cl8B:
           _sk6C::P64 = R1;
           if ((Sp + -16) < SpLim) goto cl8C; else goto cl8D;
       cl8D:
           if (HpLim == 0) goto cl8C; else goto cl8E;
       cl8C:
           R1 = _sk6C::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cl8E:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sk6C::P64;
           R3 = P64[_sk6C::P64 + 16];
           R2 = lvl1_rjUY_closure;
           Sp = Sp - 16;
           call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sk6G_entry() //  [R1]
         { info_tbl: [(cl8s,
                       label: block_cl8s_info
                       rep:StackRep [False]),
                      (cl8F,
                       label: sat_sk6G_info
                       rep:HeapRep 2 ptrs { Thunk }),
                      (cl8G,
                       label: block_cl8G_info
                       rep:StackRep [])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cl8F:
           _sk6G::P64 = R1;
           if ((Sp + -16) < SpLim) goto cl8J; else goto cl8K;
       cl8K:
           if (HpLim == 0) goto cl8J; else goto cl8L;
       cl8J:
           R1 = _sk6G::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cl8L:
           I64[Sp - 16] = cl8s;
           R1 = P64[_sk6G::P64 + 16];
           P64[Sp - 8] = P64[_sk6G::P64 + 24];
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto cl8s; else goto cl8t;
       cl8t:
           call (I64[R1])(R1) returns to cl8s, args: 8, res: 8, upd: 8;
       cl8s:
           Hp = Hp + 24;
           if (Hp > HpLim) goto cl8O; else goto cl8N;
       cl8O:
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to cl8s, args: 8, res: 8, upd: 8;
       cl8N:
           _sk6B::I64 = I64[R1 + 7];
           I64[Hp - 16] = sat_sk6C_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = cl8G;
           R4 = Hp - 16;
           R3 = _sk6B::I64;
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Show.$wshowSignedInt_info(R4,
                                              R3,
                                              R2) returns to cl8G, args: 8, res: 8, upd: 8;
       cl8G:
           Hp = Hp + 24;
           if (Hp > HpLim) goto cl8R; else goto cl8Q;
       cl8R:
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) returns to cl8G, args: 8, res: 8, upd: 8;
       cl8Q:
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sk6H_entry() //  [R1]
         { info_tbl: [(cl8S,
                       label: sat_sk6H_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cl8S:
           Hp = Hp + 32;
           if (Hp > HpLim) goto cl8W; else goto cl8V;
       cl8W:
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cl8V:
           _sk6n::P64 = P64[R1 + 16];
           _sk6r::P64 = P64[R1 + 24];
           I64[Hp - 24] = sat_sk6G_info;
           P64[Hp - 8] = _sk6n::P64;
           P64[Hp] = _sk6r::P64;
           R3 = Hp - 24;
           R2 = lvl2_rjUZ_closure;
           call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sk6I_entry() //  [R1]
         { info_tbl: [(cl8X,
                       label: sat_sk6I_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cl8X:
           _sk6I::P64 = R1;
           if ((Sp + -16) < SpLim) goto cl8Y; else goto cl8Z;
       cl8Z:
           Hp = Hp + 32;
           if (Hp > HpLim) goto cl91; else goto cl90;
       cl91:
           HpAlloc = 32;
           goto cl8Y;
       cl8Y:
           R1 = _sk6I::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cl90:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sk6I::P64;
           _sk6n::P64 = P64[_sk6I::P64 + 16];
           _sk6r::P64 = P64[_sk6I::P64 + 24];
           I64[Hp - 24] = sat_sk6H_info;
           P64[Hp - 8] = _sk6n::P64;
           P64[Hp] = _sk6r::P64;
           R3 = Hp - 24;
           R2 = lvl3_rjV0_closure;
           Sp = Sp - 16;
           call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sk6J_entry() //  [R1]
         { info_tbl: [(cl92,
                       label: sat_sk6J_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cl92:
           Hp = Hp + 32;
           if (Hp > HpLim) goto cl96; else goto cl95;
       cl96:
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cl95:
           _sk6n::P64 = P64[R1 + 16];
           _sk6o::P64 = P64[R1 + 24];
           _sk6r::P64 = P64[R1 + 32];
           I64[Hp - 24] = sat_sk6I_info;
           P64[Hp - 8] = _sk6n::P64;
           P64[Hp] = _sk6r::P64;
           R2 = Hp - 24;
           R1 = _sk6o::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sk6K_entry() //  [R1]
         { info_tbl: [(cl97,
                       label: sat_sk6K_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cl97:
           Hp = Hp + 40;
           if (Hp > HpLim) goto cl9b; else goto cl9a;
       cl9b:
           HpAlloc = 40;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cl9a:
           _sk6n::P64 = P64[R1 + 16];
           _sk6o::P64 = P64[R1 + 24];
           _sk6r::P64 = P64[R1 + 32];
           I64[Hp - 32] = sat_sk6J_info;
           P64[Hp - 16] = _sk6n::P64;
           P64[Hp - 8] = _sk6o::P64;
           P64[Hp] = _sk6r::P64;
           R3 = Hp - 32;
           R2 = lvl5_rjV2_closure;
           call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sk6L_entry() //  [R1]
         { info_tbl: [(cl9c,
                       label: sat_sk6L_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cl9c:
           _sk6L::P64 = R1;
           if ((Sp + -16) < SpLim) goto cl9d; else goto cl9e;
       cl9e:
           Hp = Hp + 40;
           if (Hp > HpLim) goto cl9g; else goto cl9f;
       cl9g:
           HpAlloc = 40;
           goto cl9d;
       cl9d:
           R1 = _sk6L::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cl9f:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sk6L::P64;
           _sk6n::P64 = P64[_sk6L::P64 + 16];
           _sk6o::P64 = P64[_sk6L::P64 + 24];
           _sk6r::P64 = P64[_sk6L::P64 + 32];
           I64[Hp - 32] = sat_sk6K_info;
           P64[Hp - 16] = _sk6n::P64;
           P64[Hp - 8] = _sk6o::P64;
           P64[Hp] = _sk6r::P64;
           R3 = Hp - 32;
           R2 = lvl3_rjV0_closure;
           Sp = Sp - 16;
           call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sk6P_entry() //  [R1]
         { info_tbl: [(cl7Z,
                       label: block_cl7Z_info
                       rep:StackRep [False, False, False]),
                      (cl9h,
                       label: sat_sk6P_info
                       rep:HeapRep 4 ptrs { Thunk }),
                      (cl9i,
                       label: block_cl9i_info
                       rep:StackRep [])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cl9h:
           _sk6P::P64 = R1;
           if ((Sp + -32) < SpLim) goto cl9l; else goto cl9m;
       cl9m:
           if (HpLim == 0) goto cl9l; else goto cl9n;
       cl9l:
           R1 = _sk6P::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cl9n:
           I64[Sp - 32] = cl7Z;
           R1 = P64[_sk6P::P64 + 16];
           P64[Sp - 24] = P64[_sk6P::P64 + 24];
           P64[Sp - 16] = P64[_sk6P::P64 + 32];
           P64[Sp - 8] = P64[_sk6P::P64 + 40];
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto cl7Z; else goto cl80;
       cl80:
           call (I64[R1])(R1) returns to cl7Z, args: 8, res: 8, upd: 8;
       cl7Z:
           Hp = Hp + 40;
           if (Hp > HpLim) goto cl9q; else goto cl9p;
       cl9q:
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to cl7Z, args: 8, res: 8, upd: 8;
       cl9p:
           _sk6z::I64 = I64[R1 + 7];
           I64[Hp - 32] = sat_sk6L_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 24];
           I64[Sp + 24] = cl9i;
           R4 = Hp - 32;
           R3 = _sk6z::I64;
           R2 = 0;
           Sp = Sp + 24;
           call GHC.Show.$wshowSignedInt_info(R4,
                                              R3,
                                              R2) returns to cl9i, args: 8, res: 8, upd: 8;
       cl9i:
           Hp = Hp + 24;
           if (Hp > HpLim) goto cl9t; else goto cl9s;
       cl9t:
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) returns to cl9i, args: 8, res: 8, upd: 8;
       cl9s:
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sk6Q_entry() //  [R1]
         { info_tbl: [(cl9u,
                       label: sat_sk6Q_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cl9u:
           Hp = Hp + 48;
           if (Hp > HpLim) goto cl9y; else goto cl9x;
       cl9y:
           HpAlloc = 48;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cl9x:
           _sk6l::P64 = P64[R1 + 16];
           _sk6n::P64 = P64[R1 + 24];
           _sk6o::P64 = P64[R1 + 32];
           _sk6r::P64 = P64[R1 + 40];
           I64[Hp - 40] = sat_sk6P_info;
           P64[Hp - 24] = _sk6l::P64;
           P64[Hp - 16] = _sk6n::P64;
           P64[Hp - 8] = _sk6o::P64;
           P64[Hp] = _sk6r::P64;
           R3 = Hp - 40;
           R2 = lvl6_rjV3_closure;
           call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 eta1_sk6x_entry() //  [R1]
         { info_tbl: [(cl9z,
                       label: eta1_sk6x_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cl9z:
           _sk6x::P64 = R1;
           if ((Sp + -16) < SpLim) goto cl9A; else goto cl9B;
       cl9B:
           Hp = Hp + 48;
           if (Hp > HpLim) goto cl9D; else goto cl9C;
       cl9D:
           HpAlloc = 48;
           goto cl9A;
       cl9A:
           R1 = _sk6x::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cl9C:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sk6x::P64;
           _sk6l::P64 = P64[_sk6x::P64 + 16];
           _sk6n::P64 = P64[_sk6x::P64 + 24];
           _sk6o::P64 = P64[_sk6x::P64 + 32];
           _sk6r::P64 = P64[_sk6x::P64 + 40];
           I64[Hp - 40] = sat_sk6Q_info;
           P64[Hp - 24] = _sk6l::P64;
           P64[Hp - 16] = _sk6n::P64;
           P64[Hp - 8] = _sk6o::P64;
           P64[Hp] = _sk6r::P64;
           R3 = Hp - 40;
           R2 = lvl3_rjV0_closure;
           Sp = Sp - 16;
           call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sk6S_entry() //  [R1]
         { info_tbl: [(cl9E,
                       label: block_cl9E_info
                       rep:StackRep [False]),
                      (cl9L,
                       label: sat_sk6S_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cl9L:
           _sk6S::P64 = R1;
           if ((Sp + -16) < SpLim) goto cl9M; else goto cl9N;
       cl9N:
           Hp = Hp + 48;
           if (Hp > HpLim) goto cl9P; else goto cl9O;
       cl9P:
           HpAlloc = 48;
           goto cl9M;
       cl9M:
           R1 = _sk6S::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cl9O:
           _sk6k::P64 = P64[_sk6S::P64 + 16];
           _sk6l::P64 = P64[_sk6S::P64 + 24];
           _sk6n::P64 = P64[_sk6S::P64 + 32];
           _sk6o::P64 = P64[_sk6S::P64 + 40];
           _sk6r::P64 = P64[_sk6S::P64 + 48];
           I64[Hp - 40] = eta1_sk6x_info;
           P64[Hp - 24] = _sk6l::P64;
           P64[Hp - 16] = _sk6n::P64;
           P64[Hp - 8] = _sk6o::P64;
           P64[Hp] = _sk6r::P64;
           I64[Sp - 16] = cl9E;
           R1 = _sk6k::P64;
           P64[Sp - 8] = Hp - 40;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto cl9E; else goto cl9F;
       cl9F:
           call (I64[R1])(R1) returns to cl9E, args: 8, res: 8, upd: 8;
       cl9E:
           _cl7N::P64 = P64[Sp + 8];
           if (R1 & 7 != 1) goto cl9J; else goto cl9I;
       cl9J:
           R3 = _cl7N::P64;
           R2 = GHC.Show.shows16_closure;
           Sp = Sp + 16;
           call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
       cl9I:
           R3 = _cl7N::P64;
           R2 = GHC.Show.shows17_closure;
           Sp = Sp + 16;
           call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sk6T_entry() //  [R1]
         { info_tbl: [(cl9W,
                       label: sat_sk6T_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cl9W:
           Hp = Hp + 56;
           if (Hp > HpLim) goto cla0; else goto cl9Z;
       cla0:
           HpAlloc = 56;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cl9Z:
           _sk6k::P64 = P64[R1 + 16];
           _sk6l::P64 = P64[R1 + 24];
           _sk6n::P64 = P64[R1 + 32];
           _sk6o::P64 = P64[R1 + 40];
           _sk6r::P64 = P64[R1 + 48];
           I64[Hp - 48] = sat_sk6S_info;
           P64[Hp - 32] = _sk6k::P64;
           P64[Hp - 24] = _sk6l::P64;
           P64[Hp - 16] = _sk6n::P64;
           P64[Hp - 8] = _sk6o::P64;
           P64[Hp] = _sk6r::P64;
           R3 = Hp - 48;
           R2 = lvl7_rjV4_closure;
           call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 eta_sk6w_entry() //  [R1]
         { info_tbl: [(cla1,
                       label: eta_sk6w_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cla1:
           _sk6w::P64 = R1;
           if ((Sp + -16) < SpLim) goto cla2; else goto cla3;
       cla3:
           Hp = Hp + 56;
           if (Hp > HpLim) goto cla5; else goto cla4;
       cla5:
           HpAlloc = 56;
           goto cla2;
       cla2:
           R1 = _sk6w::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cla4:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sk6w::P64;
           _sk6k::P64 = P64[_sk6w::P64 + 16];
           _sk6l::P64 = P64[_sk6w::P64 + 24];
           _sk6n::P64 = P64[_sk6w::P64 + 32];
           _sk6o::P64 = P64[_sk6w::P64 + 40];
           _sk6r::P64 = P64[_sk6w::P64 + 48];
           I64[Hp - 48] = sat_sk6T_info;
           P64[Hp - 32] = _sk6k::P64;
           P64[Hp - 24] = _sk6l::P64;
           P64[Hp - 16] = _sk6n::P64;
           P64[Hp - 8] = _sk6o::P64;
           P64[Hp] = _sk6r::P64;
           R3 = Hp - 48;
           R2 = lvl3_rjV0_closure;
           Sp = Sp - 16;
           call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sk6V_entry() //  [R1]
         { info_tbl: [(cla6,
                       label: block_cla6_info
                       rep:StackRep [False]),
                      (clad,
                       label: sat_sk6V_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       clad:
           _sk6V::P64 = R1;
           if ((Sp + -16) < SpLim) goto clae; else goto claf;
       claf:
           Hp = Hp + 56;
           if (Hp > HpLim) goto clah; else goto clag;
       clah:
           HpAlloc = 56;
           goto clae;
       clae:
           R1 = _sk6V::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       clag:
           _sk6j::P64 = P64[_sk6V::P64 + 16];
           _sk6k::P64 = P64[_sk6V::P64 + 24];
           _sk6l::P64 = P64[_sk6V::P64 + 32];
           _sk6n::P64 = P64[_sk6V::P64 + 40];
           _sk6o::P64 = P64[_sk6V::P64 + 48];
           _sk6r::P64 = P64[_sk6V::P64 + 56];
           I64[Hp - 48] = eta_sk6w_info;
           P64[Hp - 32] = _sk6k::P64;
           P64[Hp - 24] = _sk6l::P64;
           P64[Hp - 16] = _sk6n::P64;
           P64[Hp - 8] = _sk6o::P64;
           P64[Hp] = _sk6r::P64;
           I64[Sp - 16] = cla6;
           R1 = _sk6j::P64;
           P64[Sp - 8] = Hp - 48;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto cla6; else goto cla7;
       cla7:
           call (I64[R1])(R1) returns to cla6, args: 8, res: 8, upd: 8;
       cla6:
           _cl7B::P64 = P64[Sp + 8];
           if (R1 & 7 != 1) goto clab; else goto claa;
       clab:
           R3 = _cl7B::P64;
           R2 = GHC.Show.shows16_closure;
           Sp = Sp + 16;
           call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
       claa:
           R3 = _cl7B::P64;
           R2 = GHC.Show.shows17_closure;
           Sp = Sp + 16;
           call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sk6W_entry() //  [R1]
         { info_tbl: [(clao,
                       label: sat_sk6W_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       clao:
           Hp = Hp + 64;
           if (Hp > HpLim) goto clas; else goto clar;
       clas:
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       clar:
           _sk6j::P64 = P64[R1 + 16];
           _sk6k::P64 = P64[R1 + 24];
           _sk6l::P64 = P64[R1 + 32];
           _sk6n::P64 = P64[R1 + 40];
           _sk6o::P64 = P64[R1 + 48];
           _sk6r::P64 = P64[R1 + 56];
           I64[Hp - 56] = sat_sk6V_info;
           P64[Hp - 40] = _sk6j::P64;
           P64[Hp - 32] = _sk6k::P64;
           P64[Hp - 24] = _sk6l::P64;
           P64[Hp - 16] = _sk6n::P64;
           P64[Hp - 8] = _sk6o::P64;
           P64[Hp] = _sk6r::P64;
           R3 = Hp - 56;
           R2 = lvl8_rjV5_closure;
           call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sk6X_entry() //  [R1]
         { info_tbl: [(clat,
                       label: sat_sk6X_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       clat:
           _sk6X::P64 = R1;
           if ((Sp + -16) < SpLim) goto clau; else goto clav;
       clav:
           Hp = Hp + 64;
           if (Hp > HpLim) goto clax; else goto claw;
       clax:
           HpAlloc = 64;
           goto clau;
       clau:
           R1 = _sk6X::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       claw:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sk6X::P64;
           _sk6j::P64 = P64[_sk6X::P64 + 16];
           _sk6k::P64 = P64[_sk6X::P64 + 24];
           _sk6l::P64 = P64[_sk6X::P64 + 32];
           _sk6n::P64 = P64[_sk6X::P64 + 40];
           _sk6o::P64 = P64[_sk6X::P64 + 48];
           _sk6r::P64 = P64[_sk6X::P64 + 56];
           I64[Hp - 56] = sat_sk6W_info;
           P64[Hp - 40] = _sk6j::P64;
           P64[Hp - 32] = _sk6k::P64;
           P64[Hp - 24] = _sk6l::P64;
           P64[Hp - 16] = _sk6n::P64;
           P64[Hp - 8] = _sk6o::P64;
           P64[Hp] = _sk6r::P64;
           R3 = Hp - 56;
           R2 = lvl3_rjV0_closure;
           Sp = Sp - 16;
           call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sk71_entry() //  [R1]
         { info_tbl: [(cl7k,
                       label: block_cl7k_info
                       rep:StackRep [False, False, False, False, False, False]),
                      (clay,
                       label: sat_sk71_info
                       rep:HeapRep 7 ptrs { Thunk }),
                      (claz,
                       label: block_claz_info
                       rep:StackRep [])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       clay:
           _sk71::P64 = R1;
           if ((Sp + -56) < SpLim) goto claC; else goto claD;
       claD:
           if (HpLim == 0) goto claC; else goto claE;
       claC:
           R1 = _sk71::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       claE:
           I64[Sp - 56] = cl7k;
           R1 = P64[_sk71::P64 + 16];
           P64[Sp - 48] = P64[_sk71::P64 + 24];
           P64[Sp - 40] = P64[_sk71::P64 + 32];
           P64[Sp - 32] = P64[_sk71::P64 + 40];
           P64[Sp - 24] = P64[_sk71::P64 + 48];
           P64[Sp - 16] = P64[_sk71::P64 + 56];
           P64[Sp - 8] = P64[_sk71::P64 + 64];
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto cl7k; else goto cl7l;
       cl7l:
           call (I64[R1])(R1) returns to cl7k, args: 8, res: 8, upd: 8;
       cl7k:
           Hp = Hp + 64;
           if (Hp > HpLim) goto claH; else goto claG;
       claH:
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to cl7k, args: 8, res: 8, upd: 8;
       claG:
           _sk6v::I64 = I64[R1 + 7];
           I64[Hp - 56] = sat_sk6X_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = P64[Sp + 48];
           I64[Sp + 48] = claz;
           R4 = Hp - 56;
           R3 = _sk6v::I64;
           R2 = 0;
           Sp = Sp + 48;
           call GHC.Show.$wshowSignedInt_info(R4,
                                              R3,
                                              R2) returns to claz, args: 8, res: 8, upd: 8;
       claz:
           Hp = Hp + 24;
           if (Hp > HpLim) goto claK; else goto claJ;
       claK:
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) returns to claz, args: 8, res: 8, upd: 8;
       claJ:
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sk72_entry() //  [R1]
         { info_tbl: [(claL,
                       label: sat_sk72_info
                       rep:HeapRep 7 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       claL:
           Hp = Hp + 72;
           if (Hp > HpLim) goto claP; else goto claO;
       claP:
           HpAlloc = 72;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       claO:
           _sk6i::P64 = P64[R1 + 16];
           _sk6j::P64 = P64[R1 + 24];
           _sk6k::P64 = P64[R1 + 32];
           _sk6l::P64 = P64[R1 + 40];
           _sk6n::P64 = P64[R1 + 48];
           _sk6o::P64 = P64[R1 + 56];
           _sk6r::P64 = P64[R1 + 64];
           I64[Hp - 64] = sat_sk71_info;
           P64[Hp - 48] = _sk6i::P64;
           P64[Hp - 40] = _sk6j::P64;
           P64[Hp - 32] = _sk6k::P64;
           P64[Hp - 24] = _sk6l::P64;
           P64[Hp - 16] = _sk6n::P64;
           P64[Hp - 8] = _sk6o::P64;
           P64[Hp] = _sk6r::P64;
           R3 = Hp - 64;
           R2 = lvl9_rjV6_closure;
           call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sk73_entry() //  [R1]
         { info_tbl: [(claQ,
                       label: sat_sk73_info
                       rep:HeapRep 7 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       claQ:
           _sk73::P64 = R1;
           if ((Sp + -16) < SpLim) goto claR; else goto claS;
       claS:
           Hp = Hp + 72;
           if (Hp > HpLim) goto claU; else goto claT;
       claU:
           HpAlloc = 72;
           goto claR;
       claR:
           R1 = _sk73::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       claT:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sk73::P64;
           _sk6i::P64 = P64[_sk73::P64 + 16];
           _sk6j::P64 = P64[_sk73::P64 + 24];
           _sk6k::P64 = P64[_sk73::P64 + 32];
           _sk6l::P64 = P64[_sk73::P64 + 40];
           _sk6n::P64 = P64[_sk73::P64 + 48];
           _sk6o::P64 = P64[_sk73::P64 + 56];
           _sk6r::P64 = P64[_sk73::P64 + 64];
           I64[Hp - 64] = sat_sk72_info;
           P64[Hp - 48] = _sk6i::P64;
           P64[Hp - 40] = _sk6j::P64;
           P64[Hp - 32] = _sk6k::P64;
           P64[Hp - 24] = _sk6l::P64;
           P64[Hp - 16] = _sk6n::P64;
           P64[Hp - 8] = _sk6o::P64;
           P64[Hp] = _sk6r::P64;
           R3 = Hp - 64;
           R2 = lvl3_rjV0_closure;
           Sp = Sp - 16;
           call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sk77_entry() //  [R1]
         { info_tbl: [(cl73,
                       label: block_cl73_info
                       rep:StackRep [False, False, False, False, False, False, False]),
                      (claV,
                       label: sat_sk77_info
                       rep:HeapRep 8 ptrs { Thunk }),
                      (claW,
                       label: block_claW_info
                       rep:StackRep [])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       claV:
           _sk77::P64 = R1;
           if ((Sp + -64) < SpLim) goto claZ; else goto clb0;
       clb0:
           if (HpLim == 0) goto claZ; else goto clb1;
       claZ:
           R1 = _sk77::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       clb1:
           I64[Sp - 64] = cl73;
           R1 = P64[_sk77::P64 + 16];
           P64[Sp - 56] = P64[_sk77::P64 + 24];
           P64[Sp - 48] = P64[_sk77::P64 + 32];
           P64[Sp - 40] = P64[_sk77::P64 + 40];
           P64[Sp - 32] = P64[_sk77::P64 + 48];
           P64[Sp - 24] = P64[_sk77::P64 + 56];
           P64[Sp - 16] = P64[_sk77::P64 + 64];
           P64[Sp - 8] = P64[_sk77::P64 + 72];
           Sp = Sp - 64;
           if (R1 & 7 != 0) goto cl73; else goto cl74;
       cl74:
           call (I64[R1])(R1) returns to cl73, args: 8, res: 8, upd: 8;
       cl73:
           Hp = Hp + 72;
           if (Hp > HpLim) goto clb4; else goto clb3;
       clb4:
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to cl73, args: 8, res: 8, upd: 8;
       clb3:
           _sk6t::I64 = I64[R1 + 7];
           I64[Hp - 64] = sat_sk73_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 32];
           P64[Hp - 16] = P64[Sp + 40];
           P64[Hp - 8] = P64[Sp + 48];
           P64[Hp] = P64[Sp + 56];
           I64[Sp + 56] = claW;
           R3 = Hp - 64;
           R2 = _sk6t::I64;
           Sp = Sp + 56;
           call GHC.Show.$wshowWord_info(R3,
                                         R2) returns to claW, args: 8, res: 8, upd: 8;
       claW:
           Hp = Hp + 24;
           if (Hp > HpLim) goto clb7; else goto clb6;
       clb7:
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) returns to claW, args: 8, res: 8, upd: 8;
       clb6:
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sk78_entry() //  [R1]
         { info_tbl: [(clb8,
                       label: sat_sk78_info
                       rep:HeapRep 8 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       clb8:
           Hp = Hp + 80;
           if (Hp > HpLim) goto clbc; else goto clbb;
       clbc:
           HpAlloc = 80;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       clbb:
           _sk6h::P64 = P64[R1 + 16];
           _sk6i::P64 = P64[R1 + 24];
           _sk6j::P64 = P64[R1 + 32];
           _sk6k::P64 = P64[R1 + 40];
           _sk6l::P64 = P64[R1 + 48];
           _sk6n::P64 = P64[R1 + 56];
           _sk6o::P64 = P64[R1 + 64];
           _sk6r::P64 = P64[R1 + 72];
           I64[Hp - 72] = sat_sk77_info;
           P64[Hp - 56] = _sk6h::P64;
           P64[Hp - 48] = _sk6i::P64;
           P64[Hp - 40] = _sk6j::P64;
           P64[Hp - 32] = _sk6k::P64;
           P64[Hp - 24] = _sk6l::P64;
           P64[Hp - 16] = _sk6n::P64;
           P64[Hp - 8] = _sk6o::P64;
           P64[Hp] = _sk6r::P64;
           R3 = Hp - 72;
           R2 = lvl10_rjV7_closure;
           call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sk79_entry() //  [R2, R1]
         { info_tbl: [(clbd,
                       label: sat_sk79_info
                       rep:HeapRep 7 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       clbd:
           Hp = Hp + 80;
           if (Hp > HpLim) goto clbh; else goto clbg;
       clbh:
           HpAlloc = 80;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       clbg:
           _sk6h::P64 = P64[R1 + 7];
           _sk6i::P64 = P64[R1 + 15];
           _sk6j::P64 = P64[R1 + 23];
           _sk6k::P64 = P64[R1 + 31];
           _sk6l::P64 = P64[R1 + 39];
           _sk6n::P64 = P64[R1 + 47];
           _sk6o::P64 = P64[R1 + 55];
           I64[Hp - 72] = sat_sk78_info;
           P64[Hp - 56] = _sk6h::P64;
           P64[Hp - 48] = _sk6i::P64;
           P64[Hp - 40] = _sk6j::P64;
           P64[Hp - 32] = _sk6k::P64;
           P64[Hp - 24] = _sk6l::P64;
           P64[Hp - 16] = _sk6n::P64;
           P64[Hp - 8] = _sk6o::P64;
           P64[Hp] = R2;
           R3 = Hp - 72;
           R2 = lvl11_rjV8_closure;
           call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 Main.$w$cshowsPrec_entry() //  [R6, R5, R4, R3, R2]
         { info_tbl: [(clbi,
                       label: Main.$w$cshowsPrec_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 24 updfr_space: Just 8
         }
     {offset
       clbi:
           Hp = Hp + 88;
           if (Hp > HpLim) goto clbm; else goto clbl;
       clbm:
           HpAlloc = 88;
           R1 = Main.$w$cshowsPrec_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       clbl:
           I64[Hp - 80] = f_sk6o_info;
           P64[Hp - 64] = P64[Sp];
           I64[Hp - 56] = sat_sk79_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           P64[Hp - 16] = R6;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = Hp - 80;
           R1 = Hp - 55;
           Sp = Sp + 16;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:55.6859 UTC

[section "data" {
     Main.$w$cshowsPrec_closure:
         const Main.$w$cshowsPrec_info;
         const 0;
 },
 Main.$w$cshowsPrec_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 64 updfr_space: Just 8
         }
     {offset
       cl5T:
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Main.$w$cshowsPrec_info(R6,
                                        R5,
                                        R4,
                                        R3,
                                        R2,
                                        R1) args: 24, res: 0, upd: 8;
     }
 },
 f_sk6o_entry() //  [R1]
         { info_tbl: [(cl6G,
                       label: block_cl6G_info
                       rep:StackRep []),
                      (cl6J,
                       label: f_sk6o_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cl6J:
           _sk6o::P64 = R1;
           if ((Sp + -24) < SpLim) goto cl6K; else goto cl6L;
       cl6L:
           if (HpLim == 0) goto cl6K; else goto cl6M;
       cl6K:
           R1 = _sk6o::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cl6M:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sk6o::P64;
           I64[Sp - 24] = cl6G;
           R1 = P64[_sk6o::P64 + 16];
           Sp = Sp - 24;
           if (R1 & 7 != 0) goto cl6G; else goto cl6H;
       cl6H:
           call (I64[R1])(R1) returns to cl6G, args: 8, res: 8, upd: 24;
       cl6G:
           D1 = F64[R1 + 7];
           R3 = lvl4_rjV1_closure+1;
           R2 = GHC.Float.$fShowDouble_$sshowFloat_closure+1;
           Sp = Sp + 8;
           call GHC.Float.$w$sshowSignedFloat_info(D1,
                                                   R3,
                                                   R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sk6C_entry() //  [R1]
         { info_tbl: [(cl8B,
                       label: sat_sk6C_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cl8B:
           _sk6C::P64 = R1;
           if ((Sp + -16) < SpLim) goto cl8C; else goto cl8D;
       cl8D:
           if (HpLim == 0) goto cl8C; else goto cl8E;
       cl8C:
           R1 = _sk6C::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cl8E:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sk6C::P64;
           R3 = P64[_sk6C::P64 + 16];
           R2 = lvl1_rjUY_closure;
           Sp = Sp - 16;
           call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sk6G_entry() //  [R1]
         { info_tbl: [(cl8s,
                       label: block_cl8s_info
                       rep:StackRep [False]),
                      (cl8F,
                       label: sat_sk6G_info
                       rep:HeapRep 2 ptrs { Thunk }),
                      (cl8G,
                       label: block_cl8G_info
                       rep:StackRep [])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cl8F:
           _sk6G::P64 = R1;
           if ((Sp + -16) < SpLim) goto cl8J; else goto cl8K;
       cl8K:
           if (HpLim == 0) goto cl8J; else goto cl8L;
       cl8J:
           R1 = _sk6G::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cl8L:
           I64[Sp - 16] = cl8s;
           R1 = P64[_sk6G::P64 + 16];
           P64[Sp - 8] = P64[_sk6G::P64 + 24];
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto cl8s; else goto cl8t;
       cl8t:
           call (I64[R1])(R1) returns to cl8s, args: 8, res: 8, upd: 8;
       cl8s:
           Hp = Hp + 24;
           if (Hp > HpLim) goto cl8O; else goto cl8N;
       cl8O:
           HpAlloc = 24;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to cl8s, args: 8, res: 8, upd: 8;
       cl8N:
           _sk6B::I64 = I64[R1 + 7];
           I64[Hp - 16] = sat_sk6C_info;
           P64[Hp] = P64[Sp + 8];
           I64[Sp + 8] = cl8G;
           R4 = Hp - 16;
           R3 = _sk6B::I64;
           R2 = 0;
           Sp = Sp + 8;
           call GHC.Show.$wshowSignedInt_info(R4,
                                              R3,
                                              R2) returns to cl8G, args: 8, res: 8, upd: 8;
       cl8G:
           Hp = Hp + 24;
           if (Hp > HpLim) goto cl8R; else goto cl8Q;
       cl8R:
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) returns to cl8G, args: 8, res: 8, upd: 8;
       cl8Q:
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sk6H_entry() //  [R1]
         { info_tbl: [(cl8S,
                       label: sat_sk6H_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cl8S:
           Hp = Hp + 32;
           if (Hp > HpLim) goto cl8W; else goto cl8V;
       cl8W:
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cl8V:
           _sk6n::P64 = P64[R1 + 16];
           _sk6r::P64 = P64[R1 + 24];
           I64[Hp - 24] = sat_sk6G_info;
           P64[Hp - 8] = _sk6n::P64;
           P64[Hp] = _sk6r::P64;
           R3 = Hp - 24;
           R2 = lvl2_rjUZ_closure;
           call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sk6I_entry() //  [R1]
         { info_tbl: [(cl8X,
                       label: sat_sk6I_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cl8X:
           _sk6I::P64 = R1;
           if ((Sp + -16) < SpLim) goto cl8Y; else goto cl8Z;
       cl8Z:
           Hp = Hp + 32;
           if (Hp > HpLim) goto cl91; else goto cl90;
       cl91:
           HpAlloc = 32;
           goto cl8Y;
       cl8Y:
           R1 = _sk6I::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cl90:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sk6I::P64;
           _sk6n::P64 = P64[_sk6I::P64 + 16];
           _sk6r::P64 = P64[_sk6I::P64 + 24];
           I64[Hp - 24] = sat_sk6H_info;
           P64[Hp - 8] = _sk6n::P64;
           P64[Hp] = _sk6r::P64;
           R3 = Hp - 24;
           R2 = lvl3_rjV0_closure;
           Sp = Sp - 16;
           call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sk6J_entry() //  [R1]
         { info_tbl: [(cl92,
                       label: sat_sk6J_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cl92:
           Hp = Hp + 32;
           if (Hp > HpLim) goto cl96; else goto cl95;
       cl96:
           HpAlloc = 32;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cl95:
           _sk6n::P64 = P64[R1 + 16];
           _sk6o::P64 = P64[R1 + 24];
           _sk6r::P64 = P64[R1 + 32];
           I64[Hp - 24] = sat_sk6I_info;
           P64[Hp - 8] = _sk6n::P64;
           P64[Hp] = _sk6r::P64;
           R2 = Hp - 24;
           R1 = _sk6o::P64;
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sk6K_entry() //  [R1]
         { info_tbl: [(cl97,
                       label: sat_sk6K_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cl97:
           Hp = Hp + 40;
           if (Hp > HpLim) goto cl9b; else goto cl9a;
       cl9b:
           HpAlloc = 40;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cl9a:
           _sk6n::P64 = P64[R1 + 16];
           _sk6o::P64 = P64[R1 + 24];
           _sk6r::P64 = P64[R1 + 32];
           I64[Hp - 32] = sat_sk6J_info;
           P64[Hp - 16] = _sk6n::P64;
           P64[Hp - 8] = _sk6o::P64;
           P64[Hp] = _sk6r::P64;
           R3 = Hp - 32;
           R2 = lvl5_rjV2_closure;
           call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sk6L_entry() //  [R1]
         { info_tbl: [(cl9c,
                       label: sat_sk6L_info
                       rep:HeapRep 3 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cl9c:
           _sk6L::P64 = R1;
           if ((Sp + -16) < SpLim) goto cl9d; else goto cl9e;
       cl9e:
           Hp = Hp + 40;
           if (Hp > HpLim) goto cl9g; else goto cl9f;
       cl9g:
           HpAlloc = 40;
           goto cl9d;
       cl9d:
           R1 = _sk6L::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cl9f:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sk6L::P64;
           _sk6n::P64 = P64[_sk6L::P64 + 16];
           _sk6o::P64 = P64[_sk6L::P64 + 24];
           _sk6r::P64 = P64[_sk6L::P64 + 32];
           I64[Hp - 32] = sat_sk6K_info;
           P64[Hp - 16] = _sk6n::P64;
           P64[Hp - 8] = _sk6o::P64;
           P64[Hp] = _sk6r::P64;
           R3 = Hp - 32;
           R2 = lvl3_rjV0_closure;
           Sp = Sp - 16;
           call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sk6P_entry() //  [R1]
         { info_tbl: [(cl7Z,
                       label: block_cl7Z_info
                       rep:StackRep [False, False, False]),
                      (cl9h,
                       label: sat_sk6P_info
                       rep:HeapRep 4 ptrs { Thunk }),
                      (cl9i,
                       label: block_cl9i_info
                       rep:StackRep [])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cl9h:
           _sk6P::P64 = R1;
           if ((Sp + -32) < SpLim) goto cl9l; else goto cl9m;
       cl9m:
           if (HpLim == 0) goto cl9l; else goto cl9n;
       cl9l:
           R1 = _sk6P::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cl9n:
           I64[Sp - 32] = cl7Z;
           R1 = P64[_sk6P::P64 + 16];
           P64[Sp - 24] = P64[_sk6P::P64 + 24];
           P64[Sp - 16] = P64[_sk6P::P64 + 32];
           P64[Sp - 8] = P64[_sk6P::P64 + 40];
           Sp = Sp - 32;
           if (R1 & 7 != 0) goto cl7Z; else goto cl80;
       cl80:
           call (I64[R1])(R1) returns to cl7Z, args: 8, res: 8, upd: 8;
       cl7Z:
           Hp = Hp + 40;
           if (Hp > HpLim) goto cl9q; else goto cl9p;
       cl9q:
           HpAlloc = 40;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to cl7Z, args: 8, res: 8, upd: 8;
       cl9p:
           _sk6z::I64 = I64[R1 + 7];
           I64[Hp - 32] = sat_sk6L_info;
           P64[Hp - 16] = P64[Sp + 8];
           P64[Hp - 8] = P64[Sp + 16];
           P64[Hp] = P64[Sp + 24];
           I64[Sp + 24] = cl9i;
           R4 = Hp - 32;
           R3 = _sk6z::I64;
           R2 = 0;
           Sp = Sp + 24;
           call GHC.Show.$wshowSignedInt_info(R4,
                                              R3,
                                              R2) returns to cl9i, args: 8, res: 8, upd: 8;
       cl9i:
           Hp = Hp + 24;
           if (Hp > HpLim) goto cl9t; else goto cl9s;
       cl9t:
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) returns to cl9i, args: 8, res: 8, upd: 8;
       cl9s:
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sk6Q_entry() //  [R1]
         { info_tbl: [(cl9u,
                       label: sat_sk6Q_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cl9u:
           Hp = Hp + 48;
           if (Hp > HpLim) goto cl9y; else goto cl9x;
       cl9y:
           HpAlloc = 48;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cl9x:
           _sk6l::P64 = P64[R1 + 16];
           _sk6n::P64 = P64[R1 + 24];
           _sk6o::P64 = P64[R1 + 32];
           _sk6r::P64 = P64[R1 + 40];
           I64[Hp - 40] = sat_sk6P_info;
           P64[Hp - 24] = _sk6l::P64;
           P64[Hp - 16] = _sk6n::P64;
           P64[Hp - 8] = _sk6o::P64;
           P64[Hp] = _sk6r::P64;
           R3 = Hp - 40;
           R2 = lvl6_rjV3_closure;
           call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 eta1_sk6x_entry() //  [R1]
         { info_tbl: [(cl9z,
                       label: eta1_sk6x_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cl9z:
           _sk6x::P64 = R1;
           if ((Sp + -16) < SpLim) goto cl9A; else goto cl9B;
       cl9B:
           Hp = Hp + 48;
           if (Hp > HpLim) goto cl9D; else goto cl9C;
       cl9D:
           HpAlloc = 48;
           goto cl9A;
       cl9A:
           R1 = _sk6x::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cl9C:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sk6x::P64;
           _sk6l::P64 = P64[_sk6x::P64 + 16];
           _sk6n::P64 = P64[_sk6x::P64 + 24];
           _sk6o::P64 = P64[_sk6x::P64 + 32];
           _sk6r::P64 = P64[_sk6x::P64 + 40];
           I64[Hp - 40] = sat_sk6Q_info;
           P64[Hp - 24] = _sk6l::P64;
           P64[Hp - 16] = _sk6n::P64;
           P64[Hp - 8] = _sk6o::P64;
           P64[Hp] = _sk6r::P64;
           R3 = Hp - 40;
           R2 = lvl3_rjV0_closure;
           Sp = Sp - 16;
           call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sk6S_entry() //  [R1]
         { info_tbl: [(cl9E,
                       label: block_cl9E_info
                       rep:StackRep [False]),
                      (cl9L,
                       label: sat_sk6S_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cl9L:
           _sk6S::P64 = R1;
           if ((Sp + -16) < SpLim) goto cl9M; else goto cl9N;
       cl9N:
           Hp = Hp + 48;
           if (Hp > HpLim) goto cl9P; else goto cl9O;
       cl9P:
           HpAlloc = 48;
           goto cl9M;
       cl9M:
           R1 = _sk6S::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cl9O:
           _sk6k::P64 = P64[_sk6S::P64 + 16];
           _sk6l::P64 = P64[_sk6S::P64 + 24];
           _sk6n::P64 = P64[_sk6S::P64 + 32];
           _sk6o::P64 = P64[_sk6S::P64 + 40];
           _sk6r::P64 = P64[_sk6S::P64 + 48];
           I64[Hp - 40] = eta1_sk6x_info;
           P64[Hp - 24] = _sk6l::P64;
           P64[Hp - 16] = _sk6n::P64;
           P64[Hp - 8] = _sk6o::P64;
           P64[Hp] = _sk6r::P64;
           I64[Sp - 16] = cl9E;
           R1 = _sk6k::P64;
           P64[Sp - 8] = Hp - 40;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto cl9E; else goto cl9F;
       cl9F:
           call (I64[R1])(R1) returns to cl9E, args: 8, res: 8, upd: 8;
       cl9E:
           _cl7N::P64 = P64[Sp + 8];
           if (R1 & 7 != 1) goto cl9J; else goto cl9I;
       cl9J:
           R3 = _cl7N::P64;
           R2 = GHC.Show.shows16_closure;
           Sp = Sp + 16;
           call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
       cl9I:
           R3 = _cl7N::P64;
           R2 = GHC.Show.shows17_closure;
           Sp = Sp + 16;
           call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sk6T_entry() //  [R1]
         { info_tbl: [(cl9W,
                       label: sat_sk6T_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cl9W:
           Hp = Hp + 56;
           if (Hp > HpLim) goto cla0; else goto cl9Z;
       cla0:
           HpAlloc = 56;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cl9Z:
           _sk6k::P64 = P64[R1 + 16];
           _sk6l::P64 = P64[R1 + 24];
           _sk6n::P64 = P64[R1 + 32];
           _sk6o::P64 = P64[R1 + 40];
           _sk6r::P64 = P64[R1 + 48];
           I64[Hp - 48] = sat_sk6S_info;
           P64[Hp - 32] = _sk6k::P64;
           P64[Hp - 24] = _sk6l::P64;
           P64[Hp - 16] = _sk6n::P64;
           P64[Hp - 8] = _sk6o::P64;
           P64[Hp] = _sk6r::P64;
           R3 = Hp - 48;
           R2 = lvl7_rjV4_closure;
           call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 eta_sk6w_entry() //  [R1]
         { info_tbl: [(cla1,
                       label: eta_sk6w_info
                       rep:HeapRep 5 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cla1:
           _sk6w::P64 = R1;
           if ((Sp + -16) < SpLim) goto cla2; else goto cla3;
       cla3:
           Hp = Hp + 56;
           if (Hp > HpLim) goto cla5; else goto cla4;
       cla5:
           HpAlloc = 56;
           goto cla2;
       cla2:
           R1 = _sk6w::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       cla4:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sk6w::P64;
           _sk6k::P64 = P64[_sk6w::P64 + 16];
           _sk6l::P64 = P64[_sk6w::P64 + 24];
           _sk6n::P64 = P64[_sk6w::P64 + 32];
           _sk6o::P64 = P64[_sk6w::P64 + 40];
           _sk6r::P64 = P64[_sk6w::P64 + 48];
           I64[Hp - 48] = sat_sk6T_info;
           P64[Hp - 32] = _sk6k::P64;
           P64[Hp - 24] = _sk6l::P64;
           P64[Hp - 16] = _sk6n::P64;
           P64[Hp - 8] = _sk6o::P64;
           P64[Hp] = _sk6r::P64;
           R3 = Hp - 48;
           R2 = lvl3_rjV0_closure;
           Sp = Sp - 16;
           call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sk6V_entry() //  [R1]
         { info_tbl: [(cla6,
                       label: block_cla6_info
                       rep:StackRep [False]),
                      (clad,
                       label: sat_sk6V_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       clad:
           _sk6V::P64 = R1;
           if ((Sp + -16) < SpLim) goto clae; else goto claf;
       claf:
           Hp = Hp + 56;
           if (Hp > HpLim) goto clah; else goto clag;
       clah:
           HpAlloc = 56;
           goto clae;
       clae:
           R1 = _sk6V::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       clag:
           _sk6j::P64 = P64[_sk6V::P64 + 16];
           _sk6k::P64 = P64[_sk6V::P64 + 24];
           _sk6l::P64 = P64[_sk6V::P64 + 32];
           _sk6n::P64 = P64[_sk6V::P64 + 40];
           _sk6o::P64 = P64[_sk6V::P64 + 48];
           _sk6r::P64 = P64[_sk6V::P64 + 56];
           I64[Hp - 48] = eta_sk6w_info;
           P64[Hp - 32] = _sk6k::P64;
           P64[Hp - 24] = _sk6l::P64;
           P64[Hp - 16] = _sk6n::P64;
           P64[Hp - 8] = _sk6o::P64;
           P64[Hp] = _sk6r::P64;
           I64[Sp - 16] = cla6;
           R1 = _sk6j::P64;
           P64[Sp - 8] = Hp - 48;
           Sp = Sp - 16;
           if (R1 & 7 != 0) goto cla6; else goto cla7;
       cla7:
           call (I64[R1])(R1) returns to cla6, args: 8, res: 8, upd: 8;
       cla6:
           _cl7B::P64 = P64[Sp + 8];
           if (R1 & 7 != 1) goto clab; else goto claa;
       clab:
           R3 = _cl7B::P64;
           R2 = GHC.Show.shows16_closure;
           Sp = Sp + 16;
           call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
       claa:
           R3 = _cl7B::P64;
           R2 = GHC.Show.shows17_closure;
           Sp = Sp + 16;
           call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sk6W_entry() //  [R1]
         { info_tbl: [(clao,
                       label: sat_sk6W_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       clao:
           Hp = Hp + 64;
           if (Hp > HpLim) goto clas; else goto clar;
       clas:
           HpAlloc = 64;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       clar:
           _sk6j::P64 = P64[R1 + 16];
           _sk6k::P64 = P64[R1 + 24];
           _sk6l::P64 = P64[R1 + 32];
           _sk6n::P64 = P64[R1 + 40];
           _sk6o::P64 = P64[R1 + 48];
           _sk6r::P64 = P64[R1 + 56];
           I64[Hp - 56] = sat_sk6V_info;
           P64[Hp - 40] = _sk6j::P64;
           P64[Hp - 32] = _sk6k::P64;
           P64[Hp - 24] = _sk6l::P64;
           P64[Hp - 16] = _sk6n::P64;
           P64[Hp - 8] = _sk6o::P64;
           P64[Hp] = _sk6r::P64;
           R3 = Hp - 56;
           R2 = lvl8_rjV5_closure;
           call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sk6X_entry() //  [R1]
         { info_tbl: [(clat,
                       label: sat_sk6X_info
                       rep:HeapRep 6 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       clat:
           _sk6X::P64 = R1;
           if ((Sp + -16) < SpLim) goto clau; else goto clav;
       clav:
           Hp = Hp + 64;
           if (Hp > HpLim) goto clax; else goto claw;
       clax:
           HpAlloc = 64;
           goto clau;
       clau:
           R1 = _sk6X::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       claw:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sk6X::P64;
           _sk6j::P64 = P64[_sk6X::P64 + 16];
           _sk6k::P64 = P64[_sk6X::P64 + 24];
           _sk6l::P64 = P64[_sk6X::P64 + 32];
           _sk6n::P64 = P64[_sk6X::P64 + 40];
           _sk6o::P64 = P64[_sk6X::P64 + 48];
           _sk6r::P64 = P64[_sk6X::P64 + 56];
           I64[Hp - 56] = sat_sk6W_info;
           P64[Hp - 40] = _sk6j::P64;
           P64[Hp - 32] = _sk6k::P64;
           P64[Hp - 24] = _sk6l::P64;
           P64[Hp - 16] = _sk6n::P64;
           P64[Hp - 8] = _sk6o::P64;
           P64[Hp] = _sk6r::P64;
           R3 = Hp - 56;
           R2 = lvl3_rjV0_closure;
           Sp = Sp - 16;
           call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sk71_entry() //  [R1]
         { info_tbl: [(cl7k,
                       label: block_cl7k_info
                       rep:StackRep [False, False, False, False, False, False]),
                      (clay,
                       label: sat_sk71_info
                       rep:HeapRep 7 ptrs { Thunk }),
                      (claz,
                       label: block_claz_info
                       rep:StackRep [])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       clay:
           _sk71::P64 = R1;
           if ((Sp + -56) < SpLim) goto claC; else goto claD;
       claD:
           if (HpLim == 0) goto claC; else goto claE;
       claC:
           R1 = _sk71::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       claE:
           I64[Sp - 56] = cl7k;
           R1 = P64[_sk71::P64 + 16];
           P64[Sp - 48] = P64[_sk71::P64 + 24];
           P64[Sp - 40] = P64[_sk71::P64 + 32];
           P64[Sp - 32] = P64[_sk71::P64 + 40];
           P64[Sp - 24] = P64[_sk71::P64 + 48];
           P64[Sp - 16] = P64[_sk71::P64 + 56];
           P64[Sp - 8] = P64[_sk71::P64 + 64];
           Sp = Sp - 56;
           if (R1 & 7 != 0) goto cl7k; else goto cl7l;
       cl7l:
           call (I64[R1])(R1) returns to cl7k, args: 8, res: 8, upd: 8;
       cl7k:
           Hp = Hp + 64;
           if (Hp > HpLim) goto claH; else goto claG;
       claH:
           HpAlloc = 64;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to cl7k, args: 8, res: 8, upd: 8;
       claG:
           _sk6v::I64 = I64[R1 + 7];
           I64[Hp - 56] = sat_sk6X_info;
           P64[Hp - 40] = P64[Sp + 8];
           P64[Hp - 32] = P64[Sp + 16];
           P64[Hp - 24] = P64[Sp + 24];
           P64[Hp - 16] = P64[Sp + 32];
           P64[Hp - 8] = P64[Sp + 40];
           P64[Hp] = P64[Sp + 48];
           I64[Sp + 48] = claz;
           R4 = Hp - 56;
           R3 = _sk6v::I64;
           R2 = 0;
           Sp = Sp + 48;
           call GHC.Show.$wshowSignedInt_info(R4,
                                              R3,
                                              R2) returns to claz, args: 8, res: 8, upd: 8;
       claz:
           Hp = Hp + 24;
           if (Hp > HpLim) goto claK; else goto claJ;
       claK:
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) returns to claz, args: 8, res: 8, upd: 8;
       claJ:
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sk72_entry() //  [R1]
         { info_tbl: [(claL,
                       label: sat_sk72_info
                       rep:HeapRep 7 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       claL:
           Hp = Hp + 72;
           if (Hp > HpLim) goto claP; else goto claO;
       claP:
           HpAlloc = 72;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       claO:
           _sk6i::P64 = P64[R1 + 16];
           _sk6j::P64 = P64[R1 + 24];
           _sk6k::P64 = P64[R1 + 32];
           _sk6l::P64 = P64[R1 + 40];
           _sk6n::P64 = P64[R1 + 48];
           _sk6o::P64 = P64[R1 + 56];
           _sk6r::P64 = P64[R1 + 64];
           I64[Hp - 64] = sat_sk71_info;
           P64[Hp - 48] = _sk6i::P64;
           P64[Hp - 40] = _sk6j::P64;
           P64[Hp - 32] = _sk6k::P64;
           P64[Hp - 24] = _sk6l::P64;
           P64[Hp - 16] = _sk6n::P64;
           P64[Hp - 8] = _sk6o::P64;
           P64[Hp] = _sk6r::P64;
           R3 = Hp - 64;
           R2 = lvl9_rjV6_closure;
           call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sk73_entry() //  [R1]
         { info_tbl: [(claQ,
                       label: sat_sk73_info
                       rep:HeapRep 7 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       claQ:
           _sk73::P64 = R1;
           if ((Sp + -16) < SpLim) goto claR; else goto claS;
       claS:
           Hp = Hp + 72;
           if (Hp > HpLim) goto claU; else goto claT;
       claU:
           HpAlloc = 72;
           goto claR;
       claR:
           R1 = _sk73::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       claT:
           I64[Sp - 16] = stg_upd_frame_info;
           P64[Sp - 8] = _sk73::P64;
           _sk6i::P64 = P64[_sk73::P64 + 16];
           _sk6j::P64 = P64[_sk73::P64 + 24];
           _sk6k::P64 = P64[_sk73::P64 + 32];
           _sk6l::P64 = P64[_sk73::P64 + 40];
           _sk6n::P64 = P64[_sk73::P64 + 48];
           _sk6o::P64 = P64[_sk73::P64 + 56];
           _sk6r::P64 = P64[_sk73::P64 + 64];
           I64[Hp - 64] = sat_sk72_info;
           P64[Hp - 48] = _sk6i::P64;
           P64[Hp - 40] = _sk6j::P64;
           P64[Hp - 32] = _sk6k::P64;
           P64[Hp - 24] = _sk6l::P64;
           P64[Hp - 16] = _sk6n::P64;
           P64[Hp - 8] = _sk6o::P64;
           P64[Hp] = _sk6r::P64;
           R3 = Hp - 64;
           R2 = lvl3_rjV0_closure;
           Sp = Sp - 16;
           call GHC.Base.++_info(R3, R2) args: 24, res: 0, upd: 24;
     }
 },
 sat_sk77_entry() //  [R1]
         { info_tbl: [(cl73,
                       label: block_cl73_info
                       rep:StackRep [False, False, False, False, False, False, False]),
                      (claV,
                       label: sat_sk77_info
                       rep:HeapRep 8 ptrs { Thunk }),
                      (claW,
                       label: block_claW_info
                       rep:StackRep [])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       claV:
           _sk77::P64 = R1;
           if ((Sp + -64) < SpLim) goto claZ; else goto clb0;
       clb0:
           if (HpLim == 0) goto claZ; else goto clb1;
       claZ:
           R1 = _sk77::P64;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       clb1:
           I64[Sp - 64] = cl73;
           R1 = P64[_sk77::P64 + 16];
           P64[Sp - 56] = P64[_sk77::P64 + 24];
           P64[Sp - 48] = P64[_sk77::P64 + 32];
           P64[Sp - 40] = P64[_sk77::P64 + 40];
           P64[Sp - 32] = P64[_sk77::P64 + 48];
           P64[Sp - 24] = P64[_sk77::P64 + 56];
           P64[Sp - 16] = P64[_sk77::P64 + 64];
           P64[Sp - 8] = P64[_sk77::P64 + 72];
           Sp = Sp - 64;
           if (R1 & 7 != 0) goto cl73; else goto cl74;
       cl74:
           call (I64[R1])(R1) returns to cl73, args: 8, res: 8, upd: 8;
       cl73:
           Hp = Hp + 72;
           if (Hp > HpLim) goto clb4; else goto clb3;
       clb4:
           HpAlloc = 72;
           R1 = R1;
           call stg_gc_unpt_r1(R1) returns to cl73, args: 8, res: 8, upd: 8;
       clb3:
           _sk6t::I64 = I64[R1 + 7];
           I64[Hp - 64] = sat_sk73_info;
           P64[Hp - 48] = P64[Sp + 8];
           P64[Hp - 40] = P64[Sp + 16];
           P64[Hp - 32] = P64[Sp + 24];
           P64[Hp - 24] = P64[Sp + 32];
           P64[Hp - 16] = P64[Sp + 40];
           P64[Hp - 8] = P64[Sp + 48];
           P64[Hp] = P64[Sp + 56];
           I64[Sp + 56] = claW;
           R3 = Hp - 64;
           R2 = _sk6t::I64;
           Sp = Sp + 56;
           call GHC.Show.$wshowWord_info(R3,
                                         R2) returns to claW, args: 8, res: 8, upd: 8;
       claW:
           Hp = Hp + 24;
           if (Hp > HpLim) goto clb7; else goto clb6;
       clb7:
           HpAlloc = 24;
           R2 = R2;
           R1 = R1;
           call stg_gc_pp(R2, R1) returns to claW, args: 8, res: 8, upd: 8;
       clb6:
           I64[Hp - 16] = :_con_info;
           P64[Hp - 8] = R1;
           P64[Hp] = R2;
           R1 = Hp - 14;
           Sp = Sp + 8;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 },
 sat_sk78_entry() //  [R1]
         { info_tbl: [(clb8,
                       label: sat_sk78_info
                       rep:HeapRep 8 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       clb8:
           Hp = Hp + 80;
           if (Hp > HpLim) goto clbc; else goto clbb;
       clbc:
           HpAlloc = 80;
           R1 = R1;
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;
       clbb:
           _sk6h::P64 = P64[R1 + 16];
           _sk6i::P64 = P64[R1 + 24];
           _sk6j::P64 = P64[R1 + 32];
           _sk6k::P64 = P64[R1 + 40];
           _sk6l::P64 = P64[R1 + 48];
           _sk6n::P64 = P64[R1 + 56];
           _sk6o::P64 = P64[R1 + 64];
           _sk6r::P64 = P64[R1 + 72];
           I64[Hp - 72] = sat_sk77_info;
           P64[Hp - 56] = _sk6h::P64;
           P64[Hp - 48] = _sk6i::P64;
           P64[Hp - 40] = _sk6j::P64;
           P64[Hp - 32] = _sk6k::P64;
           P64[Hp - 24] = _sk6l::P64;
           P64[Hp - 16] = _sk6n::P64;
           P64[Hp - 8] = _sk6o::P64;
           P64[Hp] = _sk6r::P64;
           R3 = Hp - 72;
           R2 = lvl10_rjV7_closure;
           call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 sat_sk79_entry() //  [R2, R1]
         { info_tbl: [(clbd,
                       label: sat_sk79_info
                       rep:HeapRep 7 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       clbd:
           Hp = Hp + 80;
           if (Hp > HpLim) goto clbh; else goto clbg;
       clbh:
           HpAlloc = 80;
           R2 = R2;
           R1 = R1;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       clbg:
           _sk6h::P64 = P64[R1 + 7];
           _sk6i::P64 = P64[R1 + 15];
           _sk6j::P64 = P64[R1 + 23];
           _sk6k::P64 = P64[R1 + 31];
           _sk6l::P64 = P64[R1 + 39];
           _sk6n::P64 = P64[R1 + 47];
           _sk6o::P64 = P64[R1 + 55];
           I64[Hp - 72] = sat_sk78_info;
           P64[Hp - 56] = _sk6h::P64;
           P64[Hp - 48] = _sk6i::P64;
           P64[Hp - 40] = _sk6j::P64;
           P64[Hp - 32] = _sk6k::P64;
           P64[Hp - 24] = _sk6l::P64;
           P64[Hp - 16] = _sk6n::P64;
           P64[Hp - 8] = _sk6o::P64;
           P64[Hp] = R2;
           R3 = Hp - 72;
           R2 = lvl11_rjV8_closure;
           call GHC.Base.++_info(R3, R2) args: 8, res: 0, upd: 8;
     }
 },
 Main.$w$cshowsPrec_entry() //  [R6, R5, R4, R3, R2]
         { info_tbl: [(clbi,
                       label: Main.$w$cshowsPrec_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 24 updfr_space: Just 8
         }
     {offset
       clbi:
           Hp = Hp + 88;
           if (Hp > HpLim) goto clbm; else goto clbl;
       clbm:
           HpAlloc = 88;
           R1 = Main.$w$cshowsPrec_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       clbl:
           I64[Hp - 80] = f_sk6o_info;
           P64[Hp - 64] = P64[Sp];
           I64[Hp - 56] = sat_sk79_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           P64[Hp - 16] = R6;
           P64[Hp - 8] = P64[Sp + 8];
           P64[Hp] = Hp - 80;
           R1 = Hp - 55;
           Sp = Sp + 16;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:55.794885 UTC

[section "data" {
     Main.$fShowRBTreeOpts_$cshowsPrec_closure:
         const Main.$fShowRBTreeOpts_$cshowsPrec_info;
         const 0;
 },
 Main.$fShowRBTreeOpts_$cshowsPrec_entry() //  [R3, R2]
         { info_tbl: [(cldi,
                       label: Main.$fShowRBTreeOpts_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cldi:
           _sk7b::P64 = R3;
           _sk7a::P64 = R2;
           goto cldd;
       cldd:
           if ((old + 0) - <highSp> < SpLim) goto cldj; else goto cldk;
       cldk:
           goto cldc;
       cldc:
           if (HpLim == 0) goto cldj; else goto cldl;
       cldj:
           R3 = _sk7b::P64;
           R2 = _sk7a::P64;
           R1 = Main.$fShowRBTreeOpts_$cshowsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cldl:
           I64[(young<cldf> + 8)] = cldf;
           R1 = _sk7b::P64;
           if (R1 & 7 != 0) goto cldf; else goto cldg;
       cldg:
           call (I64[R1])(R1) returns to cldf, args: 8, res: 8, upd: 8;
       cldf:
           _sk7c::P64 = R1;
           _sk7d::P64 = P64[_sk7c::P64 + 7];
           _sk7e::P64 = P64[_sk7c::P64 + 15];
           _sk7f::P64 = P64[_sk7c::P64 + 23];
           _sk7g::P64 = P64[_sk7c::P64 + 31];
           _sk7h::P64 = P64[_sk7c::P64 + 39];
           _sk7i::P64 = P64[_sk7c::P64 + 47];
           _sk7j::P64 = P64[_sk7c::P64 + 55];
           R6 = _sk7h::P64;
           R5 = _sk7g::P64;
           R4 = _sk7f::P64;
           R3 = _sk7e::P64;
           R2 = _sk7d::P64;
           P64[(old + 24)] = _sk7i::P64;
           P64[(old + 16)] = _sk7j::P64;
           call Main.$w$cshowsPrec_info(R6,
                                        R5,
                                        R4,
                                        R3,
                                        R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:55.798246 UTC

{offset
  cldi:
      _sk7b::P64 = R3;
      _sk7a::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cldj; else goto cldk;
  cldk:
      if (HpLim == 0) goto cldj; else goto cldl;
  cldj:
      R3 = _sk7b::P64;
      R2 = _sk7a::P64;
      R1 = Main.$fShowRBTreeOpts_$cshowsPrec_closure;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  cldl:
      I64[(young<cldf> + 8)] = cldf;
      R1 = _sk7b::P64;
      if (R1 & 7 != 0) goto cldf; else goto cldg;
  cldg:
      call (I64[R1])(R1) returns to cldf, args: 8, res: 8, upd: 8;
  cldf:
      _sk7c::P64 = R1;
      _sk7d::P64 = P64[_sk7c::P64 + 7];
      _sk7e::P64 = P64[_sk7c::P64 + 15];
      _sk7f::P64 = P64[_sk7c::P64 + 23];
      _sk7g::P64 = P64[_sk7c::P64 + 31];
      _sk7h::P64 = P64[_sk7c::P64 + 39];
      _sk7i::P64 = P64[_sk7c::P64 + 47];
      _sk7j::P64 = P64[_sk7c::P64 + 55];
      R6 = _sk7h::P64;
      R5 = _sk7g::P64;
      R4 = _sk7f::P64;
      R3 = _sk7e::P64;
      R2 = _sk7d::P64;
      P64[(old + 24)] = _sk7i::P64;
      P64[(old + 16)] = _sk7j::P64;
      call Main.$w$cshowsPrec_info(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 24, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:55.800132 UTC

{offset
  cldi:
      _sk7b::P64 = R3;
      _sk7a::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cldj; else goto cldk;
  cldk:
      if (HpLim == 0) goto cldj; else goto cldl;
  cldj:
      R3 = _sk7b::P64;
      R2 = _sk7a::P64;
      R1 = Main.$fShowRBTreeOpts_$cshowsPrec_closure;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  cldl:
      I64[(young<cldf> + 8)] = cldf;
      R1 = _sk7b::P64;
      if (R1 & 7 != 0) goto cldf; else goto cldg;
  cldg:
      call (I64[R1])(R1) returns to cldf, args: 8, res: 8, upd: 8;
  cldf:
      _sk7c::P64 = R1;
      _sk7d::P64 = P64[_sk7c::P64 + 7];
      _sk7e::P64 = P64[_sk7c::P64 + 15];
      _sk7f::P64 = P64[_sk7c::P64 + 23];
      _sk7g::P64 = P64[_sk7c::P64 + 31];
      _sk7h::P64 = P64[_sk7c::P64 + 39];
      _sk7i::P64 = P64[_sk7c::P64 + 47];
      _sk7j::P64 = P64[_sk7c::P64 + 55];
      R6 = _sk7h::P64;
      R5 = _sk7g::P64;
      R4 = _sk7f::P64;
      R3 = _sk7e::P64;
      R2 = _sk7d::P64;
      P64[(old + 24)] = _sk7i::P64;
      P64[(old + 16)] = _sk7j::P64;
      call Main.$w$cshowsPrec_info(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 24, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:55.802009 UTC

{offset
  cldi:
      _sk7b::P64 = R3;
      _sk7a::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cldj; else goto cldk;
  cldk:
      if (HpLim == 0) goto cldj; else goto cldl;
  cldj:
      R3 = _sk7b::P64;
      R2 = _sk7a::P64;
      R1 = Main.$fShowRBTreeOpts_$cshowsPrec_closure;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  cldl:
      I64[(young<cldf> + 8)] = cldf;
      R1 = _sk7b::P64;
      if (R1 & 7 != 0) goto cldf; else goto cldg;
  cldg:
      call (I64[R1])(R1) returns to cldf, args: 8, res: 8, upd: 8;
  cldf:
      _sk7c::P64 = R1;
      _sk7d::P64 = P64[_sk7c::P64 + 7];
      _sk7e::P64 = P64[_sk7c::P64 + 15];
      _sk7f::P64 = P64[_sk7c::P64 + 23];
      _sk7g::P64 = P64[_sk7c::P64 + 31];
      _sk7h::P64 = P64[_sk7c::P64 + 39];
      _sk7i::P64 = P64[_sk7c::P64 + 47];
      _sk7j::P64 = P64[_sk7c::P64 + 55];
      R6 = _sk7h::P64;
      R5 = _sk7g::P64;
      R4 = _sk7f::P64;
      R3 = _sk7e::P64;
      R2 = _sk7d::P64;
      P64[(old + 24)] = _sk7i::P64;
      P64[(old + 16)] = _sk7j::P64;
      call Main.$w$cshowsPrec_info(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 24, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:55.80406 UTC

{offset
  cldi:
      _sk7b::P64 = R3;
      _sk7a::P64 = R2;
      if ((Sp + 8) - 24 < SpLim) goto cldj; else goto cldk;
  cldk:
      if (HpLim == 0) goto cldj; else goto cldl;
  cldj:
      R3 = _sk7b::P64;
      R2 = _sk7a::P64;
      R1 = Main.$fShowRBTreeOpts_$cshowsPrec_closure;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  cldl:
      I64[Sp - 8] = cldf;
      R1 = _sk7b::P64;
      Sp = Sp - 8;
      if (R1 & 7 != 0) goto cldf; else goto cldg;
  cldg:
      call (I64[R1])(R1) returns to cldf, args: 8, res: 8, upd: 8;
  cldf:
      _sk7c::P64 = R1;
      _sk7d::P64 = P64[_sk7c::P64 + 7];
      _sk7e::P64 = P64[_sk7c::P64 + 15];
      _sk7f::P64 = P64[_sk7c::P64 + 23];
      _sk7g::P64 = P64[_sk7c::P64 + 31];
      _sk7h::P64 = P64[_sk7c::P64 + 39];
      _sk7i::P64 = P64[_sk7c::P64 + 47];
      _sk7j::P64 = P64[_sk7c::P64 + 55];
      R6 = _sk7h::P64;
      R5 = _sk7g::P64;
      R4 = _sk7f::P64;
      R3 = _sk7e::P64;
      R2 = _sk7d::P64;
      P64[Sp - 8] = _sk7i::P64;
      P64[Sp] = _sk7j::P64;
      Sp = Sp - 8;
      call Main.$w$cshowsPrec_info(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 24, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:55.806662 UTC

{offset
  cldi:
      _sk7b::P64 = R3;
      _sk7a::P64 = R2;
      if ((Sp + -16) < SpLim) goto cldj; else goto cldk;
  cldk:
      if (HpLim == 0) goto cldj; else goto cldl;
  cldj:
      R3 = _sk7b::P64;
      R2 = _sk7a::P64;
      R1 = Main.$fShowRBTreeOpts_$cshowsPrec_closure;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  cldl:
      I64[Sp - 8] = cldf;
      R1 = _sk7b::P64;
      Sp = Sp - 8;
      if (R1 & 7 != 0) goto cldf; else goto cldg;
  cldg:
      call (I64[R1])(R1) returns to cldf, args: 8, res: 8, upd: 8;
  cldf:
      R6 = P64[R1 + 39];
      R5 = P64[R1 + 31];
      R4 = P64[R1 + 23];
      R3 = P64[R1 + 15];
      R2 = P64[R1 + 7];
      P64[Sp - 8] = P64[R1 + 47];
      P64[Sp] = P64[R1 + 55];
      Sp = Sp - 8;
      call Main.$w$cshowsPrec_info(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 24, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:55.808555 UTC

[(cldf, {Main.$w$cshowsPrec_closure}),
 (cldg, {Main.$w$cshowsPrec_closure}),
 (cldi,
  {Main.$w$cshowsPrec_closure,
   Main.$fShowRBTreeOpts_$cshowsPrec_closure}),
 (cldj, {Main.$fShowRBTreeOpts_$cshowsPrec_closure}),
 (cldk,
  {Main.$w$cshowsPrec_closure,
   Main.$fShowRBTreeOpts_$cshowsPrec_closure}),
 (cldl, {Main.$w$cshowsPrec_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:55.809248 UTC

Main.$fShowRBTreeOpts_$cshowsPrec_entry() //  [R3, R2]
        { info_tbl: [(cldf,
                      label: block_cldf_info
                      rep:StackRep []),
                     (cldi,
                      label: Main.$fShowRBTreeOpts_$cshowsPrec_info
                      rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cldi:
          _sk7b::P64 = R3;
          _sk7a::P64 = R2;
          if ((Sp + -16) < SpLim) goto cldj; else goto cldk;
      cldk:
          if (HpLim == 0) goto cldj; else goto cldl;
      cldj:
          R3 = _sk7b::P64;
          R2 = _sk7a::P64;
          R1 = Main.$fShowRBTreeOpts_$cshowsPrec_closure;
          call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
      cldl:
          I64[Sp - 8] = cldf;
          R1 = _sk7b::P64;
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto cldf; else goto cldg;
      cldg:
          call (I64[R1])(R1) returns to cldf, args: 8, res: 8, upd: 8;
      cldf:
          R6 = P64[R1 + 39];
          R5 = P64[R1 + 31];
          R4 = P64[R1 + 23];
          R3 = P64[R1 + 15];
          R2 = P64[R1 + 7];
          P64[Sp - 8] = P64[R1 + 47];
          P64[Sp] = P64[R1 + 55];
          Sp = Sp - 8;
          call Main.$w$cshowsPrec_info(R6,
                                       R5,
                                       R4,
                                       R3,
                                       R2) args: 24, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:55.811167 UTC

Main.$fShowRBTreeOpts_$cshowsPrec_entry() //  [R3, R2]
        { info_tbl: [(cldf,
                      label: block_cldf_info
                      rep:StackRep []),
                     (cldi,
                      label: Main.$fShowRBTreeOpts_$cshowsPrec_info
                      rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cldi:
          _sk7b::P64 = R3;
          _sk7a::P64 = R2;
          if ((Sp + -16) < SpLim) goto cldj; else goto cldk;
      cldk:
          if (HpLim == 0) goto cldj; else goto cldl;
      cldj:
          R3 = _sk7b::P64;
          R2 = _sk7a::P64;
          R1 = Main.$fShowRBTreeOpts_$cshowsPrec_closure;
          call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
      cldl:
          I64[Sp - 8] = cldf;
          R1 = _sk7b::P64;
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto cldf; else goto cldg;
      cldg:
          call (I64[R1])(R1) returns to cldf, args: 8, res: 8, upd: 8;
      cldf:
          R6 = P64[R1 + 39];
          R5 = P64[R1 + 31];
          R4 = P64[R1 + 23];
          R3 = P64[R1 + 15];
          R2 = P64[R1 + 7];
          P64[Sp - 8] = P64[R1 + 47];
          P64[Sp] = P64[R1 + 55];
          Sp = Sp - 8;
          call Main.$w$cshowsPrec_info(R6,
                                       R5,
                                       R4,
                                       R3,
                                       R2) args: 24, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:55.813088 UTC

[section "data" {
     Main.$fShowRBTreeOpts_$cshowsPrec_closure:
         const Main.$fShowRBTreeOpts_$cshowsPrec_info;
         const 0;
 },
 Main.$fShowRBTreeOpts_$cshowsPrec_entry() //  [R3, R2]
         { info_tbl: [(cldf,
                       label: block_cldf_info
                       rep:StackRep []),
                      (cldi,
                       label: Main.$fShowRBTreeOpts_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cldi:
           _sk7b::P64 = R3;
           _sk7a::P64 = R2;
           if ((Sp + -16) < SpLim) goto cldj; else goto cldk;
       cldk:
           if (HpLim == 0) goto cldj; else goto cldl;
       cldj:
           R3 = _sk7b::P64;
           R2 = _sk7a::P64;
           R1 = Main.$fShowRBTreeOpts_$cshowsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cldl:
           I64[Sp - 8] = cldf;
           R1 = _sk7b::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto cldf; else goto cldg;
       cldg:
           call (I64[R1])(R1) returns to cldf, args: 8, res: 8, upd: 8;
       cldf:
           R6 = P64[R1 + 39];
           R5 = P64[R1 + 31];
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           P64[Sp - 8] = P64[R1 + 47];
           P64[Sp] = P64[R1 + 55];
           Sp = Sp - 8;
           call Main.$w$cshowsPrec_info(R6,
                                        R5,
                                        R4,
                                        R3,
                                        R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:55.81531 UTC

[section "data" {
     Main.$fShowRBTreeOpts_$cshowsPrec_closure:
         const Main.$fShowRBTreeOpts_$cshowsPrec_info;
         const 0;
 },
 Main.$fShowRBTreeOpts_$cshowsPrec_entry() //  [R3, R2]
         { info_tbl: [(cldf,
                       label: block_cldf_info
                       rep:StackRep []),
                      (cldi,
                       label: Main.$fShowRBTreeOpts_$cshowsPrec_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cldi:
           _sk7b::P64 = R3;
           _sk7a::P64 = R2;
           if ((Sp + -16) < SpLim) goto cldj; else goto cldk;
       cldk:
           if (HpLim == 0) goto cldj; else goto cldl;
       cldj:
           R3 = _sk7b::P64;
           R2 = _sk7a::P64;
           R1 = Main.$fShowRBTreeOpts_$cshowsPrec_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       cldl:
           I64[Sp - 8] = cldf;
           R1 = _sk7b::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto cldf; else goto cldg;
       cldg:
           call (I64[R1])(R1) returns to cldf, args: 8, res: 8, upd: 8;
       cldf:
           R6 = P64[R1 + 39];
           R5 = P64[R1 + 31];
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           P64[Sp - 8] = P64[R1 + 47];
           P64[Sp] = P64[R1 + 55];
           Sp = Sp - 8;
           call Main.$w$cshowsPrec_info(R6,
                                        R5,
                                        R4,
                                        R3,
                                        R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:55.821036 UTC

[section "data" {
     Main.$fShowRBTreeOpts_$cshow_closure:
         const Main.$fShowRBTreeOpts_$cshow_info;
         const 0;
 },
 Main.$fShowRBTreeOpts_$cshow_entry() //  [R2]
         { info_tbl: [(cldG,
                       label: Main.$fShowRBTreeOpts_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cldG:
           _sk7k::P64 = R2;
           goto cldB;
       cldB:
           if ((old + 0) - <highSp> < SpLim) goto cldH; else goto cldI;
       cldI:
           goto cldA;
       cldA:
           if (HpLim == 0) goto cldH; else goto cldJ;
       cldH:
           R2 = _sk7k::P64;
           R1 = Main.$fShowRBTreeOpts_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cldJ:
           I64[(young<cldD> + 8)] = cldD;
           R1 = _sk7k::P64;
           if (R1 & 7 != 0) goto cldD; else goto cldE;
       cldE:
           call (I64[R1])(R1) returns to cldD, args: 8, res: 8, upd: 8;
       cldD:
           _sk7l::P64 = R1;
           _sk7m::P64 = P64[_sk7l::P64 + 7];
           _sk7n::P64 = P64[_sk7l::P64 + 15];
           _sk7o::P64 = P64[_sk7l::P64 + 23];
           _sk7p::P64 = P64[_sk7l::P64 + 31];
           _sk7q::P64 = P64[_sk7l::P64 + 39];
           _sk7r::P64 = P64[_sk7l::P64 + 47];
           _sk7s::P64 = P64[_sk7l::P64 + 55];
           R6 = _sk7q::P64;
           R5 = _sk7p::P64;
           R4 = _sk7o::P64;
           R3 = _sk7n::P64;
           R2 = _sk7m::P64;
           P64[(old + 40)] = _sk7r::P64;
           P64[(old + 32)] = _sk7s::P64;
           I64[(old + 24)] = stg_ap_p_info;
           P64[(old + 16)] = GHC.Types.[]_closure+1;
           call Main.$w$cshowsPrec_info(R6,
                                        R5,
                                        R4,
                                        R3,
                                        R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:55.824284 UTC

{offset
  cldG:
      _sk7k::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cldH; else goto cldI;
  cldI:
      if (HpLim == 0) goto cldH; else goto cldJ;
  cldH:
      R2 = _sk7k::P64;
      R1 = Main.$fShowRBTreeOpts_$cshow_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  cldJ:
      I64[(young<cldD> + 8)] = cldD;
      R1 = _sk7k::P64;
      if (R1 & 7 != 0) goto cldD; else goto cldE;
  cldE:
      call (I64[R1])(R1) returns to cldD, args: 8, res: 8, upd: 8;
  cldD:
      _sk7l::P64 = R1;
      _sk7m::P64 = P64[_sk7l::P64 + 7];
      _sk7n::P64 = P64[_sk7l::P64 + 15];
      _sk7o::P64 = P64[_sk7l::P64 + 23];
      _sk7p::P64 = P64[_sk7l::P64 + 31];
      _sk7q::P64 = P64[_sk7l::P64 + 39];
      _sk7r::P64 = P64[_sk7l::P64 + 47];
      _sk7s::P64 = P64[_sk7l::P64 + 55];
      R6 = _sk7q::P64;
      R5 = _sk7p::P64;
      R4 = _sk7o::P64;
      R3 = _sk7n::P64;
      R2 = _sk7m::P64;
      P64[(old + 40)] = _sk7r::P64;
      P64[(old + 32)] = _sk7s::P64;
      I64[(old + 24)] = stg_ap_p_info;
      P64[(old + 16)] = GHC.Types.[]_closure+1;
      call Main.$w$cshowsPrec_info(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 40, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:55.82616 UTC

{offset
  cldG:
      _sk7k::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cldH; else goto cldI;
  cldI:
      if (HpLim == 0) goto cldH; else goto cldJ;
  cldH:
      R2 = _sk7k::P64;
      R1 = Main.$fShowRBTreeOpts_$cshow_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  cldJ:
      I64[(young<cldD> + 8)] = cldD;
      R1 = _sk7k::P64;
      if (R1 & 7 != 0) goto cldD; else goto cldE;
  cldE:
      call (I64[R1])(R1) returns to cldD, args: 8, res: 8, upd: 8;
  cldD:
      _sk7l::P64 = R1;
      _sk7m::P64 = P64[_sk7l::P64 + 7];
      _sk7n::P64 = P64[_sk7l::P64 + 15];
      _sk7o::P64 = P64[_sk7l::P64 + 23];
      _sk7p::P64 = P64[_sk7l::P64 + 31];
      _sk7q::P64 = P64[_sk7l::P64 + 39];
      _sk7r::P64 = P64[_sk7l::P64 + 47];
      _sk7s::P64 = P64[_sk7l::P64 + 55];
      R6 = _sk7q::P64;
      R5 = _sk7p::P64;
      R4 = _sk7o::P64;
      R3 = _sk7n::P64;
      R2 = _sk7m::P64;
      P64[(old + 40)] = _sk7r::P64;
      P64[(old + 32)] = _sk7s::P64;
      I64[(old + 24)] = stg_ap_p_info;
      P64[(old + 16)] = GHC.Types.[]_closure+1;
      call Main.$w$cshowsPrec_info(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 40, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:55.828108 UTC

{offset
  cldG:
      _sk7k::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cldH; else goto cldI;
  cldI:
      if (HpLim == 0) goto cldH; else goto cldJ;
  cldH:
      R2 = _sk7k::P64;
      R1 = Main.$fShowRBTreeOpts_$cshow_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  cldJ:
      I64[(young<cldD> + 8)] = cldD;
      R1 = _sk7k::P64;
      if (R1 & 7 != 0) goto cldD; else goto cldE;
  cldE:
      call (I64[R1])(R1) returns to cldD, args: 8, res: 8, upd: 8;
  cldD:
      _sk7l::P64 = R1;
      _sk7m::P64 = P64[_sk7l::P64 + 7];
      _sk7n::P64 = P64[_sk7l::P64 + 15];
      _sk7o::P64 = P64[_sk7l::P64 + 23];
      _sk7p::P64 = P64[_sk7l::P64 + 31];
      _sk7q::P64 = P64[_sk7l::P64 + 39];
      _sk7r::P64 = P64[_sk7l::P64 + 47];
      _sk7s::P64 = P64[_sk7l::P64 + 55];
      R6 = _sk7q::P64;
      R5 = _sk7p::P64;
      R4 = _sk7o::P64;
      R3 = _sk7n::P64;
      R2 = _sk7m::P64;
      P64[(old + 40)] = _sk7r::P64;
      P64[(old + 32)] = _sk7s::P64;
      I64[(old + 24)] = stg_ap_p_info;
      P64[(old + 16)] = GHC.Types.[]_closure+1;
      call Main.$w$cshowsPrec_info(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 40, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:55.83021 UTC

{offset
  cldG:
      _sk7k::P64 = R2;
      if ((Sp + 8) - 40 < SpLim) goto cldH; else goto cldI;
  cldI:
      if (HpLim == 0) goto cldH; else goto cldJ;
  cldH:
      R2 = _sk7k::P64;
      R1 = Main.$fShowRBTreeOpts_$cshow_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  cldJ:
      I64[Sp - 8] = cldD;
      R1 = _sk7k::P64;
      Sp = Sp - 8;
      if (R1 & 7 != 0) goto cldD; else goto cldE;
  cldE:
      call (I64[R1])(R1) returns to cldD, args: 8, res: 8, upd: 8;
  cldD:
      _sk7l::P64 = R1;
      _sk7m::P64 = P64[_sk7l::P64 + 7];
      _sk7n::P64 = P64[_sk7l::P64 + 15];
      _sk7o::P64 = P64[_sk7l::P64 + 23];
      _sk7p::P64 = P64[_sk7l::P64 + 31];
      _sk7q::P64 = P64[_sk7l::P64 + 39];
      _sk7r::P64 = P64[_sk7l::P64 + 47];
      _sk7s::P64 = P64[_sk7l::P64 + 55];
      R6 = _sk7q::P64;
      R5 = _sk7p::P64;
      R4 = _sk7o::P64;
      R3 = _sk7n::P64;
      R2 = _sk7m::P64;
      P64[Sp - 24] = _sk7r::P64;
      P64[Sp - 16] = _sk7s::P64;
      I64[Sp - 8] = stg_ap_p_info;
      P64[Sp] = GHC.Types.[]_closure+1;
      Sp = Sp - 24;
      call Main.$w$cshowsPrec_info(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 40, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:55.832157 UTC

{offset
  cldG:
      _sk7k::P64 = R2;
      if ((Sp + -32) < SpLim) goto cldH; else goto cldI;
  cldI:
      if (HpLim == 0) goto cldH; else goto cldJ;
  cldH:
      R2 = _sk7k::P64;
      R1 = Main.$fShowRBTreeOpts_$cshow_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  cldJ:
      I64[Sp - 8] = cldD;
      R1 = _sk7k::P64;
      Sp = Sp - 8;
      if (R1 & 7 != 0) goto cldD; else goto cldE;
  cldE:
      call (I64[R1])(R1) returns to cldD, args: 8, res: 8, upd: 8;
  cldD:
      R6 = P64[R1 + 39];
      R5 = P64[R1 + 31];
      R4 = P64[R1 + 23];
      R3 = P64[R1 + 15];
      R2 = P64[R1 + 7];
      P64[Sp - 24] = P64[R1 + 47];
      P64[Sp - 16] = P64[R1 + 55];
      I64[Sp - 8] = stg_ap_p_info;
      P64[Sp] = GHC.Types.[]_closure+1;
      Sp = Sp - 24;
      call Main.$w$cshowsPrec_info(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 40, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:55.834039 UTC

[(cldD, {Main.$w$cshowsPrec_closure}),
 (cldE, {Main.$w$cshowsPrec_closure}),
 (cldG,
  {Main.$w$cshowsPrec_closure,
   Main.$fShowRBTreeOpts_$cshow_closure}),
 (cldH, {Main.$fShowRBTreeOpts_$cshow_closure}),
 (cldI,
  {Main.$w$cshowsPrec_closure,
   Main.$fShowRBTreeOpts_$cshow_closure}),
 (cldJ, {Main.$w$cshowsPrec_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:55.834739 UTC

Main.$fShowRBTreeOpts_$cshow_entry() //  [R2]
        { info_tbl: [(cldD,
                      label: block_cldD_info
                      rep:StackRep []),
                     (cldG,
                      label: Main.$fShowRBTreeOpts_$cshow_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cldG:
          _sk7k::P64 = R2;
          if ((Sp + -32) < SpLim) goto cldH; else goto cldI;
      cldI:
          if (HpLim == 0) goto cldH; else goto cldJ;
      cldH:
          R2 = _sk7k::P64;
          R1 = Main.$fShowRBTreeOpts_$cshow_closure;
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
      cldJ:
          I64[Sp - 8] = cldD;
          R1 = _sk7k::P64;
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto cldD; else goto cldE;
      cldE:
          call (I64[R1])(R1) returns to cldD, args: 8, res: 8, upd: 8;
      cldD:
          R6 = P64[R1 + 39];
          R5 = P64[R1 + 31];
          R4 = P64[R1 + 23];
          R3 = P64[R1 + 15];
          R2 = P64[R1 + 7];
          P64[Sp - 24] = P64[R1 + 47];
          P64[Sp - 16] = P64[R1 + 55];
          I64[Sp - 8] = stg_ap_p_info;
          P64[Sp] = GHC.Types.[]_closure+1;
          Sp = Sp - 24;
          call Main.$w$cshowsPrec_info(R6,
                                       R5,
                                       R4,
                                       R3,
                                       R2) args: 40, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:55.83672 UTC

Main.$fShowRBTreeOpts_$cshow_entry() //  [R2]
        { info_tbl: [(cldD,
                      label: block_cldD_info
                      rep:StackRep []),
                     (cldG,
                      label: Main.$fShowRBTreeOpts_$cshow_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cldG:
          _sk7k::P64 = R2;
          if ((Sp + -32) < SpLim) goto cldH; else goto cldI;
      cldI:
          if (HpLim == 0) goto cldH; else goto cldJ;
      cldH:
          R2 = _sk7k::P64;
          R1 = Main.$fShowRBTreeOpts_$cshow_closure;
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
      cldJ:
          I64[Sp - 8] = cldD;
          R1 = _sk7k::P64;
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto cldD; else goto cldE;
      cldE:
          call (I64[R1])(R1) returns to cldD, args: 8, res: 8, upd: 8;
      cldD:
          R6 = P64[R1 + 39];
          R5 = P64[R1 + 31];
          R4 = P64[R1 + 23];
          R3 = P64[R1 + 15];
          R2 = P64[R1 + 7];
          P64[Sp - 24] = P64[R1 + 47];
          P64[Sp - 16] = P64[R1 + 55];
          I64[Sp - 8] = stg_ap_p_info;
          P64[Sp] = GHC.Types.[]_closure+1;
          Sp = Sp - 24;
          call Main.$w$cshowsPrec_info(R6,
                                       R5,
                                       R4,
                                       R3,
                                       R2) args: 40, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:55.838708 UTC

[section "data" {
     Main.$fShowRBTreeOpts_$cshow_closure:
         const Main.$fShowRBTreeOpts_$cshow_info;
         const 0;
 },
 Main.$fShowRBTreeOpts_$cshow_entry() //  [R2]
         { info_tbl: [(cldD,
                       label: block_cldD_info
                       rep:StackRep []),
                      (cldG,
                       label: Main.$fShowRBTreeOpts_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cldG:
           _sk7k::P64 = R2;
           if ((Sp + -32) < SpLim) goto cldH; else goto cldI;
       cldI:
           if (HpLim == 0) goto cldH; else goto cldJ;
       cldH:
           R2 = _sk7k::P64;
           R1 = Main.$fShowRBTreeOpts_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cldJ:
           I64[Sp - 8] = cldD;
           R1 = _sk7k::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto cldD; else goto cldE;
       cldE:
           call (I64[R1])(R1) returns to cldD, args: 8, res: 8, upd: 8;
       cldD:
           R6 = P64[R1 + 39];
           R5 = P64[R1 + 31];
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           P64[Sp - 24] = P64[R1 + 47];
           P64[Sp - 16] = P64[R1 + 55];
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = GHC.Types.[]_closure+1;
           Sp = Sp - 24;
           call Main.$w$cshowsPrec_info(R6,
                                        R5,
                                        R4,
                                        R3,
                                        R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:55.841053 UTC

[section "data" {
     Main.$fShowRBTreeOpts_$cshow_closure:
         const Main.$fShowRBTreeOpts_$cshow_info;
         const 0;
 },
 Main.$fShowRBTreeOpts_$cshow_entry() //  [R2]
         { info_tbl: [(cldD,
                       label: block_cldD_info
                       rep:StackRep []),
                      (cldG,
                       label: Main.$fShowRBTreeOpts_$cshow_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cldG:
           _sk7k::P64 = R2;
           if ((Sp + -32) < SpLim) goto cldH; else goto cldI;
       cldI:
           if (HpLim == 0) goto cldH; else goto cldJ;
       cldH:
           R2 = _sk7k::P64;
           R1 = Main.$fShowRBTreeOpts_$cshow_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cldJ:
           I64[Sp - 8] = cldD;
           R1 = _sk7k::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto cldD; else goto cldE;
       cldE:
           call (I64[R1])(R1) returns to cldD, args: 8, res: 8, upd: 8;
       cldD:
           R6 = P64[R1 + 39];
           R5 = P64[R1 + 31];
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           P64[Sp - 24] = P64[R1 + 47];
           P64[Sp - 16] = P64[R1 + 55];
           I64[Sp - 8] = stg_ap_p_info;
           P64[Sp] = GHC.Types.[]_closure+1;
           Sp = Sp - 24;
           call Main.$w$cshowsPrec_info(R6,
                                        R5,
                                        R4,
                                        R3,
                                        R2) args: 40, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:55.846811 UTC

[section "data" {
     Main.$fShowRBTreeOpts1_closure:
         const Main.$fShowRBTreeOpts1_info;
         const 0;
 },
 Main.$fShowRBTreeOpts1_entry() //  [R2]
         { info_tbl: [(cle4,
                       label: Main.$fShowRBTreeOpts1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cle4:
           _sk7t::P64 = R2;
           goto cldZ;
       cldZ:
           if ((old + 0) - <highSp> < SpLim) goto cle5; else goto cle6;
       cle6:
           goto cldY;
       cldY:
           if (HpLim == 0) goto cle5; else goto cle7;
       cle5:
           R2 = _sk7t::P64;
           R1 = Main.$fShowRBTreeOpts1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cle7:
           I64[(young<cle1> + 8)] = cle1;
           R1 = _sk7t::P64;
           if (R1 & 7 != 0) goto cle1; else goto cle2;
       cle2:
           call (I64[R1])(R1) returns to cle1, args: 8, res: 8, upd: 8;
       cle1:
           _sk7u::P64 = R1;
           _sk7v::P64 = P64[_sk7u::P64 + 7];
           _sk7w::P64 = P64[_sk7u::P64 + 15];
           _sk7x::P64 = P64[_sk7u::P64 + 23];
           _sk7y::P64 = P64[_sk7u::P64 + 31];
           _sk7z::P64 = P64[_sk7u::P64 + 39];
           _sk7A::P64 = P64[_sk7u::P64 + 47];
           _sk7B::P64 = P64[_sk7u::P64 + 55];
           R6 = _sk7z::P64;
           R5 = _sk7y::P64;
           R4 = _sk7x::P64;
           R3 = _sk7w::P64;
           R2 = _sk7v::P64;
           P64[(old + 24)] = _sk7A::P64;
           P64[(old + 16)] = _sk7B::P64;
           call Main.$w$cshowsPrec_info(R6,
                                        R5,
                                        R4,
                                        R3,
                                        R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:55.849952 UTC

{offset
  cle4:
      _sk7t::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cle5; else goto cle6;
  cle6:
      if (HpLim == 0) goto cle5; else goto cle7;
  cle5:
      R2 = _sk7t::P64;
      R1 = Main.$fShowRBTreeOpts1_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  cle7:
      I64[(young<cle1> + 8)] = cle1;
      R1 = _sk7t::P64;
      if (R1 & 7 != 0) goto cle1; else goto cle2;
  cle2:
      call (I64[R1])(R1) returns to cle1, args: 8, res: 8, upd: 8;
  cle1:
      _sk7u::P64 = R1;
      _sk7v::P64 = P64[_sk7u::P64 + 7];
      _sk7w::P64 = P64[_sk7u::P64 + 15];
      _sk7x::P64 = P64[_sk7u::P64 + 23];
      _sk7y::P64 = P64[_sk7u::P64 + 31];
      _sk7z::P64 = P64[_sk7u::P64 + 39];
      _sk7A::P64 = P64[_sk7u::P64 + 47];
      _sk7B::P64 = P64[_sk7u::P64 + 55];
      R6 = _sk7z::P64;
      R5 = _sk7y::P64;
      R4 = _sk7x::P64;
      R3 = _sk7w::P64;
      R2 = _sk7v::P64;
      P64[(old + 24)] = _sk7A::P64;
      P64[(old + 16)] = _sk7B::P64;
      call Main.$w$cshowsPrec_info(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 24, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:55.851717 UTC

{offset
  cle4:
      _sk7t::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cle5; else goto cle6;
  cle6:
      if (HpLim == 0) goto cle5; else goto cle7;
  cle5:
      R2 = _sk7t::P64;
      R1 = Main.$fShowRBTreeOpts1_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  cle7:
      I64[(young<cle1> + 8)] = cle1;
      R1 = _sk7t::P64;
      if (R1 & 7 != 0) goto cle1; else goto cle2;
  cle2:
      call (I64[R1])(R1) returns to cle1, args: 8, res: 8, upd: 8;
  cle1:
      _sk7u::P64 = R1;
      _sk7v::P64 = P64[_sk7u::P64 + 7];
      _sk7w::P64 = P64[_sk7u::P64 + 15];
      _sk7x::P64 = P64[_sk7u::P64 + 23];
      _sk7y::P64 = P64[_sk7u::P64 + 31];
      _sk7z::P64 = P64[_sk7u::P64 + 39];
      _sk7A::P64 = P64[_sk7u::P64 + 47];
      _sk7B::P64 = P64[_sk7u::P64 + 55];
      R6 = _sk7z::P64;
      R5 = _sk7y::P64;
      R4 = _sk7x::P64;
      R3 = _sk7w::P64;
      R2 = _sk7v::P64;
      P64[(old + 24)] = _sk7A::P64;
      P64[(old + 16)] = _sk7B::P64;
      call Main.$w$cshowsPrec_info(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 24, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:55.8535 UTC

{offset
  cle4:
      _sk7t::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto cle5; else goto cle6;
  cle6:
      if (HpLim == 0) goto cle5; else goto cle7;
  cle5:
      R2 = _sk7t::P64;
      R1 = Main.$fShowRBTreeOpts1_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  cle7:
      I64[(young<cle1> + 8)] = cle1;
      R1 = _sk7t::P64;
      if (R1 & 7 != 0) goto cle1; else goto cle2;
  cle2:
      call (I64[R1])(R1) returns to cle1, args: 8, res: 8, upd: 8;
  cle1:
      _sk7u::P64 = R1;
      _sk7v::P64 = P64[_sk7u::P64 + 7];
      _sk7w::P64 = P64[_sk7u::P64 + 15];
      _sk7x::P64 = P64[_sk7u::P64 + 23];
      _sk7y::P64 = P64[_sk7u::P64 + 31];
      _sk7z::P64 = P64[_sk7u::P64 + 39];
      _sk7A::P64 = P64[_sk7u::P64 + 47];
      _sk7B::P64 = P64[_sk7u::P64 + 55];
      R6 = _sk7z::P64;
      R5 = _sk7y::P64;
      R4 = _sk7x::P64;
      R3 = _sk7w::P64;
      R2 = _sk7v::P64;
      P64[(old + 24)] = _sk7A::P64;
      P64[(old + 16)] = _sk7B::P64;
      call Main.$w$cshowsPrec_info(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 24, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:55.856102 UTC

{offset
  cle4:
      _sk7t::P64 = R2;
      if ((Sp + 8) - 24 < SpLim) goto cle5; else goto cle6;
  cle6:
      if (HpLim == 0) goto cle5; else goto cle7;
  cle5:
      R2 = _sk7t::P64;
      R1 = Main.$fShowRBTreeOpts1_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  cle7:
      I64[Sp - 8] = cle1;
      R1 = _sk7t::P64;
      Sp = Sp - 8;
      if (R1 & 7 != 0) goto cle1; else goto cle2;
  cle2:
      call (I64[R1])(R1) returns to cle1, args: 8, res: 8, upd: 8;
  cle1:
      _sk7u::P64 = R1;
      _sk7v::P64 = P64[_sk7u::P64 + 7];
      _sk7w::P64 = P64[_sk7u::P64 + 15];
      _sk7x::P64 = P64[_sk7u::P64 + 23];
      _sk7y::P64 = P64[_sk7u::P64 + 31];
      _sk7z::P64 = P64[_sk7u::P64 + 39];
      _sk7A::P64 = P64[_sk7u::P64 + 47];
      _sk7B::P64 = P64[_sk7u::P64 + 55];
      R6 = _sk7z::P64;
      R5 = _sk7y::P64;
      R4 = _sk7x::P64;
      R3 = _sk7w::P64;
      R2 = _sk7v::P64;
      P64[Sp - 8] = _sk7A::P64;
      P64[Sp] = _sk7B::P64;
      Sp = Sp - 8;
      call Main.$w$cshowsPrec_info(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 24, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:55.857971 UTC

{offset
  cle4:
      _sk7t::P64 = R2;
      if ((Sp + -16) < SpLim) goto cle5; else goto cle6;
  cle6:
      if (HpLim == 0) goto cle5; else goto cle7;
  cle5:
      R2 = _sk7t::P64;
      R1 = Main.$fShowRBTreeOpts1_closure;
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
  cle7:
      I64[Sp - 8] = cle1;
      R1 = _sk7t::P64;
      Sp = Sp - 8;
      if (R1 & 7 != 0) goto cle1; else goto cle2;
  cle2:
      call (I64[R1])(R1) returns to cle1, args: 8, res: 8, upd: 8;
  cle1:
      R6 = P64[R1 + 39];
      R5 = P64[R1 + 31];
      R4 = P64[R1 + 23];
      R3 = P64[R1 + 15];
      R2 = P64[R1 + 7];
      P64[Sp - 8] = P64[R1 + 47];
      P64[Sp] = P64[R1 + 55];
      Sp = Sp - 8;
      call Main.$w$cshowsPrec_info(R6,
                                   R5,
                                   R4,
                                   R3,
                                   R2) args: 24, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:55.859837 UTC

[(cle1, {Main.$w$cshowsPrec_closure}),
 (cle2, {Main.$w$cshowsPrec_closure}),
 (cle4,
  {Main.$fShowRBTreeOpts1_closure, Main.$w$cshowsPrec_closure}),
 (cle5, {Main.$fShowRBTreeOpts1_closure}),
 (cle6,
  {Main.$fShowRBTreeOpts1_closure, Main.$w$cshowsPrec_closure}),
 (cle7, {Main.$w$cshowsPrec_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:55.860492 UTC

Main.$fShowRBTreeOpts1_entry() //  [R2]
        { info_tbl: [(cle1,
                      label: block_cle1_info
                      rep:StackRep []),
                     (cle4,
                      label: Main.$fShowRBTreeOpts1_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cle4:
          _sk7t::P64 = R2;
          if ((Sp + -16) < SpLim) goto cle5; else goto cle6;
      cle6:
          if (HpLim == 0) goto cle5; else goto cle7;
      cle5:
          R2 = _sk7t::P64;
          R1 = Main.$fShowRBTreeOpts1_closure;
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
      cle7:
          I64[Sp - 8] = cle1;
          R1 = _sk7t::P64;
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto cle1; else goto cle2;
      cle2:
          call (I64[R1])(R1) returns to cle1, args: 8, res: 8, upd: 8;
      cle1:
          R6 = P64[R1 + 39];
          R5 = P64[R1 + 31];
          R4 = P64[R1 + 23];
          R3 = P64[R1 + 15];
          R2 = P64[R1 + 7];
          P64[Sp - 8] = P64[R1 + 47];
          P64[Sp] = P64[R1 + 55];
          Sp = Sp - 8;
          call Main.$w$cshowsPrec_info(R6,
                                       R5,
                                       R4,
                                       R3,
                                       R2) args: 24, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:55.86233 UTC

Main.$fShowRBTreeOpts1_entry() //  [R2]
        { info_tbl: [(cle1,
                      label: block_cle1_info
                      rep:StackRep []),
                     (cle4,
                      label: Main.$fShowRBTreeOpts1_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cle4:
          _sk7t::P64 = R2;
          if ((Sp + -16) < SpLim) goto cle5; else goto cle6;
      cle6:
          if (HpLim == 0) goto cle5; else goto cle7;
      cle5:
          R2 = _sk7t::P64;
          R1 = Main.$fShowRBTreeOpts1_closure;
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
      cle7:
          I64[Sp - 8] = cle1;
          R1 = _sk7t::P64;
          Sp = Sp - 8;
          if (R1 & 7 != 0) goto cle1; else goto cle2;
      cle2:
          call (I64[R1])(R1) returns to cle1, args: 8, res: 8, upd: 8;
      cle1:
          R6 = P64[R1 + 39];
          R5 = P64[R1 + 31];
          R4 = P64[R1 + 23];
          R3 = P64[R1 + 15];
          R2 = P64[R1 + 7];
          P64[Sp - 8] = P64[R1 + 47];
          P64[Sp] = P64[R1 + 55];
          Sp = Sp - 8;
          call Main.$w$cshowsPrec_info(R6,
                                       R5,
                                       R4,
                                       R3,
                                       R2) args: 24, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:55.864136 UTC

[section "data" {
     Main.$fShowRBTreeOpts1_closure:
         const Main.$fShowRBTreeOpts1_info;
         const 0;
 },
 Main.$fShowRBTreeOpts1_entry() //  [R2]
         { info_tbl: [(cle1,
                       label: block_cle1_info
                       rep:StackRep []),
                      (cle4,
                       label: Main.$fShowRBTreeOpts1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cle4:
           _sk7t::P64 = R2;
           if ((Sp + -16) < SpLim) goto cle5; else goto cle6;
       cle6:
           if (HpLim == 0) goto cle5; else goto cle7;
       cle5:
           R2 = _sk7t::P64;
           R1 = Main.$fShowRBTreeOpts1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cle7:
           I64[Sp - 8] = cle1;
           R1 = _sk7t::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto cle1; else goto cle2;
       cle2:
           call (I64[R1])(R1) returns to cle1, args: 8, res: 8, upd: 8;
       cle1:
           R6 = P64[R1 + 39];
           R5 = P64[R1 + 31];
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           P64[Sp - 8] = P64[R1 + 47];
           P64[Sp] = P64[R1 + 55];
           Sp = Sp - 8;
           call Main.$w$cshowsPrec_info(R6,
                                        R5,
                                        R4,
                                        R3,
                                        R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:55.866262 UTC

[section "data" {
     Main.$fShowRBTreeOpts1_closure:
         const Main.$fShowRBTreeOpts1_info;
         const 0;
 },
 Main.$fShowRBTreeOpts1_entry() //  [R2]
         { info_tbl: [(cle1,
                       label: block_cle1_info
                       rep:StackRep []),
                      (cle4,
                       label: Main.$fShowRBTreeOpts1_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cle4:
           _sk7t::P64 = R2;
           if ((Sp + -16) < SpLim) goto cle5; else goto cle6;
       cle6:
           if (HpLim == 0) goto cle5; else goto cle7;
       cle5:
           R2 = _sk7t::P64;
           R1 = Main.$fShowRBTreeOpts1_closure;
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;
       cle7:
           I64[Sp - 8] = cle1;
           R1 = _sk7t::P64;
           Sp = Sp - 8;
           if (R1 & 7 != 0) goto cle1; else goto cle2;
       cle2:
           call (I64[R1])(R1) returns to cle1, args: 8, res: 8, upd: 8;
       cle1:
           R6 = P64[R1 + 39];
           R5 = P64[R1 + 31];
           R4 = P64[R1 + 23];
           R3 = P64[R1 + 15];
           R2 = P64[R1 + 7];
           P64[Sp - 8] = P64[R1 + 47];
           P64[Sp] = P64[R1 + 55];
           Sp = Sp - 8;
           call Main.$w$cshowsPrec_info(R6,
                                        R5,
                                        R4,
                                        R3,
                                        R2) args: 24, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:55.871715 UTC

[section "data" {
     Main.$fShowRBTreeOpts_$cshowList_closure:
         const Main.$fShowRBTreeOpts_$cshowList_info;
         const 0;
 },
 Main.$fShowRBTreeOpts_$cshowList_entry() //  [R3, R2]
         { info_tbl: [(clem,
                       label: Main.$fShowRBTreeOpts_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       clem:
           _B1::P64 = R3;
           _B2::P64 = R2;
           goto clek;
       clek:
           if ((old + 0) - <highSp> < SpLim) goto clen; else goto cleo;
       cleo:
           goto clej;
       clej:
           if (HpLim == 0) goto clen; else goto clep;
       clen:
           R3 = _B1::P64;
           R2 = _B2::P64;
           R1 = Main.$fShowRBTreeOpts_$cshowList_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       clep:
           R4 = _B1::P64;
           R3 = _B2::P64;
           R2 = Main.$fShowRBTreeOpts1_closure+1;
           call GHC.Show.showList___info(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:55.873502 UTC

{offset
  clem:
      _B1::P64 = R3;
      _B2::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto clen; else goto cleo;
  cleo:
      if (HpLim == 0) goto clen; else goto clep;
  clen:
      R3 = _B1::P64;
      R2 = _B2::P64;
      R1 = Main.$fShowRBTreeOpts_$cshowList_closure;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  clep:
      R4 = _B1::P64;
      R3 = _B2::P64;
      R2 = Main.$fShowRBTreeOpts1_closure+1;
      call GHC.Show.showList___info(R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:55.874397 UTC

{offset
  clem:
      _B1::P64 = R3;
      _B2::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto clen; else goto cleo;
  cleo:
      if (HpLim == 0) goto clen; else goto clep;
  clen:
      R3 = _B1::P64;
      R2 = _B2::P64;
      R1 = Main.$fShowRBTreeOpts_$cshowList_closure;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  clep:
      R4 = _B1::P64;
      R3 = _B2::P64;
      R2 = Main.$fShowRBTreeOpts1_closure+1;
      call GHC.Show.showList___info(R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:55.875307 UTC

{offset
  clem:
      _B1::P64 = R3;
      _B2::P64 = R2;
      if ((old + 0) - <highSp> < SpLim) goto clen; else goto cleo;
  cleo:
      if (HpLim == 0) goto clen; else goto clep;
  clen:
      R3 = _B1::P64;
      R2 = _B2::P64;
      R1 = Main.$fShowRBTreeOpts_$cshowList_closure;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  clep:
      R4 = _B1::P64;
      R3 = _B2::P64;
      R2 = Main.$fShowRBTreeOpts1_closure+1;
      call GHC.Show.showList___info(R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:55.876257 UTC

{offset
  clem:
      _B1::P64 = R3;
      _B2::P64 = R2;
      goto cleo;
  cleo:
      if (HpLim == 0) goto clen; else goto clep;
  clen:
      R3 = _B1::P64;
      R2 = _B2::P64;
      R1 = Main.$fShowRBTreeOpts_$cshowList_closure;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  clep:
      R4 = _B1::P64;
      R3 = _B2::P64;
      R2 = Main.$fShowRBTreeOpts1_closure+1;
      call GHC.Show.showList___info(R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:55.877107 UTC

{offset
  clem:
      goto cleo;
  cleo:
      if (HpLim == 0) goto clen; else goto clep;
  clen:
      R3 = R3;
      R2 = R2;
      R1 = Main.$fShowRBTreeOpts_$cshowList_closure;
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
  clep:
      R4 = R3;
      R3 = R2;
      R2 = Main.$fShowRBTreeOpts1_closure+1;
      call GHC.Show.showList___info(R4, R3, R2) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:55.878019 UTC

[(clem,
  {Main.$fShowRBTreeOpts1_closure,
   Main.$fShowRBTreeOpts_$cshowList_closure}),
 (clen, {Main.$fShowRBTreeOpts_$cshowList_closure}),
 (cleo,
  {Main.$fShowRBTreeOpts1_closure,
   Main.$fShowRBTreeOpts_$cshowList_closure}),
 (clep, {Main.$fShowRBTreeOpts1_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:55.878558 UTC

Main.$fShowRBTreeOpts_$cshowList_entry() //  [R3, R2]
        { info_tbl: [(clem,
                      label: Main.$fShowRBTreeOpts_$cshowList_info
                      rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      clem:
          goto cleo;
      cleo:
          if (HpLim == 0) goto clen; else goto clep;
      clen:
          R3 = R3;
          R2 = R2;
          R1 = Main.$fShowRBTreeOpts_$cshowList_closure;
          call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
      clep:
          R4 = R3;
          R3 = R2;
          R2 = Main.$fShowRBTreeOpts1_closure+1;
          call GHC.Show.showList___info(R4, R3, R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:55.87957 UTC

Main.$fShowRBTreeOpts_$cshowList_entry() //  [R3, R2]
        { info_tbl: [(clem,
                      label: Main.$fShowRBTreeOpts_$cshowList_info
                      rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      clem:
          if (HpLim == 0) goto clen; else goto clep;
      clen:
          R3 = R3;
          R2 = R2;
          R1 = Main.$fShowRBTreeOpts_$cshowList_closure;
          call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
      clep:
          R4 = R3;
          R3 = R2;
          R2 = Main.$fShowRBTreeOpts1_closure+1;
          call GHC.Show.showList___info(R4, R3, R2) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:55.880535 UTC

[section "data" {
     Main.$fShowRBTreeOpts_$cshowList_closure:
         const Main.$fShowRBTreeOpts_$cshowList_info;
         const 0;
 },
 Main.$fShowRBTreeOpts_$cshowList_entry() //  [R3, R2]
         { info_tbl: [(clem,
                       label: Main.$fShowRBTreeOpts_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       clem:
           if (HpLim == 0) goto clen; else goto clep;
       clen:
           R3 = R3;
           R2 = R2;
           R1 = Main.$fShowRBTreeOpts_$cshowList_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       clep:
           R4 = R3;
           R3 = R2;
           R2 = Main.$fShowRBTreeOpts1_closure+1;
           call GHC.Show.showList___info(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:55.881742 UTC

[section "data" {
     Main.$fShowRBTreeOpts_$cshowList_closure:
         const Main.$fShowRBTreeOpts_$cshowList_info;
         const 0;
 },
 Main.$fShowRBTreeOpts_$cshowList_entry() //  [R3, R2]
         { info_tbl: [(clem,
                       label: Main.$fShowRBTreeOpts_$cshowList_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       clem:
           if (HpLim == 0) goto clen; else goto clep;
       clen:
           R3 = R3;
           R2 = R2;
           R1 = Main.$fShowRBTreeOpts_$cshowList_closure;
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;
       clep:
           R4 = R3;
           R3 = R2;
           R2 = Main.$fShowRBTreeOpts1_closure+1;
           call GHC.Show.showList___info(R4, R3, R2) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:55.884741 UTC

[section "data" {
     Main.$fShowRBTreeOpts_closure:
         const GHC.Show.D:Show_static_info;
         const Main.$fShowRBTreeOpts_$cshowsPrec_closure+2;
         const Main.$fShowRBTreeOpts_$cshow_closure+1;
         const Main.$fShowRBTreeOpts_$cshowList_closure+2;
         const 0;
 }]


==================== Post CPS Cmm ====================
2015-11-09 18:21:55.885231 UTC

[section "data" {
     Main.$fShowRBTreeOpts_closure:
         const GHC.Show.D:Show_static_info;
         const Main.$fShowRBTreeOpts_$cshowsPrec_closure+2;
         const Main.$fShowRBTreeOpts_$cshow_closure+1;
         const Main.$fShowRBTreeOpts_$cshowList_closure+2;
         const 0;
 }]


==================== Output Cmm ====================
2015-11-09 18:21:55.88565 UTC

[section "data" {
     Main.$fShowRBTreeOpts_closure:
         const GHC.Show.D:Show_static_info;
         const Main.$fShowRBTreeOpts_$cshowsPrec_closure+2;
         const Main.$fShowRBTreeOpts_$cshow_closure+1;
         const Main.$fShowRBTreeOpts_$cshowList_closure+2;
         const 0;
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:55.886581 UTC

[section "data" {
     :Main.main_closure:
         const :Main.main_info;
         const 0;
 },
 :Main.main_entry() //  []
         { info_tbl: [(cleA,
                       label: :Main.main_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cleA:
           goto cley;
       cley:
           if ((old + 0) - <highSp> < SpLim) goto cleB; else goto cleC;
       cleC:
           goto clex;
       clex:
           if (HpLim == 0) goto cleB; else goto cleD;
       cleB:
           R1 = :Main.main_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cleD:
           call Main.main2_info() args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:55.888493 UTC

{offset
  cleA:
      if ((old + 0) - <highSp> < SpLim) goto cleB; else goto cleC;
  cleC:
      if (HpLim == 0) goto cleB; else goto cleD;
  cleB:
      R1 = :Main.main_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  cleD:
      call Main.main2_info() args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:55.889143 UTC

{offset
  cleA:
      if ((old + 0) - <highSp> < SpLim) goto cleB; else goto cleC;
  cleC:
      if (HpLim == 0) goto cleB; else goto cleD;
  cleB:
      R1 = :Main.main_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  cleD:
      call Main.main2_info() args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:55.889767 UTC

{offset
  cleA:
      if ((old + 0) - <highSp> < SpLim) goto cleB; else goto cleC;
  cleC:
      if (HpLim == 0) goto cleB; else goto cleD;
  cleB:
      R1 = :Main.main_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  cleD:
      call Main.main2_info() args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:55.890433 UTC

{offset
  cleA:
      goto cleC;
  cleC:
      if (HpLim == 0) goto cleB; else goto cleD;
  cleB:
      R1 = :Main.main_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  cleD:
      call Main.main2_info() args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:55.890984 UTC

{offset
  cleA:
      goto cleC;
  cleC:
      if (HpLim == 0) goto cleB; else goto cleD;
  cleB:
      R1 = :Main.main_closure;
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
  cleD:
      call Main.main2_info() args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:55.89154 UTC

[(cleA, {:Main.main_closure, Main.main2_closure}),
 (cleB, {:Main.main_closure}),
 (cleC, {:Main.main_closure, Main.main2_closure}),
 (cleD, {Main.main2_closure})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:55.892051 UTC

:Main.main_entry() //  []
        { info_tbl: [(cleA,
                      label: :Main.main_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cleA:
          goto cleC;
      cleC:
          if (HpLim == 0) goto cleB; else goto cleD;
      cleB:
          R1 = :Main.main_closure;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
      cleD:
          call Main.main2_info() args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:55.892838 UTC

:Main.main_entry() //  []
        { info_tbl: [(cleA,
                      label: :Main.main_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cleA:
          if (HpLim == 0) goto cleB; else goto cleD;
      cleB:
          R1 = :Main.main_closure;
          call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
      cleD:
          call Main.main2_info() args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:55.893597 UTC

[section "data" {
     :Main.main_closure:
         const :Main.main_info;
         const 0;
 },
 :Main.main_entry() //  []
         { info_tbl: [(cleA,
                       label: :Main.main_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cleA:
           if (HpLim == 0) goto cleB; else goto cleD;
       cleB:
           R1 = :Main.main_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cleD:
           call Main.main2_info() args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:55.894593 UTC

[section "data" {
     :Main.main_closure:
         const :Main.main_info;
         const 0;
 },
 :Main.main_entry() //  []
         { info_tbl: [(cleA,
                       label: :Main.main_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cleA:
           if (HpLim == 0) goto cleB; else goto cleD;
       cleB:
           R1 = :Main.main_closure;
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;
       cleD:
           call Main.main2_info() args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:55.897158 UTC

[section "data" {
     Main.RBTreeOpts_closure:
         const Main.RBTreeOpts_info;
 },
 Main.RBTreeOpts_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 64 updfr_space: Just 8
         }
     {offset
       cleJ:
           _rbTz::P64 = R1;
           _B7::P64 = P64[(old + 64)];
           _B6::P64 = P64[(old + 56)];
           _B5::P64 = P64[(old + 48)];
           _B4::P64 = P64[(old + 40)];
           _B3::P64 = P64[(old + 32)];
           _B2::P64 = P64[(old + 24)];
           _B1::P64 = P64[(old + 16)];
           R6 = _B3::P64;
           R5 = _B4::P64;
           R4 = _B5::P64;
           R3 = _B6::P64;
           R2 = _B7::P64;
           R1 = _rbTz::P64;
           P64[(old + 24)] = _B2::P64;
           P64[(old + 16)] = _B1::P64;
           call Main.RBTreeOpts_info(R6,
                                     R5,
                                     R4,
                                     R3,
                                     R2,
                                     R1) args: 24, res: 0, upd: 8;
     }
 },
 Main.RBTreeOpts_entry() //  [R6, R5, R4, R3, R2]
         { info_tbl: [(cleO,
                       label: Main.RBTreeOpts_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 24 updfr_space: Just 8
         }
     {offset
       cleO:
           _B3::P64 = R6;
           _B4::P64 = R5;
           _B5::P64 = R4;
           _B6::P64 = R3;
           _B7::P64 = R2;
           _B2::P64 = P64[(old + 24)];
           _B1::P64 = P64[(old + 16)];
           goto cleL;
       cleL:
           if ((old + 0) - <highSp> < SpLim) goto cleP; else goto cleQ;
       cleQ:
           goto cleK;
       cleK:
           Hp = Hp + 64;
           if (Hp > HpLim) goto cleS; else goto cleR;
       cleS:
           HpAlloc = 64;
           goto cleP;
       cleP:
           R1 = Main.RBTreeOpts_closure;
           P64[(old + 64)] = _B7::P64;
           P64[(old + 56)] = _B6::P64;
           P64[(old + 48)] = _B5::P64;
           P64[(old + 40)] = _B4::P64;
           P64[(old + 32)] = _B3::P64;
           P64[(old + 24)] = _B2::P64;
           P64[(old + 16)] = _B1::P64;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       cleR:
           I64[Hp - 56] = Main.RBTreeOpts_con_info;
           P64[Hp - 48] = _B7::P64;
           P64[Hp - 40] = _B6::P64;
           P64[Hp - 32] = _B5::P64;
           P64[Hp - 24] = _B4::P64;
           P64[Hp - 16] = _B3::P64;
           P64[Hp - 8] = _B2::P64;
           P64[Hp] = _B1::P64;
           _cleN::P64 = Hp - 55;
           R1 = _cleN::P64;
           call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:55.901695 UTC

{offset
  cleJ:
      _rbTz::P64 = R1;
      _B7::P64 = P64[(old + 64)];
      _B6::P64 = P64[(old + 56)];
      _B5::P64 = P64[(old + 48)];
      _B4::P64 = P64[(old + 40)];
      _B3::P64 = P64[(old + 32)];
      _B2::P64 = P64[(old + 24)];
      _B1::P64 = P64[(old + 16)];
      R6 = _B3::P64;
      R5 = _B4::P64;
      R4 = _B5::P64;
      R3 = _B6::P64;
      R2 = _B7::P64;
      R1 = _rbTz::P64;
      P64[(old + 24)] = _B2::P64;
      P64[(old + 16)] = _B1::P64;
      call Main.RBTreeOpts_info(R6,
                                R5,
                                R4,
                                R3,
                                R2,
                                R1) args: 24, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:55.902757 UTC

{offset
  cleJ:
      _rbTz::P64 = R1;
      _B7::P64 = P64[(old + 64)];
      _B6::P64 = P64[(old + 56)];
      _B5::P64 = P64[(old + 48)];
      _B4::P64 = P64[(old + 40)];
      _B3::P64 = P64[(old + 32)];
      _B2::P64 = P64[(old + 24)];
      _B1::P64 = P64[(old + 16)];
      R6 = _B3::P64;
      R5 = _B4::P64;
      R4 = _B5::P64;
      R3 = _B6::P64;
      R2 = _B7::P64;
      R1 = _rbTz::P64;
      P64[(old + 24)] = _B2::P64;
      P64[(old + 16)] = _B1::P64;
      call Main.RBTreeOpts_info(R6,
                                R5,
                                R4,
                                R3,
                                R2,
                                R1) args: 24, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:55.903798 UTC

{offset
  cleJ:
      _rbTz::P64 = R1;
      _B7::P64 = P64[(old + 64)];
      _B6::P64 = P64[(old + 56)];
      _B5::P64 = P64[(old + 48)];
      _B4::P64 = P64[(old + 40)];
      _B3::P64 = P64[(old + 32)];
      _B2::P64 = P64[(old + 24)];
      _B1::P64 = P64[(old + 16)];
      R6 = _B3::P64;
      R5 = _B4::P64;
      R4 = _B5::P64;
      R3 = _B6::P64;
      R2 = _B7::P64;
      R1 = _rbTz::P64;
      P64[(old + 24)] = _B2::P64;
      P64[(old + 16)] = _B1::P64;
      call Main.RBTreeOpts_info(R6,
                                R5,
                                R4,
                                R3,
                                R2,
                                R1) args: 24, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:55.904835 UTC

{offset
  cleJ:
      _rbTz::P64 = R1;
      _B7::P64 = P64[Sp];
      _B6::P64 = P64[Sp + 8];
      _B5::P64 = P64[Sp + 16];
      _B4::P64 = P64[Sp + 24];
      _B3::P64 = P64[Sp + 32];
      _B2::P64 = P64[Sp + 40];
      _B1::P64 = P64[Sp + 48];
      R6 = _B3::P64;
      R5 = _B4::P64;
      R4 = _B5::P64;
      R3 = _B6::P64;
      R2 = _B7::P64;
      R1 = _rbTz::P64;
      Sp = Sp + 40;
      call Main.RBTreeOpts_info(R6,
                                R5,
                                R4,
                                R3,
                                R2,
                                R1) args: 24, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:55.905828 UTC

{offset
  cleJ:
      R6 = P64[Sp + 32];
      R5 = P64[Sp + 24];
      R4 = P64[Sp + 16];
      R3 = P64[Sp + 8];
      R2 = P64[Sp];
      R1 = R1;
      Sp = Sp + 40;
      call Main.RBTreeOpts_info(R6,
                                R5,
                                R4,
                                R3,
                                R2,
                                R1) args: 24, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:55.906641 UTC

[(cleJ, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:55.906885 UTC

Main.RBTreeOpts_slow() //  [R1]
        { info_tbl: []
          stack_info: arg_space: 64 updfr_space: Just 8
        }
    {offset
      cleJ:
          R6 = P64[Sp + 32];
          R5 = P64[Sp + 24];
          R4 = P64[Sp + 16];
          R3 = P64[Sp + 8];
          R2 = P64[Sp];
          R1 = R1;
          Sp = Sp + 40;
          call Main.RBTreeOpts_info(R6,
                                    R5,
                                    R4,
                                    R3,
                                    R2,
                                    R1) args: 24, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:55.907703 UTC

Main.RBTreeOpts_slow() //  [R1]
        { info_tbl: []
          stack_info: arg_space: 64 updfr_space: Just 8
        }
    {offset
      cleJ:
          R6 = P64[Sp + 32];
          R5 = P64[Sp + 24];
          R4 = P64[Sp + 16];
          R3 = P64[Sp + 8];
          R2 = P64[Sp];
          R1 = R1;
          Sp = Sp + 40;
          call Main.RBTreeOpts_info(R6,
                                    R5,
                                    R4,
                                    R3,
                                    R2,
                                    R1) args: 24, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:55.908504 UTC

{offset
  cleO:
      _B3::P64 = R6;
      _B4::P64 = R5;
      _B5::P64 = R4;
      _B6::P64 = R3;
      _B7::P64 = R2;
      _B2::P64 = P64[(old + 24)];
      _B1::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto cleP; else goto cleQ;
  cleQ:
      Hp = Hp + 64;
      if (Hp > HpLim) goto cleS; else goto cleR;
  cleS:
      HpAlloc = 64;
      goto cleP;
  cleP:
      R1 = Main.RBTreeOpts_closure;
      P64[(old + 64)] = _B7::P64;
      P64[(old + 56)] = _B6::P64;
      P64[(old + 48)] = _B5::P64;
      P64[(old + 40)] = _B4::P64;
      P64[(old + 32)] = _B3::P64;
      P64[(old + 24)] = _B2::P64;
      P64[(old + 16)] = _B1::P64;
      call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
  cleR:
      I64[Hp - 56] = Main.RBTreeOpts_con_info;
      P64[Hp - 48] = _B7::P64;
      P64[Hp - 40] = _B6::P64;
      P64[Hp - 32] = _B5::P64;
      P64[Hp - 24] = _B4::P64;
      P64[Hp - 16] = _B3::P64;
      P64[Hp - 8] = _B2::P64;
      P64[Hp] = _B1::P64;
      _cleN::P64 = Hp - 55;
      R1 = _cleN::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:55.910321 UTC

{offset
  cleO:
      _B3::P64 = R6;
      _B4::P64 = R5;
      _B5::P64 = R4;
      _B6::P64 = R3;
      _B7::P64 = R2;
      _B2::P64 = P64[(old + 24)];
      _B1::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto cleP; else goto cleQ;
  cleQ:
      Hp = Hp + 64;
      if (Hp > HpLim) goto cleS; else goto cleR;
  cleS:
      HpAlloc = 64;
      goto cleP;
  cleP:
      R1 = Main.RBTreeOpts_closure;
      P64[(old + 64)] = _B7::P64;
      P64[(old + 56)] = _B6::P64;
      P64[(old + 48)] = _B5::P64;
      P64[(old + 40)] = _B4::P64;
      P64[(old + 32)] = _B3::P64;
      P64[(old + 24)] = _B2::P64;
      P64[(old + 16)] = _B1::P64;
      call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
  cleR:
      I64[Hp - 56] = Main.RBTreeOpts_con_info;
      P64[Hp - 48] = _B7::P64;
      P64[Hp - 40] = _B6::P64;
      P64[Hp - 32] = _B5::P64;
      P64[Hp - 24] = _B4::P64;
      P64[Hp - 16] = _B3::P64;
      P64[Hp - 8] = _B2::P64;
      P64[Hp] = _B1::P64;
      _cleN::P64 = Hp - 55;
      R1 = _cleN::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:55.912683 UTC

{offset
  cleO:
      _B3::P64 = R6;
      _B4::P64 = R5;
      _B5::P64 = R4;
      _B6::P64 = R3;
      _B7::P64 = R2;
      _B2::P64 = P64[(old + 24)];
      _B1::P64 = P64[(old + 16)];
      if ((old + 0) - <highSp> < SpLim) goto cleP; else goto cleQ;
  cleQ:
      Hp = Hp + 64;
      if (Hp > HpLim) goto cleS; else goto cleR;
  cleS:
      HpAlloc = 64;
      goto cleP;
  cleP:
      R1 = Main.RBTreeOpts_closure;
      P64[(old + 64)] = _B7::P64;
      P64[(old + 56)] = _B6::P64;
      P64[(old + 48)] = _B5::P64;
      P64[(old + 40)] = _B4::P64;
      P64[(old + 32)] = _B3::P64;
      P64[(old + 24)] = _B2::P64;
      P64[(old + 16)] = _B1::P64;
      call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
  cleR:
      I64[Hp - 56] = Main.RBTreeOpts_con_info;
      P64[Hp - 48] = _B7::P64;
      P64[Hp - 40] = _B6::P64;
      P64[Hp - 32] = _B5::P64;
      P64[Hp - 24] = _B4::P64;
      P64[Hp - 16] = _B3::P64;
      P64[Hp - 8] = _B2::P64;
      P64[Hp] = _B1::P64;
      _cleN::P64 = Hp - 55;
      R1 = _cleN::P64;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:55.914623 UTC

{offset
  cleO:
      _B3::P64 = R6;
      _B4::P64 = R5;
      _B5::P64 = R4;
      _B6::P64 = R3;
      _B7::P64 = R2;
      _B2::P64 = P64[Sp];
      _B1::P64 = P64[Sp + 8];
      goto cleQ;
  cleQ:
      Hp = Hp + 64;
      if (Hp > HpLim) goto cleS; else goto cleR;
  cleS:
      HpAlloc = 64;
      goto cleP;
  cleP:
      R1 = Main.RBTreeOpts_closure;
      P64[Sp - 40] = _B7::P64;
      P64[Sp - 32] = _B6::P64;
      P64[Sp - 24] = _B5::P64;
      P64[Sp - 16] = _B4::P64;
      P64[Sp - 8] = _B3::P64;
      Sp = Sp - 40;
      call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
  cleR:
      I64[Hp - 56] = Main.RBTreeOpts_con_info;
      P64[Hp - 48] = _B7::P64;
      P64[Hp - 40] = _B6::P64;
      P64[Hp - 32] = _B5::P64;
      P64[Hp - 24] = _B4::P64;
      P64[Hp - 16] = _B3::P64;
      P64[Hp - 8] = _B2::P64;
      P64[Hp] = _B1::P64;
      _cleN::P64 = Hp - 55;
      R1 = _cleN::P64;
      Sp = Sp + 16;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:55.916333 UTC

{offset
  cleO:
      goto cleQ;
  cleQ:
      Hp = Hp + 64;
      if (Hp > HpLim) goto cleS; else goto cleR;
  cleS:
      HpAlloc = 64;
      goto cleP;
  cleP:
      R1 = Main.RBTreeOpts_closure;
      P64[Sp - 40] = R2;
      P64[Sp - 32] = R3;
      P64[Sp - 24] = R4;
      P64[Sp - 16] = R5;
      P64[Sp - 8] = R6;
      Sp = Sp - 40;
      call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
  cleR:
      I64[Hp - 56] = Main.RBTreeOpts_con_info;
      P64[Hp - 48] = R2;
      P64[Hp - 40] = R3;
      P64[Hp - 32] = R4;
      P64[Hp - 24] = R5;
      P64[Hp - 16] = R6;
      P64[Hp - 8] = P64[Sp];
      P64[Hp] = P64[Sp + 8];
      R1 = Hp - 55;
      Sp = Sp + 16;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:55.91821 UTC

[(cleO, {}), (cleP, {}), (cleQ, {}), (cleR, {}), (cleS, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:55.918554 UTC

Main.RBTreeOpts_entry() //  [R6, R5, R4, R3, R2]
        { info_tbl: [(cleO,
                      label: Main.RBTreeOpts_info
                      rep:HeapRep static {
                            Fun {arity: 7
                                 fun_type: ArgGen [False, False, False, False, False, False,
                                                   False]} })]
          stack_info: arg_space: 24 updfr_space: Just 8
        }
    {offset
      cleO:
          goto cleQ;
      cleQ:
          Hp = Hp + 64;
          if (Hp > HpLim) goto cleS; else goto cleR;
      cleS:
          HpAlloc = 64;
          goto cleP;
      cleP:
          R1 = Main.RBTreeOpts_closure;
          P64[Sp - 40] = R2;
          P64[Sp - 32] = R3;
          P64[Sp - 24] = R4;
          P64[Sp - 16] = R5;
          P64[Sp - 8] = R6;
          Sp = Sp - 40;
          call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
      cleR:
          I64[Hp - 56] = Main.RBTreeOpts_con_info;
          P64[Hp - 48] = R2;
          P64[Hp - 40] = R3;
          P64[Hp - 32] = R4;
          P64[Hp - 24] = R5;
          P64[Hp - 16] = R6;
          P64[Hp - 8] = P64[Sp];
          P64[Hp] = P64[Sp + 8];
          R1 = Hp - 55;
          Sp = Sp + 16;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:55.920436 UTC

Main.RBTreeOpts_entry() //  [R6, R5, R4, R3, R2]
        { info_tbl: [(cleO,
                      label: Main.RBTreeOpts_info
                      rep:HeapRep static {
                            Fun {arity: 7
                                 fun_type: ArgGen [False, False, False, False, False, False,
                                                   False]} })]
          stack_info: arg_space: 24 updfr_space: Just 8
        }
    {offset
      cleO:
          Hp = Hp + 64;
          if (Hp > HpLim) goto cleS; else goto cleR;
      cleS:
          HpAlloc = 64;
          R1 = Main.RBTreeOpts_closure;
          P64[Sp - 40] = R2;
          P64[Sp - 32] = R3;
          P64[Sp - 24] = R4;
          P64[Sp - 16] = R5;
          P64[Sp - 8] = R6;
          Sp = Sp - 40;
          call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
      cleR:
          I64[Hp - 56] = Main.RBTreeOpts_con_info;
          P64[Hp - 48] = R2;
          P64[Hp - 40] = R3;
          P64[Hp - 32] = R4;
          P64[Hp - 24] = R5;
          P64[Hp - 16] = R6;
          P64[Hp - 8] = P64[Sp];
          P64[Hp] = P64[Sp + 8];
          R1 = Hp - 55;
          Sp = Sp + 16;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:55.922162 UTC

[section "data" {
     Main.RBTreeOpts_closure:
         const Main.RBTreeOpts_info;
 },
 Main.RBTreeOpts_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 64 updfr_space: Just 8
         }
     {offset
       cleJ:
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Main.RBTreeOpts_info(R6,
                                     R5,
                                     R4,
                                     R3,
                                     R2,
                                     R1) args: 24, res: 0, upd: 8;
     }
 },
 Main.RBTreeOpts_entry() //  [R6, R5, R4, R3, R2]
         { info_tbl: [(cleO,
                       label: Main.RBTreeOpts_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 24 updfr_space: Just 8
         }
     {offset
       cleO:
           Hp = Hp + 64;
           if (Hp > HpLim) goto cleS; else goto cleR;
       cleS:
           HpAlloc = 64;
           R1 = Main.RBTreeOpts_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       cleR:
           I64[Hp - 56] = Main.RBTreeOpts_con_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           P64[Hp - 16] = R6;
           P64[Hp - 8] = P64[Sp];
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 55;
           Sp = Sp + 16;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:55.924841 UTC

[section "data" {
     Main.RBTreeOpts_closure:
         const Main.RBTreeOpts_info;
 },
 Main.RBTreeOpts_slow() //  [R1]
         { info_tbl: []
           stack_info: arg_space: 64 updfr_space: Just 8
         }
     {offset
       cleJ:
           R6 = P64[Sp + 32];
           R5 = P64[Sp + 24];
           R4 = P64[Sp + 16];
           R3 = P64[Sp + 8];
           R2 = P64[Sp];
           R1 = R1;
           Sp = Sp + 40;
           call Main.RBTreeOpts_info(R6,
                                     R5,
                                     R4,
                                     R3,
                                     R2,
                                     R1) args: 24, res: 0, upd: 8;
     }
 },
 Main.RBTreeOpts_entry() //  [R6, R5, R4, R3, R2]
         { info_tbl: [(cleO,
                       label: Main.RBTreeOpts_info
                       rep:HeapRep static {
                             Fun {arity: 7
                                  fun_type: ArgGen [False, False, False, False, False, False,
                                                    False]} })]
           stack_info: arg_space: 24 updfr_space: Just 8
         }
     {offset
       cleO:
           Hp = Hp + 64;
           if (Hp > HpLim) goto cleS; else goto cleR;
       cleS:
           HpAlloc = 64;
           R1 = Main.RBTreeOpts_closure;
           P64[Sp - 40] = R2;
           P64[Sp - 32] = R3;
           P64[Sp - 24] = R4;
           P64[Sp - 16] = R5;
           P64[Sp - 8] = R6;
           Sp = Sp - 40;
           call (stg_gc_fun)(R1) args: 64, res: 0, upd: 8;
       cleR:
           I64[Hp - 56] = Main.RBTreeOpts_con_info;
           P64[Hp - 48] = R2;
           P64[Hp - 40] = R3;
           P64[Hp - 32] = R4;
           P64[Hp - 24] = R5;
           P64[Hp - 16] = R6;
           P64[Hp - 8] = P64[Sp];
           P64[Hp] = P64[Sp + 8];
           R1 = Hp - 55;
           Sp = Sp + 16;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Cmm produced by new codegen ====================
2015-11-09 18:21:55.931245 UTC

[Main.RBTreeOpts_con_entry() //  []
         { info_tbl: [(clf1,
                       label: Main.RBTreeOpts_con_info
                       rep:HeapRep 7 ptrs {
                             Con {tag: 0
                                  descr:[109,97,105,110,58,77,97,105,110,46,82,66,84,114,101,101,79,112,116,115]} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       clf1:
           R1 = R1 + 1;
           call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Main.RBTreeOpts_static_entry() //  []
         { info_tbl: [(clf2,
                       label: Main.RBTreeOpts_static_info
                       rep:HeapRep static {
                             Con {tag: 0
                                  descr:[109,97,105,110,58,77,97,105,110,46,82,66,84,114,101,101,79,112,116,115]} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       clf2:
           R1 = R1 + 1;
           call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Post control-flow optimisations ====================
2015-11-09 18:21:55.932656 UTC

{offset
  clf1:
      R1 = R1 + 1;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:55.93303 UTC

{offset
  clf1:
      R1 = R1 + 1;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:55.933391 UTC

{offset
  clf1:
      R1 = R1 + 1;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:55.933748 UTC

{offset
  clf1:
      R1 = R1 + 1;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:55.93408 UTC

{offset
  clf1:
      R1 = R1 + 1;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:55.934408 UTC

[(clf1, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:55.934634 UTC

Main.RBTreeOpts_con_entry() //  []
        { info_tbl: [(clf1,
                      label: Main.RBTreeOpts_con_info
                      rep:HeapRep 7 ptrs {
                            Con {tag: 0
                                 descr:[109,97,105,110,58,77,97,105,110,46,82,66,84,114,101,101,79,112,116,115]} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      clf1:
          R1 = R1 + 1;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:55.935247 UTC

Main.RBTreeOpts_con_entry() //  []
        { info_tbl: [(clf1,
                      label: Main.RBTreeOpts_con_info
                      rep:HeapRep 7 ptrs {
                            Con {tag: 0
                                 descr:[109,97,105,110,58,77,97,105,110,46,82,66,84,114,101,101,79,112,116,115]} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      clf1:
          R1 = R1 + 1;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:55.935864 UTC

{offset
  clf2:
      R1 = R1 + 1;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post common block elimination ====================
2015-11-09 18:21:55.936218 UTC

{offset
  clf2:
      R1 = R1 + 1;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Post switch plan ====================
2015-11-09 18:21:55.936568 UTC

{offset
  clf2:
      R1 = R1 + 1;
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;
}


==================== Layout Stack ====================
2015-11-09 18:21:55.936915 UTC

{offset
  clf2:
      R1 = R1 + 1;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== Sink assignments ====================
2015-11-09 18:21:55.937261 UTC

{offset
  clf2:
      R1 = R1 + 1;
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
}


==================== CAFEnv ====================
2015-11-09 18:21:55.93808 UTC

[(clf2, {})]


==================== after setInfoTableStackMap ====================
2015-11-09 18:21:55.938298 UTC

Main.RBTreeOpts_static_entry() //  []
        { info_tbl: [(clf2,
                      label: Main.RBTreeOpts_static_info
                      rep:HeapRep static {
                            Con {tag: 0
                                 descr:[109,97,105,110,58,77,97,105,110,46,82,66,84,114,101,101,79,112,116,115]} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      clf2:
          R1 = R1 + 1;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post control-flow optimisations ====================
2015-11-09 18:21:55.938899 UTC

Main.RBTreeOpts_static_entry() //  []
        { info_tbl: [(clf2,
                      label: Main.RBTreeOpts_static_info
                      rep:HeapRep static {
                            Con {tag: 0
                                 descr:[109,97,105,110,58,77,97,105,110,46,82,66,84,114,101,101,79,112,116,115]} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      clf2:
          R1 = R1 + 1;
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
    }
}


==================== Post CPS Cmm ====================
2015-11-09 18:21:55.939598 UTC

[Main.RBTreeOpts_con_entry() //  []
         { info_tbl: [(clf1,
                       label: Main.RBTreeOpts_con_info
                       rep:HeapRep 7 ptrs {
                             Con {tag: 0
                                  descr:[109,97,105,110,58,77,97,105,110,46,82,66,84,114,101,101,79,112,116,115]} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       clf1:
           R1 = R1 + 1;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Main.RBTreeOpts_static_entry() //  []
         { info_tbl: [(clf2,
                       label: Main.RBTreeOpts_static_info
                       rep:HeapRep static {
                             Con {tag: 0
                                  descr:[109,97,105,110,58,77,97,105,110,46,82,66,84,114,101,101,79,112,116,115]} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       clf2:
           R1 = R1 + 1;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:55.940772 UTC

[Main.RBTreeOpts_con_entry() //  []
         { info_tbl: [(clf1,
                       label: Main.RBTreeOpts_con_info
                       rep:HeapRep 7 ptrs {
                             Con {tag: 0
                                  descr:[109,97,105,110,58,77,97,105,110,46,82,66,84,114,101,101,79,112,116,115]} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       clf1:
           R1 = R1 + 1;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 },
 Main.RBTreeOpts_static_entry() //  []
         { info_tbl: [(clf2,
                       label: Main.RBTreeOpts_static_info
                       rep:HeapRep static {
                             Con {tag: 0
                                  descr:[109,97,105,110,58,77,97,105,110,46,82,66,84,114,101,101,79,112,116,115]} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       clf2:
           R1 = R1 + 1;
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;
     }
 }]


==================== Output Cmm ====================
2015-11-09 18:21:55.943808 UTC

[section "relreadonly" {
     Sk8q_srt:
         const Main.rbTreeOpts51_closure;
         const Options.Applicative.Help.Chunk.paragraph1_closure;
         const Main.rbTreeOpts62_closure;
         const System.Random.PCG.Fast.Pure.$wbounded_closure;
         const Main.$wa2_closure;
         const Main.samples1_closure;
         const SkipList.$wa3_closure;
         const Main.runRSTMSingle'1_closure;
         const Main.rbTreeOpts8_closure;
         const GHC.Read.$fReadInt_closure;
         const Options.Applicative.Builder.auto1_closure;
         const Main.rbTreeOpts11_closure;
         const Main.rbTreeOpts23_closure;
         const GHC.Read.$fReadDouble_closure;
         const Main.rbTreeOpts26_closure;
         const Main.rbTreeOpts38_closure;
         const Main.rbTreeOpts75_closure;
         const Main.rbTreeOpts88_closure;
         const GHC.Read.$fReadWord_closure;
         const Main.rbTreeOpts91_closure;
         const Main.rbTreeOpts81_closure;
         const Control.Monad.Primitive.$fPrimMonadIO_closure;
         const Main.initGens2_closure;
         const Main.initGens1_closure;
         const Main.initGens_closure;
         const SkipList.newSL2_closure;
         const Main.mkRBTree_closure;
         const GHC.Word.$fEnumWord12_closure;
         const Main.$wa_closure;
         const Main.runRSTMEmpty1_closure;
         const Main.runRSTMEmpty_closure;
         const SkipList.$wa2_closure;
         const SkipList.$wa4_closure;
         const GHC.Real.$fIntegralWord_closure;
         const GHC.Float.$w$cproperFraction_closure;
         const Main.$wa1_closure;
         const Main.runRSTMSingle1_closure;
         const Main.runRSTMSingle_closure;
         const Main.runRSTMSingle'_closure;
         const Main.samples_closure;
         const Main.samples1_closure;
         const lvl21_rjVq_closure;
         const Options.Applicative.Help.Chunk.paragraph1_closure;
         const Main.rbTreeOpts94_closure;
         const Main.rbTreeOpts79_closure;
         const lvl18_rjVl_closure;
         const GHC.Integer.Type.wordToInteger_closure;
         const GHC.Show.$w$cshowsPrec1_closure;
         const lvl17_rjVj_closure;
         const GHC.Float.$fShowDouble_$sshowFloat_closure;
         const lvl16_rjVi_closure;
         const lvl15_rjVh_closure;
         const lvl13_rjVf_closure;
         const GHC.IO.Handle.Text.hPutStr2_closure;
         const GHC.Enum.$w$cenumFromThenTo_closure;
         const GHC.IO.Handle.FD.stdout_closure;
         const Throughput.throughputMain1_closure;
         const Options.Applicative.Extra.execParserPure_closure;
         const System.Environment.getArgs1_closure;
         const Options.Applicative.Extra.customExecParser2_closure;
         const lvl20_rjVp_closure;
         const lvl22_rjVr_closure;
         const Main.main1_closure;
         const System.Environment.getProgName1_closure;
         const Main.main_closure;
         const GHC.TopHandler.runMainIO1_closure;
         const Main.main2_closure;
         const lvl1_rjUY_closure;
         const lvl2_rjUZ_closure;
         const lvl3_rjV0_closure;
         const lvl5_rjV2_closure;
         const lvl6_rjV3_closure;
         const GHC.Show.shows16_closure;
         const GHC.Show.shows17_closure;
         const lvl7_rjV4_closure;
         const lvl8_rjV5_closure;
         const lvl9_rjV6_closure;
         const lvl10_rjV7_closure;
         const lvl11_rjV8_closure;
         const Main.$w$cshowsPrec_closure;
         const Main.$fShowRBTreeOpts_$cshowsPrec_closure;
         const Main.$fShowRBTreeOpts_$cshow_closure;
         const Main.$fShowRBTreeOpts1_closure;
         const Main.$fShowRBTreeOpts_$cshowList_closure;
         const :Main.main_closure;
 }]

